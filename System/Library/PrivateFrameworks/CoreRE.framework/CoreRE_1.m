uint64_t re::ConstructMatrix3x3FromVector3sCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  void *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  void *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  __n128 *v19;
  void *v20;
  __n128 *v21;
  __n128 *v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (!a3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(void *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (void *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v27);
    v27 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_17;
  }
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (void *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v27);
    v27 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  if (a3 <= 2) {
    goto LABEL_18;
  }
  v18 = v17->n128_u64[0];
  v19 = a2[2];
  if (v19[6].n128_u8[0] == 1)
  {
    v20 = (void *)v19[1].n128_u64[0];
    v21 = v19 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v20 + 243), (uint64_t)&v27);
    v27 = v20[245] - 1;
    re::DynamicArray<unsigned long>::add(v20 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v20 + 76), v21);
    v22 = (__n128 *)(v20[40] + 8 * v20[38] - 8);
  }
  else
  {
    v22 = v19 + 11;
  }
  v23 = v22->n128_u64[0];
  LODWORD(v27) = 38;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1784), (uint64_t)&v27);
  v24 = *(void *)(v8 + 1800) - 1;
  v25 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v8 + 1664, v24);
  v25[1] = v13;
  v25[2] = v18;
  v25[3] = v23;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v24;
  return 1;
}

uint64_t re::ExtractTranslationMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 4;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    uint64_t v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 37;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1944), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1960) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::ExtractScaleMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v13[0]) = 4;
    memset(&v13[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)v13);
    v13[0] = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, v13);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  unint64_t Scale = re::EvaluationTree::extractScale(v6, *v10);
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = Scale;
  return 1;
}

uint64_t re::ExtractRotationMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v13[0]) = 4;
    memset(&v13[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)v13);
    v13[0] = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, v13);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  unint64_t Rotation = re::EvaluationTree::extractRotation(v6, *v10);
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = Rotation;
  return 1;
}

uint64_t re::ExtractRotationMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 3;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    uint64_t v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 35;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1880) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::ExtractMinorMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 4;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    uint64_t v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 34;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1800) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::TransposeMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 3;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    uint64_t v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 33;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1800) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::PassthroughRigHierarchyCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    if (a3)
    {
      uint64_t v5 = *(long long **)(*(void *)a2 + 184);
      uint64_t v6 = *(void *)(*(void *)a4 + 184);
      long long v7 = *v5;
      *(void *)(v6 + 16) = *((void *)v5 + 2);
      *(_OWORD *)uint64_t v6 = v7;
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 24, (uint64_t)v5 + 24);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 72, (uint64_t)v5 + 72);
      re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v6 + 120, (uint64_t *)v5 + 15);
      re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v6 + 160, (uint64_t *)v5 + 20);
      re::DynamicArray<re::StringID>::operator=(v6 + 200, (uint64_t *)v5 + 25);
      re::DynamicArray<unsigned long>::operator=(v6 + 240, (uint64_t *)v5 + 30);
      re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v6 + 280, (uint64_t *)v5 + 35);
      re::DynamicArray<unsigned long>::operator=(v6 + 320, (uint64_t *)v5 + 40);
      return 1;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::GetBindPoseRigHierarchyCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  if (!a3)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  re::RigHierarchy::getBindPoseHierarchy(*(re::RigHierarchy **)(*(void *)a2 + 184), a2, (uint64_t)&v9);
  uint64_t v6 = *(void *)(v5 + 184);
  long long v7 = v9;
  *(void *)(v6 + 16) = v10;
  *(_OWORD *)uint64_t v6 = v7;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 24, (uint64_t)v11);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 72, (uint64_t)v12);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v6 + 120, v13);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v6 + 160, v14);
  re::DynamicArray<re::StringID>::operator=(v6 + 200, v15);
  re::DynamicArray<unsigned long>::operator=(v6 + 240, v16);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v6 + 280, v19);
  re::DynamicArray<unsigned long>::operator=(v6 + 320, v22);
  if (v22[0])
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v22[0] + 40))();
    }
    uint64_t v24 = 0;
    memset(v22, 0, sizeof(v22));
    ++v23;
  }
  if (v19[0])
  {
    if (v21) {
      (*(void (**)(void))(*(void *)v19[0] + 40))();
    }
    uint64_t v21 = 0;
    memset(v19, 0, sizeof(v19));
    ++v20;
  }
  if (v16[0])
  {
    if (v18) {
      (*(void (**)(void))(*(void *)v16[0] + 40))();
    }
    uint64_t v18 = 0;
    memset(v16, 0, sizeof(v16));
    ++v17;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v14);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v13);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v12);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v11);
  return 1;
}

uint64_t re::AddVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  long long v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    uint64_t v11 = v9 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    uint64_t v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    unint64_t v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    uint64_t v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    int v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    int v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 8;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1960) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::AddVector2Compile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  long long v9 = (void *)*a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = (void *)v9[2];
    uint64_t v11 = v9 + 14;
    LODWORD(v22) = 6;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 238), (uint64_t)&v22);
    uint64_t v22 = v10[240] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v10 + 71, v11);
    unint64_t v12 = (uint64_t *)(v10[35] + 8 * v10[33] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 22;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (void *)(v14 + 112);
    LODWORD(v22) = 6;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 238), (uint64_t)&v22);
    uint64_t v22 = v15[240] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v15 + 71, v16);
    int v17 = (uint64_t *)(v15[35] + 8 * v15[33] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 9;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1904), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1920) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector2<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::AddFloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    int v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 49;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1760) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    uint64_t v11 = v9 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    uint64_t v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    unint64_t v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    uint64_t v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    int v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    int v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 31;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1960) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractVector2Compile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = (void *)*a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = (void *)v9[2];
    uint64_t v11 = v9 + 14;
    LODWORD(v22) = 6;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 238), (uint64_t)&v22);
    uint64_t v22 = v10[240] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v10 + 71, v11);
    unint64_t v12 = (uint64_t *)(v10[35] + 8 * v10[33] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 22;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (void *)(v14 + 112);
    LODWORD(v22) = 6;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 238), (uint64_t)&v22);
    uint64_t v22 = v15[240] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v15 + 71, v16);
    int v17 = (uint64_t *)(v15[35] + 8 * v15[33] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 32;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1904), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1920) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector2<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractFloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    int v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 50;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1760) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::DivideQuaternionCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    uint64_t v11 = v9 + 7;
    LODWORD(v22) = 5;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    uint64_t v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    unint64_t v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 5;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v22);
    uint64_t v22 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    int v17 = (__n128 *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    int v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 16;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1864), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1880) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::DivideFloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    int v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 52;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1760) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyFloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    int v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    int v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 51;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1760) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ConjugateQuaternionCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(__n128 **)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = (void *)v7[1].n128_u64[0];
    uint64_t v9 = v7 + 7;
    LODWORD(v14) = 5;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 233), (uint64_t)&v14);
    uint64_t v14 = v8[235] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 26, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 66), v9);
    uint64_t v10 = (__n128 *)(v8[30] + 8 * v8[28] - 8);
  }
  else
  {
    uint64_t v10 = v7 + 11;
  }
  unint64_t v11 = v10->n128_u64[0];
  LODWORD(v14) = 18;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1880) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertQuaternionCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(__n128 **)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = (void *)v7[1].n128_u64[0];
    uint64_t v9 = v7 + 7;
    LODWORD(v14) = 5;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 233), (uint64_t)&v14);
    uint64_t v14 = v8[235] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 26, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 66), v9);
    uint64_t v10 = (__n128 *)(v8[30] + 8 * v8[28] - 8);
  }
  else
  {
    uint64_t v10 = v7 + 11;
  }
  unint64_t v11 = v10->n128_u64[0];
  LODWORD(v14) = 21;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1880) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 3;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    uint64_t v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    uint64_t v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 19;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1800) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    uint64_t v9 = v7 + 112;
    LODWORD(v14) = 4;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    uint64_t v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    uint64_t v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 20;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1824), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1840) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::NormalizeVector3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(__n128 **)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = (void *)v7[1].n128_u64[0];
    uint64_t v9 = v7 + 7;
    LODWORD(v14) = 7;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 243), (uint64_t)&v14);
    uint64_t v14 = v8[245] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 36, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 76), v9);
    uint64_t v10 = (__n128 *)(v8[40] + 8 * v8[38] - 8);
  }
  else
  {
    uint64_t v10 = v7 + 11;
  }
  unint64_t v11 = v10->n128_u64[0];
  LODWORD(v14) = 29;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1944), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1960) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::RotateVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    unint64_t v11 = v9 + 7;
    LODWORD(v22) = 5;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    uint64_t v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    unint64_t v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    uint64_t v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 30;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1960) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyQuaternionCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    unint64_t v11 = v9 + 7;
    LODWORD(v22) = 5;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    uint64_t v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    unint64_t v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 5;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v22);
    uint64_t v22 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    uint64_t v17 = (__n128 *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    uint64_t v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 24;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1864), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1880) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyMatrix3x3Compile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = v9 + 112;
    LODWORD(v22) = 3;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 223), (uint64_t)&v22);
    uint64_t v22 = v10[225] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v10 + 56), v11);
    unint64_t v12 = (uint64_t *)(v10[20] + 8 * v10[18] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = v14 + 112;
    LODWORD(v22) = 3;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 223), (uint64_t)&v22);
    uint64_t v22 = v15[225] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v15 + 56), v16);
    uint64_t v17 = (uint64_t *)(v15[20] + 8 * v15[18] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 27;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1784), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1800) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyMatrix4x4Compile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = v9 + 112;
    LODWORD(v22) = 4;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 228), (uint64_t)&v22);
    uint64_t v22 = v10[230] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v10 + 61), v11);
    unint64_t v12 = (uint64_t *)(v10[25] + 8 * v10[23] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = v14 + 112;
    LODWORD(v22) = 4;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)&v22);
    uint64_t v22 = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    uint64_t v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 28;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1824), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1840) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    uint64_t v11 = v9 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    uint64_t v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    unint64_t v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    uint64_t v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 25;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1960) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ScaleVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    uint64_t v10 = (void *)v9[1].n128_u64[0];
    uint64_t v11 = v9 + 7;
    LODWORD(v22) = 7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    uint64_t v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    unint64_t v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    unint64_t v12 = v9 + 11;
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  unint64_t v13 = v12->n128_u64[0];
  uint64_t v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = (float *)&v14[7];
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (__n128 *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = v14 + 11;
  }
  unint64_t v18 = v17->n128_u64[0];
  LODWORD(v22) = 26;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1960) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ClampCompile(re::Allocator **a1, const re::RigDataValue **a2, unint64_t a3, re::RigDataValue **a4, uint64_t a5)
{
  uint64_t v20 = 0;
  memset(v16, 0, sizeof(v16));
  int v17 = 0;
  memset(v18, 0, sizeof(v18));
  int v19 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v16, *a1);
  *(void *)&v15.var0 = 223945442;
  v15.var1 = "value";
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a2);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 216228;
  v15.var1 = "min";
  if (a3 == 1)
  {
LABEL_7:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[1]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 215752;
  v15.var1 = "max";
  if (a3 <= 2)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[2]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 0x188223202;
  v15.var1 = "output";
  if (a5)
  {
    re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a4);
    re::StringID::destroyString((re::StringID *)&v15);
    re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v16, (uint64_t)a1, (uint64_t)re::ClampCompile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke, 0);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v18 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v16 + 8);
    return 1;
  }
LABEL_9:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(void *)&v15.var0, v15.var1);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ClampVector3Compile(re::Allocator **a1, const re::RigDataValue **a2, unint64_t a3, re::RigDataValue **a4, uint64_t a5)
{
  uint64_t v20 = 0;
  memset(v16, 0, sizeof(v16));
  int v17 = 0;
  memset(v18, 0, sizeof(v18));
  int v19 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v16, *a1);
  *(void *)&v15.var0 = 223945442;
  v15.var1 = "value";
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a2);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 216228;
  v15.var1 = "min";
  if (a3 == 1)
  {
LABEL_7:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[1]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 215752;
  v15.var1 = "max";
  if (a3 <= 2)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(void *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[2]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(void *)&v15.var0 = 0x188223202;
  v15.var1 = "output";
  if (a5)
  {
    re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a4);
    re::StringID::destroyString((re::StringID *)&v15);
    re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v16, (uint64_t)a1, (uint64_t)re::ClampVector3Compile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke, 0);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v18 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v16 + 8);
    return 1;
  }
LABEL_9:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(void *)&v15.var0, v15.var1);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AdditiveBlendSRTCompile(uint64_t a1, const re::RigDataValue **a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  uint64_t v9 = *(void **)(a1 + 8);
  if (a3 == 1)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::EvaluationTree::additiveBlend(v9, &v22, (uint64_t *)&v26, v28);
  if (!a5)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v12 = *a4;
  v26 = "scale";
  uint64_t v27 = 5;
  re::RigDataValue::attributeValue(v12, (uint64_t)&v26, (uint64_t)&v22);
  uint64_t v13 = v23;
  unint64_t v14 = v28[0];
  *(unsigned char *)(v23 + 96) = 2;
  *(void *)(v13 + 176) = v14;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0) {
    (*(void (**)(void))(*(void *)v24 + 40))();
  }
  uint64_t v15 = *a4;
  v26 = "rotation";
  uint64_t v27 = 8;
  re::RigDataValue::attributeValue(v15, (uint64_t)&v26, (uint64_t)&v22);
  uint64_t v16 = v23;
  unint64_t v17 = v28[1];
  *(unsigned char *)(v23 + 96) = 2;
  *(void *)(v16 + 176) = v17;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0) {
    (*(void (**)(void))(*(void *)v24 + 40))();
  }
  uint64_t v18 = *a4;
  v26 = "translation";
  uint64_t v27 = 11;
  re::RigDataValue::attributeValue(v18, (uint64_t)&v26, (uint64_t)&v22);
  uint64_t v19 = v23;
  unint64_t v20 = v28[2];
  *(unsigned char *)(v23 + 96) = 2;
  *(void *)(v19 + 176) = v20;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0) {
    (*(void (**)(void))(*(void *)v24 + 40))();
  }
  return 1;
}

uint64_t re::LocalSpaceJointScaleCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointScale(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointRotationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointRotation(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointTranslationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointTranslation(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointTransformCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointTransform(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointScaleCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointScale(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointRotationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointRotation(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointTranslationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointTranslation(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointTransformCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointTransform(v7, (uint64_t)v14, (uint64_t)v15);
    int v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
      return v10 != 0;
    }
    if (a5)
    {
      uint64_t v11 = *a4;
      uint64_t v12 = v16;
      *(unsigned char *)(v11 + 96) = 2;
      *(void *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SetLocalSpaceJointScaleCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointScale(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::SetLocalSpaceJointRotationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v23[0]) = 5;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)v23);
    v23[0] = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    uint64_t v17 = (uint64_t *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointRotation(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::SetLocalSpaceJointTranslationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointTranslation(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::SetLocalSpaceJointTransformCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(void *)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = a2[2];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = v14 + 112;
    LODWORD(v23[0]) = 4;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)v23);
    v23[0] = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, v23);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    uint64_t v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  re::RigHierarchy::setLocalSpaceJointTransform(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::SetModelSpaceJointScaleCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointScale(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::SetModelSpaceJointRotationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (!a5)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(uint64_t **)(*(void *)a4 + 184);
  v21[0] = *(const char **)(v8 + 232);
  v21[1] = (const char *)strlen(v21[0]);
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v25[0]) = 5;
    memset(&v25[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)v25);
    v25[0] = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    uint64_t v17 = (uint64_t *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointRotation((_anonymous_namespace_ *)v12, (uint64_t)v21, *v17, (uint64_t)v22);
  if (!v22[0] && (void)v23)
  {
    if (BYTE8(v23)) {
      (*(void (**)(void))(*(void *)v23 + 40))();
    }
    long long v23 = 0u;
    long long v24 = 0u;
  }
  uint64_t v18 = *(void *)(*(void *)a4 + 184);
  long long v19 = *(_OWORD *)v12;
  *(void *)(v18 + 16) = v12[2];
  *(_OWORD *)uint64_t v18 = v19;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 24, (uint64_t)(v12 + 3));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 72, (uint64_t)(v12 + 9));
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v18 + 120, v12 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v18 + 160, v12 + 20);
  re::DynamicArray<re::StringID>::operator=(v18 + 200, v12 + 25);
  re::DynamicArray<unsigned long>::operator=(v18 + 240, v12 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v18 + 280, v12 + 35);
  re::DynamicArray<unsigned long>::operator=(v18 + 320, v12 + 40);
  return 1;
}

uint64_t re::SetModelSpaceJointTranslationCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (!a5)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(uint64_t **)(*(void *)a4 + 184);
  v21[0] = *(const char **)(v8 + 232);
  v21[1] = (const char *)strlen(v21[0]);
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    uint64_t v15 = (void *)v14[1].n128_u64[0];
    uint64_t v16 = v14 + 7;
    LODWORD(v25[0]) = 7;
    memset(&v25[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v25);
    v25[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    uint64_t v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointTranslation((_anonymous_namespace_ *)v12, (uint64_t)v21, *v17, (uint64_t)v22);
  if (!v22[0] && (void)v23)
  {
    if (BYTE8(v23)) {
      (*(void (**)(void))(*(void *)v23 + 40))();
    }
    long long v23 = 0u;
    long long v24 = 0u;
  }
  uint64_t v18 = *(void *)(*(void *)a4 + 184);
  long long v19 = *(_OWORD *)v12;
  *(void *)(v18 + 16) = v12[2];
  *(_OWORD *)uint64_t v18 = v19;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 24, (uint64_t)(v12 + 3));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 72, (uint64_t)(v12 + 9));
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v18 + 120, v12 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v18 + 160, v12 + 20);
  re::DynamicArray<re::StringID>::operator=(v18 + 200, v12 + 25);
  re::DynamicArray<unsigned long>::operator=(v18 + 240, v12 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v18 + 280, v12 + 35);
  re::DynamicArray<unsigned long>::operator=(v18 + 320, v12 + 40);
  return 1;
}

uint64_t re::SetModelSpaceJointTransformCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  uint64_t v12 = *(void *)(*(void *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = a2[2];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = v14 + 112;
    LODWORD(v23[0]) = 4;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)v23);
    v23[0] = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, v23);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    uint64_t v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  re::RigHierarchy::setModelSpaceJointTransform(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  return 1;
}

uint64_t re::JointParentCompile(uint64_t a1, void *a2, unint64_t a3, re::Allocator ***a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    uint64_t v8 = *(const char **)(a2[1] + 232);
    uint64_t v15 = v8;
    uint64_t v16 = (const char *)strlen(v8);
    uint64_t v9 = (_anonymous_namespace_ *)re::RigHierarchy::jointParent(v7, (uint64_t)&v15, 1, (uint64_t)v17);
    int v11 = v17[0];
    if (!v17[0]) {
      goto LABEL_5;
    }
    if (a5)
    {
      uint64_t v12 = *a4;
      uint64_t v13 = *(const char **)(v18 + 8);
      uint64_t v15 = 0;
      uint64_t v16 = "";
      re::StringID::copy((re::StringID *)(v12 + 28), (const re::StringID *)&v15, *v12);
      re::StringID::destroyString((re::StringID *)&v15);
      if (v17[0]) {
        return v11 != 0;
      }
LABEL_5:
      if (v19)
      {
        if (v20) {
          (*(void (**)(void))(*(void *)v19 + 40))();
        }
      }
      return v11 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SetJointParentCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (!a5)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = *(long long **)(*a2 + 184);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  long long v11 = *v9;
  *(void *)(v10 + 16) = *((void *)v9 + 2);
  *(_OWORD *)uint64_t v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  if (a3 <= 2)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  size_t v13 = strlen(*(const char **)(a2[2] + 232));
  v21[0] = *(void *)(a2[2] + 232);
  v21[1] = v13;
  uint64_t v14 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  size_t v15 = strlen(*(const char **)(v8 + 232));
  v17[0] = *(void *)(v8 + 232);
  v17[1] = v15;
  re::RigHierarchy::setJointParent(v14, (uint64_t)v17, (uint64_t)v21, (uint64_t)v18);
  if (!v18[0] && v19 && (v20 & 1) != 0) {
    (*(void (**)(void))(*(void *)v19 + 40))();
  }
  return 1;
}

uint64_t re::AddJointCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = *(long long **)(*a2 + 184);
  uint64_t v8 = *(void *)(*(void *)a4 + 184);
  long long v9 = *v7;
  *(void *)(v8 + 16) = *((void *)v7 + 2);
  *(_OWORD *)uint64_t v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::addJoint(v10, v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

uint64_t re::RemoveJointCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = *(long long **)(*a2 + 184);
  uint64_t v8 = *(void *)(*(void *)a4 + 184);
  long long v9 = *v7;
  *(void *)(v8 + 16) = *((void *)v7 + 2);
  *(_OWORD *)uint64_t v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  uint64_t v10 = *(void *)(*(void *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::removeJoint(v10, (uint64_t)v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

uint64_t re::ClearJointParentCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = *(long long **)(*a2 + 184);
  uint64_t v8 = *(void *)(*(void *)a4 + 184);
  long long v9 = *v7;
  *(void *)(v8 + 16) = *((void *)v7 + 2);
  *(_OWORD *)uint64_t v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  uint64_t v10 = *(_anonymous_namespace_ **)(*(void *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::clearJointParent(v10, (uint64_t)v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

uint64_t re::SinFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 53;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::CosFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 54;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::TanFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 55;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AsinFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 56;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AcosFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 57;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AtanFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  if (*(unsigned char *)(*(void *)a2 + 96) == 1)
  {
    uint64_t v8 = *(void **)(v7 + 16);
    long long v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    uint64_t v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    uint64_t v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v7 + 176);
  }
  uint64_t v11 = *v10;
  LODWORD(v14) = 58;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  unint64_t v12 = *(void *)(v6 + 1760) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(unsigned char *)(v5 + 96) = 2;
  *(void *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::Atan2FloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 59;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1760) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::GreaterCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 61;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1720) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::GreaterEqualCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 62;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1720) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::LessCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 63;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1720) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::LessEqualCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    uint64_t v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    unint64_t v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    uint64_t v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  uint64_t v18 = *v17;
  LODWORD(v22) = 64;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  unint64_t v19 = *(void *)(v8 + 1720) - 1;
  uint64_t v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(void *)(v20 + 8) = v13;
  *(void *)(v20 + 16) = v18;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SelectFloatCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (!a3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *a2;
  if (*(unsigned char *)(*a2 + 96) == 1)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = (_DWORD *)(v9 + 112);
    LODWORD(v27) = 1;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 213), (uint64_t)&v27);
    uint64_t v27 = v10[215] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 6, &v27);
    re::DynamicArray<int>::add(v10 + 46, v11);
    unint64_t v12 = (uint64_t *)(v10[10] + 8 * v10[8] - 8);
  }
  else
  {
    unint64_t v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1) {
    goto LABEL_17;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = a2[1];
  if (*(unsigned char *)(v14 + 96) == 1)
  {
    uint64_t v15 = *(void **)(v14 + 16);
    uint64_t v16 = (float *)(v14 + 112);
    LODWORD(v27) = 2;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v27);
    uint64_t v27 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v27);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    uint64_t v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    uint64_t v17 = (uint64_t *)(v14 + 176);
  }
  if (a3 <= 2) {
    goto LABEL_18;
  }
  uint64_t v18 = *v17;
  uint64_t v19 = a2[2];
  if (*(unsigned char *)(v19 + 96) == 1)
  {
    uint64_t v20 = *(void **)(v19 + 16);
    uint64_t v21 = (float *)(v19 + 112);
    LODWORD(v27) = 2;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v20 + 218), (uint64_t)&v27);
    uint64_t v27 = v20[220] - 1;
    re::DynamicArray<unsigned long>::add(v20 + 11, &v27);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v20 + 51), v21);
    uint64_t v22 = (uint64_t *)(v20[15] + 8 * v20[13] - 8);
  }
  else
  {
    uint64_t v22 = (uint64_t *)(v19 + 176);
  }
  uint64_t v23 = *v22;
  LODWORD(v27) = 60;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v27);
  unint64_t v24 = *(void *)(v8 + 1760) - 1;
  uint64_t v25 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v24);
  v25[1] = v13;
  v25[2] = v18;
  v25[3] = v23;
  *(unsigned char *)(v7 + 96) = 2;
  *(void *)(v7 + 176) = v24;
  return 1;
}

uint64_t re::BlendRigHierarchyCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a3)
  {
LABEL_65:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_66;
  }
  if (a3 == 1)
  {
LABEL_66:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_67;
  }
  uint64_t v8 = *(re::RigHierarchy **)(*a2 + 184);
  uint64_t v9 = *(_anonymous_namespace_ **)(a2[1] + 184);
  re::RigHierarchy::getBindPoseHierarchy(v8, (uint64_t)a2, (uint64_t)&v74);
  if (*((void *)v8 + 27))
  {
    unint64_t v11 = 0;
    uint64_t v35 = a1;
    v36 = v9;
    while (1)
    {
      unint64_t v12 = re::RigHierarchy::jointName(v8, v11);
      size_t v13 = strlen(*(const char **)(v12 + 8));
      uint64_t v66 = *(void *)(v12 + 8);
      uint64_t v67 = v13;
      re::RigHierarchy::getLocalSpaceJointScale(v8, (uint64_t)&v66, (uint64_t)v70);
      size_t v14 = strlen(*(const char **)(v12 + 8));
      uint64_t v62 = *(void *)(v12 + 8);
      uint64_t v63 = v14;
      re::RigHierarchy::getLocalSpaceJointRotation(v8, (uint64_t)&v62, (uint64_t)&v66);
      size_t v15 = strlen(*(const char **)(v12 + 8));
      uint64_t v57 = *(void *)(v12 + 8);
      uint64_t v58 = v15;
      re::RigHierarchy::getLocalSpaceJointTranslation(v8, (uint64_t)&v57, (uint64_t)&v62);
      v61[0] = v71;
      v61[1] = v67;
      v61[2] = v63;
      size_t v16 = strlen(*(const char **)(v12 + 8));
      uint64_t v53 = *(void *)(v12 + 8);
      uint64_t v54 = v16;
      re::RigHierarchy::getLocalSpaceJointScale(v9, (uint64_t)&v53, (uint64_t)&v57);
      size_t v17 = strlen(*(const char **)(v12 + 8));
      uint64_t v49 = *(void *)(v12 + 8);
      uint64_t v50 = v17;
      re::RigHierarchy::getLocalSpaceJointRotation(v9, (uint64_t)&v49, (uint64_t)&v53);
      size_t v18 = strlen(*(const char **)(v12 + 8));
      uint64_t v90 = *(void *)(v12 + 8);
      size_t v91 = v18;
      re::RigHierarchy::getLocalSpaceJointTranslation(v9, (uint64_t)&v90, (uint64_t)&v49);
      v48[0] = v58;
      v48[1] = v54;
      v48[2] = v50;
      if (a3 <= 2) {
        break;
      }
      uint64_t v20 = *(void **)(a1 + 8);
      uint64_t v21 = a2[2];
      if (*(unsigned char *)(v21 + 96) == 1)
      {
        uint64_t v22 = *(void **)(v21 + 16);
        uint64_t v23 = (float *)(v21 + 112);
        LODWORD(v90) = 2;
        uint64_t v92 = 0;
        uint64_t v93 = 0;
        size_t v91 = 0;
        re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v22 + 218), (uint64_t)&v90);
        uint64_t v90 = v22[220] - 1;
        re::DynamicArray<unsigned long>::add(v22 + 11, &v90);
        re::DynamicArray<float>::add((_anonymous_namespace_ *)(v22 + 51), v23);
        uint64_t v24 = v22[15];
        uint64_t v25 = v22[13];
        a1 = v35;
        uint64_t v9 = v36;
        v26 = (uint64_t *)(v24 + 8 * v25 - 8);
      }
      else
      {
        v26 = (uint64_t *)(v21 + 176);
      }
      re::EvaluationTree::lerp(v20, v61, v48, *v26, (unint64_t *)&v90);
      size_t v27 = strlen(*(const char **)(v12 + 8));
      uint64_t v43 = *(void *)(v12 + 8);
      size_t v44 = v27;
      re::RigHierarchy::setLocalSpaceJointScale((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v90, (uint64_t)v45);
      if (!v45[0] && (void)v46)
      {
        if (BYTE8(v46)) {
          (*(void (**)(void))(*(void *)v46 + 40))();
        }
        long long v46 = 0u;
        long long v47 = 0u;
      }
      size_t v28 = strlen(*(const char **)(v12 + 8));
      uint64_t v43 = *(void *)(v12 + 8);
      size_t v44 = v28;
      re::RigHierarchy::setLocalSpaceJointRotation((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v91, (uint64_t)v40);
      if (!v40[0] && (void)v41)
      {
        if (BYTE8(v41)) {
          (*(void (**)(void))(*(void *)v41 + 40))();
        }
        long long v41 = 0u;
        long long v42 = 0u;
      }
      size_t v29 = strlen(*(const char **)(v12 + 8));
      uint64_t v43 = *(void *)(v12 + 8);
      size_t v44 = v29;
      re::RigHierarchy::setLocalSpaceJointTranslation((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v92, (uint64_t)v37);
      if (!v37[0] && (void)v38)
      {
        if (BYTE8(v38)) {
          (*(void (**)(void))(*(void *)v38 + 40))();
        }
        long long v38 = 0u;
        long long v39 = 0u;
      }
      if (!(_BYTE)v49 && v51 && (v52 & 1) != 0) {
        (*(void (**)(void))(*(void *)v51 + 40))();
      }
      if (!(_BYTE)v53 && v55 && (v56 & 1) != 0) {
        (*(void (**)(void))(*(void *)v55 + 40))();
      }
      if (!(_BYTE)v57 && v59 && (v60 & 1) != 0) {
        (*(void (**)(void))(*(void *)v59 + 40))();
      }
      if (!(_BYTE)v62 && v64 && (v65 & 1) != 0) {
        (*(void (**)(void))(*(void *)v64 + 40))();
      }
      if (!(_BYTE)v66 && v68 && (v69 & 1) != 0) {
        (*(void (**)(void))(*(void *)v68 + 40))();
      }
      if (!v70[0] && v72 && (v73 & 1) != 0) {
        (*(void (**)(void))(*(void *)v72 + 40))();
      }
      if (++v11 >= *((void *)v8 + 27)) {
        goto LABEL_50;
      }
    }
    re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_65;
  }
LABEL_50:
  if (!a5)
  {
LABEL_67:
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v30 = *(void *)(*(void *)a4 + 184);
  long long v31 = v74;
  *(void *)(v30 + 16) = v75;
  *(_OWORD *)uint64_t v30 = v31;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v30 + 24, (uint64_t)v76);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v30 + 72, (uint64_t)v77);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v30 + 120, v78);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v30 + 160, v79);
  re::DynamicArray<re::StringID>::operator=(v30 + 200, v80);
  re::DynamicArray<unsigned long>::operator=(v30 + 240, v81);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v30 + 280, v84);
  re::DynamicArray<unsigned long>::operator=(v30 + 320, v87);
  if (v87[0])
  {
    if (v89) {
      (*(void (**)(void))(*(void *)v87[0] + 40))();
    }
    uint64_t v89 = 0;
    memset(v87, 0, sizeof(v87));
    ++v88;
  }
  if (v84[0])
  {
    if (v86) {
      (*(void (**)(void))(*(void *)v84[0] + 40))();
    }
    uint64_t v86 = 0;
    memset(v84, 0, sizeof(v84));
    ++v85;
  }
  if (v81[0])
  {
    if (v83) {
      (*(void (**)(void))(*(void *)v81[0] + 40))();
    }
    uint64_t v83 = 0;
    memset(v81, 0, sizeof(v81));
    ++v82;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v80);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v79);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v78);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v77);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v76);
  return 1;
}

uint64_t re::BlendAdditiveRigHierarchyCompile(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_61;
  }
  if (a3 == 1)
  {
LABEL_61:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_62:
    re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v7 = *(re::RigHierarchy **)(*a2 + 184);
  uint64_t v8 = *(_anonymous_namespace_ **)(a2[1] + 184);
  re::RigHierarchy::getBindPoseHierarchy(v7, (uint64_t)a2, (uint64_t)&v66);
  if (*((void *)v7 + 27))
  {
    unint64_t v10 = 0;
    do
    {
      unint64_t v11 = re::RigHierarchy::jointName(v7, v10);
      size_t v12 = strlen(*(const char **)(v11 + 8));
      uint64_t v58 = *(void *)(v11 + 8);
      uint64_t v59 = v12;
      re::RigHierarchy::getLocalSpaceJointScale(v7, (uint64_t)&v58, (uint64_t)v62);
      size_t v13 = strlen(*(const char **)(v11 + 8));
      uint64_t v54 = *(void *)(v11 + 8);
      uint64_t v55 = v13;
      re::RigHierarchy::getLocalSpaceJointRotation(v7, (uint64_t)&v54, (uint64_t)&v58);
      size_t v14 = strlen(*(const char **)(v11 + 8));
      uint64_t v49 = *(void *)(v11 + 8);
      uint64_t v50 = v14;
      re::RigHierarchy::getLocalSpaceJointTranslation(v7, (uint64_t)&v49, (uint64_t)&v54);
      v53[0] = v63;
      v53[1] = v59;
      v53[2] = v55;
      size_t v15 = strlen(*(const char **)(v11 + 8));
      uint64_t v45 = *(void *)(v11 + 8);
      size_t v46 = v15;
      re::RigHierarchy::getLocalSpaceJointScale(v8, (uint64_t)&v45, (uint64_t)&v49);
      size_t v16 = strlen(*(const char **)(v11 + 8));
      uint64_t v41 = *(void *)(v11 + 8);
      size_t v42 = v16;
      re::RigHierarchy::getLocalSpaceJointRotation(v8, (uint64_t)&v41, (uint64_t)&v45);
      size_t v17 = strlen(*(const char **)(v11 + 8));
      uint64_t v38 = *(void *)(v11 + 8);
      size_t v39 = v17;
      re::RigHierarchy::getLocalSpaceJointTranslation(v8, (uint64_t)&v38, (uint64_t)&v41);
      uint64_t v38 = v50;
      size_t v39 = v46;
      size_t v40 = v42;
      re::EvaluationTree::additiveBlend(*(void **)(a1 + 8), v53, &v38, v37);
      size_t v18 = strlen(*(const char **)(v11 + 8));
      v32 = *(const char **)(v11 + 8);
      size_t v33 = v18;
      re::RigHierarchy::setLocalSpaceJointScale((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[0], (uint64_t)v34);
      if (!v34[0] && (void)v35)
      {
        if (BYTE8(v35)) {
          (*(void (**)(void))(*(void *)v35 + 40))();
        }
        long long v35 = 0u;
        long long v36 = 0u;
      }
      size_t v19 = strlen(*(const char **)(v11 + 8));
      v32 = *(const char **)(v11 + 8);
      size_t v33 = v19;
      re::RigHierarchy::setLocalSpaceJointRotation((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[1], (uint64_t)v29);
      if (!v29[0] && (void)v30)
      {
        if (BYTE8(v30)) {
          (*(void (**)(void))(*(void *)v30 + 40))();
        }
        long long v30 = 0u;
        long long v31 = 0u;
      }
      uint64_t v20 = *(const char **)(v11 + 8);
      size_t v21 = strlen(v20);
      v32 = v20;
      size_t v33 = v21;
      re::RigHierarchy::setLocalSpaceJointTranslation((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[2], (uint64_t)v26);
      if (!v26[0] && (void)v27)
      {
        if (BYTE8(v27)) {
          (*(void (**)(void))(*(void *)v27 + 40))();
        }
        long long v27 = 0u;
        long long v28 = 0u;
      }
      if (!(_BYTE)v41 && v43 && (v44 & 1) != 0) {
        (*(void (**)(void))(*(void *)v43 + 40))();
      }
      if (!(_BYTE)v45 && v47 && (v48 & 1) != 0) {
        (*(void (**)(void))(*(void *)v47 + 40))();
      }
      if (!(_BYTE)v49 && v51 && (v52 & 1) != 0) {
        (*(void (**)(void))(*(void *)v51 + 40))();
      }
      if (!(_BYTE)v54 && v56 && (v57 & 1) != 0) {
        (*(void (**)(void))(*(void *)v56 + 40))();
      }
      if (!(_BYTE)v58 && v60 && (v61 & 1) != 0) {
        (*(void (**)(void))(*(void *)v60 + 40))();
      }
      if (!v62[0] && v64 && (v65 & 1) != 0) {
        (*(void (**)(void))(*(void *)v64 + 40))();
      }
      ++v10;
    }
    while (v10 < *((void *)v7 + 27));
  }
  if (!a5) {
    goto LABEL_62;
  }
  uint64_t v22 = *(void *)(*(void *)a4 + 184);
  long long v23 = v66;
  *(void *)(v22 + 16) = v67;
  *(_OWORD *)uint64_t v22 = v23;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v22 + 24, (uint64_t)v68);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v22 + 72, (uint64_t)v69);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v22 + 120, v70);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v22 + 160, v71);
  re::DynamicArray<re::StringID>::operator=(v22 + 200, v72);
  re::DynamicArray<unsigned long>::operator=(v22 + 240, v73);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v22 + 280, v76);
  re::DynamicArray<unsigned long>::operator=(v22 + 320, v79);
  if (v79[0])
  {
    if (v81) {
      (*(void (**)(void))(*(void *)v79[0] + 40))();
    }
    uint64_t v81 = 0;
    memset(v79, 0, sizeof(v79));
    ++v80;
  }
  if (v76[0])
  {
    if (v78) {
      (*(void (**)(void))(*(void *)v76[0] + 40))();
    }
    uint64_t v78 = 0;
    memset(v76, 0, sizeof(v76));
    ++v77;
  }
  if (v73[0])
  {
    if (v75) {
      (*(void (**)(void))(*(void *)v73[0] + 40))();
    }
    uint64_t v75 = 0;
    memset(v73, 0, sizeof(v73));
    ++v74;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v72);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v71);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v70);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v69);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v68);
  return 1;
}

void re::RigGraphOperatorDefinition::registerBuiltIns(re::RigGraphOperatorDefinition *this, re::RigEnvironment *a2)
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BDFFF8;
  long long v102 = *(_OWORD *)&off_264BE0008;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConjugateQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0038;
  long long v102 = *(_OWORD *)&off_264BE0048;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BDFFD8;
  long long v102 = *(_OWORD *)&off_264BDFFE8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BDFFF8;
  long long v102 = *(_OWORD *)&off_264BE0008;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0018;
  long long v102 = *(_OWORD *)&off_264BE0028;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::NormalizeVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0038;
  long long v102 = *(_OWORD *)&off_264BE0048;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::TransposeMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0058;
  long long v102 = *(_OWORD *)&off_264BE0068;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::PassthroughRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0058;
  long long v102 = *(_OWORD *)&off_264BE0068;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::GetBindPoseRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0078;
  long long v102 = *(_OWORD *)&off_264BE0088;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractMinorMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0098;
  long long v102 = *(_OWORD *)&off_264BE00A8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractRotationMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE00B8;
  long long v102 = *(_OWORD *)&off_264BE00C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractRotationMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE00D8;
  long long v102 = *(_OWORD *)&off_264BE00E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractScaleMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE00D8;
  long long v102 = *(_OWORD *)&off_264BE00E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractTranslationMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE00F8;
  long long v102 = *(_OWORD *)&off_264BE0108;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4FromSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0118;
  long long v102 = *(_OWORD *)&off_264BE0128;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConstructSRTFromMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0478;
  long long v102 = *(_OWORD *)&off_264BE0488;
  long long v103 = xmmword_264BE0498;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0138;
  long long v102 = *(_OWORD *)&off_264BE0148;
  long long v103 = xmmword_264BE0158;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0918;
  long long v102 = *(_OWORD *)&off_264BE0928;
  long long v103 = xmmword_264BE0938;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0478;
  long long v102 = *(_OWORD *)&off_264BE0488;
  long long v103 = xmmword_264BE0498;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0138;
  long long v102 = *(_OWORD *)&off_264BE0148;
  long long v103 = xmmword_264BE0158;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0918;
  long long v102 = *(_OWORD *)&off_264BE0928;
  long long v103 = xmmword_264BE0938;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0448;
  long long v102 = *(_OWORD *)&off_264BE0458;
  long long v103 = xmmword_264BE0468;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DivideQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0918;
  long long v102 = *(_OWORD *)&off_264BE0928;
  long long v103 = xmmword_264BE0938;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DivideFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0918;
  long long v102 = *(_OWORD *)&off_264BE0928;
  long long v103 = xmmword_264BE0938;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0168;
  long long v102 = *(_OWORD *)&off_264BE0178;
  long long v103 = xmmword_264BE0188;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::RotateVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0198;
  long long v102 = *(_OWORD *)&off_264BE01A8;
  long long v103 = xmmword_264BE01B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ScaleVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE01C8;
  long long v102 = *(_OWORD *)&off_264BE01D8;
  long long v103 = xmmword_264BE01E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE01F8;
  long long v102 = *(_OWORD *)&off_264BE0208;
  long long v103 = xmmword_264BE0218;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4FromMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0228;
  long long v102 = *(_OWORD *)&off_264BE0238;
  long long v103 = xmmword_264BE0248;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformDirectionByMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0258;
  long long v102 = *(_OWORD *)&off_264BE0268;
  long long v103 = xmmword_264BE0278;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformDirectionByMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0258;
  long long v102 = *(_OWORD *)&off_264BE0268;
  long long v103 = xmmword_264BE0278;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformPositionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0348;
  long long v102 = *(_OWORD *)&off_264BE0358;
  long long v103 = xmmword_264BE0368;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DotVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0378;
  long long v102 = *(_OWORD *)&off_264BE0388;
  long long v103 = xmmword_264BE0398;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DotVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0478;
  long long v102 = *(_OWORD *)&off_264BE0488;
  long long v103 = xmmword_264BE0498;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::CrossVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0288;
  long long v102 = *(_OWORD *)&off_264BE0298;
  long long v103 = xmmword_264BE02A8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConvertIntrinsicEulerToQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE02B8;
  long long v102 = *(_OWORD *)&off_264BE02C8;
  long long v103 = xmmword_264BE02D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConvertQuaternionToIntrinsicEulerCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE02E8;
  long long v102 = *(_OWORD *)&off_264BE02F8;
  long long v103 = xmmword_264BE0308;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ExtractTwistFromQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0318;
  long long v102 = *(_OWORD *)&off_264BE0328;
  long long v103 = xmmword_264BE0338;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0348;
  long long v102 = *(_OWORD *)&off_264BE0358;
  long long v103 = xmmword_264BE0368;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GetVector3ComponentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0378;
  long long v102 = *(_OWORD *)&off_264BE0388;
  long long v103 = xmmword_264BE0398;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GetVector2ComponentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE03A8;
  long long v102 = *(_OWORD *)&off_264BE03B8;
  long long v103 = xmmword_264BE03C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE03D8;
  long long v102 = *(_OWORD *)&off_264BE03E8;
  long long v103 = xmmword_264BE03F8;
  long long v104 = *(_OWORD *)&off_264BE0408;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0418;
  long long v102 = *(_OWORD *)&off_264BE0428;
  long long v103 = xmmword_264BE0438;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AdditiveBlendSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0448;
  long long v102 = *(_OWORD *)&off_264BE0458;
  long long v103 = xmmword_264BE0468;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0478;
  long long v102 = *(_OWORD *)&off_264BE0488;
  long long v103 = xmmword_264BE0498;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE04A8;
  long long v102 = *(_OWORD *)&off_264BE04B8;
  long long v103 = xmmword_264BE04C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE04D8;
  long long v102 = *(_OWORD *)&off_264BE04E8;
  long long v103 = xmmword_264BE04F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0508;
  long long v102 = *(_OWORD *)&off_264BE0518;
  long long v103 = xmmword_264BE0528;
  long long v104 = *(_OWORD *)&off_264BE0538;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructMatrix3x3FromVector3sCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0548;
  long long v102 = *(_OWORD *)&off_264BE0558;
  long long v103 = xmmword_264BE0568;
  long long v104 = *(_OWORD *)&off_264BE0578;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0588;
  long long v102 = *(_OWORD *)&off_264BE0598;
  long long v103 = xmmword_264BE05A8;
  long long v104 = *(_OWORD *)&off_264BE05B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ComponentLerpVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE05C8;
  long long v102 = *(_OWORD *)&off_264BE05D8;
  long long v103 = xmmword_264BE05E8;
  long long v104 = *(_OWORD *)&off_264BE05F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0608;
  long long v102 = *(_OWORD *)&off_264BE0618;
  long long v103 = xmmword_264BE0628;
  long long v104 = *(_OWORD *)&off_264BE0638;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0648;
  long long v102 = *(_OWORD *)&off_264BE0658;
  long long v103 = xmmword_264BE0668;
  long long v104 = *(_OWORD *)&off_264BE0678;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SlerpCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0688;
  long long v102 = *(_OWORD *)&off_264BE0698;
  long long v103 = xmmword_264BE06A8;
  long long v104 = *(_OWORD *)&off_264BE06B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ClampCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE06C8;
  long long v102 = *(_OWORD *)&off_264BE06D8;
  long long v103 = xmmword_264BE06E8;
  long long v104 = *(_OWORD *)&off_264BE06F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ClampVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0738;
  long long v102 = *(_OWORD *)&off_264BE0748;
  long long v103 = xmmword_264BE0758;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0708;
  long long v102 = *(_OWORD *)&off_264BE0718;
  long long v103 = xmmword_264BE0728;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0738;
  long long v102 = *(_OWORD *)&off_264BE0748;
  long long v103 = xmmword_264BE0758;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0768;
  long long v102 = *(_OWORD *)&off_264BE0778;
  long long v103 = xmmword_264BE0788;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0738;
  long long v102 = *(_OWORD *)&off_264BE0748;
  long long v103 = xmmword_264BE0758;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0708;
  long long v102 = *(_OWORD *)&off_264BE0718;
  long long v103 = xmmword_264BE0728;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0738;
  long long v102 = *(_OWORD *)&off_264BE0748;
  long long v103 = xmmword_264BE0758;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0768;
  long long v102 = *(_OWORD *)&off_264BE0778;
  long long v103 = xmmword_264BE0788;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE07D8;
  long long v102 = *(_OWORD *)&off_264BE07E8;
  long long v103 = xmmword_264BE07F8;
  long long v104 = *(_OWORD *)&off_264BE0808;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0798;
  long long v102 = *(_OWORD *)&off_264BE07A8;
  long long v103 = xmmword_264BE07B8;
  long long v104 = *(_OWORD *)&off_264BE07C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE07D8;
  long long v102 = *(_OWORD *)&off_264BE07E8;
  long long v103 = xmmword_264BE07F8;
  long long v104 = *(_OWORD *)&off_264BE0808;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0818;
  long long v102 = *(_OWORD *)&off_264BE0828;
  long long v103 = xmmword_264BE0838;
  long long v104 = *(_OWORD *)&off_264BE0848;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE07D8;
  long long v102 = *(_OWORD *)&off_264BE07E8;
  long long v103 = xmmword_264BE07F8;
  long long v104 = *(_OWORD *)&off_264BE0808;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0798;
  long long v102 = *(_OWORD *)&off_264BE07A8;
  long long v103 = xmmword_264BE07B8;
  long long v104 = *(_OWORD *)&off_264BE07C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE07D8;
  long long v102 = *(_OWORD *)&off_264BE07E8;
  long long v103 = xmmword_264BE07F8;
  long long v104 = *(_OWORD *)&off_264BE0808;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0818;
  long long v102 = *(_OWORD *)&off_264BE0828;
  long long v103 = xmmword_264BE0838;
  long long v104 = *(_OWORD *)&off_264BE0848;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0858;
  long long v102 = *(_OWORD *)&off_264BE0868;
  long long v103 = xmmword_264BE0878;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::JointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0888;
  long long v102 = *(_OWORD *)&off_264BE0898;
  long long v103 = xmmword_264BE08A8;
  long long v104 = *(_OWORD *)&off_264BE08B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetJointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08C8;
  long long v102 = *(_OWORD *)&off_264BE08D8;
  long long v103 = xmmword_264BE08E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ClearJointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08C8;
  long long v102 = *(_OWORD *)&off_264BE08D8;
  long long v103 = xmmword_264BE08E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddJointCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08C8;
  long long v102 = *(_OWORD *)&off_264BE08D8;
  long long v103 = xmmword_264BE08E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::RemoveJointCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::SinFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::CosFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::TanFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AsinFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AcosFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE08F8;
  long long v102 = *(_OWORD *)&off_264BE0908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AtanFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0918;
  long long v102 = *(_OWORD *)&off_264BE0928;
  long long v103 = xmmword_264BE0938;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::Atan2FloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0948;
  long long v102 = *(_OWORD *)&off_264BE0958;
  long long v103 = xmmword_264BE0968;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GreaterCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0948;
  long long v102 = *(_OWORD *)&off_264BE0958;
  long long v103 = xmmword_264BE0968;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GreaterEqualCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0948;
  long long v102 = *(_OWORD *)&off_264BE0958;
  long long v103 = xmmword_264BE0968;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LessCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0948;
  long long v102 = *(_OWORD *)&off_264BE0958;
  long long v103 = xmmword_264BE0968;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LessEqualCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0978;
  long long v102 = *(_OWORD *)&off_264BE0988;
  long long v103 = xmmword_264BE0998;
  long long v104 = *(_OWORD *)&off_264BE09A8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SelectFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE09B8;
  long long v102 = *(_OWORD *)&off_264BE09C8;
  long long v103 = xmmword_264BE09D8;
  long long v104 = *(_OWORD *)&off_264BE09E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE09F8;
  long long v102 = *(_OWORD *)&off_264BE0A08;
  long long v103 = xmmword_264BE0A18;
  long long v104 = *(_OWORD *)&off_264BE0A28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::BlendRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  uint64_t v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  unint64_t v95 = 0;
  long long v97 = 0u;
  v96 = "";
  uint64_t v93 = 0;
  v94 = "";
  long long v101 = xmmword_264BE0A38;
  long long v102 = *(_OWORD *)&off_264BE0A48;
  long long v103 = xmmword_264BE0A58;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::BlendAdditiveRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
}

float *re::ClampCompile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a8)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a4)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  uint64_t Runtime = re::RigDataValue::getRuntimeValue<float>(a3, a2);
  if (a4 == 1)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  size_t v13 = (float *)Runtime;
  uint64_t v14 = re::RigDataValue::getRuntimeValue<float>(a3 + 288, v12);
  if (a4 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    uint64_t result = (float *)_os_crash();
    __break(1u);
    return result;
  }
  size_t v16 = (float *)v14;
  size_t v17 = (float *)re::RigDataValue::getRuntimeValue<float>(a3 + 576, v15);
  float v19 = *v13;
  if (*v13 > *v17) {
    float v19 = *v17;
  }
  if (v19 >= *v16) {
    float v20 = v19;
  }
  else {
    float v20 = *v16;
  }
  uint64_t result = (float *)re::RigDataValue::getRuntimeValue<float>(a7, v18);
  *uint64_t result = v20;
  return result;
}

_OWORD *re::ClampVector3Compile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  uint64_t v12 = re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3, a2);
  if (a4 == 1)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  float32x2_t v14 = *(float32x2_t *)v12;
  float v15 = *(float *)(v12 + 8);
  uint64_t v16 = re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3 + 288, v13);
  if (a4 <= 2)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  float v18 = *(float *)(v16 + 8);
  float32x2_t v19 = *(float32x2_t *)v16;
  float v20 = (float32x2_t *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3 + 576, v17);
  if (!a8)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v21, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = (_OWORD *)_os_crash();
    __break(1u);
    return result;
  }
  float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14, *v20), (int8x8_t)*v20, (int8x8_t)v14);
  *(int8x8_t *)&long long v22 = vbsl_s8((int8x8_t)vcgt_f32(v19, v23), (int8x8_t)v19, (int8x8_t)v23);
  float v24 = v20[1].f32[0];
  if (v15 <= v24) {
    float v24 = v15;
  }
  if (v24 < v18) {
    float v24 = v18;
  }
  *((float *)&v22 + 2) = v24;
  long long v26 = v22;
  uint64_t result = (_OWORD *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a7, v21);
  *uint64_t result = v26;
  return result;
}

BOOL re::AnimationHelper::makeAdditiveForValues<float>(re *a1, float **a2, float *a3, float *a4)
{
  if (*((float **)a1 + 1) != a4)
  {
    float32x2_t v14 = *re::animationLogObjects(a1);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v23 = 0;
    uint64_t v16 = "Cannot make additive values, output values expected to match input values size.";
    uint64_t v17 = (uint8_t *)&v23;
LABEL_13:
    _os_log_error_impl(&dword_233120000, v14, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    return 0;
  }
  v4 = a2[1];
  if (!v4)
  {
    float32x2_t v14 = *re::animationLogObjects(a1);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v22 = 0;
    uint64_t v16 = "Cannot make additive values, base values array size must not be zero.";
    uint64_t v17 = (uint8_t *)&v22;
    goto LABEL_13;
  }
  if (a4 < v4) {
    v4 = a4;
  }
  if (v4)
  {
    uint64_t v5 = *(float **)a1;
    uint64_t v6 = *a2;
    uint64_t v7 = a3;
    uint64_t v8 = v4;
    do
    {
      float v9 = *v6++;
      float v10 = v9;
      float v11 = *v5++;
      *v7++ = v11 - v10;
      uint64_t v8 = (float *)((char *)v8 - 1);
    }
    while (v8);
    float v12 = -v10;
    unint64_t v13 = v4;
  }
  else
  {
    unint64_t v13 = 0;
    float v12 = 0.0;
  }
  uint64_t v18 = (uint64_t)a4 - v13;
  if ((unint64_t)a4 > v13)
  {
    float32x2_t v19 = &a3[v13];
    float v20 = (float *)(*(void *)a1 + 4 * v13);
    do
    {
      float v21 = *v20++;
      *v19++ = v12 + v21;
      --v18;
    }
    while (v18);
  }
  return 1;
}

double re::SampledAnimation<float>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<float>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    float v7 = **(float **)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    float v8 = *(double *)(a2 + 24);
    float v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (float v10 = (float)(v8 - v9) / *(float *)(result + 76),
            float v11 = floorf(v10),
            float v12 = v11 + ceilf(v10 - v11),
            unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        float v7 = *(float *)(*(void *)(result + 104) + 4 * v6 - 4);
        goto LABEL_10;
      }
      if (v6 != v13 && *(unsigned char *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            float v7 = (float)((float)(v10 - (float)(v12 + -1.0)) * *(float *)(*(void *)(result + 104) + 4 * v13))
               + (float)(*(float *)(*(void *)(result + 104) + 4 * (v13 - 1))
                       * (float)(1.0 - (float)(v10 - (float)(v12 + -1.0))));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13) {
        unint64_t v13 = v6 - 1;
      }
      if (v6 > v13)
      {
        float v7 = *(float *)(*(void *)(result + 104) + 4 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  float v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

BOOL re::AnimationHelper::makeAdditiveForValues<double>(re *a1, uint64_t a2, double *a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    float32x2_t v14 = *re::animationLogObjects(a1);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v23 = 0;
    uint64_t v16 = "Cannot make additive values, output values expected to match input values size.";
    uint64_t v17 = (uint8_t *)&v23;
LABEL_13:
    _os_log_error_impl(&dword_233120000, v14, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    return 0;
  }
  unint64_t v4 = *(void *)(a2 + 8);
  if (!v4)
  {
    float32x2_t v14 = *re::animationLogObjects(a1);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v22 = 0;
    uint64_t v16 = "Cannot make additive values, base values array size must not be zero.";
    uint64_t v17 = (uint8_t *)&v22;
    goto LABEL_13;
  }
  if (a4 < v4) {
    unint64_t v4 = a4;
  }
  if (v4)
  {
    uint64_t v5 = *(double **)a1;
    unint64_t v6 = *(double **)a2;
    float v7 = a3;
    unint64_t v8 = v4;
    do
    {
      double v9 = *v6++;
      double v10 = v9;
      double v11 = *v5++;
      *v7++ = v11 - v10;
      --v8;
    }
    while (v8);
    double v12 = -v10;
    unint64_t v13 = v4;
  }
  else
  {
    unint64_t v13 = 0;
    double v12 = 0.0;
  }
  unint64_t v18 = a4 - v13;
  if (a4 > v13)
  {
    float32x2_t v19 = &a3[v13];
    float v20 = (double *)(*(void *)a1 + 8 * v13);
    do
    {
      double v21 = *v20++;
      *v19++ = v12 + v21;
      --v18;
    }
    while (v18);
  }
  return 1;
}

double re::SampledAnimation<double>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<double>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, double *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    double v7 = **(double **)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    float v8 = *(double *)(a2 + 24);
    float v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (float v10 = (float)(v8 - v9) / *(float *)(result + 76),
            float v11 = floorf(v10),
            float v12 = v11 + ceilf(v10 - v11),
            unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        double v7 = *(double *)(*(void *)(result + 104) + 8 * v6 - 8);
        goto LABEL_10;
      }
      if (v6 != v13 && *(unsigned char *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            double v7 = *(double *)(*(void *)(result + 104) + 8 * v13) * (float)(v10 - (float)(v12 + -1.0))
               + *(double *)(*(void *)(result + 104) + 8 * (v13 - 1))
               * (float)(1.0 - (float)(v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13) {
        unint64_t v13 = v6 - 1;
      }
      if (v6 > v13)
      {
        double v7 = *(double *)(*(void *)(result + 104) + 8 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  double v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Vector2<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    float v11 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v15 = 0;
    float v12 = "Cannot make additive values, output values expected to match input values size.";
    unint64_t v13 = (uint8_t *)&v15;
    goto LABEL_25;
  }
  if (!a2[1])
  {
    float v11 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    float v12 = "Cannot make additive values, base values array size must not be zero.";
    unint64_t v13 = buf;
LABEL_25:
    _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
    return 0;
  }
  if (!a4) {
    return 1;
  }
  unint64_t v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_27;
    }
    float32x2_t v5 = *(float32x2_t *)(*a2 + 8 * v4);
    *(float32x2_t *)(a3 + 8 * v4) = vsub_f32(*(float32x2_t *)(*(void *)a1 + 8 * v4), v5);
    ++v4;
    unint64_t v6 = *((void *)a1 + 1);
  }
  while (v6 > v4 && a2[1] > v4);
  if (v6 <= v4) {
    return 1;
  }
  uint64_t v8 = v4;
  if (a4 <= v4) {
    unint64_t v9 = v4;
  }
  else {
    unint64_t v9 = a4;
  }
  if (a4 <= v4) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = a4;
  }
  while (v4 != v8)
  {
    *(float32x2_t *)(a3 + 8 * v8) = vsub_f32(*(float32x2_t *)(*(void *)a1 + 8 * v8), v5);
    if (*((void *)a1 + 1) <= (unint64_t)++v8) {
      return 1;
    }
  }
LABEL_27:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

float32x2_t re::SampledAnimation<re::Vector2<float>>::evaluateCore(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t *a4, float32x2_t result, uint64_t a6, double *a7)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  unint64_t v7 = *(void *)(a1 + 96);
  if (v7 == 1)
  {
LABEL_9:
    uint64_t v8 = **(void **)(a1 + 104);
    goto LABEL_10;
  }
  if (v7)
  {
    uint64_t result = a2[3];
    result.f32[0] = *(double *)&result;
    float v9 = *(float *)(a1 + 80);
    if (v9 < result.f32[0])
    {
      if (*(float *)(a1 + 84) <= result.f32[0]
        || (result.f32[0] = (float)(result.f32[0] - v9) / *(float *)(a1 + 76),
            float v10 = floorf(result.f32[0]),
            float v11 = v10 + ceilf(result.f32[0] - v10),
            unint64_t v12 = (unint64_t)(float)(v11 + 0.5),
            v7 < v12))
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 104) + 8 * v7 - 8);
        goto LABEL_10;
      }
      if (v7 != v12 && *(unsigned char *)(a1 + 73) != 0)
      {
        if (v7 > v12 - 1)
        {
          if (v7 > v12)
          {
            uint64_t result = vadd_f32(vmul_n_f32(*(float32x2_t *)(*(void *)(a1 + 104) + 8 * (v12 - 1)), 1.0 - (float)(result.f32[0] - (float)(v11 + -1.0))), vmul_n_f32(*(float32x2_t *)(*(void *)(a1 + 104) + 8 * v12), result.f32[0] - (float)(v11 + -1.0)));
            *a7 = *(double *)&result;
            return result;
          }
LABEL_27:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_26:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_27;
      }
      if (v7 <= v12) {
        unint64_t v12 = v7 - 1;
      }
      if (v7 > v12)
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 104) + 8 * v12);
        goto LABEL_10;
      }
LABEL_25:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_26;
    }
    goto LABEL_9;
  }
  uint64_t v8 = *a4;
LABEL_10:
  *(void *)a7 = v8;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Vector3<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    float v11 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v15 = 0;
    unint64_t v12 = "Cannot make additive values, output values expected to match input values size.";
    unint64_t v13 = (uint8_t *)&v15;
    goto LABEL_25;
  }
  if (!a2[1])
  {
    float v11 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    unint64_t v12 = "Cannot make additive values, base values array size must not be zero.";
    unint64_t v13 = buf;
LABEL_25:
    _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
    return 0;
  }
  if (!a4) {
    return 1;
  }
  unint64_t v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_27;
    }
    float32x4_t v5 = *(float32x4_t *)(*a2 + 16 * v4);
    *(float32x4_t *)(a3 + 16 * v4) = vsubq_f32(*(float32x4_t *)(*(void *)a1 + 16 * v4), v5);
    ++v4;
    unint64_t v6 = *((void *)a1 + 1);
  }
  while (v6 > v4 && a2[1] > v4);
  if (v6 <= v4) {
    return 1;
  }
  uint64_t v8 = v4;
  if (a4 <= v4) {
    unint64_t v9 = v4;
  }
  else {
    unint64_t v9 = a4;
  }
  if (a4 <= v4) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = a4;
  }
  while (v4 != v8)
  {
    *(float32x4_t *)(a3 + 16 * v8) = vsubq_f32(*(float32x4_t *)(*(void *)a1 + 16 * v8), v5);
    if (*((void *)a1 + 1) <= (unint64_t)++v8) {
      return 1;
    }
  }
LABEL_27:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    float32x4_t v7 = *(float32x4_t *)*(void *)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    float v8 = *(double *)(a2 + 24);
    float v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (float v10 = (float)(v8 - v9) / *(float *)(result + 76),
            float v11 = floorf(v10),
            float v12 = v11 + ceilf(v10 - v11),
            unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        float32x4_t v7 = *(float32x4_t *)(*(void *)(result + 104) + 16 * v6 - 16);
        goto LABEL_10;
      }
      if (v6 != v13 && *(unsigned char *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            float32x4_t v7 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 104) + 16 * v13), v10 - (float)(v12 + -1.0)), *(float32x4_t *)(*(void *)(result + 104) + 16 * (v13 - 1)), 1.0 - (float)(v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13) {
        unint64_t v13 = v6 - 1;
      }
      if (v6 > v13)
      {
        float32x4_t v7 = *(float32x4_t *)(*(void *)(result + 104) + 16 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  float32x4_t v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

double re::SampledAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    float32x4_t v7 = *(float32x4_t *)*(void *)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    float v8 = *(double *)(a2 + 24);
    float v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (float v10 = (float)(v8 - v9) / *(float *)(result + 76),
            float v11 = floorf(v10),
            float v12 = v11 + ceilf(v10 - v11),
            unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        float32x4_t v7 = *(float32x4_t *)(*(void *)(result + 104) + 16 * v6 - 16);
        goto LABEL_10;
      }
      if (v6 != v13 && *(unsigned char *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            float32x4_t v7 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 104) + 16 * (v13 - 1)), 1.0 - (float)(v10 - (float)(v12 + -1.0))), vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 104) + 16 * v13), v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13) {
        unint64_t v13 = v6 - 1;
      }
      if (v6 > v13)
      {
        float32x4_t v7 = *(float32x4_t *)(*(void *)(result + 104) + 16 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  float32x4_t v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Quaternion<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    long long v26 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v30 = 0;
    long long v27 = "Cannot make additive values, output values expected to match input values size.";
    long long v28 = (uint8_t *)&v30;
    goto LABEL_23;
  }
  if (!a2[1])
  {
    long long v26 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    long long v27 = "Cannot make additive values, base values array size must not be zero.";
    long long v28 = buf;
LABEL_23:
    _os_log_error_impl(&dword_233120000, v26, OS_LOG_TYPE_ERROR, v27, v28, 2u);
    return 0;
  }
  if (!a4) {
    return 1;
  }
  unint64_t v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_25;
    }
    _Q0 = *(float32x4_t *)(*a2 + 16 * v4);
    float32x4_t v6 = vnegq_f32(_Q0);
    _Q4 = *(float32x4_t *)(*(void *)a1 + 16 * v4);
    float32x4_t v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL);
    int8x16_t v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), (int8x16_t)_Q4, 0xCuLL), _Q0), _Q4, v8);
    float32x4_t v10 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL), _Q4, _Q0, 3), _Q0, _Q4, 3);
    _Q4.i32[0] = _Q4.i32[3];
    __asm { FMLA            S6, S4, V0.S[3] }
    v10.i32[3] = _S6;
    *(float32x4_t *)(a3 + 16 * v4++) = v10;
    unint64_t v16 = *((void *)a1 + 1);
  }
  while (v16 > v4 && a2[1] > v4);
  if (v16 <= v4) {
    return 1;
  }
  float32x4_t v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 3);
  _S5 = _Q0.i32[3];
  unint64_t v19 = v4;
  if (a4 <= v4) {
    unint64_t v20 = v4;
  }
  else {
    unint64_t v20 = a4;
  }
  if (a4 <= v4) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = a4;
  }
  while (v4 != v19)
  {
    _Q6 = *(float32x4_t *)(*(void *)a1 + 16 * v19);
    int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q6, (int32x4_t)_Q6), (int8x16_t)_Q6, 0xCuLL), _Q0), _Q6, v8);
    float32x4_t v23 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL), _Q6, v17), v6, _Q6, 3);
    __asm { FMLA            S16, S5, V6.S[3] }
    v23.i32[3] = _S16;
    *(float32x4_t *)(a3 + 16 * v19++) = v23;
    if (*((void *)a1 + 1) <= v19) {
      return 1;
    }
  }
LABEL_25:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v20, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

void re::SampledAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_26:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
  unint64_t v6 = *(void *)(a1 + 96);
  if (v6 == 1) {
    goto LABEL_9;
  }
  if (!v6)
  {
    long long v7 = *a4;
LABEL_10:
    *(_OWORD *)a6 = v7;
    return;
  }
  float v8 = *(double *)(a2 + 24);
  float v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    long long v7 = *(_OWORD *)*(void *)(a1 + 104);
    goto LABEL_10;
  }
  if (*(float *)(a1 + 84) <= v8
    || (float v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        float v11 = floorf(v10),
        float v12 = v11 + ceilf(v10 - v11),
        unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    long long v7 = *(_OWORD *)(*(void *)(a1 + 104) + 16 * v6 - 16);
    goto LABEL_10;
  }
  if (v6 == v13 || *(unsigned char *)(a1 + 73) == 0)
  {
    if (v6 <= v13) {
      unint64_t v13 = v6 - 1;
    }
    if (v6 > v13)
    {
      long long v7 = *(_OWORD *)(*(void *)(a1 + 104) + 16 * v13);
      goto LABEL_10;
    }
    goto LABEL_26;
  }
  if (v6 <= v13 - 1)
  {
LABEL_27:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_28:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13) {
    goto LABEL_28;
  }
  uint64_t v15 = *(void *)(a1 + 104);
  float v16 = v10 - (float)(v12 + -1.0);
  re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)(v15 + 16 * (v13 - 1)), (float32x4_t *)(v15 + 16 * v13), a6, v16);
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::GenericSRT<float>>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    size_t v29 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    __int16 v30 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_23;
  }
  unint64_t v4 = a2;
  if (!*(void *)(a2 + 8))
  {
    size_t v29 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    __int16 v30 = "Cannot make additive values, base values array size must not be zero.";
LABEL_23:
    _os_log_error_impl(&dword_233120000, v29, OS_LOG_TYPE_ERROR, v30, buf, 2u);
    return 0;
  }
  *(void *)buf = 0x3F8000003F800000;
  *(void *)&buf[8] = 1065353216;
  v33.i64[0] = 0;
  v33.i64[1] = 0x3F80000000000000;
  float32x4_t v34 = 0uLL;
  if (!a4) {
    return 1;
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v31 = _Q0;
  do
  {
    uint64_t v15 = (float32x4_t *)(*(void *)v4 + v8);
    float32x4_t v16 = v15[1];
    float32x4_t v17 = v15[2];
    int8x16_t v18 = (int8x16_t)vnegq_f32(v16);
    float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), v18, 0xCuLL);
    v18.i32[3] = v16.i32[3];
    float32x4_t v20 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v16), v17, v19);
    int8x16_t v21 = (int8x16_t)vaddq_f32(v20, v20);
    float32x4_t v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL);
    float32x4_t v23 = vaddq_f32(v17, vmulq_laneq_f32(v22, v16, 3));
    int8x16_t v24 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v16), v22, v19);
    *(float32x4_t *)buf = vdivq_f32(v31, *v15);
    int8x16_t v33 = v18;
    float32x4_t v34 = vmulq_f32(vaddq_f32(v23, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL)), vnegq_f32(*(float32x4_t *)buf));
    if (a4 == v9)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_25;
    }
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(void *)a1 + v8), (float32x4_t *)buf, (float32x4_t *)(a3 + v8));
    ++v9;
    unint64_t v25 = *((void *)a1 + 1);
    if (v25 <= v9) {
      break;
    }
    v8 += 48;
  }
  while (*(void *)(v4 + 8) > v9);
  if (v25 <= v9) {
    return 1;
  }
  unint64_t v26 = v9;
  if (a4 <= v9) {
    unint64_t v4 = v9;
  }
  else {
    unint64_t v4 = a4;
  }
  uint64_t v27 = 48 * v9;
  if (a4 <= v9) {
    unint64_t v9 = v9;
  }
  else {
    unint64_t v9 = a4;
  }
  while (v9 != v26)
  {
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(void *)a1 + v27), (float32x4_t *)buf, (float32x4_t *)(a3 + v27));
    ++v26;
    v27 += 48;
    if (*((void *)a1 + 1) <= v26) {
      return 1;
    }
  }
LABEL_25:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

double re::SampledAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, _OWORD *a6)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  unint64_t v7 = *(void *)(a1 + 96);
  if (v7 == 1) {
    goto LABEL_9;
  }
  if (!v7)
  {
    long long v8 = *a4;
    long long v9 = a4[1];
    long long v10 = a4[2];
LABEL_11:
    a6[1] = v9;
    a6[2] = v10;
    *a6 = v8;
    return *(double *)&v8;
  }
  float v11 = *(double *)(a2 + 24);
  float v12 = *(float *)(a1 + 80);
  if (v12 >= v11)
  {
LABEL_9:
    int8x16_t v18 = *(long long **)(a1 + 104);
LABEL_10:
    long long v8 = *v18;
    long long v9 = v18[1];
    long long v10 = v18[2];
    goto LABEL_11;
  }
  if (*(float *)(a1 + 84) <= v11
    || (float v13 = (float)(v11 - v12) / *(float *)(a1 + 76),
        float v14 = floorf(v13),
        float v15 = v14 + ceilf(v13 - v14),
        unint64_t v16 = (unint64_t)(float)(v15 + 0.5),
        v7 < v16))
  {
    uint64_t v17 = *(void *)(a1 + 104) + 48 * v7;
    long long v8 = *(_OWORD *)(v17 - 48);
    long long v9 = *(_OWORD *)(v17 - 32);
    long long v10 = *(_OWORD *)(v17 - 16);
    goto LABEL_11;
  }
  if (v7 == v16 || *(unsigned char *)(a1 + 73) == 0)
  {
    if (v7 <= v16) {
      unint64_t v16 = v7 - 1;
    }
    if (v7 > v16)
    {
      int8x16_t v18 = (long long *)(*(void *)(a1 + 104) + 48 * v16);
      goto LABEL_10;
    }
LABEL_26:
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    float32x4_t v22 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
  if (v7 <= v16 - 1)
  {
LABEL_27:
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    float32x4_t v22 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_28:
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    float32x4_t v22 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v7 <= v16) {
    goto LABEL_28;
  }
  re::lerp<float>((float32x4_t *)(*(void *)(a1 + 104) + 48 * (v16 - 1)), (float32x4_t *)(*(void *)(a1 + 104) + 48 * v16), &v22, v13 - (float)(v15 + -1.0));
  long long v20 = v23;
  *a6 = v22;
  a6[1] = v20;
  *(void *)&long long v8 = v24;
  a6[2] = v24;
  return *(double *)&v8;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::SkeletalPose>(re *a1, void *a2, uint64_t a3, void *a4)
{
  if (*((void **)a1 + 1) != a4)
  {
    unint64_t v16 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    uint64_t v17 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_24;
  }
  unint64_t v4 = a2;
  if (!a2[1])
  {
    unint64_t v16 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    uint64_t v17 = "Cannot make additive values, base values array size must not be zero.";
LABEL_24:
    _os_log_error_impl(&dword_233120000, v16, OS_LOG_TYPE_ERROR, v17, buf, 2u);
    return 0;
  }
  *(void *)buf = 0;
  float32x4_t v19 = "";
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  int v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  re::SkeletalPose::init((uint64_t *)buf, (uint64_t *)(*a2 + 80));
  unint64_t v9 = 0;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10 && v4[1])
  {
    uint64_t v11 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      re::AnimationValueTraits<re::SkeletalPose>::invert((void *)(*v4 + v11), buf);
      unint64_t v13 = *((void *)a1 + 1);
      if (v13 <= v9) {
        break;
      }
      if (a4 == (void *)v9) {
        goto LABEL_27;
      }
      re::AnimationValueTraits<re::SkeletalPose>::combine((void *)(*(void *)a1 + v11), buf, (void *)(a3 + v11));
      ++v9;
      unint64_t v10 = *((void *)a1 + 1);
      if (v10 > v9)
      {
        v11 += 88;
        if (v4[1] > v9) {
          continue;
        }
      }
      unint64_t v9 = v9;
      goto LABEL_11;
    }
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v13);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_11:
    if (v10 <= v9)
    {
LABEL_18:
      re::SkeletalPose::deinit((re::SkeletalPose *)buf);
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)buf);
      return 1;
    }
    if ((unint64_t)a4 <= v9) {
      unint64_t v4 = (void *)v9;
    }
    else {
      unint64_t v4 = a4;
    }
    uint64_t v14 = 88 * v9;
    while (v4 != (void *)v9)
    {
      re::AnimationValueTraits<re::SkeletalPose>::combine((void *)(*(void *)a1 + v14), buf, (void *)(a3 + v14));
      ++v9;
      v14 += 88;
      if (*((void *)a1 + 1) <= v9) {
        goto LABEL_18;
      }
    }
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  _os_crash();
  __break(1u);
LABEL_27:
  re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

void re::SampledAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_28:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_29;
  }
  unint64_t v6 = *(void *)(a1 + 96);
  if (v6 == 1) {
    goto LABEL_9;
  }
  if (!v6) {
    goto LABEL_10;
  }
  float v8 = *(double *)(a2 + 24);
  float v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    a4 = *(void **)(a1 + 104);
    goto LABEL_10;
  }
  if (*(float *)(a1 + 84) <= v8
    || (float v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        float v11 = floorf(v10),
        float v12 = v11 + ceilf(v10 - v11),
        unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    a4 = (void *)(*(void *)(a1 + 104) + 88 * v6 - 88);
LABEL_10:
    re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
    return;
  }
  if (v6 == v13 || *(unsigned char *)(a1 + 73) == 0)
  {
    if (v6 <= v13) {
      unint64_t v13 = v6 - 1;
    }
    if (v6 > v13)
    {
      a4 = (void *)(*(void *)(a1 + 104) + 88 * v13);
      goto LABEL_10;
    }
    goto LABEL_28;
  }
  if (v6 <= v13 - 1)
  {
LABEL_29:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_30:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13) {
    goto LABEL_30;
  }
  uint64_t v15 = *(void *)(a1 + 104);
  float v16 = v10 - (float)(v12 + -1.0);
  re::AnimationValueTraits<re::SkeletalPose>::interpolate((void *)(v15 + 88 * (v13 - 1)), (void *)(v15 + 88 * v13), a6, v16);
}

double re::SampledAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t *re::SampledAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_28:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_29;
  }
  unint64_t v6 = *(void *)(a1 + 96);
  if (v6 == 1) {
    goto LABEL_9;
  }
  if (!v6) {
    goto LABEL_10;
  }
  float v8 = *(double *)(a2 + 24);
  float v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    a4 = *(uint64_t **)(a1 + 104);
    goto LABEL_10;
  }
  if (*(float *)(a1 + 84) <= v8
    || (float v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        float v11 = floorf(v10),
        float v12 = v11 + ceilf(v10 - v11),
        unint64_t v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    a4 = (uint64_t *)(*(void *)(a1 + 104) + 32 * v6 - 32);
LABEL_10:
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  }
  if (v6 == v13 || *(unsigned char *)(a1 + 73) == 0)
  {
    if (v6 <= v13) {
      unint64_t v13 = v6 - 1;
    }
    if (v6 > v13)
    {
      a4 = (uint64_t *)(*(void *)(a1 + 104) + 32 * v13);
      goto LABEL_10;
    }
    goto LABEL_28;
  }
  if (v6 <= v13 - 1)
  {
LABEL_29:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_30:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13) {
    goto LABEL_30;
  }
  uint64_t v16 = *(void *)(a1 + 104);
  float v17 = v10 - (float)(v12 + -1.0);
  return (uint64_t *)re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)(v16 + 32 * (v13 - 1)), (void *)(v16 + 32 * v13), a6, v17);
}

void re::SkeletalPoseSampledAnimation::evaluateCore(re::SkeletalPoseSampledAnimation *this, uint64_t a2, uint64_t a3, re::SkeletalPose *a4, uint64_t a5, re::SkeletalPose *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, 0, a4, a5, a6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_129:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_130:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_131:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_132:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_133:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_134:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_135:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_136:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_137:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_138:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_139:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_141:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_143:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_145:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_146;
  }
  unint64_t v9 = *((void *)this + 12);
  float v10 = a4;
  if (!v9) {
    goto LABEL_23;
  }
  if (v9 == 1
    || (v11.i64[0] = *(void *)(a2 + 24),
        v11.f32[0] = *(double *)v11.i64,
        float v12 = *((float *)this + 20),
        v12 >= v11.f32[0]))
  {
    float v10 = (const re::SkeletalPose *)*((void *)this + 13);
LABEL_23:
    re::SkeletalPoseSampledAnimation::copyPose(this, a4, v10, a6);
    return;
  }
  if (*((float *)this + 21) <= v11.f32[0])
  {
    float v10 = (const re::SkeletalPose *)(*((void *)this + 13) + 88 * v9 - 88);
    goto LABEL_23;
  }
  float v13 = (float)(v11.f32[0] - v12) / *((float *)this + 19);
  float v14 = floorf(v13);
  float v15 = v14 + ceilf(v13 - v14);
  unint64_t v16 = (unint64_t)(float)(v15 + 0.5);
  if (!*((unsigned char *)this + 73) || v9 == v16)
  {
    if (v9 <= v16) {
      unint64_t v30 = v9 - 1;
    }
    else {
      unint64_t v30 = (unint64_t)(float)(v15 + 0.5);
    }
    if (v9 <= v30)
    {
LABEL_164:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    float v10 = (const re::SkeletalPose *)(*((void *)this + 13) + 88 * v30);
    goto LABEL_23;
  }
  unint64_t v17 = v16 - 1;
  if (v9 <= v16 - 1)
  {
LABEL_162:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_163;
  }
  if (v9 <= v16)
  {
LABEL_163:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_164;
  }
  float v18 = v13 - (float)(v15 + -1.0);
  uint64_t v19 = *((void *)a4 + 10);
  uint64_t v20 = *(void *)(v19 + 192);
  unint64_t v149 = (unint64_t)(float)(v15 + 0.5);
  uint64_t v150 = *((void *)this + 13);
  v169 = (void *)(v150 + 88 * v17 + 80);
  float v171 = v18;
  unint64_t v148 = v16 - 1;
  if (*v169 == v19)
  {
    if (*((unsigned char *)this + 112))
    {
      if (v20)
      {
        uint64_t v31 = 0;
        unint64_t v32 = 0;
        uint64_t v33 = v150 + 88 * v17;
        float32x4_t v34 = (unint64_t *)(v33 + 24);
        uint64_t v35 = v150 + 88 * v16;
        long long v36 = (unint64_t *)(v35 + 24);
        v37 = (void *)(v33 + 32);
        v11.f32[0] = 1.0 - v18;
        float32x4_t v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        uint64_t v38 = (void *)(v35 + 32);
        while (*v34 > v32)
        {
          if (*v36 <= v32) {
            goto LABEL_141;
          }
          if (*((void *)a6 + 3) <= v32) {
            goto LABEL_142;
          }
          *(float32x4_t *)(*((void *)a6 + 4) + v31) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v38 + v31), v18), v11, *(float32x4_t *)(*v37 + v31));
          ++v32;
          v31 += 48;
          if (v20 == v32) {
            goto LABEL_92;
          }
        }
        goto LABEL_140;
      }
    }
    else if (v20)
    {
      uint64_t v95 = 0;
      unint64_t v96 = 0;
      while (*((void *)a4 + 3) > v96)
      {
        if (*((void *)a6 + 3) <= v96) {
          goto LABEL_157;
        }
        float32x4_t v11 = *(float32x4_t *)(*((void *)a4 + 4) + v95);
        *(float32x4_t *)(*((void *)a6 + 4) + v95) = v11;
        ++v96;
        v95 += 48;
        if (v20 == v96) {
          goto LABEL_92;
        }
      }
      goto LABEL_156;
    }
LABEL_92:
    if (*((unsigned char *)this + 113))
    {
      if (v20)
      {
        unint64_t v97 = 0;
        uint64_t v98 = v150 + 88 * v148;
        v159 = (unint64_t *)(v98 + 24);
        uint64_t v99 = v150 + 88 * v16;
        uint64_t v100 = (unint64_t *)(v99 + 24);
        long long v101 = (void *)(v98 + 32);
        long long v102 = (void *)(v99 + 32);
        float v103 = 1.0 - v18;
        uint64_t v104 = 16;
        while (*v159 > v97)
        {
          if (*v100 <= v97) {
            goto LABEL_149;
          }
          float32x4_t v105 = *(float32x4_t *)(*v101 + v104);
          float32x4_t v106 = *(float32x4_t *)(*v102 + v104);
          float32x4_t v107 = vmulq_f32(v105, v106);
          float32x4_t v108 = (float32x4_t)vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL);
          *(float32x2_t *)v107.f32 = vadd_f32(*(float32x2_t *)v107.f32, *(float32x2_t *)v108.f32);
          v107.f32[0] = vaddv_f32(*(float32x2_t *)v107.f32);
          v108.i64[0] = 0;
          float32x4_t v109 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v107, v108)), 0), (int8x16_t)vnegq_f32(v106), (int8x16_t)v106);
          float32x4_t v110 = vsubq_f32(v105, v109);
          int8x16_t v111 = (int8x16_t)vmulq_f32(v110, v110);
          float32x4_t v168 = v109;
          float32x4_t v170 = v105;
          float32x4_t v112 = vaddq_f32(v105, v109);
          int8x16_t v113 = (int8x16_t)vmulq_f32(v112, v112);
          float v114 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v111.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v111, v111, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v113.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL)))));
          float v115 = v114 + v114;
          float v116 = 1.0;
          float v117 = 1.0;
          if ((float)(v114 + v114) != 0.0) {
            float v117 = sinf(v114 + v114) / v115;
          }
          if ((float)(v103 * v115) != 0.0)
          {
            float v163 = v117;
            float v118 = sinf(v103 * v115);
            float v117 = v163;
            float v116 = v118 / (float)(v103 * v115);
          }
          float v119 = v171;
          float v120 = v171 * v115;
          float v121 = 1.0;
          if (v120 != 0.0)
          {
            float v164 = v117;
            float v122 = sinf(v120);
            float v119 = v171;
            float v117 = v164;
            float v121 = v122 / v120;
          }
          float v123 = v117;
          float32x2_t v124 = vrecpe_f32((float32x2_t)LODWORD(v117));
          float32x2_t v125 = vmul_f32(v124, vrecps_f32((float32x2_t)LODWORD(v123), v124));
          float v126 = vmul_f32(v125, vrecps_f32((float32x2_t)LODWORD(v123), v125)).f32[0];
          v125.f32[0] = v103 * (float)(v126 * v116);
          float32x4_t v11 = vmlaq_f32(vmulq_n_f32(v168, v119 * (float)(v126 * v121)), v170, (float32x4_t)vdupq_lane_s32((int32x2_t)v125, 0));
          int8x16_t v127 = (int8x16_t)vmulq_f32(v11, v11);
          float32x2_t v128 = vadd_f32(*(float32x2_t *)v127.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v127, v127, 8uLL));
          if (vaddv_f32(v128) == 0.0)
          {
            uint64_t v129 = 0;
            uint64_t v130 = 0x3F80000000000000;
          }
          else
          {
            unsigned __int32 v131 = vadd_f32(v128, (float32x2_t)vdup_lane_s32((int32x2_t)v128, 1)).u32[0];
            float32x2_t v132 = vrsqrte_f32((float32x2_t)v131);
            float32x2_t v133 = vmul_f32(v132, vrsqrts_f32((float32x2_t)v131, vmul_f32(v132, v132)));
            float32x4_t v11 = vmulq_n_f32(v11, vmul_f32(v133, vrsqrts_f32((float32x2_t)v131, vmul_f32(v133, v133))).f32[0]);
            uint64_t v130 = v11.i64[1];
            uint64_t v129 = v11.i64[0];
          }
          if (*((void *)a6 + 3) <= v97) {
            goto LABEL_150;
          }
          v134 = (uint64_t *)(*((void *)a6 + 4) + v104);
          uint64_t *v134 = v129;
          v134[1] = v130;
          ++v97;
          v104 += 48;
          if (v20 == v97) {
            goto LABEL_114;
          }
        }
        goto LABEL_148;
      }
    }
    else if (v20)
    {
      unint64_t v135 = 0;
      uint64_t v136 = 16;
      while (*((void *)a4 + 3) > v135)
      {
        if (*((void *)a6 + 3) <= v135) {
          goto LABEL_159;
        }
        float32x4_t v11 = *(float32x4_t *)(*((void *)a4 + 4) + v136);
        *(float32x4_t *)(*((void *)a6 + 4) + v136) = v11;
        ++v135;
        v136 += 48;
        if (v20 == v135) {
          goto LABEL_114;
        }
      }
LABEL_158:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_159:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_160;
    }
LABEL_114:
    if (*((unsigned char *)this + 114))
    {
      if (v20)
      {
        unint64_t v137 = 0;
        uint64_t v138 = v150 + 88 * v148;
        v139 = (unint64_t *)(v138 + 24);
        uint64_t v140 = v150 + 88 * v149;
        v141 = (unint64_t *)(v140 + 24);
        v142 = (void *)(v138 + 32);
        v11.f32[0] = 1.0 - v171;
        float32x4_t v143 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        v144 = (void *)(v140 + 32);
        uint64_t v145 = 32;
        while (*v139 > v137)
        {
          if (*v141 <= v137) {
            goto LABEL_154;
          }
          if (*((void *)a6 + 3) <= v137) {
            goto LABEL_155;
          }
          *(float32x4_t *)(*((void *)a6 + 4) + v145) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v144 + v145), v171), v143, *(float32x4_t *)(*v142 + v145));
          ++v137;
          v145 += 48;
          if (v20 == v137) {
            return;
          }
        }
        goto LABEL_153;
      }
    }
    else if (v20)
    {
      unint64_t v146 = 0;
      uint64_t v147 = 32;
      while (*((void *)a4 + 3) > v146)
      {
        if (*((void *)a6 + 3) <= v146) {
          goto LABEL_161;
        }
        *(_OWORD *)(*((void *)a6 + 4) + v147) = *(_OWORD *)(*((void *)a4 + 4) + v147);
        ++v146;
        v147 += 48;
        if (v20 == v146) {
          return;
        }
      }
LABEL_160:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_161:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_162;
    }
  }
  else
  {
    if (*((unsigned char *)this + 112))
    {
      if (v20)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        unint64_t v23 = 0;
        uint64_t v24 = v150 + 88 * v148;
        v165 = (unint64_t *)(v24 + 24);
        uint64_t v25 = v150 + 88 * v149;
        v160 = (unint64_t *)(v25 + 24);
        v155 = (void *)(v24 + 32);
        v11.f32[0] = 1.0 - v18;
        float32x4_t v153 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        long long v26 = (void *)(v25 + 32);
        do
        {
          uint64_t v27 = *((void *)a4 + 10);
          if (*(void *)(v27 + 192) <= v23) {
            goto LABEL_129;
          }
          long long v28 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (void *)(*(void *)(v27 + 200) + v21));
          if (v28)
          {
            unint64_t v29 = *v28;
            if (*v165 <= *v28) {
              goto LABEL_132;
            }
            if (*v160 <= v29) {
              goto LABEL_133;
            }
            if (*((void *)a6 + 3) <= v23) {
              goto LABEL_134;
            }
            float32x4_t v11 = *(float32x4_t *)(*v155 + 48 * v29);
            *(float32x4_t *)(*((void *)a6 + 4) + v22) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v26 + 48 * v29), v171), v153, v11);
          }
          ++v23;
          v22 += 48;
          v21 += 16;
        }
        while (v20 != v23);
      }
    }
    else if (v20)
    {
      uint64_t v39 = 0;
      unint64_t v40 = 0;
      while (*((void *)a4 + 3) > v40)
      {
        if (*((void *)a6 + 3) <= v40) {
          goto LABEL_139;
        }
        float32x4_t v11 = *(float32x4_t *)(*((void *)a4 + 4) + v39);
        *(float32x4_t *)(*((void *)a6 + 4) + v39) = v11;
        ++v40;
        v39 += 48;
        if (v20 == v40) {
          goto LABEL_45;
        }
      }
      goto LABEL_138;
    }
LABEL_45:
    if (*((unsigned char *)this + 113))
    {
      if (v20)
      {
        uint64_t v41 = 0;
        unint64_t v42 = 0;
        uint64_t v43 = v150 + 88 * v148;
        v154 = (unint64_t *)(v43 + 24);
        uint64_t v44 = v150 + 88 * v149;
        v151 = (void *)(v43 + 32);
        v152 = (unint64_t *)(v44 + 24);
        uint64_t v45 = (void *)(v44 + 32);
        float v46 = 1.0 - v171;
        uint64_t v47 = 16;
        do
        {
          uint64_t v48 = *((void *)a4 + 10);
          if (*(void *)(v48 + 192) <= v42) {
            goto LABEL_130;
          }
          uint64_t v49 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (void *)(*(void *)(v48 + 200) + v41));
          if (v49)
          {
            unint64_t v50 = *v49;
            if (*v154 <= *v49) {
              goto LABEL_135;
            }
            if (*v152 <= v50) {
              goto LABEL_136;
            }
            float32x4_t v51 = *(float32x4_t *)(*v151 + 48 * v50 + 16);
            float32x4_t v52 = *(float32x4_t *)(*v45 + 48 * v50 + 16);
            float32x4_t v53 = vmulq_f32(v51, v52);
            float32x4_t v54 = (float32x4_t)vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL);
            *(float32x2_t *)v53.f32 = vadd_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v54.f32);
            v53.f32[0] = vaddv_f32(*(float32x2_t *)v53.f32);
            v54.i64[0] = 0;
            float32x4_t v55 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v53, v54)), 0), (int8x16_t)vnegq_f32(v52), (int8x16_t)v52);
            float32x4_t v56 = vsubq_f32(v51, v55);
            int8x16_t v57 = (int8x16_t)vmulq_f32(v56, v56);
            float32x4_t v161 = v55;
            float32x4_t v166 = v51;
            float32x4_t v58 = vaddq_f32(v51, v55);
            int8x16_t v59 = (int8x16_t)vmulq_f32(v58, v58);
            float v60 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v57.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL)))));
            float v61 = v60 + v60;
            float v62 = 1.0;
            float v63 = 1.0;
            if ((float)(v60 + v60) != 0.0) {
              float v63 = sinf(v60 + v60) / v61;
            }
            if ((float)(v46 * v61) != 0.0)
            {
              float v156 = v63;
              float v64 = sinf(v46 * v61);
              float v63 = v156;
              float v62 = v64 / (float)(v46 * v61);
            }
            float v65 = v171;
            float v66 = v171 * v61;
            float v67 = 1.0;
            if (v66 != 0.0)
            {
              float v157 = v63;
              float v68 = sinf(v66);
              float v65 = v171;
              float v63 = v157;
              float v67 = v68 / v66;
            }
            float v69 = v63;
            float32x2_t v70 = vrecpe_f32((float32x2_t)LODWORD(v63));
            float32x2_t v71 = vmul_f32(v70, vrecps_f32((float32x2_t)LODWORD(v69), v70));
            float v72 = vmul_f32(v71, vrecps_f32((float32x2_t)LODWORD(v69), v71)).f32[0];
            v71.f32[0] = v46 * (float)(v72 * v62);
            float32x4_t v11 = vmlaq_f32(vmulq_n_f32(v161, v65 * (float)(v72 * v67)), v166, (float32x4_t)vdupq_lane_s32((int32x2_t)v71, 0));
            int8x16_t v73 = (int8x16_t)vmulq_f32(v11, v11);
            float32x2_t v74 = vadd_f32(*(float32x2_t *)v73.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL));
            if (vaddv_f32(v74) == 0.0)
            {
              uint64_t v75 = 0;
              uint64_t v76 = 0x3F80000000000000;
            }
            else
            {
              unsigned __int32 v77 = vadd_f32(v74, (float32x2_t)vdup_lane_s32((int32x2_t)v74, 1)).u32[0];
              float32x2_t v78 = vrsqrte_f32((float32x2_t)v77);
              float32x2_t v79 = vmul_f32(v78, vrsqrts_f32((float32x2_t)v77, vmul_f32(v78, v78)));
              float32x4_t v11 = vmulq_n_f32(v11, vmul_f32(v79, vrsqrts_f32((float32x2_t)v77, vmul_f32(v79, v79))).f32[0]);
              uint64_t v76 = v11.i64[1];
              uint64_t v75 = v11.i64[0];
            }
            if (*((void *)a6 + 3) <= v42) {
              goto LABEL_137;
            }
            int v80 = (uint64_t *)(*((void *)a6 + 4) + v47);
            *int v80 = v75;
            v80[1] = v76;
          }
          ++v42;
          v47 += 48;
          v41 += 16;
        }
        while (v20 != v42);
      }
    }
    else if (v20)
    {
      unint64_t v81 = 0;
      uint64_t v82 = 16;
      while (*((void *)a4 + 3) > v81)
      {
        if (*((void *)a6 + 3) <= v81) {
          goto LABEL_147;
        }
        float32x4_t v11 = *(float32x4_t *)(*((void *)a4 + 4) + v82);
        *(float32x4_t *)(*((void *)a6 + 4) + v82) = v11;
        ++v81;
        v82 += 48;
        if (v20 == v81) {
          goto LABEL_70;
        }
      }
LABEL_146:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_147:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_148:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_149:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_150:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_151;
    }
LABEL_70:
    if (*((unsigned char *)this + 114))
    {
      if (v20)
      {
        uint64_t v83 = 0;
        unint64_t v84 = 0;
        uint64_t v85 = v150 + 88 * v148;
        v167 = (unint64_t *)(v85 + 24);
        uint64_t v86 = v150 + 88 * v149;
        v162 = (unint64_t *)(v86 + 24);
        v87 = (void *)(v85 + 32);
        v11.f32[0] = 1.0 - v171;
        float32x4_t v158 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        int v88 = (void *)(v86 + 32);
        for (uint64_t i = 32; ; i += 48)
        {
          uint64_t v90 = *((void *)a4 + 10);
          if (*(void *)(v90 + 192) <= v84) {
            break;
          }
          size_t v91 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (void *)(*(void *)(v90 + 200) + v83));
          if (v91)
          {
            unint64_t v92 = *v91;
            if (*v167 <= *v91) {
              goto LABEL_143;
            }
            if (*v162 <= v92) {
              goto LABEL_144;
            }
            if (*((void *)a6 + 3) <= v84) {
              goto LABEL_145;
            }
            *(float32x4_t *)(*((void *)a6 + 4) + i) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v88 + 48 * v92 + 32), v171), v158, *(float32x4_t *)(*v87 + 48 * v92 + 32));
          }
          ++v84;
          v83 += 16;
          if (v20 == v84) {
            return;
          }
        }
        goto LABEL_131;
      }
    }
    else if (v20)
    {
      unint64_t v93 = 0;
      uint64_t v94 = 32;
      while (*((void *)a4 + 3) > v93)
      {
        if (*((void *)a6 + 3) <= v93) {
          goto LABEL_152;
        }
        *(_OWORD *)(*((void *)a6 + 4) + v94) = *(_OWORD *)(*((void *)a4 + 4) + v94);
        ++v93;
        v94 += 48;
        if (v20 == v93) {
          return;
        }
      }
LABEL_151:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_152:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_153:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_154:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_155:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_156:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_157:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_158;
    }
  }
}

__n128 re::SkeletalPoseSampledAnimation::copyPose(re::SkeletalPoseSampledAnimation *this, const re::SkeletalPose *a2, const re::SkeletalPose *a3, re::SkeletalPose *a4)
{
  uint64_t v6 = *((void *)a4 + 10);
  uint64_t v7 = *(void *)(v6 + 192);
  uint64_t v8 = *((void *)a3 + 10);
  if (v8 == v6)
  {
    if (*((unsigned char *)this + 112)) {
      BOOL v41 = v7 == 0;
    }
    else {
      BOOL v41 = 1;
    }
    if (v41)
    {
LABEL_57:
      if (*((unsigned char *)this + 113)) {
        BOOL v44 = v7 == 0;
      }
      else {
        BOOL v44 = 1;
      }
      if (v44)
      {
LABEL_65:
        if (!*((unsigned char *)this + 114) || !v7) {
          return result;
        }
        unint64_t v47 = 0;
        uint64_t v48 = 32;
        while (*((void *)a3 + 3) > v47)
        {
          if (*((void *)a4 + 3) <= v47) {
            goto LABEL_140;
          }
          __n128 result = *(__n128 *)(*((void *)a3 + 4) + v48);
          *(__n128 *)(*((void *)a4 + 4) + v48) = result;
          ++v47;
          v48 += 48;
          if (v7 == v47) {
            return result;
          }
        }
        goto LABEL_139;
      }
      unint64_t v45 = 0;
      uint64_t v46 = 16;
      while (*((void *)a3 + 3) > v45)
      {
        if (*((void *)a4 + 3) <= v45) {
          goto LABEL_138;
        }
        __n128 result = *(__n128 *)(*((void *)a3 + 4) + v46);
        *(__n128 *)(*((void *)a4 + 4) + v46) = result;
        ++v45;
        v46 += 48;
        if (v7 == v45) {
          goto LABEL_65;
        }
      }
    }
    else
    {
      uint64_t v42 = 0;
      unint64_t v43 = 0;
      while (*((void *)a3 + 3) > v43)
      {
        if (*((void *)a4 + 3) <= v43) {
          goto LABEL_136;
        }
        __n128 result = *(__n128 *)(*((void *)a3 + 4) + v42);
        *(__n128 *)(*((void *)a4 + 4) + v42) = result;
        ++v43;
        v42 += 48;
        if (v7 == v43) {
          goto LABEL_57;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_136:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_138:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_139:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_141:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_143;
  }
  uint64_t v10 = *((void *)a2 + 10);
  if (v8 == v10)
  {
    if (*((unsigned char *)this + 112)) {
      BOOL v50 = v7 == 0;
    }
    else {
      BOOL v50 = 1;
    }
    if (v50)
    {
LABEL_83:
      if (!*((unsigned char *)this + 113) || !v7)
      {
LABEL_92:
        if (!*((unsigned char *)this + 114) || !v7) {
          return result;
        }
        uint64_t v61 = 0;
        unint64_t v62 = 0;
        for (uint64_t i = 32; ; i += 48)
        {
          uint64_t v64 = *((void *)a4 + 10);
          if (*(void *)(v64 + 192) <= v62) {
            break;
          }
          float v65 = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v64 + 200) + v61));
          if (v65)
          {
            if (*((void *)a3 + 3) <= *v65) {
              goto LABEL_159;
            }
            if (*((void *)a4 + 3) <= v62) {
              goto LABEL_160;
            }
            __n128 result = *(__n128 *)(*((void *)a3 + 4) + 48 * *v65 + 32);
            *(__n128 *)(*((void *)a4 + 4) + i) = result;
          }
          ++v62;
          v61 += 16;
          if (v7 == v62) {
            return result;
          }
        }
        goto LABEL_146;
      }
      uint64_t v56 = 0;
      unint64_t v57 = 0;
      uint64_t v58 = 16;
      while (1)
      {
        uint64_t v59 = *((void *)a4 + 10);
        if (*(void *)(v59 + 192) <= v57) {
          break;
        }
        float v60 = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v59 + 200) + v56));
        if (v60)
        {
          if (*((void *)a3 + 3) <= *v60) {
            goto LABEL_156;
          }
          if (*((void *)a4 + 3) <= v57) {
            goto LABEL_157;
          }
          __n128 result = *(__n128 *)(*((void *)a3 + 4) + 48 * *v60 + 16);
          *(__n128 *)(*((void *)a4 + 4) + v58) = result;
        }
        ++v57;
        v58 += 48;
        v56 += 16;
        if (v7 == v57) {
          goto LABEL_92;
        }
      }
LABEL_145:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_146:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_147:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_148:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_149:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_150:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_151:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_152:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_153:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_154:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_155;
    }
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    unint64_t v53 = 0;
    while (1)
    {
      uint64_t v54 = *((void *)a4 + 10);
      if (*(void *)(v54 + 192) <= v53) {
        break;
      }
      float32x4_t v55 = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v54 + 200) + v51));
      if (v55)
      {
        if (*((void *)a3 + 3) <= *v55) {
          goto LABEL_151;
        }
        if (*((void *)a4 + 3) <= v53) {
          goto LABEL_152;
        }
        __n128 result = *(__n128 *)(*((void *)a3 + 4) + 48 * *v55);
        *(__n128 *)(*((void *)a4 + 4) + v52) = result;
      }
      ++v53;
      v52 += 48;
      v51 += 16;
      if (v7 == v53) {
        goto LABEL_83;
      }
    }
LABEL_143:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_145;
  }
  if (*((unsigned char *)this + 112)) {
    BOOL v11 = v7 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  int v12 = !v11;
  if (v6 == v10)
  {
    if (!v12)
    {
LABEL_112:
      if (!*((unsigned char *)this + 113) || !v7)
      {
LABEL_123:
        if (!*((unsigned char *)this + 114) || !v7) {
          return result;
        }
        uint64_t v80 = 0;
        unint64_t v81 = 0;
        for (uint64_t j = 32; ; j += 48)
        {
          uint64_t v83 = *((void *)a4 + 10);
          if (*(void *)(v83 + 192) <= v81) {
            break;
          }
          unint64_t v84 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v83 + 200) + v80));
          if (v84)
          {
            unint64_t v85 = *v84;
            if (*((void *)a3 + 3) <= (unint64_t)*v84) {
              goto LABEL_166;
            }
            uint64_t v86 = a3;
            if (*((void *)a4 + 3) <= v81) {
              goto LABEL_167;
            }
          }
          else
          {
            if (*((void *)a2 + 3) <= v81) {
              goto LABEL_178;
            }
            uint64_t v86 = a2;
            unint64_t v85 = v81;
            if (*((void *)a4 + 3) <= v81) {
              goto LABEL_179;
            }
          }
          __n128 result = *(__n128 *)(*((void *)v86 + 4) + 48 * v85 + 32);
          *(__n128 *)(*((void *)a4 + 4) + j) = result;
          ++v81;
          v80 += 16;
          if (v7 == v81) {
            return result;
          }
        }
LABEL_161:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_162:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_163:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_164:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_165:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_166:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_167:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_168:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_169:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_170:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_171:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_172:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_173:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_174:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_175:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_176:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_177:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_178:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_179:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v73 = 0;
      unint64_t v74 = 0;
      uint64_t v75 = 16;
      while (1)
      {
        uint64_t v76 = *((void *)a4 + 10);
        if (*(void *)(v76 + 192) <= v74) {
          break;
        }
        unsigned __int32 v77 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v76 + 200) + v73));
        if (v77)
        {
          unint64_t v78 = *v77;
          if (*((void *)a3 + 3) <= (unint64_t)*v77) {
            goto LABEL_164;
          }
          float32x2_t v79 = a3;
          if (*((void *)a4 + 3) <= v74) {
            goto LABEL_165;
          }
        }
        else
        {
          if (*((void *)a2 + 3) <= v74) {
            goto LABEL_176;
          }
          float32x2_t v79 = a2;
          unint64_t v78 = v74;
          if (*((void *)a4 + 3) <= v74) {
            goto LABEL_177;
          }
        }
        __n128 result = *(__n128 *)(*((void *)v79 + 4) + 48 * v78 + 16);
        *(__n128 *)(*((void *)a4 + 4) + v75) = result;
        ++v74;
        v73 += 16;
        v75 += 48;
        if (v7 == v74) {
          goto LABEL_123;
        }
      }
LABEL_158:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_159:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_160:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_161;
    }
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    unint64_t v68 = 0;
    while (1)
    {
      uint64_t v69 = *((void *)a4 + 10);
      if (*(void *)(v69 + 192) <= v68) {
        break;
      }
      float32x2_t v70 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, (void *)(*(void *)(v69 + 200) + v67));
      if (v70)
      {
        unint64_t v71 = *v70;
        if (*((void *)a3 + 3) <= (unint64_t)*v70) {
          goto LABEL_162;
        }
        float v72 = a3;
        if (*((void *)a4 + 3) <= v68) {
          goto LABEL_163;
        }
      }
      else
      {
        if (*((void *)a2 + 3) <= v68) {
          goto LABEL_174;
        }
        float v72 = a2;
        unint64_t v71 = v68;
        if (*((void *)a4 + 3) <= v68) {
          goto LABEL_175;
        }
      }
      __n128 result = *(__n128 *)(*((void *)v72 + 4) + 48 * v71);
      *(__n128 *)(*((void *)a4 + 4) + v66) = result;
      ++v68;
      v67 += 16;
      v66 += 48;
      if (v7 == v68) {
        goto LABEL_112;
      }
    }
LABEL_155:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_156:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_157:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_158;
  }
  if (v12)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    while (1)
    {
      uint64_t v16 = *((void *)a4 + 10);
      if (*(void *)(v16 + 192) <= v15) {
        goto LABEL_141;
      }
      unint64_t v17 = (void *)(*(void *)(v16 + 200) + v14);
      float v18 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, v17);
      if (v18) {
        break;
      }
      uint64_t v21 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a2 + 10) + 208, v17);
      if (v21)
      {
        uint64_t v19 = *v21;
        if (*((void *)a2 + 3) <= (unint64_t)*v21) {
          goto LABEL_168;
        }
        uint64_t v20 = a2;
        if (*((void *)a4 + 3) <= v15) {
          goto LABEL_169;
        }
        goto LABEL_20;
      }
LABEL_21:
      ++v15;
      v14 += 16;
      v13 += 48;
      if (v7 == v15) {
        goto LABEL_22;
      }
    }
    uint64_t v19 = *v18;
    if (*((void *)a3 + 3) <= (unint64_t)*v18) {
      goto LABEL_147;
    }
    uint64_t v20 = a3;
    if (*((void *)a4 + 3) <= v15) {
      goto LABEL_148;
    }
LABEL_20:
    __n128 result = *(__n128 *)(*((void *)v20 + 4) + 48 * v19);
    *(__n128 *)(*((void *)a4 + 4) + v13) = result;
    goto LABEL_21;
  }
LABEL_22:
  if (*((unsigned char *)this + 113) && v7)
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    uint64_t v25 = 16;
    while (1)
    {
      uint64_t v26 = *((void *)a4 + 10);
      if (*(void *)(v26 + 192) <= v24) {
        goto LABEL_142;
      }
      uint64_t v27 = (void *)(*(void *)(v26 + 200) + v23);
      long long v28 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, v27);
      if (v28) {
        break;
      }
      uint64_t v31 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a2 + 10) + 208, v27);
      if (v31)
      {
        uint64_t v29 = *v31;
        if (*((void *)a2 + 3) <= (unint64_t)*v31) {
          goto LABEL_170;
        }
        unint64_t v30 = a2;
        if (*((void *)a4 + 3) <= v24) {
          goto LABEL_171;
        }
        goto LABEL_33;
      }
LABEL_34:
      ++v24;
      v23 += 16;
      v25 += 48;
      if (v7 == v24) {
        goto LABEL_35;
      }
    }
    uint64_t v29 = *v28;
    if (*((void *)a3 + 3) <= (unint64_t)*v28) {
      goto LABEL_149;
    }
    unint64_t v30 = a3;
    if (*((void *)a4 + 3) <= v24) {
      goto LABEL_150;
    }
LABEL_33:
    __n128 result = *(__n128 *)(*((void *)v30 + 4) + 48 * v29 + 16);
    *(__n128 *)(*((void *)a4 + 4) + v25) = result;
    goto LABEL_34;
  }
LABEL_35:
  if (*((unsigned char *)this + 114) && v7)
  {
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    for (uint64_t k = 32; ; k += 48)
    {
      uint64_t v35 = *((void *)a4 + 10);
      if (*(void *)(v35 + 192) <= v33) {
        goto LABEL_144;
      }
      long long v36 = (void *)(*(void *)(v35 + 200) + v32);
      v37 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a3 + 10) + 208, v36);
      if (v37) {
        break;
      }
      unint64_t v40 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((void *)a2 + 10) + 208, v36);
      if (v40)
      {
        uint64_t v38 = *v40;
        if (*((void *)a2 + 3) <= (unint64_t)*v40) {
          goto LABEL_172;
        }
        uint64_t v39 = a2;
        if (*((void *)a4 + 3) <= v33) {
          goto LABEL_173;
        }
        goto LABEL_46;
      }
LABEL_47:
      ++v33;
      v32 += 16;
      if (v7 == v33) {
        return result;
      }
    }
    uint64_t v38 = *v37;
    if (*((void *)a3 + 3) <= (unint64_t)*v37) {
      goto LABEL_153;
    }
    uint64_t v39 = a3;
    if (*((void *)a4 + 3) <= v33) {
      goto LABEL_154;
    }
LABEL_46:
    __n128 result = *(__n128 *)(*((void *)v39 + 4) + 48 * v38 + 32);
    *(__n128 *)(*((void *)a4 + 4) + k) = result;
    goto LABEL_47;
  }
  return result;
}

uint64_t *re::SampledAnimation<float>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0C50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<float>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0C50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::SampledAnimation<double>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0CD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<double>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0CD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

uint64_t *re::SampledAnimation<re::Vector2<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0D50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::Vector2<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0D50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

uint64_t *re::SampledAnimation<re::Vector3<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0DD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::Vector3<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0DD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

uint64_t *re::SampledAnimation<re::Vector4<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0E50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::Vector4<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0E50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

uint64_t *re::SampledAnimation<re::Quaternion<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0ED0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::Quaternion<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0ED0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

uint64_t *re::SampledAnimation<re::GenericSRT<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0F50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::GenericSRT<float>>::~SampledAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C0F50;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

void *re::SampledAnimation<re::SkeletalPose>::~SampledAnimation(void *a1)
{
  *a1 = &unk_26E6C0FD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::SkeletalPose>::deinit(a1 + 11);
  *a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::SkeletalPose>::~SampledAnimation(void *a1)
{
  *a1 = &unk_26E6C0FD0;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::SkeletalPose>::deinit(a1 + 11);
  *a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationImpl<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

void re::SkeletalPoseSampledAnimation::~SkeletalPoseSampledAnimation(re::SkeletalPoseSampledAnimation *this)
{
  *(void *)this = &unk_26E6C0FD0;
  v2 = (re::SkeletalPoseSampledAnimation *)((char *)this + 40);
  re::FixedArray<re::SkeletalPose>::deinit((void *)this + 11);
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::SkeletalPoseSampledAnimation *)((char *)this + 24));
}

{
  re::DynamicString *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6C0FD0;
  v2 = (re::SkeletalPoseSampledAnimation *)((char *)this + 40);
  re::FixedArray<re::SkeletalPose>::deinit((void *)this + 11);
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::SkeletalPoseSampledAnimation *)((char *)this + 24));
  JUMPOUT(0x237DBCBD0);
}

void *re::SampledAnimation<re::BlendShapeWeights>::~SampledAnimation(void *a1)
{
  *a1 = &unk_26E6C1050;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::BlendShapeWeights>::deinit(a1 + 11);
  *a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::SampledAnimation<re::BlendShapeWeights>::~SampledAnimation(void *a1)
{
  *a1 = &unk_26E6C1050;
  v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::BlendShapeWeights>::deinit(a1 + 11);
  *a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Animation<re::BlendShapeWeights>::animationValueType()
{
  v0 = &qword_268772000;
  {
    v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::BlendShapeWeights>(void)::info = re::introspect_BlendShapeWeights(0);
      v0 = &qword_268772000;
    }
  }
  return v0[50];
}

float re::AnimationImpl<re::BlendShapeWeights>::timelineDesc@<S0>(unsigned char *a1@<X0>, uint64_t a2@<X8>)
{
  double v4 = (*(double (**)(unsigned char *))(*(void *)a1 + 40))(a1);
  *(_DWORD *)a2 = 0;
  float result = v4;
  *(float *)(a2 + 4) = result;
  *(void *)(a2 + 8) = 1065353216;
  *(float *)(a2 + 16) = result;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 25) = a1[16];
  return result;
}

double re::AnimationImpl<re::BlendShapeWeights>::makeCompositionChain(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
  double result = 0.0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + 40) = 0;
  *(void *)(v2 + 88) = 0;
  *(void *)(v2 + 96) = 0;
  *(unsigned char *)(v2 + 104) = 0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_DWORD *)(v2 + 80) = 0;
  *(void *)uint64_t v2 = &unk_26E6BED78;
  *(unsigned char *)(v2 + 112) = 0;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::isValidBindPoint(int a1, re::BindPoint *this)
{
  if (!*((void *)this + 3)) {
    return 0;
  }
  uint64_t v2 = &qword_268772000;
  {
    float32x4_t v5 = this;
    uint64_t v2 = &qword_268772000;
    this = v5;
    if (v4)
    {
      re::introspect<re::BlendShapeWeights>(void)::info = re::introspect_BlendShapeWeights(0);
      uint64_t v2 = &qword_268772000;
      this = v5;
    }
  }
  if (v2[50] != *(void *)this) {
    return 0;
  }
  uint64_t result = re::BindPoint::valueUntyped(this);
  if (result) {
    return *(void *)(result + 24) != 0;
  }
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::evaluate(_DWORD *a1, unsigned char *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6)
{
  if (a3)
  {
    if (a2[16]) {
      BOOL v12 = *a2 == 2;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12 || (uint64_t result = (uint64_t)re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6), a1[2] == 49))
    {
      uint64_t v14 = *(uint64_t (**)(_DWORD *, unsigned char *, uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)a1 + 96);
      return v14(a1, a2, a3, a4, a5, a6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

void *re::FixedArray<re::SkeletalPose>::deinit(void *result)
{
  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      int v4 = (re::SkeletalPose *)result[2];
      uint64_t v5 = 88 * v2;
      do
      {
        re::SkeletalPose::~SkeletalPose(v4);
        int v4 = (re::SkeletalPose *)(v6 + 88);
        v5 -= 88;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      void *v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::BlendShapeWeights>::deinit(void *result)
{
  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      int v4 = (re::BlendShapeWeights *)result[2];
      uint64_t v5 = 32 * v2;
      do
      {
        re::BlendShapeWeights::~BlendShapeWeights(v4);
        int v4 = (re::BlendShapeWeights *)(v6 + 32);
        v5 -= 32;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      void *v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::StateMachineParameterBinding::indexOf@<X0>(uint64_t result@<X0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(void *)(result + 16);
  if (v5)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(result + 32);
    while (1)
    {
      uint64_t result = re::StringID::operator==((void *)v9, a2);
      if (result)
      {
        if (*(unsigned __int8 *)(v9 + 16) == a3) {
          break;
        }
      }
      ++v8;
      v9 += 40;
      if (v5 == v8) {
        goto LABEL_6;
      }
    }
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v8;
  }
  else
  {
LABEL_6:
    *(unsigned char *)a4 = 0;
  }
  return result;
}

unint64_t *re::StateMachineParameterBinding::setBindTarget(re::StateMachineParameterBinding *this, unint64_t a2, const re::StringID *a3)
{
  if (*((void *)this + 2) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t result = re::StringID::operator=((unint64_t *)(*((void *)this + 4) + 40 * a2 + 24), (uint64_t *)a3);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::StateMachineParameterBinding::add(void *a1, const StringID *a2, char a3, const StringID *a4)
{
  re::StringID::StringID((re::StringID *)v7, a2);
  char v8 = a3;
  re::StringID::StringID((re::StringID *)v9, a4);
  re::DynamicArray<re::StateMachineParameterBindingItem>::add(a1, v7);
  re::StringID::destroyString((re::StringID *)v9);
  re::StringID::destroyString((re::StringID *)v7);
}

void *re::DynamicArray<re::StateMachineParameterBindingItem>::add(void *this, uint64_t *a2)
{
  v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::StateMachineParameterBindingItem>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4] + 40 * v4;
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)uint64_t v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  *(unsigned char *)(v5 + 16) = *((unsigned char *)a2 + 16);
  uint64_t v7 = a2[3];
  *(void *)(v5 + 24) = *(void *)(v5 + 24) & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  *(void *)(v5 + 24) = a2[3] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  *(void *)(v5 + 32) = a2[4];
  a2[3] = 0;
  a2[4] = (uint64_t)"";
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::DynamicArray<re::StateMachineParameterBindingItem>::removeAt(uint64_t a1, unint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    memset(v17, 0, sizeof(v17));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = v4 + 40 * v2;
    uint64_t v6 = v4 + 40 * a2;
    uint64_t v7 = *(void *)(v5 - 40);
    uint64_t v8 = *(void *)(v5 - 32);
    *(void *)(v5 - 40) = 0;
    *(void *)(v5 - 32) = "";
    uint64_t v9 = *(void *)(v6 + 8);
    unint64_t v10 = v7 & 0xFFFFFFFFFFFFFFFELL | *(void *)v6 & 1;
    *(void *)(v6 + 8) = v8;
    *(void *)&v17[0] = v10;
    *((void *)&v17[0] + 1) = v9;
    *(void *)uint64_t v6 = v7;
    re::StringID::destroyString((re::StringID *)v17);
    *(unsigned char *)(v6 + 16) = *(unsigned char *)(v5 - 24);
    uint64_t v11 = *(void *)(v5 - 16);
    uint64_t v12 = *(void *)(v5 - 8);
    *(void *)(v5 - 16) = 0;
    *(void *)(v5 - 8) = "";
    uint64_t v13 = *(void *)(v6 + 32);
    unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v6 + 24) & 1;
    *(void *)(v6 + 32) = v12;
    *(void *)&v17[0] = v14;
    *((void *)&v17[0] + 1) = v13;
    *(void *)(v6 + 24) = v11;
    re::StringID::destroyString((re::StringID *)v17);
    unint64_t v2 = *(void *)(a1 + 16);
  }
  uint64_t v15 = *(void *)(a1 + 32) + 40 * v2;
  uint64_t v16 = (re::StringID *)(v15 - 40);
  re::StringID::destroyString((re::StringID *)(v15 - 16));
  re::StringID::destroyString(v16);
  --*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

void *re::allocInfo_StateMachineParameterBindingItem(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72628, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72628))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF72720, "StateMachineParameterBindingItem");
    __cxa_guard_release(&qword_26AF72628);
  }
  return &unk_26AF72720;
}

void re::initInfo_StateMachineParameterBindingItem(re *this, re::IntrospectionBase *a2)
{
  uint64_t v53 = 0x17066B9AB678EF0ALL;
  uint64_t v54 = "StateMachineParameterBindingItem";
  re::StringID::destroyString((re::StringID *)&v53);
  *((_OWORD *)this + 2) = v49;
  if (atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72620, memory_order_acquire)) {
    goto LABEL_2;
  }
  uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72620);
  if (!v4) {
    goto LABEL_2;
  }
  uint64_t v5 = re::introspectionAllocator(v4);
  uint64_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
  uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
  *(_DWORD *)uint64_t v8 = 1;
  *(void *)(v8 + 8) = "m_name";
  *(void *)(v8 + 16) = v7;
  *(void *)(v8 + 24) = 0;
  *(void *)(v8 + 32) = 1;
  *(_DWORD *)(v8 + 40) = 0;
  *(void *)(v8 + 48) = 0;
  *(void *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 64) = 0;
  qword_26AF72660 = v8;
  unint64_t v10 = re::introspectionAllocator((re *)v8);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72610, memory_order_acquire) & 1) == 0)
  {
    uint64_t v38 = (re *)__cxa_guard_acquire(&qword_26AF72610);
    if (v38)
    {
      uint64_t v39 = re::introspectionAllocator(v38);
      unint64_t v40 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v39 + 32))(v39, 24, 8);
      *(_DWORD *)unint64_t v40 = 1;
      *((void *)v40 + 1) = 0;
      *((void *)v40 + 2) = "Invalid";
      qword_26AF72678 = (uint64_t)v40;
      BOOL v41 = re::introspectionAllocator(v40);
      uint64_t v42 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v41 + 32))(v41, 24, 8);
      *(_DWORD *)uint64_t v42 = 1;
      *((void *)v42 + 1) = 1;
      *((void *)v42 + 2) = "Int";
      qword_26AF72680 = (uint64_t)v42;
      unint64_t v43 = re::introspectionAllocator(v42);
      BOOL v44 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v43 + 32))(v43, 24, 8);
      *(_DWORD *)BOOL v44 = 1;
      *((void *)v44 + 1) = 2;
      *((void *)v44 + 2) = "Float";
      qword_26AF72688 = (uint64_t)v44;
      unint64_t v45 = re::introspectionAllocator(v44);
      uint64_t v46 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v45 + 32))(v45, 24, 8);
      *(_DWORD *)uint64_t v46 = 1;
      *(void *)(v46 + 8) = 3;
      *(void *)(v46 + 16) = "Bool";
      qword_26AF72690 = v46;
      __cxa_guard_release(&qword_26AF72610);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72618))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF726D8, "REStateMachineParameterType", 1, 1, 1, 1);
    qword_26AF726D8 = (uint64_t)&unk_26E715E00;
    qword_26AF72718 = (uint64_t)&introspect_REStateMachineParameterType(BOOL)::enumTable;
    dword_26AF726E8 = 9;
    __cxa_guard_release(&qword_26AF72618);
  }
  if (_MergedGlobals_14)
  {
LABEL_33:
    uint64_t v33 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 72, 8);
    *(_DWORD *)uint64_t v33 = 1;
    *(void *)(v33 + 8) = "m_type";
    *(void *)(v33 + 16) = &qword_26AF726D8;
    *(void *)(v33 + 24) = 0;
    *(void *)(v33 + 32) = 0x1000000002;
    *(_DWORD *)(v33 + 40) = 0;
    *(void *)(v33 + 48) = 0;
    *(void *)(v33 + 56) = 0;
    *(_DWORD *)(v33 + 64) = 0;
    qword_26AF72668 = v33;
    float32x4_t v34 = re::introspectionAllocator((re *)v33);
    long long v36 = re::IntrospectionInfo<re::StringID>::get(1, v35);
    uint64_t v37 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 72, 8);
    *(_DWORD *)uint64_t v37 = 1;
    *(void *)(v37 + 8) = "m_bindTarget";
    *(void *)(v37 + 16) = v36;
    *(void *)(v37 + 24) = 0;
    *(void *)(v37 + 32) = 0x1800000003;
    *(_DWORD *)(v37 + 40) = 0;
    *(void *)(v37 + 48) = 0;
    *(void *)(v37 + 56) = 0;
    *(_DWORD *)(v37 + 64) = 0;
    qword_26AF72670 = v37;
    __cxa_guard_release(&qword_26AF72620);
LABEL_2:
    *((void *)this + 2) = 0x2800000008;
    *((_DWORD *)this + 6) = 8;
    *((_WORD *)this + 14) = 0;
    *((_DWORD *)this + 14) = 3;
    *((void *)this + 8) = &qword_26AF72660;
    *((void *)this + 9) = re::internal::defaultConstruct<re::StateMachineParameterBindingItem>;
    *((void *)this + 11) = 0;
    *((void *)this + 12) = 0;
    *((void *)this + 10) = re::internal::defaultDestruct<re::StateMachineParameterBindingItem>;
    *((void *)this + 13) = re::internal::defaultConstructV2<re::StateMachineParameterBindingItem>;
    *((void *)this + 14) = re::internal::defaultDestructV2<re::StateMachineParameterBindingItem>;
    re::IntrospectionRegistry::add(this, v3);
    long long v48 = v49;
    return;
  }
  _MergedGlobals_14 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF726D8, v9);
  v50[0] = 0x3F37F4A355D87974;
  v50[1] = (uint64_t)"REStateMachineParameterType";
  uint64_t v53 = 0x31CD534126;
  uint64_t v54 = "uint8_t";
  uint64_t v11 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, &v53);
  if (v11)
  {
    uint64_t v12 = *v11;
    re::StringID::destroyString((re::StringID *)&v53);
    uint64_t v13 = (unsigned int *)qword_26AF72718;
    v52[1] = v12;
    re::TypeBuilder::beginEnumType((uint64_t)&v53, v50, 1, 1, (uint64_t)v52);
    unint64_t v15 = *v13;
    if (v15)
    {
      for (unint64_t i = 0; i < v15; ++i)
      {
        uint64_t v17 = *(void *)(*((void *)v13 + 1) + 8 * i);
        if (*(_DWORD *)v17 == 1)
        {
          uint64_t v18 = *(char **)(v17 + 16);
          if (v18)
          {
            uint64_t v19 = *v18;
            if (*v18)
            {
              char v20 = v18[1];
              if (v20)
              {
                uint64_t v21 = (unsigned __int8 *)(v18 + 2);
                do
                {
                  uint64_t v19 = 31 * v19 + v20;
                  int v22 = *v21++;
                  char v20 = v22;
                }
                while (v22);
              }
            }
          }
          else
          {
            uint64_t v19 = 0;
          }
          uint64_t v23 = *(void *)(v17 + 8);
          *(void *)&v51.var0 = 2 * v19;
          v51.var1 = v18;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)&v53, v23, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v15 = *v13;
        }
      }
      if (v15)
      {
        for (unint64_t j = 0; j < v15; ++j)
        {
          uint64_t v25 = *(void *)(*((void *)v13 + 1) + 8 * j);
          if (*(_DWORD *)v25 == 2)
          {
            uint64_t v26 = *(char **)(v25 + 16);
            if (v26)
            {
              uint64_t v27 = *v26;
              if (*v26)
              {
                char v28 = v26[1];
                if (v28)
                {
                  uint64_t v29 = (unsigned __int8 *)(v26 + 2);
                  do
                  {
                    uint64_t v27 = 31 * v27 + v28;
                    int v30 = *v29++;
                    char v28 = v30;
                  }
                  while (v30);
                }
              }
            }
            else
            {
              uint64_t v27 = 0;
            }
            uint64_t v31 = *(void *)(v25 + 8);
            *(void *)&v51.var0 = 2 * v27;
            v51.var1 = v26;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)&v53, v31, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v15 = *v13;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v53, v32);
    xmmword_26AF726F8 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)v50);
    goto LABEL_33;
  }
  re::StringID::destroyString((re::StringID *)&v53);
  re::internal::assertLog((re::internal *)5, v47, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "REStateMachineParameterType");
  _os_crash();
  __break(1u);
}

void re::internal::defaultConstruct<re::StateMachineParameterBindingItem>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  *(unsigned char *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = "";
}

void re::internal::defaultDestruct<re::StateMachineParameterBindingItem>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::StringID::destroyString((re::StringID *)(a3 + 24));
  re::StringID::destroyString((re::StringID *)a3);
}

uint64_t re::internal::defaultConstructV2<re::StateMachineParameterBindingItem>(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = "";
  *(unsigned char *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = "";
  return result;
}

void re::internal::defaultDestructV2<re::StateMachineParameterBindingItem>(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  re::StringID::destroyString((re::StringID *)a1);
}

void *re::allocInfo_StateMachineParameterBinding(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72640, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72640))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF72798, "StateMachineParameterBinding");
    __cxa_guard_release(&qword_26AF72640);
  }
  return &unk_26AF72798;
}

void re::initInfo_StateMachineParameterBinding(re *this, re::IntrospectionBase *a2)
{
  unint64_t v27 = 0xFB22E2DC977D02A4;
  v28[0] = "StateMachineParameterBinding";
  re::StringID::destroyString((re::StringID *)&v27);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72638, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72638);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      uint64_t v6 = v5;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72648, memory_order_acquire) & 1) == 0)
      {
        uint64_t v5 = (re *)__cxa_guard_acquire(&qword_26AF72648);
        if (v5)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)qword_26AF72698);
          qword_26AF72698[0] = (uint64_t)&unk_26E6C1270;
          __cxa_guard_release(&qword_26AF72648);
        }
      }
      if ((byte_26AF72609 & 1) == 0)
      {
        uint64_t v7 = (void *)qword_26AF72630;
        if (qword_26AF72630
          || (uint64_t v7 = re::allocInfo_StateMachineParameterBindingItem(v5),
              qword_26AF72630 = (uint64_t)v7,
              re::initInfo_StateMachineParameterBindingItem((re *)v7, v8),
              (byte_26AF72609 & 1) == 0))
        {
          byte_26AF72609 = 1;
          int v9 = *((_DWORD *)v7 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_26AF72698, 0);
          unk_26AF726A8 = 0x2800000003;
          unk_26AF726B0 = v9;
          unk_26AF726B4 = 0;
          *(void *)&xmmword_26AF726B8 = 0;
          *((void *)&xmmword_26AF726B8 + 1) = 0xFFFFFFFFLL;
          unk_26AF726C8 = v7;
          unk_26AF726D0 = 0;
          qword_26AF72698[0] = (uint64_t)&unk_26E6C1270;
          re::IntrospectionRegistry::add(v10, v11);
          re::getPrettyTypeName((re *)qword_26AF72698, (const re::IntrospectionBase *)&v27);
          if (v28[0]) {
            uint64_t v12 = (const char *)v28[1];
          }
          else {
            uint64_t v12 = (char *)v28 + 1;
          }
          if (v27 && (v28[0] & 1) != 0) {
            (*(void (**)(void))(*(void *)v27 + 40))();
          }
          long long v24 = *((_OWORD *)v7 + 2);
          uint64_t v13 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v25);
          if (v13)
          {
            uint64_t v14 = *v13;
            *((void *)&v23 + 1) = v14;
          }
          else
          {
            long long v26 = v24;
            re::TypeBuilder::beginListType((uint64_t)&v27, v25, 1, 0x28uLL, 8uLL, &v26);
            re::TypeBuilder::setConstructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v27, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v27, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v27, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v27, v15);
          }
          xmmword_26AF726B8 = v23;
          re::StringID::destroyString((re::StringID *)v25);
        }
      }
      uint64_t v16 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "m_bindings";
      *(void *)(v16 + 16) = qword_26AF72698;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 1;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72650 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      uint64_t v19 = re::introspect_uint32_t((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "m_lastArrayVersion";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x2800000002;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF72658 = v20;
      __cxa_guard_release(&qword_26AF72638);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72650;
  *((void *)this + 9) = re::internal::defaultConstruct<re::StateMachineParameterBinding>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::StateMachineParameterBinding>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::StateMachineParameterBinding>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::StateMachineParameterBinding>;
  re::IntrospectionRegistry::add(this, v3);
  long long v21 = v22;
}

void re::internal::defaultConstruct<re::StateMachineParameterBinding>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 40) = 0;
}

uint64_t re::internal::defaultDestruct<re::StateMachineParameterBinding>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a3);
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a3);
}

uint64_t re::internal::defaultConstructV2<re::StateMachineParameterBinding>(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::StateMachineParameterBinding>(uint64_t a1)
{
  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
}

uint64_t re::introspect_StateMachineParameterBinding(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"StateMachineParameterBinding", (uint64_t (*)(re::internal *))re::allocInfo_StateMachineParameterBinding, (re::IntrospectionBase *(*)(void))re::initInfo_StateMachineParameterBinding, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::StateMachineParameterBinding>, this);
}

void *re::DynamicArray<re::StateMachineParameterBindingItem>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = &v8[5 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          *((unsigned char *)v11 + 16) = *((unsigned char *)v8 + 16);
          LOBYTE(v12) = v8[3];
          v11[3] = v11[3] & 0xFFFFFFFFFFFFFFFELL | v8[3] & 1;
          v11[3] = v8[3] & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[4] = v8[4];
          v8[4] = (uint64_t)"";
          v8[3] = 0;
          re::StringID::destroyString((re::StringID *)(v8 + 3));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 5;
          v11 += 5;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::StateMachineParameterBindingItem>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  v10[0] = 0;
  v10[1] = (uint64_t)"";
  char v11 = 0;
  v12[0] = 0;
  v12[1] = "";
  re::DynamicArray<re::StateMachineParameterBindingItem>::add(this, v10);
  re::StringID::destroyString((re::StringID *)v12);
  re::StringID::destroyString((re::StringID *)v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 40 * *((void *)this + 2) - 40);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 40 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 40 * a3;
}

void re::DynamicArray<re::StateMachineParameterBindingItem>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 40 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = *(void *)(a1 + 32) + v8;
      re::StringID::destroyString((re::StringID *)(v10 + 24));
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 40;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 40 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = "";
        *(unsigned char *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + 32) = "";
        v6 += 40;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = 40 * v8;
      do
      {
        re::StringID::destroyString((re::StringID *)(v9 + 24));
        re::StringID::destroyString((re::StringID *)v9);
        v9 += 40;
        v10 -= 40;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::StateMachineParameterBindingItem>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    uint64_t v12 = *(void *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = *(char **)(a1 + 32);
      uint64_t v14 = 40 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 40;
        v14 -= 40;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 40 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 40 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

uint64_t re::validateRigDefinitionData@<X0>(re *this@<X0>, re::Allocator *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v277 = *MEMORY[0x263EF8340];
  uint64_t v9 = *((void *)a2 + 2);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *((void *)a2 + 4);
    do
    {
      uint64_t v12 = *(void *)(v11 + 88 * v10 + 24);
      if (!v12)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has no constraint nodes.", (re::DynamicString *)&v264, v10);
        goto LABEL_412;
      }
      uint64_t v13 = *(void *)(v11 + 88 * v10 + 64);
      if (v13) {
        BOOL v14 = v13 == v12;
      }
      else {
        BOOL v14 = 1;
      }
      if (!v14)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v264, v10, v13);
        goto LABEL_412;
      }
      uint64_t v15 = *(void **)(v11 + 88 * v10 + 40);
      uint64_t v16 = 8 * v12;
      do
      {
        if (*v15 >= *((void *)a2 + 130))
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v264, v10, *v15);
          goto LABEL_412;
        }
        ++v15;
        v16 -= 8;
      }
      while (v16);
      ++v10;
    }
    while (v10 != v9);
  }
  uint64_t v17 = *((void *)a2 + 7);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = *((void *)a2 + 9);
    do
    {
      uint64_t v20 = *(void *)(v19 + 88 * v18 + 24);
      if (!v20)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has no constraint nodes.", (re::DynamicString *)&v264, v18);
        goto LABEL_412;
      }
      uint64_t v21 = *(void *)(v19 + 88 * v18 + 64);
      if (v21) {
        BOOL v22 = v21 == v20;
      }
      else {
        BOOL v22 = 1;
      }
      if (!v22)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v264, v18, v21);
        goto LABEL_412;
      }
      long long v23 = *(void **)(v19 + 88 * v18 + 40);
      uint64_t v24 = 8 * v20;
      do
      {
        if (*v23 >= *((void *)a2 + 130))
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v264, v18, *v23);
          goto LABEL_412;
        }
        ++v23;
        v24 -= 8;
      }
      while (v24);
      ++v18;
    }
    while (v18 != v17);
  }
  uint64_t v25 = *((void *)a2 + 12);
  if (v25)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *((void *)a2 + 14);
    do
    {
      uint64_t v28 = v27 + 80 * v26;
      uint64_t v29 = *(void *)(v28 + 16);
      if (!v29)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has no constraint nodes.", (re::DynamicString *)&v264, v26);
        goto LABEL_412;
      }
      uint64_t v30 = *(void *)(v27 + 80 * v26 + 56);
      if (v30) {
        BOOL v31 = v30 == v29;
      }
      else {
        BOOL v31 = 1;
      }
      if (!v31)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v264, v26, v30);
        goto LABEL_412;
      }
      uint64_t v32 = *(void **)(v28 + 32);
      uint64_t v33 = 8 * v29;
      do
      {
        if (*v32 >= *((void *)a2 + 130))
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v264, v26, *v32);
          goto LABEL_412;
        }
        ++v32;
        v33 -= 8;
      }
      while (v33);
      ++v26;
    }
    while (v26 != v25);
  }
  uint64_t v34 = *((void *)a2 + 17);
  if (v34)
  {
    uint64_t v35 = 0;
    uint64_t v36 = *((void *)a2 + 19);
    unint64_t v37 = *((void *)a2 + 130);
    do
    {
      float32x4_t v38 = *(float32x4_t *)(v36 + 144 * v35 + 16);
      float32x4_t v39 = vmulq_f32(v38, v38);
      float v40 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0];
      if (v40 != 1.0 && fabsf(v40 + -1.0) > 0.000001)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid aim vector: (%f, %f %f).", (re::DynamicString *)&v264, v35, v38.f32[0], v38.f32[1], v38.f32[2]);
        goto LABEL_412;
      }
      float32x4_t v41 = *(float32x4_t *)(v36 + 144 * v35 + 32);
      float32x4_t v42 = vmulq_f32(v41, v41);
      float v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0];
      if (v43 != 1.0 && fabsf(v43 + -1.0) > 0.000001)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up vector: (%f, %f %f).", (re::DynamicString *)&v264, v35, v41.f32[0], v41.f32[1], v41.f32[2]);
        goto LABEL_412;
      }
      uint64_t v44 = v36 + 144 * v35;
      uint64_t v45 = *(unsigned __int8 *)(v44 + 4);
      uint64_t v46 = *(unsigned __int8 *)(v44 + 3);
      if (v45 == v46)
      {
        float32x4_t v47 = vmulq_f32(v38, v41);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]) >= 0.00001)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig aim constraint %zu must have perpendicular aim/up vectors.", (re::DynamicString *)&v264, v35);
          goto LABEL_412;
        }
      }
      if (v46 >= 2)
      {
        if (v46 != 2)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid forward axis type: %u.", (re::DynamicString *)&v264, v35, v46);
          goto LABEL_412;
        }
      }
      else
      {
        uint64_t v48 = *(void *)(v36 + 144 * v35 + 64);
        if (!v48)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has no forward nodes.", (re::DynamicString *)&v264, v35);
          goto LABEL_412;
        }
        uint64_t v49 = *(void *)(v36 + 144 * v35 + 104);
        if (v49) {
          BOOL v50 = v49 == v48;
        }
        else {
          BOOL v50 = 1;
        }
        if (!v50)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v264, v35, v49);
          goto LABEL_412;
        }
        StringID v51 = *(unint64_t **)(v36 + 144 * v35 + 80);
        uint64_t v52 = 8 * v48;
        do
        {
          if (*v51 >= v37)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid forward node: %zu.", (re::DynamicString *)&v264, v35, *v51);
            goto LABEL_412;
          }
          ++v51;
          v52 -= 8;
        }
        while (v52);
      }
      if (v45 >= 2)
      {
        if (v45 != 2)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up axis type: %u.", (re::DynamicString *)&v264, v35, v45);
          goto LABEL_412;
        }
      }
      else
      {
        unint64_t v53 = *(void *)(v36 + 144 * v35 + 128);
        if (v53 >= v37)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up node: %zu.", (re::DynamicString *)&v264, v35, v53);
          goto LABEL_412;
        }
      }
      ++v35;
    }
    while (v35 != v34);
  }
  unint64_t v54 = *((void *)a2 + 22);
  if (v54)
  {
    uint64_t v55 = 0;
    uint64_t v56 = (void *)(*((void *)a2 + 24) + 8);
    do
    {
      uint64_t v57 = *((unsigned __int8 *)v56 - 8);
      if ((v57 - 1) >= 3)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node channel %zu has an invalid channel type: %u.", (re::DynamicString *)&v264, v55, v57);
        goto LABEL_412;
      }
      if (*v56 >= *((void *)a2 + 130))
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node channel %zu has an invalid rig node: %zu.", (re::DynamicString *)&v264, v55, *v56);
        goto LABEL_412;
      }
      ++v55;
      v56 += 2;
    }
    while (v54 != v55);
  }
  unint64_t v58 = *((void *)a2 + 67);
  if (v58)
  {
    uint64_t v59 = 0;
    uint64_t v60 = *((void *)a2 + 69);
    unint64_t v61 = *((void *)a2 + 62);
    unint64_t v62 = *((void *)a2 + 57);
    unint64_t v63 = *((void *)a2 + 52);
    unint64_t v64 = *((void *)a2 + 47);
    unint64_t v65 = *((void *)a2 + 42);
    unint64_t v66 = *((void *)a2 + 37);
    unint64_t v67 = *((void *)a2 + 32);
    unint64_t v68 = *((void *)a2 + 27);
    uint64_t v69 = (unint64_t *)(v60 + 8);
    while (2)
    {
      uint64_t v70 = *((unsigned __int8 *)v69 - 8);
      if (v70 >= 8)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constant %zu has an constant type: %u.", (re::DynamicString *)&v264, v59, v70);
        goto LABEL_412;
      }
      switch(*((unsigned char *)v69 - 8))
      {
        case 0:
          unint64_t v71 = *v69;
          if (v68 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 1:
          unint64_t v71 = *v69;
          if (v67 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 2:
          unint64_t v71 = *v69;
          if (v66 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 3:
          unint64_t v71 = *v69;
          if (v65 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 4:
          unint64_t v71 = *v69;
          if (v64 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 5:
          unint64_t v71 = *v69;
          if (v63 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 6:
          unint64_t v71 = *v69;
          if (v62 <= *v69) {
            goto LABEL_243;
          }
          goto LABEL_88;
        case 7:
          unint64_t v71 = *v69;
          if (v61 <= *v69)
          {
LABEL_243:
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constant %zu has an invalid constant index: %zu.", (re::DynamicString *)&v264, v59, v71);
            goto LABEL_412;
          }
LABEL_88:
          ++v59;
          v69 += 2;
          if (v58 == v59) {
            break;
          }
          continue;
        default:
          re::internal::assertLog((re::internal *)5, v67, v68, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "validateRigDefinitionData", 311, v70);
          unint64_t v227 = _os_crash();
          __break(1u);
          goto LABEL_420;
      }
      break;
    }
  }
  unint64_t v72 = *((void *)a2 + 80);
  if (v72)
  {
    uint64_t v73 = 0;
    unint64_t v74 = (void *)(*((void *)a2 + 82) + 8);
    do
    {
      uint64_t v75 = *((unsigned __int8 *)v74 - 8);
      if (v75 >= 8)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig temporary value %zu has an invalid type: %u.", (re::DynamicString *)&v264, v73, v75);
        goto LABEL_412;
      }
      if (*v74 >= *((void *)a2 + *((unsigned __int8 *)v74 - 8) + 70))
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig temporary value %zu has an invalid index: %zu.", (re::DynamicString *)&v264, v73, *v74);
        goto LABEL_412;
      }
      ++v73;
      v74 += 2;
    }
    while (v72 != v73);
  }
  uint64_t v76 = *((void *)a2 + 85);
  if (v76)
  {
    uint64_t v77 = 0;
    unint64_t v78 = (unint64_t *)(*((void *)a2 + 87) + 8);
    do
    {
      uint64_t v79 = *((unsigned __int8 *)v78 - 8);
      switch(v79)
      {
        case 3:
          if (*v78 >= v72)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid temporary value index: %zu.", (re::DynamicString *)&v264, v77, *v78);
            goto LABEL_412;
          }
          break;
        case 2:
          if (*v78 >= v58)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid constraint value index: %zu.", (re::DynamicString *)&v264, v77, *v78);
            goto LABEL_412;
          }
          break;
        case 1:
          if (*v78 >= v54)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid joint channel: %zu.", (re::DynamicString *)&v264, v77, *v78);
            goto LABEL_412;
          }
          break;
        default:
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid type: %u.", (re::DynamicString *)&v264, v77, v79);
          goto LABEL_412;
      }
      ++v77;
      v78 += 2;
    }
    while (v76 != v77);
  }
  if (*((void *)a2 + 90))
  {
    unint64_t v80 = 0;
    do
    {
      uint64_t v81 = *((void *)a2 + 92);
      uint64_t v82 = *(unsigned int *)(v81 + 24 * v80);
      if (v82 > 0x4D || v82 == 76)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression command %zu has an invalid type: %u.", (re::DynamicString *)&v264, v80, v82);
        goto LABEL_412;
      }
      uint64_t v83 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v82 + 9);
      unint64_t v84 = *((void *)a2 + 85);
      if (*((unsigned char *)&re::kEvaluationCommandDescriptions + 16 * v82 + 9))
      {
        uint64_t v85 = v81 + 24 * v80;
        uint64_t v87 = *(void *)(v85 + 8);
        uint64_t v86 = (void *)(v85 + 8);
        unint64_t v88 = v87 + v83;
        if (__CFADD__(v87, v83) || v88 > v84)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression command %zu does not have enough parameters.", (re::DynamicString *)&v264, v80);
          goto LABEL_412;
        }
        uint64_t v89 = 0;
        uint64_t v90 = (char *)&re::kEvaluationCommandDescriptions + 16 * v82 + 10;
        do
        {
          unint64_t v91 = v89 + *v86;
          if (v91 >= *((void *)a2 + 85))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu has an invalid input parameter: %zu.", (re::DynamicString *)&v264, v80, v91);
            goto LABEL_412;
          }
          if (ExpressionParameterType != v90[v89])
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu input parameter %u expected type %u, received %u.", (re::DynamicString *)&v264, v80, v89, v90[v89], ExpressionParameterType);
            goto LABEL_412;
          }
          ++v89;
        }
        while (v83 != v89);
        unint64_t v84 = *((void *)a2 + 85);
      }
      unint64_t v93 = *(void *)(v81 + 24 * v80 + 16);
      if (v93 >= v84)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu has an invalid output parameter index: %zu.", (re::DynamicString *)&v264, v80, v93);
        goto LABEL_412;
      }
      if (v94 != LOBYTE((&re::kEvaluationCommandDescriptions)[2 * v82 + 1]))
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu output parameter expected type %u, received %u.", (re::DynamicString *)&v264, v80, LOBYTE((&re::kEvaluationCommandDescriptions)[2 * v82 + 1]), v94);
        goto LABEL_412;
      }
      ++v80;
    }
    while (v80 < *((void *)a2 + 90));
  }
  unint64_t v95 = *((void *)a2 + 95);
  if (v95)
  {
    unint64_t v96 = 0;
    float v97 = 0.001;
    float v98 = 1.001;
    do
    {
      uint64_t v99 = *((void *)a2 + 97);
      uint64_t v100 = (void *)(v99 + 240 * v96);
      uint64_t v101 = v100[2];
      if (v101 != v100[7])
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and effectors.", (re::DynamicString *)&v264, v96);
        goto LABEL_412;
      }
      if (v101 != *(void *)(v99 + 240 * v96 + 96))
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and targets.", (re::DynamicString *)&v264, v96);
        goto LABEL_412;
      }
      if (v101 != *(void *)(v99 + 240 * v96 + 136))
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and up nodes.", (re::DynamicString *)&v264, v96);
        goto LABEL_412;
      }
      uint64_t v102 = *(void *)(v99 + 240 * v96 + 176);
      if (v102) {
        BOOL v103 = v101 == v102;
      }
      else {
        BOOL v103 = 1;
      }
      if (!v103)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has invalid end twist offsets.", (re::DynamicString *)&v264, v96);
        goto LABEL_412;
      }
      uint64_t v104 = *(void *)(v99 + 240 * v96 + 216);
      if (v104) {
        BOOL v105 = v101 == v104;
      }
      else {
        BOOL v105 = 1;
      }
      if (!v105)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has invalid soft IK percentages.", (re::DynamicString *)&v264, v96);
        goto LABEL_412;
      }
      if (v101)
      {
        float32x4_t v106 = (unint64_t *)v100[4];
        unint64_t v107 = *((void *)a2 + 130);
        uint64_t v108 = 8 * v101;
        uint64_t v109 = 8 * v101;
        do
        {
          if (*v106 >= v107)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid root node: %zu.", (re::DynamicString *)&v264, v96, *v106);
            goto LABEL_412;
          }
          ++v106;
          v109 -= 8;
        }
        while (v109);
        float32x4_t v110 = *(unint64_t **)(v99 + 240 * v96 + 72);
        uint64_t v111 = 8 * v101;
        do
        {
          if (*v110 >= v107)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid effector node: %zu.", (re::DynamicString *)&v264, v96, *v110);
            goto LABEL_412;
          }
          ++v110;
          v111 -= 8;
        }
        while (v111);
        float32x4_t v112 = *(unint64_t **)(v99 + 240 * v96 + 112);
        uint64_t v113 = 8 * v101;
        do
        {
          if (*v112 >= v107)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid target node: %zu.", (re::DynamicString *)&v264, v96, *v112);
            goto LABEL_412;
          }
          ++v112;
          v113 -= 8;
        }
        while (v113);
        float v114 = *(unint64_t **)(v99 + 240 * v96 + 152);
        do
        {
          if (*v114 >= v107)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid up node: %zu.", (re::DynamicString *)&v264, v96, *v114);
            goto LABEL_412;
          }
          ++v114;
          v108 -= 8;
        }
        while (v108);
      }
      if (v104)
      {
        float v115 = *(float **)(v99 + 240 * v96 + 232);
        uint64_t v116 = 4 * v104;
        do
        {
          float v117 = *v115;
          if (*v115 < v97 || v117 > v98)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid soft IK Percentage: %f.", (re::DynamicString *)&v264, v96, v117);
            goto LABEL_412;
          }
          ++v115;
          v116 -= 4;
        }
        while (v116);
      }
      if (v101)
      {
        float v118 = v98;
        float v119 = v97;
        for (unint64_t i = 0; i != v101; ++i)
        {
          float v121 = (unint64_t *)re::DynamicArray<unsigned long>::operator[]((uint64_t)(v100 + 5), i);
          unint64_t v122 = *(void *)(re::DynamicArray<re::RigNode>::operator[](*((void *)a2 + 130), *((void *)a2 + 132), *v121)+ 32);
          if (v122 == -1)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has effector with no parent: %zu.", (re::DynamicString *)&v264, v96, i);
            goto LABEL_412;
          }
          uint64_t v123 = *(void *)(re::DynamicArray<re::RigNode>::operator[](*((void *)a2 + 130), *((void *)a2 + 132), v122)+ 32);
          if (v123 == -1)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has middle with no parent: %zu.", (re::DynamicString *)&v264, v96, i);
            goto LABEL_412;
          }
          if (v123 != *(void *)re::DynamicArray<unsigned long>::operator[]((uint64_t)v100, i))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu does not have a 2-bone chain: %zu.", (re::DynamicString *)&v264, v96, i);
            goto LABEL_412;
          }
        }
        unint64_t v95 = *((void *)a2 + 95);
        float v97 = v119;
        float v98 = v118;
      }
      ++v96;
    }
    while (v96 < v95);
  }
  unint64_t v124 = *((void *)a2 + 100);
  if (v124)
  {
    unint64_t v125 = 0;
    while (1)
    {
      float v126 = (void *)re::DynamicArray<re::RigSingleChainIKHandles>::operator[](v124, *((void *)a2 + 102), v125);
      uint64_t v127 = v126[2];
      if (v127 != v126[7])
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has mismatching roots & effectors.", (re::DynamicString *)&v264, v125);
        goto LABEL_412;
      }
      uint64_t v128 = (uint64_t)v126;
      if (v127 != v126[12])
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has mismatching roots & targets.", (re::DynamicString *)&v264, v125);
        goto LABEL_412;
      }
      if (v127) {
        break;
      }
LABEL_189:
      ++v125;
      unint64_t v124 = *((void *)a2 + 100);
      if (v125 >= v124) {
        goto LABEL_190;
      }
    }
    uint64_t v263 = (uint64_t)(v126 + 5);
    uint64_t v129 = (unint64_t *)v126[4];
    unint64_t v130 = *((void *)a2 + 130);
    uint64_t v131 = 8 * v127;
    uint64_t v132 = 8 * v127;
    do
    {
      if (*v129 >= v130)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid root: %zu.", (re::DynamicString *)&v264, v125, *v129);
        goto LABEL_412;
      }
      ++v129;
      v132 -= 8;
    }
    while (v132);
    float32x2_t v133 = (unint64_t *)v126[9];
    uint64_t v134 = 8 * v127;
    do
    {
      if (*v133 >= v130)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid effector: %zu.", (re::DynamicString *)&v264, v125, *v133);
        goto LABEL_412;
      }
      ++v133;
      v134 -= 8;
    }
    while (v134);
    unint64_t v135 = (unint64_t *)v126[14];
    do
    {
      if (*v135 >= v130)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid target: %zu.", (re::DynamicString *)&v264, v125, *v135);
        goto LABEL_412;
      }
      ++v135;
      v131 -= 8;
    }
    while (v131);
    unint64_t v136 = 0;
    while (1)
    {
      unint64_t v137 = (unint64_t *)re::DynamicArray<unsigned long>::operator[](v263, v136);
      uint64_t v138 = re::DynamicArray<re::RigNode>::operator[](*((void *)a2 + 130), *((void *)a2 + 132), *v137);
      uint64_t v139 = *(void *)re::DynamicArray<unsigned long>::operator[](v128, v136);
      unint64_t v140 = *(void *)(v138 + 32);
      if (v140 != -1 && v140 != v139) {
        break;
      }
LABEL_187:
      if (v140 == -1)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu no a valid chain: %zu.", (re::DynamicString *)&v264, v125, v136);
        goto LABEL_412;
      }
      if (++v136 == v127) {
        goto LABEL_189;
      }
    }
    unint64_t v142 = *((void *)a2 + 130);
    while (v142 > v140)
    {
      unint64_t v140 = *(void *)(*((void *)a2 + 132) + 32 + 56 * v140);
      if (v140 == -1 || v140 == v139) {
        goto LABEL_187;
      }
    }
    long long v267 = 0u;
    long long v268 = 0u;
    long long v265 = 0u;
    long long v266 = 0u;
    long long v264 = 0u;
    a3 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v276 = 136315906;
    *(void *)&v276[4] = "operator[]";
    *(_WORD *)&v276[12] = 1024;
    *(_DWORD *)&v276[14] = 797;
    *(_WORD *)&v276[18] = 2048;
    *(void *)&v276[20] = v140;
    *(_WORD *)&v276[28] = 2048;
    *(void *)&v276[30] = v142;
    int v260 = 38;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_389:
    uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node %zu does not have a valid name.", (re::DynamicString *)&v264, v125, v260);
    goto LABEL_412;
  }
LABEL_190:
  unint64_t v144 = *((void *)a2 + 105);
  if (v144)
  {
    unint64_t v145 = 0;
    while (1)
    {
      unint64_t v146 = (void *)re::DynamicArray<re::RigSplineIKHandle>::operator[](v144, *((void *)a2 + 107), v145);
      unint64_t v147 = v146[3];
      if (v147)
      {
        unint64_t v148 = (void *)v146[5];
        uint64_t v149 = 80 * v147;
        do
        {
          if (*v148 >= *((void *)a2 + 130))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid joint node.", (re::DynamicString *)&v264, v145);
            goto LABEL_412;
          }
          v148 += 10;
          v149 -= 80;
        }
        while (v149);
      }
      uint64_t v150 = v146[8];
      if (!v150)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have any control points.", (re::DynamicString *)&v264, v145);
        goto LABEL_412;
      }
      uint64_t v151 = v146[10];
      uint64_t v152 = v151 + 96 * v150;
      do
      {
        uint64_t v153 = *(void *)(v151 + 16);
        if (v153)
        {
          v154 = *(unint64_t **)(v151 + 32);
          uint64_t v155 = 8 * v153;
          do
          {
            if (*v154 >= v147)
            {
              uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid control point joint influence: %zu", (re::DynamicString *)&v264, v145, *v154);
              goto LABEL_412;
            }
            ++v154;
            v155 -= 8;
          }
          while (v155);
        }
        v151 += 96;
      }
      while (v151 != v152);
      if (v150 + 2 != v146[13])
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu has %zu knots and needs %zu.", (re::DynamicString *)&v264, v145, v146[13], v150 + 2);
        goto LABEL_412;
      }
      unint64_t v156 = v146[16];
      unint64_t v157 = *((void *)a2 + 130);
      if (v156 >= v157)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid root node: %zu", (re::DynamicString *)&v264, v145, v156);
        goto LABEL_412;
      }
      unint64_t v158 = v146[17];
      if (v158 >= v157)
      {
        uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid end effector node: %zu", (re::DynamicString *)&v264, v145, v158);
        goto LABEL_412;
      }
      unint64_t v159 = v146[18];
      if (v159 >= v157) {
        break;
      }
      ++v145;
      unint64_t v144 = *((void *)a2 + 105);
      if (v145 >= v144) {
        goto LABEL_208;
      }
    }
    uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid bind transform node: %zu", (re::DynamicString *)&v264, v145, v159);
LABEL_412:
    long long v252 = v264;
    long long v253 = v265;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 3000;
    *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v252;
    *(_OWORD *)(a3 + 40) = v253;
  }
  else
  {
LABEL_208:
    unint64_t v160 = *((void *)a2 + 110);
    if (v160)
    {
      for (unint64_t j = 0; j < v160; ++j)
      {
        uint64_t v162 = re::DynamicArray<re::RigTransform>::operator[](v160, *((void *)a2 + 112), j);
        float32x4_t v163 = *(float32x4_t *)(v162 + 32);
        float32x4_t v164 = vmulq_f32(v163, v163);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v164, 2), vaddq_f32(v164, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v164.f32, 1))).f32[0]) < 1.0e-10)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu must have a valid scale value.", (re::DynamicString *)&v264, j);
          goto LABEL_412;
        }
        if (*((void *)a2 + 120)
          && (v163.f32[0] != v163.f32[1]
           && vabds_f32(v163.f32[0], v163.f32[1]) >= (float)((float)((float)(fabsf(v163.f32[0]) + fabsf(v163.f32[1]))
                                                                   + 1.0)
                                                           * 0.00001)
           || v163.f32[0] != v163.f32[2]
           && vabds_f32(v163.f32[0], v163.f32[2]) >= (float)((float)((float)(fabsf(v163.f32[0]) + fabsf(v163.f32[2]))
                                                                   + 1.0)
                                                           * 0.00001)))
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu contains unsupported non-uniform scaling.", (re::DynamicString *)&v264, j);
          goto LABEL_412;
        }
        uint64_t v165 = *(unsigned __int8 *)(v162 + 48);
        if (v165 >= 6)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu contains an invalid rotation order: %u.", (re::DynamicString *)&v264, j, v165);
          goto LABEL_412;
        }
        unint64_t v160 = *((void *)a2 + 110);
      }
    }
    unint64_t v166 = *((void *)a2 + 115);
    if (v166)
    {
      for (unint64_t k = 0; k < v166; ++k)
      {
        uint64_t v168 = re::DynamicArray<re::RigJoint>::operator[](v166, *((void *)a2 + 117), k);
        int8x16_t v169 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v168 + 16), *(float32x4_t *)(v168 + 16));
        float v170 = vaddv_f32(vadd_f32(*(float32x2_t *)v169.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v169, v169, 8uLL)));
        if (v170 != 1.0 && fabsf(v170 + -1.0) > 0.00001)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu does not have a valid orientation value.", (re::DynamicString *)&v264, k);
          goto LABEL_412;
        }
        int8x16_t v171 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v168 + 48), *(float32x4_t *)(v168 + 48));
        float v172 = vaddv_f32(vadd_f32(*(float32x2_t *)v171.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v171, v171, 8uLL)));
        if (v172 != 1.0 && fabsf(v172 + -1.0) > 0.00001)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu does not have a valid scale orientation value.", (re::DynamicString *)&v264, k);
          goto LABEL_412;
        }
        float32x4_t v173 = *(float32x4_t *)(v168 + 64);
        float32x4_t v174 = vmulq_f32(v173, v173);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v174, 2), vaddq_f32(v174, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v174.f32, 1))).f32[0]) < 1.0e-10)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu must have a valid scale value.", (re::DynamicString *)&v264, k);
          goto LABEL_412;
        }
        unint64_t v175 = *((void *)a2 + 120);
        if (v175
          && (v173.f32[0] != v173.f32[1]
           && vabds_f32(v173.f32[0], v173.f32[1]) >= (float)((float)((float)(fabsf(v173.f32[0]) + fabsf(v173.f32[1]))
                                                                   + 1.0)
                                                           * 0.00001)
           || v173.f32[0] != v173.f32[2]
           && vabds_f32(v173.f32[0], v173.f32[2]) >= (float)((float)((float)(fabsf(v173.f32[0]) + fabsf(v173.f32[2]))
                                                                   + 1.0)
                                                           * 0.00001)))
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu contains unsupported non-uniform scaling.", (re::DynamicString *)&v264, k);
          goto LABEL_412;
        }
        uint64_t v176 = *(unsigned __int8 *)(v168 + 80);
        if (v176 >= 6)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu contains an invalid rotation order: %u.", (re::DynamicString *)&v264, k, v176);
          goto LABEL_412;
        }
        unint64_t v166 = *((void *)a2 + 115);
      }
    }
    else
    {
      unint64_t v175 = *((void *)a2 + 120);
    }
    if (v175)
    {
      unint64_t v178 = 0;
      while (1)
      {
        v179 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](v175, *((void *)a2 + 122), v178);
        switch(*v179)
        {
          case 1u:
            if (*((void *)v179 + 1) < *((void *)a2 + 2)) {
              goto LABEL_290;
            }
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid point constraint.", (re::DynamicString *)&v264, v178);
            goto LABEL_412;
          case 2u:
            if (*((void *)v179 + 1) < *((void *)a2 + 7)) {
              goto LABEL_290;
            }
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid orient constraint.", (re::DynamicString *)&v264, v178);
            goto LABEL_412;
          case 3u:
            if (*((void *)v179 + 1) < *((void *)a2 + 12)) {
              goto LABEL_290;
            }
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid parent constraint.", (re::DynamicString *)&v264, v178);
            goto LABEL_412;
          case 4u:
            if (*((void *)v179 + 1) < *((void *)a2 + 17)) {
              goto LABEL_290;
            }
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid aim constraint.", (re::DynamicString *)&v264, v178);
            goto LABEL_412;
          case 5u:
            if (*((void *)v179 + 1) >= *((void *)a2 + 90))
            {
              uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid expression constraint.", (re::DynamicString *)&v264, v178);
              goto LABEL_412;
            }
LABEL_290:
            ++v178;
            unint64_t v175 = *((void *)a2 + 120);
            if (v178 >= v175) {
              goto LABEL_291;
            }
            break;
          default:
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu contains an invalid constraint type: %u.", (re::DynamicString *)&v264, v178, *v179);
            goto LABEL_412;
        }
      }
    }
LABEL_291:
    unint64_t v180 = *((void *)a2 + 130);
    if (v180)
    {
      unint64_t v125 = 0;
      do
      {
        uint64_t v181 = re::DynamicArray<re::RigNode>::operator[](v180, *((void *)a2 + 132), v125);
        v182 = *(unsigned char **)(v181 + 8);
        if (!v182 || !*v182) {
          goto LABEL_389;
        }
        uint64_t v183 = *(unsigned __int8 *)(v181 + 16);
        if (v183 == 2)
        {
          unint64_t v185 = *(void *)(v181 + 24);
          if (v185 >= *((void *)a2 + 115))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid joint node: %zu.", (re::DynamicString *)&v264, v125, *(void *)(v181 + 8), v185);
            goto LABEL_412;
          }
        }
        else
        {
          if (v183 != 1)
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid node type: %u.", (re::DynamicString *)&v264, v125, *(void *)(v181 + 8), v183);
            goto LABEL_412;
          }
          unint64_t v184 = *(void *)(v181 + 24);
          if (v184 >= *((void *)a2 + 110))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid transform node: %zu.", (re::DynamicString *)&v264, v125, *(void *)(v181 + 8), v184);
            goto LABEL_412;
          }
        }
        unint64_t v186 = *(void *)(v181 + 32);
        unint64_t v180 = *((void *)a2 + 130);
        BOOL v187 = v186 != -1 && v186 >= v180;
        if (v187)
        {
          uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) does not specify a valid parent node: %zu.", (re::DynamicString *)&v264, v125, *(void *)(v181 + 8), v186);
          goto LABEL_412;
        }
        uint64_t v188 = *(void *)(v181 + 40);
        if (v188)
        {
          uint64_t v189 = *(void *)(v181 + 48);
          BOOL v187 = __CFADD__(v189, v188);
          unint64_t v190 = v189 + v188;
          if (v187 || v190 > *((void *)a2 + 120))
          {
            uint64_t result = re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) does not specify valid constraint nodes.", (re::DynamicString *)&v264, v125, v182);
            goto LABEL_412;
          }
        }
      }
      while (++v125 < v180);
    }
    uint64_t v191 = 0;
    long long v274 = 0u;
    long long v275 = 0u;
    long long v272 = 0u;
    long long v273 = 0u;
    long long v270 = 0u;
    long long v271 = 0u;
    long long v268 = 0u;
    long long v269 = 0u;
    long long v266 = 0u;
    long long v267 = 0u;
    v192 = (unint64_t *)((char *)a2 + 560);
    long long v264 = 0u;
    long long v265 = 0u;
    do
    {
      unint64_t v193 = *v192++;
      v191 += 24;
    }
    while (v191 != 192);
    unint64_t v194 = *((void *)a2 + 130);
    if (v194)
    {
      for (unint64_t m = 0; m < v194; ++m)
      {
        uint64_t v195 = re::DynamicArray<re::RigNode>::operator[](v194, *((void *)a2 + 132), m);
        if (*(void *)(v195 + 40))
        {
          unint64_t v5 = (void *)v195;
          for (unint64_t n = 0; n < v5[5]; ++n)
          {
            v197 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 120), *((void *)a2 + 122), v5[6] + n);
            switch(*v197)
            {
              case 1u:
                uint64_t v198 = re::DynamicArray<re::RigComponentConstraint>::operator[](*((void *)a2 + 2), *((void *)a2 + 4), *((void *)v197 + 1));
                uint64_t v199 = *(void *)(v198 + 24);
                if (!v199) {
                  continue;
                }
                v200 = *(void **)(v198 + 40);
                uint64_t v201 = 8 * v199;
                do
                {
                  if (*v200 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) point constraint %zu is constrained to itself.", (re::DynamicString *)v276, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v200;
                  v201 -= 8;
                }
                while (v201);
                continue;
              case 2u:
                uint64_t v202 = re::DynamicArray<re::RigComponentConstraint>::operator[](*((void *)a2 + 7), *((void *)a2 + 9), *((void *)v197 + 1));
                uint64_t v203 = *(void *)(v202 + 24);
                if (!v203) {
                  continue;
                }
                v204 = *(void **)(v202 + 40);
                uint64_t v205 = 8 * v203;
                do
                {
                  if (*v204 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) orient constraint %zu is constrained to itself.", (re::DynamicString *)v276, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v204;
                  v205 -= 8;
                }
                while (v205);
                continue;
              case 3u:
                uint64_t v206 = re::DynamicArray<re::RigBasicConstraint>::operator[](*((void *)a2 + 12), *((void *)a2 + 14), *((void *)v197 + 1));
                uint64_t v207 = *(void *)(v206 + 16);
                if (!v207) {
                  continue;
                }
                v208 = *(void **)(v206 + 32);
                uint64_t v209 = 8 * v207;
                do
                {
                  if (*v208 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) parent constraint %zu is constrained to itself.", (re::DynamicString *)v276, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v208;
                  v209 -= 8;
                }
                while (v209);
                continue;
              case 4u:
                v210 = (void *)re::DynamicArray<re::RigAimConstraint>::operator[](*((void *)a2 + 17), *((void *)a2 + 19), *((void *)v197 + 1));
                uint64_t v211 = v210[8];
                if (!v211) {
                  goto LABEL_334;
                }
                v212 = (void *)v210[10];
                uint64_t v213 = 8 * v211;
                do
                {
                  if (*v212 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) aim constraint %zu forward is constrained to self.", (re::DynamicString *)v276, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v212;
                  v213 -= 8;
                }
                while (v213);
LABEL_334:
                if (v210[16] == m)
                {
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) aim constraint %zu up is contrained to seld.", (re::DynamicString *)v276, m, v5[1], n);
                  goto LABEL_421;
                }
                continue;
              case 5u:
                v214 = (unsigned int *)re::DynamicArray<re::RigExpression>::operator[](*((void *)a2 + 90), *((void *)a2 + 92), *((void *)v197 + 1));
                v215 = &(&re::kEvaluationCommandDescriptions)[2 * *v214];
                uint64_t v216 = *((unsigned __int8 *)v215 + 9);
                if (!*((unsigned char *)v215 + 9)) {
                  goto LABEL_342;
                }
                uint64_t v217 = 0;
                break;
              default:
                re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu contains an invalid constraint type: %u.", (re::DynamicString *)v276, m, *v197);
                goto LABEL_421;
            }
            do
            {
              uint64_t v218 = re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 85), *((void *)a2 + 87), v217 + *((void *)v214 + 1));
              if (*(unsigned char *)v218 == 3)
              {
                uint64_t v219 = re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 80), *((void *)a2 + 82), *(void *)(v218 + 8));
                {
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) reads from uninitialized temporary value.", (re::DynamicString *)v276, m, v5[1]);
                  goto LABEL_421;
                }
                if (TemporaryValueUsed != m)
                {
                  unint64_t v250 = TemporaryValueUsed;
                  uint64_t v251 = v5[1];
                  uint64_t v261 = *(void *)(re::DynamicArray<re::RigNode>::operator[](*((void *)a2 + 130), *((void *)a2 + 132), TemporaryValueUsed)+ 8);
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) reads from temporary value initialized by other rig node %zu (%s).", (re::DynamicString *)v276, m, v251, v250, v261);
                  goto LABEL_421;
                }
              }
              ++v217;
            }
            while (v216 != v217);
LABEL_342:
            v221 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 85), *((void *)a2 + 87), *((void *)v214 + 2));
            uint64_t v222 = *v221;
            if (v222 == 1)
            {
              uint64_t v228 = *(void *)(re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 22), *((void *)a2 + 24), *((void *)v221 + 1))+ 8);
              if (v228 != m)
              {
                re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) constraint %zu outputs for a differing rig node : %zu.", (re::DynamicString *)v276, m, v5[1], n, v228);
                goto LABEL_421;
              }
            }
            else
            {
              if (v222 != 3)
              {
                re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) constraint %zu outputs to invalid destination: %u.", (re::DynamicString *)v276, m, v5[1], n, v222);
                goto LABEL_421;
              }
              uint64_t v223 = re::DynamicArray<re::RigNodeChannel>::operator[](*((void *)a2 + 80), *((void *)a2 + 82), *((void *)v221 + 1));
              unsigned __int8 v225 = *(unsigned char *)v223;
              unint64_t v226 = *(void *)(v223 + 8);
              if (isTemporaryValueUsed)
              {
                if (v227 != m)
                {
LABEL_420:
                  unint64_t v254 = v227;
                  uint64_t v255 = v5[1];
                  uint64_t v262 = *(void *)(re::DynamicArray<re::RigNode>::operator[](*((void *)a2 + 130), *((void *)a2 + 132), v227)+ 8);
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) initializing temporary value already initialized by other rig node %zu (%s).", (re::DynamicString *)v276, m, v255, v254, v262);
                  goto LABEL_421;
                }
              }
              else
              {
              }
            }
          }
        }
        unint64_t v194 = *((void *)a2 + 130);
      }
    }
    unint64_t v229 = *((void *)a2 + 125);
    if (v229)
    {
      for (iunint64_t i = 0; ii < v229; ++ii)
      {
        v231 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](v229, *((void *)a2 + 127), ii);
        uint64_t v232 = *v231;
        switch(v232)
        {
          case 3:
            unint64_t v234 = *((void *)v231 + 1);
            if (v234 >= *((void *)a2 + 105))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid Spline IK index: %zu.", (re::DynamicString *)v276, ii, v234);
              goto LABEL_421;
            }
            break;
          case 2:
            unint64_t v235 = *((void *)v231 + 1);
            if (v235 >= *((void *)a2 + 100))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid single chain IK index: %zu.", (re::DynamicString *)v276, ii, v235);
              goto LABEL_421;
            }
            break;
          case 1:
            unint64_t v233 = *((void *)v231 + 1);
            if (v233 >= *((void *)a2 + 95))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid two-bone IK index: %zu.", (re::DynamicString *)v276, ii, v233);
              goto LABEL_421;
            }
            break;
          default:
            re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid type: %u.", (re::DynamicString *)v276, ii, v232);
            goto LABEL_421;
        }
        unint64_t v229 = *((void *)a2 + 125);
      }
    }
    unint64_t v236 = *((void *)a2 + 135);
    if (v236)
    {
      for (junint64_t j = 0; jj < v236; ++jj)
      {
        v238 = (unsigned __int8 *)re::DynamicArray<re::RigExpression>::operator[](v236, *((void *)a2 + 137), jj);
        uint64_t v239 = *v238;
        if (v239 == 2)
        {
          unint64_t v241 = *((void *)v238 + 1);
          if (v241 >= *((void *)a2 + 115))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid joint node: %zu.", (re::DynamicString *)v276, jj, v241);
            goto LABEL_421;
          }
        }
        else
        {
          if (v239 != 1)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid node type: %u.", (re::DynamicString *)v276, jj, v239);
            goto LABEL_421;
          }
          unint64_t v240 = *((void *)v238 + 1);
          if (v240 >= *((void *)a2 + 110))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid transform node: %zu.", (re::DynamicString *)v276, jj, v240);
            goto LABEL_421;
          }
        }
        unint64_t v242 = *((void *)v238 + 2);
        if (v242 >= *((void *)a2 + 130))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid rig node to override: %zu.", (re::DynamicString *)v276, jj, v242);
          goto LABEL_421;
        }
        unint64_t v236 = *((void *)a2 + 135);
      }
    }
    unint64_t v243 = *((void *)a2 + 140);
    if (v243)
    {
      unint64_t v244 = 0;
      while (1)
      {
        v245 = (void *)re::DynamicArray<re::RigPose>::operator[](v243, *((void *)a2 + 142), v244);
        v246 = (unsigned char *)v245[1];
        if (!v246 || !*v246)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu does not have a valid name.", (re::DynamicString *)v276, v244);
          goto LABEL_421;
        }
        uint64_t v247 = v245[2];
        if (!v247)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu (%s) does not contain any pose nodes.", (re::DynamicString *)v276, v244, v246);
          goto LABEL_421;
        }
        uint64_t v248 = v245[3];
        BOOL v187 = __CFADD__(v248, v247);
        unint64_t v249 = v248 + v247;
        if (v187 || v249 > *((void *)a2 + 135)) {
          break;
        }
        ++v244;
        unint64_t v243 = *((void *)a2 + 140);
        if (v244 >= v243) {
          goto LABEL_380;
        }
      }
      re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu (%s) does not contain valid pose nodes.", (re::DynamicString *)v276, v244, v246);
LABEL_421:
      long long v256 = *(_OWORD *)v276;
      uint64_t v257 = *(void *)&v276[16];
      uint64_t v258 = *(void *)&v276[24];
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = 3000;
      *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)(a3 + 24) = v256;
      *(void *)(a3 + 40) = v257;
      *(void *)(a3 + 48) = v258;
    }
    else
    {
LABEL_380:
      *(unsigned char *)a3 = 1;
    }
    for (kunint64_t k = 168; kk != -24; kk -= 24)
      uint64_t result = re::FixedArray<CoreIKTransform>::deinit((uint64_t *)((char *)&v264 + kk));
  }
  return result;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 88 * a3;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 80 * a3;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 144 * a3;
}

uint64_t re::DynamicArray<re::RigNodeChannel>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 16 * a3;
}

uint64_t re::DynamicArray<re::RigExpression>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 24 * a3;
}

uint64_t re::anonymous namespace'::getExpressionParameterType(re::_anonymous_namespace_ *this, uint64_t a2)
{
  if (*((void *)this + 85) <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v2 = *((void *)this + 87);
  int v3 = *(unsigned __int8 *)(v2 + 16 * a2);
  if (v3 == 1) {
    return 7;
  }
  if (v3 == 3)
  {
    unint64_t v4 = *(void *)(v2 + 16 * a2 + 8);
    if (*((void *)this + 80) > v4)
    {
      uint64_t v5 = *((void *)this + 82);
      return *(unsigned __int8 *)(v5 + 16 * v4);
    }
LABEL_14:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v3 != 2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected parameter type value.", "!\"Unreachable code\"", "getExpressionParameterType", 84);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v4 = *(void *)(v2 + 16 * a2 + 8);
  if (*((void *)this + 67) <= v4)
  {
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v5 = *((void *)this + 69);
  return *(unsigned __int8 *)(v5 + 16 * v4);
}

uint64_t re::DynamicArray<re::RigNode>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 56 * a3;
}

uint64_t re::DynamicArray<unsigned long>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 8 * a2;
}

uint64_t re::DynamicArray<re::RigSingleChainIKHandles>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + (a3 << 7);
}

uint64_t re::DynamicArray<re::RigSplineIKHandle>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 240 * a3;
}

uint64_t re::DynamicArray<re::RigTransform>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + (a3 << 6);
}

uint64_t re::DynamicArray<re::RigJoint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 96 * a3;
}

BOOL re::anonymous namespace'::TemporaryValueValidationTable::isTemporaryValueUsed(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  if (*(void *)(a1 + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 24 * a2 + 16) + 8 * a3) != -1;
}

uint64_t re::anonymous namespace'::TemporaryValueValidationTable::getTemporaryValueUsed(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  if (*(void *)(a1 + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 24 * a2 + 16) + 8 * a3);
}

uint64_t re::anonymous namespace'::TemporaryValueValidationTable::setTemporaryValueUsed(uint64_t result, unsigned __int8 a2, unint64_t a3, uint64_t a4)
{
  if (*(void *)(result + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(*(void *)(result + 24 * a2 + 16) + 8 * a3) = a4;
  return result;
}

uint64_t re::DynamicArray<re::RigPose>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 32 * a3;
}

void re::introspect_RigConstraintType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72830, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF72830);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "InvalidConstraint";
      qword_26AF72D10 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "PointConstraint";
      qword_26AF72D18 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "OrientConstraint";
      qword_26AF72D20 = (uint64_t)v30;
      BOOL v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "ParentConstraint";
      qword_26AF72D28 = (uint64_t)v32;
      uint64_t v33 = re::introspectionAllocator(v32);
      uint64_t v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "AimConstraint";
      qword_26AF72D30 = (uint64_t)v34;
      uint64_t v35 = re::introspectionAllocator(v34);
      uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = 5;
      *(void *)(v36 + 16) = "ExpressionConstraint";
      qword_26AF72D38 = v36;
      __cxa_guard_release(&qword_26AF72830);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72838, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72838))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73378, "RigConstraintType", 1, 1, 1, 1);
    qword_26AF73378 = (uint64_t)&unk_26E715E00;
    qword_26AF733B8 = (uint64_t)&re::introspect_RigConstraintType(BOOL)::enumTable;
    dword_26AF73388 = 9;
    __cxa_guard_release(&qword_26AF72838);
  }
  if ((_MergedGlobals_15 & 1) == 0)
  {
    _MergedGlobals_15 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73378, a2);
    uint64_t v38 = 0x2C7A148B8865178ELL;
    float32x4_t v39 = "RigConstraintType";
    v42[0] = 0x31CD534126;
    v42[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v42);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v42);
      unint64_t v4 = (unsigned int *)qword_26AF733B8;
      v41[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v40.var0 = 2 * v10;
            v40.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v14, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v40.var0 = 2 * v18;
              v40.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v22, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v23);
      xmmword_26AF73398 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigConstraintType", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigBasicConstraint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72840, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72840))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF735B8, "RigBasicConstraint");
    __cxa_guard_release(&qword_26AF72840);
  }
  return &unk_26AF735B8;
}

void re::initInfo_RigBasicConstraint(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xA7153225B4A8BB36;
  v14[1] = "RigBasicConstraint";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72848, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72848);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "constraintNodeIndices";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72B48 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "constraintNodeWeights";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72B50 = v12;
      __cxa_guard_release(&qword_26AF72848);
    }
  }
  *((void *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B48;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigBasicConstraint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigBasicConstraint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigBasicConstraint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigBasicConstraint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info = (uint64_t)&unk_26E6C1308;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  unint64_t v6 = (re *)re::introspect_size_t((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info, 0);
    qword_268772220 = 0x2800000003;
    dword_268772228 = v10;
    word_26877222C = 0;
    *(void *)&xmmword_268772230 = 0;
    *((void *)&xmmword_268772230 + 1) = 0xFFFFFFFFLL;
    qword_268772240 = v9;
    unk_268772248 = 0;
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info = (uint64_t)&unk_26E6C1308;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      long long v13 = v16;
    }
    else {
      long long v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_268772230 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<float>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info = (uint64_t)&unk_26E6C13A0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  unint64_t v6 = (re *)re::introspect_float((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info, 0);
    qword_268772270 = 0x2800000003;
    dword_268772278 = v10;
    word_26877227C = 0;
    *(void *)&xmmword_268772280 = 0;
    *((void *)&xmmword_268772280 + 1) = 0xFFFFFFFFLL;
    qword_268772290 = v9;
    unk_268772298 = 0;
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info = (uint64_t)&unk_26E6C13A0;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      long long v13 = v16;
    }
    else {
      long long v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_268772280 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::RigBasicConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigBasicConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::RigBasicConstraint>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigBasicConstraint>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

void *re::allocInfo_RigComponentConstraint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72858, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72858))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73630, "RigComponentConstraint");
    __cxa_guard_release(&qword_26AF72858);
  }
  return &unk_26AF73630;
}

void re::initInfo_RigComponentConstraint(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x58E39F8DB27A6F54;
  v17[1] = "RigComponentConstraint";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72860, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72860);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<BOOL [3]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "constraintComponents";
      *(void *)(v7 + 16) = &unk_26AF73528;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72BC8 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      int v10 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "constraintNodeIndices";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72BD0 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      long long v14 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "constraintNodeWeights";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x3000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF72BD8 = v15;
      __cxa_guard_release(&qword_26AF72860);
    }
  }
  *((void *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF72BC8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigComponentConstraint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigComponentConstraint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigComponentConstraint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigComponentConstraint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

void re::IntrospectionInfo<BOOL [3]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A98, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A98))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF73528);
    __cxa_guard_release(&qword_26AF72A98);
  }
  if ((byte_26AF72816 & 1) == 0)
  {
    byte_26AF72816 = 1;
    uint64_t v2 = (const re::IntrospectionBase *)re::introspect_BOOL((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF73528, v2, 3);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF73528, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF73548 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

double re::internal::defaultConstruct<re::RigComponentConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(_WORD *)(a3 + 1) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(void *)(a3 + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigComponentConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 48);
  return re::DynamicArray<unsigned long>::deinit(a3 + 8);
}

double re::internal::defaultConstructV2<re::RigComponentConstraint>(uint64_t a1)
{
  *(unsigned char *)a1 = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigComponentConstraint>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 48);
  return re::DynamicArray<unsigned long>::deinit(a1 + 8);
}

void re::introspect_RigAimAxisType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72870, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF72870);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "PointAtConstraintNode";
      qword_26AF72BE0 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "ConstraintNodeAxis";
      qword_26AF72BE8 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = 2;
      *(void *)(v30 + 16) = "WorldAxis";
      qword_26AF72BF0 = v30;
      __cxa_guard_release(&qword_26AF72870);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72878, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72878))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF733C0, "RigAimAxisType", 1, 1, 1, 1);
    qword_26AF733C0 = (uint64_t)&unk_26E715E00;
    qword_26AF73400 = (uint64_t)&re::introspect_RigAimAxisType(BOOL)::enumTable;
    dword_26AF733D0 = 9;
    __cxa_guard_release(&qword_26AF72878);
  }
  if ((byte_26AF72811 & 1) == 0)
  {
    byte_26AF72811 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF733C0, a2);
    uint64_t v32 = 0x570029D698AED7A0;
    uint64_t v33 = "RigAimAxisType";
    v36[0] = 0x31CD534126;
    v36[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v36);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v36);
      unint64_t v4 = (unsigned int *)qword_26AF73400;
      v35[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v36, &v32, 1, 1, (uint64_t)v35);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v34.var0 = 2 * v10;
            v34.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v36, v14, &v34);
            re::StringID::destroyString((re::StringID *)&v34);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v34.var0 = 2 * v18;
              v34.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v36, v22, &v34);
              re::StringID::destroyString((re::StringID *)&v34);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v36, v23);
      xmmword_26AF733E0 = (__int128)v34;
      re::StringID::destroyString((re::StringID *)&v32);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigAimAxisType", v32, v33);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigAimConstraint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72880, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72880))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF736A8, "RigAimConstraint");
    __cxa_guard_release(&qword_26AF72880);
  }
  return &unk_26AF736A8;
}

void re::initInfo_RigAimConstraint(re *this, re::IntrospectionBase *a2)
{
  v33[0] = 0x979D610D07DC9BE4;
  v33[1] = "RigAimConstraint";
  re::StringID::destroyString((re::StringID *)v33);
  *((_OWORD *)this + 2) = v34;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72888, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72888);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<BOOL [3]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "constraintComponents";
      *(void *)(v7 + 16) = &unk_26AF73528;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72E38 = v7;
      uint64_t v8 = (re *)re::introspectionAllocator((re *)v7);
      re::introspect_RigAimAxisType(v8, v9);
      uint64_t v10 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "forwardAxisType";
      *(void *)(v10 + 16) = &qword_26AF733C0;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x300000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF72E40 = v10;
      char v11 = (re *)re::introspectionAllocator((re *)v10);
      re::introspect_RigAimAxisType(v11, v12);
      uint64_t v13 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = "upAxisType";
      *(void *)(v13 + 16) = &qword_26AF733C0;
      *(void *)(v13 + 24) = 0;
      *(void *)(v13 + 32) = 0x400000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_26AF72E48 = v13;
      uint64_t v14 = re::introspectionAllocator((re *)v13);
      uint64_t v15 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "aimAxisForward";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x1000000004;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72E50 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      uint64_t v18 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "aimAxisUp";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x2000000005;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF72E58 = v19;
      uint64_t v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "forwardConstraintNodeIndices";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x3000000006;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF72E60 = v23;
      uint64_t v24 = re::introspectionAllocator((re *)v23);
      uint64_t v26 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v25);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "forwardConstraintWeights";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x5800000007;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF72E68 = v27;
      uint64_t v28 = re::introspectionAllocator((re *)v27);
      uint64_t v30 = re::introspect_size_t((re *)1, v29);
      uint64_t v31 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v28 + 32))(v28, 72, 8);
      *(_DWORD *)uint64_t v31 = 1;
      *(void *)(v31 + 8) = "upConstraintNodeIndex";
      *(void *)(v31 + 16) = v30;
      *(void *)(v31 + 24) = 0;
      *(void *)(v31 + 32) = 0x8000000008;
      *(_DWORD *)(v31 + 40) = 0;
      *(void *)(v31 + 48) = 0;
      *(void *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_26AF72E70 = v31;
      __cxa_guard_release(&qword_26AF72888);
    }
  }
  *((void *)this + 2) = 0x9000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 8;
  *((void *)this + 8) = &qword_26AF72E38;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigAimConstraint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigAimConstraint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigAimConstraint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigAimConstraint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v32 = v34;
}

double re::internal::defaultConstruct<re::RigAimConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 60) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_DWORD *)(a3 + 112) = 0;
  *(void *)(a3 + 120) = 0;
  *(void *)(a3 + 128) = -1;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigAimConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 88);
  return re::DynamicArray<unsigned long>::deinit(a3 + 48);
}

double re::internal::defaultConstructV2<re::RigAimConstraint>(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(unsigned char *)(a1 + 4) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = -1;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigAimConstraint>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 88);
  return re::DynamicArray<unsigned long>::deinit(a1 + 48);
}

void re::introspect_RigNodeChannelType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72898, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF72898);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Invalid";
      qword_26AF72C70 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Rotation";
      qword_26AF72C78 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "Scale";
      qword_26AF72C80 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "Translation";
      qword_26AF72C88 = v32;
      __cxa_guard_release(&qword_26AF72898);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF728A0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73408, "RigNodeChannelType", 1, 1, 1, 1);
    qword_26AF73408 = (uint64_t)&unk_26E715E00;
    qword_26AF73448 = (uint64_t)&re::introspect_RigNodeChannelType(BOOL)::enumTable;
    dword_26AF73418 = 9;
    __cxa_guard_release(&qword_26AF728A0);
  }
  if ((byte_26AF72812 & 1) == 0)
  {
    byte_26AF72812 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73408, a2);
    uint64_t v34 = 0x3CBA80F78C4288D6;
    uint64_t v35 = "RigNodeChannelType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      unint64_t v4 = (unsigned int *)qword_26AF73448;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.var0 = 2 * v10;
            v36.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.var0 = 2 * v18;
              v36.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF73428 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigNodeChannelType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigNodeChannel(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF728A8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73720, "RigNodeChannel");
    __cxa_guard_release(&qword_26AF728A8);
  }
  return &unk_26AF73720;
}

void re::initInfo_RigNodeChannel(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x574CF3CA093CE322;
  v13[1] = "RigNodeChannel";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728B0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF728B0);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RigNodeChannelType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "channelType";
      *(void *)(v7 + 16) = &qword_26AF73408;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72B58 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_size_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "rigNode";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72B60 = v11;
      __cxa_guard_release(&qword_26AF728B0);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B58;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigNodeChannel>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigNodeChannel>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigNodeChannel>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigNodeChannel>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void re::internal::defaultConstruct<re::RigNodeChannel>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeChannel>(uint64_t result)
{
  *(unsigned char *)double result = 0;
  *(void *)(result + 8) = -1;
  return result;
}

void *re::allocInfo_RigNodeConstant(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF728C0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&_MergedGlobals_161, "RigNodeConstant");
    __cxa_guard_release(&qword_26AF728C0);
  }
  return &_MergedGlobals_161;
}

void re::initInfo_RigNodeConstant(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x9251857A2FE701ACLL;
  v14[1] = "RigNodeConstant";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728C8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF728C8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_EvaluationRegisterType((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "constantType";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72B68 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_size_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "constantIndex";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72B70 = v12;
      __cxa_guard_release(&qword_26AF728C8);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B68;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigNodeConstant>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigNodeConstant>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigNodeConstant>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigNodeConstant>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void re::internal::defaultConstruct<re::RigNodeConstant>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = -1;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeConstant>(uint64_t result)
{
  *(unsigned char *)double result = -1;
  *(void *)(result + 8) = -1;
  return result;
}

void *re::allocInfo_RigNodeTemporaryValue(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF728D8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_2687966A0, "RigNodeTemporaryValue");
    __cxa_guard_release(&qword_26AF728D8);
  }
  return &unk_2687966A0;
}

void re::initInfo_RigNodeTemporaryValue(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xD3DD14C91493BAA4;
  v14[1] = "RigNodeTemporaryValue";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728E0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF728E0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_EvaluationRegisterType((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "temporaryValueType";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72B78 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_size_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "temporaryValueIndex";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72B80 = v12;
      __cxa_guard_release(&qword_26AF728E0);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B78;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigNodeTemporaryValue>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigNodeTemporaryValue>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigNodeTemporaryValue>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigNodeTemporaryValue>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void re::internal::defaultConstruct<re::RigNodeTemporaryValue>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = -1;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeTemporaryValue>(uint64_t result)
{
  *(unsigned char *)double result = -1;
  *(void *)(result + 8) = -1;
  return result;
}

void re::introspect_RigExpressionParameterType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF728F0);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Invalid";
      qword_26AF72C90 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "NodeChannel";
      qword_26AF72C98 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "ConstantValue";
      qword_26AF72CA0 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "TemporaryValue";
      qword_26AF72CA8 = v32;
      __cxa_guard_release(&qword_26AF728F0);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF728F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF728F8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73450, "RigExpressionParameterType", 1, 1, 1, 1);
    qword_26AF73450 = (uint64_t)&unk_26E715E00;
    qword_26AF73490 = (uint64_t)&re::introspect_RigExpressionParameterType(BOOL)::enumTable;
    dword_26AF73460 = 9;
    __cxa_guard_release(&qword_26AF728F8);
  }
  if ((byte_26AF72813 & 1) == 0)
  {
    byte_26AF72813 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73450, a2);
    uint64_t v34 = 0x654B278C74D9AF76;
    uint64_t v35 = "RigExpressionParameterType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      unint64_t v4 = (unsigned int *)qword_26AF73490;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.var0 = 2 * v10;
            v36.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.var0 = 2 * v18;
              v36.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF73470 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigExpressionParameterType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigExpressionParameter(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72900, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72900))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796718, "RigExpressionParameter");
    __cxa_guard_release(&qword_26AF72900);
  }
  return &unk_268796718;
}

void re::initInfo_RigExpressionParameter(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x27D44DBCDBB059C2;
  v13[1] = "RigExpressionParameter";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72908, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72908);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RigExpressionParameterType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "type";
      *(void *)(v7 + 16) = &qword_26AF73450;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72B88 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_size_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "parameterIndex";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72B90 = v11;
      __cxa_guard_release(&qword_26AF72908);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B88;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigExpressionParameter>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigExpressionParameter>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigExpressionParameter>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigExpressionParameter>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void re::internal::defaultConstruct<re::RigExpressionParameter>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigExpressionParameter>(uint64_t result)
{
  *(unsigned char *)double result = 0;
  *(void *)(result + 8) = -1;
  return result;
}

void *re::allocInfo_RigExpression(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72918, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72918))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796790, "RigExpression");
    __cxa_guard_release(&qword_26AF72918);
  }
  return &unk_268796790;
}

void re::initInfo_RigExpression(re *this, re::IntrospectionBase *a2)
{
  v18[0] = 0x4D21E17B034C8750;
  v18[1] = "RigExpression";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72920, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72920);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_EvaluationCommand((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "command";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72BF8 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_size_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "expressionParameterIndexStart";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72C00 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::introspect_size_t((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "expressionDestinationParameterIndex";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x1000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72C08 = v16;
      __cxa_guard_release(&qword_26AF72920);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF72BF8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigExpression>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigExpression>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigExpression>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigExpression>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

void re::internal::defaultConstruct<re::RigExpression>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = -1;
  *(void *)(a3 + 8) = -1;
  *(void *)(a3 + 16) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigExpression>(uint64_t result)
{
  *(_DWORD *)double result = -1;
  *(void *)(result + 8) = -1;
  *(void *)(result + 16) = -1;
  return result;
}

void *re::allocInfo_RigTwoBoneIKHandles(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72930, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72930))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796808, "RigTwoBoneIKHandles");
    __cxa_guard_release(&qword_26AF72930);
  }
  return &unk_268796808;
}

void re::initInfo_RigTwoBoneIKHandles(re *this, re::IntrospectionBase *a2)
{
  v30[0] = 0xCDF945C63DA71752;
  v30[1] = "RigTwoBoneIKHandles";
  re::StringID::destroyString((re::StringID *)v30);
  *((_OWORD *)this + 2) = v31;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72938, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72938);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "rootRigNodes";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72D40 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "effectorRigNodes";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72D48 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "targetRigNodes";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x5000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72D50 = v16;
      long long v17 = re::introspectionAllocator((re *)v16);
      long long v19 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "upRigNodes";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x7800000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF72D58 = v20;
      int v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "twistOffsets";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0xA000000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF72D60 = v24;
      uint64_t v25 = re::introspectionAllocator((re *)v24);
      uint64_t v27 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "softIKPercentages";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0xC800000006;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF72D68 = v28;
      __cxa_guard_release(&qword_26AF72938);
    }
  }
  *((void *)this + 2) = 0xF000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF72D40;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigTwoBoneIKHandles>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigTwoBoneIKHandles>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigTwoBoneIKHandles>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigTwoBoneIKHandles>;
  re::IntrospectionRegistry::add(this, v3);
  long long v29 = v31;
}

double re::internal::defaultConstruct<re::RigTwoBoneIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 232) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigTwoBoneIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 200);
  re::DynamicArray<unsigned long>::deinit(a3 + 160);
  re::DynamicArray<unsigned long>::deinit(a3 + 120);
  re::DynamicArray<unsigned long>::deinit(a3 + 80);
  re::DynamicArray<unsigned long>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::RigTwoBoneIKHandles>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 232) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigTwoBoneIKHandles>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 200);
  re::DynamicArray<unsigned long>::deinit(a1 + 160);
  re::DynamicArray<unsigned long>::deinit(a1 + 120);
  re::DynamicArray<unsigned long>::deinit(a1 + 80);
  re::DynamicArray<unsigned long>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

void *re::allocInfo_RigSingleChainIKHandles(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72948, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72948))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796880, "RigSingleChainIKHandles");
    __cxa_guard_release(&qword_26AF72948);
  }
  return &unk_268796880;
}

void re::initInfo_RigSingleChainIKHandles(re *this, re::IntrospectionBase *a2)
{
  v22[0] = 0x4FC8F2E06F6B7B40;
  v22[1] = "RigSingleChainIKHandles";
  re::StringID::destroyString((re::StringID *)v22);
  *((_OWORD *)this + 2) = v23;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72950, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72950);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "rootRigNodes";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72CB0 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "effectorRigNodes";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72CB8 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "targetRigNodes";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x5000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72CC0 = v16;
      long long v17 = re::introspectionAllocator((re *)v16);
      long long v19 = re::introspect_float((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "tolerance";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x7800000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF72CC8 = v20;
      __cxa_guard_release(&qword_26AF72950);
    }
  }
  *((void *)this + 2) = 0x8000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF72CB0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigSingleChainIKHandles>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigSingleChainIKHandles>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigSingleChainIKHandles>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigSingleChainIKHandles>;
  re::IntrospectionRegistry::add(this, v3);
  long long v21 = v23;
}

double re::internal::defaultConstruct<re::RigSingleChainIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 120) = 1008981770;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSingleChainIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 80);
  re::DynamicArray<unsigned long>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::RigSingleChainIKHandles>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 120) = 1008981770;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSingleChainIKHandles>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 80);
  re::DynamicArray<unsigned long>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

void *re::allocInfo_RigSplineIKJoint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72960, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72960))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_2687968F8, "RigSplineIKJoint");
    __cxa_guard_release(&qword_26AF72960);
  }
  return &unk_2687968F8;
}

void re::initInfo_RigSplineIKJoint(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x2612B483F7D3490ELL;
  v13[1] = "RigSplineIKJoint";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72968, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72968);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_size_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "rigNodeIndex";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72B98 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v10 = re::introspect_Matrix4x4F((re::IntrospectionBase **)1);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "inverseBindPose";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72BA0 = v11;
      __cxa_guard_release(&qword_26AF72968);
    }
  }
  *((void *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72B98;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigSplineIKJoint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigSplineIKJoint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigSplineIKJoint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigSplineIKJoint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::RigSplineIKJoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = -1;
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::RigSplineIKJoint>(uint64_t a1)
{
  *(void *)a1 = -1;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  return result;
}

void *re::allocInfo_RigSplineIKControlPoint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72978, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72978))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796970, "RigSplineIKControlPoint");
    __cxa_guard_release(&qword_26AF72978);
  }
  return &unk_268796970;
}

void re::initInfo_RigSplineIKControlPoint(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0xEC09AC94D535DF2CLL;
  v17[1] = "RigSplineIKControlPoint";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72980, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72980);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "jointInfluences";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72C10 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "jointWeights";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72C18 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v14 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "bindPosition";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x5000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF72C20 = v15;
      __cxa_guard_release(&qword_26AF72980);
    }
  }
  *((void *)this + 2) = 0x6000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF72C10;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigSplineIKControlPoint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigSplineIKControlPoint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigSplineIKControlPoint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigSplineIKControlPoint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

double re::internal::defaultConstruct<re::RigSplineIKControlPoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(void *)(a3 + 80) = 0;
  *(void *)(a3 + 88) = 0;
  *(void *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSplineIKControlPoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::RigSplineIKControlPoint>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSplineIKControlPoint>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

void *re::allocInfo_RigSplineIKHandle(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72990, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72990))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_2687969E8, "RigSplineIKHandle");
    __cxa_guard_release(&qword_26AF72990);
  }
  return &unk_2687969E8;
}

void re::initInfo_RigSplineIKHandle(re *this, re::IntrospectionBase *a2)
{
  v31[0] = 0x9C43DBFAFA3C2396;
  v31[1] = "RigSplineIKHandle";
  re::StringID::destroyString((re::StringID *)v31);
  *((_OWORD *)this + 2) = v32;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72998, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72998);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKJoint>>::get(v5);
      uint64_t v6 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "joints";
      *(void *)(v6 + 16) = &qword_26AF72E78;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0x800000001;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF72E00 = v6;
      uint64_t v7 = (re *)re::introspectionAllocator((re *)v6);
      re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKControlPoint>>::get(v7);
      uint64_t v8 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "controlPoints";
      *(void *)(v8 + 16) = &qword_26AF72EB8;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x3000000002;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72E08 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "knots";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x5800000003;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72E10 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_size_t((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "rootRigNode";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x8000000004;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72E18 = v16;
      long long v17 = re::introspectionAllocator((re *)v16);
      long long v19 = re::introspect_size_t((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "endEffectorRigNode";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x8800000005;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF72E20 = v20;
      long long v21 = re::introspectionAllocator((re *)v20);
      long long v23 = re::introspect_size_t((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "splineBindTransformNodeIndex";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x9000000006;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF72E28 = v24;
      uint64_t v25 = (re *)re::introspectionAllocator((re *)v24);
      uint64_t v26 = v25;
      uint64_t v27 = (re *)qword_26AF729B8;
      if (!qword_26AF729B8)
      {
        uint64_t v27 = (re *)re::allocInfo_RigIKTwistControls(v25);
        qword_26AF729B8 = (uint64_t)v27;
        re::initInfo_RigIKTwistControls(v27, v28);
      }
      uint64_t v29 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v26 + 32))(v26, 72, 8);
      *(_DWORD *)uint64_t v29 = 1;
      *(void *)(v29 + 8) = "twistControls";
      *(void *)(v29 + 16) = v27;
      *(void *)(v29 + 24) = 0;
      *(void *)(v29 + 32) = 0xA000000007;
      *(_DWORD *)(v29 + 40) = 0;
      *(void *)(v29 + 48) = 0;
      *(void *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_26AF72E30 = v29;
      __cxa_guard_release(&qword_26AF72998);
    }
  }
  *((void *)this + 2) = 0xF000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 7;
  *((void *)this + 8) = &qword_26AF72E00;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigSplineIKHandle>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigSplineIKHandle>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigSplineIKHandle>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigSplineIKHandle>;
  re::IntrospectionRegistry::add(this, v3);
  long long v30 = v32;
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKJoint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AA0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AA0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72E78);
      qword_26AF72E78 = (uint64_t)&unk_26E6C1438;
      __cxa_guard_release(&qword_26AF72AA0);
    }
  }
  if ((byte_26AF72817 & 1) == 0)
  {
    v1 = (void *)qword_26AF72970;
    if (qword_26AF72970
      || (v1 = re::allocInfo_RigSplineIKJoint(a1),
          qword_26AF72970 = (uint64_t)v1,
          re::initInfo_RigSplineIKJoint((re *)v1, v2),
          (byte_26AF72817 & 1) == 0))
    {
      byte_26AF72817 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72E78, 0);
      qword_26AF72E88 = 0x2800000003;
      dword_26AF72E90 = v3;
      word_26AF72E94 = 0;
      *(void *)&xmmword_26AF72E98 = 0;
      *((void *)&xmmword_26AF72E98 + 1) = 0xFFFFFFFFLL;
      qword_26AF72EA8 = (uint64_t)v1;
      qword_26AF72EB0 = 0;
      qword_26AF72E78 = (uint64_t)&unk_26E6C1438;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72E78, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72E98 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKControlPoint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AA8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AA8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72EB8);
      qword_26AF72EB8 = (uint64_t)&unk_26E6C14D0;
      __cxa_guard_release(&qword_26AF72AA8);
    }
  }
  if ((byte_26AF72818 & 1) == 0)
  {
    v1 = (void *)qword_26AF72988;
    if (qword_26AF72988
      || (v1 = re::allocInfo_RigSplineIKControlPoint(a1),
          qword_26AF72988 = (uint64_t)v1,
          re::initInfo_RigSplineIKControlPoint((re *)v1, v2),
          (byte_26AF72818 & 1) == 0))
    {
      byte_26AF72818 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72EB8, 0);
      qword_26AF72EC8 = 0x2800000003;
      dword_26AF72ED0 = v3;
      word_26AF72ED4 = 0;
      *(void *)&xmmword_26AF72ED8 = 0;
      *((void *)&xmmword_26AF72ED8 + 1) = 0xFFFFFFFFLL;
      qword_26AF72EE8 = (uint64_t)v1;
      qword_26AF72EF0 = 0;
      qword_26AF72EB8 = (uint64_t)&unk_26E6C14D0;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72EB8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72ED8 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

double re::internal::defaultConstruct<re::RigSplineIKHandle>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 1008981770;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_DWORD *)(a3 + 112) = 0;
  *(void *)(a3 + 160) = -1;
  *(void *)(a3 + 168) = -1;
  *(void *)(a3 + 120) = 0;
  *(void *)(a3 + 128) = -1;
  *(void *)(a3 + 136) = -1;
  *(void *)(a3 + 144) = -1;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSplineIKHandle>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 88);
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a3 + 48);
  return re::DynamicArray<unsigned long>::deinit(a3 + 8);
}

double re::internal::defaultConstructV2<re::RigSplineIKHandle>(uint64_t a1)
{
  *(_DWORD *)a1 = 1008981770;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 160) = -1;
  *(void *)(a1 + 168) = -1;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 136) = -1;
  *(void *)(a1 + 144) = -1;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSplineIKHandle>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 88);
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a1 + 48);
  return re::DynamicArray<unsigned long>::deinit(a1 + 8);
}

void *re::allocInfo_RigIKTwistControls(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF729A8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796A60, "RigIKTwistControls");
    __cxa_guard_release(&qword_26AF729A8);
  }
  return &unk_268796A60;
}

void re::initInfo_RigIKTwistControls(re *this, re::IntrospectionBase *a2)
{
  v27[0] = 0x47666560A0227416;
  v27[1] = "RigIKTwistControls";
  re::StringID::destroyString((re::StringID *)v27);
  *((_OWORD *)this + 2) = v28;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729B0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF729B0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_size_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "startTwistRigNode";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72D70 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      long long v11 = re::introspect_size_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "endTwistRigNode";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72D78 = v12;
      long long v13 = re::introspectionAllocator((re *)v12);
      uint64_t v14 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "startTwistUpAxis";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x1000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF72D80 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      uint64_t v17 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "endTwistUpAxis";
      *(void *)(v18 + 16) = v17;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0x2000000004;
      *(_DWORD *)(v18 + 40) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF72D88 = v18;
      long long v19 = re::introspectionAllocator((re *)v18);
      uint64_t v20 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v21 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v19 + 32))(v19, 72, 8);
      *(_DWORD *)uint64_t v21 = 1;
      *(void *)(v21 + 8) = "ikChainUpAxis";
      *(void *)(v21 + 16) = v20;
      *(void *)(v21 + 24) = 0;
      *(void *)(v21 + 32) = 0x3000000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(void *)(v21 + 48) = 0;
      *(void *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_26AF72D90 = v21;
      uint64_t v22 = re::introspectionAllocator((re *)v21);
      uint64_t v24 = re::introspect_float((re *)1, v23);
      uint64_t v25 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v22 + 32))(v22, 72, 8);
      *(_DWORD *)uint64_t v25 = 1;
      *(void *)(v25 + 8) = "twistOffset";
      *(void *)(v25 + 16) = v24;
      *(void *)(v25 + 24) = 0;
      *(void *)(v25 + 32) = 0x4000000006;
      *(_DWORD *)(v25 + 40) = 0;
      *(void *)(v25 + 48) = 0;
      *(void *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_26AF72D98 = v25;
      __cxa_guard_release(&qword_26AF729B0);
    }
  }
  *((void *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF72D70;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigIKTwistControls>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigIKTwistControls>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigIKTwistControls>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigIKTwistControls>;
  re::IntrospectionRegistry::add(this, v3);
  long long v26 = v28;
}

double re::internal::defaultConstruct<re::RigIKTwistControls>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = -1;
  *(void *)(a3 + 8) = -1;
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::RigIKTwistControls>(uint64_t a1)
{
  *(void *)a1 = -1;
  *(void *)(a1 + 8) = -1;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

void re::introspect_RigIKHandleType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729C0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF729C0);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      long long v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)long long v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Invalid";
      qword_26AF72CD0 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      long long v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)long long v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "TwoBone";
      qword_26AF72CD8 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      long long v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)long long v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "SingleChain";
      qword_26AF72CE0 = (uint64_t)v30;
      long long v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "Spline";
      qword_26AF72CE8 = v32;
      __cxa_guard_release(&qword_26AF729C0);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF729C8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73498, "RigIKHandleType", 1, 1, 1, 1);
    qword_26AF73498 = (uint64_t)&unk_26E715E00;
    qword_26AF734D8 = (uint64_t)&re::introspect_RigIKHandleType(BOOL)::enumTable;
    dword_26AF734A8 = 9;
    __cxa_guard_release(&qword_26AF729C8);
  }
  if ((byte_26AF72814 & 1) == 0)
  {
    byte_26AF72814 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73498, a2);
    uint64_t v34 = 0x8DF3E5D041D1B268;
    uint64_t v35 = "RigIKHandleType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      unint64_t v4 = (unsigned int *)qword_26AF734D8;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.var0 = 2 * v10;
            v36.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.var0 = 2 * v18;
              v36.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF734B8 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigIKHandleType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigIKHandles(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF729D0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796AD8, "RigIKHandles");
    __cxa_guard_release(&qword_26AF729D0);
  }
  return &unk_268796AD8;
}

void re::initInfo_RigIKHandles(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x3C4B6E422A8111B2;
  v13[1] = "RigIKHandles";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729D8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF729D8);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RigIKHandleType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "type";
      *(void *)(v7 + 16) = &qword_26AF73498;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72BA8 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_size_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "ikHandleIndex";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72BB0 = v11;
      __cxa_guard_release(&qword_26AF729D8);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72BA8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigIKHandles>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigIKHandles>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigIKHandles>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigIKHandles>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void re::internal::defaultConstruct<re::RigIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigIKHandles>(uint64_t result)
{
  *(unsigned char *)double result = 0;
  *(void *)(result + 8) = -1;
  return result;
}

void *re::allocInfo_RigTransform(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF729E8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796B50, "RigTransform");
    __cxa_guard_release(&qword_26AF729E8);
  }
  return &unk_268796B50;
}

void re::initInfo_RigTransform(re *this, re::IntrospectionBase *a2)
{
  v19[0] = 0x3C4B815110E2B0B8;
  v19[1] = "RigTransform";
  re::StringID::destroyString((re::StringID *)v19);
  *((_OWORD *)this + 2) = v20;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF729F0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF729F0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "translation";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72CF0 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v9 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "rotation";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1000000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF72CF8 = v10;
      uint64_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v12 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = "scale";
      *(void *)(v13 + 16) = v12;
      *(void *)(v13 + 24) = 0;
      *(void *)(v13 + 32) = 0x2000000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_26AF72D00 = v13;
      long long v14 = re::introspectionAllocator((re *)v13);
      uint64_t v16 = re::introspect_RERotationOrder((re *)1, v15);
      uint64_t v17 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 72, 8);
      *(_DWORD *)uint64_t v17 = 1;
      *(void *)(v17 + 8) = "rotationOrder";
      *(void *)(v17 + 16) = v16;
      *(void *)(v17 + 24) = 0;
      *(void *)(v17 + 32) = 0x3000000004;
      *(_DWORD *)(v17 + 40) = 0;
      *(void *)(v17 + 48) = 0;
      *(void *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_26AF72D08 = v17;
      __cxa_guard_release(&qword_26AF729F0);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF72CF0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigTransform>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigTransform>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigTransform>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigTransform>;
  re::IntrospectionRegistry::add(this, v3);
  long long v18 = v20;
}

double re::internal::defaultConstruct<re::RigTransform>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 32) = 0x3F8000003F800000;
  *(void *)(a3 + 40) = 1065353216;
  *(unsigned char *)(a3 + 48) = 7;
  return result;
}

double re::internal::defaultConstructV2<re::RigTransform>(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 32) = 0x3F8000003F800000;
  *(void *)(a1 + 40) = 1065353216;
  *(unsigned char *)(a1 + 48) = 7;
  return result;
}

void *re::allocInfo_RigJoint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A00, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A00))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796BC8, "RigJoint");
    __cxa_guard_release(&qword_26AF72A00);
  }
  return &unk_268796BC8;
}

void re::initInfo_RigJoint(re *this, re::IntrospectionBase *a2)
{
  v25[0] = 0x44759315AF4;
  v25[1] = "RigJoint";
  re::StringID::destroyString((re::StringID *)v25);
  *((_OWORD *)this + 2) = v26;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A08, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A08);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "translation";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72DA0 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v9 = re::introspect_QuaternionF((re::IntrospectionBase **)1);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "orientation";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1000000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF72DA8 = v10;
      uint64_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v12 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = "rotation";
      *(void *)(v13 + 16) = v12;
      *(void *)(v13 + 24) = 0;
      *(void *)(v13 + 32) = 0x2000000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_26AF72DB0 = v13;
      long long v14 = re::introspectionAllocator((re *)v13);
      uint64_t v15 = re::introspect_QuaternionF((re::IntrospectionBase **)1);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "scaleOrientation";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x3000000004;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72DB8 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      uint64_t v18 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "scale";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x4000000005;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF72DC0 = v19;
      long long v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_RERotationOrder((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "rotationOrder";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x5000000006;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF72DC8 = v23;
      __cxa_guard_release(&qword_26AF72A08);
    }
  }
  *((void *)this + 2) = 0x6000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF72DA0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigJoint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigJoint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigJoint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigJoint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v24 = v26;
}

double re::internal::defaultConstruct<re::RigJoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = xmmword_23435FBB0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = xmmword_23435FBB0;
  *(void *)(a3 + 64) = 0x3F8000003F800000;
  *(void *)(a3 + 72) = 1065353216;
  *(unsigned char *)(a3 + 80) = 7;
  return result;
}

double re::internal::defaultConstructV2<re::RigJoint>(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = xmmword_23435FBB0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = xmmword_23435FBB0;
  *(void *)(a1 + 64) = 0x3F8000003F800000;
  *(void *)(a1 + 72) = 1065353216;
  *(unsigned char *)(a1 + 80) = 7;
  return result;
}

void *re::allocInfo_RigNodeConstraint(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A18))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796C40, "RigNodeConstraint");
    __cxa_guard_release(&qword_26AF72A18);
  }
  return &unk_268796C40;
}

void re::initInfo_RigNodeConstraint(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x44060FADD4005D1ELL;
  v13[1] = "RigNodeConstraint";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A20, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A20);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RigConstraintType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "type";
      *(void *)(v7 + 16) = &qword_26AF73378;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72BB8 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_size_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "constraintIndex";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72BC0 = v11;
      __cxa_guard_release(&qword_26AF72A20);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF72BB8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigNodeConstraint>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigNodeConstraint>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigNodeConstraint>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigNodeConstraint>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void re::internal::defaultConstruct<re::RigNodeConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeConstraint>(uint64_t result)
{
  *(unsigned char *)double result = 0;
  *(void *)(result + 8) = -1;
  return result;
}

void re::introspect_RigNodeType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A30, memory_order_acquire) & 1) == 0)
  {
    long long v24 = (re *)__cxa_guard_acquire(&qword_26AF72A30);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      long long v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)long long v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Invalid";
      qword_26AF72C28 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      long long v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)long long v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Transform";
      qword_26AF72C30 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = 2;
      *(void *)(v30 + 16) = "Joint";
      qword_26AF72C38 = v30;
      __cxa_guard_release(&qword_26AF72A30);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A38))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF734E0, "RigNodeType", 1, 1, 1, 1);
    qword_26AF734E0 = (uint64_t)&unk_26E715E00;
    qword_26AF73520 = (uint64_t)&re::introspect_RigNodeType(BOOL)::enumTable;
    dword_26AF734F0 = 9;
    __cxa_guard_release(&qword_26AF72A38);
  }
  if ((byte_26AF72815 & 1) == 0)
  {
    byte_26AF72815 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF734E0, a2);
    uint64_t v32 = 0x1F1EB17A3692AD8;
    uint64_t v33 = "RigNodeType";
    v36[0] = 0x31CD534126;
    v36[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v36);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v36);
      unint64_t v4 = (unsigned int *)qword_26AF73520;
      v35[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v36, &v32, 1, 1, (uint64_t)v35);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  long long v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v34.var0 = 2 * v10;
            v34.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v36, v14, &v34);
            re::StringID::destroyString((re::StringID *)&v34);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    long long v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v34.var0 = 2 * v18;
              v34.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v36, v22, &v34);
              re::StringID::destroyString((re::StringID *)&v34);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v36, v23);
      xmmword_26AF73500 = (__int128)v34;
      re::StringID::destroyString((re::StringID *)&v32);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigNodeType", v32, v33);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RigNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A40))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796CB8, "RigNode");
    __cxa_guard_release(&qword_26AF72A40);
  }
  return &unk_268796CB8;
}

void re::initInfo_RigNode(re *this, re::IntrospectionBase *a2)
{
  v29[0] = 0x235578D624;
  v29[1] = "RigNode";
  re::StringID::destroyString((re::StringID *)v29);
  *((_OWORD *)this + 2) = v30;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A48, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A48);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72DD0 = v8;
      uint64_t v9 = (re *)re::introspectionAllocator((re *)v8);
      re::introspect_RigNodeType(v9, v10);
      uint64_t v11 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "nodeType";
      *(void *)(v11 + 16) = &qword_26AF734E0;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72DD8 = v11;
      long long v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_size_t((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "index";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x1800000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF72DE0 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_size_t((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "parentIndex";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x2000000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF72DE8 = v19;
      long long v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_size_t((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "constraintCount";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x2800000005;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF72DF0 = v23;
      long long v24 = re::introspectionAllocator((re *)v23);
      long long v26 = re::introspect_size_t((re *)1, v25);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "constraintStartIndex";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x3000000006;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF72DF8 = v27;
      __cxa_guard_release(&qword_26AF72A48);
    }
  }
  *((void *)this + 2) = 0x3800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF72DD0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v28 = v30;
}

double re::internal::defaultConstruct<re::RigNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  *(unsigned char *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = -1;
  *(void *)(a3 + 32) = -1;
  double result = 0.0;
  *(_OWORD *)(a3 + 40) = xmmword_234361D10;
  return result;
}

void re::internal::defaultDestruct<re::RigNode>(int a1, int a2, re::StringID *this)
{
}

double re::internal::defaultConstructV2<re::RigNode>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 32) = -1;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = xmmword_234361D10;
  return result;
}

void *re::allocInfo_RigPoseNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A58))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796D30, "RigPoseNode");
    __cxa_guard_release(&qword_26AF72A58);
  }
  return &unk_268796D30;
}

void re::initInfo_RigPoseNode(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x1F1EB3176197E86;
  v17[1] = "RigPoseNode";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A60, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A60);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RigNodeType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "nodeType";
      *(void *)(v7 + 16) = &qword_26AF734E0;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF72C40 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_size_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "nodeIndex";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF72C48 = v11;
      long long v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_size_t((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "rigNodeIndex";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x1000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF72C50 = v15;
      __cxa_guard_release(&qword_26AF72A60);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF72C40;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigPoseNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigPoseNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigPoseNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigPoseNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

void re::internal::defaultConstruct<re::RigPoseNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = -1;
  *(void *)(a3 + 16) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigPoseNode>(uint64_t result)
{
  *(unsigned char *)double result = 0;
  *(void *)(result + 8) = -1;
  *(void *)(result + 16) = -1;
  return result;
}

void *re::allocInfo_RigPose(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A70))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796DA8, "RigPose");
    __cxa_guard_release(&qword_26AF72A70);
  }
  return &unk_268796DA8;
}

void re::initInfo_RigPose(re *this, re::IntrospectionBase *a2)
{
  v18[0] = 0x23557AAB42;
  v18[1] = "RigPose";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A78, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A78);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF72C58 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_size_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "poseNodeCount";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF72C60 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_size_t((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "poseNodeStartIndex";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x1800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF72C68 = v16;
      __cxa_guard_release(&qword_26AF72A78);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF72C58;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigPose>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigPose>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigPose>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigPose>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

double re::internal::defaultConstruct<re::RigPose>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = xmmword_234361D10;
  return result;
}

void re::internal::defaultDestruct<re::RigPose>(int a1, int a2, re::StringID *this)
{
}

double re::internal::defaultConstructV2<re::RigPose>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_234361D10;
  return result;
}

void *re::allocInfo_RigDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A88, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72A88))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_268796E20, "RigDefinition");
    __cxa_guard_release(&qword_26AF72A88);
  }
  return &unk_268796E20;
}

void re::initInfo_RigDefinition(re *this, re::IntrospectionBase *a2)
{
  v50[0] = 0x4D2193656067CCC6;
  v50[1] = "RigDefinition";
  re::StringID::destroyString((re::StringID *)v50);
  *((_OWORD *)this + 2) = v51;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72A90, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF72A90);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get(v5);
      uint64_t v6 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "pointConstraints";
      *(void *)(v6 + 16) = &qword_26AF72EF8;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_268796E98 = v6;
      uint64_t v7 = (re *)re::introspectionAllocator((re *)v6);
      re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get(v7);
      uint64_t v8 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "orientConstraints";
      *(void *)(v8 + 16) = &qword_26AF72EF8;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x2800000002;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_268796EA0 = v8;
      uint64_t v9 = (re *)re::introspectionAllocator((re *)v8);
      re::IntrospectionInfo<re::DynamicArray<re::RigBasicConstraint>>::get(v9);
      uint64_t v10 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "parentConstraints";
      *(void *)(v10 + 16) = &qword_26AF72F38;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x5000000003;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_268796EA8 = v10;
      uint64_t v11 = (re *)re::introspectionAllocator((re *)v10);
      re::IntrospectionInfo<re::DynamicArray<re::RigAimConstraint>>::get(v11);
      uint64_t v12 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "aimConstraints";
      *(void *)(v12 + 16) = &qword_26AF72F78;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x7800000004;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_268796EB0 = v12;
      int v13 = (re *)re::introspectionAllocator((re *)v12);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeChannel>>::get(v13);
      uint64_t v14 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "nodeChannels";
      *(void *)(v14 + 16) = &qword_26AF72FB8;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0xA000000005;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_268796EB8 = v14;
      uint64_t v15 = re::introspectionAllocator((re *)v14);
      uint64_t v16 = re::introspect_DynamicRegisterTable((re::IntrospectionBase **)1);
      uint64_t v17 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, 72, 8);
      *(_DWORD *)uint64_t v17 = 1;
      *(void *)(v17 + 8) = "constantValues";
      *(void *)(v17 + 16) = v16;
      *(void *)(v17 + 24) = 0;
      *(void *)(v17 + 32) = 0xC800000006;
      *(_DWORD *)(v17 + 40) = 0;
      *(void *)(v17 + 48) = 0;
      *(void *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_268796EC0 = v17;
      long long v18 = (re *)re::introspectionAllocator((re *)v17);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstant>>::get(v18);
      uint64_t v19 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "rigNodeConstants";
      *(void *)(v19 + 16) = &qword_26AF72FF8;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x20800000007;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_268796EC8 = v19;
      long long v20 = re::introspectionAllocator((re *)v19);
      re::IntrospectionInfo<unsigned long [8]>::get((uint64_t)v20, v21);
      uint64_t v22 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v22 = 1;
      *(void *)(v22 + 8) = "temporaryValueCounts";
      *(void *)(v22 + 16) = &unk_26AF73570;
      *(void *)(v22 + 24) = 0;
      *(void *)(v22 + 32) = 0x23000000008;
      *(_DWORD *)(v22 + 40) = 0;
      *(void *)(v22 + 48) = 0;
      *(void *)(v22 + 56) = 0;
      *(_DWORD *)(v22 + 64) = 0;
      qword_268796ED0 = v22;
      uint64_t v23 = (re *)re::introspectionAllocator((re *)v22);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeTemporaryValue>>::get(v23);
      uint64_t v24 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v23 + 32))(v23, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "rigNodeTemporaryValues";
      *(void *)(v24 + 16) = &qword_26AF73038;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x27000000009;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_268796ED8 = v24;
      uint64_t v25 = (re *)re::introspectionAllocator((re *)v24);
      re::IntrospectionInfo<re::DynamicArray<re::RigExpressionParameter>>::get(v25);
      uint64_t v26 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *(void *)(v26 + 8) = "expressionParameters";
      *(void *)(v26 + 16) = &qword_26AF73078;
      *(void *)(v26 + 24) = 0;
      *(void *)(v26 + 32) = 0x2980000000ALL;
      *(_DWORD *)(v26 + 40) = 0;
      *(void *)(v26 + 48) = 0;
      *(void *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_268796EE0 = v26;
      uint64_t v27 = (re *)re::introspectionAllocator((re *)v26);
      re::IntrospectionInfo<re::DynamicArray<re::RigExpression>>::get(v27);
      uint64_t v28 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "expressions";
      *(void *)(v28 + 16) = &qword_26AF730B8;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x2C00000000BLL;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_268796EE8 = v28;
      uint64_t v29 = (re *)re::introspectionAllocator((re *)v28);
      re::IntrospectionInfo<re::DynamicArray<re::RigTwoBoneIKHandles>>::get(v29);
      uint64_t v30 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 72, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = "twoBoneIKHandles";
      *(void *)(v30 + 16) = &qword_26AF730F8;
      *(void *)(v30 + 24) = 0;
      *(void *)(v30 + 32) = 0x2E80000000CLL;
      *(_DWORD *)(v30 + 40) = 0;
      *(void *)(v30 + 48) = 0;
      *(void *)(v30 + 56) = 0;
      *(_DWORD *)(v30 + 64) = 0;
      qword_268796EF0 = v30;
      uint64_t v31 = (re *)re::introspectionAllocator((re *)v30);
      re::IntrospectionInfo<re::DynamicArray<re::RigSingleChainIKHandles>>::get(v31);
      uint64_t v32 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 72, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = "singleChainIKHandles";
      *(void *)(v32 + 16) = &qword_26AF73138;
      *(void *)(v32 + 24) = 0;
      *(void *)(v32 + 32) = 0x3100000000DLL;
      *(_DWORD *)(v32 + 40) = 0;
      *(void *)(v32 + 48) = 0;
      *(void *)(v32 + 56) = 0;
      *(_DWORD *)(v32 + 64) = 0;
      qword_268796EF8 = v32;
      uint64_t v33 = (re *)re::introspectionAllocator((re *)v32);
      re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKHandle>>::get(v33);
      uint64_t v34 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 72, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *(void *)(v34 + 8) = "splineIKHandles";
      *(void *)(v34 + 16) = &qword_26AF73178;
      *(void *)(v34 + 24) = 0;
      *(void *)(v34 + 32) = 0x3380000000ELL;
      *(_DWORD *)(v34 + 40) = 0;
      *(void *)(v34 + 48) = 0;
      *(void *)(v34 + 56) = 0;
      *(_DWORD *)(v34 + 64) = 0;
      qword_268796F00 = v34;
      uint64_t v35 = (re *)re::introspectionAllocator((re *)v34);
      re::IntrospectionInfo<re::DynamicArray<re::RigTransform>>::get(v35);
      uint64_t v36 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 72, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = "transforms";
      *(void *)(v36 + 16) = &qword_26AF731B8;
      *(void *)(v36 + 24) = 0;
      *(void *)(v36 + 32) = 0x3600000000FLL;
      *(_DWORD *)(v36 + 40) = 0;
      *(void *)(v36 + 48) = 0;
      *(void *)(v36 + 56) = 0;
      *(_DWORD *)(v36 + 64) = 0;
      qword_268796F08 = v36;
      uint64_t v37 = (re *)re::introspectionAllocator((re *)v36);
      re::IntrospectionInfo<re::DynamicArray<re::RigJoint>>::get(v37);
      uint64_t v38 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, 72, 8);
      *(_DWORD *)uint64_t v38 = 1;
      *(void *)(v38 + 8) = "joints";
      *(void *)(v38 + 16) = &qword_26AF731F8;
      *(void *)(v38 + 24) = 0;
      *(void *)(v38 + 32) = 0x38800000010;
      *(_DWORD *)(v38 + 40) = 0;
      *(void *)(v38 + 48) = 0;
      *(void *)(v38 + 56) = 0;
      *(_DWORD *)(v38 + 64) = 0;
      qword_268796F10 = v38;
      float32x4_t v39 = (re *)re::introspectionAllocator((re *)v38);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstraint>>::get(v39);
      uint64_t v40 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v39 + 32))(v39, 72, 8);
      *(_DWORD *)uint64_t v40 = 1;
      *(void *)(v40 + 8) = "constraints";
      *(void *)(v40 + 16) = &qword_26AF73238;
      *(void *)(v40 + 24) = 0;
      *(void *)(v40 + 32) = 0x3B000000011;
      *(_DWORD *)(v40 + 40) = 0;
      *(void *)(v40 + 48) = 0;
      *(void *)(v40 + 56) = 0;
      *(_DWORD *)(v40 + 64) = 0;
      qword_268796F18 = v40;
      float32x4_t v41 = (re *)re::introspectionAllocator((re *)v40);
      re::IntrospectionInfo<re::DynamicArray<re::RigIKHandles>>::get(v41);
      uint64_t v42 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v41 + 32))(v41, 72, 8);
      *(_DWORD *)uint64_t v42 = 1;
      *(void *)(v42 + 8) = "ikHandles";
      *(void *)(v42 + 16) = &qword_26AF73278;
      *(void *)(v42 + 24) = 0;
      *(void *)(v42 + 32) = 0x3D800000012;
      *(_DWORD *)(v42 + 40) = 0;
      *(void *)(v42 + 48) = 0;
      *(void *)(v42 + 56) = 0;
      *(_DWORD *)(v42 + 64) = 0;
      qword_268796F20 = v42;
      float v43 = (re *)re::introspectionAllocator((re *)v42);
      re::IntrospectionInfo<re::DynamicArray<re::RigNode>>::get(v43);
      uint64_t v44 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v43 + 32))(v43, 72, 8);
      *(_DWORD *)uint64_t v44 = 1;
      *(void *)(v44 + 8) = "rigNodes";
      *(void *)(v44 + 16) = &qword_26AF732B8;
      *(void *)(v44 + 24) = 0;
      *(void *)(v44 + 32) = 0x40000000013;
      *(_DWORD *)(v44 + 40) = 0;
      *(void *)(v44 + 48) = 0;
      *(void *)(v44 + 56) = 0;
      *(_DWORD *)(v44 + 64) = 0;
      qword_268796F28 = v44;
      uint64_t v45 = (re *)re::introspectionAllocator((re *)v44);
      re::IntrospectionInfo<re::DynamicArray<re::RigPoseNode>>::get(v45);
      uint64_t v46 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v45 + 32))(v45, 72, 8);
      *(_DWORD *)uint64_t v46 = 1;
      *(void *)(v46 + 8) = "poseNodes";
      *(void *)(v46 + 16) = &qword_26AF732F8;
      *(void *)(v46 + 24) = 0;
      *(void *)(v46 + 32) = 0x42800000014;
      *(_DWORD *)(v46 + 40) = 0;
      *(void *)(v46 + 48) = 0;
      *(void *)(v46 + 56) = 0;
      *(_DWORD *)(v46 + 64) = 0;
      qword_268796F30 = v46;
      float32x4_t v47 = (re *)re::introspectionAllocator((re *)v46);
      re::IntrospectionInfo<re::DynamicArray<re::RigPose>>::get(v47);
      uint64_t v48 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v47 + 32))(v47, 72, 8);
      *(_DWORD *)uint64_t v48 = 1;
      *(void *)(v48 + 8) = "rigPoses";
      *(void *)(v48 + 16) = &qword_26AF73338;
      *(void *)(v48 + 24) = 0;
      *(void *)(v48 + 32) = 0x45000000015;
      *(_DWORD *)(v48 + 40) = 0;
      *(void *)(v48 + 48) = 0;
      *(void *)(v48 + 56) = 0;
      *(_DWORD *)(v48 + 64) = 0;
      qword_268796F38 = v48;
      __cxa_guard_release(&qword_26AF72A90);
    }
  }
  *((void *)this + 2) = 0x47800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 21;
  *((void *)this + 8) = &qword_268796E98;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RigDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RigDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RigDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RigDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v49 = v51;
}

void re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AB0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AB0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72EF8);
      qword_26AF72EF8 = (uint64_t)&unk_26E6C1568;
      __cxa_guard_release(&qword_26AF72AB0);
    }
  }
  if ((byte_26AF72819 & 1) == 0)
  {
    v1 = (void *)qword_26AF72868;
    if (qword_26AF72868
      || (v1 = re::allocInfo_RigComponentConstraint(a1),
          qword_26AF72868 = (uint64_t)v1,
          re::initInfo_RigComponentConstraint((re *)v1, v2),
          (byte_26AF72819 & 1) == 0))
    {
      byte_26AF72819 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72EF8, 0);
      qword_26AF72F08 = 0x2800000003;
      dword_26AF72F10 = v3;
      word_26AF72F14 = 0;
      *(void *)&xmmword_26AF72F18 = 0;
      *((void *)&xmmword_26AF72F18 + 1) = 0xFFFFFFFFLL;
      qword_26AF72F28 = (uint64_t)v1;
      qword_26AF72F30 = 0;
      qword_26AF72EF8 = (uint64_t)&unk_26E6C1568;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72EF8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72F18 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigBasicConstraint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AB8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AB8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72F38);
      qword_26AF72F38 = (uint64_t)&unk_26E6C1600;
      __cxa_guard_release(&qword_26AF72AB8);
    }
  }
  if ((byte_26AF7281A & 1) == 0)
  {
    v1 = (void *)qword_26AF72850;
    if (qword_26AF72850
      || (v1 = re::allocInfo_RigBasicConstraint(a1),
          qword_26AF72850 = (uint64_t)v1,
          re::initInfo_RigBasicConstraint((re *)v1, v2),
          (byte_26AF7281A & 1) == 0))
    {
      byte_26AF7281A = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72F38, 0);
      qword_26AF72F48 = 0x2800000003;
      dword_26AF72F50 = v3;
      word_26AF72F54 = 0;
      *(void *)&xmmword_26AF72F58 = 0;
      *((void *)&xmmword_26AF72F58 + 1) = 0xFFFFFFFFLL;
      qword_26AF72F68 = (uint64_t)v1;
      qword_26AF72F70 = 0;
      qword_26AF72F38 = (uint64_t)&unk_26E6C1600;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72F38, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72F58 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigAimConstraint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AC0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AC0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72F78);
      qword_26AF72F78 = (uint64_t)&unk_26E6C1698;
      __cxa_guard_release(&qword_26AF72AC0);
    }
  }
  if ((byte_26AF7281B & 1) == 0)
  {
    v1 = (void *)qword_26AF72890;
    if (qword_26AF72890
      || (v1 = re::allocInfo_RigAimConstraint(a1),
          qword_26AF72890 = (uint64_t)v1,
          re::initInfo_RigAimConstraint((re *)v1, v2),
          (byte_26AF7281B & 1) == 0))
    {
      byte_26AF7281B = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72F78, 0);
      qword_26AF72F88 = 0x2800000003;
      dword_26AF72F90 = v3;
      word_26AF72F94 = 0;
      *(void *)&xmmword_26AF72F98 = 0;
      *((void *)&xmmword_26AF72F98 + 1) = 0xFFFFFFFFLL;
      qword_26AF72FA8 = (uint64_t)v1;
      qword_26AF72FB0 = 0;
      qword_26AF72F78 = (uint64_t)&unk_26E6C1698;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72F78, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72F98 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeChannel>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AC8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AC8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72FB8);
      qword_26AF72FB8 = (uint64_t)&unk_26E6C1730;
      __cxa_guard_release(&qword_26AF72AC8);
    }
  }
  if ((byte_26AF7281C & 1) == 0)
  {
    v1 = (void *)qword_26AF728B8;
    if (qword_26AF728B8
      || (v1 = re::allocInfo_RigNodeChannel(a1),
          qword_26AF728B8 = (uint64_t)v1,
          re::initInfo_RigNodeChannel((re *)v1, v2),
          (byte_26AF7281C & 1) == 0))
    {
      byte_26AF7281C = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72FB8, 0);
      qword_26AF72FC8 = 0x2800000003;
      dword_26AF72FD0 = v3;
      word_26AF72FD4 = 0;
      *(void *)&xmmword_26AF72FD8 = 0;
      *((void *)&xmmword_26AF72FD8 + 1) = 0xFFFFFFFFLL;
      qword_26AF72FE8 = (uint64_t)v1;
      qword_26AF72FF0 = 0;
      qword_26AF72FB8 = (uint64_t)&unk_26E6C1730;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72FB8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF72FD8 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstant>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AD0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AD0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF72FF8);
      qword_26AF72FF8 = (uint64_t)&unk_26E6C17C8;
      __cxa_guard_release(&qword_26AF72AD0);
    }
  }
  if ((byte_26AF7281D & 1) == 0)
  {
    v1 = (void *)qword_26AF728D0;
    if (qword_26AF728D0
      || (v1 = re::allocInfo_RigNodeConstant(a1),
          qword_26AF728D0 = (uint64_t)v1,
          re::initInfo_RigNodeConstant((re *)v1, v2),
          (byte_26AF7281D & 1) == 0))
    {
      byte_26AF7281D = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF72FF8, 0);
      qword_26AF73008 = 0x2800000003;
      dword_26AF73010 = v3;
      word_26AF73014 = 0;
      *(void *)&xmmword_26AF73018 = 0;
      *((void *)&xmmword_26AF73018 + 1) = 0xFFFFFFFFLL;
      qword_26AF73028 = (uint64_t)v1;
      qword_26AF73030 = 0;
      qword_26AF72FF8 = (uint64_t)&unk_26E6C17C8;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF72FF8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73018 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<unsigned long [8]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF72AD8))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF73570);
    __cxa_guard_release(&qword_26AF72AD8);
  }
  if ((byte_26AF7281E & 1) == 0)
  {
    byte_26AF7281E = 1;
    uint64_t v2 = (const re::IntrospectionBase *)re::introspect_size_t((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF73570, v2, 8);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF73570, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF73590 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeTemporaryValue>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AE0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AE0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73038);
      qword_26AF73038 = (uint64_t)&unk_26E6C1860;
      __cxa_guard_release(&qword_26AF72AE0);
    }
  }
  if ((byte_26AF7281F & 1) == 0)
  {
    v1 = (void *)qword_26AF728E8;
    if (qword_26AF728E8
      || (v1 = re::allocInfo_RigNodeTemporaryValue(a1),
          qword_26AF728E8 = (uint64_t)v1,
          re::initInfo_RigNodeTemporaryValue((re *)v1, v2),
          (byte_26AF7281F & 1) == 0))
    {
      byte_26AF7281F = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73038, 0);
      qword_26AF73048 = 0x2800000003;
      dword_26AF73050 = v3;
      word_26AF73054 = 0;
      *(void *)&xmmword_26AF73058 = 0;
      *((void *)&xmmword_26AF73058 + 1) = 0xFFFFFFFFLL;
      qword_26AF73068 = (uint64_t)v1;
      qword_26AF73070 = 0;
      qword_26AF73038 = (uint64_t)&unk_26E6C1860;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73038, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73058 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigExpressionParameter>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AE8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AE8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73078);
      qword_26AF73078 = (uint64_t)&unk_26E6C18F8;
      __cxa_guard_release(&qword_26AF72AE8);
    }
  }
  if ((byte_26AF72820 & 1) == 0)
  {
    v1 = (void *)qword_26AF72910;
    if (qword_26AF72910
      || (v1 = re::allocInfo_RigExpressionParameter(a1),
          qword_26AF72910 = (uint64_t)v1,
          re::initInfo_RigExpressionParameter((re *)v1, v2),
          (byte_26AF72820 & 1) == 0))
    {
      byte_26AF72820 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73078, 0);
      qword_26AF73088 = 0x2800000003;
      dword_26AF73090 = v3;
      word_26AF73094 = 0;
      *(void *)&xmmword_26AF73098 = 0;
      *((void *)&xmmword_26AF73098 + 1) = 0xFFFFFFFFLL;
      qword_26AF730A8 = (uint64_t)v1;
      qword_26AF730B0 = 0;
      qword_26AF73078 = (uint64_t)&unk_26E6C18F8;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73078, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73098 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigExpression>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AF0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AF0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF730B8);
      qword_26AF730B8 = (uint64_t)&unk_26E6C1990;
      __cxa_guard_release(&qword_26AF72AF0);
    }
  }
  if ((byte_26AF72821 & 1) == 0)
  {
    v1 = (void *)qword_26AF72928;
    if (qword_26AF72928
      || (v1 = re::allocInfo_RigExpression(a1),
          qword_26AF72928 = (uint64_t)v1,
          re::initInfo_RigExpression((re *)v1, v2),
          (byte_26AF72821 & 1) == 0))
    {
      byte_26AF72821 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF730B8, 0);
      qword_26AF730C8 = 0x2800000003;
      dword_26AF730D0 = v3;
      word_26AF730D4 = 0;
      *(void *)&xmmword_26AF730D8 = 0;
      *((void *)&xmmword_26AF730D8 + 1) = 0xFFFFFFFFLL;
      qword_26AF730E8 = (uint64_t)v1;
      qword_26AF730F0 = 0;
      qword_26AF730B8 = (uint64_t)&unk_26E6C1990;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF730B8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF730D8 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigTwoBoneIKHandles>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72AF8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72AF8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF730F8);
      qword_26AF730F8 = (uint64_t)&unk_26E6C1A28;
      __cxa_guard_release(&qword_26AF72AF8);
    }
  }
  if ((byte_26AF72822 & 1) == 0)
  {
    v1 = (void *)qword_26AF72940;
    if (qword_26AF72940
      || (v1 = re::allocInfo_RigTwoBoneIKHandles(a1),
          qword_26AF72940 = (uint64_t)v1,
          re::initInfo_RigTwoBoneIKHandles((re *)v1, v2),
          (byte_26AF72822 & 1) == 0))
    {
      byte_26AF72822 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF730F8, 0);
      qword_26AF73108 = 0x2800000003;
      dword_26AF73110 = v3;
      word_26AF73114 = 0;
      *(void *)&xmmword_26AF73118 = 0;
      *((void *)&xmmword_26AF73118 + 1) = 0xFFFFFFFFLL;
      qword_26AF73128 = (uint64_t)v1;
      qword_26AF73130 = 0;
      qword_26AF730F8 = (uint64_t)&unk_26E6C1A28;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF730F8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73118 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSingleChainIKHandles>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B00, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B00);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73138);
      qword_26AF73138 = (uint64_t)&unk_26E6C1AC0;
      __cxa_guard_release(&qword_26AF72B00);
    }
  }
  if ((byte_26AF72823 & 1) == 0)
  {
    v1 = (void *)qword_26AF72958;
    if (qword_26AF72958
      || (v1 = re::allocInfo_RigSingleChainIKHandles(a1),
          qword_26AF72958 = (uint64_t)v1,
          re::initInfo_RigSingleChainIKHandles((re *)v1, v2),
          (byte_26AF72823 & 1) == 0))
    {
      byte_26AF72823 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73138, 0);
      qword_26AF73148 = 0x2800000003;
      dword_26AF73150 = v3;
      word_26AF73154 = 0;
      *(void *)&xmmword_26AF73158 = 0;
      *((void *)&xmmword_26AF73158 + 1) = 0xFFFFFFFFLL;
      qword_26AF73168 = (uint64_t)v1;
      qword_26AF73170 = 0;
      qword_26AF73138 = (uint64_t)&unk_26E6C1AC0;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73138, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73158 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKHandle>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B08, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B08);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73178);
      qword_26AF73178 = (uint64_t)&unk_26E6C1B58;
      __cxa_guard_release(&qword_26AF72B08);
    }
  }
  if ((byte_26AF72824 & 1) == 0)
  {
    v1 = (void *)qword_26AF729A0;
    if (qword_26AF729A0
      || (v1 = re::allocInfo_RigSplineIKHandle(a1),
          qword_26AF729A0 = (uint64_t)v1,
          re::initInfo_RigSplineIKHandle((re *)v1, v2),
          (byte_26AF72824 & 1) == 0))
    {
      byte_26AF72824 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73178, 0);
      qword_26AF73188 = 0x2800000003;
      dword_26AF73190 = v3;
      word_26AF73194 = 0;
      *(void *)&xmmword_26AF73198 = 0;
      *((void *)&xmmword_26AF73198 + 1) = 0xFFFFFFFFLL;
      qword_26AF731A8 = (uint64_t)v1;
      qword_26AF731B0 = 0;
      qword_26AF73178 = (uint64_t)&unk_26E6C1B58;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73178, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73198 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigTransform>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B10, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B10);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF731B8);
      qword_26AF731B8 = (uint64_t)&unk_26E6C1BF0;
      __cxa_guard_release(&qword_26AF72B10);
    }
  }
  if ((byte_26AF72825 & 1) == 0)
  {
    v1 = (void *)qword_26AF729F8;
    if (qword_26AF729F8
      || (v1 = re::allocInfo_RigTransform(a1),
          qword_26AF729F8 = (uint64_t)v1,
          re::initInfo_RigTransform((re *)v1, v2),
          (byte_26AF72825 & 1) == 0))
    {
      byte_26AF72825 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF731B8, 0);
      qword_26AF731C8 = 0x2800000003;
      dword_26AF731D0 = v3;
      word_26AF731D4 = 0;
      *(void *)&xmmword_26AF731D8 = 0;
      *((void *)&xmmword_26AF731D8 + 1) = 0xFFFFFFFFLL;
      qword_26AF731E8 = (uint64_t)v1;
      qword_26AF731F0 = 0;
      qword_26AF731B8 = (uint64_t)&unk_26E6C1BF0;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF731B8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF731D8 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigJoint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B18, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B18);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF731F8);
      qword_26AF731F8 = (uint64_t)&unk_26E6C1C88;
      __cxa_guard_release(&qword_26AF72B18);
    }
  }
  if ((byte_26AF72826 & 1) == 0)
  {
    v1 = (void *)qword_26AF72A10;
    if (qword_26AF72A10
      || (v1 = re::allocInfo_RigJoint(a1),
          qword_26AF72A10 = (uint64_t)v1,
          re::initInfo_RigJoint((re *)v1, v2),
          (byte_26AF72826 & 1) == 0))
    {
      byte_26AF72826 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF731F8, 0);
      qword_26AF73208 = 0x2800000003;
      dword_26AF73210 = v3;
      word_26AF73214 = 0;
      *(void *)&xmmword_26AF73218 = 0;
      *((void *)&xmmword_26AF73218 + 1) = 0xFFFFFFFFLL;
      qword_26AF73228 = (uint64_t)v1;
      qword_26AF73230 = 0;
      qword_26AF731F8 = (uint64_t)&unk_26E6C1C88;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF731F8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73218 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstraint>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B20, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B20);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73238);
      qword_26AF73238 = (uint64_t)&unk_26E6C1D20;
      __cxa_guard_release(&qword_26AF72B20);
    }
  }
  if ((byte_26AF72827 & 1) == 0)
  {
    v1 = (void *)qword_26AF72A28;
    if (qword_26AF72A28
      || (v1 = re::allocInfo_RigNodeConstraint(a1),
          qword_26AF72A28 = (uint64_t)v1,
          re::initInfo_RigNodeConstraint((re *)v1, v2),
          (byte_26AF72827 & 1) == 0))
    {
      byte_26AF72827 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73238, 0);
      qword_26AF73248 = 0x2800000003;
      dword_26AF73250 = v3;
      word_26AF73254 = 0;
      *(void *)&xmmword_26AF73258 = 0;
      *((void *)&xmmword_26AF73258 + 1) = 0xFFFFFFFFLL;
      qword_26AF73268 = (uint64_t)v1;
      qword_26AF73270 = 0;
      qword_26AF73238 = (uint64_t)&unk_26E6C1D20;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73238, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73258 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigIKHandles>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B28, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B28);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73278);
      qword_26AF73278 = (uint64_t)&unk_26E6C1DB8;
      __cxa_guard_release(&qword_26AF72B28);
    }
  }
  if ((byte_26AF72828 & 1) == 0)
  {
    v1 = (void *)qword_26AF729E0;
    if (qword_26AF729E0
      || (v1 = re::allocInfo_RigIKHandles(a1),
          qword_26AF729E0 = (uint64_t)v1,
          re::initInfo_RigIKHandles((re *)v1, v2),
          (byte_26AF72828 & 1) == 0))
    {
      byte_26AF72828 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73278, 0);
      qword_26AF73288 = 0x2800000003;
      dword_26AF73290 = v3;
      word_26AF73294 = 0;
      *(void *)&xmmword_26AF73298 = 0;
      *((void *)&xmmword_26AF73298 + 1) = 0xFFFFFFFFLL;
      qword_26AF732A8 = (uint64_t)v1;
      qword_26AF732B0 = 0;
      qword_26AF73278 = (uint64_t)&unk_26E6C1DB8;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73278, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73298 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNode>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B30, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B30);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF732B8);
      qword_26AF732B8 = (uint64_t)&unk_26E6C1E50;
      __cxa_guard_release(&qword_26AF72B30);
    }
  }
  if ((byte_26AF72829 & 1) == 0)
  {
    v1 = (void *)qword_26AF72A50;
    if (qword_26AF72A50
      || (v1 = re::allocInfo_RigNode(a1),
          qword_26AF72A50 = (uint64_t)v1,
          re::initInfo_RigNode((re *)v1, v2),
          (byte_26AF72829 & 1) == 0))
    {
      byte_26AF72829 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF732B8, 0);
      qword_26AF732C8 = 0x2800000003;
      dword_26AF732D0 = v3;
      word_26AF732D4 = 0;
      *(void *)&xmmword_26AF732D8 = 0;
      *((void *)&xmmword_26AF732D8 + 1) = 0xFFFFFFFFLL;
      qword_26AF732E8 = (uint64_t)v1;
      qword_26AF732F0 = 0;
      qword_26AF732B8 = (uint64_t)&unk_26E6C1E50;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF732B8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF732D8 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigPoseNode>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B38, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B38);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF732F8);
      qword_26AF732F8 = (uint64_t)&unk_26E6C1EE8;
      __cxa_guard_release(&qword_26AF72B38);
    }
  }
  if ((byte_26AF7282A & 1) == 0)
  {
    v1 = (void *)qword_26AF72A68;
    if (qword_26AF72A68
      || (v1 = re::allocInfo_RigPoseNode(a1),
          qword_26AF72A68 = (uint64_t)v1,
          re::initInfo_RigPoseNode((re *)v1, v2),
          (byte_26AF7282A & 1) == 0))
    {
      byte_26AF7282A = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF732F8, 0);
      qword_26AF73308 = 0x2800000003;
      dword_26AF73310 = v3;
      word_26AF73314 = 0;
      *(void *)&xmmword_26AF73318 = 0;
      *((void *)&xmmword_26AF73318 + 1) = 0xFFFFFFFFLL;
      qword_26AF73328 = (uint64_t)v1;
      qword_26AF73330 = 0;
      qword_26AF732F8 = (uint64_t)&unk_26E6C1EE8;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF732F8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73318 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigPose>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF72B40, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF72B40);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73338);
      qword_26AF73338 = (uint64_t)&unk_26E6C1F80;
      __cxa_guard_release(&qword_26AF72B40);
    }
  }
  if ((byte_26AF7282B & 1) == 0)
  {
    v1 = (void *)qword_26AF72A80;
    if (qword_26AF72A80
      || (v1 = re::allocInfo_RigPose(a1),
          qword_26AF72A80 = (uint64_t)v1,
          re::initInfo_RigPose((re *)v1, v2),
          (byte_26AF7282B & 1) == 0))
    {
      byte_26AF7282B = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73338, 0);
      qword_26AF73348 = 0x2800000003;
      dword_26AF73350 = v3;
      word_26AF73354 = 0;
      *(void *)&xmmword_26AF73358 = 0;
      *((void *)&xmmword_26AF73358 + 1) = 0xFFFFFFFFLL;
      qword_26AF73368 = (uint64_t)v1;
      qword_26AF73370 = 0;
      qword_26AF73338 = (uint64_t)&unk_26E6C1F80;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73338, (const re::IntrospectionBase *)&v14);
      if (v15) {
        long long v6 = *(const char **)&v16[7];
      }
      else {
        long long v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF73358 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

double re::internal::defaultConstruct<re::RigDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 232) = 0u;
  *(_OWORD *)(a3 + 248) = 0u;
  *(_DWORD *)(a3 + 264) = 0;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_DWORD *)(a3 + 304) = 0;
  *(_DWORD *)(a3 + 344) = 0;
  *(_OWORD *)(a3 + 312) = 0u;
  *(_OWORD *)(a3 + 328) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_DWORD *)(a3 + 384) = 0;
  *(_DWORD *)(a3 + 424) = 0;
  *(_OWORD *)(a3 + 392) = 0u;
  *(_OWORD *)(a3 + 408) = 0u;
  *(_DWORD *)(a3 + 464) = 0;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_DWORD *)(a3 + 504) = 0;
  *(_OWORD *)(a3 + 472) = 0u;
  *(_OWORD *)(a3 + 488) = 0u;
  *(void *)(a3 + 1136) = 0;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_DWORD *)(a3 + 544) = 0;
  *(_OWORD *)(a3 + 512) = 0u;
  *(_OWORD *)(a3 + 528) = 0u;
  *(_DWORD *)(a3 + 648) = 0;
  *(_OWORD *)(a3 + 616) = 0u;
  *(_OWORD *)(a3 + 632) = 0u;
  *(_OWORD *)(a3 + 584) = 0u;
  *(_OWORD *)(a3 + 600) = 0u;
  *(_OWORD *)(a3 + 552) = 0u;
  *(_OWORD *)(a3 + 568) = 0u;
  *(_DWORD *)(a3 + 688) = 0;
  *(_OWORD *)(a3 + 656) = 0u;
  *(_OWORD *)(a3 + 672) = 0u;
  *(_OWORD *)(a3 + 696) = 0u;
  *(_OWORD *)(a3 + 712) = 0u;
  *(_DWORD *)(a3 + 728) = 0;
  *(_DWORD *)(a3 + 768) = 0;
  *(_OWORD *)(a3 + 736) = 0u;
  *(_OWORD *)(a3 + 752) = 0u;
  *(_DWORD *)(a3 + 808) = 0;
  *(_OWORD *)(a3 + 776) = 0u;
  *(_OWORD *)(a3 + 792) = 0u;
  *(_DWORD *)(a3 + 848) = 0;
  *(_OWORD *)(a3 + 816) = 0u;
  *(_OWORD *)(a3 + 832) = 0u;
  *(_DWORD *)(a3 + 888) = 0;
  *(_OWORD *)(a3 + 856) = 0u;
  *(_OWORD *)(a3 + 872) = 0u;
  *(_DWORD *)(a3 + 928) = 0;
  *(_OWORD *)(a3 + 896) = 0u;
  *(_OWORD *)(a3 + 912) = 0u;
  *(_DWORD *)(a3 + 968) = 0;
  *(_OWORD *)(a3 + 936) = 0u;
  *(_OWORD *)(a3 + 952) = 0u;
  *(_DWORD *)(a3 + 1008) = 0;
  *(_OWORD *)(a3 + 976) = 0u;
  *(_OWORD *)(a3 + 992) = 0u;
  *(_DWORD *)(a3 + 1048) = 0;
  *(_OWORD *)(a3 + 1016) = 0u;
  *(_OWORD *)(a3 + 1032) = 0u;
  *(_DWORD *)(a3 + 1088) = 0;
  *(_OWORD *)(a3 + 1072) = 0u;
  *(_OWORD *)(a3 + 1056) = 0u;
  *(_DWORD *)(a3 + 1128) = 0;
  *(_OWORD *)(a3 + 1096) = 0u;
  *(_OWORD *)(a3 + 1112) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RigDefinition>(int a1, int a2, re::RigDefinition *this)
{
}

double re::internal::defaultConstructV2<re::RigDefinition>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_DWORD *)(a1 + 504) = 0;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(void *)(a1 + 1136) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 544) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 648) = 0;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_DWORD *)(a1 + 688) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_DWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 768) = 0;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_DWORD *)(a1 + 808) = 0;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_DWORD *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_DWORD *)(a1 + 888) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_DWORD *)(a1 + 928) = 0;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_DWORD *)(a1 + 968) = 0;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_DWORD *)(a1 + 1008) = 0;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_DWORD *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_DWORD *)(a1 + 1088) = 0;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(_OWORD *)(a1 + 1112) = 0u;
  return result;
}

uint64_t re::introspect_RigDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RigDefinition", (uint64_t (*)(re::internal *))re::allocInfo_RigDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_RigDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RigDefinition>, this);
}

void *re::FixedArray<unsigned long>::init<unsigned long const&>(void *result, uint64_t a2, unint64_t a3, void *a4)
{
  *double result = a2;
  result[1] = a3;
  if (!a3) {
    return result;
  }
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  long long v6 = result;
  double result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 8 * a3, 8);
  v6[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    double result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  unint64_t v8 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *result++ = *a4;
      --v8;
    }
    while (v8);
  }
  *double result = *a4;
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<unsigned long>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<unsigned long>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<unsigned long>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<unsigned long>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  double result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<unsigned long>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<unsigned long>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<unsigned long>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v10 = 0;
  re::DynamicArray<unsigned long>::add(this, &v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 8 * *((void *)this + 2) - 8);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

void re::DynamicArray<unsigned long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + 8 * v4);
      uint64_t v6 = 8 * a2 - 8 * v4;
      if (v6 >= 1) {
        bzero(v5, 8 * (((unint64_t)v6 >> 3) - ((unint64_t)v6 > 7)) + 8);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  double result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<unsigned long>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 8 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 8;
        v11 -= 8;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 8 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 8 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<float>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<float>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<float>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<float>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<float>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<int>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<float>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<float>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<float>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  int v10 = 0;
  re::DynamicArray<float>::add(this, (float *)&v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 4 * *((void *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<float>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<float>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

void re::DynamicArray<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<int>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + 4 * v4);
      uint64_t v6 = 4 * a2 - 4 * v4;
      if (v6 >= 1) {
        bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<int>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<int>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<float>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      int v10 = *(char **)(a1 + 32);
      uint64_t v11 = 4 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 4;
        v11 -= 4;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 4 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

re::IntrospectionCStyleArray *re::IntrospectionCStyleArray::IntrospectionCStyleArray(re::IntrospectionCStyleArray *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)((char *)v2 + 22) = 0;
  v2[2] = 0;
  v2[4] = 0;
  v2[5] = 0xFFFFFFFFLL;
  void *v2 = &unk_26E6C2018;
  *((void *)this + 7) = 0;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(v2 + 6));
  *((_DWORD *)this + 16) = 0;
  return this;
}

void re::IntrospectionCStyleArray::~IntrospectionCStyleArray(re::IntrospectionCStyleArray *this)
{
  *(void *)this = &unk_26E6C2018;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C2018;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionCStyleArray::childInfoCount(re::IntrospectionCStyleArray *this)
{
  return 1;
}

uint64_t re::IntrospectionCStyleArray::childInfo(re::IntrospectionCStyleArray *this, uint64_t a2)
{
  if (!a2) {
    return *((void *)this + 6);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 449);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKJoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigSplineIKJoint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigSplineIKJoint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = *(void *)(a4 + 32) + 80 * v9;
  *(void *)uint64_t v15 = -1;
  *(_OWORD *)(v15 + 8) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(void *)(v15 + 72) = 0;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  uint64_t v17 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 80 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 80 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 80 * a3;
}

void *re::DynamicArray<re::RigSplineIKJoint>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 80 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::RigSplineIKJoint>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 80 * v4;
      memset((char *)v9 + 8, 0, 56);
      uint64_t v7 = v5 + 80 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = v7 / 0x50uLL + 1;
        do
        {
          *(void *)uint64_t v6 = -1;
          *(_OWORD *)(v6 + 24) = v9[1];
          *(_OWORD *)(v6 + 40) = v9[2];
          *(_OWORD *)(v6 + 56) = v9[3];
          *(void *)(v6 + 72) = 0;
          --v8;
          *(_OWORD *)(v6 + 8) = v9[0];
          v6 += 80;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKJoint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 80 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 80;
        v11 -= 80;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 80 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 80 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigSplineIKControlPoint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = *(void *)(a4 + 32) + 96 * v9;
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  *(void *)(v15 + 8) = 0;
  *(void *)(v15 + 16) = 0;
  *(void *)uint64_t v15 = 0;
  *(_DWORD *)(v15 + 24) = 1;
  *(_DWORD *)(v15 + 64) = 0;
  *(void *)(v15 + 48) = 0;
  *(void *)(v15 + 56) = 0;
  *(_DWORD *)(v15 + 64) = 1;
  *(void *)(v15 + 80) = 0;
  *(void *)(v15 + 88) = 0;
  *(void *)(v15 + 72) = 0;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  uint64_t v17 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 96 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 96 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 96 * a3;
}

uint64_t re::DynamicArray<re::RigSplineIKControlPoint>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 96 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 96;
          v5 -= 96;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x60uLL))
        {
          uint64_t v2 = 96 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = v8 + 96 * v9;
        do
        {
          uint64_t v12 = v8 + v10;
          unint64_t v13 = &v7[v10 / 8];
          void v13[4] = 0;
          v13[1] = 0;
          void v13[2] = 0;
          *unint64_t v13 = 0;
          *((_DWORD *)v13 + 6) = 0;
          uint64_t v14 = *(void *)(v8 + v10 + 8);
          *unint64_t v13 = *(void *)(v8 + v10);
          v13[1] = v14;
          *(void *)uint64_t v12 = 0;
          *(void *)(v12 + 8) = 0;
          uint64_t v15 = v7[v10 / 8 + 2];
          void v13[2] = *(void *)(v8 + v10 + 16);
          *(void *)(v12 + 16) = v15;
          uint64_t v16 = v7[v10 / 8 + 4];
          void v13[4] = *(void *)(v8 + v10 + 32);
          *(void *)(v12 + 32) = v16;
          *(_DWORD *)(v12 + 24) = *(_DWORD *)(v8 + v10 + 24) + 1;
          *((_DWORD *)v13 + 6) = LODWORD(v7[v10 / 8 + 3]) + 1;
          v13[9] = 0;
          v13[6] = 0;
          v13[7] = 0;
          uint64_t v13[5] = 0;
          *((_DWORD *)v13 + 16) = 0;
          uint64_t v17 = (void *)(v8 + v10 + 40);
          uint64_t v18 = *(void *)(v8 + v10 + 48);
          uint64_t v13[5] = *v17;
          *uint64_t v17 = 0;
          v13[6] = v18;
          *(void *)(v12 + 48) = 0;
          uint64_t v19 = v7[v10 / 8 + 7];
          v13[7] = *(void *)(v8 + v10 + 56);
          *(void *)(v12 + 56) = v19;
          uint64_t v20 = v7[v10 / 8 + 9];
          v13[9] = *(void *)(v8 + v10 + 72);
          *(void *)(v12 + 72) = v20;
          *(_DWORD *)(v12 + 64) = *(_DWORD *)(v8 + v10 + 64) + 1;
          *((_DWORD *)v13 + 16) = LODWORD(v7[v10 / 8 + 8]) + 1;
          *((_OWORD *)v13 + 5) = *(_OWORD *)(v8 + v10 + 80);
          re::DynamicArray<unsigned long>::deinit((uint64_t)v17);
          re::DynamicArray<unsigned long>::deinit(v8 + v10);
          v10 += 96;
        }
        while (v12 + 96 != v11);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::RigSplineIKControlPoint>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 96 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 96;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 96 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(void *)(v7 + 80) = 0;
        *(void *)(v7 + 88) = 0;
        *(void *)(v7 + 72) = 0;
        v6 += 96;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKControlPoint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 96 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 96;
        v11 -= 96;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigSplineIKControlPoint>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 96 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v3 + 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v3);
      v3 += 96;
      v4 -= 96;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 96 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 96 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigComponentConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigComponentConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigComponentConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigComponentConstraint>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigComponentConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigComponentConstraint>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigComponentConstraint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigComponentConstraint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigComponentConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigComponentConstraint>::add(this, (__int16 *)v10);
  if ((void)v12)
  {
    if (v14) {
      (*(void (**)(void))(*(void *)v12 + 40))();
    }
    uint64_t v14 = 0;
    *(void *)&long long v13 = 0;
    long long v12 = 0uLL;
    ++DWORD2(v13);
  }
  if (*((void *)&v10[0] + 1) && *((void *)&v11 + 1)) {
    (*(void (**)(void))(**((void **)&v10[0] + 1) + 40))();
  }
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 88 * *((void *)this + 2) - 88);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 88 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 88 * a3;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 88 * v4;
        uint64_t v6 = v3 + 48;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v6);
          re::DynamicArray<unsigned long>::deinit(v6 - 40);
          v6 += 88;
          v5 -= 88;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigComponentConstraint>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 88 * a2 + 48;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10 - 40);
      ++v9;
      v8 += 88;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigComponentConstraint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 88 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(unsigned char *)uint64_t v7 = 0;
        *(_WORD *)(v7 + 1) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 32) = 0;
        *(void *)(v7 + 80) = 0;
        *(_OWORD *)(v7 + 40) = 0uLL;
        *(_OWORD *)(v7 + 56) = 0uLL;
        *(_DWORD *)(v7 + 72) = 0;
        v6 += 88;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigComponentConstraint>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigComponentConstraint>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigComponentConstraint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 88 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 88;
        v11 -= 88;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 88 * v2;
    uint64_t v4 = *(void *)(result + 32) + 48;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v4);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v4 - 40);
      v4 += 88;
      v3 -= 88;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 88 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 88 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigBasicConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigBasicConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigBasicConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigBasicConstraint>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigBasicConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigBasicConstraint>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigBasicConstraint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigBasicConstraint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigBasicConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigBasicConstraint>::add(this, (uint64_t)v10);
  if (*((void *)&v11 + 1))
  {
    if (*((void *)&v13 + 1)) {
      (*(void (**)(void))(**((void **)&v11 + 1) + 40))();
    }
    *((void *)&v13 + 1) = 0;
    long long v12 = 0uLL;
    *((void *)&v11 + 1) = 0;
    LODWORD(v13) = v13 + 1;
  }
  if (*(void *)&v10[0] && (void)v11) {
    (*(void (**)(void))(**(void **)&v10[0] + 40))();
  }
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 80 * *((void *)this + 2) - 80);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 80 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 80 * a3;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 80;
          v5 -= 80;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigBasicConstraint>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 80 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 80;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigBasicConstraint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 80 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 72) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        v6 += 80;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigBasicConstraint>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigBasicConstraint>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigBasicConstraint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 80 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 80;
        v11 -= 80;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 80 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v3 + 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v3);
      v3 += 80;
      v4 -= 80;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 80 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 80 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigAimConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigAimConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigAimConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigAimConstraint>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigAimConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigAimConstraint>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigAimConstraint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigAimConstraint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigAimConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  long long v16 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  long long v17 = 0xFFFFFFFFFFFFFFFFLL;
  __n128 v8 = re::DynamicArray<re::RigAimConstraint>::add(this, (uint64_t)v11);
  if (*((void *)&v14 + 1))
  {
    if (*((void *)&v16 + 1)) {
      (*(void (**)(__n128))(**((void **)&v14 + 1) + 40))(v8);
    }
    *((void *)&v16 + 1) = 0;
    long long v15 = 0uLL;
    *((void *)&v14 + 1) = 0;
    LODWORD(v16) = v16 + 1;
  }
  if ((void)v12 && (void)v14) {
    (*(void (**)(__n128))(*(void *)v12 + 40))(v8);
  }
  uint64_t v9 = (re::IntrospectionBase *)(*((void *)this + 4) + 144 * *((void *)this + 2) - 144);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 144 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 144 * a3;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 144 * v4;
        uint64_t v6 = v3 + 48;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v6 + 40);
          re::DynamicArray<unsigned long>::deinit(v6);
          v6 += 144;
          v5 -= 144;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigAimConstraint>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 144 * a2 + 48;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 144;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigAimConstraint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 144 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(_DWORD *)uint64_t v7 = 0;
        *(unsigned char *)(v7 + 4) = 0;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_OWORD *)(v7 + 60) = 0uLL;
        *(_OWORD *)(v7 + 80) = 0uLL;
        *(_OWORD *)(v7 + 96) = 0uLL;
        *(_DWORD *)(v7 + 112) = 0;
        *(void *)(v7 + 120) = 0;
        *(void *)(v7 + 128) = -1;
        v6 += 144;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigAimConstraint>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigAimConstraint>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigAimConstraint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 144 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 144;
        v11 -= 144;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigAimConstraint>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 144 * v2;
    uint64_t v4 = *(void *)(result + 32) + 48;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v4 + 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v4);
      v4 += 144;
      v3 -= 144;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 144 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 144 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeChannel>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeChannel>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigNodeChannel>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigNodeChannel>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeChannel>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeChannel>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeChannel>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  *(_OWORD *)(*(void *)(a4 + 32) + 16 * v9) = xmmword_234361D10;
  uint64_t v15 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v16 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::DynamicArray<re::RigNodeChannel>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 16 * v4;
      uint64_t v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(void *)(v6 + 8) = -1;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeConstant>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeConstant>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigNodeConstant>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigNodeConstant>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeConstant>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeConstant>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeConstant>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  *(_OWORD *)(*(void *)(a4 + 32) + 16 * v9) = xmmword_2343663D0;
  uint64_t v15 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v16 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::DynamicArray<re::RigNodeConstant>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 16 * v4;
      uint64_t v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(unsigned char *)uint64_t v6 = -1;
          *(void *)(v6 + 8) = -1;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstant>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeConstant>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  *(_OWORD *)(*(void *)(a4 + 32) + 16 * v9) = xmmword_2343663D0;
  uint64_t v15 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v16 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstant>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigExpressionParameter>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigExpressionParameter>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigExpressionParameter>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigExpressionParameter>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigExpressionParameter>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeChannel>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigExpressionParameter>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  *(_OWORD *)(*(void *)(a4 + 32) + 16 * v9) = xmmword_234361D10;
  uint64_t v15 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v16 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigExpression>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigExpression>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigExpression>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigExpression>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigExpression>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigExpression>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigExpression>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = (void *)(*(void *)(a4 + 32) + 24 * v9);
  *uint64_t v15 = 0xFFFFFFFFLL;
  v15[1] = -1;
  v15[2] = -1;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v17 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 24 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

void *re::DynamicArray<re::RigExpression>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 24 * v4;
      uint64_t v7 = v5 + 24 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = v7 / 0x18uLL + 1;
        do
        {
          *(_DWORD *)uint64_t v6 = -1;
          *(void *)(v6 + 8) = -1;
          *(void *)(v6 + 16) = -1;
          --v8;
          v6 += 24;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigExpression>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 24 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 24;
        v11 -= 24;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 24 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigTwoBoneIKHandles>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigTwoBoneIKHandles>::add(this, (uint64_t)v10);
  if (*((void *)&v21 + 1))
  {
    if (*((void *)&v23 + 1)) {
      (*(void (**)(void))(**((void **)&v21 + 1) + 40))();
    }
    *((void *)&v23 + 1) = 0;
    long long v22 = 0uLL;
    *((void *)&v21 + 1) = 0;
    LODWORD(v23) = v23 + 1;
  }
  if ((void)v19)
  {
    if ((void)v21) {
      (*(void (**)(void))(*(void *)v19 + 40))();
    }
    *(void *)&long long v21 = 0;
    *(void *)&long long v20 = 0;
    long long v19 = 0uLL;
    ++DWORD2(v20);
  }
  if (*((void *)&v16 + 1))
  {
    if (*((void *)&v18 + 1)) {
      (*(void (**)(void))(**((void **)&v16 + 1) + 40))();
    }
    *((void *)&v18 + 1) = 0;
    long long v17 = 0uLL;
    *((void *)&v16 + 1) = 0;
    LODWORD(v18) = v18 + 1;
  }
  if ((void)v14)
  {
    if ((void)v16) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    *(void *)&long long v16 = 0;
    *(void *)&long long v15 = 0;
    long long v14 = 0uLL;
    ++DWORD2(v15);
  }
  if (*((void *)&v11 + 1))
  {
    if (*((void *)&v13 + 1)) {
      (*(void (**)(void))(**((void **)&v11 + 1) + 40))();
    }
    *((void *)&v13 + 1) = 0;
    long long v12 = 0uLL;
    *((void *)&v11 + 1) = 0;
    LODWORD(v13) = v13 + 1;
  }
  if (*(void *)&v10[0] && (void)v11) {
    (*(void (**)(void))(**(void **)&v10[0] + 40))();
  }
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 240 * *((void *)this + 2) - 240);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 240 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 240 * a3;
}

uint64_t re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 240 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 200);
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 160);
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 120);
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 80);
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 40);
          re::DynamicArray<unsigned long>::deinit(v3 + v5);
          v5 += 240;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigTwoBoneIKHandles>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 240 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 200);
      re::DynamicArray<unsigned long>::deinit(v10 + 160);
      re::DynamicArray<unsigned long>::deinit(v10 + 120);
      re::DynamicArray<unsigned long>::deinit(v10 + 80);
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 240;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 240 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 232) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_OWORD *)(v7 + 72) = 0uLL;
        *(_OWORD *)(v7 + 88) = 0uLL;
        *(_DWORD *)(v7 + 104) = 0;
        *(_OWORD *)(v7 + 112) = 0uLL;
        *(_OWORD *)(v7 + 128) = 0uLL;
        *(_DWORD *)(v7 + 144) = 0;
        *(_OWORD *)(v7 + 152) = 0uLL;
        *(_OWORD *)(v7 + 168) = 0uLL;
        *(_DWORD *)(v7 + 184) = 0;
        *(_OWORD *)(v7 + 192) = 0uLL;
        *(_OWORD *)(v7 + 208) = 0uLL;
        v6 += 240;
        *(_DWORD *)(v7 + 224) = 0;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigTwoBoneIKHandles>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 240 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 240;
        v11 -= 240;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigTwoBoneIKHandles>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(result + 32);
    uint64_t v5 = 240 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 200);
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 160);
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 120);
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 80);
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v4 + v3);
      v3 += 240;
    }
    while (v5 != v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 240 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 240 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigSingleChainIKHandles>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  DWORD2(v17) = 1008981770;
  v8.n128_f32[0] = re::DynamicArray<re::RigSingleChainIKHandles>::add(this, (uint64_t)v11);
  if ((void)v15)
  {
    if ((void)v17) {
      (*(void (**)(float))(*(void *)v15 + 40))(v8.n128_f32[0]);
    }
    *(void *)&long long v17 = 0;
    *(void *)&long long v16 = 0;
    long long v15 = 0uLL;
    ++DWORD2(v16);
  }
  if (*((void *)&v12 + 1))
  {
    if (*((void *)&v14 + 1)) {
      (*(void (**)(__n128))(**((void **)&v12 + 1) + 40))(v8);
    }
    *((void *)&v14 + 1) = 0;
    long long v13 = 0uLL;
    *((void *)&v12 + 1) = 0;
    LODWORD(v14) = v14 + 1;
  }
  if (*(void *)&v11[0] && (void)v12) {
    (*(void (**)(__n128))(**(void **)&v11[0] + 40))(v8);
  }
  uint64_t v9 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 7) - 128);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 7);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 7);
}

uint64_t re::DynamicArray<re::RigSingleChainIKHandles>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v4 << 7;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + 80);
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 128;
          v5 -= 128;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigSingleChainIKHandles>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    unint64_t v8 = a2 << 7;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 80);
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 128;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      unint64_t v6 = v4 << 7;
      do
      {
        unint64_t v7 = v3[4] + v6;
        *(void *)unint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 112) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_OWORD *)(v7 + 72) = 0uLL;
        *(_OWORD *)(v7 + 88) = 0uLL;
        *(_DWORD *)(v7 + 104) = 0;
        v6 += 128;
        *(_DWORD *)(v7 + 120) = 1008981770;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

float re::DynamicArray<re::RigSingleChainIKHandles>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + (v4 << 7);
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = 0;
  *(_DWORD *)(v5 + 24) = 0;
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 8) = v6;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v7 = *(void *)(v5 + 16);
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v7;
  uint64_t v8 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v8;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v5 + 24);
  *(void *)(v5 + 72) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 64) = 0;
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(v5 + 40) = *(void *)(a2 + 40);
  *(void *)(v5 + 48) = v9;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  uint64_t v10 = *(void *)(v5 + 56);
  *(void *)(v5 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v10;
  uint64_t v11 = *(void *)(v5 + 72);
  *(void *)(v5 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v11;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(v5 + 64);
  *(void *)(v5 + 112) = 0;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 96) = 0;
  *(void *)(v5 + 80) = 0;
  *(_DWORD *)(v5 + 104) = 0;
  uint64_t v12 = *(void *)(a2 + 88);
  *(void *)(v5 + 80) = *(void *)(a2 + 80);
  *(void *)(v5 + 88) = v12;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  uint64_t v13 = *(void *)(v5 + 96);
  *(void *)(v5 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v13;
  uint64_t v14 = *(void *)(v5 + 112);
  *(void *)(v5 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v14;
  ++*(_DWORD *)(a2 + 104);
  ++*(_DWORD *)(v5 + 104);
  float result = *(float *)(a2 + 120);
  *(float *)(v5 + 120) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::RigSingleChainIKHandles>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  float result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSingleChainIKHandles>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 7;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 128;
        v11 -= 128;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigSingleChainIKHandles>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = v2 << 7;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v3 + 80);
      re::DynamicArray<unsigned long>::deinit(v3 + 40);
      float result = re::DynamicArray<unsigned long>::deinit(v3);
      v3 += 128;
      v4 -= 128;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 7);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 7);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKHandle>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigSplineIKHandle>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSplineIKHandle>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigSplineIKHandle>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigSplineIKHandle>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  *(void *)&long long v32 = -1;
  *((void *)&v32 + 1) = -1;
  *(void *)&long long v30 = -1;
  *((void *)&v30 + 1) = -1;
  long long v31 = 0xFFFFFFFFFFFFFFFFLL;
  long long v35 = 0u;
  long long v36 = 0u;
  LODWORD(v36) = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = *(void *)(a4 + 32) + 240 * v9;
  *(_DWORD *)uint64_t v15 = 1008981770;
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = 0;
  *(void *)(v15 + 8) = 0;
  *(_DWORD *)(v15 + 32) = 0;
  *(void *)(v15 + 24) = 0;
  *(void *)(v15 + 40) = 0;
  ++*(_DWORD *)(v15 + 32);
  *(void *)(v15 + 56) = 0;
  *(void *)(v15 + 64) = 0;
  *(void *)(v15 + 48) = 0;
  *(_DWORD *)(v15 + 72) = 0;
  long long v25 = 0uLL;
  uint64_t v16 = *(void *)(v15 + 64);
  *(void *)(v15 + 64) = 0;
  *(void *)&long long v26 = v16;
  *(void *)(v15 + 80) = 0;
  *(void *)&long long v27 = 0;
  DWORD2(v26) = 1;
  ++*(_DWORD *)(v15 + 72);
  *(void *)(v15 + 96) = 0;
  *(void *)(v15 + 104) = 0;
  *(void *)(v15 + 88) = 0;
  *(_DWORD *)(v15 + 112) = 0;
  *((void *)&v27 + 1) = 0;
  *(void *)&long long v28 = 0;
  uint64_t v17 = *(void *)(v15 + 104);
  *(void *)(v15 + 104) = 0;
  *((void *)&v28 + 1) = v17;
  *(void *)(v15 + 120) = 0;
  *((void *)&v29 + 1) = 0;
  LODWORD(v29) = 1;
  ++*(_DWORD *)(v15 + 112);
  long long v18 = v30;
  long long v19 = v32;
  *(_OWORD *)(v15 + 144) = v31;
  *(_OWORD *)(v15 + 160) = v19;
  *(_OWORD *)(v15 + 128) = v18;
  long long v20 = v33;
  long long v21 = v34;
  long long v22 = v35;
  *(_DWORD *)(v15 + 224) = v36;
  *(_OWORD *)(v15 + 192) = v21;
  *(_OWORD *)(v15 + 208) = v22;
  *(_OWORD *)(v15 + 176) = v20;
  ++*(void *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit((uint64_t)&v25);
  long long v23 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 240 * *(void *)(a4 + 16) - 240);
  re::introspectionInitElement(a2, a3, a1[6], v23);
  return v23;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 240 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 240 * a3;
}

uint64_t re::DynamicArray<re::RigSplineIKHandle>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 240 * v4;
        uint64_t v6 = v3 + 88;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v6);
          re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v6 - 40);
          re::DynamicArray<unsigned long>::deinit(v6 - 80);
          v6 += 240;
          v5 -= 240;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigSplineIKHandle>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0xF0uLL))
        {
          uint64_t v2 = 240 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 240 * a2, 16);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::RigSplineIKHandle>(v5[4], v5[4] + 240 * v5[2], v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 240, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::RigSplineIKHandle>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::ObjectHelper::move<re::RigSplineIKHandle>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      *(_DWORD *)a3 = *(_DWORD *)v5;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 32) = 0;
      uint64_t v6 = v5 + 8;
      uint64_t v7 = *(void *)(v5 + 16);
      *(void *)(a3 + 8) = *(void *)(v5 + 8);
      *(void *)(v5 + 8) = 0;
      *(void *)(a3 + 16) = v7;
      *(void *)(v5 + 16) = 0;
      uint64_t v8 = *(void *)(a3 + 24);
      *(void *)(a3 + 24) = *(void *)(v5 + 24);
      *(void *)(v5 + 24) = v8;
      uint64_t v9 = *(void *)(a3 + 40);
      *(void *)(a3 + 40) = *(void *)(v5 + 40);
      *(void *)(v5 + 40) = v9;
      ++*(_DWORD *)(v5 + 32);
      LODWORD(v9) = *(_DWORD *)(a3 + 32) + 1;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 56) = 0;
      *(void *)(a3 + 64) = 0;
      *(void *)(a3 + 48) = 0;
      *(_DWORD *)(a3 + 72) = 0;
      uint64_t v11 = v5 + 48;
      uint64_t v10 = *(void *)(v5 + 48);
      *(_DWORD *)(a3 + 32) = v9;
      uint64_t v12 = *(void *)(v5 + 56);
      *(void *)(a3 + 48) = v10;
      *(void *)(v5 + 48) = 0;
      *(void *)(a3 + 56) = v12;
      *(void *)(v5 + 56) = 0;
      uint64_t v13 = *(void *)(a3 + 64);
      *(void *)(a3 + 64) = *(void *)(v5 + 64);
      *(void *)(v5 + 64) = v13;
      uint64_t v14 = *(void *)(a3 + 80);
      *(void *)(a3 + 80) = *(void *)(v5 + 80);
      *(void *)(v5 + 80) = v14;
      ++*(_DWORD *)(v5 + 72);
      ++*(_DWORD *)(a3 + 72);
      *(void *)(a3 + 120) = 0;
      *(void *)(a3 + 96) = 0;
      *(void *)(a3 + 104) = 0;
      *(void *)(a3 + 88) = 0;
      *(_DWORD *)(a3 + 112) = 0;
      uint64_t v15 = *(void *)(v5 + 88);
      uint64_t v16 = *(void *)(v5 + 96);
      uint64_t v17 = v5 + 88;
      *(void *)(a3 + 88) = v15;
      *(void *)(a3 + 96) = v16;
      *(void *)uint64_t v17 = 0;
      *(void *)(v17 + 8) = 0;
      uint64_t v18 = *(void *)(a3 + 104);
      *(void *)(a3 + 104) = *(void *)(v17 + 16);
      *(void *)(v17 + 16) = v18;
      uint64_t v19 = *(void *)(a3 + 120);
      *(void *)(a3 + 120) = *(void *)(v17 + 32);
      *(void *)(v17 + 32) = v19;
      ++*(_DWORD *)(v17 + 24);
      ++*(_DWORD *)(a3 + 112);
      long long v20 = *(_OWORD *)(v17 + 40);
      long long v21 = *(_OWORD *)(v17 + 72);
      *(_OWORD *)(a3 + 144) = *(_OWORD *)(v17 + 56);
      *(_OWORD *)(a3 + 160) = v21;
      *(_OWORD *)(a3 + 128) = v20;
      long long v22 = *(_OWORD *)(v17 + 88);
      long long v23 = *(_OWORD *)(v17 + 104);
      long long v24 = *(_OWORD *)(v17 + 120);
      *(_DWORD *)(a3 + 224) = *(_DWORD *)(v17 + 136);
      *(_OWORD *)(a3 + 192) = v23;
      *(_OWORD *)(a3 + 208) = v24;
      *(_OWORD *)(a3 + 176) = v22;
      re::DynamicArray<unsigned long>::deinit(v17);
      re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v11);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v6);
      uint64_t v5 = v17 + 152;
      a3 += 240;
    }
    while (v5 != a2);
  }
  return result;
}

void *re::DynamicArray<re::RigSplineIKHandle>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 240 * a2 + 88;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10);
      re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v10 - 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10 - 80);
      ++v9;
      v8 += 240;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 240 * v4 + 176;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(_DWORD *)(v7 - 176) = 1008981770;
        *(void *)(v7 - 160) = 0;
        *(void *)(v7 - 152) = 0;
        *(void *)(v7 - 168) = 0;
        *(_DWORD *)(v7 - 144) = 0;
        *(_OWORD *)(v7 - 136) = 0uLL;
        *(_OWORD *)(v7 - 120) = 0uLL;
        *(_DWORD *)(v7 - 104) = 0;
        *(_OWORD *)(v7 - 96) = 0uLL;
        *(_OWORD *)(v7 - 80) = 0uLL;
        *(_DWORD *)(v7 - 64) = 0;
        *(void *)(v7 - 56) = 0;
        *(void *)(v7 - 48) = -1;
        *(void *)(v7 - 40) = -1;
        *(void *)(v7 - 32) = -1;
        *(void *)(v7 - 16) = -1;
        *(void *)(v7 - 8) = -1;
        *(_DWORD *)(v7 + 48) = 0;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        v6 += 240;
        *(_OWORD *)uint64_t v7 = 0uLL;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSplineIKHandle>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigSplineIKHandle>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKHandle>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 240 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 240;
        v11 -= 240;
      }
      while (v11);
    }
  }
}

uint64_t re::DynamicArray<re::RigSplineIKHandle>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 240 * v2;
    uint64_t v4 = *(void *)(result + 32) + 88;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v4);
      re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v4 - 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v4 - 80);
      v4 += 240;
      v3 -= 240;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 240 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 240 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigTransform>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigTransform>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigTransform>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigTransform>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigTransform>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigTransform>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigTransform>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigTransform>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigTransform>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigTransform>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v13 = 0u;
  memset(v10, 0, sizeof(v10));
  uint64_t v11 = 0x3F8000003F800000;
  uint64_t v12 = 1065353216;
  LOBYTE(v13) = 7;
  re::DynamicArray<re::RigTransform>::add(this, (uint64_t)v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

void *re::DynamicArray<re::RigTransform>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigTransform>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + (v4 << 6);
      uint64_t v7 = v5 + (a2 << 6) - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = ((unint64_t)v7 >> 6) + 1;
        do
        {
          *(_OWORD *)uint64_t v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = 0uLL;
          *(void *)(v6 + 32) = 0x3F8000003F800000;
          *(void *)(v6 + 40) = 1065353216;
          --v8;
          *(unsigned char *)(v6 + 48) = 7;
          v6 += 64;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigTransform>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigTransform>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigTransform>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigJoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigJoint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigJoint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigJoint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigJoint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigJoint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigJoint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigJoint>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigJoint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigJoint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v13 = 0u;
  v10[0] = 0u;
  v10[1] = xmmword_23435FBB0;
  _OWORD v10[2] = 0u;
  v10[3] = xmmword_23435FBB0;
  uint64_t v11 = 0x3F8000003F800000;
  uint64_t v12 = 1065353216;
  LOBYTE(v13) = 7;
  re::DynamicArray<re::RigJoint>::add(this, (uint64_t)v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 96 * *((void *)this + 2) - 96);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 96 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 96 * a3;
}

void *re::DynamicArray<re::RigJoint>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::RigJoint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 96 * v4;
      uint64_t v7 = v5 + 96 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = v7 / 0x60uLL + 1;
        do
        {
          *(_OWORD *)uint64_t v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = xmmword_23435FBB0;
          *(_OWORD *)(v6 + 32) = 0uLL;
          *(_OWORD *)(v6 + 48) = xmmword_23435FBB0;
          --v8;
          *(void *)(v6 + 64) = 0x3F8000003F800000;
          *(void *)(v6 + 72) = 1065353216;
          *(unsigned char *)(v6 + 80) = 7;
          v6 += 96;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigJoint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigJoint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigJoint>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 96 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 96;
        v11 -= 96;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 96 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 96 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeConstraint>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigNodeConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigNodeConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNodeConstraint>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeChannel>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v10 = xmmword_234361D10;
  re::DynamicArray<re::RigNodeConstraint>::add(this, (__n128 *)&v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 16 * *((void *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      long long v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigIKHandles>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigIKHandles>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigIKHandles>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigNodeChannel>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v10 = xmmword_234361D10;
  re::DynamicArray<re::RigNodeConstraint>::add(this, (__n128 *)&v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 16 * *((void *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      long long v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigNode>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigNode>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigNode>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigNode>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::RigNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::RigNode>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::RigNode>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::RigNode>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNode>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = (unint64_t)"";
  uint64_t v11 = 0;
  uint64_t v12 = -1;
  uint64_t v13 = -1;
  long long v14 = xmmword_234361D10;
  re::DynamicArray<re::RigNode>::add(this, &v10);
  re::StringID::destroyString((re::StringID *)&v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 56 * *((void *)this + 2) - 56);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

uint64_t re::DynamicArray<re::RigNode>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    int v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 56 * v4;
        do
        {
          re::StringID::destroyString(v3);
          int v3 = (re::StringID *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        int v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::DynamicArray<re::RigNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 56 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 56;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::RigNode>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 56 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = "";
        *(unsigned char *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = -1;
        *(void *)(v7 + 32) = -1;
        *(_OWORD *)(v7 + 40) = xmmword_234361D10;
        v6 += 56;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigNode>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigNode>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigNode>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigNode>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::RigNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      __n128 v10 = *(char **)(a1 + 32);
      uint64_t v11 = 56 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 56;
        v11 -= 56;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::RigNode>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    int v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = 56 * v2;
    do
    {
      re::StringID::destroyString(v3);
      int v3 = (re::StringID *)((char *)v3 + 56);
      v4 -= 56;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 56 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 56 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigPoseNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigPoseNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigPoseNode>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigPoseNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::RigPoseNode>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::RigPoseNode>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigPoseNode>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = (void *)(*(void *)(a4 + 32) + 24 * v9);
  *uint64_t v15 = 0;
  v15[1] = -1;
  v15[2] = -1;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  uint64_t v17 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 24 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

void *re::DynamicArray<re::RigPoseNode>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 24 * v4;
      uint64_t v7 = v5 + 24 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = v7 / 0x18uLL + 1;
        do
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(void *)(v6 + 8) = -1;
          *(void *)(v6 + 16) = -1;
          --v8;
          v6 += 24;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigPoseNode>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 24 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 24;
        v11 -= 24;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 24 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::RigPose>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigPose>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::RigPose>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigPose>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::RigPose>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigPose>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::RigPose>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::RigPose>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::RigPose>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::RigPose>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::RigPose>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigPose>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  long long v19 = xmmword_234361D10;
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::RigPose>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigPose>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  uint64_t v15 = *(void *)(a4 + 32) + 32 * v9;
  *(void *)uint64_t v15 = 0;
  *(void *)(v15 + 8) = "";
  v18[0] = 0;
  v18[1] = "";
  *(_OWORD *)(v15 + 16) = v19;
  ++*(void *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)v18);
  uint64_t v16 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 32 * *(void *)(a4 + 16) - 32);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

uint64_t re::DynamicArray<re::RigPose>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    int v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 32 * v4;
        do
        {
          re::StringID::destroyString(v3);
          int v3 = (re::StringID *)((char *)v3 + 32);
          v5 -= 32;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        int v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::RigPose>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::RigPose>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = &v8[4 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          *((_OWORD *)v11 + 1) = *((_OWORD *)v8 + 1);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 4;
          v11 += 4;
        }
        while (v8 != v10);
        unint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::RigPose>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 32 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::RigPose>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 32 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = "";
        *(_OWORD *)(v7 + 16) = xmmword_234361D10;
        v6 += 32;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::RigPose>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigPose>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigPose>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::RigPose>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::RigPose>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::RigPose>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = 32 * v2;
    do
    {
      re::StringID::destroyString(v3);
      uint64_t v3 = (re::StringID *)((char *)v3 + 32);
      v4 -= 32;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 32 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::RigDefinition::~RigDefinition(re::RigDefinition *this)
{
}

re::internal::AutoRetargetRigGraphNode *re::internal::AutoRetargetRigGraphNode::AutoRetargetRigGraphNode(re::internal::AutoRetargetRigGraphNode *this, re::Allocator *a2, const re::RigHierarchy *a3, const re::RigHierarchy *a4)
{
  *(void *)this = 0;
  re::internal::AutoRetargetRigGraphNode::makeJointDefArray(a2, a3, (void *)this + 1);
  re::internal::AutoRetargetRigGraphNode::makeJointDefArray(a2, a4, (void *)this + 4);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  unint64_t v7 = *((void *)a4 + 27);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = 0;
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)this + 10, (uint64_t)a2, v7);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 128) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 17) = a2;
  return this;
}

void re::internal::AutoRetargetRigGraphNode::makeJointDefArray(re::Allocator *a1@<X1>, const re::RigHierarchy *a2@<X2>, void *a3@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  unint64_t v5 = *((void *)a2 + 27);
  *a3 = a1;
  a3[1] = v5;
  a3[2] = 0;
  if (v5)
  {
    if (!(v5 >> 59))
    {
      unint64_t v7 = (unint64_t *)(*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)a1 + 32))(a1, 32 * v5, 8);
      a3[2] = v7;
      if (!v7) {
        goto LABEL_24;
      }
      uint64_t v9 = v7;
      unint64_t v10 = v5 - 1;
      if (v5 == 1)
      {
        *unint64_t v7 = 0;
        v7[1] = (unint64_t)"";
        uint64_t v11 = v7 + 3;
        uint64_t v7[2] = 0;
      }
      else
      {
        uint64_t v11 = v7 + 3;
        do
        {
          *(v11 - 3) = 0;
          *(v11 - 2) = "";
          *(v11 - 1) = 0;
          *uint64_t v11 = "";
          v11 += 4;
          --v10;
        }
        while (v10);
        *(v11 - 3) = 0;
        *(v11 - 2) = "";
        *(v11 - 1) = 0;
      }
      unint64_t v12 = 0;
      *uint64_t v11 = "";
      while (1)
      {
        uint64_t v24 = 0;
        __s = "";
        uint64_t v26 = 0;
        long long v27 = "";
        unint64_t v13 = (uint64_t *)re::RigHierarchy::jointName(a2, v12);
        re::StringID::operator=((unint64_t *)&v24, v13);
        size_t v14 = strlen(__s);
        *(void *)&v34[0] = __s;
        *((void *)&v34[0] + 1) = v14;
        uint64_t v15 = (_anonymous_namespace_ *)re::RigHierarchy::jointParent(a2, (uint64_t)v34, 1, (uint64_t)v20);
        if (!v20[0]) {
          goto LABEL_13;
        }
        if (v21)
        {
          re::StringID::operator=((unint64_t *)&v26, v21);
        }
        else
        {
LABEL_13:
          *(void *)long long v29 = 0;
          *(void *)&v29[8] = "";
          uint64_t v16 = *(void *)v29;
          uint64_t v17 = *(const char **)&v29[8];
          *(void *)long long v29 = 0;
          *(void *)&v29[8] = "";
          char v18 = v26;
          long long v19 = v27;
          uint64_t v26 = v16;
          long long v27 = v17;
          *(void *)&v34[0] = v16 & 0xFFFFFFFFFFFFFFFELL | v18 & 1;
          *((void *)&v34[0] + 1) = v19;
          re::StringID::destroyString((re::StringID *)v34);
          re::StringID::destroyString((re::StringID *)v29);
        }
        if (v5 == v12) {
          break;
        }
        re::StringID::operator=(v9, &v24);
        re::StringID::operator=(v9 + 2, &v26);
        if (!v20[0] && v22 && (v23 & 1) != 0) {
          (*(void (**)(void))(*(void *)v22 + 40))();
        }
        re::StringID::destroyString((re::StringID *)&v26);
        re::StringID::destroyString((re::StringID *)&v24);
        ++v12;
        v9 += 4;
        if (v5 == v12) {
          return;
        }
      }
      uint64_t v28 = 0;
      memset(v34, 0, sizeof(v34));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v29 = 136315906;
      *(void *)&v29[4] = "operator[]";
      *(_WORD *)&v29[12] = 1024;
      *(_DWORD *)&v29[14] = 468;
      __int16 v30 = 2048;
      unint64_t v31 = v5;
      __int16 v32 = 2048;
      unint64_t v33 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)a1, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, v5);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
}

BOOL re::internal::AutoRetargetRigGraphNode::initialize(re::internal::AutoRetargetRigGraphNode *this, const re::RigDataValue *a2, const re::RigDataValue *a3, const re::RigDataValue *a4, const re::RigDataValue *a5)
{
  if (*((unsigned char *)this + 128)) {
    return 1;
  }
  re::internal::getSRTFromRDV(a4, v27);
  re::internal::getSRTFromRDV(a5, v26);
  float32x4_t v10 = vmulq_f32(v27[0], v27[0]);
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]) < 1.0e-10)return 0; {
  float32x4_t v11 = vmulq_f32(v26[0], v26[0]);
  }
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]) < 1.0e-10)return 0; {
  uint64_t v23 = 0;
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  re::FixedArray<CoreIKBaseJoint>::init<>(&v23, *((void *)this + 17), *((void *)a2 + 32));
  re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(a2, (uint64_t)this + 8, (uint64_t)&v23);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  re::FixedArray<CoreIKBaseJoint>::init<>(&v20, *((void *)this + 17), *((void *)a3 + 32));
  re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(a3, (uint64_t)this + 32, (uint64_t)&v20);
  uint64_t v14 = v21;
  uint64_t v13 = v22;
  uint64_t v16 = v24;
  uint64_t v15 = v25;
  uint64_t RetargetRig = CoreIKAutoMatchingGenerateRetargetRig();
  unint64_t v18 = MEMORY[0x237DBA570](RetargetRig);
  if (!*((void *)this + 7)) {
    re::FixedArray<CoreIKTransform>::init<>((uint64_t *)this + 7, *((void *)this + 17), v18);
  }
  if (!*((void *)this + 13)) {
    re::FixedArray<unsigned long>::init<>((uint64_t *)this + 13, *((void *)this + 17), v18);
  }
  CoreIKAutoMatchingGenerateHierarchyToRigMapping();
  uint64_t v19 = MEMORY[0x237DBA0D0](RetargetRig);
  *(void *)this = v19;
  if (RetargetRig)
  {
    MEMORY[0x237DBA110](RetargetRig);
    uint64_t v19 = *(void *)this;
  }
  BOOL v5 = v19 != 0;
  *((unsigned char *)this + 128) = v5;
  if (v14 && v20) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 40))(v20, v13);
  }
  if (v16 && v23) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 40))(v23, v15);
  }
  return v5;
}

void re::FixedArray<CoreIKBaseJoint>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >= 0x555555555555556)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 48 * a3;
  uint64_t v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 48 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 48);
    uint64_t v8 = (_OWORD *)((char *)v8 + v5 - 48);
  }
  v8[1] = 0u;
  v8[2] = 0u;
  _OWORD *v8 = 0u;
}

__n128 re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(re::RigDataValue *this, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*((void *)this + 32))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      unint64_t v9 = *(void *)(a2 + 8);
      if (v9 <= v8)
      {
        *(void *)unint64_t v18 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v27 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v17 = 136315906;
        *(void *)&v17[4] = "operator[]";
        *(_WORD *)&v17[12] = 1024;
        *(_DWORD *)&v17[14] = 476;
        *(_WORD *)&v17[18] = 2048;
        *(void *)&v17[20] = v8;
        *(_WORD *)&v17[28] = 2048;
        *(void *)&v17[30] = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        long long v28 = 0u;
        long long v29 = 0u;
        long long v27 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v18 = 136315906;
        *(void *)&v18[4] = "operator[]";
        __int16 v19 = 1024;
        int v20 = 468;
        __int16 v21 = 2048;
        unint64_t v22 = v8;
        __int16 v23 = 2048;
        unint64_t v24 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = *(void *)(a2 + 16) + v7;
      uint64_t v11 = *(void *)(v10 + 8);
      uint64_t v12 = *(void *)(v10 + 24);
      unint64_t v13 = re::RigDataValue::attributeValue(this, v8);
      *(void *)&unsigned char v17[8] = 1065353216;
      *(void *)&v17[16] = 0;
      *(void *)uint64_t v17 = 0x3F8000003F800000;
      *(void *)&v17[24] = 0x3F80000000000000;
      *(_OWORD *)&v17[32] = 0uLL;
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v13, v17);
      unint64_t v9 = *(void *)(a3 + 8);
      if (v9 <= v8) {
        goto LABEL_8;
      }
      long long v15 = *(_OWORD *)&v17[16];
      __n128 result = *(__n128 *)&v17[32];
      uint64_t v16 = *(void *)(a3 + 16) + v6;
      *(void *)uint64_t v16 = v11;
      *(void *)(v16 + 8) = v12;
      *(void *)(v16 + 16) = result.n128_u64[0];
      *(_DWORD *)(v16 + 24) = result.n128_u32[2];
      *(_OWORD *)(v16 + 32) = v15;
      ++v8;
      v7 += 32;
      v6 += 48;
    }
    while (v8 < *((void *)this + 32));
  }
  return result;
}

uint64_t re::internal::AutoRetargetRigGraphNode::solveAndUpdate(re::internal::AutoRetargetRigGraphNode *this, unint64_t a2, const re::RigDataValue *a3, re::RigDataValue *a4)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (*((void *)this + 8))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 1065353216;
    while (1)
    {
      unint64_t v11 = *((void *)this + 14);
      if (v11 <= v9) {
        break;
      }
      unint64_t v12 = *(void *)(*((void *)this + 15) + 8 * v9);
      *(void *)long long v27 = 0x3F8000003F800000;
      *(void *)&v27[8] = 1065353216;
      *(void *)&v27[16] = 0;
      *(void *)&v27[24] = 0x3F80000000000000;
      *(_OWORD *)&v27[32] = 0uLL;
      unint64_t v13 = re::RigDataValue::attributeValue((re::RigDataValue *)a2, v12);
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v13, v27);
      unint64_t v11 = *((void *)this + 8);
      if (v11 <= v9) {
        goto LABEL_25;
      }
      long long v15 = *(_OWORD *)&v27[16];
      uint64_t v14 = *(void *)&v27[32];
      uint64_t v16 = *((void *)this + 9) + v8;
      *(_DWORD *)(v16 + 8) = *(_DWORD *)&v27[40];
      *(void *)uint64_t v16 = v14;
      *(_OWORD *)(v16 + 16) = v15;
      ++v9;
      v8 += 32;
      if (v9 >= *((void *)this + 8)) {
        goto LABEL_8;
      }
    }
    *(void *)long long v28 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v27 = 136315906;
    *(void *)&v27[4] = "operator[]";
    *(_WORD *)&v27[12] = 1024;
    *(_DWORD *)&v27[14] = 468;
    *(_WORD *)&v27[18] = 2048;
    *(void *)&v27[20] = v9;
    *(_WORD *)&v27[28] = 2048;
    *(void *)&v27[30] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_25:
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v28 = 136315906;
    *(void *)&v28[4] = "operator[]";
    __int16 v29 = 1024;
    int v30 = 468;
    __int16 v31 = 2048;
    unint64_t v32 = v9;
    __int16 v33 = 2048;
    unint64_t v34 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    *(void *)long long v28 = 0;
    *(_OWORD *)(v10 + 48) = 0u;
    *(_OWORD *)(v10 + 64) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v27 = 136315906;
    *(void *)&v27[4] = "operator[]";
    *(_WORD *)&v27[12] = 1024;
    *(_DWORD *)&v27[14] = 468;
    *(_WORD *)&v27[18] = 2048;
    *(void *)&v27[20] = a2;
    *(_WORD *)&v27[28] = 2048;
    *(void *)&v27[30] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_8:
  re::internal::transferPose(a3, (uint64_t)this + 80);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  int v17 = CoreIKSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKSolverGetConstraintCount();
    kdebug_trace();
  }
  uint64_t v10 = (uint64_t)&v35;
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::internal::transferPose((re::RigDataValue *)a2, a4, v18);
  if (!v17 && *((void *)this + 8))
  {
    uint64_t v19 = 0;
    a2 = 0;
    do
    {
      unint64_t v11 = *((void *)this + 14);
      if (v11 <= a2) {
        goto LABEL_26;
      }
      unint64_t v20 = *(void *)(*((void *)this + 15) + 8 * a2);
      __int16 v21 = (long long *)(*((void *)this + 9) + v19);
      uint64_t v22 = *((void *)v21 + 2);
      uint64_t v23 = *((void *)v21 + 3);
      long long v24 = *v21;
      *(void *)&long long v35 = 0x3F8000003F800000;
      *((void *)&v35 + 1) = 1065353216;
      *(void *)&long long v36 = v22;
      *((void *)&v36 + 1) = v23;
      long long v37 = v24;
      unint64_t v25 = re::RigDataValue::attributeValue(a4, v20);
      re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v25, &v35);
      ++a2;
      v19 += 32;
    }
    while (a2 < *((void *)this + 8));
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result) {
    return kdebug_trace();
  }
  return result;
}

re::RigDataValue *re::internal::GameRigSettingsUpdateHelper::updateRigJointSettings(re::RigDataValue *this)
{
  if (*((void *)this + 32))
  {
    uint64_t v1 = this;
    unint64_t v2 = 0;
    do
    {
      int v3 = (re::RigDataValue *)re::RigDataValue::attributeValue(v1, v2);
      unint64_t v4 = re::RigDataValue::attributeValue(v3, 0);
      re::RigDataValue::getRuntimeValue<float>(v4, v5);
      unint64_t v6 = re::RigDataValue::attributeValue(v3, 1uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v6, v7);
      unint64_t v8 = re::RigDataValue::attributeValue(v3, 2uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v8, v9);
      CoreIKGenericSolverGetJoint();
      CoreIKJointSetRetargetingGain();
      CoreIKJointSetRetargetingGainDOF();
      this = (re::RigDataValue *)CoreIKJointSetRotationStiffness();
      ++v2;
    }
    while (v2 < *((void *)v1 + 32));
  }
  return this;
}

re::RigDataValue *re::internal::GameRigSettingsUpdateHelper::updateRigTaskSettings(re::RigDataValue *this, uint64_t a2)
{
  if (*((void *)this + 32))
  {
    int v3 = this;
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = (re::RigDataValue *)re::RigDataValue::attributeValue(v3, v4);
      unint64_t v6 = re::RigDataValue::attributeValue(v5, 0);
      __n128 v14 = *(__n128 *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v6, v7);
      unint64_t v8 = re::RigDataValue::attributeValue(v5, 1uLL);
      __n128 v13 = *(__n128 *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v8, v9);
      unint64_t v10 = re::RigDataValue::attributeValue(v5, 2uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v10, v11);
      MEMORY[0x237DBA340](a2, v4);
      uint64_t v12 = MEMORY[0x237DBA220]();
      MEMORY[0x237DBA520](v14);
      MEMORY[0x237DBA510](v12, v13);
      this = (re::RigDataValue *)CoreIKGenericConstraintSetLookAtAxis();
      ++v4;
    }
    while (v4 < *((void *)v3 + 32));
  }
  return this;
}

uint64_t re::internal::GameRigSettingsUpdateHelper::updateRigSolverSettings(re::RigDataValue *a1, uint64_t a2)
{
  unint64_t v4 = re::RigDataValue::attributeValue(a1, 0);
  uint64_t v6 = *(unsigned int *)re::RigDataValue::getRuntimeValue<int>(v4, v5);
  unint64_t v7 = re::RigDataValue::attributeValue(a1, 1uLL);
  unsigned __int32 v9 = *(_DWORD *)re::RigDataValue::getRuntimeValue<float>(v7, v8);
  MEMORY[0x237DBA3F0](a2, v6);
  v10.n128_u32[0] = v9;
  return MEMORY[0x270F1A640](a2, v10);
}

void re::internal::registerMakeIKLookAtTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE0F48;
  v7[1] = *(_OWORD *)&off_264BE0F58;
  uint64_t v7[2] = xmmword_264BE0F68;
  v7[3] = *(_OWORD *)&off_264BE0F78;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKLookAtTaskCompile(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = *a4;
  __n128 v10 = "lookAtTarget";
  uint64_t v11 = 12;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "rotationAlpha";
  uint64_t v11 = 13;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "taskIndex";
  uint64_t v11 = 9;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

void re::internal::registerMakeIKTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE0F88;
  v7[1] = *(_OWORD *)&off_264BE0F98;
  uint64_t v7[2] = xmmword_264BE0FA8;
  v7[3] = *(_OWORD *)&off_264BE0FB8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKTaskCompile(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = *a4;
  __n128 v10 = "target";
  uint64_t v11 = 6;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "targetAlpha";
  uint64_t v11 = 11;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "taskIndex";
  uint64_t v11 = 9;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

void re::internal::registerMakeIKPenetrationCorrectionTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE0FC8;
  v7[1] = *(_OWORD *)&off_264BE0FD8;
  uint64_t v7[2] = xmmword_264BE0FE8;
  v7[3] = *(_OWORD *)&off_264BE0FF8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKPenetrationCorrectionTask(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = *a4;
  __n128 v10 = "inJointName";
  uint64_t v11 = 11;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "inRayCastDirection";
  uint64_t v11 = 18;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  __n128 v10 = "inRayCastLength";
  uint64_t v11 = 15;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  return 1;
}

void re::internal::registerMakeIKRigJointSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE1028;
  v7[3] = *(_OWORD *)&off_264BE1038;
  _OWORD v7[4] = xmmword_264BE1048;
  v7[0] = xmmword_264BE1008;
  v7[1] = *(_OWORD *)&off_264BE1018;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKRigJointSettings(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  if (a3 == 1)
  {
LABEL_24:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  if (a3 <= 2)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  if (a3 == 3)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (!a5)
  {
LABEL_27:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v8 = a2[2];
  uint64_t v7 = a2[3];
  uint64_t v9 = *a4;
  uint64_t v11 = "inJointName";
  uint64_t v12 = 11;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v6);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inRetargetingGain";
  uint64_t v12 = 17;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v5);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inRetargetingGainDof";
  uint64_t v12 = 20;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v8);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inStiffness";
  uint64_t v12 = 11;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v7);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  return 1;
}

void re::internal::registerMakeIKRigTaskSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE1078;
  v7[3] = *(_OWORD *)&off_264BE1088;
  _OWORD v7[4] = xmmword_264BE1098;
  v7[0] = xmmword_264BE1058;
  v7[1] = *(_OWORD *)&off_264BE1068;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKRigTaskSettings(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  if (a3 == 1)
  {
LABEL_24:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  if (a3 <= 2)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  if (a3 == 3)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (!a5)
  {
LABEL_27:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v8 = a2[2];
  uint64_t v7 = a2[3];
  uint64_t v9 = *a4;
  uint64_t v11 = "inTaskBoneName";
  uint64_t v12 = 14;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v6);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inPositionWeight";
  uint64_t v12 = 16;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v5);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inRotationWeight";
  uint64_t v12 = 16;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v8);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t v11 = "inLookAtAxis";
  uint64_t v12 = 12;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v7);
  if (!v13[0] && v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  return 1;
}

void re::internal::registerMakeIKRigSolverSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE10A8;
  v7[1] = *(_OWORD *)&off_264BE10B8;
  uint64_t v7[2] = xmmword_264BE10C8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t anonymous namespace'::makeIKRigSolverSettings(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a3 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (!a5)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v7 = *a4;
  uint64_t v9 = "inMaxIterations";
  uint64_t v10 = 15;
  re::RigDataValue::attributeValue(v7, (uint64_t)&v9, (uint64_t)v11);
  re::RigDataValue::operator=(v12, v6);
  if (!v11[0] && v13 && (v14 & 1) != 0) {
    (*(void (**)(void))(*(void *)v13 + 40))();
  }
  uint64_t v9 = "inRetargetingGain";
  uint64_t v10 = 17;
  re::RigDataValue::attributeValue(v7, (uint64_t)&v9, (uint64_t)v11);
  re::RigDataValue::operator=(v12, v5);
  if (!v11[0] && v13 && (v14 & 1) != 0) {
    (*(void (**)(void))(*(void *)v13 + 40))();
  }
  return 1;
}

void re::introspect_BlendSpaceType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737A0, memory_order_acquire) & 1) == 0)
  {
    long long v24 = (re *)__cxa_guard_acquire(&qword_26AF737A0);
    if (v24)
    {
      unint64_t v25 = re::introspectionAllocator(v24);
      long long v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)long long v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "None";
      qword_26AF73830 = (uint64_t)v26;
      long long v27 = re::introspectionAllocator(v26);
      long long v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)long long v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "1DLinearUniform";
      qword_26AF73838 = (uint64_t)v28;
      __int16 v29 = re::introspectionAllocator(v28);
      int v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)int v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "1DLinearNonUniform";
      qword_26AF73840 = (uint64_t)v30;
      __int16 v31 = re::introspectionAllocator(v30);
      unint64_t v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)unint64_t v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "2DLinearUniform";
      qword_26AF73848 = (uint64_t)v32;
      __int16 v33 = re::introspectionAllocator(v32);
      unint64_t v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)unint64_t v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "KernelRegression";
      qword_26AF73850 = (uint64_t)v34;
      long long v35 = re::introspectionAllocator(v34);
      uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = 5;
      *(void *)(v36 + 16) = "RBFInterpolation";
      qword_26AF73858 = v36;
      __cxa_guard_release(&qword_26AF737A0);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF737A8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73910, "BlendSpaceType", 4, 4, 1, 1);
    qword_26AF73910 = (uint64_t)&unk_26E715E00;
    qword_26AF73950 = (uint64_t)&re::introspect_BlendSpaceType(BOOL)::enumTable;
    dword_26AF73920 = 9;
    __cxa_guard_release(&qword_26AF737A8);
  }
  if ((_MergedGlobals_16 & 1) == 0)
  {
    _MergedGlobals_16 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73910, a2);
    uint64_t v38 = 0x3CA07D4B122E305ELL;
    long long v39 = "BlendSpaceType";
    v42[0] = 0x607DD0F01DCLL;
    v42[1] = "uint32_t";
    unint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v42);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v42);
      unint64_t v4 = (unsigned int *)qword_26AF73950;
      v41[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v40.var0 = 2 * v10;
            v40.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v14, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              int v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    unint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v40.var0 = 2 * v18;
              v40.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v22, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v23);
      xmmword_26AF73930 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "BlendSpaceType", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_BlendSpaceAxisDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF737B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73958, "BlendSpaceAxisDefinition");
    __cxa_guard_release(&qword_26AF737B0);
  }
  return &unk_26AF73958;
}

void re::initInfo_BlendSpaceAxisDefinition(re *this, re::IntrospectionBase *a2)
{
  v30[0] = 0x65A436012C3C7D12;
  v30[1] = "BlendSpaceAxisDefinition";
  re::StringID::destroyString((re::StringID *)v30);
  *((_OWORD *)this + 2) = v31;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737B8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF737B8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73860 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::IntrospectionInfo<re::StringID>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "controlValueBindPath";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1000000002;
      *(_DWORD *)(v12 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF73868 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "minValue";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x2000000003;
      *(_DWORD *)(v16 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF73870 = v16;
      int v17 = re::introspectionAllocator((re *)v16);
      char v19 = re::introspect_float((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "maxValue";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x2400000004;
      *(_DWORD *)(v20 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF73878 = v20;
      int v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::introspect_float((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "defaultControlValue";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x2800000005;
      *(_DWORD *)(v24 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF73880 = v24;
      unint64_t v25 = re::introspectionAllocator((re *)v24);
      long long v27 = re::introspect_uint32_t((re *)1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "uniformSampleCount";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x2C00000006;
      *(_DWORD *)(v28 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF73888 = v28;
      __cxa_guard_release(&qword_26AF737B8);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF73860;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BlendSpaceAxisDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendSpaceAxisDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendSpaceAxisDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendSpaceAxisDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v29 = v31;
}

void re::internal::defaultConstruct<re::BlendSpaceAxisDefinition>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = "";
  a3[2] = 0;
  a3[3] = "";
  a3[4] = 0;
  a3[5] = 0;
}

void re::internal::defaultDestruct<re::BlendSpaceAxisDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::StringID::destroyString((re::StringID *)(a3 + 16));
  re::StringID::destroyString((re::StringID *)a3);
}

void *re::internal::defaultConstructV2<re::BlendSpaceAxisDefinition>(void *result)
{
  *uint64_t result = 0;
  result[1] = "";
  result[2] = 0;
  result[3] = "";
  result[4] = 0;
  result[5] = 0;
  return result;
}

void re::internal::defaultDestructV2<re::BlendSpaceAxisDefinition>(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 16));
  re::StringID::destroyString((re::StringID *)a1);
}

void *re::allocInfo_BlendSpaceSampleDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF737C8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF739D0, "BlendSpaceSampleDefinition");
    __cxa_guard_release(&qword_26AF737C8);
  }
  return &unk_26AF739D0;
}

void re::initInfo_BlendSpaceSampleDefinition(re *this, re::IntrospectionBase *a2)
{
  v18[0] = 0x63C009CC69597824;
  v18[1] = "BlendSpaceSampleDefinition";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737D0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF737D0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73800 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "falloffParameter";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1000000002;
      *(_DWORD *)(v12 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF73808 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "position";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x1800000003;
      *(_DWORD *)(v16 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF73810 = v16;
      __cxa_guard_release(&qword_26AF737D0);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF73800;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BlendSpaceSampleDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendSpaceSampleDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendSpaceSampleDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendSpaceSampleDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

void re::internal::defaultConstruct<re::BlendSpaceSampleDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  *(_DWORD *)(a3 + 16) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  *(void *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 48) = 0;
}

void re::internal::defaultDestruct<re::BlendSpaceSampleDefinition>(uint64_t a1, uint64_t a2, re::StringID *a3)
{
  re::DynamicArray<unsigned long>::deinit((uint64_t)a3 + 24);
  re::StringID::destroyString(a3);
}

uint64_t re::internal::defaultConstructV2<re::BlendSpaceSampleDefinition>(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = "";
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 48) = 0;
  return result;
}

void re::internal::defaultDestructV2<re::BlendSpaceSampleDefinition>(re::StringID *a1)
{
  re::DynamicArray<unsigned long>::deinit((uint64_t)a1 + 24);
  re::StringID::destroyString(a1);
}

void *re::allocInfo_BlendSpaceDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF737E0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73A48, "BlendSpaceDefinition");
    __cxa_guard_release(&qword_26AF737E0);
  }
  return &unk_26AF73A48;
}

void re::initInfo_BlendSpaceDefinition(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x32C0B3902874E510;
  v13[1] = "BlendSpaceDefinition";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737E8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF737E8);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_BlendSpaceType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "type";
      *(void *)(v7 + 16) = &qword_26AF73910;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF73818 = v7;
      uint64_t v8 = (re *)re::introspectionAllocator((re *)v7);
      re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceAxisDefinition>>::get(v8);
      uint64_t v9 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v9 = 1;
      *(void *)(v9 + 8) = "axes";
      *(void *)(v9 + 16) = &qword_26AF73890;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0x800000002;
      *(_DWORD *)(v9 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_26AF73820 = v9;
      uint64_t v10 = (re *)re::introspectionAllocator((re *)v9);
      re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceSampleDefinition>>::get(v10);
      uint64_t v11 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "samples";
      *(void *)(v11 + 16) = &qword_26AF738D0;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x3000000003;
      *(_DWORD *)(v11 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF73828 = v11;
      __cxa_guard_release(&qword_26AF737E8);
    }
  }
  *((void *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF73818;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BlendSpaceDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendSpaceDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendSpaceDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendSpaceDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceAxisDefinition>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737F0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF737F0);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73890);
      qword_26AF73890 = (uint64_t)&unk_26E6C2070;
      __cxa_guard_release(&qword_26AF737F0);
    }
  }
  if ((byte_26AF73799 & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF737C0;
    if (qword_26AF737C0
      || (uint64_t v1 = re::allocInfo_BlendSpaceAxisDefinition(a1),
          qword_26AF737C0 = (uint64_t)v1,
          re::initInfo_BlendSpaceAxisDefinition((re *)v1, v2),
          (byte_26AF73799 & 1) == 0))
    {
      byte_26AF73799 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73890, 0);
      qword_26AF738A0 = 0x2800000003;
      dword_26AF738A8 = v3;
      word_26AF738AC = 0;
      *(void *)&xmmword_26AF738B0 = 0;
      *((void *)&xmmword_26AF738B0 + 1) = 0xFFFFFFFFLL;
      qword_26AF738C0 = (uint64_t)v1;
      unk_26AF738C8 = 0;
      qword_26AF73890 = (uint64_t)&unk_26E6C2070;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73890, (const re::IntrospectionBase *)&v14);
      if (v15) {
        unint64_t v6 = *(const char **)&v16[7];
      }
      else {
        unint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF738B0 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceSampleDefinition>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF737F8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF737F8);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF738D0);
      qword_26AF738D0 = (uint64_t)&unk_26E6C2108;
      __cxa_guard_release(&qword_26AF737F8);
    }
  }
  if ((byte_26AF7379A & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF737D8;
    if (qword_26AF737D8
      || (uint64_t v1 = re::allocInfo_BlendSpaceSampleDefinition(a1),
          qword_26AF737D8 = (uint64_t)v1,
          re::initInfo_BlendSpaceSampleDefinition((re *)v1, v2),
          (byte_26AF7379A & 1) == 0))
    {
      byte_26AF7379A = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF738D0, 0);
      qword_26AF738E0 = 0x2800000003;
      dword_26AF738E8 = v3;
      word_26AF738EC = 0;
      *(void *)&xmmword_26AF738F0 = 0;
      *((void *)&xmmword_26AF738F0 + 1) = 0xFFFFFFFFLL;
      qword_26AF73900 = (uint64_t)v1;
      unk_26AF73908 = 0;
      qword_26AF738D0 = (uint64_t)&unk_26E6C2108;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF738D0, (const re::IntrospectionBase *)&v14);
      if (v15) {
        unint64_t v6 = *(const char **)&v16[7];
      }
      else {
        unint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF738F0 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

double re::internal::defaultConstruct<re::BlendSpaceDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(void *)(a3 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::BlendSpaceDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a3 + 48);
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a3 + 8);
}

double re::internal::defaultConstructV2<re::BlendSpaceDefinition>(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::BlendSpaceDefinition>(uint64_t a1)
{
  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a1 + 48);
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a1 + 8);
}

uint64_t re::introspect_BlendSpaceDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendSpaceDefinition", (uint64_t (*)(re::internal *))re::allocInfo_BlendSpaceDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_BlendSpaceDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendSpaceDefinition>, this);
}

void *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a2);
  *(void *)a2 = a3;
  double result = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = (unint64_t)"";
  v11[0] = 0;
  v11[1] = "";
  _OWORD v11[2] = 0;
  _OWORD v11[3] = 0;
  re::DynamicArray<re::BlendSpaceAxisDefinition>::add(this, &v10);
  re::StringID::destroyString((re::StringID *)v11);
  re::StringID::destroyString((re::StringID *)&v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 48 * *((void *)this + 2) - 48);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 48 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 48 * a3;
}

void *re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        __n128 v10 = &v8[6 * v9];
        long long v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *long long v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *long long v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          LOBYTE(v12) = v8[2];
          _OWORD v11[2] = v11[2] & 0xFFFFFFFFFFFFFFFELL | v8[2] & 1;
          _OWORD v11[2] = v8[2] & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          _OWORD v11[3] = v8[3];
          v8[3] = (uint64_t)"";
          v8[2] = 0;
          *((_OWORD *)v11 + 2) = *((_OWORD *)v8 + 2);
          re::StringID::destroyString((re::StringID *)(v8 + 2));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 48 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = *(void *)(a1 + 32) + v8;
      re::StringID::destroyString((re::StringID *)(v10 + 16));
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 48;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 48 * v4;
      do
      {
        uint64_t v7 = (void *)(*(void *)(a1 + 32) + v6);
        *uint64_t v7 = 0;
        v7[1] = "";
        uint64_t v7[2] = 0;
        _OWORD v7[3] = "";
        _OWORD v7[4] = 0;
        _OWORD v7[5] = 0;
        v6 += 48;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

__n128 re::DynamicArray<re::BlendSpaceAxisDefinition>::add(_anonymous_namespace_ *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unint64_t v5 = (__n128 *)(*((void *)this + 4) + 48 * v4);
  unint64_t v6 = a2->n128_u64[0];
  v5->n128_u64[0] = v5->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | a2->n128_u64[0] & 1;
  v5->n128_u64[0] = a2->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  v5->n128_u64[1] = a2->n128_u64[1];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = (unint64_t)"";
  unint64_t v7 = a2[1].n128_u64[0];
  v5[1].n128_u64[0] = v5[1].n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v5[1].n128_u64[0] = a2[1].n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v5[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[0] = 0;
  a2[1].n128_u64[1] = (unint64_t)"";
  __n128 result = a2[2];
  v5[2] = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::BlendSpaceAxisDefinition>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  __n128 result = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 48 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 48;
        v11 -= 48;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::BlendSpaceAxisDefinition>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = 48 * v2;
    do
    {
      re::StringID::destroyString((re::StringID *)(v3 + 16));
      re::StringID::destroyString((re::StringID *)v3);
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 48 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 48 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  v11[0] = 0;
  long long v12 = 0uLL;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  v11[1] = "";
  long long v13 = 0uLL;
  float v8 = re::DynamicArray<re::BlendSpaceSampleDefinition>::add(this, (float *)v11);
  if (*((void *)&v12 + 1))
  {
    if (v15) {
      (*(void (**)(float))(**((void **)&v12 + 1) + 40))(v8);
    }
    uint64_t v15 = 0;
    long long v13 = 0uLL;
    *((void *)&v12 + 1) = 0;
    LODWORD(v14) = v14 + 1;
  }
  re::StringID::destroyString((re::StringID *)v11);
  uint64_t v9 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

void *re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 6;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      float v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = &v8[8 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          *((_DWORD *)v11 + 4) = *((_DWORD *)v8 + 4);
          v11[7] = 0;
          void v11[4] = 0;
          v11[5] = 0;
          _OWORD v11[3] = 0;
          *((_DWORD *)v11 + 12) = 0;
          uint64_t v13 = v8[4];
          _OWORD v11[3] = v8[3];
          v8[3] = 0;
          void v11[4] = v13;
          v8[4] = 0;
          uint64_t v14 = v11[5];
          v11[5] = v8[5];
          v8[5] = v14;
          uint64_t v15 = v11[7];
          v11[7] = v8[7];
          v8[7] = v15;
          ++*((_DWORD *)v8 + 12);
          ++*((_DWORD *)v11 + 12);
          re::DynamicArray<unsigned long>::deinit((uint64_t)(v8 + 3));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 8;
          v11 += 8;
        }
        while (v8 != v10);
        float v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    unint64_t v8 = a2 << 6;
    unint64_t v9 = a2;
    do
    {
      unint64_t v10 = (re::StringID *)(*(void *)(a1 + 32) + v8);
      re::DynamicArray<unsigned long>::deinit((uint64_t)v10 + 24);
      re::StringID::destroyString(v10);
      ++v9;
      v8 += 64;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      unint64_t v6 = v4 << 6;
      do
      {
        unint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)unint64_t v7 = 0;
        *(void *)(v7 + 8) = "";
        *(_DWORD *)(v7 + 16) = 0;
        *(void *)(v7 + 56) = 0;
        *(void *)(v7 + 32) = 0;
        *(void *)(v7 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
        *(void *)(v7 + 24) = 0;
        *(_DWORD *)(v7 + 48) = 0;
        v6 += 64;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

float re::DynamicArray<re::BlendSpaceSampleDefinition>::add(_anonymous_namespace_ *this, float *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + (v4 << 6);
  uint64_t v6 = *(void *)a2;
  *(void *)uint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFFELL | *(void *)a2 & 1;
  *(void *)uint64_t v5 = *(void *)a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(v5 + 8) = *((void *)a2 + 1);
  *(void *)a2 = 0;
  *((void *)a2 + 1) = "";
  float result = a2[4];
  *(float *)(v5 + 16) = result;
  *(void *)(v5 + 56) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v5 + 24) = 0;
  uint64_t v8 = *((void *)a2 + 4);
  *(void *)(v5 + 24) = *((void *)a2 + 3);
  *(void *)(v5 + 32) = v8;
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  uint64_t v9 = *(void *)(v5 + 40);
  *(void *)(v5 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = *((void *)a2 + 5);
  *((void *)a2 + 5) = v9;
  uint64_t v10 = *(void *)(v5 + 56);
  *(void *)(v5 + 56) = *((void *)a2 + 7);
  *((void *)a2 + 7) = v10;
  ++*((_DWORD *)a2 + 12);
  ++*(_DWORD *)(v5 + 48);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::BlendSpaceSampleDefinition>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  float result = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::BlendSpaceSampleDefinition>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    unint64_t v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = v2 << 6;
    do
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 24);
      re::StringID::destroyString(v3);
      unint64_t v3 = (re::StringID *)((char *)v3 + 64);
      v4 -= 64;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::StateParameterBlackboard::deinit(re::StateParameterBlackboard *this)
{
  uint64_t v2 = *((unsigned int *)this + 10);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = (int *)*((void *)this + 3);
    while (1)
    {
      int v5 = *v4;
      v4 += 8;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 10);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 8, *(void **)(*((void *)this + 3) + 32 * v6 + 24));
      LODWORD(v2) = *((_DWORD *)this + 10);
      if (v2 <= (int)v3 + 1) {
        int v7 = v3 + 1;
      }
      else {
        int v7 = *((_DWORD *)this + 10);
      }
      int v8 = v3;
      while (1)
      {
        uint64_t v6 = (v8 + 1);
        if (v7 - 1 == v8) {
          break;
        }
        ++v8;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)this + 3) + 32 * v6) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v7;
LABEL_17:
      ;
    }
    while (v2 != v3);
  }
  if (*((_DWORD *)this + 9))
  {
    uint64_t v9 = *((unsigned int *)this + 8);
    if (v9)
    {
      memset_pattern16(*((void **)this + 2), &unk_2343655D0, 4 * v9);
      LODWORD(v2) = *((_DWORD *)this + 10);
    }
    if (v2)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      do
      {
        uint64_t v12 = *((void *)this + 3);
        int v13 = *(_DWORD *)(v12 + v10);
        if (v13 < 0)
        {
          *(_DWORD *)(v12 + v10) = v13 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v12 + v10 + 8));
          LODWORD(v2) = *((_DWORD *)this + 10);
        }
        ++v11;
        v10 += 32;
      }
      while (v11 < v2);
    }
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 10) = 0;
    int v14 = *((_DWORD *)this + 12) + 1;
    *((_DWORD *)this + 11) = 0x7FFFFFFF;
    *((_DWORD *)this + 12) = v14;
  }
  uint64_t v15 = *((unsigned int *)this + 22);
  if (v15)
  {
    uint64_t v16 = 0;
    long long v17 = (int *)*((void *)this + 9);
    while (1)
    {
      int v18 = *v17;
      v17 += 8;
      if (v18 < 0) {
        break;
      }
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 22);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if (v15 != v16)
  {
    uint64_t v19 = v16;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 13, *(void **)(*((void *)this + 9) + 32 * v19 + 24));
      LODWORD(v15) = *((_DWORD *)this + 22);
      if (v15 <= (int)v16 + 1) {
        int v20 = v16 + 1;
      }
      else {
        int v20 = *((_DWORD *)this + 22);
      }
      int v21 = v16;
      while (1)
      {
        uint64_t v19 = (v21 + 1);
        if (v20 - 1 == v21) {
          break;
        }
        ++v21;
        LODWORD(v16) = v19;
        if ((*(_DWORD *)(*((void *)this + 9) + 32 * v19) & 0x80000000) != 0) {
          goto LABEL_43;
        }
      }
      LODWORD(v16) = v20;
LABEL_43:
      ;
    }
    while (v15 != v16);
  }
  if (*((_DWORD *)this + 21))
  {
    uint64_t v22 = *((unsigned int *)this + 20);
    if (v22)
    {
      memset_pattern16(*((void **)this + 8), &unk_2343655D0, 4 * v22);
      LODWORD(v15) = *((_DWORD *)this + 22);
    }
    if (v15)
    {
      uint64_t v23 = 0;
      unint64_t v24 = 0;
      do
      {
        uint64_t v25 = *((void *)this + 9);
        int v26 = *(_DWORD *)(v25 + v23);
        if (v26 < 0)
        {
          *(_DWORD *)(v25 + v23) = v26 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v25 + v23 + 8));
          LODWORD(v15) = *((_DWORD *)this + 22);
        }
        ++v24;
        v23 += 32;
      }
      while (v24 < v15);
    }
    *((_DWORD *)this + 21) = 0;
    *((_DWORD *)this + 22) = 0;
    int v27 = *((_DWORD *)this + 24) + 1;
    *((_DWORD *)this + 23) = 0x7FFFFFFF;
    *((_DWORD *)this + 24) = v27;
  }
  uint64_t v28 = *((unsigned int *)this + 34);
  if (v28)
  {
    uint64_t v29 = 0;
    int v30 = (int *)*((void *)this + 15);
    while (1)
    {
      int v31 = *v30;
      v30 += 8;
      if (v31 < 0) {
        break;
      }
      if (v28 == ++v29)
      {
        LODWORD(v29) = *((_DWORD *)this + 34);
        break;
      }
    }
  }
  else
  {
    LODWORD(v29) = 0;
  }
  if (v28 != v29)
  {
    uint64_t v32 = v29;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 18, *(void **)(*((void *)this + 15) + 32 * v32 + 24));
      LODWORD(v28) = *((_DWORD *)this + 34);
      if (v28 <= (int)v29 + 1) {
        int v33 = v29 + 1;
      }
      else {
        int v33 = *((_DWORD *)this + 34);
      }
      int v34 = v29;
      while (1)
      {
        uint64_t v32 = (v34 + 1);
        if (v33 - 1 == v34) {
          break;
        }
        ++v34;
        LODWORD(v29) = v32;
        if ((*(_DWORD *)(*((void *)this + 15) + 32 * v32) & 0x80000000) != 0) {
          goto LABEL_69;
        }
      }
      LODWORD(v29) = v33;
LABEL_69:
      ;
    }
    while (v28 != v29);
  }
  if (*((_DWORD *)this + 33))
  {
    uint64_t v35 = *((unsigned int *)this + 32);
    if (v35)
    {
      memset_pattern16(*((void **)this + 14), &unk_2343655D0, 4 * v35);
      LODWORD(v28) = *((_DWORD *)this + 34);
    }
    if (v28)
    {
      uint64_t v36 = 0;
      unint64_t v37 = 0;
      do
      {
        uint64_t v38 = *((void *)this + 15);
        int v39 = *(_DWORD *)(v38 + v36);
        if (v39 < 0)
        {
          *(_DWORD *)(v38 + v36) = v39 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v38 + v36 + 8));
          LODWORD(v28) = *((_DWORD *)this + 34);
        }
        ++v37;
        v36 += 32;
      }
      while (v37 < v28);
    }
    *((_DWORD *)this + 33) = 0;
    *((_DWORD *)this + 34) = 0;
    int v40 = *((_DWORD *)this + 36) + 1;
    *((_DWORD *)this + 35) = 0x7FFFFFFF;
    *((_DWORD *)this + 36) = v40;
  }
  uint64_t v41 = *((unsigned int *)this + 46);
  if (v41)
  {
    uint64_t v42 = 0;
    float v43 = (int *)*((void *)this + 21);
    while (1)
    {
      int v44 = *v43;
      v43 += 8;
      if (v44 < 0) {
        break;
      }
      if (v41 == ++v42)
      {
        LODWORD(v42) = *((_DWORD *)this + 46);
        break;
      }
    }
  }
  else
  {
    LODWORD(v42) = 0;
  }
  if (v41 != v42)
  {
    uint64_t v45 = v42;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 23, *(void **)(*((void *)this + 21) + 32 * v45 + 24));
      LODWORD(v41) = *((_DWORD *)this + 46);
      if (v41 <= (int)v42 + 1) {
        int v46 = v42 + 1;
      }
      else {
        int v46 = *((_DWORD *)this + 46);
      }
      int v47 = v42;
      while (1)
      {
        uint64_t v45 = (v47 + 1);
        if (v46 - 1 == v47) {
          break;
        }
        ++v47;
        LODWORD(v42) = v45;
        if ((*(_DWORD *)(*((void *)this + 21) + 32 * v45) & 0x80000000) != 0) {
          goto LABEL_95;
        }
      }
      LODWORD(v42) = v46;
LABEL_95:
      ;
    }
    while (v41 != v42);
  }
  if (*((_DWORD *)this + 45))
  {
    uint64_t v48 = *((unsigned int *)this + 44);
    if (v48)
    {
      memset_pattern16(*((void **)this + 20), &unk_2343655D0, 4 * v48);
      LODWORD(v41) = *((_DWORD *)this + 46);
    }
    if (v41)
    {
      uint64_t v49 = 0;
      unint64_t v50 = 0;
      do
      {
        uint64_t v51 = *((void *)this + 21);
        int v52 = *(_DWORD *)(v51 + v49);
        if (v52 < 0)
        {
          *(_DWORD *)(v51 + v49) = v52 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v51 + v49 + 8));
          LODWORD(v41) = *((_DWORD *)this + 46);
        }
        ++v50;
        v49 += 32;
      }
      while (v50 < v41);
    }
    *((_DWORD *)this + 45) = 0;
    *((_DWORD *)this + 46) = 0;
    int v53 = *((_DWORD *)this + 48) + 1;
    *((_DWORD *)this + 47) = 0x7FFFFFFF;
    *((_DWORD *)this + 48) = v53;
  }
}

re *re::internal::destroyPersistent<re::StateParameterInt>(re *result, uint64_t a2, void *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    *a3 = &unk_26E6C21A0;
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)(a3 + 2));
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)(a3 + 2));
    int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

BOOL re::StateParameterBlackboard::removeStateParameterInt(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  uint64_t v3 = (char *)this + 8;
  uint64_t v4 = (void **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 8, a2);
  int v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterInt", 33, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

uint64_t re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(uint64_t a1, void *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (!re::StringID::operator==((void *)(v9 + 32 * v7 + 8), a2))
  {
    while (1)
    {
      unsigned int v10 = v7;
      int v11 = *(_DWORD *)(v9 + 32 * v7);
      uint64_t v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (re::StringID::operator==((void *)(v9 + 32 * v7 + 8), a2))
      {
        *(_DWORD *)(v9 + 32 * v10) = *(_DWORD *)(v9 + 32 * v10) & 0x80000000 | *(_DWORD *)(v9 + 32 * v7) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 32 * v7) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  int v13 = (int *)(v12 + 32 * v7);
  int v14 = *v13;
  if (*v13 < 0)
  {
    *int v13 = v14 & 0x7FFFFFFF;
    re::StringID::destroyString((re::StringID *)(v13 + 2));
    uint64_t v12 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v12 + 32 * v7);
  }
  int v15 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v7) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v15 + 1;
  return 1;
}

BOOL re::StateParameterBlackboard::removeStateParameterFloat(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  uint64_t v3 = (char *)this + 56;
  unint64_t v4 = (void **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 56, a2);
  unint64_t v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterFloat", 43, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

BOOL re::StateParameterBlackboard::removeStateParameterBool(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  uint64_t v3 = (char *)this + 104;
  unint64_t v4 = (void **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 104, a2);
  unint64_t v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterBool", 53, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

BOOL re::StateParameterBlackboard::removeStateParameterTrigger(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  uint64_t v3 = (char *)this + 152;
  unint64_t v4 = (void **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 152, a2);
  unint64_t v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterTrigger", 63, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

unsigned char *re::StateParameter::processParameterReset(unsigned char *this)
{
  if (this[56])
  {
    uint64_t v1 = this;
    this = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)this + 8))(this);
    v1[56] = 0;
  }
  return this;
}

double re::AnimationManager::AnimationManager(re::AnimationManager *this)
{
  *(void *)this = &unk_26E6C21D0;
  *((void *)this + 1) = 0;
  *((_WORD *)this + 8) = 259;
  *((_DWORD *)this + 5) = 1023969417;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = -1;
  *((_WORD *)this + 28) = 0;
  uint64_t v1 = 72;
  do
  {
    uint64_t v2 = (char *)this + v1;
    *(void *)uint64_t v2 = 0;
    *((void *)v2 + 1) = 0;
    *((_DWORD *)v2 + 6) = 0;
    *((void *)v2 + 2) = 0;
    *((void *)v2 + 4) = 0;
    *((void *)v2 + 5) = 0;
    *((_DWORD *)v2 + 12) = 0;
    v1 += 64;
    *(void *)(v2 + 52) = 0x1FFFFFFFFLL;
  }
  while (v2 + 64 != (char *)this + 200);
  for (uint64_t i = 0; i != 80; i += 40)
  {
    unint64_t v4 = (char *)this + i;
    *((void *)v4 + 29) = 0;
    *((void *)v4 + 26) = 0;
    *((void *)v4 + 27) = 0;
    *((void *)v4 + 25) = 0;
    *((_DWORD *)v4 + 56) = 0;
  }
  uint64_t v5 = 280;
  do
  {
    uint64_t v6 = (char *)this + v5;
    *((_DWORD *)v6 + 8) = 0;
    *(_OWORD *)uint64_t v6 = 0uLL;
    *((_OWORD *)v6 + 1) = 0uLL;
    *(void *)(v6 + 36) = 0x7FFFFFFFLL;
    v5 += 48;
  }
  while (v6 + 48 != (char *)this + 376);
  for (uint64_t j = 0; j != 80; j += 40)
  {
    int v8 = (char *)this + j;
    *((void *)v8 + 51) = 0;
    *((void *)v8 + 48) = 0;
    *((void *)v8 + 49) = 0;
    *((void *)v8 + 47) = 0;
    *((_DWORD *)v8 + 100) = 0;
  }
  *((_DWORD *)this + 122) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(void *)((char *)this + 492) = 0x7FFFFFFFLL;
  *((_WORD *)this + 252) = 0;
  *((unsigned char *)this + 506) = 0;
  return result;
}

void re::AnimationManager::~AnimationManager(re::AnimationManager *this)
{
  re::AnimationManager::deinit((CFTypeRef *)this);
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)this + 57);
  for (uint64_t i = 416; i != 336; i -= 40)
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + i);
  for (uint64_t j = 328; j != 232; j -= 48)
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)((char *)this + j));
  for (uint64_t k = 240; k != 160; k -= 40)
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + k);
  for (uint64_t m = 136; m != 8; m -= 64)
  {
    re::DataArray<re::internal::TimelineTree>::deinit((uint64_t)this + m);
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + m);
  }
}

{
  uint64_t vars8;

  re::AnimationManager::~AnimationManager(this);
  JUMPOUT(0x237DBCBD0);
}

void re::AnimationManager::deinit(CFTypeRef *this)
{
  if (*((_DWORD *)this + 29))
  {
    uint64_t v2 = 0;
    char v3 = 1;
    do
    {
      char v4 = v3;
      re::DataArray<re::internal::TimelineTree>::deinit((uint64_t)&this[8 * v2 + 9]);
      uint64_t v5 = &this[5 * v2];
      CFTypeRef v6 = v5[27];
      if (v6)
      {
        uint64_t v7 = (re::internal::AnimationHandoffBehavior **)v5[29];
        uint64_t v8 = 8 * (void)v6;
        do
        {
          uint64_t v9 = *v7;
          if (*v7)
          {
            re::internal::AnimationHandoffBehavior::~AnimationHandoffBehavior(*v7);
          }
          ++v7;
          v8 -= 8;
        }
        while (v8);
      }
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v5 + 25));
      unsigned int v10 = &this[5 * v2];
      CFTypeRef v11 = v10[49];
      if (v11)
      {
        uint64_t v12 = v10[51];
        uint64_t v13 = 8 * (void)v11;
        do
        {
          int v14 = (void (***)(void))*v12;
          if (*v12)
          {
            (**v14)(*v12);
          }
          ++v12;
          v13 -= 8;
        }
        while (v13);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&this[6 * v2 + 35]);
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v10 + 47));
      char v3 = 0;
      uint64_t v2 = 1;
    }
    while ((v4 & 1) != 0);
    CFRelease(this[8]);
    this[8] = 0;
    *((unsigned char *)this + 57) = 0;
  }
}

void re::AnimationManager::init(re::AnimationManager *this, CFTypeRef cf, char a3)
{
  if (cf)
  {
    *((unsigned char *)this + 57) = 0;
    *((void *)this + 8) = cf;
    uint64_t v5 = (_anonymous_namespace_ *)CFRetain(cf);
  }
  else
  {
    *((unsigned char *)this + 57) = 1;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    HostTimeClocuint64_t k = CMClockGetHostTimeClock();
    uint64_t v5 = (_anonymous_namespace_ *)CMTimebaseCreateWithSourceClock(v6, HostTimeClock, (CMTimebaseRef *)this + 8);
  }
  uint64_t v8 = 0;
  char v9 = 1;
  do
  {
    char v10 = v9;
    CFTypeRef v11 = (char *)this + 64 * v8;
    v11 += 72;
    re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(v11, 0);
    ++*((_DWORD *)v11 + 6);
    *((_DWORD *)v11 + 11) = 512;
    re::DataArray<re::internal::TimelineTree>::allocBlock(v11);
    uint64_t v12 = (char *)this + 40 * v8;
    v12 += 200;
    re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v12, 0x80uLL);
    ++*((_DWORD *)v12 + 6);
    uint64_t v13 = (uint64_t)re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity((void *)v12 + 22, 0x200uLL);
    char v9 = 0;
    ++*((_DWORD *)v12 + 50);
    uint64_t v8 = 1;
  }
  while ((v10 & 1) != 0);
  if ((a3 & 1) != 0 || (uint64_t v13 = dyld_program_sdk_at_least(), (v13 & 1) == 0))
  {
    int v15 = *re::animationLogObjects((re *)v13);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Using deprecated animation clock. Please rebuild application using newer SDK.", v16, 2u);
    }
    char v14 = 1;
  }
  else
  {
    char v14 = 0;
  }
  *((unsigned char *)this + 506) = v14;
}

uint64_t re::DataArray<re::internal::TimelineTree>::deinit(uint64_t result)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(result + 44)) {
    return result;
  }
  uint64_t v2 = (void *)result;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v22, result, 0);
  uint64_t v3 = v22;
  long long v12 = v22;
  uint64_t v4 = WORD4(v22);
  if ((void *)v22 != v2 || WORD4(v22) != 0xFFFFLL || (DWORD2(v22) & 0xFFFF0000) != 4294901760)
  {
    unint64_t v7 = WORD5(v22);
    while (1)
    {
      unint64_t v8 = *(void *)(v3 + 16);
      if (v8 <= v7) {
        break;
      }
      re::DataArray<re::internal::TimelineTree>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(void *)(*(void *)(v3 + 32) + 16 * v7 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v7 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v12);
      uint64_t v3 = v12;
      uint64_t v4 = WORD4(v12);
      unint64_t v7 = WORD5(v12);
      if ((void *)v12 == v2 && WORD4(v12) == 0xFFFFLL && WORD5(v12) == 0xFFFFLL) {
        goto LABEL_14;
      }
    }
LABEL_28:
    uint64_t v13 = 0;
    long long v26 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    int v15 = "operator[]";
    __int16 v16 = 1024;
    int v17 = 797;
    __int16 v18 = 2048;
    unint64_t v19 = v7;
    __int16 v20 = 2048;
    unint64_t v21 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_14:
  unint64_t v9 = v2[2];
  unint64_t v7 = v9 - 1;
  if (v9 == 1) {
    goto LABEL_23;
  }
  unint64_t v8 = 16 * v9 - 16;
  do
  {
    if (v9 <= v7)
    {
      *(void *)&long long v12 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      int v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 789;
      __int16 v18 = 2048;
      unint64_t v19 = v7;
      __int16 v20 = 2048;
      unint64_t v21 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_27:
      *(void *)&long long v12 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      int v15 = "removeAt";
      __int16 v16 = 1024;
      int v17 = 931;
      __int16 v18 = 2048;
      unint64_t v19 = v7;
      __int16 v20 = 2048;
      unint64_t v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_28;
    }
    char v10 = (void *)(v2[4] + v8);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v10);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v10[1]);
    unint64_t v1 = v2[2];
    if (v1 <= v7) {
      goto LABEL_27;
    }
    unint64_t v9 = v1 - 1;
    if (v1 - 1 > v7)
    {
      *(_OWORD *)(v2[4] + v8) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      unint64_t v9 = v2[2] - 1;
    }
    v2[2] = v9;
    ++*((_DWORD *)v2 + 6);
    v8 -= 16;
    --v7;
  }
  while (v7);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v9)
  {
    *(void *)&long long v12 = 0;
    long long v26 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    uint64_t v2 = (void *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    int v15 = "operator[]";
    __int16 v16 = 1024;
    int v17 = 789;
    __int16 v18 = 2048;
    unint64_t v19 = 0;
    __int16 v20 = 2048;
    unint64_t v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_23:
    v2[6] = 0xFFFFFFFF00000000;
  }
  CFTypeRef v11 = (void *)v2[4];
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v11);
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v11[1]);
  double result = re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

double re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 32 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 32;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::AnimationManager::setTaskOptions(uint64_t result, float *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(result + 32);
  if (v4 != -1) {
    double result = re::Scheduler::setTaskOptions(*(re::Scheduler **)(result + 8), v4, a2);
  }
  uint64_t v5 = *(void *)a2;
  *(unsigned char *)(v3 + 24) = *((unsigned char *)a2 + 8);
  *(void *)(v3 + 16) = v5;
  return result;
}

uint64_t re::Scheduler::setTaskOptions(re::Scheduler *a1, unint64_t a2, float *a3)
{
  re::Scheduler::updateTaskSchedule(a1, a2, *(unsigned __int8 *)a3);
  re::Scheduler::setTaskUpdateInterval(a1, a2, a3[1]);
  re::Scheduler::setTaskOverscheduleStrategy((uint64_t)a1, a2, *((unsigned char *)a3 + 1));
  char v6 = *((unsigned char *)a3 + 8);
  return re::Scheduler::setTaskMaxOverscheduleSubsteps((uint64_t)a1, a2, v6);
}

void re::AnimationManager::isAnimated(re::AnimationManager *this, const re::BindNode *a2)
{
}

uint64_t re::AnimationManager::isAnimated(re::AnimationManager *this, const re::BindPoint *a2)
{
  re::AnimationManager::updateLookupTableForAllBuckets(this);
  unint64_t v4 = re::BindPoint::targetIdentifier(a2);
  uint64_t v5 = 0;
  unint64_t v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  unint64_t v7 = v6 ^ (v6 >> 31);
  char v8 = 1;
  while (1)
  {
    char v9 = v8;
    if (*((void *)this + 6 * v5 + 35))
    {
      uint64_t v10 = *(unsigned int *)(*((void *)this + 6 * v5 + 36) + 4 * (v7 % *((unsigned int *)this + 12 * v5 + 76)));
      if (v10 != 0x7FFFFFFF) {
        break;
      }
    }
LABEL_7:
    char v8 = 0;
    uint64_t v12 = 0;
    uint64_t v5 = 1;
    if ((v9 & 1) == 0) {
      return v12;
    }
  }
  uint64_t v11 = *((void *)this + 6 * v5 + 37);
  while (*(void *)(v11 + 32 * v10 + 16) != v4)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_7;
    }
  }
  return 1;
}

void re::AnimationManager::updateLookupTableForAllBuckets(re::AnimationManager *this)
{
  uint64_t v1 = 0;
  char v2 = 1;
  do
  {
    char v24 = v2;
    uint64_t v3 = (char *)this + 40 * v1;
    if ((int)*((void *)v3 + 49) >= 1)
    {
      int v31 = v3 + 392;
      unint64_t v4 = *((void *)v3 + 49);
      uint64_t v29 = (unint64_t *)((char *)this + 48 * v1 + 280);
      int v30 = (void *)((char *)this + 40 * v1 + 408);
      uint64_t v5 = (char *)this + 48 * v1;
      uint64_t v27 = v5 + 304;
      uint64_t v28 = v5 + 288;
      unint64_t v6 = (uint64_t *)(v5 + 296);
      unint64_t v7 = (int *)(v5 + 316);
      char v8 = (unsigned int *)(v5 + 312);
      long long v25 = v5 + 320;
      long long v26 = v5 + 308;
      do
      {
        if (*v31 <= (unint64_t)(v4 - 1))
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v9 = *(void *)(*v30 + 8 * (v4 - 1));
        uint64_t v10 = re::BindPoint::targetIdentifier((re::BindPoint *)(v9 + 8));
        unint64_t v11 = *(void *)(v9 + 96);
        if (v11 != v10)
        {
          unint64_t v12 = v10;
          if (v11) {
            re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v29, v11);
          }
          if (v12)
          {
            unint64_t v13 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27));
            unint64_t v14 = v13 ^ (v13 >> 31);
            unint64_t v15 = *v29;
            if (!*v29
              || (unint64_t v15 = v14 % *v27, v16 = *(unsigned int *)(*v28 + 4 * v15), v16 == 0x7FFFFFFF))
            {
LABEL_14:
              uint64_t v18 = *v7;
              if (v18 == 0x7FFFFFFF)
              {
                uint64_t v18 = *v8;
                int v19 = v18;
                if (v18 == *v27)
                {
                  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity((uint64_t)v29, 2 * *v26);
                  unint64_t v15 = v14 % *v27;
                  int v19 = *v8;
                }
                unsigned int *v8 = v19 + 1;
                uint64_t v20 = *v6;
                int v21 = *(_DWORD *)(*v6 + 32 * v18 + 8);
              }
              else
              {
                uint64_t v20 = *v6;
                int v21 = *(_DWORD *)(*v6 + 32 * v18 + 8);
                *unint64_t v7 = v21 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
              *(_DWORD *)(*v6 + 32 * v18 + 8) = *(_DWORD *)(*v6 + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(*v28 + 4 * v15);
              *(void *)(*v6 + 32 * v18) = v14;
              *(void *)(*v6 + 32 * v18 + 16) = v12;
              *(void *)(*v6 + 32 * v18 + 24) = v9;
              *(_DWORD *)(*v28 + 4 * v15) = v18;
              ++*v26;
              ++*v25;
            }
            else
            {
              uint64_t v17 = *v6;
              while (*(void *)(v17 + 32 * v16 + 16) != v12)
              {
                uint64_t v16 = *(_DWORD *)(v17 + 32 * v16 + 8) & 0x7FFFFFFF;
                if (v16 == 0x7FFFFFFF) {
                  goto LABEL_14;
                }
              }
            }
          }
          *(void *)(v9 + 96) = v12;
        }
      }
      while (v4-- > 1);
    }
    char v2 = 0;
    uint64_t v1 = 1;
  }
  while ((v24 & 1) != 0);
}

uint64_t re::AnimationManager::isAnimated(re::AnimationManager *this, re::BindNode **a2, const re::IntrospectionBase *a3, const char *a4)
{
  if (v14 && (re::BindPoint::isAlive((re::BindPoint *)&v12) & 1) != 0
        uint64_t v12 = v10,
        re::DynamicArray<re::RigDataValue>::operator=((uint64_t)v13, (uint64_t)v11),
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11),
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11),
        v14)
    && re::BindPoint::isAlive((re::BindPoint *)&v12))
  {
    uint64_t isAnimated = re::AnimationManager::isAnimated(this, (const re::BindPoint *)&v12);
  }
  else
  {
    uint64_t isAnimated = 0;
  }
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  return isAnimated;
}

double anonymous namespace'::findBindPoint(_anonymous_namespace_ *this, re::BindNode **a2, const re::IntrospectionBase *a3, const char *__s, int a5)
{
  if (__s && *__s)
  {
    if (a5)
    {
      uint64_t v10 = __s;
      size_t v11 = strlen(__s);
      return re::BindNode::bindPointWithOverride(a2, (uint64_t)a3, (uint64_t *)&v10, (uint64_t)this);
    }
    else
    {
      uint64_t v10 = __s;
      size_t v11 = strlen(__s);
      return re::BindNode::bindPoint(a2, (uint64_t)a3, (uint64_t *)&v10, (uint64_t)this);
    }
  }
  else
  {
    uint64_t v9 = *re::animationLogObjects(this);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "No bind target found for played animation.", (uint8_t *)&v10, 2u);
    }
    *((void *)this + 5) = 0;
    double result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((_DWORD *)this + 8) = 0;
  }
  return result;
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *a2, re::BindNode **a3, long long *a4, char a5, void *a6)
{
  long long v7 = *a4;
  uint64_t v8 = *((void *)a4 + 2);
  return re::AnimationManager::startAnimation(a1, a2, a3, 0, (unint64_t)&v7, a5, 0, a6);
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *this, re::BindNode **a3, void *a4, unint64_t a5, char a6, re::internal::TimelineTree *a7, void *a8)
{
  uint64_t v168 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 504)) {
    return 0;
  }
  unint64_t v13 = this;
  int v17 = DWORD1(v163);
  if ((_BYTE)v163) {
    BOOL v18 = DWORD1(v163) == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18) {
    goto LABEL_89;
  }
  uint64_t v151 = a3;
  uint64_t v152 = (re::AnimationManager *)a1;
  uint64_t v139 = v13;
  unint64_t v148 = a5;
  char v144 = a6;
  uint64_t v19 = (a6 & 1) == 0;
  uint64_t v20 = a1 + (v19 << 6);
  int v21 = (_DWORD *)(v20 + 124);
  unint64_t v13 = (_anonymous_namespace_ *)*(unsigned __int16 *)(v20 + 124);
  unint64_t v22 = v20 + 72;
  char v24 = (int *)(v20 + 128);
  int v23 = *(_DWORD *)(v20 + 128);
  int v25 = (v23 + 1) >> 24 ? 1 : v23 + 1;
  *char v24 = v25;
  unint64_t v26 = *(unsigned __int16 *)(v20 + 126);
  if (v13 == (_anonymous_namespace_ *)0xFFFF && v26 == 0xFFFF)
  {
    unsigned int v32 = *(_DWORD *)(v20 + 120);
    int v31 = (_DWORD *)(v20 + 120);
    if (v32 >= *(v31 - 1)) {
      re::DataArray<re::internal::TimelineTree>::allocBlock((void *)v22);
    }
    uint64_t v33 = *(void *)(v22 + 16);
    unint64_t v26 = (unsigned __int16)(v33 - 1);
    if (!v33) {
      goto LABEL_238;
    }
    unint64_t v13 = (_anonymous_namespace_ *)*v31;
    if (v13 >= 0x10000) {
      goto LABEL_239;
    }
    int v34 = (void *)(*(void *)(v22 + 32) + 16 * v26);
    *int v31 = v13 + 1;
    *(_DWORD *)(v34[1] + 4 * (void)v13) = *v24;
    uint64_t v30 = *v34 + 216 * v13;
  }
  else
  {
    uint64_t v28 = *(re::AnimationManager **)(v20 + 88);
    if ((unint64_t)v28 <= v26)
    {
LABEL_237:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 789;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v26;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_238:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 789;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v26;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_239:
      re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v13);
      _os_crash();
      __break(1u);
    }
    uint64_t v29 = (void *)(*(void *)(v21 - 5) + 16 * v26);
    *(_DWORD *)(v29[1] + 4 * (void)v13) = v25;
    uint64_t v30 = *v29 + 216 * v13;
    *int v21 = *(_DWORD *)v30;
  }
  ++*(_DWORD *)(a1 + (v19 << 6) + 112);
  *(void *)(v30 + 208) = 0;
  *(_OWORD *)(v30 + 192) = 0u;
  *(_OWORD *)(v30 + 144) = 0u;
  *(_OWORD *)(v30 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0u;
  *(_OWORD *)(v30 + 112) = 0u;
  *(_OWORD *)(v30 + 128) = 0u;
  *(_OWORD *)(v30 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0u;
  *(_OWORD *)(v30 + 96) = 0u;
  *(_OWORD *)(v30 + 48) = 0u;
  *(_OWORD *)(v30 + 64) = 0u;
  *(_OWORD *)(v30 + 16) = 0u;
  *(_OWORD *)(v30 + 32) = 0u;
  *(_OWORD *)uint64_t v30 = 0u;
  *(_OWORD *)(v30 + 176) = 0u;
  objc_initWeak((id *)(v30 + 176), 0);
  *(_WORD *)(v30 + 184) = 767;
  *(_DWORD *)(v30 + 188) = 1065353216;
  *(void *)(v30 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = 0;
  *(void *)(v30 + 208) = 0;
  *(void *)(v30 + 192) = 0;
  unint64_t v35 = (v26 << 16) | ((unint64_t)(*v24 & 0xFFFFFF) << 32);
  unint64_t v36 = v35 | (unint64_t)v13;
  unint64_t v37 = (_anonymous_namespace_ *)re::DataArray<re::internal::TimelineTree>::get(v22, v35 | v13);
  re::internal::TimelineTree::init((uint64_t)v37, v17, v19, *(CMTimebaseRef *)(a1 + 64), a7, a8, *(unsigned __int8 *)(a1 + 506));
  unint64_t v13 = v139;
  unint64_t v38 = v36 | (v19 << 56);
  unint64_t v39 = v148;
  if (!v38)
  {
LABEL_89:
    uint64_t v81 = *re::animationLogObjects(v15);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      uint64_t v97 = *((void *)v13 + 4);
      LODWORD(v163) = 136315138;
      *(void *)((char *)&v163 + 4) = v97;
      _os_log_error_impl(&dword_233120000, v81, OS_LOG_TYPE_ERROR, "Potentially invalid timeline detected. Name of root timeline: %s", (uint8_t *)&v163, 0xCu);
    }
    return 0;
  }
  uint64_t v40 = re::DataArray<re::internal::TimelineTree>::get(v22, v38);
  re::AnimationManager::updateLookupTableForAllBuckets((re::AnimationManager *)a1);
  uint64_t v28 = *(re::AnimationManager **)(v40 + 32);
  if ((int)v28 < 1)
  {
LABEL_111:
    uint64_t v90 = *(void *)(v40 + 152);
    if (v90)
    {
      unint64_t v91 = *(void **)(v40 + 160);
      uint64_t v92 = 8 * v90;
      while (!*v91)
      {
        ++v91;
        v92 -= 8;
        if (!v92) {
          goto LABEL_115;
        }
      }
    }
    else
    {
LABEL_115:
      unint64_t v93 = *re::animationLogObjects((re *)v41);
      uint64_t v41 = os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT);
      if (v41)
      {
        if (*((unsigned char *)v13 + 48)) {
          unsigned int v94 = (char *)*((void *)v13 + 7);
        }
        else {
          unsigned int v94 = (char *)v13 + 49;
        }
        LODWORD(v163) = 136315138;
        *(void *)((char *)&v163 + 4) = v94;
        _os_log_impl(&dword_233120000, v93, OS_LOG_TYPE_DEFAULT, "Failed to assign animation to target variables. Please check the bind node/point. Make sure the animation type matches the target variable. Failing bind path is: '%s'.", (uint8_t *)&v163, 0xCu);
      }
    }
    uint64_t v28 = (re::AnimationManager *)*(unsigned int *)(v39 + 12);
    LOBYTE(v151) = v28 != 0x80000000;
    float v95 = *(float *)(v39 + 4);
    int v96 = *(_DWORD *)v39;
    switch(*(_DWORD *)v39)
    {
      case 0:
        unint64_t v98 = *(void *)(v40 + 152);
        if (v98)
        {
          for (unint64_t i = 0; i < v98; ++i)
          {
            uint64_t v41 = *(void *)(*(void *)(v40 + 160) + 8 * i);
            if (v41)
            {
              uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 48))(v41);
              unint64_t v98 = *(void *)(v40 + 152);
            }
          }
        }
        unint64_t v22 = 0;
        char v150 = 0;
        char v145 = 1;
        char v147 = 0;
        int v154 = 2;
        goto LABEL_134;
      case 1:
        char v147 = 0;
        char v150 = 0;
        int v154 = 1;
        unint64_t v22 = 4;
        goto LABEL_133;
      case 2:
      case 4:
      case 5:
        char v147 = 0;
        char v150 = 0;
        if (v96 == 4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = 2 * (v96 == 5);
        }
        int v154 = *(unsigned __int8 *)(v39 + 8);
LABEL_133:
        char v145 = 1;
        goto LABEL_134;
      case 3:
        if (v95 <= 0.0) {
          goto LABEL_183;
        }
        unint64_t v22 = 0;
        char v143 = 0;
        int v154 = 1;
        char v145 = 0;
        char v147 = 1;
        char v150 = 1;
        break;
      default:
        unint64_t v22 = 0;
        int v154 = 0;
        char v150 = 0;
        char v145 = 0;
        char v147 = 1;
LABEL_134:
        char v143 = 1;
        break;
    }
    if ((int)*(void *)(v40 + 32) >= 1)
    {
      unint64_t v44 = 0;
      uint64_t v100 = *(void *)(v40 + 32);
      unint64_t v26 = 0x80000000;
      while (1)
      {
        CompositionChaiunint64_t n = *(unint64_t **)(v40 + 152);
        if ((unint64_t)CompositionChain <= v44) {
          break;
        }
        unint64_t v13 = *(_anonymous_namespace_ **)(*(void *)(v40 + 160) + 8 * v44);
        if (v13)
        {
          unint64_t v39 = (unint64_t)v28;
          if (v28 == 0x80000000)
          {
            CompositionChaiunint64_t n = *(unint64_t **)(v40 + 128);
            if ((unint64_t)CompositionChain <= v44) {
              goto LABEL_234;
            }
            unint64_t v39 = *(unsigned int *)(*(void *)(*(void *)(v40 + 136) + 8 * v44) + 12);
          }
          unint64_t v101 = *((void *)v13 + 9);
          if (v101)
          {
            unint64_t v102 = 0;
            BOOL v103 = (int *)(*((void *)v13 + 11) + 16);
            while (1)
            {
              int v104 = *v103;
              v103 += 6;
              if (v104 > (int)v39) {
                break;
              }
              if (v101 == ++v102)
              {
                unint64_t v102 = *((void *)v13 + 9);
                break;
              }
            }
          }
          else
          {
            unint64_t v102 = 0;
          }
          CompositionChaiunint64_t n = (unint64_t *)(v101 + 1);
          if (v101 + 1 <= v102) {
            goto LABEL_230;
          }
          unint64_t v105 = *((void *)v13 + 8);
          if (v101 >= v105)
          {
            if (v105 < (unint64_t)CompositionChain)
            {
              if (*((void *)v13 + 7))
              {
                unint64_t v106 = 2 * v105;
                if (!v105) {
                  unint64_t v106 = 8;
                }
                if (v106 <= (unint64_t)CompositionChain) {
                  unint64_t v107 = (unint64_t)CompositionChain;
                }
                else {
                  unint64_t v107 = v106;
                }
                uint64_t v41 = (uint64_t)re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)v13 + 7, v107);
              }
              else
              {
                uint64_t v41 = (uint64_t)re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)v13 + 7, (unint64_t)CompositionChain);
                ++*((_DWORD *)v13 + 20);
              }
              unint64_t v26 = 0x80000000;
            }
            unint64_t v101 = *((void *)v13 + 9);
          }
          uint64_t v108 = *((void *)v13 + 11);
          uint64_t v109 = (__n128 *)(v108 + 24 * v101);
          if (v101 > v102)
          {
            uint64_t v110 = v108 + 24 * v101;
            __n128 v42 = *(__n128 *)(v110 - 24);
            *uint64_t v109 = v42;
            v109[1].n128_u64[0] = *(void *)(v110 - 8);
            uint64_t v111 = *((void *)v13 + 11);
            uint64_t v112 = v111 + 24 * v102;
            uint64_t v113 = v111 + 24 * *((void *)v13 + 9);
            if (v113 - 24 != v112)
            {
              uint64_t v41 = (uint64_t)memmove((void *)(v112 + 24), (const void *)v112, v113 - 24 - v112 - 3);
              uint64_t v111 = *((void *)v13 + 11);
            }
            uint64_t v109 = (__n128 *)(v111 + 24 * v102);
          }
          v109->n128_u64[0] = v40;
          v109->n128_u32[2] = v44;
          v109[1].n128_u32[0] = v39;
          v109[1].n128_u8[4] = v22;
          ++*((void *)v13 + 9);
          ++*((_DWORD *)v13 + 20);
        }
        if (++v44 == v100) {
          goto LABEL_167;
        }
      }
LABEL_228:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v44;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_229:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      unint64_t v102 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v39;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_230:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "insert";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 855;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v102;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_231:
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = v26;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_232:
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_233:
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v160 = 136315906;
      *(void *)&v160[4] = "operator[]";
      *(_WORD *)&v160[12] = 1024;
      *(_DWORD *)&v160[14] = 476;
      *(_WORD *)&v160[18] = 2048;
      *(void *)&v160[20] = v22;
      *(_WORD *)&v160[28] = 2048;
      *(void *)&v160[30] = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_234:
      *(void *)unint64_t v160 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v44;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_235:
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_236:
      re::internal::assertLog((re::internal *)4, v57, "assertion failure: '%s' (%s:line %i) ", "bindPointTargetIdentifier", "addToLookupTable", 930);
      _os_crash();
      __break(1u);
      goto LABEL_237;
    }
LABEL_167:
    if (v95 <= 0.0)
    {
      unint64_t v114 = v148;
      int v116 = v154;
    }
    else
    {
      unint64_t v114 = v148;
      LODWORD(v163) = *(_DWORD *)v148;
      BYTE4(v163) = v145;
      if ((v147 & 1) == 0) {
        DWORD2(v163) = 0;
      }
      BYTE12(v163) = v150;
      if ((v143 & 1) == 0) {
        LODWORD(v164) = 0;
      }
      DWORD1(v164) = *(_DWORD *)(v148 + 4);
      float v115 = (re::internal::AnimationHandoffBehavior *)re::AnimationManager::addFadeOutHandoffBehavior(v152, v40, &v163);
      if (v154 != 1)
      {
        if (v154 != 2)
        {
LABEL_195:
          uint64_t v28 = v152;
LABEL_203:
          uint64_t v120 = *(void *)(v40 + 152);
          if (v120)
          {
            float v121 = *(void **)(v40 + 160);
            uint64_t v122 = 8 * v120;
            do
            {
              if (*v121) {
                (*(void (**)(void, __n128))(*(void *)*v121 + 56))(*v121, v42);
              }
              ++v121;
              v122 -= 8;
            }
            while (v122);
          }
          re::AnimationManager::updateScheduler(v28);
          unint64_t v123 = *(void *)(v40 + 32);
          if (!v123) {
            return v28;
          }
          unint64_t v39 = 0;
          unint64_t v26 = 72;
          unint64_t v44 = 1;
          while (1)
          {
            CompositionChaiunint64_t n = *(unint64_t **)(v40 + 128);
            if ((unint64_t)CompositionChain <= v39) {
              goto LABEL_229;
            }
            CompositionChaiunint64_t n = *(unint64_t **)(*(void *)(v40 + 136) + 8 * v39);
            if (*((_DWORD *)CompositionChain + 2) == 49)
            {
              LOWORD(buf[0]) = 255;
              BYTE2(buf[0]) = 0;
              LODWORD(buf[1]) = 0;
              HIDWORD(buf[0]) = 0;
              memset(&buf[2], 0, 41);
              uint64_t v124 = re::TypedEventTimelineInstance<float>::compositionChain((uint64_t)CompositionChain);
              if (v124)
              {
                buf[5] = v124 + 8;
                *(unsigned char *)(v124 + 104) = 1;
              }
              WeakRetained = (char *)objc_loadWeakRetained((id *)(CompositionChain[16] + 176));
              float v126 = (void *)CompositionChain[16];
              unint64_t v22 = CompositionChain[18];
              unint64_t v13 = (_anonymous_namespace_ *)v126[7];
              if ((unint64_t)v13 <= v22) {
                goto LABEL_233;
              }
              uint64_t v127 = v126[21];
              if (WeakRetained) {
                uint64_t v128 = WeakRetained - 8;
              }
              else {
                uint64_t v128 = 0;
              }
              uint64_t v129 = v126[8];
              uint64_t v130 = v129 + 72 * v22;
              unint64_t v22 = (unint64_t)(v128 + 8);
              (*(void (**)(char *, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, unint64_t *, void *, double, void *, int))(*(void *)v128 + 40))(v128, 12, v127, v130, CompositionChain[17], -1, CompositionChain, buf, *(double *)(v129 + 8), v132, v133);

              unint64_t v123 = *(void *)(v40 + 32);
            }
            if (v123 <= ++v39) {
              return v28;
            }
          }
        }
LABEL_196:
        if (*(unsigned char *)(v114 + 8))
        {
          char v117 = 1;
LABEL_198:
          v158[0] = (char)v151;
          if (v28 != 0x80000000) {
            int v159 = (int)v28;
          }
          uint64_t v28 = v152;
          v42.n128_f64[0] = re::AnimationManager::removeLayerExcept(v152, (void *)v40, v158, 0);
          if ((v117 & 1) == 0) {
            goto LABEL_201;
          }
        }
        else
        {
          uint64_t v28 = v152;
          v42.n128_f64[0] = re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, 0);
        }
        goto LABEL_203;
      }
      if (*(unsigned char *)(v148 + 8))
      {
        LOBYTE(v155) = v28 != 0x80000000;
        if (v28 != 0x80000000) {
          HIDWORD(v155) = v28;
        }
        v42.n128_f64[0] = re::AnimationManager::removeLayerExcept(v152, (void *)v40, &v155, (uint64_t)v115);
      }
      else
      {
        v42.n128_f64[0] = re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, v115);
      }
      int v116 = 1;
    }
    BOOL v119 = v95 > 0.0 || v116 != 1;
    if (v116 != 2 && v119) {
      goto LABEL_195;
    }
    goto LABEL_196;
  }
  unint64_t v26 = 0;
  int v43 = 0;
  unint64_t v146 = (void *)(a1 + 48 * *(char *)(v40 + 184) + 280);
  uint64_t v134 = (_anonymous_namespace_ *)(a1 + 40 * *(char *)(v40 + 184) + 376);
  unint64_t v39 = (unint64_t)&v160[8];
  unint64_t v44 = (unint64_t)&v163 + 8;
  uint64_t v45 = a1 + 48 * *(char *)(v40 + 184);
  unint64_t v137 = (unsigned int *)(v45 + 304);
  unint64_t v136 = (void *)(v45 + 288);
  unint64_t v135 = (uint64_t *)(v45 + 296);
  uint64_t v138 = (_DWORD *)(v45 + 320);
  uint64_t v46 = a1 + 40 * *(char *)(v40 + 184);
  uint64_t v149 = (unint64_t *)(v46 + 392);
  v141 = (unint64_t *)(v46 + 384);
  unint64_t v142 = (_DWORD *)(v46 + 400);
  unint64_t v140 = (void *)(v46 + 408);
  unint64_t v22 = 1;
  while (1)
  {
    unint64_t v13 = (_anonymous_namespace_ *)v43;
    unint64_t v47 = *(void *)(v40 + 128);
    if (v47 <= v43)
    {
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      CompositionChaiunint64_t n = (unint64_t *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 476;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = v47;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_227:
      uint64_t v155 = 0;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v163 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(void *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(void *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(void *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_228;
    }
    int v48 = v43;
    uint64_t v49 = *(void *)(*(void *)(v40 + 136) + 8 * v43);
    uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 16))(v49);
    if (!v50)
    {
LABEL_27:
      uint64_t v161 = 0;
      memset(v160, 0, 36);
      goto LABEL_28;
    }
    uint64_t v51 = (const re::IntrospectionBase *)v50;
    if (!a4)
    {
      *((void *)&v165 + 1) = 0;
      long long v163 = 0u;
      long long v164 = 0u;
      LODWORD(v165) = 0;
      unint64_t v64 = v156 >> 1;
      if ((v156 & 1) == 0) {
        unint64_t v64 = v156 >> 1;
      }
      if (v64)
      {
        unint64_t v65 = (v156 & 1) != 0 ? v157 : (char *)&v156 + 1;
        *(void *)&long long v163 = buf[0];
        re::DynamicArray<re::RigDataValue>::operator=((uint64_t)&v163 + 8, (uint64_t)&buf[1]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[1]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[1]);
        Alive = (re *)re::BindPoint::makeAlive((uint64_t)&v163);
        if (*((void *)&v164 + 1))
        {
          if ((const re::IntrospectionBase *)v163 == v51)
          {
            *(void *)unint64_t v160 = v51;
            *(void *)&v160[8] = *((void *)&v163 + 1);
            *(_OWORD *)&v160[16] = v164;
            *((void *)&v163 + 1) = 0;
            long long v164 = 0uLL;
            uint64_t v161 = *((void *)&v165 + 1);
            *((void *)&v165 + 1) = 0;
            LODWORD(v165) = v165 + 1;
            *(_DWORD *)&v160[32] = 1;
            goto LABEL_50;
          }
          unint64_t v67 = *re::animationLogObjects(Alive);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            unint64_t v80 = (char *)&v156 + 1;
            if (v156) {
              unint64_t v80 = v157;
            }
            LODWORD(buf[0]) = 136315138;
            *(void *)((char *)buf + 4) = v80;
            _os_log_error_impl(&dword_233120000, v67, OS_LOG_TYPE_ERROR, "Failed to create bind point. Type mismatch for path: %s", (uint8_t *)buf, 0xCu);
          }
        }
      }
      uint64_t v161 = 0;
      memset(v160, 0, 36);
LABEL_50:
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v163 + 8);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v163 + 8);
      if (v155 && (v156 & 1) != 0) {
        (*(void (**)(void))(*(void *)v155 + 40))();
      }
      goto LABEL_28;
    }
    if (*a4 != v50) {
      goto LABEL_27;
    }
    *(void *)unint64_t v160 = v50;
    re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)&v160[8], a4 + 1);
LABEL_28:
    CompositionChaiunint64_t n = *(unint64_t **)(v40 + 128);
    if (CompositionChain <= (unint64_t *)v13) {
      goto LABEL_227;
    }
    uint64_t v53 = *(void *)(*(void *)(v40 + 136) + 8 * (void)v13);
    if ((*(unsigned int (**)(uint64_t, unsigned char *))(*(void *)v53 + 64))(v53, v160)) {
      break;
    }
    int v43 = v13 + 1;
LABEL_84:
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v160[8]);
    uint64_t v41 = re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v160[8]);
    if (v43 >= (int)v28)
    {
      unint64_t v13 = v139;
      unint64_t v39 = v148;
      if ((v26 & 1) == 0)
      {
        *((void *)&v163 + 1) = 0;
        long long v164 = 0uLL;
        re::DynamicString::setCapacity(&v163, 0);
        uint64_t v83 = 0;
        unint64_t v22 = (unint64_t)", ";
        do
        {
          unint64_t v39 = v39 & 0xFFFFFFFF00000000 | v83;
          if (v83) {
            re::DynamicString::append((re::DynamicString *)&v163, ", ", 2uLL);
          }
          re::DynamicString::append((re::DynamicString *)&v163, "\"", 1uLL);
          char v85 = buf[1];
          uint64_t v84 = buf[2];
          if (buf[1]) {
            uint64_t v86 = (const char *)buf[2];
          }
          else {
            uint64_t v86 = (char *)&buf[1] + 1;
          }
          if (buf[1]) {
            size_t v87 = buf[1] >> 1;
          }
          else {
            size_t v87 = LOBYTE(buf[1]) >> 1;
          }
          re::DynamicString::append((re::DynamicString *)&v163, v86, v87);
          unint64_t v88 = (re *)re::DynamicString::append((re::DynamicString *)&v163, "\"", 1uLL);
          if (v85)
          {
            unint64_t v88 = (re *)buf[0];
            if (buf[0]) {
              unint64_t v88 = (re *)(*(uint64_t (**)(void, uint64_t))(*(void *)buf[0] + 40))(buf[0], v84);
            }
          }
          ++v83;
        }
        while (v28 != v83);
        uint64_t v89 = *re::animationLogObjects(v88);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
        {
          if (BYTE8(v163)) {
            uint64_t v131 = (char *)v164;
          }
          else {
            uint64_t v131 = (char *)&v163 + 9;
          }
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = v131;
          _os_log_error_impl(&dword_233120000, v89, OS_LOG_TYPE_ERROR, "Cannot find a BindPoint for any bind path: %s", (uint8_t *)buf, 0xCu);
        }
        uint64_t v41 = v163;
        unint64_t v39 = v148;
        if (void)v163 && (BYTE8(v163)) {
          uint64_t v41 = (*(uint64_t (**)(void))(*(void *)v163 + 40))();
        }
      }
      goto LABEL_111;
    }
  }
  CompositionChaiunint64_t n = (unint64_t *)re::AnimationManager::getCompositionChain(v152, (const re::BindPoint *)v160);
  if (CompositionChain) {
    goto LABEL_69;
  }
  CompositionChaiunint64_t n = *(unint64_t **)(v40 + 128);
  if (CompositionChain <= (unint64_t *)v13) {
    goto LABEL_235;
  }
  uint64_t v54 = *(void *)(*(void *)(v40 + 136) + 8 * (void)v13);
  (*(void (**)(unint64_t *, unsigned char *))(*CompositionChain + 16))(CompositionChain, v160);
  uint64_t v55 = (uint64_t)v146;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v146, CompositionChain[12]);
  unint64_t v56 = re::BindPoint::targetIdentifier((re::BindPoint *)(CompositionChain + 1));
  *(void *)&long long v163 = v56;
  if (!v56) {
    goto LABEL_236;
  }
  unint64_t v58 = v56;
  buf[0] = CompositionChain;
  unint64_t v59 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v56 ^ (v56 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v56 ^ (v56 >> 30))) >> 27));
  unint64_t v60 = v59 ^ (v59 >> 31);
  if (!*v146)
  {
    LODWORD(v61) = 0;
    goto LABEL_55;
  }
  unint64_t v61 = v60 % *v137;
  uint64_t v62 = *(unsigned int *)(*v136 + 4 * v61);
  if (v62 == 0x7FFFFFFF)
  {
LABEL_55:
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(v55, v61, v60, &v163, buf);
    ++*v138;
    goto LABEL_56;
  }
  uint64_t v63 = *v135;
  while (*(void *)(v63 + 32 * v62 + 16) != v56)
  {
    uint64_t v62 = *(_DWORD *)(v63 + 32 * v62 + 8) & 0x7FFFFFFF;
    if (v62 == 0x7FFFFFFF)
    {
      uint64_t v55 = (uint64_t)v146;
      goto LABEL_55;
    }
  }
LABEL_56:
  CompositionChain[12] = v58;
  unint64_t v68 = v149;
  unint64_t v69 = *v149;
  unint64_t v70 = *v141;
  if (*v149 >= *v141)
  {
    unint64_t v71 = v69 + 1;
    if (v70 < v69 + 1)
    {
      if (*(void *)v134)
      {
        uint64_t v72 = 2 * v70;
        BOOL v18 = v70 == 0;
        unint64_t v73 = 8;
        if (!v18) {
          unint64_t v73 = v72;
        }
        if (v73 <= v71) {
          unint64_t v74 = v71;
        }
        else {
          unint64_t v74 = v73;
        }
        re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v134, v74);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v134, v71);
        ++*v142;
      }
    }
    unint64_t v68 = v149;
    unint64_t v69 = *v149;
  }
  *(void *)(*v140 + 8 * v69) = CompositionChain;
  *unint64_t v68 = v69 + 1;
  ++*v142;
LABEL_69:
  unint64_t v26 = *(void *)(v40 + 152);
  if (v26 <= (unint64_t)v13) {
    goto LABEL_231;
  }
  *(void *)(*(void *)(v40 + 160) + 8 * (void)v13) = CompositionChain;
  CompositionChaiunint64_t n = *(unint64_t **)(v40 + 128);
  if (CompositionChain <= (unint64_t *)v13) {
    goto LABEL_232;
  }
  if ((_BYTE)v163) {
    int v75 = DWORD1(v163);
  }
  else {
    int v75 = 0;
  }
  int v43 = v75 + v13;
  if (v75 < 1)
  {
LABEL_83:
    unint64_t v26 = 1;
    goto LABEL_84;
  }
  unint64_t v77 = *(void *)(v40 + 128);
  uint64_t v76 = *(void *)(v40 + 136);
  if (v77 <= (unint64_t)v13) {
    unint64_t v78 = v13;
  }
  else {
    unint64_t v78 = *(_anonymous_namespace_ **)(v40 + 128);
  }
  while (v78 != v13)
  {
    uint64_t v79 = *(void *)(v76 + 8 * (void)v13);
    if (*(_DWORD *)(v79 + 8) == 49 && *(unsigned __int8 *)(*(void *)(*(void *)(v79 + 136) + 80) + 496) != 255) {
      *(unsigned char *)(v79 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 1;
    }
    unint64_t v13 = (_anonymous_namespace_ *)((char *)v13 + 1);
    if ((uint64_t)v13 >= v43) {
      goto LABEL_83;
    }
  }
  uint64_t v155 = 0;
  long long v166 = 0u;
  long long v167 = 0u;
  long long v164 = 0u;
  long long v165 = 0u;
  long long v163 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  LODWORD(buf[0]) = 136315906;
  *(void *)((char *)buf + 4) = "operator[]";
  WORD2(buf[1]) = 1024;
  *(_DWORD *)((char *)&buf[1] + 6) = 468;
  WORD1(buf[2]) = 2048;
  *(void *)((char *)&buf[2] + 4) = v78;
  WORD2(buf[3]) = 2048;
  *(void *)((char *)&buf[3] + 6) = v77;
  int v133 = 38;
  uint64_t v132 = buf;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_183:
  if (*(unsigned char *)(v39 + 8))
  {
    char v117 = 0;
    goto LABEL_198;
  }
  uint64_t v28 = v152;
  re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, 0);
LABEL_201:
  re::AnimationManager::destroyTimelineTree(v28, (re::internal::TimelineTree *)v40);
  return 0;
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *a2, void *a3, long long *a4, char a5, re::internal::TimelineTree *a6, void *a7)
{
  long long v8 = *a4;
  uint64_t v9 = *((void *)a4 + 2);
  return re::AnimationManager::startAnimation(a1, a2, 0, a3, (unint64_t)&v8, a5, a6, a7);
}

uint64_t re::DataArray<re::internal::TimelineTree>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 216 * (unsigned __int16)a2;
}

void re::AnimationManager::destroyTimelineTree(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  if (*((void *)a2 + 16))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*((void *)a2 + 17) + 8 * v4);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 80))(v5))
      {
        if (*((void *)a2 + 16) <= v4)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_12:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        unint64_t v6 = *(uint64_t (****)(void))(*((void *)a2 + 17) + 8 * v4);
        long long v7 = (_anonymous_namespace_ *)(**v6)(v6);
        if (*((void *)a2 + 16) <= v4) {
          goto LABEL_12;
        }
      }
      ++v4;
    }
    while (v4 < *((void *)a2 + 16));
  }
  long long v8 = (char *)this + 64 * (uint64_t)*((char *)a2 + 184) + 72;
  unint64_t v9 = re::DataArray<re::internal::TimelineTree>::handle((uint64_t)v8, (uint64_t)a2);
  re::DataArray<re::internal::TimelineTree>::destroy((uint64_t)v8, v9);
}

double re::AnimationManager::updateScheduler(re::AnimationManager *this)
{
  uint64_t v2 = 0;
  int v3 = *((unsigned __int8 *)this + 56);
  do
  {
    int v4 = *(_DWORD *)((char *)this + v2 + 112);
    if (v4) {
      break;
    }
    BOOL v7 = v2 == 64;
    v2 += 64;
  }
  while (!v7);
  int v5 = v4 != 0;
  *((unsigned char *)this + 56) = v5;
  uint64_t v6 = *((void *)this + 5);
  BOOL v7 = v3 == v5 || v6 == 0;
  if (!v7) {
    (*(void (**)(uint64_t, BOOL, void))(*(void *)v6 + 16))(v6, v4 != 0, *((void *)this + 6));
  }
  unint64_t v9 = *((void *)this + 4);
  if (v9 != -1)
  {
    int Bit = re::DynamicBitset<unsigned long long,256ul>::getBit(*((void *)this + 1) + 128, v9);
    int v11 = *((unsigned __int8 *)this + 56);
    if (v11 != Bit)
    {
      re::Scheduler::setEnabled(*((re::Scheduler **)this + 1), *((void *)this + 4), v11 != 0);
      if (*((unsigned char *)this + 56))
      {
        uint64_t v12 = (re::Scheduler *)*((void *)this + 1);
        unint64_t v13 = *((void *)this + 4);
        return re::Scheduler::resetTaskCurrentTime(v12, v13);
      }
    }
  }
  return result;
}

void re::AnimationManager::stopAnimation(re::AnimationManager *this, const re::BindNode *a2)
{
}

uint64_t re::AnimationManager::stopAnimation(re::AnimationManager *this, const re::BindPoint *a2)
{
  return re::AnimationManager::removeCompositionChainsForBindPoint(this, a2, 1);
}

uint64_t re::AnimationManager::removeCompositionChainsForBindPoint(re::AnimationManager *this, const re::BindPoint *a2, BOOL a3)
{
  uint64_t v8 = *(void *)a2;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v9, (uint64_t *)a2 + 1);
  for (uint64_t i = re::AnimationManager::getCompositionChain(this, (const re::BindPoint *)&v8);
        i;
        uint64_t i = re::AnimationManager::getCompositionChain(this, (const re::BindPoint *)&v8))
  {
    uint64_t v6 = *(void *)(i + 72);
    if (!v6) {
      break;
    }
    re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(*(void *)(i + 88) + 24 * v6 - 24), a3);
  }
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v9);
  return re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v9);
}

void re::AnimationManager::stopAllAnimations(re::AnimationManager *this)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    int v5 = (char *)this + 40 * v2;
    uint64_t v6 = *((void *)v5 + 49);
    if (v6)
    {
      BOOL v7 = (uint64_t *)(v5 + 392);
      uint64_t v8 = (void *)((char *)this + 40 * v2 + 408);
      do
      {
        re::AnimationManager::removeCompositionChainsForBindPoint(this, (const re::BindPoint *)(*(void *)(*v8 + 8 * v6 - 8) + 8), 0);
        uint64_t v6 = *v7;
      }
      while (*v7);
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  re::AnimationManager::raiseAnimationEvents(this);
}

void re::AnimationManager::raiseAnimationEvents(re::AnimationManager *this)
{
  uint64_t v2 = *((unsigned int *)this + 122);
  if (v2)
  {
    uint64_t v3 = 0;
    char v4 = (int *)(*((void *)this + 59) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 122);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      uint64_t v7 = *(void *)(*((void *)this + 59) + 24 * v6 + 16);
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
      if (*((_DWORD *)this + 122) <= (v3 + 1)) {
        int v8 = v3 + 1;
      }
      else {
        int v8 = *((_DWORD *)this + 122);
      }
      int v9 = v3;
      while (1)
      {
        uint64_t v6 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)this + 59) + 24 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v2 != v3);
  }
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear((uint64_t)this + 456);
}

const re::Timeline *anonymous namespace'::setTimelines(_anonymous_namespace_ *this, re::internal::TimelineTree *a2, const re::Timeline *a3, unint64_t a4, const re::BindNode *a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unint64_t v7 = (int)a3;
  unint64_t v8 = *((void *)this + 1);
  if (v8 <= (int)a3)
  {
    *(void *)&v21[0] = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v23 = 136315906;
    char v24 = "operator[]";
    __int16 v25 = 1024;
    int v26 = 468;
    __int16 v27 = 2048;
    unint64_t v28 = v7;
    __int16 v29 = 2048;
    unint64_t v30 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  unint64_t v5 = a4;
  *(_DWORD *)(*((void *)this + 2) + 4 * (int)a3) = a5;
  (*(void (**)(_OWORD *__return_ptr, re::internal::TimelineTree *))(*(void *)a2 + 48))(v21, a2);
  unint64_t v8 = *((void *)this + 4);
  if (v8 <= v7)
  {
LABEL_9:
    uint64_t v22 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v23 = 136315906;
    char v24 = "operator[]";
    __int16 v25 = 1024;
    int v26 = 468;
    __int16 v27 = 2048;
    unint64_t v28 = v7;
    __int16 v29 = 2048;
    unint64_t v30 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  int v11 = (_OWORD *)(*((void *)this + 5) + 28 * (int)v7);
  long long v12 = v21[0];
  *(_OWORD *)((char *)v11 + 10) = *(_OWORD *)((char *)v21 + 10);
  *int v11 = v12;
  unint64_t v13 = (const re::Timeline *)(a3 + 1);
  uint64_t v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(re::internal::TimelineTree *))(*(void *)a2 + 24))(a2);
  if (v14)
  {
    unint64_t v15 = v14;
    for (uint64_t i = 0; i != v15; uint64_t i = (_anonymous_namespace_ *)((char *)i + 1))
    {
      int v17 = (re::internal::TimelineTree *)(*(uint64_t (**)(re::internal::TimelineTree *, _anonymous_namespace_ *))(*(void *)a2 + 32))(a2, i);
      unint64_t v13 = v14;
    }
  }
  unint64_t v5 = *((void *)this + 16);
  if (v5 <= v7)
  {
LABEL_10:
    *(void *)&v21[0] = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v23 = 136315906;
    char v24 = "operator[]";
    __int16 v25 = 1024;
    int v26 = 468;
    __int16 v27 = 2048;
    unint64_t v28 = v7;
    __int16 v29 = 2048;
    unint64_t v30 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(*((void *)this + 17) + 8 * v7) = v19;
  return v13;
}

void re::DataArray<re::internal::TimelineTree>::destroy(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    re::internal::TimelineTree::~TimelineTree(v5);
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

unint64_t re::DataArray<re::internal::TimelineTree>::handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    int v3 = 0;
    uint64_t v4 = 0;
    unint64_t v5 = (void *)(*(void *)(a1 + 32) + 8);
    while (v4 != 0x10000)
    {
      uint64_t v6 = a2 - *(v5 - 1);
      if (v6 >= -215)
      {
        unint64_t v7 = 0x84BDA12F684BDA13 * (v6 >> 3);
        if (v7 < *(unsigned int *)(a1 + 44)) {
          goto LABEL_8;
        }
      }
      ++v4;
      v5 += 2;
      v3 += 0x10000;
      if (v2 == v4) {
        goto LABEL_7;
      }
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
    _os_crash();
    __break(1u);
LABEL_8:
    if (v7 < 0x10000) {
      return v3 & 0xFFFF0000 | ((unint64_t)(*(_DWORD *)(*v5 + 4 * v7) & 0xFFFFFF) << 32) | v7;
    }
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v7);
  unint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AnimationManager::getCompositionChain(re::AnimationManager *this, const re::BindPoint *a2)
{
  re::AnimationManager::updateLookupTableForAllBuckets(this);
  unint64_t v4 = re::BindPoint::targetIdentifier(a2);
  uint64_t v5 = 0;
  unint64_t v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  unint64_t v7 = v6 ^ (v6 >> 31);
  for (char i = 1; ; char i = 0)
  {
    char v9 = i;
    if (*((void *)this + 6 * v5 + 35))
    {
      uint64_t v10 = *(unsigned int *)(*((void *)this + 6 * v5 + 36) + 4 * (v7 % *((unsigned int *)this + 12 * v5 + 76)));
      if (v10 != 0x7FFFFFFF) {
        break;
      }
    }
LABEL_7:
    uint64_t v5 = 1;
    if ((v9 & 1) == 0) {
      return 0;
    }
  }
  uint64_t v11 = *((void *)this + 6 * v5 + 37);
  while (*(void *)(v11 + 32 * v10 + 16) != v4)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_7;
    }
  }
  return *(void *)(v11 + 32 * v10 + 24);
}

void *anonymous namespace'::getBindPath(_anonymous_namespace_ *a1, void *a2, int a3)
{
  LODWORD(v3) = a3;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  unint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(a1, 0);
  unint64_t result = re::DynamicString::setCapacity(a1, 0x80uLL);
  if ((v3 & 0x80000000) == 0)
  {
    unint64_t v3 = v3;
    while (a2[16] > v3)
    {
      uint64_t v8 = *(void *)(a2[17] + 8 * v3);
      unint64_t v9 = *(void *)(v8 + 48);
      uint64_t v10 = v9 & 1;
      size_t v11 = v9 >> 1;
      size_t v12 = v9 >> 1;
      if (*(void *)(v8 + 48)) {
        size_t v13 = v11;
      }
      else {
        size_t v13 = v12;
      }
      if (v13)
      {
        unint64_t v14 = *((void *)a1 + 1);
        if (v14) {
          unint64_t v15 = v14 >> 1;
        }
        else {
          unint64_t v15 = v14 >> 1;
        }
        if (v15)
        {
          re::DynamicString::insert(a1, 0, 1, 46);
          unint64_t v16 = *(void *)(v8 + 48);
          uint64_t v10 = v16 & 1;
          size_t v11 = v16 >> 1;
          size_t v12 = v16 >> 1;
        }
        if (v10) {
          int v17 = *(const char **)(v8 + 56);
        }
        else {
          int v17 = (const char *)(v8 + 49);
        }
        if (v10) {
          size_t v18 = v11;
        }
        else {
          size_t v18 = v12;
        }
        unint64_t result = (void *)re::DynamicString::insert(a1, 0, v17, v18);
      }
      if (a2[1] <= v3) {
        goto LABEL_24;
      }
      unint64_t v3 = *(unsigned int *)(a2[2] + 4 * v3);
      if ((v3 & 0x80000000) != 0) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::DataArray<re::internal::TimelineTree>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 216 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::AnimationManager::addFadeOutHandoffBehavior(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = re::internal::AnimationHandoffBehavior::AnimationHandoffBehavior(v6, a1, a2, a3);
  re::DynamicArray<re::internal::AnimationHandoffBehavior *>::add((void *)a1 + 5 * *(char *)(a2 + 184) + 25, &v8);
  return v8;
}

double re::AnimationManager::removeLayerExcept(re::AnimationManager *a1, void *a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t v46 = *MEMORY[0x263EF8340];
  unsigned int v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v31 = 0x7FFFFFFFLL;
  unint64_t v5 = a2[19];
  if (!v5)
  {
    unsigned int v17 = 0;
    LODWORD(v18) = 0;
    goto LABEL_25;
  }
  unint64_t v8 = 0;
  __int16 v27 = (int *)(a3 + 4);
  uint64_t v9 = a4 + 168;
  do
  {
    uint64_t v11 = *(void *)(a2[20] + 8 * v8);
    if (!v11) {
      goto LABEL_17;
    }
    size_t v12 = v27;
    if (!*a3)
    {
      unint64_t v13 = a2[16];
      if (v13 <= v8) {
        goto LABEL_38;
      }
      size_t v12 = (int *)(*(void *)(a2[17] + 8 * v8) + 12);
    }
    LODWORD(v13) = *(_DWORD *)(v11 + 72);
    if ((int)v13 - 1 < 0) {
      goto LABEL_17;
    }
    int v14 = *v12;
    do
    {
      unint64_t v13 = (v13 - 1);
      unint64_t v15 = *(void *)(v11 + 72);
      if (v15 <= v13)
      {
        uint64_t v32 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v33 = 136315906;
        long long v34 = "operator[]";
        __int16 v35 = 1024;
        int v36 = 789;
        __int16 v37 = 2048;
        unint64_t v38 = v13;
        __int16 v39 = 2048;
        unint64_t v40 = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_38:
        uint64_t v32 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v33 = 136315906;
        long long v34 = "operator[]";
        __int16 v35 = 1024;
        int v36 = 468;
        __int16 v37 = 2048;
        unint64_t v38 = v8;
        __int16 v39 = 2048;
        unint64_t v40 = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v16 = *(void *)(v11 + 88) + 24 * v13;
      if (*(_DWORD *)(v16 + 16) == v14 && *(void **)v16 != a2)
      {
        if (a4)
        {
          *(void *)&long long v41 = *(void *)v16;
          re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::add(v9, &v41);
        }
        else
        {
          re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v28, (uint64_t *)v16);
        }
      }
    }
    while ((int)v13 > 0);
    unint64_t v5 = a2[19];
LABEL_17:
    ++v8;
  }
  while (v5 > v8);
  unsigned int v17 = v30;
  if (v30)
  {
    uint64_t v18 = 0;
    uint64_t v19 = (int *)(v29 + 8);
    uint64_t v4 = a1;
    while (1)
    {
      int v20 = *v19;
      v19 += 6;
      if (v20 < 0) {
        break;
      }
      if (v30 == ++v18)
      {
        LODWORD(v18) = v30;
        break;
      }
    }
  }
  else
  {
    LODWORD(v18) = 0;
    uint64_t v4 = a1;
  }
LABEL_25:
  if (v17 != v18)
  {
    uint64_t v21 = v18;
    uint64_t v22 = v29;
    do
    {
      re::AnimationManager::remove(v4, *(re::internal::TimelineTree **)(v22 + 24 * v21 + 16), 1);
      if (v30 <= (int)v18 + 1) {
        unsigned int v23 = v18 + 1;
      }
      else {
        unsigned int v23 = v30;
      }
      int v24 = v18;
      while (1)
      {
        uint64_t v21 = (v24 + 1);
        if (v23 - 1 == v24) {
          break;
        }
        ++v24;
        LODWORD(v18) = v21;
        if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0) {
          goto LABEL_35;
        }
      }
      LODWORD(v18) = v23;
LABEL_35:
      ;
    }
    while (v17 != v18);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v28);
}

double re::AnimationManager::removeExcept(re::AnimationManager *this, re::internal::TimelineTree *a2, re::internal::AnimationHandoffBehavior *a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unsigned int v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v25 = 0x7FFFFFFFLL;
  unint64_t v4 = *((void *)a2 + 19);
  if (!v4)
  {
    unsigned int v13 = 0;
LABEL_19:
    LODWORD(v14) = 0;
    goto LABEL_20;
  }
  unint64_t v7 = 0;
  unint64_t v8 = (char *)a3 + 168;
  do
  {
    uint64_t v9 = *(void *)(*((void *)a2 + 20) + 8 * v7);
    if (v9)
    {
      LODWORD(v10) = *(_DWORD *)(v9 + 72);
      if ((int)v10 - 1 >= 0)
      {
        do
        {
          unint64_t v10 = (v10 - 1);
          unint64_t v11 = *(void *)(v9 + 72);
          if (v11 <= v10)
          {
            uint64_t v26 = 0;
            memset(v35, 0, sizeof(v35));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v27 = 136315906;
            long long v28 = "operator[]";
            __int16 v29 = 1024;
            int v30 = 789;
            __int16 v31 = 2048;
            unint64_t v32 = v10;
            __int16 v33 = 2048;
            unint64_t v34 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          size_t v12 = (uint64_t *)(*(void *)(v9 + 88) + 24 * v10);
          if ((re::internal::TimelineTree *)*v12 != a2)
          {
            if (a3)
            {
              *(void *)&v35[0] = *v12;
              re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::add((uint64_t)v8, v35);
            }
            else
            {
              re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v22, v12);
            }
          }
        }
        while ((int)v10 > 0);
        unint64_t v4 = *((void *)a2 + 19);
      }
    }
    ++v7;
  }
  while (v4 > v7);
  unsigned int v13 = v24;
  if (!v24) {
    goto LABEL_19;
  }
  uint64_t v14 = 0;
  unint64_t v15 = (int *)(v23 + 8);
  while (1)
  {
    int v16 = *v15;
    v15 += 6;
    if (v16 < 0) {
      break;
    }
    if (v24 == ++v14)
    {
      LODWORD(v14) = v24;
      break;
    }
  }
LABEL_20:
  if (v13 != v14)
  {
    uint64_t v17 = v14;
    uint64_t v18 = v23;
    do
    {
      re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(v18 + 24 * v17 + 16), 1);
      if (v24 <= (int)v14 + 1) {
        unsigned int v19 = v14 + 1;
      }
      else {
        unsigned int v19 = v24;
      }
      int v20 = v14;
      while (1)
      {
        uint64_t v17 = (v20 + 1);
        if (v19 - 1 == v20) {
          break;
        }
        ++v20;
        LODWORD(v14) = v17;
        if ((*(_DWORD *)(v18 + 24 * v17 + 8) & 0x80000000) != 0) {
          goto LABEL_30;
        }
      }
      LODWORD(v14) = v19;
LABEL_30:
      ;
    }
    while (v13 != v14);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v22);
}

double re::AnimationManager::remove(re::AnimationManager *this, re::internal::TimelineTree *a2, int a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  char v5 = *((unsigned char *)a2 + 184);
  uint64_t v6 = (char *)this + 40 * v5;
  uint64_t v7 = *((void *)v6 + 27);
  if (v7)
  {
    unint64_t v8 = (re::internal::TimelineTree ***)*((void *)v6 + 29);
    uint64_t v9 = 8 * v7;
    do
    {
      if (**v8 == a2) {
        *char *v8 = 0;
      }
      ++v8;
      v9 -= 8;
    }
    while (v9);
  }
  if (!*((unsigned char *)this + 504)) {
    re::AnimationManager::cleanUpHandoffBehaviors(this, v5);
  }
  unint64_t v10 = *((void *)a2 + 19);
  if (v10)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    while (*((void *)a2 + 10) > v12)
    {
      if (*(unsigned char *)(*((void *)a2 + 11) + v11))
      {
        uint64_t v13 = *((char *)a2 + 184);
        unint64_t v14 = re::DataArray<re::internal::TimelineTree>::handle((uint64_t)this + 64 * v13 + 72, (uint64_t)a2);
        re::AnimationManager::blendFactorAsBindPoint(this, v14 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v13 << 56), v12, (uint64_t)&v40);
        re::AnimationManager::removeCompositionChainsForBindPoint(this, (const re::BindPoint *)&v40, 1);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40 + 8);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40 + 8);
        unint64_t v10 = *((void *)a2 + 19);
      }
      ++v12;
      v11 += 12;
      if (v10 <= v12) {
        goto LABEL_14;
      }
    }
LABEL_48:
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v40 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v40 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v40 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    while (1)
    {
LABEL_51:
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v40 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
LABEL_14:
  unint64_t v15 = *((void *)a2 + 4);
  if (v15)
  {
    for (unint64_t i = 0; i < v15; ++i)
    {
      if (*((void *)a2 + 16) <= i) {
        goto LABEL_49;
      }
      uint64_t v17 = *(void *)(*((void *)a2 + 17) + 8 * i);
      if (*(_DWORD *)(v17 + 8) == 49)
      {
        re::TypedEventTimelineInstance<float>::timelineRemoved(v17);
        unint64_t v15 = *((void *)a2 + 4);
      }
    }
    unint64_t v10 = *((void *)a2 + 19);
  }
  if (v10)
  {
    for (unint64_t j = 0; v10 > j; ++j)
    {
      uint64_t v19 = *(void *)(*((void *)a2 + 20) + 8 * j);
      if (v19)
      {
        (*(void (**)(uint64_t))(*(void *)v19 + 64))(v19);
        unint64_t v20 = *(void *)(v19 + 72);
        if (!v20) {
          goto LABEL_51;
        }
        uint64_t v21 = 0;
        unint64_t v22 = 0;
        uint64_t v23 = *(void *)(v19 + 88);
        while (*(re::internal::TimelineTree **)(v23 + v21) != a2 || j != *(_DWORD *)(v23 + v21 + 8))
        {
          ++v22;
          v21 += 24;
          if (v20 == v22) {
            goto LABEL_51;
          }
        }
        if (v20 <= v22) {
          goto LABEL_51;
        }
        uint64_t v24 = v20 - 1;
        if (v20 - 1 > v22 && 24 * v20 - 24 != v21)
        {
          memmove((void *)(*(void *)(v19 + 88) + v21), (const void *)(*(void *)(v19 + 88) + v21 + 24), 24 * v20 - v21 - 27);
          uint64_t v24 = *(void *)(v19 + 72) - 1;
        }
        *(void *)(v19 + 72) = v24;
        ++*(_DWORD *)(v19 + 80);
        unint64_t v10 = *((void *)a2 + 19);
        if (v10 <= j) {
          goto LABEL_50;
        }
        *(void *)(*((void *)a2 + 20) + 8 * j) = 0;
      }
    }
  }
  double v25 = re::internal::TimelineTree::currentTime(a2);
  re::AnimationManager::addAnimationEvent((uint64_t)this, 4, (uint64_t)a2, a3, v25);
  if (!*((unsigned char *)this + 504))
  {
    re::AnimationManager::updateLookupTableForAllBuckets(this);
    uint64_t v27 = 0;
    char v28 = 1;
    while (1)
    {
      char v29 = v28;
      int v30 = (char *)this + 40 * v27;
      if ((int)*((void *)v30 + 49) >= 1) {
        break;
      }
LABEL_45:
      char v28 = 0;
      uint64_t v27 = 1;
      if ((v29 & 1) == 0) {
        goto LABEL_46;
      }
    }
    __int16 v31 = (char *)this + 48 * v27 + 280;
    uint64_t v32 = (uint64_t)(v30 + 376);
    __int16 v33 = (unint64_t *)(v30 + 392);
    unint64_t v34 = (void *)((char *)this + 40 * v27 + 408);
    uint64_t v35 = *((void *)v30 + 49) + 1;
    while (1)
    {
      unint64_t v36 = (v35 - 2);
      if (*v33 <= v36) {
        break;
      }
      __int16 v37 = *(void **)(*v34 + 8 * v36);
      if (!v37[9])
      {
        (*(void (**)(void))(*v37 + 40))(*(void *)(*v34 + 8 * v36));
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v31, v37[12]);
        v37[12] = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(v32, (v35 - 2));
        (*(void (**)(void *))*v37)(v37);
      }
      if ((unint64_t)--v35 <= 1) {
        goto LABEL_45;
      }
    }
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v40 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_48;
  }
LABEL_46:
  re::AnimationManager::destroyTimelineTree(this, a2);
  return re::AnimationManager::updateScheduler(this);
}

void re::AnimationManager::addAnimationEvent(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a3 + 176));
  uint64_t v11 = WeakRetained - 8;
  if (WeakRetained) {
    unint64_t v12 = WeakRetained - 8;
  }
  else {
    unint64_t v12 = 0;
  }
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    unint64_t v14 = re::DataArray<re::internal::TimelineTree>::handle(a1 + ((uint64_t)*(char *)(a3 + 184) << 6) + 72, a3) & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a3 + 184) << 56);
    v26[0] = a1;
    v26[1] = v14;
    if (!*(void *)(a3 + 56))
    {
      float32x4_t v26[2] = 0;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v35 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v27 = 136315906;
      char v28 = "operator[]";
      __int16 v29 = 1024;
      int v30 = 476;
      __int16 v31 = 2048;
      uint64_t v32 = 0;
      __int16 v33 = 2048;
      uint64_t v34 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    (*(void (**)(char *, uint64_t, void *, void, double))(*(void *)v11 + 32))(v11, a2, v26, *(void *)(a3 + 64), a5);
    if (a4)
    {
      (*(void (**)(char *))(*(void *)v11 + 48))(v11);
LABEL_8:
      unint64_t v12 = v11;
LABEL_22:

      return;
    }
    unint64_t v15 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * ((unint64_t)v11 ^ ((unint64_t)v11 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                              * ((unint64_t)v11 ^ ((unint64_t)v11 >> 30))) >> 27));
    unint64_t v16 = v15 ^ (v15 >> 31);
    unint64_t v17 = *(unsigned int *)(a1 + 480);
    if (v17)
    {
      unint64_t v18 = v16 % v17;
      uint64_t v19 = *(unsigned int *)(*(void *)(a1 + 464) + 4 * (v16 % v17));
      if (v19 != 0x7FFFFFFF)
      {
        uint64_t v20 = *(void *)(a1 + 472);
        if (*(char **)(v20 + 24 * v19 + 16) == v11) {
          goto LABEL_8;
        }
        while (1)
        {
          LODWORD(v19) = *(_DWORD *)(v20 + 24 * v19 + 8) & 0x7FFFFFFF;
          if (v19 == 0x7FFFFFFF) {
            break;
          }
          if (*(char **)(v20 + 24 * v19 + 16) == v12) {
            goto LABEL_22;
          }
        }
      }
    }
    else
    {
      LODWORD(v18) = 0;
    }
    uint64_t v21 = *(unsigned int *)(a1 + 492);
    if (v21 == 0x7FFFFFFF)
    {
      uint64_t v21 = *(unsigned int *)(a1 + 488);
      int v22 = v21;
      if (v21 == v17)
      {
        re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(a1 + 456, 2 * *(_DWORD *)(a1 + 484));
        LODWORD(v18) = v16 % *(unsigned int *)(a1 + 480);
        int v22 = *(_DWORD *)(a1 + 488);
      }
      *(_DWORD *)(a1 + 488) = v22 + 1;
      uint64_t v23 = *(void *)(a1 + 472);
      int v24 = *(_DWORD *)(v23 + 24 * v21 + 8);
    }
    else
    {
      uint64_t v23 = *(void *)(a1 + 472);
      int v24 = *(_DWORD *)(v23 + 24 * v21 + 8);
      *(_DWORD *)(a1 + 492) = v24 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v23 + 24 * v21 + 8) = v24 | 0x80000000;
    *(_DWORD *)(*(void *)(a1 + 472) + 24 * v21 + 8) = *(_DWORD *)(*(void *)(a1 + 472) + 24 * v21 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 464) + 4 * v18);
    *(void *)(*(void *)(a1 + 472) + 24 * v21) = v16;
    *(void *)(*(void *)(a1 + 472) + 24 * v21 + 16) = v12;
    id v25 = v13;
    *(_DWORD *)(*(void *)(a1 + 464) + 4 * v18) = v21;
    ++*(_DWORD *)(a1 + 484);
    ++*(_DWORD *)(a1 + 496);
    goto LABEL_22;
  }
}

uint64_t re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2) {
    *(void *)(*(void *)(result + 32) + 8 * a2) = *(void *)(*(void *)(result + 32) + 8 * v2 - 8);
  }
  *(void *)(result + 16) = v2 - 1;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove(uint64_t result, unint64_t a2)
{
  if (*(void *)result)
  {
    unint64_t v2 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v3 = (v2 ^ (v2 >> 31)) % *(unsigned int *)(result + 24);
    uint64_t v4 = *(void *)(result + 8);
    uint64_t v5 = *(unsigned int *)(v4 + 4 * v3);
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *(void *)(result + 16);
      uint64_t v7 = v6 + 32 * v5;
      if (*(void *)(v7 + 16) == a2)
      {
        *(_DWORD *)(v4 + 4 * v3) = *(_DWORD *)(v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v10 = *(void *)(result + 16);
        uint64_t v11 = v10 + 32 * v5;
        int v14 = *(_DWORD *)(v11 + 8);
        uint64_t v13 = (int *)(v11 + 8);
        int v12 = v14;
        if (v14 < 0)
        {
          *uint64_t v13 = v12 & 0x7FFFFFFF;
          uint64_t v10 = *(void *)(result + 16);
          int v12 = *(_DWORD *)(v10 + 32 * v5 + 8);
        }
        int v15 = *(_DWORD *)(result + 40);
        *(_DWORD *)(v10 + 32 * v5 + 8) = *(_DWORD *)(result + 36) | v12 & 0x80000000;
        --*(_DWORD *)(result + 28);
        *(_DWORD *)(result + 36) = v5;
        *(_DWORD *)(result + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v15 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v8 = v5;
          uint64_t v5 = *(_DWORD *)(v6 + 32 * v5 + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          uint64_t v9 = v6 + 32 * v5;
          if (*(void *)(v9 + 16) == a2)
          {
            *(_DWORD *)(v6 + 32 * v8 + 8) = *(_DWORD *)(v6 + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (v7)
  {
    unint64_t v8 = v6 % v7;
    uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v10 = *(void *)(a1 + 16);
      if (*(void *)(v10 + 24 * v9 + 16) == v4) {
        return;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v10 + 24 * v9 + 16) == v4) {
          return;
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 36);
  if (v11 == 0x7FFFFFFF)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    int v12 = v11;
    if (v11 == v7)
    {
      re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      int v12 = *(_DWORD *)(a1 + 32);
      uint64_t v4 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8);
  *(void *)(*(void *)(a1 + 16) + 24 * v11) = v6;
  *(void *)(*(void *)(a1 + 16) + 24 * v11 + 16) = v4;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

double re::AnimationManager::removePending(re::AnimationManager *this, re::internal::TimelineTree *a2, const re::internal::AnimationHandoffBehavior *a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  unsigned int v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v29 = 0x7FFFFFFFLL;
  unint64_t v4 = *((void *)a2 + 19);
  if (!v4)
  {
    unsigned int v17 = 0;
LABEL_23:
    LODWORD(v18) = 0;
    goto LABEL_24;
  }
  unint64_t v7 = 0;
  unint64_t v8 = (char *)a3 + 192;
  do
  {
    uint64_t v9 = *(void *)(*((void *)a2 + 20) + 8 * v7);
    if (v9)
    {
      unsigned int v10 = *(_DWORD *)(v9 + 72) - 1;
      if ((v10 & 0x80000000) == 0)
      {
        do
        {
          uint64_t v11 = v10;
          unint64_t v12 = *(void *)(v9 + 72);
          if (v12 <= v10)
          {
            uint64_t v30 = 0;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v39 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v31 = 136315906;
            uint64_t v32 = "operator[]";
            __int16 v33 = 1024;
            int v34 = 789;
            __int16 v35 = 2048;
            uint64_t v36 = v11;
            __int16 v37 = 2048;
            unint64_t v38 = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          uint64_t v13 = (void *)*((void *)a3 + 25);
          if (*((unsigned char *)a3 + 184)) {
            uint64_t v13 = v8;
          }
          uint64_t v14 = *((void *)a3 + 22);
          if (v14)
          {
            int v15 = (uint64_t *)(*(void *)(v9 + 88) + 24 * v10);
            uint64_t v16 = 8 * v14;
            while (*v13 != *v15)
            {
              ++v13;
              v16 -= 8;
              if (!v16) {
                goto LABEL_14;
              }
            }
            re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v26, v15);
          }
LABEL_14:
          unsigned int v10 = v11 - 1;
        }
        while ((int)v11 > 0);
        unint64_t v4 = *((void *)a2 + 19);
      }
    }
    ++v7;
  }
  while (v4 > v7);
  unsigned int v17 = v28;
  if (!v28) {
    goto LABEL_23;
  }
  uint64_t v18 = 0;
  uint64_t v19 = (int *)(v27 + 8);
  while (1)
  {
    int v20 = *v19;
    v19 += 6;
    if (v20 < 0) {
      break;
    }
    if (v28 == ++v18)
    {
      LODWORD(v18) = v28;
      break;
    }
  }
LABEL_24:
  if (v17 != v18)
  {
    uint64_t v21 = v18;
    uint64_t v22 = v27;
    do
    {
      re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(v22 + 24 * v21 + 16), 1);
      if (v28 <= (int)v18 + 1) {
        unsigned int v23 = v18 + 1;
      }
      else {
        unsigned int v23 = v28;
      }
      int v24 = v18;
      while (1)
      {
        uint64_t v21 = (v24 + 1);
        if (v23 - 1 == v24) {
          break;
        }
        ++v24;
        LODWORD(v18) = v21;
        if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0) {
          goto LABEL_34;
        }
      }
      LODWORD(v18) = v23;
LABEL_34:
      ;
    }
    while (v17 != v18);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v26);
}

void *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::add(void *this, void *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::AnimationHandoffBehavior *>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * v4) = *a2;
  uint64_t v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::AnimationManager::cleanUpHandoffBehaviors(_anonymous_namespace_ *a1, int a2)
{
  unint64_t v4 = (char *)a1 + 40 * a2;
  uint64_t v7 = *((void *)v4 + 27);
  unint64_t v6 = (unint64_t *)(v4 + 216);
  uint64_t v5 = v7;
  if (v7)
  {
    unint64_t v8 = (re::internal::AnimationHandoffBehavior ***)(v6 + 2);
    uint64_t v9 = (re::internal::AnimationHandoffBehavior **)v6[2];
    unsigned int v10 = &v9[v5];
    uint64_t v11 = (_DWORD *)((char *)a1 + 40 * a2 + 224);
    do
    {
      unint64_t v12 = *v9;
      if (!*(void *)*v9)
      {
        uint64_t v13 = *v8;
        unint64_t v14 = *v6;
        int v15 = *v8;
        if (*v6)
        {
          uint64_t v16 = 8 * v14;
          int v15 = *v8;
          while (*v15 != v12)
          {
            ++v15;
            v16 -= 8;
            if (!v16)
            {
              int v15 = &(*v8)[*v6];
              break;
            }
          }
        }
        unint64_t v17 = v15 - v13;
        if (v17 != v14)
        {
          if (v14 <= v17)
          {
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          if (v14 - 1 > v17) {
            v13[v17] = (*v8)[*v6 - 1];
          }
          *unint64_t v6 = v14 - 1;
          ++*v11;
          re::internal::AnimationHandoffBehavior::~AnimationHandoffBehavior(v12);
        }
      }
      ++v9;
    }
    while (v9 != v10);
  }
}

void re::AnimationManager::update(re::AnimationManager *this, float a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v9, 1000, (uint64_t)this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v8);
  *((unsigned char *)this + 504) = 1;
  if (!*((unsigned char *)this + 57)) {
    goto LABEL_4;
  }
  if (a2 >= 0.0)
  {
    unint64_t v4 = (OpaqueCMTimebase *)*((void *)this + 8);
    CMTimebaseGetTime(&lhs, v4);
    CMTimeMake(&rhs, (unint64_t)(a2 * 18000.0 + 0.5), 18000);
    CMTimeAdd(&time, &lhs, &rhs);
    CMTimebaseSetTime(v4, &time);
LABEL_4:
    re::AnimationManager::update((unint64_t)this, 0);
    re::AnimationManager::applyAnimations(this, 0);
    re::AnimationManager::update((unint64_t)this, 1);
    *((unsigned char *)this + 504) = 0;
  }
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end((uint64_t)v8);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v9);
}

uint64_t re::AnimationManager::update(unint64_t a1, int a2)
{
  uint64_t v5 = a1 + ((uint64_t)a2 << 6) + 72;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v18, v5, 0);
  if (v5 != v18 || (unsigned __int16)v19 != 0xFFFFLL || (v19 & 0xFFFF0000) != 4294901760)
  {
    do
    {
      unint64_t v8 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v18);
      re::AnimationManager::updateTime(a1, v8);
      re::AnimationManager::updateBlendFactors(v9, v8);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v18);
    }
    while (v18 != v5 || (unsigned __int16)v19 != 0xFFFF || WORD1(v19) != 0xFFFF);
  }
  uint64_t result = re::AnimationManager::updateHandoffBehaviors(a1, a2);
  unint64_t v13 = a1 + 40 * a2;
  uint64_t v14 = *(void *)(v13 + 392);
  if (v14)
  {
    int v15 = *(uint64_t **)(v13 + 408);
    uint64_t v16 = 8 * v14;
    do
    {
      uint64_t v17 = *v15++;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 32))(v17);
      v16 -= 8;
    }
    while (v16);
  }
  return result;
}

double re::AnimationManager::applyAnimations(_anonymous_namespace_ *a1, int a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v26 = a2;
  unint64_t v4 = (char *)a1 + 40 * a2;
  re::AnimationManager::updateLookupTableForAllBuckets(a1);
  uint64_t v5 = (unint64_t *)(v4 + 392);
  uint64_t v6 = *((void *)v4 + 49);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = (uint64_t)(v4 + 376);
    uint64_t v8 = v6 + 1;
    while (1)
    {
      unint64_t v9 = (v8 - 2);
      unint64_t v10 = *v5;
      if (*v5 <= v9) {
        break;
      }
      uint64_t v11 = *(void *)(*((void *)a1 + 5 * (int)v26 + 51) + 8 * v9);
      if (!*(void *)(v11 + 72))
      {
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)a1 + 48 * a2 + 280, *(void *)(v11 + 96));
        *(void *)(v11 + 96) = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(v7, (v8 - 2));
        (**(void (***)(uint64_t))v11)(v11);
      }
      if ((unint64_t)--v8 <= 1) {
        goto LABEL_7;
      }
    }
    *(void *)&long long v27 = 0;
    long long v41 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v29 = 136315906;
    uint64_t v30 = "operator[]";
    __int16 v31 = 1024;
    int v32 = 789;
    __int16 v33 = 2048;
    uint64_t v34 = (v8 - 2);
    __int16 v35 = 2048;
    unint64_t v36 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_46;
  }
LABEL_7:
  if (!*((unsigned char *)a1 + 506))
  {
    uint64_t v12 = (uint64_t)a1 + 64 * v26 + 72;
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v37, v12, 0);
    long long v27 = v37;
    if (v12 != (void)v37 || WORD4(v37) != 0xFFFFLL || (DWORD2(v37) & 0xFFFF0000) != 0xFFFF0000)
    {
      while (1)
      {
        uint64_t v13 = re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v27);
        if (!*(void *)(v13 + 56)) {
          break;
        }
        if (**(unsigned char **)(v13 + 64) == 1) {
          re::AnimationManager::remove(a1, (re::internal::TimelineTree *)v13, 0);
        }
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
        if ((void)v27 == v12 && WORD4(v27) == 0xFFFF && WORD5(v27) == 0xFFFF) {
          goto LABEL_22;
        }
      }
LABEL_47:
      uint64_t v28 = 0;
      long long v41 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v29 = 136315906;
      uint64_t v30 = "operator[]";
      __int16 v31 = 1024;
      int v32 = 468;
      __int16 v33 = 2048;
      uint64_t v34 = 0;
      __int16 v35 = 2048;
      unint64_t v36 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
LABEL_22:
  if (*v5)
  {
    uint64_t v16 = (uint64_t *)*((void *)a1 + 5 * (int)v26 + 51);
    uint64_t v17 = 8 * *v5;
    do
    {
      uint64_t v18 = *v16++;
      (*(void (**)(uint64_t))(*(void *)v18 + 40))(v18);
      v17 -= 8;
    }
    while (v17);
  }
  if (*((unsigned char *)a1 + 506))
  {
    uint64_t v19 = (uint64_t)a1 + 64 * v26 + 72;
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v37, v19, 0);
    long long v27 = v37;
    BOOL v20 = v19 == (void)v37 && WORD4(v37) == 0xFFFFLL;
    if (!v20 || (DWORD2(v37) & 0xFFFF0000) != 4294901760)
    {
      while (1)
      {
        uint64_t v22 = re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v27);
        if (!*(void *)(v22 + 56)) {
          break;
        }
        if (**(unsigned char **)(v22 + 64) == 1) {
          re::AnimationManager::remove(a1, (re::internal::TimelineTree *)v22, 0);
        }
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
        if ((void)v27 == v19 && WORD4(v27) == 0xFFFF && WORD5(v27) == 0xFFFF) {
          goto LABEL_44;
        }
      }
LABEL_46:
      uint64_t v28 = 0;
      long long v41 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v29 = 136315906;
      uint64_t v30 = "operator[]";
      __int16 v31 = 1024;
      int v32 = 468;
      __int16 v33 = 2048;
      uint64_t v34 = 0;
      __int16 v35 = 2048;
      unint64_t v36 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
  }
LABEL_44:
  re::AnimationManager::cleanUpHandoffBehaviors(a1, a2);
  return re::AnimationManager::updateScheduler(a1);
}

uint64_t re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1 = a1[5];
  if (*(void *)(*(void *)a1 + 16) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(*(void *)a1 + 32) + 16 * v1) + 216 * a1[4];
}

void re::AnimationManager::updateTime(unint64_t this, re::internal::TimelineTree *a2)
{
  unint64_t v3 = (unint64_t)&v40;
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (!*((void *)a2 + 7))
  {
LABEL_49:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    *(void *)(v3 + 20) = 0;
    __int16 v46 = 2048;
    *(void *)(v3 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    *(void *)(v3 + 20) = 0;
    __int16 v46 = 2048;
    *(void *)(v3 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  uint64_t v6 = (re::AnimationManager *)*((void *)a2 + 4);
  uint64_t v7 = (float *)*((void *)a2 + 8);
  int v8 = *(unsigned __int8 *)v7;
  float v9 = v7[15];
  unint64_t v10 = a2;
  do
  {
    uint64_t v11 = v10;
    unint64_t v10 = (re::internal::TimelineTree *)*((void *)v10 + 25);
  }
  while (v10);
  double Rate = CMTimebaseGetRate(*((CMTimebaseRef *)v11 + 24));
  if (!*((void *)a2 + 25) && *((unsigned char *)a2 + 185) == 2)
  {
    CMTimebaseSetRate(*((CMTimebaseRef *)a2 + 24), *((float *)a2 + 47));
    *((unsigned char *)a2 + 185) = 0;
  }
  if (!*((void *)a2 + 7)) {
    goto LABEL_50;
  }
  uint64_t v13 = (char *)*((void *)a2 + 8);
  v37[0] = 1;
  Float64 v38 = re::internal::TimelineTree::currentTime(a2);
  if (!*((void *)a2 + 4))
  {
LABEL_51:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = 0;
    __int16 v46 = 2048;
    unint64_t v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_52;
  }
  float v14 = Rate;
  re::AnimationClock::update(v13, (uint64_t)v37, *((void *)a2 + 5), v14);
  if ((unint64_t)v6 >= 2)
  {
    unint64_t v3 = 1;
    uint64_t v15 = 28;
    uint64_t v16 = 72;
    while (1)
    {
      unint64_t v17 = *((void *)a2 + 1);
      if (v17 <= v3) {
        break;
      }
      unint64_t v2 = *((void *)a2 + 7);
      if (v2 <= v3) {
        goto LABEL_44;
      }
      unint64_t v17 = *(int *)(*((void *)a2 + 2) + 4 * v3);
      if (v2 <= v17) {
        goto LABEL_45;
      }
      uint64_t v18 = *((void *)a2 + 8);
      v35[0] = *(unsigned char *)(v18 + 72 * (int)v17 + 16);
      if (v35[0]) {
        uint64_t v36 = *(void *)(v18 + 72 * (int)v17 + 24);
      }
      unint64_t v17 = *((void *)a2 + 4);
      if (v17 <= v3) {
        goto LABEL_46;
      }
      re::AnimationClock::update((char *)(v18 + v16), (uint64_t)v35, *((void *)a2 + 5) + v15, v14);
      ++v3;
      v15 += 28;
      v16 += 72;
      if (v6 == (re::AnimationManager *)v3) {
        goto LABEL_18;
      }
    }
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = v3;
    __int16 v46 = 2048;
    unint64_t v47 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_44:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = v3;
    __int16 v46 = 2048;
    unint64_t v47 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_45:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = v17;
    __int16 v46 = 2048;
    unint64_t v47 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_46:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = v3;
    __int16 v46 = 2048;
    unint64_t v47 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_47;
  }
LABEL_18:
  if (!*((void *)a2 + 7))
  {
LABEL_52:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = 0;
    __int16 v46 = 2048;
    unint64_t v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    uint64_t v39 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v40 = 136315906;
    long long v41 = "operator[]";
    __int16 v42 = 1024;
    int v43 = 468;
    __int16 v44 = 2048;
    unint64_t v45 = 0;
    __int16 v46 = 2048;
    unint64_t v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(unsigned char *)(*((void *)a2 + 8) + 32) = 0;
  id WeakRetained = objc_loadWeakRetained((id *)a2 + 22);
  if (WeakRetained)
  {
    if (!*((void *)a2 + 7)) {
      goto LABEL_53;
    }
    unint64_t v3 = (unint64_t)WeakRetained;
    BOOL v20 = (unsigned __int8 *)*((void *)a2 + 8);
    int v21 = *v20;
    double v22 = *((double *)v20 + 1);
    if (v8 == v21)
    {
      if ((LODWORD(v9) & 0x7FFFFFFFu) > 0x7F7FFFFF
        || (*((_DWORD *)v20 + 15) & 0x7FFFFFFFu) > 0x7F7FFFFF
        || floorf(v9) == floorf(*((float *)v20 + 15)))
      {
        goto LABEL_31;
      }
      uint64_t v23 = 3;
    }
    else if (v21 == 3)
    {
      uint64_t v23 = 1;
      v20[32] = 1;
    }
    else
    {
      if ((v21 & 0xFFFFFFFB) != 1)
      {
LABEL_31:
        if (v6)
        {
          uint64_t v24 = 0;
          this = 0;
          while (1)
          {
            unint64_t v17 = *((void *)a2 + 16);
            if (v17 <= this) {
              break;
            }
            uint64_t v25 = *(void *)(*((void *)a2 + 17) + 8 * this);
            if (*(_DWORD *)(v25 + 8) == 49 && !*(unsigned char *)(v25 + 120))
            {
              unint64_t v17 = *((void *)a2 + 7);
              if (v17 <= this) {
                goto LABEL_48;
              }
              uint64_t v26 = *((void *)a2 + 8) + v24;
              long long v29 = *(_OWORD *)v26;
              if (*(unsigned char *)(v26 + 16)) {
                uint64_t v31 = *(void *)(v26 + 24);
              }
              long long v27 = *(_OWORD *)(v26 + 32);
              long long v28 = *(_OWORD *)(v26 + 48);
              int v34 = *(_DWORD *)(v26 + 64);
              long long v32 = v27;
              long long v33 = v28;
              re::TypedEventTimelineInstance<float>::processEvents(v25, &v29, 0);
            }
            ++this;
            v24 += 72;
            if (v6 == (re::AnimationManager *)this) {
              goto LABEL_41;
            }
          }
LABEL_47:
          uint64_t v39 = 0;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v48 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v40 = 136315906;
          long long v41 = "operator[]";
          __int16 v42 = 1024;
          int v43 = 468;
          __int16 v44 = 2048;
          unint64_t v45 = this;
          __int16 v46 = 2048;
          unint64_t v47 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_48:
          uint64_t v39 = 0;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v48 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v40 = 136315906;
          long long v41 = "operator[]";
          __int16 v42 = 1024;
          int v43 = 468;
          __int16 v44 = 2048;
          unint64_t v45 = this;
          __int16 v46 = 2048;
          unint64_t v47 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_49;
        }
LABEL_41:

        return;
      }
      uint64_t v23 = 2;
    }
    re::AnimationManager::addAnimationEvent(this, v23, (uint64_t)a2, 0, v22);
    goto LABEL_31;
  }
}

float re::AnimationManager::updateBlendFactors(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  uint64_t v2 = *((void *)a2 + 10);
  if (!v2)
  {
LABEL_23:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v3 = *((void *)a2 + 13);
  if (!v3) {
    goto LABEL_24;
  }
  unint64_t v4 = *((void *)a2 + 4);
  uint64_t v5 = (unsigned char *)*((void *)a2 + 11);
  uint64_t v6 = 8;
  if (!*v5) {
    uint64_t v6 = 4;
  }
  float result = *(float *)&v5[v6];
  int v8 = (float *)*((void *)a2 + 14);
  float *v8 = result;
  if (v4 >= 2)
  {
    uint64_t v9 = *((void *)a2 + 2);
    if (*((void *)a2 + 1) <= 1uLL) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = *((void *)a2 + 1);
    }
    uint64_t v11 = (float *)(v5 + 20);
    uint64_t v12 = 1;
    while (v10 != v12)
    {
      unint64_t v13 = *(int *)(v9 + 4 * v12);
      if (v3 <= v13) {
        goto LABEL_20;
      }
      if (v2 == v12) {
        goto LABEL_21;
      }
      if (v3 == v12) {
        goto LABEL_22;
      }
      if (*((unsigned char *)v11 - 8)) {
        float v14 = v11;
      }
      else {
        float v14 = v11 - 1;
      }
      float result = v8[v13] * *v14;
      v8[v12++] = result;
      v11 += 3;
      if (v4 == v12) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_22:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_23;
  }
  return result;
}

BOOL re::AnimationManager::updateHandoffBehaviors(BOOL result, int a2)
{
  uint64_t v2 = result + 40 * a2;
  uint64_t v3 = *(void *)(v2 + 216);
  if (v3)
  {
    unint64_t v4 = (re::AnimationManager *)result;
    uint64_t v5 = *(re::internal::TimelineTree ****)(v2 + 232);
    uint64_t v6 = 8 * v3;
    do
    {
      uint64_t v7 = *v5;
      if (**v5)
      {
        float result = re::internal::AnimationHandoffBehavior::update(*v5, v4);
        if (result) {
          *uint64_t v7 = 0;
        }
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void re::AnimationManager::applyAnimations(re::AnimationManager *this)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3, 1002, (uint64_t)this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v2);
  *((unsigned char *)this + 505) = 1;
  re::AnimationManager::applyAnimations(this, 1);
  *((unsigned char *)this + 505) = 0;
  re::AnimationManager::raiseAnimationEvents(this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end((uint64_t)v2);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3);
}

void re::AnimationManager::updateAndApplyAnimations(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  *((unsigned char *)this + 504) = 1;
  re::AnimationManager::updateTime((unint64_t)this, a2);
  re::AnimationManager::updateBlendFactors(v3, a2);
  uint64_t v4 = *((void *)a2 + 4);
  re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v24);
  unsigned int v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v23 = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)&v20, (uint64_t)v24, 3);
  if (v4)
  {
    for (unint64_t i = 0; i != v4; ++i)
    {
      unint64_t v6 = *((void *)a2 + 19);
      if (v6 <= i)
      {
        uint64_t v25 = 0;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v34 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v26 = 136315906;
        long long v27 = "operator[]";
        __int16 v28 = 1024;
        int v29 = 468;
        __int16 v30 = 2048;
        unint64_t v31 = i;
        __int16 v32 = 2048;
        unint64_t v33 = v6;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      unint64_t v7 = *(void *)(*((void *)a2 + 20) + 8 * i);
      if (!v7) {
        continue;
      }
      unint64_t v8 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      unint64_t v9 = v8 ^ (v8 >> 31);
      if (DWORD2(v21))
      {
        uint64_t v10 = *(unsigned int *)(*((void *)&v20 + 1) + 4 * (v9 % DWORD2(v21)));
        if (v10 != 0x7FFFFFFF)
        {
          while (*(void *)(v21 + 24 * v10 + 16) != v7)
          {
            LODWORD(v10) = *(_DWORD *)(v21 + 24 * v10 + 8) & 0x7FFFFFFF;
            if (v10 == 0x7FFFFFFF) {
              goto LABEL_9;
            }
          }
          continue;
        }
LABEL_9:
        unint64_t v11 = v9 % DWORD2(v21);
        uint64_t v12 = *(unsigned int *)(*((void *)&v20 + 1) + 4 * (v9 % DWORD2(v21)));
        if (v12 != 0x7FFFFFFF)
        {
          while (*(void *)(v21 + 24 * v12 + 16) != v7)
          {
            LODWORD(v12) = *(_DWORD *)(v21 + 24 * v12 + 8) & 0x7FFFFFFF;
            if (v12 == 0x7FFFFFFF) {
              goto LABEL_14;
            }
          }
          goto LABEL_20;
        }
      }
      else
      {
        unint64_t v11 = 0;
      }
LABEL_14:
      unsigned int v13 = v23;
      if (v23 == 0x7FFFFFFF)
      {
        unsigned int v13 = v22;
        unsigned int v14 = v22;
        if (v22 == DWORD2(v21))
        {
          re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity((uint64_t)&v20, 2 * HIDWORD(v21));
          unsigned int v14 = v22;
          unint64_t v11 = v9 % DWORD2(v21);
        }
        unsigned int v22 = v14 + 1;
        uint64_t v15 = v21;
        int v16 = *(_DWORD *)(v21 + 24 * v13 + 8);
      }
      else
      {
        uint64_t v15 = v21;
        int v16 = *(_DWORD *)(v21 + 24 * v23 + 8);
        LODWORD(v23) = v16 & 0x7FFFFFFF;
      }
      uint64_t v17 = v15 + 24 * v13;
      *(_DWORD *)(v17 + 8) = v16 | 0x80000000;
      uint64_t v18 = *((void *)&v20 + 1);
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(*((void *)&v20 + 1) + 4 * v11) | 0x80000000;
      *(void *)uint64_t v17 = v9;
      *(void *)(v17 + 16) = v7;
      *(_DWORD *)(v18 + 4 * v11) = v13;
      ++HIDWORD(v21);
      ++HIDWORD(v23);
LABEL_20:
      (*(void (**)(unint64_t))(*(void *)v7 + 32))(v7);
      (*(void (**)(unint64_t))(*(void *)v7 + 40))(v7);
    }
  }
  *((unsigned char *)this + 504) = 0;
  re::AnimationManager::raiseAnimationEvents(this);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v20);
  re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v24);
}

void re::AnimationManager::blendFactorAsBindPoint(re::AnimationManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v11 = a3;
  uint64_t v12 = a2;
  unint64_t v6 = 0x268771000uLL;
  {
    unint64_t v6 = 0x268771000;
    if (v8)
    {
      re::introspect<float>(void)::info = re::introspect_float(0, v9);
      unint64_t v6 = 0x268771000;
    }
  }
  uint64_t v7 = *(void *)(v6 + 3632);
  *(void *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  *(void *)a4 = v7;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  *(_DWORD *)(a4 + 32) = 0;
  uint64_t v10 = this;
}

void re::BindPoint::addToBindPointStack<re::internal::BlendFactorBindPointImpl,re::AnimationManager *,unsigned long long &,unsigned long &>(void *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(v13, 0, sizeof(v13));
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a1 + 1), v13);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v13);
  uint64_t v9 = a1[5] + 32 * a1[3];
  uint64_t v10 = *a3;
  uint64_t v11 = *a4;
  uint64_t v12 = *a5;
  *(void *)(v9 - 32) = &unk_26E6C2278;
  *(void *)(v9 - 24) = v10;
  *(void *)(v9 - 16) = v11;
  *(void *)(v9 - 8) = v12;
}

void re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 24;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v9;
  }
}

BOOL re::AnimationManager::isUpdating(re::AnimationManager *this)
{
  return *((unsigned char *)this + 504) || *((unsigned char *)this + 505) != 0;
}

uint64_t re::AnimationManager::rootTimebase(re::AnimationManager *this)
{
  return *((void *)this + 8);
}

uint64_t re::AnimationManager::taskOptions(re::AnimationManager *this)
{
  return (uint64_t)this + 16;
}

double re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 24;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::Scheduler::setTaskOverscheduleStrategy(uint64_t result, unint64_t a2, char a3)
{
  if (*(void *)(result + 472) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(unsigned char *)(*(void *)(result + 480) + a2) = a3;
  return result;
}

uint64_t re::Scheduler::setTaskMaxOverscheduleSubsteps(uint64_t this, unint64_t a2, char a3)
{
  if (*(void *)(this + 496) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(unsigned char *)(*(void *)(this + 504) + a2) = a3;
  return this;
}

re::internal::AriadneSignpostScopeGuard *re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this, int a2, uint64_t a3)
{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return this;
}

void re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::getBit(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2 >> 6)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v2 = a1 + 24;
  }
  else {
    uint64_t v2 = *(void *)(a1 + 32);
  }
  return (*(void *)(v2 + 8 * (a2 >> 6)) >> a2) & 1;
}

_anonymous_namespace_ *re::DataArray<re::internal::TimelineTree>::allocBlock(void *a1)
{
  uint64_t v3 = 216 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  double result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    double result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  int v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        double result = (_anonymous_namespace_ *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(a1, v14);
      }
      else
      {
        double result = (_anonymous_namespace_ *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  *uint64_t v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void *re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          int v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          int v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::TypedEventTimelineInstance<float>::compositionChain(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 144);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v2 = *(void **)(a1 + 128);
  do
  {
    if (v2[19] <= v1)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_11:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v2[1] <= v1) {
      goto LABEL_11;
    }
    uint64_t result = *(void *)(v2[20] + 8 * v1);
    if (result) {
      break;
    }
    unint64_t v1 = *(unsigned int *)(v2[2] + 4 * v1);
  }
  while ((v1 & 0x80000000) == 0);
  return result;
}

uint64_t re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(uint64_t result, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = result;
  uint64_t v9 = *(unsigned int *)(result + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(result + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(result + 24))
    {
      uint64_t result = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(result, (2 * *(_DWORD *)(result + 28)));
      a2 = a3 % *(unsigned int *)(v8 + 24);
      int v10 = *(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(v8 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(v8 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(result + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(result + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(v8 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(v8 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v8 + 8) + 4 * a2);
  *(void *)(*(void *)(v8 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(v8 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(v8 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(v8 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(v8 + 28);
  return result;
}

void re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(void *)&v14[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v14, v4, a2);
      long long v5 = *(_OWORD *)v14;
      *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v14[16];
      uint64_t v7 = *(void *)(a1 + 16);
      *(void *)&v14[16] = v7;
      *(void *)(a1 + 16) = v6;
      long long v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = (void *)(v7 + 16);
        do
        {
          if ((*(_DWORD *)(v12 - 1) & 0x80000000) != 0) {
            re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(a1, *(v12 - 2) % (unint64_t)*(unsigned int *)(a1 + 24), *(v12 - 2), v12, v12 + 1);
          }
          ++v11;
          v12 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2) {
      signed int v13 = a2;
    }
    else {
      signed int v13 = 3;
    }
  }
}

void re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)unsigned int v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&unsigned char v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        signed int v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

void *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t *re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(uint64_t *a1)
{
  *a1 = 0;
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = re::profilerThreadContext(isStatisticCollectionEnabled);
    *a1 = v3;
    if (*(void *)(v3 + 152)) {
      a1[1] = mach_absolute_time();
    }
  }
  return a1;
}

uint64_t re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end(uint64_t result)
{
  if (*(void *)result && *(void *)(*(void *)result + 152))
  {
    unint64_t v1 = (void *)result;
    uint64_t result = mach_absolute_time();
    uint64_t v2 = *v1;
    uint64_t v3 = *(int64x2_t **)(*v1 + 152);
    if (v3)
    {
      uint64_t v4 = result - v1[1];
      uint64_t v5 = v3[84].u64[0];
      if (v5 >= v4) {
        uint64_t v5 = result - v1[1];
      }
      v3[84].i64[0] = v5;
      unint64_t v6 = v3[84].u64[1];
      if (v6 <= v4) {
        unint64_t v6 = v4;
      }
      v3[84].i64[1] = v6;
      int64x2_t v7 = vdupq_n_s64(1uLL);
      v7.i64[0] = v4;
      v3[85] = vaddq_s64(v3[85], v7);
      *(unsigned char *)(v2 + 184) = 0;
    }
    void *v1 = 0;
  }
  return result;
}

void re::DynamicArray<re::BindPoint::BindPointData>::add(_anonymous_namespace_ *this, _OWORD *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::BindPoint::BindPointData>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = (re::BindPoint::BindPointData *)(*((void *)this + 4) + 32 * v4);
  *(_OWORD *)uint64_t v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  re::BindPoint::BindPointData::move(v5, a2);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
}

void *re::DynamicArray<re::BindPoint::BindPointData>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::BindPoint::BindPointData>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BindPoint::BindPointData>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void re::internal::BlendFactorBindPointImpl::~BlendFactorBindPointImpl(re::internal::BlendFactorBindPointImpl *this)
{
}

const char *re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::implTypeInfo()
{
  return " ";
}

__n128 re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::copyInto(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&unk_26E6C2278;
  a2->n128_u64[1] = v2;
  __n128 result = a1[1];
  a2[1] = result;
  return result;
}

__n128 re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::moveInto(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&unk_26E6C2278;
  a2->n128_u64[1] = v2;
  __n128 result = a1[1];
  a2[1] = result;
  return result;
}

BOOL re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::equals(void *a1, void *a2)
{
  return (char *)(*(uint64_t (**)(void *))(*a2 + 16))(a2) == " "
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3];
}

uint64_t re::internal::BlendFactorBindPointImpl::hash(void *a1)
{
  unint64_t v1 = 0xBF58476D1CE4E5B9 * (a1[1] ^ (a1[1] >> 30));
  unint64_t v2 = (0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) ^ ((0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) >> 31);
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (a1[2] ^ (a1[2] >> 30));
  unint64_t v4 = (0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31);
  uint64_t v5 = a1[3] ^ (a1[3] >> 30);
  unint64_t v6 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v5) ^ ((0xBF58476D1CE4E5B9 * v5) >> 27));
  return ((v2 << 6)
        + (v2 >> 2)
        - 0x61C8864680B583E9
        + (((v6 ^ (v6 >> 31)) + (v4 << 6) + (v4 >> 2) - 0x61C8864680B583E9) ^ v4)) ^ v2;
}

uint64_t re::internal::BlendFactorBindPointImpl::isWeak()
{
  return 1;
}

BOOL re::internal::BlendFactorBindPointImpl::isAlive(re::internal::BlendFactorBindPointImpl *a1)
{
  return re::internal::BlendFactorBindPointImpl::getBlendFactor(a1) != 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::targetIdentifier(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor) {
    return BlendFactor + 4;
  }
  else {
    return 0;
  }
}

uint64_t re::internal::BlendFactorBindPointImpl::baseValueUntyped(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor) {
    return BlendFactor + 4;
  }
  else {
    return 0;
  }
}

uint64_t re::internal::BlendFactorBindPointImpl::supportsOverrideValue()
{
  return 1;
}

unsigned char *re::internal::BlendFactorBindPointImpl::isOverridden(re::internal::BlendFactorBindPointImpl *a1)
{
  __n128 result = (unsigned char *)re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (result) {
    return (unsigned char *)(*result != 0);
  }
  return result;
}

unsigned char *re::internal::BlendFactorBindPointImpl::setIsOverridden(re::internal::BlendFactorBindPointImpl *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  __n128 result = (unsigned char *)re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (result) {
    *__n128 result = a5;
  }
  return result;
}

uint64_t re::internal::BlendFactorBindPointImpl::overrideValueUntyped(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor) {
    return BlendFactor + 8;
  }
  else {
    return 0;
  }
}

uint64_t re::internal::BlendFactorBindPointImpl::boundOwner()
{
  return 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::getBlendFactor(re::internal::BlendFactorBindPointImpl *this)
{
  uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*((void *)this + 1) + (*((uint64_t *)this + 2) >> 56 << 6) + 72, *((void *)this + 2));
  if (result)
  {
    unint64_t v3 = *((void *)this + 3);
    if (*(void *)(result + 80) <= v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(void *)(result + 88) + 12 * v3;
  }
  return result;
}

void re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)uint64_t v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unsigned int v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        uint64_t v12 = v7;
        int v13 = DWORD1(v9);
        unint64_t v14 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 2);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(a1, (2 * v13));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 24 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 24 * v18) = v15;
            *(void *)(*(void *)(a1 + 16) + 24 * v18 + 16) = *v14;
            *unint64_t v14 = 0;
            *(_DWORD *)(v12 + 4 * v17) = v18;
            int v13 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v13;
            unsigned int v10 = *(_DWORD *)&v23[32];
          }
          ++v11;
          v14 += 3;
        }
        while (v11 < v10);
      }
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

re::DynamicString *re::RigGraphCompiler::getCurrentCompiledAssetInfo@<X0>(re::RigGraphCompiler *this@<X0>, void *a2@<X8>)
{
  *a2 = 0x100000001;
  unint64_t v2 = (re::DynamicString *)(a2 + 1);
  unint64_t v3 = (_anonymous_namespace_ *)re::RigGraphAsset::assetType(this);
  uint64_t v4 = *(const char **)v3;
}

uint64_t re::RigGraphCompiler::assetIntrospectionType(re::RigGraphCompiler *this)
{
  unint64_t v1 = &qword_268772000;
  {
    unint64_t v1 = &qword_268772000;
    if (v3)
    {
      re::introspect<re::RigGraphAsset>(void)::info = re::introspect_RigGraphAsset(0);
      unint64_t v1 = &qword_268772000;
    }
  }
  return v1[88];
}

uint64_t re::RigGraphCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = "reriggraph";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::RigGraphCompiler::compile@<X0>(re::RigGraphCompiler *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  v30[4] = *MEMORY[0x263EF8340];
  unsigned int v8 = re::globalAllocators(this);
  long long v9 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 160, 8);
  *(_OWORD *)long long v9 = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 9) = 0u;
  *(void *)&long long v25 = &unk_26E6C23D0;
  *((void *)&v26 + 1) = &v25;
  v30[3] = v30;
  int v29 = v9;
  v30[0] = &unk_26E6C23D0;
  std::__function::__value_func<void ()(re::RigGraphAsset *)>::~__value_func[abi:nn180100](&v25);
  unsigned int v10 = strrchr(a2, 46);
  if (!strcasecmp(v10 + 1, "reriggraph"))
  {
    int v13 = v29;
    unint64_t v14 = &qword_268772000;
    {
      *(void *)int v21 = v13;
      unint64_t v14 = &qword_268772000;
      int v13 = *(const char **)v21;
      if (v20)
      {
        re::introspect<re::RigGraphAsset>(void)::info = re::introspect_RigGraphAsset(0);
        unint64_t v14 = &qword_268772000;
        int v13 = *(const char **)v21;
      }
    }
    re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, v13, v14[88], a3, (uint64_t)v22);
    if (v22[0])
    {
      uint64_t v15 = (uint64_t)v29;
      int v29 = 0;
      *(unsigned char *)a4 = 1;
      *(void *)(a4 + 8) = v15;
    }
    else
    {
      *(void *)&long long v25 = 100;
      *((void *)&v25 + 1) = re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)&v23);
      long long v16 = v26;
      *(_OWORD *)(a4 + 8) = v25;
      uint64_t v17 = v27;
      uint64_t v18 = v28;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 24) = v16;
      *(void *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v17;
      *(void *)(a4 + 48) = v18;
      if (!v22[0] && v23 && (v24 & 1) != 0) {
        (*(void (**)(void))(*(void *)v23 + 40))();
      }
    }
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v25, a2);
    long long v11 = v25;
    long long v12 = v26;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 200;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v11;
    *(_OWORD *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v12;
  }
  return std::unique_ptr<re::RigGraphAsset,std::function<void ()(re::RigGraphAsset*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v29);
}

re *re::RigGraphCompiler::deleteAsset(re::RigGraphCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::RigGraphAsset>((re *)"deleteAsset", 56, a2);
}

re *re::internal::destroyPersistent<re::RigGraphAsset>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::DynamicArray<re::RigGraphNode>::deinit(a3 + 120);
    re::DynamicArray<re::RigGraphBoundInputParameterData>::deinit(a3 + 80);
    re::DynamicArray<re::MeshRigGraphIndex>::deinit(a3 + 40);
    re::DynamicArray<re::RigGraphDefinition>::deinit(a3);
    long long v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::RigGraphCompiler::~RigGraphCompiler(re::RigGraphCompiler *this)
{
}

uint64_t re::DynamicArray<char const*>::DynamicArray(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    re::DynamicArray<float *>::setCapacity((void *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<char const*>::copy((void *)a1, 0, *(char **)a2, *(void *)(a2 + 8));
  }
  return a1;
}

void *re::DynamicArray<char const*>::copy(void *this, unint64_t a2, char *__src, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unint64_t v5 = a2;
  uint64_t v6 = this;
  unint64_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v12 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(void *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_12;
  }
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + 8 * a2), __src, 8 * a4);
  }
  else
  {
    re::DynamicArray<float *>::growCapacity(this, a2 + a4);
    unint64_t v10 = v6[2] - v5;
    long long v11 = &__src[8 * v10];
    if (v10)
    {
      memmove((void *)(v6[4] + 8 * v5), __src, 8 * v10);
      unint64_t v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + 8 * v5), v11, &__src[8 * v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

uint64_t re::DynamicArray<re::RigGraphNode>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 200 * v4;
        do
        {
          re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit(v3 + 160);
          re::DynamicArray<re::StringID>::deinit(v3 + 120);
          re::DynamicArray<re::RigGraphNodeChild>::deinit(v3 + 80);
          re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(v3 + 40);
          re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(v3);
          v3 += 200;
          v5 -= 200;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigGraphBoundInputParameterData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        do
        {
          re::StringID::destroyString((re::StringID *)(v3 + 16));
          re::StringID::destroyString((re::StringID *)v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshRigGraphIndex>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v4 << 6;
        uint64_t v6 = (re::StringID *)(v3 + 40);
        do
        {
          re::StringID::destroyString(v6);
          re::StringID::destroyString((re::StringID *)((char *)v6 - 16));
          re::StringID::destroyString((re::StringID *)((char *)v6 - 32));
          uint64_t v6 = (re::StringID *)((char *)v6 + 64);
          v5 -= 64;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigGraphDefinition>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 216 * v4;
        do
        {
          re::DynamicArray<re::RigGraphInputValue>::deinit(v3 + v5 + 176);
          re::DynamicArray<re::RigGraphConnection>::deinit((void *)(v3 + v5 + 136));
          re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit(v3 + v5 + 96);
          re::DynamicArray<re::RigGraphParameterProxy>::deinit(v3 + v5 + 56);
          re::DynamicArray<re::RigGraphParameterProxy>::deinit(v3 + v5 + 16);
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 216;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::~__func()
{
}

void *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C23D0;
  return result;
}

void std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C23D0;
}

re *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::RigGraphAsset>((re *)"operator()", 35, *a2);
}

uint64_t std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::RigGraphAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::RigGraphAsset,std::function<void ()(re::RigGraphAsset*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::RigGraphAsset *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::RigGraphAsset *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t std::function<void ()(re::RigGraphAsset *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return re::solverTwoBoneIK(v4);
}

uint64_t re::solverTwoBoneIK(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, __n128 a15, uint64_t a16, unint64_t a17, uint64_t *a18)
{
  if (a18)
  {
    uint64_t v145 = a18[2];
    uint64_t v146 = *a18;
    unint64_t v148 = a18[3];
    unint64_t v149 = a18[1];
    if (a6) {
      goto LABEL_3;
    }
    return 1;
  }
  unint64_t v148 = 0;
  unint64_t v149 = 0;
  uint64_t v145 = 0;
  uint64_t v146 = 0;
  if (!a6) {
    return 1;
  }
LABEL_3:
  unint64_t v20 = 0;
  unint64_t v21 = a17;
  LOBYTE(v22) = 1;
  float v23 = 1.0;
  uint64_t v147 = a6;
  while (v20 != a8)
  {
    unint64_t v24 = *(void *)(a7 + 8 * v20);
    if (a4 <= v24) {
      goto LABEL_46;
    }
    unint64_t v25 = *(void *)(a5 + 8 * v20);
    unint64_t v26 = *(unsigned int *)(a3 + 4 * v24);
    uint64_t v27 = v20;
    uint64_t v28 = (float32x4_t *)&re::solverTwoBoneIK(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *)::kDefaultUpPosition;
    if (a6 != v21)
    {
      uint64_t v27 = 2 * v20;
      if (v21 <= 2 * v20) {
        goto LABEL_50;
      }
      uint64_t v29 = v27 | 1;
      if (v21 <= (v27 | 1uLL)) {
        goto LABEL_51;
      }
      uint64_t v28 = (float32x4_t *)(a16 + 16 * v29);
    }
    float v30 = 0.0;
    if (v20 < v148) {
      float v30 = *(float *)(v145 + 4 * v20);
    }
    float v31 = 0.05;
    if (v20 < v149)
    {
      float v31 = *(float *)(v146 + 4 * v20);
      if (v31 > v23) {
        float v31 = v23;
      }
      if (v31 < 0.0) {
        float v31 = 0.0;
      }
    }
    if (a2 <= v25) {
      goto LABEL_47;
    }
    if (a2 <= v26) {
      goto LABEL_48;
    }
    if (a2 <= v24) {
      goto LABEL_49;
    }
    __int16 v32 = (float32x4_t *)(a1 + (v25 << 6));
    float32x4_t v33 = v32[3];
    long long v34 = (float32x4_t *)(a1 + (v26 << 6));
    float32x4_t v35 = v34[3];
    long long v36 = (float32x4_t *)(a1 + (v24 << 6));
    float32x4_t v37 = *(float32x4_t *)(a16 + 16 * v27);
    float32x4_t v38 = vsubq_f32(v33, v37);
    float32x4_t v159 = vsubq_f32(v33, v35);
    float32x4_t v160 = vsubq_f32(v35, v36[3]);
    float32x4_t v39 = vmulq_f32(v160, v160);
    float32x4_t v40 = vmulq_f32(v159, v159);
    float32x4_t v41 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1);
    a15.n128_f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
    v41.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, v41)).f32[0]);
    float32x4_t v42 = vmulq_f32(v38, v38);
    float32x4_t v43 = vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1));
    v43.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), v43).f32[0]);
    int32x2_t v157 = *(int32x2_t *)v41.f32;
    unint64_t v158 = a15.n128_u64[0];
    float v44 = v31 * (float)(v41.f32[0] + a15.n128_f32[0]);
    float v45 = (float)(v41.f32[0] + a15.n128_f32[0]) - v44;
    float v161 = v41.f32[0] + a15.n128_f32[0];
    float32x4_t v162 = v33;
    if (v43.f32[0] >= v45)
    {
      float32x4_t v163 = v38;
      int32x2_t v165 = *(int32x2_t *)v43.f32;
      float v46 = expf((float)-(float)(v43.f32[0] - v45) / v44);
      float32x4_t v33 = v162;
      float v47 = v45 + (float)(v44 * (float)(1.0 - v46));
      float32x4_t v37 = vsubq_f32(v162, vmulq_n_f32(vdivq_f32(v163, (float32x4_t)vdupq_lane_s32(v165, 0)), v47));
      float32x4_t v38 = vsubq_f32(v162, v37);
      v43.i64[0] = __PAIR64__(v163.u32[1], LODWORD(v47));
    }
    float32x4_t v48 = vsubq_f32(v37, v33);
    float32x4_t v49 = vmulq_f32(v48, v48);
    LODWORD(v50) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).u32[0];
    float32x4_t v155 = v37;
    float32x4_t v164 = v38;
    int32x2_t v166 = *(int32x2_t *)v43.f32;
    if (fabsf(v50) >= 1.0e-10)
    {
      float v51 = v50;
      float32x2_t v52 = vrsqrte_f32((float32x2_t)LODWORD(v50));
      float32x2_t v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)LODWORD(v51), vmul_f32(v52, v52)));
      float32x4_t v48 = vmulq_n_f32(v48, vmul_f32(v53, vrsqrts_f32((float32x2_t)LODWORD(v51), vmul_f32(v53, v53))).f32[0]);
    }
    float32x4_t v156 = v48;
    __float2 v55 = __sincosf_stret(v30 * 0.5);
    *(float32x2_t *)v56.i8 = vmul_n_f32(*(float32x2_t *)v156.f32, v55.__sinval);
    v56.i32[2] = vmuls_lane_f32(v55.__sinval, v156, 2);
    float32x4_t v57 = v162;
    float32x4_t v58 = vsubq_f32(*v28, v162);
    float32x4_t v59 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v56, v56), (int8x16_t)v56, 0xCuLL);
    float32x4_t v60 = vnegq_f32((float32x4_t)v56);
    float32x4_t v61 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), (int8x16_t)v58, 0xCuLL), v60), v58, v59);
    int8x16_t v62 = (int8x16_t)vaddq_f32(v61, v61);
    float32x4_t v63 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), v62, 0xCuLL);
    int8x16_t v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL), v60), v63, v59);
    float32x4_t v65 = vaddq_f32(v162, vaddq_f32(vaddq_f32(v58, vmulq_n_f32(v63, v55.__cosval)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL)));
    if (*(float *)v166.i32 >= v161)
    {
      float32x4_t v79 = vdivq_f32(vnegq_f32(v164), (float32x4_t)vdupq_lane_s32(v166, 0));
      int32x2_t v66 = (int32x2_t)v158;
      float32x4_t v78 = (float32x4_t)vdupq_lane_s32(v157, 0);
      float32x4_t v77 = vaddq_f32(v162, vmulq_n_f32(v79, *(float *)v157.i32));
      float32x4_t v69 = vaddq_f32(v162, vmulq_n_f32(v79, v161));
    }
    else
    {
      int32x2_t v66 = (int32x2_t)v158;
      float v67 = (float)((float)((float)(*(float *)v66.i32 * *(float *)v66.i32)
                          + (float)(*(float *)v166.i32 * *(float *)v166.i32))
                  - (float)(*(float *)v157.i32 * *(float *)v157.i32))
          / (float)(*(float *)v166.i32 + *(float *)v166.i32);
      float32x4_t v68 = vdivq_f32(v164, (float32x4_t)vdupq_lane_s32(v166, 0));
      float32x4_t v69 = v155;
      float32x4_t v70 = vaddq_f32(v155, vmulq_n_f32(v68, v67));
      float v71 = sqrtf((float)(*(float *)v66.i32 * *(float *)v66.i32) - (float)(v67 * v67));
      float32x4_t v72 = vmulq_f32(v68, vsubq_f32(v65, v70));
      float32x4_t v73 = vsubq_f32(vsubq_f32(v65, vmulq_n_f32(v68, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 2), vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 1))).f32[0])), v70);
      int32x4_t v74 = (int32x4_t)vmulq_f32(v73, v73);
      v74.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v74, 2), vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v74.i8, 1))).u32[0];
      float32x2_t v75 = vrsqrte_f32((float32x2_t)v74.u32[0]);
      float32x2_t v76 = vmul_f32(v75, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v75, v75)));
      float32x4_t v77 = vaddq_f32(v70, vmulq_n_f32(vmulq_n_f32(v73, vmul_f32(v76, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v76, v76))).f32[0]), v71));
      float32x4_t v78 = (float32x4_t)vdupq_lane_s32(v157, 0);
    }
    unint64_t v21 = a17;
    a6 = v147;
    float32x4_t v80 = (float32x4_t)vdupq_lane_s32(v66, 0);
    float32x4_t v81 = vdivq_f32(v160, v80);
    float32x4_t v82 = vdivq_f32(v159, v78);
    float32x4_t v83 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), (int8x16_t)v81, 0xCuLL);
    float32x4_t v84 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL);
    float32x4_t v85 = vnegq_f32(v81);
    float32x4_t v86 = vmlaq_f32(vmulq_f32(v84, v85), v82, v83);
    float32x4_t v87 = vmulq_f32(v86, v86);
    int32x2_t v88 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v87, 2), v87)).u64[0];
    *(float *)v88.i32 = sqrtf(*(float *)v88.i32);
    if (*(float *)v88.i32 <= 0.01)
    {
      float32x4_t v90 = v34[2];
      int32x4_t v91 = (int32x4_t)vmulq_f32(v90, v90);
      v91.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v91, 2), vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v91.i8, 1))).u32[0];
      float32x2_t v92 = vrsqrte_f32((float32x2_t)v91.u32[0]);
      float32x2_t v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v92, v92)));
      float32x4_t v89 = vmulq_n_f32(v90, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v93, v93))).f32[0]);
    }
    else
    {
      float32x4_t v89 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v86, (int32x4_t)v86), (int8x16_t)v86, 0xCuLL), (float32x4_t)vdupq_lane_s32(v88, 0));
    }
    uint64_t v94 = 0;
    float32x4_t v95 = vsubq_f32(v65, v69);
    float32x4_t v96 = vsubq_f32(v162, v65);
    float32x4_t v97 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), (int8x16_t)v96, 0xCuLL), vnegq_f32(v95)), v96, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL));
    float32x4_t v98 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v97, (int32x4_t)v97), (int8x16_t)v97, 0xCuLL);
    int32x4_t v99 = (int32x4_t)vmulq_f32(v97, v97);
    v99.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v99.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v99, 2), *(float32x2_t *)v99.i8)).u32[0];
    float32x2_t v100 = vrsqrte_f32((float32x2_t)v99.u32[0]);
    float32x2_t v101 = vmul_f32(v100, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v100, v100)));
    float32x4_t v102 = vmulq_n_f32(v98, vmul_f32(v101, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v101, v101))).f32[0]);
    float32x4_t v103 = vdivq_f32(vsubq_f32(v162, v77), v78);
    float32x4_t v104 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL);
    int8x16_t v105 = (int8x16_t)vmlaq_f32(vmulq_f32(v104, vnegq_f32(v82)), v89, v84);
    int32x4_t v106 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v105, (int32x4_t)v105), v105, 0xCuLL);
    float32x4_t v107 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v102, (int32x4_t)v102), (int8x16_t)v102, 0xCuLL);
    int8x16_t v108 = (int8x16_t)vmlaq_f32(vmulq_f32(v107, vnegq_f32(v103)), v102, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
    float32x4_t v109 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v108, (int32x4_t)v108), v108, 0xCuLL);
    int32x4_t v110 = vzip1q_s32((int32x4_t)v82, v106);
    int32x4_t v111 = vzip2q_s32((int32x4_t)v82, v106);
    int32x4_t v112 = vzip1q_s32((int32x4_t)v89, (int32x4_t)0);
    int32x4_t v113 = vdupq_laneq_s32((int32x4_t)v89, 2);
    int32x4_t v114 = vzip1q_s32(v110, (int32x4_t)v89);
    int32x4_t v167 = v114;
    int32x4_t v168 = vzip2q_s32(v110, v112);
    int32x4_t v169 = vzip1q_s32(v111, v113);
    do
    {
      float32x4_t v115 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v103, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v94))), v102, *(float32x2_t *)&v167.i8[v94], 1), v109, *(float32x4_t *)((char *)&v167 + v94), 2);
      *(float32x4_t *)((char *)&v170 + v94) = v115;
      v94 += 16;
    }
    while (v94 != 48);
    uint64_t v116 = 0;
    float32x4_t v117 = v170;
    float32x4_t v118 = v171;
    float32x4_t v119 = (float32x4_t)v172;
    v115.i64[0] = v32->i64[0];
    v114.i64[0] = v32[1].i64[0];
    v54.i64[0] = v32[2].i64[0];
    v115.i32[2] = v32->i32[2];
    v114.i32[2] = v32[1].i32[2];
    v54.i32[2] = v32[2].i32[2];
    int32x4_t v167 = (int32x4_t)v115;
    int32x4_t v168 = v114;
    int32x4_t v169 = v54;
    do
    {
      *(float32x4_t *)((char *)&v170 + v116) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v117, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v116))), v118, *(float32x2_t *)&v167.i8[v116], 1), v119, *(float32x4_t *)((char *)&v167 + v116), 2);
      v116 += 16;
    }
    while (v116 != 48);
    uint64_t v120 = 0;
    float32x4_t v121 = v170;
    float32x4_t v122 = v171;
    v121.i32[3] = 0;
    v122.i32[3] = 0;
    __n128 v123 = v172;
    v123.n128_u32[3] = 0;
    float v23 = 1.0;
    v57.i32[3] = 1.0;
    float32x4_t *v32 = v121;
    v32[1] = v122;
    v32[2] = (float32x4_t)v123;
    v32[3] = v57;
    float32x4_t v124 = vdivq_f32(vsubq_f32(v77, v69), v80);
    int8x16_t v125 = (int8x16_t)vmlaq_f32(vmulq_f32(v104, v85), v89, v83);
    int32x4_t v126 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v125, (int32x4_t)v125), v125, 0xCuLL);
    int8x16_t v127 = (int8x16_t)vmlaq_f32(vmulq_f32(v107, vnegq_f32(v124)), v102, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v124, (int32x4_t)v124), (int8x16_t)v124, 0xCuLL));
    float32x4_t v128 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v127, (int32x4_t)v127), v127, 0xCuLL);
    int32x4_t v129 = vzip1q_s32((int32x4_t)v81, v126);
    int32x4_t v130 = vzip2q_s32((int32x4_t)v81, v126);
    int32x4_t v131 = vzip1q_s32(v129, v112);
    int32x4_t v132 = vzip2q_s32(v129, v112);
    int32x4_t v167 = v131;
    int32x4_t v168 = v132;
    int32x4_t v169 = vzip1q_s32(v130, v113);
    do
    {
      float32x4_t v133 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v124, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v120))), v102, *(float32x2_t *)&v167.i8[v120], 1), v128, *(float32x4_t *)((char *)&v167 + v120), 2);
      *(float32x4_t *)((char *)&v170 + vre::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v133;
      v120 += 16;
    }
    while (v120 != 48);
    uint64_t v134 = 0;
    float32x4_t v135 = v170;
    float32x4_t v136 = v171;
    float32x4_t v137 = (float32x4_t)v172;
    v133.i64[0] = v34->i64[0];
    v132.i64[0] = v34[1].i64[0];
    v102.i64[0] = v34[2].i64[0];
    v133.i32[2] = v34->i32[2];
    v132.i32[2] = v34[1].i32[2];
    v102.i32[2] = v34[2].i32[2];
    int32x4_t v167 = (int32x4_t)v133;
    int32x4_t v168 = v132;
    int32x4_t v169 = (int32x4_t)v102;
    do
    {
      *(float32x4_t *)((char *)&v170 + v134) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v135, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v134))), v136, *(float32x2_t *)&v167.i8[v134], 1), v137, *(float32x4_t *)((char *)&v167 + v134), 2);
      v134 += 16;
    }
    while (v134 != 48);
    uint64_t v138 = 0;
    int32x4_t v139 = (int32x4_t)v170;
    int32x4_t v140 = (int32x4_t)v171;
    v139.i32[3] = 0;
    v140.i32[3] = 0;
    a15 = v172;
    a15.n128_u32[3] = 0;
    v77.i32[3] = 1.0;
    float32x4_t *v34 = (float32x4_t)v139;
    v34[1] = (float32x4_t)v140;
    v34[2] = (float32x4_t)a15;
    v34[3] = v77;
    v77.i64[0] = v36->i64[0];
    v139.i64[0] = v36[1].i64[0];
    v140.i64[0] = v36[2].i64[0];
    v77.i32[2] = v36->i32[2];
    v139.i32[2] = v36[1].i32[2];
    v140.i32[2] = v36[2].i32[2];
    int32x4_t v167 = (int32x4_t)v77;
    int32x4_t v168 = v139;
    int32x4_t v169 = v140;
    do
    {
      *(float32x4_t *)((char *)&v170 + v138) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v135, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v138))), v136, *(float32x2_t *)&v167.i8[v138], 1), v137, *(float32x4_t *)((char *)&v167 + v138), 2);
      v138 += 16;
    }
    while (v138 != 48);
    float32x4_t v141 = v170;
    float32x4_t v142 = v171;
    v141.i32[3] = 0;
    v142.i32[3] = 0;
    __n128 v143 = v172;
    v143.n128_u32[3] = 0;
    v69.i32[3] = 1.0;
    float32x4_t *v36 = v141;
    v36[1] = v142;
    v36[2] = (float32x4_t)v143;
    v36[3] = v69;
    uint64_t v22 = v22 & (*(float *)v166.i32 < v161);
    if (++v20 == v147) {
      return v22;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a8, a8);
  _os_crash();
  __break(1u);
LABEL_46:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v24, a4);
  _os_crash();
  __break(1u);
LABEL_47:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v25, a2);
  _os_crash();
  __break(1u);
LABEL_48:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v26, a2);
  _os_crash();
  __break(1u);
LABEL_49:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v24, a2);
  _os_crash();
  __break(1u);
LABEL_50:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v27, v21);
  _os_crash();
  __break(1u);
LABEL_51:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v29, v21);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::solverFABRIK(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v14 = a8;
  uint64_t v15 = a7;
  unint64_t v18 = a2;
  uint64_t v83 = *MEMORY[0x263EF8340];
  if (a11)
  {
    float v20 = *(float *)a11;
    unsigned int v56 = *(_DWORD *)(a11 + 4);
  }
  else
  {
    unsigned int v56 = 32;
    float v20 = 0.1;
  }
  if (a6)
  {
    uint64_t v21 = 0;
    float v22 = v20 * v20;
    LODWORD(result) = 1;
    while (1)
    {
      if (v21 == v14) {
        goto LABEL_68;
      }
      if (v21 == a10) {
        goto LABEL_69;
      }
      unint64_t v24 = *(void *)(a5 + 8 * v21);
      if (v18 <= v24) {
        goto LABEL_70;
      }
      unint64_t v25 = *(void *)(v15 + 8 * v21);
      float32x4_t v68 = *(float32x4_t *)(a1 + (v24 << 6) + 48);
      unint64_t v26 = 1;
      if (v25 != v24) {
        break;
      }
LABEL_13:
      uint64_t v54 = v21;
      unint64_t v55 = v25;
      int v53 = result;
      char v67 = 0;
      v66[0] = &unk_26E6DEC70;
      v66[1] = "Scratch Pad";
      uint64_t v63 = 0;
      unint64_t v64 = 0;
      float32x4_t v65 = 0;
      re::FixedArray<re::Vector3<float>>::init<>(&v63, (uint64_t)v66, v26);
      uint64_t v60 = 0;
      unint64_t v61 = 0;
      uint64_t v62 = 0;
      unint64_t v57 = v26 - 1;
      re::FixedArray<int>::init<>(&v60, (uint64_t)v66, v26 - 1);
      if (v26)
      {
        unint64_t v13 = 0;
        unint64_t v29 = v55;
        while (v18 > v29)
        {
          unint64_t v11 = v64;
          if (v64 <= v13) {
            goto LABEL_58;
          }
          v65[v13] = *(float32x4_t *)(a1 + (v29 << 6) + 48);
          if (v13)
          {
            unint64_t v11 = v64;
            if (v64 <= v13) {
              goto LABEL_65;
            }
            unint64_t v12 = v13 - 1;
            unint64_t v11 = v61;
            if (v61 <= v13 - 1) {
              goto LABEL_66;
            }
            float32x4_t v30 = vsubq_f32(v65[v13], v65[v13 - 1]);
            float32x4_t v31 = vmulq_f32(v30, v30);
            *(float *)(v62 + 4 * v13 - 4) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0]);
          }
          if ((unint64_t)a4 <= v29) {
            goto LABEL_59;
          }
          ++v13;
          unint64_t v29 = *(unsigned int *)(a3 + 4 * v29);
          if (v26 == v13) {
            goto LABEL_23;
          }
        }
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v29, v18);
        _os_crash();
        __break(1u);
LABEL_58:
        uint64_t v69 = 0;
        a4 = &v70;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        unint64_t v18 = &_os_log_internal;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v70 = 136315906;
        float v71 = "operator[]";
        __int16 v72 = 1024;
        int v73 = 468;
        __int16 v74 = 2048;
        unint64_t v75 = v13;
        __int16 v76 = 2048;
        unint64_t v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_59:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v29, a4);
        _os_crash();
        __break(1u);
LABEL_60:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v18);
        _os_crash();
        __break(1u);
LABEL_61:
        uint64_t v69 = 0;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v70 = 136315906;
        float v71 = "operator[]";
        __int16 v72 = 1024;
        int v73 = 468;
        __int16 v74 = 2048;
        unint64_t v75 = v11;
        __int16 v76 = 2048;
        unint64_t v77 = v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_62:
        uint64_t v69 = 0;
        a4 = &v70;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v70 = 136315906;
        float v71 = "operator[]";
        __int16 v72 = 1024;
        int v73 = 468;
        __int16 v74 = 2048;
        unint64_t v75 = v14;
        __int16 v76 = 2048;
        unint64_t v77 = v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a4);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v27, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        uint64_t v69 = 0;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v70 = 136315906;
        float v71 = "operator[]";
        __int16 v72 = 1024;
        int v73 = 468;
        __int16 v74 = 2048;
        unint64_t v75 = v13;
        __int16 v76 = 2048;
        unint64_t v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_66:
        uint64_t v69 = 0;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v78 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v70 = 136315906;
        float v71 = "operator[]";
        __int16 v72 = 1024;
        int v73 = 468;
        __int16 v74 = 2048;
        unint64_t v75 = v12;
        __int16 v76 = 2048;
        unint64_t v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_67;
      }
LABEL_23:
      if (!v64) {
        goto LABEL_71;
      }
      unint64_t v13 = 1;
      if (v56)
      {
        unint64_t v26 = a9 + 16 * v54;
        float32x4_t v32 = vsubq_f32(*v65, *(float32x4_t *)v26);
        float32x4_t v33 = vmulq_f32(v32, v32);
        float v34 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0];
        if (v34 > v22)
        {
          LODWORD(v11) = 1;
          while (1)
          {
            float v58 = v34;
            if (!v64) {
              break;
            }
            float32x4_t v35 = vsubq_f32(*v65, *(float32x4_t *)v26);
            float32x4_t v36 = vmulq_f32(v35, v35);
            float v34 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
            unint64_t v13 = (float)(v58 - v34) > v20;
            BOOL v37 = (float)(v58 - v34) <= v20 || v11 >= v56;
            unint64_t v11 = (v11 + 1);
            if (v37 || v34 <= v22) {
              goto LABEL_35;
            }
          }
LABEL_67:
          uint64_t v69 = 0;
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          long long v78 = 0u;
          unint64_t v18 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v70 = 136315906;
          float v71 = "operator[]";
          __int16 v72 = 1024;
          int v73 = 468;
          __int16 v74 = 2048;
          unint64_t v75 = 0;
          __int16 v76 = 2048;
          unint64_t v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_68:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, v14);
          _os_crash();
          __break(1u);
LABEL_69:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a10, a10);
          _os_crash();
          __break(1u);
LABEL_70:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v24, v18);
          _os_crash();
          __break(1u);
LABEL_71:
          uint64_t v69 = 0;
          a4 = &v70;
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          long long v78 = 0u;
          unint64_t v18 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v70 = 136315906;
          float v71 = "operator[]";
          __int16 v72 = 1024;
          int v73 = 468;
          __int16 v74 = 2048;
          unint64_t v75 = 0;
          __int16 v76 = 2048;
          unint64_t v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_72:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v39, a4);
          _os_crash();
          __break(1u);
LABEL_73:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v39, v18);
          _os_crash();
          __break(1u);
LABEL_74:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v18);
          _os_crash();
          __break(1u);
LABEL_75:
          uint64_t v69 = 0;
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          long long v78 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v70 = 136315906;
          float v71 = "operator[]";
          __int16 v72 = 1024;
          int v73 = 468;
          __int16 v74 = 2048;
          unint64_t v75 = 0;
          __int16 v76 = 2048;
          unint64_t v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_35:
      unint64_t v39 = v55;
      if ((unint64_t)a4 <= v55) {
        goto LABEL_72;
      }
      if (v18 <= v55) {
        goto LABEL_73;
      }
      unint64_t v12 = *(unsigned int *)(a3 + 4 * v55);
      uint64_t v52 = a1 + (v55 << 6);
      if (v57)
      {
        unint64_t v14 = 0;
        float32x4_t v40 = *(float32x4_t *)(a1 + (v55 << 6) + 48);
        unsigned int v41 = 1;
        do
        {
          if (v18 <= v12) {
            goto LABEL_60;
          }
          unint64_t v11 = v41;
          unint64_t v26 = v64;
          if (v64 <= v41) {
            goto LABEL_61;
          }
          if (v64 <= v14) {
            goto LABEL_62;
          }
          unint64_t v26 = a1 + (v12 << 6);
          float32x4_t v59 = *(float32x4_t *)(v26 + 48);
          *(_OWORD *)unint64_t v26 = v78;
          *(_OWORD *)(v26 + 16) = v79;
          *(_OWORD *)(v26 + 32) = v80;
          *(_OWORD *)(v26 + 48) = v81;
          if ((unint64_t)a4 <= v12) {
            goto LABEL_63;
          }
          unint64_t v12 = *(unsigned int *)(a3 + 4 * v12);
          ++v41;
          float32x4_t v40 = v59;
          unint64_t v14 = v11;
        }
        while (v57 > v11);
        unint64_t v12 = *(unsigned int *)(a3 + 4 * v55);
        uint64_t v15 = a7;
        unint64_t v14 = a8;
      }
      if (v18 <= v12) {
        goto LABEL_74;
      }
      float32x4_t v42 = (long long *)(a1 + (v12 << 6));
      long long v43 = v42[3];
      long long v45 = *v42;
      long long v44 = v42[1];
      *(_OWORD *)(v52 + 32) = v42[2];
      *(_OWORD *)(v52 + 48) = v43;
      *(_OWORD *)uint64_t v52 = v45;
      *(_OWORD *)(v52 + 16) = v44;
      if (!v64) {
        goto LABEL_75;
      }
      float32x4_t v46 = *v65;
      v46.i32[3] = *(_DWORD *)(v52 + 60);
      *(float32x4_t *)(v52 + 48) = v46;
      if (v60)
      {
        uint64_t v47 = 1;
        if (v61)
        {
          (*(void (**)(void))(*(void *)v60 + 40))();
          uint64_t v47 = v64;
        }
      }
      else
      {
        uint64_t v47 = 1;
      }
      if (v63)
      {
        if (v47) {
          (*(void (**)(void))(*(void *)v63 + 40))();
        }
      }
      re::Allocator::~Allocator((re::Allocator *)v66);
      uint64_t result = v53 & v13;
      uint64_t v21 = v54 + 1;
      if (v54 + 1 == a6) {
        return result;
      }
    }
    unint64_t v27 = v25;
    while ((unint64_t)a4 > v27)
    {
      ++v26;
      unint64_t v27 = *(unsigned int *)(a3 + 4 * v27);
      if (v24 == v27) {
        goto LABEL_13;
      }
    }
    goto LABEL_64;
  }
  return 1;
}

float re::getTwistAngle(uint64_t a1, float32x4_t a2)
{
  v2.i64[0] = *(void *)(a1 + 4);
  float32x4_t v3 = *(float32x4_t *)a1;
  float32x4_t v4 = vmulq_f32(v3, v3);
  LODWORD(v5) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  if (fabsf(v5) >= 1.0e-10)
  {
    float v6 = v5;
    float32x2_t v7 = vrsqrte_f32((float32x2_t)LODWORD(v5));
    float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)LODWORD(v6), vmul_f32(v7, v7)));
    float32x4_t v3 = vmulq_n_f32(v3, vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v6), vmul_f32(v8, v8))).f32[0]);
  }
  float32x4_t v9 = vmulq_f32(a2, a2);
  LODWORD(v10) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).u32[0];
  if (fabsf(v10) >= 1.0e-10)
  {
    float v11 = v10;
    float32x2_t v12 = vrsqrte_f32((float32x2_t)LODWORD(v10));
    float32x2_t v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v11), vmul_f32(v12, v12)));
    a2 = vmulq_n_f32(a2, vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v11), vmul_f32(v13, v13))).f32[0]);
  }
  v2.i32[2] = *(_DWORD *)a1;
  float32x4_t v14 = vmulq_f32(v3, a2);
  int32x2_t v15 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u64[0];
  if (*(float *)v15.i32 == -1.0
    || (float v16 = (float)((float)(fabsf(*(float *)v15.i32) + 1.0) + 1.0) * 0.00001,
        *(float *)v15.i32 = *(float *)v15.i32 + 1.0,
        fabsf(*(float *)v15.i32) < v16))
  {
    if (fabsf(v3.f32[2]) >= 0.00001)
    {
      v17.i32[0] = 0;
      v17.f32[1] = -v3.f32[2];
      v17.i64[1] = v3.u32[1];
    }
    else
    {
      float32x4_t v17 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v3.f32[1]), (int32x4_t)v3);
    }
    int32x4_t v18 = (int32x4_t)vmulq_f32(v17, v17);
    v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
    float32x2_t v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
    float32x2_t v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
    float32x4_t v21 = vmulq_n_f32(v17, vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
    v17.i64[0] = 0;
  }
  else
  {
    int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a2, (int32x4_t)a2), (int8x16_t)a2, 0xCuLL), vnegq_f32(v3)), a2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL));
    float32x4_t v17 = (float32x4_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22);
    float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v17, v22, 0xCuLL);
    *(float *)v15.i32 = sqrtf(*(float *)v15.i32 + *(float *)v15.i32);
    v17.f32[0] = *(float *)v15.i32 * 0.5;
    float32x4_t v21 = vdivq_f32(v23, (float32x4_t)vdupq_lane_s32(v15, 0));
  }
  float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL);
  float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL);
  float32x4_t v26 = vnegq_f32(v21);
  float32x4_t v27 = vmlaq_f32(vmulq_f32(v25, v26), v2, v24);
  int8x16_t v28 = (int8x16_t)vaddq_f32(v27, v27);
  float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), v28, 0xCuLL);
  int8x16_t v30 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL), v26), v29, v24);
  float32x4_t v31 = vaddq_f32(vaddq_f32(v2, vmulq_n_f32(v29, v17.f32[0])), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL));
  float32x4_t v32 = vmulq_f32(v31, v31);
  LODWORD(v33) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).u32[0];
  if (fabsf(v33) >= 1.0e-10)
  {
    float v34 = v33;
    float32x2_t v35 = vrsqrte_f32((float32x2_t)LODWORD(v33));
    float32x2_t v36 = vmul_f32(v35, vrsqrts_f32((float32x2_t)LODWORD(v34), vmul_f32(v35, v35)));
    float32x4_t v31 = vmulq_n_f32(v31, vmul_f32(v36, vrsqrts_f32((float32x2_t)LODWORD(v34), vmul_f32(v36, v36))).f32[0]);
  }
  float32x4_t v37 = vmulq_f32(v2, v2);
  LODWORD(v38) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u32[0];
  float32x4_t v39 = v2;
  if (fabsf(v38) >= 1.0e-10)
  {
    float v40 = v38;
    float32x2_t v41 = vrsqrte_f32((float32x2_t)LODWORD(v38));
    float32x2_t v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v41, v41)));
    float32x4_t v39 = vmulq_n_f32(v2, vmul_f32(v42, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v42, v42))).f32[0]);
    float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL);
  }
  float32x4_t v73 = v2;
  float32x4_t v43 = v21;
  v43.i32[3] = v17.i32[0];
  float32x4_t v44 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 0);
  float32x4_t v45 = vmulq_f32(v31, v39);
  float v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0];
  if (v46 == -1.0 || (float v47 = (float)((float)(fabsf(v46) + 1.0) + 1.0) * 0.00001, v48 = v46 + 1.0, fabsf(v48) < v47))
  {
    if (fabsf(v31.f32[2]) >= 0.00001)
    {
      v49.i32[0] = 0;
      v49.f32[1] = -v31.f32[2];
      v49.i64[1] = v31.u32[1];
    }
    else
    {
      float32x4_t v49 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v31.f32[1]), (int32x4_t)v31);
    }
    int32x4_t v50 = (int32x4_t)vmulq_f32(v49, v49);
    v50.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1))).u32[0];
    float32x2_t v51 = vrsqrte_f32((float32x2_t)v50.u32[0]);
    float32x2_t v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v51, v51)));
    float32x4_t v53 = vmulq_n_f32(v49, vmul_f32(v52, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v52, v52))).f32[0]);
    float v54 = 0.0;
  }
  else
  {
    int8x16_t v55 = (int8x16_t)vmlaq_f32(vmulq_f32(v25, vnegq_f32(v31)), v39, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL));
    float32x4_t v56 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), v55, 0xCuLL);
    v39.f32[0] = sqrtf(v48 + v48);
    float v54 = v39.f32[0] * 0.5;
    float32x4_t v53 = vdivq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
  }
  float32x4_t v57 = v53;
  v57.f32[3] = v54;
  int8x16_t v58 = (int8x16_t)vmlaq_f32(vmulq_f32(v24, vnegq_f32(v53)), v21, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL));
  float32x4_t v59 = vmlaq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), v58, 0xCuLL), v21, v54), v53, v44);
  float32x4_t v60 = vmulq_f32(v43, v57);
  float v61 = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), vaddq_f32(v60, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1))).f32[0]- (float)(v54 * v17.f32[0]));
  float32x4_t v62 = v59;
  v62.f32[3] = v61;
  float32x4_t v63 = vmulq_f32(v62, v62);
  LODWORD(v64) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1))).u32[0];
  float32x4_t v65 = 0uLL;
  if (fabsf(v64) >= 1.0e-10)
  {
    float v66 = v64;
    float32x2_t v67 = vrsqrte_f32((float32x2_t)LODWORD(v64));
    float32x2_t v68 = vmul_f32(v67, vrsqrts_f32((float32x2_t)LODWORD(v66), vmul_f32(v67, v67)));
    float32x4_t v65 = vmulq_n_f32(v59, vmul_f32(v68, vrsqrts_f32((float32x2_t)LODWORD(v66), vmul_f32(v68, v68))).f32[0]);
  }
  float32x4_t v72 = v65;
  float v69 = acosf(v61);
  float32x4_t v70 = vmulq_f32(v73, v72);
  return (float)(v69 + v69)
       * vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 2), vaddq_f32(v70, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v70.f32, 1))).f32[0];
}

uint64_t re::solverSplineIK(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t *a9, void **a10, unint64_t a11)
{
  float v16 = a10;
  unint64_t v17 = a11;
  unint64_t v18 = (unint64_t)a9;
  uint64_t v151 = *MEMORY[0x263EF8340];
  float v19 = *(float *)a11;
  float v20 = *(float *)(a11 + 64);
  if (*(unsigned char *)(a11 + 25))
  {
    unint64_t v21 = (unint64_t)a10 - 1;
    if (!a10)
    {
LABEL_138:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, 0);
      _os_crash();
      __break(1u);
      goto LABEL_139;
    }
    float v20 = v20 + re::getTwistAngle(a11 + 48, (float32x4_t)a9[v21]);
  }
  else
  {
    unint64_t v21 = (unint64_t)a10;
  }
  if (*(unsigned char *)(a11 + 24))
  {
    if ((unint64_t)a10 <= --v21)
    {
LABEL_139:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v16);
      _os_crash();
      __break(1u);
LABEL_140:
      uint64_t v137 = 0;
      long long v149 = 0u;
      long long v150 = 0u;
      long long v147 = 0u;
      long long v148 = 0u;
      int32x4_t v146 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v138 = 136315906;
      int32x4_t v139 = "operator[]";
      __int16 v140 = 1024;
      int v141 = 468;
      __int16 v142 = 2048;
      unint64_t v143 = v11;
      __int16 v144 = 2048;
      unint64_t v145 = v18;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_141;
    }
    float TwistAngle = re::getTwistAngle(a11 + 32, (float32x4_t)a9[v21]);
  }
  else
  {
    float TwistAngle = 0.0;
  }
  v117[0] = 0;
  v117[1] = 0;
  int v119 = 0;
  unint64_t v118 = 0;
  uint64_t v125 = 0;
  memset(v120, 0, sizeof(v120));
  int v121 = 0;
  long long v122 = 0u;
  long long v123 = 0u;
  int v124 = 0;
  uint64_t v126 = 0x3F80000000000000;
  char v127 = 1;
  uint64_t v116 = (void (**)(void **))&unk_26E6C2460;
  int v23 = *(_DWORD *)(a11 + 16);
  unint64_t v11 = (v23 - 5);
  float32x4_t v98 = (unsigned int *)a5;
  unint64_t v24 = (unint64_t)a9;
  if ((_WORD)v23 == 5)
  {
    int v119 = 1;
    __int16 v128 = 0;
  }
  else
  {
    re::DynamicArray<re::Vector3<float>>::resize((uint64_t)v117, (unsigned __int16)(3 * (v23 - 5) + 1));
    __int16 v128 = v23 - 5;
    if (!v127) {
      re::DynamicArray<float>::resize((uint64_t)v120 + 8, (unsigned __int16)(v23 - 5) + 1);
    }
  }
  a5 = (unint64_t)&v116;
  v116[11]((void **)&v116);
  uint64_t v27 = (v23 - 2);
  if (v27 >= 3)
  {
    unint64_t v18 = 2;
    while (1)
    {
      unint64_t v28 = *(void *)(a11 + 16);
      if (v28 <= v18) {
        break;
      }
      ((void (*)(void (***)(void **), void, float))v116[13])(&v116, (v18 - 2), *(float *)(*(void *)(a11 + 8) + 4 * v18));
      if (v27 == ++v18) {
        goto LABEL_17;
      }
    }
LABEL_121:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, v28);
    _os_crash();
    __break(1u);
LABEL_122:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v11;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_123:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v11;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_124:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v12;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_125:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v18;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_126:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a7;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_127:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v18;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_128;
  }
LABEL_17:
  if (!v21) {
    goto LABEL_131;
  }
  a5 = (unint64_t)&v138;
  if (!v118)
  {
LABEL_132:
    v135[0] = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    *(void *)(a5 + 4) = "operator[]";
    __int16 v140 = 1024;
    *(_DWORD *)(a5 + 14) = 789;
    __int16 v142 = 2048;
    *(void *)(a5 + 20) = 0;
    __int16 v144 = 2048;
    *(void *)(a5 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_133:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_134;
  }
  float32x4_t v97 = (unint64_t *)a7;
  int32x4_t v29 = *a9;
  **(_OWORD **)&v120[0] = *a9;
  uint64_t v108 = a1;
  if (v11)
  {
    unint64_t v18 = (unint64_t)a9;
    a5 = 0;
    uint64_t v30 = 0;
    a7 = 1;
    unint64_t v109 = v21;
    unint64_t v106 = v11;
    while (1)
    {
      uint64_t v31 = v30 + 2;
      unint64_t v32 = *(void *)(v17 + 16);
      if (v32 <= v30 + 2) {
        goto LABEL_112;
      }
      uint64_t v33 = v30 + 3;
      if (v32 <= v30 + 3) {
        break;
      }
      if (v21 == v30) {
        goto LABEL_114;
      }
      uint64_t v34 = *(void *)(v17 + 8);
      v29.i32[0] = *(_DWORD *)(v34 + 4 * v30 + 8);
      v26.i32[0] = *(_DWORD *)(v34 + 4 * v30 + 12);
      int32x4_t v112 = v29;
      int32x2_t v113 = v26;
      uint64_t v35 = v34 + a5;
      v29.i32[1] = v29.i32[0];
      v29.i32[2] = v26.i32[0];
      int32x4_t v146 = v29;
      unint64_t v17 = v36;
      int32x4_t v37 = v112;
      v37.i32[1] = v113.i32[0];
      v37.i32[2] = v113.i32[0];
      int32x4_t v146 = v37;
      a1 = v38;
      int32x4_t v146 = vdupq_lane_s32(v113, 0);
      unint64_t v11 = v18;
      unint64_t v24 = (unsigned __int16)a7;
      unint64_t v18 = v118;
      if (v118 <= (unsigned __int16)a7) {
        goto LABEL_115;
      }
      float v40 = (unint64_t *)(*(void *)&v120[0] + 16 * (unsigned __int16)a7);
      *float v40 = v21;
      v40[1] = v17;
      unint64_t v21 = (unsigned __int16)(a7 + 1);
      unint64_t v17 = v118;
      if (v118 <= v21) {
        goto LABEL_116;
      }
      float32x2_t v41 = (uint64_t *)(*(void *)&v120[0] + 16 * v21);
      *float32x2_t v41 = v12;
      v41[1] = a1;
      unint64_t v21 = (unsigned __int16)(a7 + 2);
      a1 = v118;
      if (v118 <= v21) {
        goto LABEL_117;
      }
      float32x2_t v42 = (uint64_t *)(*(void *)&v120[0] + 16 * v21);
      *float32x2_t v42 = v39;
      v42[1] = v25;
      a7 = (a7 + 3);
      ++v30;
      unint64_t v18 = v11 + 16;
      a5 += 4;
      unint64_t v11 = v106;
      a1 = v108;
      unint64_t v21 = v109;
      unint64_t v17 = a11;
      if (v106 == v30) {
        goto LABEL_28;
      }
    }
LABEL_113:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v33, v32);
    _os_crash();
    __break(1u);
LABEL_114:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v21);
    _os_crash();
    __break(1u);
LABEL_115:
    v135[0] = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 789;
    __int16 v142 = 2048;
    unint64_t v143 = v24;
    __int16 v144 = 2048;
    unint64_t v145 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_116:
    v135[0] = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 789;
    __int16 v142 = 2048;
    unint64_t v143 = v21;
    __int16 v144 = 2048;
    unint64_t v145 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_117:
    v135[0] = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    unint64_t v43 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 789;
    __int16 v142 = 2048;
    unint64_t v143 = v21;
    __int16 v144 = 2048;
    unint64_t v145 = a1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_118;
  }
LABEL_28:
  if (!a6) {
    goto LABEL_133;
  }
  if (!a8)
  {
LABEL_134:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_135:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    float v16 = (void **)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v24;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_136:
    re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, a1);
    _os_crash();
    __break(1u);
    goto LABEL_137;
  }
  unint64_t v24 = *v98;
  unint64_t v17 = *v97;
  char v136 = 0;
  v135[0] = &unk_26E6DEC70;
  v135[1] = "Scratch Pad";
  unint64_t v43 = a2;
  unint64_t v21 = a2;
  uint64_t v132 = 0;
  unint64_t v133 = 0;
  unint64_t v134 = 0;
  re::FixedArray<re::Vector3<float>>::init<>(&v132, (uint64_t)v135, a2);
  uint64_t v129 = 0;
  unint64_t v130 = 0;
  uint64_t v131 = 0;
  re::FixedArray<int>::init<>(&v129, (uint64_t)v135, a2);
  unint64_t v45 = a4;
  if (a2)
  {
    unint64_t v18 = 0;
    unint64_t v46 = v17;
    while (a2 > v46)
    {
      a5 = v133;
      if (v133 <= v18) {
        goto LABEL_119;
      }
      *(_OWORD *)(v134 + 16 * v18) = *(_OWORD *)(a1 + (v46 << 6) + 48);
      if (v18)
      {
        a5 = v133;
        if (v133 <= v18) {
          goto LABEL_125;
        }
        a7 = v18 - 1;
        if (v133 <= v18 - 1) {
          goto LABEL_126;
        }
        a5 = v130;
        if (v130 <= v18) {
          goto LABEL_127;
        }
        float32x4_t v47 = vsubq_f32(*(float32x4_t *)(v134 + 16 * v18), *(float32x4_t *)(v134 + 16 * v18 - 16));
        float32x4_t v48 = vmulq_f32(v47, v47);
        *(float *)(v131 + 4 * v18) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).f32[0]);
      }
      if (a4 <= v46) {
        goto LABEL_120;
      }
      ++v18;
      unint64_t v46 = *(unsigned int *)(a3 + 4 * v46);
      if (a2 == v18) {
        goto LABEL_41;
      }
    }
LABEL_118:
    re::internal::assertLog((re::internal *)6, v44, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v46, v43);
    _os_crash();
    __break(1u);
LABEL_119:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v18;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_120:
    re::internal::assertLog((re::internal *)6, v44, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v46, v45);
    _os_crash();
    __break(1u);
    goto LABEL_121;
  }
LABEL_41:
  float v101 = TwistAngle;
  float v107 = v20;
  float v16 = (void **)&v116;
  float v49 = ((float (*)(void (***)(void **), void))v116[7])(&v116, 0);
  __int16 v50 = ((uint64_t (*)(void **))v116[6])((void **)&v116);
  float v51 = ((float (*)(void (***)(void **), void))v116[7])(&v116, (unsigned __int16)(v50 - 1));
  uint64_t v52 = ((uint64_t (*)(void (***)(void **), float))v116[15])(&v116, v49);
  a5 = v133;
  if (v133 <= v24) {
    goto LABEL_135;
  }
  float v54 = (uint64_t *)(v134 + 16 * v24);
  *float v54 = v52;
  v54[1] = v53;
  uint64_t v55 = (v24 - 1);
  if ((int)v24 - 1 < 0) {
    goto LABEL_79;
  }
  float v16 = (void **)&v116;
  uint64_t v12 = v24;
  float v105 = v19;
  float v110 = v51;
LABEL_44:
  unint64_t v11 = (int)v12;
  a5 = v133;
  if (v133 <= (int)v12) {
    goto LABEL_122;
  }
  a5 = v130;
  if (v130 <= (int)v12) {
    goto LABEL_123;
  }
  uint64_t v12 = v55;
  a7 = 0;
  unint64_t v18 = v134;
  float v56 = *(float *)(v131 + 4 * v11) * *(float *)(v131 + 4 * v11);
  a5 = 15;
  float v57 = 3.4028e38;
  float v58 = v49;
  float v59 = 3.4028e38;
  while (1)
  {
    float v60 = (float)(v58 + v51) * 0.5;
    v61.i64[0] = ((uint64_t (*)(void (***)(void **), float))v116[15])(&v116, v60);
    v61.i64[1] = v53;
    float32x4_t v62 = vsubq_f32(v61, *(float32x4_t *)(v18 + 16 * v11));
    float32x4_t v63 = vmulq_f32(v62, v62);
    __n128 v64 = (__n128)vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1));
    v63.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), (float32x4_t)v64).f32[0];
    float v65 = v63.f32[0] - v56;
    float v66 = vabds_f32(v63.f32[0], v56);
    if (v66 < 0.75)
    {
      if ((int)a7 >= 1) {
        goto LABEL_61;
      }
      a7 = 1;
      float v59 = v57;
      float v51 = (float)(v58 + v51) * 0.5;
      float v58 = v49;
      goto LABEL_60;
    }
    if (v65 >= 0.0)
    {
      float v51 = (float)(v58 + v51) * 0.5;
      goto LABEL_60;
    }
    if (!a7 || v60 <= v59) {
      break;
    }
    a7 = 1;
    float v58 = v51;
LABEL_60:
    a5 = (a5 - 1);
    if (!a5)
    {
LABEL_61:
      if (v66 >= v105)
      {
        float32x4_t v111 = v61;
        float v67 = v65 * v65;
        a5 = 5;
        float v51 = v110;
        while (1)
        {
          float32x4_t v114 = v62;
          v68.i64[0] = ((uint64_t (*)(void (***)(void **), uint64_t, float))v116[16])(&v116, 1, v60);
          v68.i64[1] = v53;
          float32x4_t v69 = vmulq_f32(v114, v68);
          __n128 v64 = (__n128)vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1));
          v69.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), (float32x4_t)v64).f32[0];
          float v70 = v69.f32[0] + v69.f32[0];
          v64.n128_f32[0] = fabsf(v70);
          if (v64.n128_f32[0] < 0.01) {
            goto LABEL_76;
          }
          float v71 = v65 / v70;
          float v72 = v60 - v71;
          if ((float)(v60 - v71) < v49 || v72 > v110) {
            goto LABEL_76;
          }
          v74.i64[0] = ((uint64_t (*)(void (***)(void **), float))v116[15])(&v116, v60 - v71);
          v74.i64[1] = v53;
          float32x4_t v62 = vsubq_f32(v74, *(float32x4_t *)(v18 + 16 * v11));
          float32x4_t v75 = vmulq_f32(v62, v62);
          __n128 v64 = (__n128)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2), vaddq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v75.f32, 1)));
          float v65 = v64.n128_f32[0] - v56;
          v64.n128_f32[0] = v65 * v65;
          if ((float)(v65 * v65) >= v67) {
            goto LABEL_76;
          }
          if (fabsf(v65) < v105) {
            break;
          }
          float32x4_t v111 = v74;
          float v60 = v72;
          float v67 = v65 * v65;
          a5 = (a5 - 1);
          if (!a5) {
            goto LABEL_76;
          }
        }
        float v49 = v72;
        float32x4_t v61 = v74;
      }
      else
      {
        float v49 = v60;
        float v51 = v110;
      }
LABEL_77:
      a5 = v133;
      if (v133 <= v12) {
        goto LABEL_124;
      }
      *(float32x4_t *)(v134 + 16 * v12) = v61;
      uint64_t v55 = v12 - 1;
      unint64_t v24 = (v24 - 1);
      if (v12 <= 0) {
        goto LABEL_79;
      }
      goto LABEL_44;
    }
  }
  float v57 = fminf(v60, v57);
  if (a7)
  {
    a7 = 1;
LABEL_59:
    float v58 = (float)(v58 + v51) * 0.5;
    goto LABEL_60;
  }
  v64.n128_f32[0] = v110 - v60;
  if ((float)(v110 - v60) >= 0.01)
  {
    a7 = 0;
    goto LABEL_59;
  }
  float32x4_t v111 = 0u;
  float v60 = 3.4028e38;
  float v51 = v110;
LABEL_76:
  float v49 = v60;
  float32x4_t v61 = v111;
  if (v60 <= v51) {
    goto LABEL_77;
  }
  float v16 = (void **)&v116;
  a1 = ((uint64_t (*)(void (***)(void **), uint64_t, float, __n128))v116[16])(&v116, 1, v51, v64);
  unint64_t v21 = v84;
  uint64_t v85 = ((uint64_t (*)(void (***)(void **), float))v116[15])(&v116, v51);
  unint64_t v18 = v133;
  if (v133 <= v11) {
    goto LABEL_140;
  }
  a5 = v130;
  if (v130 <= v11)
  {
LABEL_141:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = v11;
    __int16 v144 = 2048;
    unint64_t v145 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_142;
  }
  v86.i64[0] = a1;
  v86.i64[1] = v21;
  int32x4_t v87 = (int32x4_t)vmulq_f32(v86, v86);
  v87.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v87, 2), vadd_f32(*(float32x2_t *)v87.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 1))).u32[0];
  float32x2_t v88 = vrsqrte_f32((float32x2_t)v87.u32[0]);
  float32x2_t v89 = vmul_f32(v88, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v88, v88)));
  v89.i32[0] = vmul_f32(v89, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v89, v89))).u32[0];
  v90.i64[0] = v85;
  v90.i64[1] = v53;
  float32x4_t v91 = vmulq_n_f32(v86, v89.f32[0]);
  float32x4_t v92 = vsubq_f32(v90, *(float32x4_t *)(v134 + 16 * v11));
  float32x4_t v93 = vmulq_f32(v91, v92);
  LODWORD(v94) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 2), vaddq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v93.f32, 1))).u32[0];
  float32x4_t v95 = vmulq_f32(v92, v92);
  float v96 = vmlas_n_f32(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 2), vaddq_f32(v95, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.f32, 1))).f32[0]- (float)(*(float *)(v131 + 4 * v11) * *(float *)(v131 + 4 * v11))), v94, v94);
  if (v96 < 0.0)
  {
    BOOL v81 = 0;
    uint64_t v82 = 0;
    goto LABEL_91;
  }
  a5 = v12;
  if (v133 <= v12)
  {
LABEL_142:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a5;
    __int16 v144 = 2048;
    unint64_t v145 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float32x4_t *)(v134 + 16 * v12) = vaddq_f32(vmulq_n_f32(v91, sqrtf(v96) - v94), v90);
  if ((int)v12 >= 1)
  {
    while (1)
    {
      a5 = (v24 - 1);
      unint64_t v18 = v133;
      if (v133 <= a5) {
        break;
      }
      a7 = v130;
      if (v130 <= a5) {
        goto LABEL_129;
      }
      a7 = (v24 - 2);
      if (v133 <= a7) {
        goto LABEL_130;
      }
      *(float32x4_t *)(v134 + 16 * a7) = vaddq_f32(*(float32x4_t *)(v134 + 16 * a5), vmulq_n_f32(v91, *(float *)(v131 + 4 * a5)));
      unint64_t v24 = (v24 - 1);
      if (a5 <= 1) {
        goto LABEL_79;
      }
    }
LABEL_128:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a5;
    __int16 v144 = 2048;
    unint64_t v145 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_129:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a5;
    __int16 v144 = 2048;
    unint64_t v145 = a7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_130:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a7;
    __int16 v144 = 2048;
    unint64_t v145 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_131:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_132;
  }
LABEL_79:
  a1 = a4;
  if (a4 <= v17) {
    goto LABEL_136;
  }
  unint64_t v24 = a2;
  if (a2 <= v17)
  {
LABEL_137:
    re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v24);
    _os_crash();
    __break(1u);
    goto LABEL_138;
  }
  unint64_t v11 = a3;
  unint64_t v76 = *(unsigned int *)(a3 + 4 * v17);
  uint64_t v12 = v108;
  float32x4_t v77 = *(float32x4_t *)(v108 + (v17 << 6) + 48);
  if (a2 >= 3)
  {
    float v78 = v107;
    float v79 = (float)(v101 - v107) / (float)(a2 - 2);
    unsigned int v80 = a2 - 1;
LABEL_85:
    unint64_t v18 = 0;
    a5 = 0;
    a7 = v80;
    while (a2 > v76)
    {
      ++a5;
      unint64_t v21 = v133;
      if (v133 <= a5) {
        goto LABEL_110;
      }
      unint64_t v21 = v108 + (v76 << 6);
      float32x4_t v115 = *(float32x4_t *)(v21 + 48);
      *(int32x4_t *)unint64_t v21 = v146;
      *(_OWORD *)(v21 + 16) = v147;
      *(_OWORD *)(v21 + 32) = v148;
      *(_OWORD *)(v21 + 48) = v149;
      if (a4 <= v76) {
        goto LABEL_111;
      }
      float v78 = v79 + v78;
      unint64_t v76 = *(unsigned int *)(a3 + 4 * v76);
      v18 += 16;
      float32x4_t v77 = v115;
      if (a7 == a5) {
        goto LABEL_90;
      }
    }
    re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v76, a2);
    _os_crash();
    __break(1u);
LABEL_110:
    uint64_t v137 = 0;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    int32x4_t v146 = 0u;
    unint64_t v76 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v138 = 136315906;
    int32x4_t v139 = "operator[]";
    __int16 v140 = 1024;
    int v141 = 468;
    __int16 v142 = 2048;
    unint64_t v143 = a5;
    __int16 v144 = 2048;
    unint64_t v145 = v21;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_111:
    re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v76, a4);
    _os_crash();
    __break(1u);
LABEL_112:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v31, v32);
    _os_crash();
    __break(1u);
    goto LABEL_113;
  }
  unsigned int v80 = a2 - 1;
  float v78 = v107;
  if (a2 != 1)
  {
    float v79 = 0.0;
    goto LABEL_85;
  }
LABEL_90:
  BOOL v81 = v130 == 0;
  uint64_t v82 = 1;
LABEL_91:
  if (v129 && !v81) {
    (*(void (**)(void))(*(void *)v129 + 40))();
  }
  if (v132 && v133) {
    (*(void (**)(void))(*(void *)v132 + 40))();
  }
  re::Allocator::~Allocator((re::Allocator *)v135);
  re::Spline<re::Vector3<float>>::~Spline(&v116);
  return v82;
}

float32x4_t anonymous namespace'::calculateFABRIKChain(float32x4_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 8);
  if (a3) {
    int v5 = v4 - 1;
  }
  else {
    int v5 = 0;
  }
  if (a3) {
    int v6 = -1;
  }
  else {
    int v6 = 1;
  }
  if (a3) {
    int v7 = -1;
  }
  else {
    int v7 = *(void *)(a4 + 8);
  }
  if (v4 <= v5) {
    goto LABEL_21;
  }
  float32x4_t result = *a1;
  *(float32x4_t *)(*(void *)(a4 + 16) + 16 * v5) = *a1;
  if (v5 + v6 != v7)
  {
    unint64_t v9 = v5 + v6;
    uint64_t v10 = (uint64_t)((unint64_t)(a3 ^ 1u) << 63) >> 63;
    int v11 = v7 - v6;
    while (*(void *)(a2 + 8) > v10 + v9)
    {
      unint64_t v12 = *(void *)(a4 + 8);
      if (v12 <= v9) {
        goto LABEL_19;
      }
      if (v12 <= v5) {
        goto LABEL_20;
      }
      uint64_t v13 = *(void *)(a4 + 16);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16 * v5);
      float32x4_t v15 = vsubq_f32(*(float32x4_t *)(v13 + 16 * v9), v14);
      int32x4_t v16 = (int32x4_t)vmulq_f32(v15, v15);
      v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2), vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.i8, 1))).u32[0];
      float32x2_t v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
      float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
      float32x4_t result = vaddq_f32(v14, vmulq_n_f32(vmulq_n_f32(v15, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]), *(float *)(*(void *)(a2 + 16) + 4 * v10 + 4 * v9)));
      *(float32x4_t *)(v13 + 16 * v9) = result;
      v9 += v6;
      v5 += v6;
      if (v11 == v5) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

__n128 anonymous namespace'::lookAtTransformFromReference(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, int32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v12 = vsubq_f32(a6, *(float32x4_t *)(a2 + 48));
  int32x4_t v13 = (int32x4_t)vmulq_f32(v12, v12);
  v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
  float32x2_t v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  float32x2_t v15 = vmul_f32(v14, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)));
  float32x4_t v16 = vmulq_n_f32(v12, vmul_f32(v15, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v15, v15))).f32[0]);
  float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL);
  float32x4_t v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a5, a5), (int8x16_t)a5, 0xCuLL);
  float32x4_t v19 = vnegq_f32(v16);
  float32x4_t v20 = vmlaq_f32(vmulq_f32(v18, v19), (float32x4_t)a5, v17);
  float32x4_t v21 = vmulq_f32(v20, v20);
  int32x2_t v22 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), v21)).u64[0];
  if (*(float *)v22.i32 >= 0.0001)
  {
    float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL);
  }
  else
  {
    float32x4_t v23 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v19), v18, v17);
    float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL);
    float32x4_t v25 = vmulq_f32(v23, v23);
    int32x2_t v22 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), v25)).u64[0];
  }
  *(float *)v22.i32 = sqrtf(*(float *)v22.i32);
  v106.columns[2] = (simd_float3)vdivq_f32(v24, (float32x4_t)vdupq_lane_s32(v22, 0));
  float32x4_t v96 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v106.columns[2], (int32x4_t)v106.columns[2]), (int8x16_t)v106.columns[2], 0xCuLL);
  float32x4_t v97 = (float32x4_t)v106.columns[2];
  int8x16_t v26 = (int8x16_t)vmlaq_f32(vmulq_f32(v96, v19), (float32x4_t)v106.columns[2], v17);
  v106.columns[1] = (simd_float3)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), v26, 0xCuLL);
  float32x4_t v94 = v16;
  v106.columns[0] = (simd_float3)v16;
  float32x4_t v98 = (float32x4_t)v106.columns[1];
  simd_float3x3 v107 = __invert_f3(v106);
  uint64_t v27 = 0;
  long long v28 = *(_OWORD *)(a2 + 16);
  long long v29 = *(_OWORD *)(a2 + 32);
  __n128 v100 = *(__n128 *)a2;
  long long v101 = v28;
  long long v102 = v29;
  do
  {
    *(float32x4_t *)((char *)&v103 + v27 * 8) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v107.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v100 + v27 * 8))), (float32x4_t)v107.columns[1], (float32x2_t)v100.n128_u64[v27], 1), (float32x4_t)v107.columns[2], *(float32x4_t *)((char *)&v100 + v27 * 8), 2);
    v27 += 2;
  }
  while (v27 != 6);
  float32x4_t v99 = *a3;
  float32x4_t v30 = vsubq_f32(*a4, *a3);
  int32x4_t v31 = (int32x4_t)vmulq_f32(v30, v30);
  v31.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))).u32[0];
  float32x2_t v32 = vrsqrte_f32((float32x2_t)v31.u32[0]);
  float32x2_t v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v32, v32)));
  float32x4_t v34 = vmulq_n_f32(v30, vmul_f32(v33, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v33, v33))).f32[0]);
  float32x4_t v35 = v34;
  float32x4_t v36 = vmulq_f32(v34, v34);
  LODWORD(v37) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).u32[0];
  float v38 = fabsf(v37);
  float32x4_t v90 = v34;
  if (v38 >= 1.0e-10)
  {
    float32x2_t v39 = vrsqrte_f32((float32x2_t)LODWORD(v37));
    float32x2_t v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v39, v39)));
    float32x4_t v35 = vmulq_n_f32(v34, vmul_f32(v40, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v40, v40))).f32[0]);
  }
  float v88 = v37;
  float32x4_t v89 = v35;
  float32x4_t v95 = v34;
  long long v92 = v104;
  __n128 v93 = v103;
  long long v91 = v105;
  __float2 v41 = __sincosf_stret(a7 * 0.5);
  *(float32x2_t *)v42.f32 = vmul_n_f32(*(float32x2_t *)v89.f32, v41.__sinval);
  float v43 = vmuls_lane_f32(v41.__sinval, v89, 2);
  float32x4_t v44 = v94;
  float32x4_t v45 = vmulq_f32(v44, v44);
  LODWORD(v46) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).u32[0];
  if (fabsf(v46) >= 1.0e-10)
  {
    float v47 = v46;
    float32x2_t v48 = vrsqrte_f32((float32x2_t)LODWORD(v46));
    float32x2_t v49 = vmul_f32(v48, vrsqrts_f32((float32x2_t)LODWORD(v47), vmul_f32(v48, v48)));
    float32x4_t v44 = vmulq_n_f32(v94, vmul_f32(v49, vrsqrts_f32((float32x2_t)LODWORD(v47), vmul_f32(v49, v49))).f32[0]);
  }
  v42.f32[2] = v43;
  float32x4_t v50 = v90;
  if (v38 >= 1.0e-10)
  {
    float32x2_t v51 = vrsqrte_f32((float32x2_t)LODWORD(v88));
    float32x2_t v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)LODWORD(v88), vmul_f32(v51, v51)));
    float32x4_t v50 = vmulq_n_f32(v95, vmul_f32(v52, vrsqrts_f32((float32x2_t)LODWORD(v88), vmul_f32(v52, v52))).f32[0]);
  }
  float32x4_t v53 = v42;
  v53.i32[3] = LODWORD(v41.__cosval);
  float32x4_t v54 = vmulq_f32(v44, v50);
  float v55 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), vaddq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1))).f32[0];
  if (v55 == -1.0 || (float v56 = (float)((float)(fabsf(v55) + 1.0) + 1.0) * 0.00001, v57 = v55 + 1.0, fabsf(v57) < v56))
  {
    if (fabsf(v44.f32[2]) >= 0.00001)
    {
      v58.i32[0] = 0;
      v58.f32[1] = -v44.f32[2];
      v58.i64[1] = v44.u32[1];
    }
    else
    {
      float32x4_t v58 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v44.f32[1]), (int32x4_t)v44);
    }
    int32x4_t v59 = (int32x4_t)vmulq_f32(v58, v58);
    v59.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v59, 2), vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v59.i8, 1))).u32[0];
    float32x2_t v60 = vrsqrte_f32((float32x2_t)v59.u32[0]);
    float32x2_t v61 = vmul_f32(v60, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(v60, v60)));
    float32x4_t v62 = vmulq_n_f32(v58, vmul_f32(v61, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(v61, v61))).f32[0]);
    float v63 = 0.0;
  }
  else
  {
    int8x16_t v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v50, 0xCuLL), vnegq_f32(v44)), v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL));
    float32x4_t v65 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL);
    *(float *)v64.i32 = sqrtf(v57 + v57);
    float v63 = *(float *)v64.i32 * 0.5;
    float32x4_t v62 = vdivq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v64.i8, 0));
  }
  uint64_t v66 = 0;
  float32x4_t v67 = v62;
  v67.f32[3] = v63;
  int8x16_t v68 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL), vnegq_f32(v42)), v62, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), (int8x16_t)v42, 0xCuLL));
  float32x4_t v69 = vmlaq_n_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), v68, 0xCuLL), v62, v53, 3), v42, v63);
  float32x4_t v70 = vmulq_f32(v53, v67);
  float v71 = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 2), vaddq_f32(v70, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v70.f32, 1))).f32[0]- (float)(v41.__cosval * v63));
  float32x4_t v72 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), (int8x16_t)v69, 0xCuLL);
  float32x4_t v73 = vnegq_f32(v69);
  float32x4_t v74 = vmlaq_f32(vmulq_f32(v96, v73), v97, v72);
  int8x16_t v75 = (int8x16_t)vaddq_f32(v74, v74);
  float32x4_t v76 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), v75, 0xCuLL);
  int8x16_t v77 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v76, (int32x4_t)v76), (int8x16_t)v76, 0xCuLL), v73), v76, v72);
  float32x4_t v78 = vaddq_f32(vaddq_f32(v97, vmulq_n_f32(v76, v71)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v77, (int32x4_t)v77), v77, 0xCuLL));
  float32x4_t v79 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v98, (int32x4_t)v98), (int8x16_t)v98, 0xCuLL), v73), v98, v72);
  int8x16_t v80 = (int8x16_t)vaddq_f32(v79, v79);
  float32x4_t v81 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v80, (int32x4_t)v80), v80, 0xCuLL);
  int8x16_t v82 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), (int8x16_t)v81, 0xCuLL), v73), v81, v72);
  float32x4_t v83 = vaddq_f32(vaddq_f32(v98, vmulq_n_f32(v81, v71)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), v82, 0xCuLL));
  __n128 v100 = v93;
  long long v101 = v92;
  long long v102 = v91;
  do
  {
    *(float32x4_t *)((char *)&v103 + v66 * 8) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v95, COERCE_FLOAT(*(_OWORD *)((char *)&v100 + v66 * 8))), v83, (float32x2_t)v100.n128_u64[v66], 1), v78, *(float32x4_t *)((char *)&v100 + v66 * 8), 2);
    v66 += 2;
  }
  while (v66 != 6);
  __n128 result = v103;
  long long v84 = v104;
  result.n128_u32[3] = 0;
  long long v86 = v105;
  HIDWORD(v84) = 0;
  HIDWORD(v86) = 0;
  float32x4_t v87 = v99;
  v87.i32[3] = 1.0;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v84;
  *(_OWORD *)(a1 + 32) = v86;
  *(float32x4_t *)(a1 + 48) = v87;
  return result;
}

void re::BezierSpline<re::Vector3<float>>::~BezierSpline(void *a1)
{
  re::Spline<re::Vector3<float>>::~Spline(a1);
  JUMPOUT(0x237DBCBD0);
}

void re::BezierSpline<re::Vector3<float>>::resizeSpans(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    re::DynamicArray<re::Vector3<float>>::resize(a1 + 8, (unsigned __int16)(3 * a2 + 1));
    *(_WORD *)(a1 + 138) = a2;
    if (!*(unsigned char *)(a1 + 136))
    {
      re::DynamicArray<float>::resize(a1 + 48, a2 + 1);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
    ++*(_DWORD *)(a1 + 32);
    *(_WORD *)(a1 + 138) = 0;
    if (!*(unsigned char *)(a1 + 136))
    {
      *(void *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 72);
    }
  }
}

void *re::BezierSpline<re::Vector3<float>>::reserveSpans(void *result, int a2)
{
  if (a2) {
    unsigned __int16 v2 = 3 * a2 + 1;
  }
  else {
    unsigned __int16 v2 = 0;
  }
  if (result[2] < (unint64_t)v2) {
    return re::DynamicArray<re::Quaternion<float>>::setCapacity(result + 1, v2);
  }
  return result;
}

uint64_t re::BezierSpline<re::Vector3<float>>::degree()
{
  return 3;
}

uint64_t re::BezierSpline<re::Vector3<float>>::spanCount(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 138);
}

uint64_t re::Spline<re::Vector3<float>>::knotCount(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1)) {
    return (unsigned __int16)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 1);
  }
  else {
    return 0;
  }
}

uint64_t re::Spline<re::Vector3<float>>::knotAtIndex(uint64_t result, unsigned int a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 136))
  {
    __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    if (result != a2) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
    }
  }
  else if (*(void *)(result + 64) <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::BezierSpline<re::Vector3<float>>::findSpanIndex(uint64_t a1, float a2)
{
  if (*(unsigned char *)(a1 + 136))
  {
    float v2 = *(float *)(a1 + 128);
    if (v2 >= a2)
    {
      LOWORD(v3) = 0;
    }
    else
    {
      unsigned int v3 = *(unsigned __int16 *)(a1 + 138);
      float v4 = *(float *)(a1 + 132);
      if (v4 <= a2) {
        LOWORD(v3) = v3 - 1;
      }
      else {
        unsigned int v3 = (int)(float)((float)((float)(a2 - v2) / (float)(v4 - v2)) * (float)v3);
      }
    }
    LOWORD(result) = v3;
  }
  else
  {
    LOWORD(result) = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  return (unsigned __int16)result;
}

BOOL re::Spline<re::Vector3<float>>::areKnotsNormalized(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    float v2 = *(float **)(a1 + 80);
    if (fabsf(*v2) < 0.00001)
    {
      float v3 = v2[v1 - 1];
      return v3 == 1.0 || fabsf(v3 + -1.0) < (float)((float)((float)(fabsf(v3) + 1.0) + 1.0) * 0.00001);
    }
    return 0;
  }
  if (fabsf(*(float *)(a1 + 128)) >= 0.00001) {
    return 0;
  }
  float v3 = *(float *)(a1 + 132);
  return v3 == 1.0 || fabsf(v3 + -1.0) < (float)((float)((float)(fabsf(v3) + 1.0) + 1.0) * 0.00001);
}

uint64_t re::Spline<re::Vector3<float>>::normalizeKnots(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 64);
  unint64_t v2 = v1 - 2;
  if (v1 >= 2)
  {
    float v3 = *(float **)(result + 80);
    float v4 = *v3;
    unint64_t v5 = v1 - 1;
    float v6 = v3[v5];
    float *v3 = 0.0;
    if (v5 >= 2)
    {
      float v7 = v6 - v4;
      float32x2_t v8 = v3 + 1;
      do
      {
        float *v8 = (float)(*v8 - v4) / v7;
        ++v8;
        --v2;
      }
      while (v2);
    }
    v3[v5] = 1.0;
  }
  return result;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnots(uint64_t a1)
{
  *(unsigned char *)(a1 + 136) = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    unsigned int v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    re::DynamicArray<float>::resize(a1 + 48, v2 + 1);
  }
  else
  {
    *(void *)(a1 + 64) = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnots(uint64_t a1, uint64_t *a2)
{
  *(unsigned char *)(a1 + 136) = 0;
  re::DynamicArray<float>::operator=(a1 + 48, a2);
  uint64_t v4 = a2[2];
  if (!v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v5 = (_DWORD *)a2[4];
  *(_DWORD *)(a1 + 128) = *v5;
  *(_DWORD *)(a1 + 132) = v5[v4 - 1];
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnotAtIndex(uint64_t a1, unsigned int a2, float a3)
{
  if (*(void *)(a1 + 64) <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(*(void *)(a1 + 80) + 4 * a2) = a3;
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setUniformKnots(uint64_t result, float a2, float a3)
{
  *(unsigned char *)(result + 136) = 1;
  *(void *)(result + 64) = 0;
  ++*(_DWORD *)(result + 72);
  *(float *)(result + 128) = a2;
  *(float *)(result + 132) = a3;
  return result;
}

double re::BezierSpline<re::Vector3<float>>::evaluateAt(uint64_t a1, float a2)
{
  if (*(unsigned char *)(a1 + 136))
  {
    float v3 = *(float *)(a1 + 128);
    if (v3 >= a2)
    {
      LOWORD(v4) = 0;
      unint64_t v7 = 0;
    }
    else
    {
      unsigned int v4 = *(unsigned __int16 *)(a1 + 138);
      float v5 = *(float *)(a1 + 132);
      if (v5 <= a2)
      {
        LOWORD(v4) = v4 - 1;
        unint64_t v7 = 0x3F80000000000000;
      }
      else
      {
        float v6 = (float)((float)(a2 - v3) / (float)(v5 - v3)) * (float)v4;
        unsigned int v4 = (int)v6;
        unint64_t v7 = (unint64_t)COERCE_UNSIGNED_INT(v6 - (float)(int)v6) << 32;
      }
    }
    NonUniformSpaunint64_t n = v7 | (unsigned __int16)v4;
  }
  else
  {
    NonUniformSpaunint64_t n = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  unint64_t v9 = (unsigned __int16)(3 * NonUniformSpan);
  unint64_t v10 = *(void *)(a1 + 24);
  if (v10 <= v9)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_15;
  }
  unint64_t v11 = (v9 + 1);
  if (v10 <= v11)
  {
LABEL_15:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  unint64_t v12 = (v9 + 2);
  if (v10 <= v12)
  {
LABEL_16:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_17:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v13 = (v9 + 3);
  if (v10 <= v13) {
    goto LABEL_17;
  }
  uint64_t v14 = *(void *)(a1 + 40);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v9), (float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v11), (float)((float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))* 3.0)* *((float *)&NonUniformSpan + 1))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v12), (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1)) * 3.0))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v13),
                           (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))
                         * *((float *)&NonUniformSpan + 1))).u64[0];
  return result;
}

double re::BezierSpline<re::Vector3<float>>::evaluateDerivativeAt(uint64_t a1, int a2, float a3)
{
  if (*(unsigned char *)(a1 + 136))
  {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 138);
    float v6 = *(float *)(a1 + 128);
    float v7 = *(float *)(a1 + 132);
    if (v6 >= a3)
    {
      LOWORD(v9) = 0;
      unint64_t v10 = 0;
    }
    else if (v7 <= a3)
    {
      LOWORD(v9) = v5 - 1;
      unint64_t v10 = 0x3F80000000000000;
    }
    else
    {
      float v8 = (float)((float)(a3 - v6) / (float)(v7 - v6)) * (float)v5;
      int v9 = (int)v8;
      unint64_t v10 = (unint64_t)COERCE_UNSIGNED_INT(v8 - (float)(int)v8) << 32;
    }
    float v12 = (float)v5 / (float)(v7 - v6);
    NonUniformSpaunint64_t n = v10 | (unsigned __int16)v9;
  }
  else
  {
    NonUniformSpaunint64_t n = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a3);
  }
  switch(a2)
  {
    case 0:
      unint64_t v13 = *(void *)(a1 + 24);
      if (v13 <= (unsigned __int16)(3 * NonUniformSpan))
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_28:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_29:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_30:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_31;
      }
      int v14 = (unsigned __int16)(3 * NonUniformSpan);
      unint64_t v15 = (v14 + 1);
      if (v13 <= v15)
      {
LABEL_31:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_32;
      }
      unint64_t v16 = (v14 + 2);
      if (v13 <= v16)
      {
LABEL_32:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_36:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      unint64_t v17 = (v14 + 3);
      if (v13 <= v17) {
        goto LABEL_33;
      }
      uint64_t v18 = *(void *)(a1 + 40);
      *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v18 + 16 * (unsigned __int16)(3 * NonUniformSpan)), (float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v15), (float)((float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))* 3.0)* *((float *)&NonUniformSpan + 1))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v16), (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1)) * 3.0))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v17),
                               (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))
                             * *((float *)&NonUniformSpan + 1))).u64[0];
      return result;
    case 1:
      int v20 = (unsigned __int16)(3 * NonUniformSpan);
      unint64_t v21 = (v20 + 1);
      unint64_t v22 = *(void *)(a1 + 24);
      if (v22 <= v21) {
        goto LABEL_28;
      }
      unint64_t v23 = (v20 + 2);
      if (v22 <= v23) {
        goto LABEL_34;
      }
      unint64_t v24 = (v20 + 3);
      if (v22 <= v24) {
        goto LABEL_35;
      }
      float v25 = v12 * 3.0;
      uint64_t v26 = *(void *)(a1 + 40);
      float v27 = 1.0 - *((float *)&NonUniformSpan + 1);
      float32x4_t v28 = vaddq_f32(vaddq_f32(vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v21), *(float32x4_t *)(v26 + 16 * (unsigned __int16)(3 * NonUniformSpan))), v27 * v27), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v23), *(float32x4_t *)(v26 + 16 * v21)), (float)(v27 + v27) * *((float *)&NonUniformSpan + 1))), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v24), *(float32x4_t *)(v26 + 16 * v23)), *((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1)));
LABEL_23:
      *(void *)&double result = vmulq_n_f32(v28, v25).u64[0];
      return result;
    case 2:
      int v29 = (unsigned __int16)(3 * NonUniformSpan);
      unint64_t v30 = (v29 + 2);
      unint64_t v31 = *(void *)(a1 + 24);
      if (v31 <= v30) {
        goto LABEL_29;
      }
      unint64_t v32 = (v29 + 3);
      if (v31 <= v32) {
        goto LABEL_36;
      }
      float v25 = (float)(v12 * 6.0) * v12;
      uint64_t v33 = *(void *)(a1 + 40);
      float32x4_t v34 = *(float32x4_t *)(v33 + 16 * (v29 + 1));
      float32x4_t v28 = vaddq_f32(vmulq_n_f32(vaddq_f32(v34, vsubq_f32(*(float32x4_t *)(v33 + 16 * v32), vaddq_f32(*(float32x4_t *)(v33 + 16 * v30), *(float32x4_t *)(v33 + 16 * v30)))), *((float *)&NonUniformSpan + 1)), vmulq_n_f32(vaddq_f32(*(float32x4_t *)(v33 + 16 * (unsigned __int16)(3 * NonUniformSpan)), vsubq_f32(*(float32x4_t *)(v33 + 16 * v30), vaddq_f32(v34, v34))), 1.0 - *((float *)&NonUniformSpan + 1)));
      goto LABEL_23;
    case 3:
      unint64_t v35 = (unsigned __int16)(3 * NonUniformSpan) + 3;
      if (*(void *)(a1 + 24) <= v35) {
        goto LABEL_30;
      }
      __asm { FMOV            V3.4S, #3.0 }
      *(void *)&double result = vmulq_n_f32(vsubq_f32(vaddq_f32(vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v35), vmulq_f32(*(float32x4_t *)(*(void *)(a1 + 40)+ 16 * ((unsigned __int16)(3 * NonUniformSpan) + 2)), _Q3)), vmulq_f32(*(float32x4_t *)(*(void *)(a1 + 40)+ 16 * ((unsigned __int16)(3 * NonUniformSpan) + 1)), _Q3)), *(float32x4_t *)(*(void *)(a1 + 40) + 16 * (unsigned __int16)(3 * NonUniformSpan))), (float)((float)(v12 * 6.0) * v12) * v12).u64[0];
      return result;
    default:
      return 0.0;
  }
}

float re::BezierSpline<re::Vector3<float>>::evaluateLengthAt(uint64_t a1, float a2)
{
  if (*(unsigned char *)(a1 + 136))
  {
    float v4 = *(float *)(a1 + 128);
    if (v4 >= a2)
    {
      LOWORD(v5) = 0;
    }
    else
    {
      unsigned int v5 = *(unsigned __int16 *)(a1 + 138);
      float v6 = *(float *)(a1 + 132);
      if (v6 <= a2) {
        LOWORD(v5) = v5 - 1;
      }
      else {
        unsigned int v5 = (int)(float)((float)((float)(a2 - v4) / (float)(v6 - v4)) * (float)v5);
      }
    }
    NonUniformSpaunint64_t n = v5;
  }
  else
  {
    NonUniformSpaunint64_t n = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  unint64_t v8 = *(void *)(a1 + 104);
  if (!v8)
  {
    if (NonUniformSpan)
    {
      uint64_t v11 = 0;
      float v10 = 0.0;
      do
      {
        float v10 = v10 + (*(float (**)(uint64_t, uint64_t))(*(void *)a1 + 152))(a1, v11);
        uint64_t v11 = (v11 + 1);
      }
      while (NonUniformSpan != v11);
      goto LABEL_18;
    }
LABEL_17:
    float v10 = 0.0;
    goto LABEL_18;
  }
  if (!NonUniformSpan) {
    goto LABEL_17;
  }
  unint64_t v9 = NonUniformSpan - 1;
  if (v8 <= v9)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  float v10 = *(float *)(*(void *)(a1 + 120) + 4 * v9);
LABEL_18:
  float v12 = (*(float (**)(uint64_t, void))(*(void *)a1 + 56))(a1, NonUniformSpan);
  uint64_t v13 = 0;
  uint64_t v14 = qword_2687755F8;
  float v15 = (float)(v12 + a2) * 0.5;
  float v16 = (float)(a2 - v12) * 0.5;
  float v17 = 0.0;
  do
  {
    float v18 = *(float *)(v14 + v13 + 4);
    v19.i64[0] = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(void *)a1 + 128))(a1, 1, v15 + (float)(v16 * *(float *)(v14 + v13)));
    v19.i64[1] = v20;
    float32x4_t v21 = vmulq_f32(v19, v19);
    float v17 = v17
        + (float)(v18
                * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]));
    v13 += 8;
  }
  while (v13 != 128);
  return v10 + (float)(v16 * v17);
}

uint64_t re::BezierSpline<re::Vector3<float>>::calculateMonomialBasisForSpan(uint64_t a1, __int16 a2, uint64_t a3)
{
  unint64_t v3 = (unsigned __int16)(3 * a2);
  if (*(void *)(a1 + 24) <= v3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  int v4 = (unsigned __int16)(3 * a2);
  *(_OWORD *)a3 = *(_OWORD *)(*(void *)(a1 + 40) + 16 * v3);
  unint64_t v5 = (v4 + 1);
  if (*(void *)(a1 + 24) <= v5)
  {
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  __asm { FMOV            V0.4S, #3.0 }
  *(float32x4_t *)(a3 + 16) = vmulq_f32(vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(void *)(a1 + 40) + 16 * v3)), _Q0);
  unint64_t v11 = *(void *)(a1 + 24);
  if (v11 <= v3)
  {
LABEL_10:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_11;
  }
  if (v11 <= v5)
  {
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  unint64_t v12 = (v4 + 2);
  if (v11 <= v12)
  {
LABEL_12:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float32x4_t *)(a3 + 32) = vmulq_f32(vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v12), vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v3), vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(void *)(a1 + 40) + 16 * v5)))), _Q0);
  unint64_t v13 = (v4 + 3);
  if (*(void *)(a1 + 24) <= v13) {
    goto LABEL_13;
  }
  *(float32x4_t *)(a3 + 48) = vsubq_f32(vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v13), vmulq_f32(vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(void *)(a1 + 40) + 16 * v12)), _Q0)), *(float32x4_t *)(*(void *)(a1 + 40) + 16 * v3));
  return 4;
}

float re::BezierSpline<re::Vector3<float>>::evaluateSpanLength(uint64_t a1, unsigned __int16 a2)
{
  float v4 = (*(float (**)(uint64_t, void))(*(void *)a1 + 56))(a1, a2);
  float v5 = (*(float (**)(uint64_t, void))(*(void *)a1 + 56))(a1, (unsigned __int16)(a2 + 1));
  uint64_t v6 = 0;
  uint64_t v7 = qword_2687755F8;
  float v8 = (float)(v4 + v5) * 0.5;
  float v9 = (float)(v5 - v4) * 0.5;
  float v10 = 0.0;
  do
  {
    float v11 = *(float *)(v7 + v6 + 4);
    v12.i64[0] = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(void *)a1 + 128))(a1, 1, v8 + (float)(v9 * *(float *)(v7 + v6)));
    v12.i64[1] = v13;
    float32x4_t v14 = vmulq_f32(v12, v12);
    float v10 = v10
        + (float)(v11
                * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]));
    v6 += 8;
  }
  while (v6 != 128);
  return v9 * v10;
}

void re::DynamicArray<re::Vector3<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      float v5 = (void *)(*(void *)(a1 + 32) + 16 * v4);
      uint64_t v6 = 16 * a2 - 16 * v4;
      if (v6 >= 1) {
        bzero(v5, 16 * (((unint64_t)v6 >> 4) - ((unint64_t)v6 > 0xF)) + 16);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

unint64_t re::internal::findNonUniformSpan(uint64_t a1, unsigned int a2, unsigned int a3, float a4)
{
  unint64_t v4 = a2;
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 <= a2)
  {
LABEL_25:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_26;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  float v7 = *(float *)(v6 + 4 * a2);
  if (v7 >= a4) {
    goto LABEL_14;
  }
  if (v5 <= a3)
  {
LABEL_26:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
  float v8 = *(float *)(v6 + 4 * a3);
  if (v8 > a4)
  {
    unint64_t v4 = (a3 + a2) >> 1;
    if (v5 > v4)
    {
      unsigned __int16 v9 = a3;
      while (1)
      {
        unint64_t v10 = (v4 + 1);
        if (v5 <= v10) {
          break;
        }
        if (*(float *)(v6 + 4 * v4) <= a4)
        {
          float v8 = *(float *)(v6 + 4 * v10);
          if (v8 >= a4) {
            goto LABEL_18;
          }
          a2 = (unsigned __int16)(v4 + 1);
        }
        else
        {
          unsigned __int16 v9 = v4 - 1;
        }
        unint64_t v4 = (a2 + v9) >> 1;
        if (v5 <= v4) {
          goto LABEL_13;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_14:
    if (v5 <= v4 + 1)
    {
LABEL_27:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_28:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    float v11 = 1.0 / (float)(*(float *)(v6 + 4 * (v4 + 1)) - v7);
    float v12 = v7 - v7;
    return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
  }
  unint64_t v4 = (unsigned __int16)(a3 - 1);
  unint64_t v10 = v4 + 1;
  if (v5 <= v4 + 1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    if (v4 == a3 - 1 || v8 > a4)
    {
      float v14 = *(float *)(v6 + 4 * v4);
      unint64_t v4 = v4;
      float v11 = 1.0 / (float)(v8 - v14);
      float v12 = a4 - v14;
      return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
    }
    unint64_t v4 = (unsigned __int16)v10;
    unint64_t v10 = v4 + 1;
    if (v5 <= v4 + 1) {
      goto LABEL_28;
    }
  }
  float v13 = *(float *)(v6 + 4 * v4);
  float v11 = 1.0 / (float)(*(float *)(v6 + 4 * v10) - v13);
  float v12 = v8 - v13;
  return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
}

uint64_t re::DynamicArray<float>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4) {
        re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
      }
      else {
        *(void *)(a1 + 16) = 0;
      }
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<int>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<float>::copy(void **result, uint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<int>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 4 * (void)v5);
      unint64_t v5 = v3[2];
    }
    double result = (void **)memcpy((char *)v3[4] + 4 * (void)v5, (const void *)(*(void *)(a2 + 32) + 4 * (void)v5), 4 * v4 - 4 * (void)v5);
  }
  else if (v4)
  {
    double result = (void **)memmove(result[4], *(const void **)(a2 + 32), 4 * v4);
  }
  void v3[2] = (void *)v4;
  return result;
}

uint64_t anonymous namespace'::evaluateCubicBlossom(float32x4_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v16 = *MEMORY[0x263EF8340];
  float32x4_t v14 = *a1;
  v15[0] = a1[1];
  float32x4_t v4 = a1[3];
  v15[1] = a1[2];
  v15[2] = v4;
  uint64_t v5 = a2 + 12;
  uint64_t v6 = 3;
  do
  {
    uint64_t v7 = 0;
    float v8 = *(float *)(a3 + 4 * v3);
    float32x4_t v9 = v14;
    unint64_t v10 = (float32x4_t *)v15;
    do
    {
      float v11 = (float)(v8 - *(float *)(a2 + 4 * v7)) / (float)(*(float *)(v5 + 4 * v7) - *(float *)(a2 + 4 * v7));
      float32x4_t v12 = vmulq_n_f32(v9, 1.0 - v11);
      ++v7;
      float32x4_t v9 = *v10;
      v10[-1] = vaddq_f32(vmulq_n_f32(*v10, v11), v12);
      ++v10;
    }
    while (v6 != v7);
    ++v3;
    --v6;
    a2 += 4;
  }
  while (v3 != 3);
  return v14.i64[0];
}

void *re::Spline<re::Vector3<float>>::~Spline(void *a1)
{
  *a1 = &unk_26E6C2538;
  uint64_t v2 = (uint64_t)(a1 + 1);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 11));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 6));
  re::DynamicArray<unsigned long>::deinit(v2);
  return a1;
}

uint64_t re::EvaluationDependencyMap::init@<X0>(void *a1@<X0>, re::Allocator *a2@<X1>, re::EvaluationTree *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X8>)
{
  uint64_t v126 = *MEMORY[0x263EF8340];
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  uint64_t v88 = 0;
  uint64_t v87 = 0;
  uint64_t v89 = 0;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  long long v71 = 0u;
  memset(v70, 0, sizeof(v70));
  memset(v69, 0, sizeof(v69));
  re::EvaluationTree::resolveAliasRegisters(a3, (uint64_t)a2, a4, &v90, &v87, &v75, &v72, v69);
  v64[0] = 1;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  memset(v109, 0, sizeof(v109));
  memset(v108, 0, sizeof(v108));
  memset(v107, 0, sizeof(v107));
  memset(v106, 0, sizeof(v106));
  memset(v105, 0, sizeof(v105));
  memset(v104, 0, sizeof(v104));
  memset(v103, 0, sizeof(v103));
  unint64_t v9 = *((void *)a3 + 210);
  re::FixedArray<BOOL>::init<>(a1, (uint64_t)a2, v9);
  re::FixedArray<BOOL>::init<>(v107, (uint64_t)a2, v9);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v103, (uint64_t)a2, v9);
  unint64_t v10 = *((void *)a3 + 215);
  re::FixedArray<BOOL>::init<>(a1 + 3, (uint64_t)a2, v10);
  re::FixedArray<BOOL>::init<>((void *)&v107[1] + 1, (uint64_t)a2, v10);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v103[1] + 1, (uint64_t)a2, v10);
  unint64_t v11 = *((void *)a3 + 220);
  re::FixedArray<BOOL>::init<>(a1 + 6, (uint64_t)a2, v11);
  re::FixedArray<BOOL>::init<>(v108, (uint64_t)a2, v11);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v104, (uint64_t)a2, v11);
  unint64_t v12 = *((void *)a3 + 225);
  re::FixedArray<BOOL>::init<>(a1 + 9, (uint64_t)a2, v12);
  re::FixedArray<BOOL>::init<>((void *)&v108[1] + 1, (uint64_t)a2, v12);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v104[1] + 1, (uint64_t)a2, v12);
  unint64_t v13 = *((void *)a3 + 230);
  re::FixedArray<BOOL>::init<>(a1 + 12, (uint64_t)a2, v13);
  re::FixedArray<BOOL>::init<>(v109, (uint64_t)a2, v13);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v105, (uint64_t)a2, v13);
  unint64_t v14 = *((void *)a3 + 235);
  re::FixedArray<BOOL>::init<>(a1 + 15, (uint64_t)a2, v14);
  re::FixedArray<BOOL>::init<>((void *)&v109[1] + 1, (uint64_t)a2, v14);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v105[1] + 1, (uint64_t)a2, v14);
  unint64_t v15 = *((void *)a3 + 240);
  re::FixedArray<BOOL>::init<>(a1 + 18, (uint64_t)a2, v15);
  re::FixedArray<BOOL>::init<>(&v110, (uint64_t)a2, v15);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v106, (uint64_t)a2, v15);
  unint64_t v16 = *((void *)a3 + 245);
  re::FixedArray<BOOL>::init<>(a1 + 21, (uint64_t)a2, v16);
  re::FixedArray<BOOL>::init<>((void *)&v111 + 1, (uint64_t)a2, v16);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v106[1] + 1, (uint64_t)a2, v16);
  unint64_t v63 = 0;
  if (!v64[0])
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v65;
    *(void *)(a6 + 24) = v66;
    *(void *)(a6 + 48) = v68;
    *(_OWORD *)(a6 + 32) = v67;
    goto LABEL_46;
  }
  uint64_t v18 = *((void *)&v71 + 1);
  if (*((void *)&v71 + 1))
  {
    uint64_t v19 = 0;
    unint64_t v20 = 0;
    while (1)
    {
      uint64_t v21 = *((void *)&v71 + 1);
      if (*((void *)&v71 + 1) <= v20) {
        break;
      }
      uint64_t v22 = v71;
      if (!v64[0]) {
        goto LABEL_45;
      }
      uint64_t v23 = v22 + v19;
      if (!v64[0]) {
        goto LABEL_45;
      }
      if (!v64[0]) {
        goto LABEL_45;
      }
      ++v20;
      v19 += 24;
      if (v18 == v20) {
        goto LABEL_9;
      }
    }
LABEL_132:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v21);
    _os_crash();
    __break(1u);
    goto LABEL_133;
  }
LABEL_9:
  if (a5)
  {
    uint64_t v24 = *((void *)a3 + 255);
    if (v24)
    {
      float v25 = (unint64_t *)*((void *)a3 + 257);
      uint64_t v26 = 8 * v24;
      while (1)
      {
        if (!v64[0]) {
          break;
        }
        ++v25;
        v26 -= 8;
        if (!v26) {
          goto LABEL_14;
        }
      }
LABEL_45:
      *(unsigned char *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v65;
      *(void *)(a6 + 24) = v66;
      *(void *)(a6 + 48) = v68;
      *(_OWORD *)(a6 + 32) = v67;
LABEL_46:
      uint64_t v68 = 0;
      uint64_t v66 = 0;
      long long v67 = 0uLL;
      goto LABEL_47;
    }
  }
LABEL_14:
  unint64_t v20 = v63;
  a1[48] = a2;
  a1[49] = v20;
  if (v20)
  {
    if (v20 >> 60) {
      goto LABEL_134;
    }
    uint64_t v27 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * v20, 8);
    a1[50] = v27;
    if (!v27)
    {
LABEL_135:
      re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    unint64_t v28 = v20 - 1;
    if (v20 != 1)
    {
      do
      {
        *(unsigned char *)uint64_t v27 = -1;
        *(void *)(v27 + 8) = -1;
        v27 += 16;
        --v28;
      }
      while (v28);
    }
    *(unsigned char *)uint64_t v27 = -1;
    *(void *)(v27 + 8) = -1;
  }
  for (uint64_t i = 0; i != 24; i += 3)
  {
    unint64_t v20 = *(void *)((char *)v103 + i * 8 + 8);
    unint64_t v30 = &a1[i];
    v30[24] = a2;
    v30[25] = v20;
    if (v20)
    {
      if (v20 >> 60) {
        goto LABEL_130;
      }
      uint64_t v31 = 16 * v20;
      unint64_t v32 = (void *)(*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * v20, 8);
      a1[i + 26] = v32;
      if (!v32) {
        goto LABEL_131;
      }
      uint64_t v33 = v32;
      if (v20 != 1)
      {
        bzero(v32, v31 - 16);
        uint64_t v33 = (void *)((char *)v33 + v31 - 16);
      }
      *uint64_t v33 = 0;
      v33[1] = 0;
    }
  }
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  do
  {
    float32x4_t v36 = (char *)v103 + 24 * v34;
    uint64_t v39 = *((void *)v36 + 1);
    float v37 = (unint64_t *)(v36 + 8);
    uint64_t v38 = v39;
    if (v39)
    {
      uint64_t v40 = 0;
      unint64_t v41 = 0;
      float32x4_t v42 = &a1[3 * v34];
      float v43 = v42 + 25;
      float32x4_t v44 = v42 + 26;
      while (1)
      {
        unint64_t v45 = *v37;
        if (*v37 <= v41) {
          break;
        }
        unint64_t v45 = *v43;
        if (*v43 <= v41) {
          goto LABEL_129;
        }
        uint64_t v46 = *(void *)(*((void *)&v103[1] + 3 * v34) + 8 * v41);
        float v47 = (void *)(*v44 + v40);
        *float v47 = a1[50] + 16 * v35;
        v47[1] = v46;
        v35 += v46;
        ++v41;
        v40 += 16;
        if (v38 == v41) {
          goto LABEL_34;
        }
      }
      uint64_t v102 = 0;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      long long v121 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v113 = 136315906;
      float32x4_t v114 = "operator[]";
      __int16 v115 = 1024;
      int v116 = 468;
      __int16 v117 = 2048;
      unint64_t v118 = v41;
      __int16 v119 = 2048;
      unint64_t v120 = v45;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_129:
      uint64_t v102 = 0;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      long long v121 = 0u;
      unint64_t v20 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v113 = 136315906;
      float32x4_t v114 = "operator[]";
      __int16 v115 = 1024;
      int v116 = 468;
      __int16 v117 = 2048;
      unint64_t v118 = v41;
      __int16 v119 = 2048;
      unint64_t v120 = v45;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_130:
      re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v20);
      _os_crash();
      __break(1u);
LABEL_131:
      re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
      goto LABEL_132;
    }
LABEL_34:
    ++v34;
  }
  while (v34 != 8);
  if (v18)
  {
    uint64_t v49 = 0;
    unint64_t v20 = 0;
    while (1)
    {
      uint64_t v50 = *((void *)&v71 + 1);
      if (*((void *)&v71 + 1) <= v20) {
        break;
      }
      uint64_t v51 = v71 + v49;
      ++v20;
      v49 += 24;
      if (v18 == v20) {
        goto LABEL_39;
      }
    }
LABEL_133:
    re::internal::assertLog((re::internal *)6, v48, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v50);
    _os_crash();
    __break(1u);
LABEL_134:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v20);
    _os_crash();
    __break(1u);
    goto LABEL_135;
  }
LABEL_39:
  if (a5)
  {
    uint64_t v52 = *((void *)a3 + 255);
    if (v52)
    {
      float32x4_t v53 = (unint64_t *)*((void *)a3 + 257);
      uint64_t v54 = 8 * v52;
      do
      {
        unint64_t v55 = *v53++;
        v54 -= 8;
      }
      while (v54);
    }
  }
  *(unsigned char *)a6 = 1;
LABEL_47:
  for (uint64_t j = 168; j != -24; j -= 24)
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)((char *)v103 + j));
  for (uint64_t k = 0; k != -192; k -= 24)
  {
    float32x4_t v58 = (void *)((char *)v107 + k);
    uint64_t v59 = *(void *)((char *)&v111 + k + 8);
    if (v59)
    {
      if (v58[22])
      {
        (*(void (**)(uint64_t, void))(*(void *)v59 + 40))(v59, *(void *)((char *)&v112 + k + 8));
        v58[22] = 0;
        v58[23] = 0;
      }
      v58[21] = 0;
    }
  }
  if (!v64[0] && v66 && (v67 & 1) != 0) {
    (*(void (**)(void))(*(void *)v66 + 40))();
  }
  if (v72 && v73) {
    (*(void (**)(void))(*(void *)v72 + 40))();
  }
  if (*((void *)&v85 + 1))
  {
    if ((void)v86)
    {
      (*(void (**)(void))(**((void **)&v85 + 1) + 40))();
      long long v86 = 0uLL;
    }
    *((void *)&v85 + 1) = 0;
  }
  if ((void)v84)
  {
    if (*((void *)&v84 + 1))
    {
      (*(void (**)(void))(*(void *)v84 + 40))();
      *((void *)&v84 + 1) = 0;
      *(void *)&long long v85 = 0;
    }
    *(void *)&long long v84 = 0;
  }
  if (*((void *)&v82 + 1))
  {
    if ((void)v83)
    {
      (*(void (**)(void))(**((void **)&v82 + 1) + 40))();
      long long v83 = 0uLL;
    }
    *((void *)&v82 + 1) = 0;
  }
  if ((void)v81)
  {
    if (*((void *)&v81 + 1))
    {
      (*(void (**)(void))(*(void *)v81 + 40))();
      *((void *)&v81 + 1) = 0;
      *(void *)&long long v82 = 0;
    }
    *(void *)&long long v81 = 0;
  }
  if (*((void *)&v79 + 1))
  {
    if ((void)v80)
    {
      (*(void (**)(void))(**((void **)&v79 + 1) + 40))();
      long long v80 = 0uLL;
    }
    *((void *)&v79 + 1) = 0;
  }
  if ((void)v78)
  {
    if (*((void *)&v78 + 1))
    {
      (*(void (**)(void))(*(void *)v78 + 40))();
      *((void *)&v78 + 1) = 0;
      *(void *)&long long v79 = 0;
    }
    *(void *)&long long v78 = 0;
  }
  if (*((void *)&v76 + 1))
  {
    if ((void)v77)
    {
      (*(void (**)(void))(**((void **)&v76 + 1) + 40))();
      long long v77 = 0uLL;
    }
    *((void *)&v76 + 1) = 0;
  }
  if ((void)v75 && *((void *)&v75 + 1)) {
    (*(void (**)(void))(*(void *)v75 + 40))();
  }
  if (v87 && v88) {
    (*(void (**)(void))(*(void *)v87 + 40))();
  }
  if (*((void *)&v100 + 1))
  {
    if ((void)v101)
    {
      (*(void (**)(void))(**((void **)&v100 + 1) + 40))();
      long long v101 = 0uLL;
    }
    *((void *)&v100 + 1) = 0;
  }
  if ((void)v99)
  {
    if (*((void *)&v99 + 1))
    {
      (*(void (**)(void))(*(void *)v99 + 40))();
      *((void *)&v99 + 1) = 0;
      *(void *)&long long v100 = 0;
    }
    *(void *)&long long v99 = 0;
  }
  if (*((void *)&v97 + 1))
  {
    if ((void)v98)
    {
      (*(void (**)(void))(**((void **)&v97 + 1) + 40))();
      long long v98 = 0uLL;
    }
    *((void *)&v97 + 1) = 0;
  }
  if ((void)v96)
  {
    if (*((void *)&v96 + 1))
    {
      (*(void (**)(void))(*(void *)v96 + 40))();
      *((void *)&v96 + 1) = 0;
      *(void *)&long long v97 = 0;
    }
    *(void *)&long long v96 = 0;
  }
  if (*((void *)&v94 + 1))
  {
    if ((void)v95)
    {
      (*(void (**)(void))(**((void **)&v94 + 1) + 40))();
      long long v95 = 0uLL;
    }
    *((void *)&v94 + 1) = 0;
  }
  if ((void)v93)
  {
    if (*((void *)&v93 + 1))
    {
      (*(void (**)(void))(*(void *)v93 + 40))();
      *((void *)&v93 + 1) = 0;
      *(void *)&long long v94 = 0;
    }
    *(void *)&long long v93 = 0;
  }
  if (*((void *)&v91 + 1))
  {
    if ((void)v92)
    {
      (*(void (**)(void))(**((void **)&v91 + 1) + 40))();
      long long v92 = 0uLL;
    }
    *((void *)&v91 + 1) = 0;
  }
  uint64_t result = v90;
  if ((void)v90)
  {
    if (*((void *)&v90 + 1)) {
      return (*(uint64_t (**)(void))(*(void *)v90 + 40))();
    }
  }
  return result;
}

void re::anonymous namespace'::countRegisterDependenciesForType<int>(re::Allocator *a1, re::EvaluationTree *a2, char a3, void *a4, uint64_t a5, uint64_t a6, void *a7, unsigned __int8 *a8)
{
  unint64_t v8 = a4[1];
  if (v8)
  {
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = a4[1];
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<unsigned int>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 24);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 24);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<float>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 40);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 40);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<re::Matrix3x3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 56);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 56);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<re::Matrix4x4<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 72);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 72);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<re::Quaternion<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 88);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 88);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<re::Vector2<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 104);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 104);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::countRegisterDependenciesForType<re::Vector3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  unint64_t v8 = *(void *)(a4 + 120);
  if (v8)
  {
    uint64_t v16 = result;
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(void *)(a4 + 120);
      if (v18 <= v17) {
        break;
      }
      if (*a8) {
        BOOL v19 = v17 >= v8;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::anonymous namespace'::countRegisterDependencies(re::Allocator *a1, re::EvaluationTree *a2, char a3, unsigned int a4, unint64_t a5, uint64_t a6, uint64_t a7, void *a8, unsigned __int8 *a9)
{
  unint64_t i = a5;
  unint64_t v15 = (unint64_t)v68;
  uint64_t v115 = *MEMORY[0x263EF8340];
  if (a3)
  {
    ++*a8;
    unint64_t v17 = *(void *)(a7 + 24 * a4 + 8);
    if (v17 <= a5)
    {
LABEL_76:
      *(void *)&long long v57 = 0;
      *(_OWORD *)(v15 + 176) = 0u;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0u;
      *(_OWORD *)(v15 + 128) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v68 = 136315906;
      *(void *)(v15 + 4) = "operator[]";
      *(_WORD *)&v68[12] = 1024;
      *(_DWORD *)(v15 + 14) = 468;
      *(_WORD *)&v68[18] = 2048;
      *(void *)(v15 + 20) = i;
      *(_WORD *)&v68[28] = 2048;
      *(void *)(v15 + 30) = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_77;
    }
    uint64_t v18 = *(void *)(a7 + 24 * a4 + 16);
    ++*(void *)(v18 + 8 * a5);
  }
  uint64_t v19 = a6 + 24 * a4;
  unint64_t v21 = *(void *)(v19 + 8);
  unint64_t v20 = (unint64_t *)(v19 + 8);
  unint64_t v17 = v21;
  if (v21 <= a5)
  {
LABEL_75:
    *(void *)&long long v57 = 0;
    *(_OWORD *)(v15 + 176) = 0u;
    *(_OWORD *)(v15 + 192) = 0u;
    *(_OWORD *)(v15 + 144) = 0u;
    *(_OWORD *)(v15 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0u;
    *(_OWORD *)(v15 + 128) = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v68 = 136315906;
    *(void *)(v15 + 4) = "operator[]";
    *(_WORD *)&v68[12] = 1024;
    *(_DWORD *)(v15 + 14) = 468;
    *(_WORD *)&v68[18] = 2048;
    *(void *)(v15 + 20) = i;
    *(_WORD *)&v68[28] = 2048;
    *(void *)(v15 + 30) = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_76;
  }
  uint64_t v22 = a6 + 24 * a4;
  uint64_t v25 = *(void *)(v22 + 16);
  uint64_t v24 = (void *)(v22 + 16);
  uint64_t v23 = v25;
  int v26 = *(unsigned __int8 *)(v25 + a5);
  if (v26 == 2) {
    return;
  }
  if (v26 == 1)
  {
    *(void *)uint64_t v68 = a1;
    memset(&v68[8], 0, 24);
    re::DynamicString::setCapacity(v68, 0x80uLL);
    re::DynamicString::appendf((re::DynamicString *)v68, "A circular dependency has been detected with register type %u, register id %zu.", a4, i);
    LOBYTE(vre::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
    *((void *)&v80 + 1) = 4000;
    v81[0] = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)&v81[1] = *(_OWORD *)v68;
    uint64_t v81[3] = *(void *)&v68[16];
    *(void *)&long long v82 = *(void *)&v68[24];
    re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)a9, (uint64_t)&v80);
    if (!(_BYTE)v80 && v81[1] && (v81[2] & 1) != 0) {
      (*(void (**)(void))(*(void *)v81[1] + 40))();
    }
    return;
  }
  uint64_t v49 = v24;
  uint64_t v50 = v20;
  *(unsigned char *)(v23 + a5) = 1;
  re::EvaluationTree::getRegister((uint64_t)v56, a2, a4, a5);
  float32x4_t v53 = &(&re::kEvaluationCommandDescriptions)[2 * LODWORD(v56[0])];
  uint64_t v52 = *((unsigned __int8 *)v53 + 9);
  if (!*((unsigned char *)v53 + 9)) {
    goto LABEL_69;
  }
  uint64_t v27 = 0;
  unint64_t v51 = i;
  while (1)
  {
    uint64_t v28 = *((unsigned __int8 *)v53 + v27 + 10);
    unint64_t v29 = v56[v27 + 1];
    uint64_t v54 = v27;
    if (v28 != 253) {
      break;
    }
    uint64_t v34 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[]((uint64_t)a2 + 1608, v29);
    uint64_t v55 = *(void *)(v34 + 40);
    if (!v55) {
      goto LABEL_68;
    }
    uint64_t v35 = v34;
    for (unint64_t i = 0; i != v55; ++i)
    {
      uint64_t v31 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v35, i);
      uint64_t v36 = v31[5];
      if (v36 == -1) {
        goto LABEL_33;
      }
      unint64_t v15 = v36 - 0x7FFFFFFFFFFFFFFFLL;
      if (v36 - 0x7FFFFFFFFFFFFFFFLL < 0) {
        goto LABEL_32;
      }
      uint64_t v37 = v35;
      unint64_t v17 = *((void *)a2 + 88);
      do
      {
        if (v17 <= v15)
        {
          *(void *)&long long v57 = 0;
          long long v82 = 0u;
          long long v83 = 0u;
          memset(v81, 0, sizeof(v81));
          long long v80 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v68 = 136315906;
          *(void *)&v68[4] = "operator[]";
          *(_WORD *)&v68[12] = 1024;
          *(_DWORD *)&v68[14] = 797;
          *(_WORD *)&v68[18] = 2048;
          *(void *)&v68[20] = v15;
          *(_WORD *)&v68[28] = 2048;
          *(void *)&v68[30] = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_74;
        }
        uint64_t v36 = *(void *)(*((void *)a2 + 90) + 8 * v15);
        unint64_t v15 = v36 - 0x7FFFFFFFFFFFFFFFLL;
      }
      while (v36 - 0x7FFFFFFFFFFFFFFFLL >= 0);
      uint64_t v35 = v37;
LABEL_32:
      unint64_t v15 = (unint64_t)v68;
      if (!*a9) {
        return;
      }
LABEL_33:
      uint64_t v38 = (void *)*v31;
      uint64_t v39 = *(void *)(*v31 + 1304);
      *(void *)uint64_t v68 = *(void *)(*v31 + 1320);
      *(void *)&v68[8] = v39;
      uint64_t v40 = v38[168];
      *(void *)&v68[16] = v38[170];
      *(void *)&v68[24] = v40;
      uint64_t v41 = v38[173];
      *(void *)&v68[32] = v38[175];
      uint64_t v69 = v41;
      uint64_t v42 = v38[178];
      uint64_t v70 = v38[180];
      uint64_t v71 = v42;
      uint64_t v43 = v38[183];
      uint64_t v72 = v38[185];
      uint64_t v73 = v43;
      uint64_t v44 = v38[188];
      uint64_t v74 = v38[190];
      uint64_t v75 = v44;
      uint64_t v45 = v38[193];
      uint64_t v76 = v38[195];
      uint64_t v77 = v45;
      uint64_t v46 = v38[200];
      uint64_t v47 = v38[198];
      uint64_t v78 = v46;
      uint64_t v79 = v47;
      long long v89 = 0u;
      long long v90 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v82 = 0u;
      long long v80 = 0u;
      memset(v81, 0, sizeof(v81));
      re::EvaluationTree::resolveAliasRegisters((uint64_t)a2, (uint64_t)a1, (uint64_t *)v68, &v80);
      *(void *)&long long v57 = v81[0];
      *((void *)&v57 + 1) = *((void *)&v80 + 1);
      *(void *)&long long v58 = v81[3];
      *((void *)&v58 + 1) = v81[2];
      *(void *)&long long v59 = v83;
      *((void *)&v59 + 1) = *((void *)&v82 + 1);
      *(void *)&long long v60 = *((void *)&v84 + 1);
      *((void *)&v60 + 1) = v84;
      *(void *)&long long v61 = v86;
      *((void *)&v61 + 1) = *((void *)&v85 + 1);
      uint64_t v62 = *((void *)&v87 + 1);
      uint64_t v63 = v87;
      uint64_t v64 = v89;
      uint64_t v65 = *((void *)&v88 + 1);
      uint64_t v66 = *((void *)&v90 + 1);
      uint64_t v67 = v90;
      int v48 = *a9;
      if (*((void *)&v89 + 1))
      {
        if ((void)v90)
        {
          (*(void (**)(void))(**((void **)&v89 + 1) + 40))();
          long long v90 = 0uLL;
        }
        *((void *)&v89 + 1) = 0;
      }
      if ((void)v88)
      {
        if (*((void *)&v88 + 1))
        {
          (*(void (**)(void))(*(void *)v88 + 40))();
          *((void *)&v88 + 1) = 0;
          *(void *)&long long v89 = 0;
        }
        *(void *)&long long v88 = 0;
      }
      if (*((void *)&v86 + 1))
      {
        if ((void)v87)
        {
          (*(void (**)(void))(**((void **)&v86 + 1) + 40))();
          long long v87 = 0uLL;
        }
        *((void *)&v86 + 1) = 0;
      }
      if ((void)v85)
      {
        if (*((void *)&v85 + 1))
        {
          (*(void (**)(void))(*(void *)v85 + 40))();
          *((void *)&v85 + 1) = 0;
          *(void *)&long long v86 = 0;
        }
        *(void *)&long long v85 = 0;
      }
      if (*((void *)&v83 + 1))
      {
        if ((void)v84)
        {
          (*(void (**)(void))(**((void **)&v83 + 1) + 40))();
          long long v84 = 0uLL;
        }
        *((void *)&v83 + 1) = 0;
      }
      if ((void)v82)
      {
        if (*((void *)&v82 + 1))
        {
          (*(void (**)(void))(*(void *)v82 + 40))();
          *((void *)&v82 + 1) = 0;
          *(void *)&long long v83 = 0;
        }
        *(void *)&long long v82 = 0;
      }
      if (v81[1])
      {
        if (v81[2])
        {
          (*(void (**)(void))(*(void *)v81[1] + 40))();
          v81[2] = 0;
          uint64_t v81[3] = 0;
        }
        v81[1] = 0;
      }
      if ((void)v80 && *((void *)&v80 + 1)) {
        (*(void (**)(void))(*(void *)v80 + 40))();
      }
      if (!v48) {
        return;
      }
    }
LABEL_68:
    uint64_t v27 = v54 + 1;
    unint64_t i = v51;
    if (v54 + 1 == v52)
    {
LABEL_69:
      unint64_t v17 = *v50;
      if (*v50 > i)
      {
        *(unsigned char *)(*v49 + i) = 2;
        return;
      }
LABEL_77:
      *(void *)&long long v57 = 0;
      *(_OWORD *)(v15 + 176) = 0u;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0u;
      *(_OWORD *)(v15 + 128) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v68 = 136315906;
      *(void *)(v15 + 4) = "operator[]";
      *(_WORD *)&v68[12] = 1024;
      *(_DWORD *)(v15 + 14) = 468;
      *(_WORD *)&v68[18] = 2048;
      *(void *)(v15 + 20) = i;
      *(_WORD *)&v68[28] = 2048;
      *(void *)(v15 + 30) = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  if (v28 == 254)
  {
    long long v105 = 0u;
    long long v106 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    long long v80 = 0u;
    memset(v81, 0, sizeof(v81));
    CallbackData = (const re::EvaluationCallbackData *)re::EvaluationTree::getCallbackData(a2, v29);
    re::EvaluationTree::resolveAliasRegisters(a2, a1, CallbackData, (re::EvaluationCallbackData *)&v80);
    *(void *)uint64_t v68 = v81[1];
    *(void *)&v68[8] = v81[0];
    *(void *)&v68[16] = v82;
    *(void *)&v68[24] = v81[3];
    *(void *)&v68[32] = *((void *)&v83 + 1);
    uint64_t v69 = v83;
    uint64_t v70 = v85;
    uint64_t v71 = *((void *)&v84 + 1);
    uint64_t v72 = *((void *)&v86 + 1);
    uint64_t v73 = v86;
    uint64_t v74 = v88;
    uint64_t v75 = *((void *)&v87 + 1);
    uint64_t v76 = *((void *)&v89 + 1);
    uint64_t v77 = v89;
    uint64_t v78 = v91;
    uint64_t v79 = *((void *)&v90 + 1);
    if (!*a9)
    {
LABEL_71:
      re::EvaluationCallbackData::~EvaluationCallbackData((re::EvaluationCallbackData *)&v80);
      return;
    }
    unint64_t i = v92;
    if (!(void)v92)
    {
LABEL_23:
      re::EvaluationCallbackData::~EvaluationCallbackData((re::EvaluationCallbackData *)&v80);
      unint64_t v15 = (unint64_t)v68;
      goto LABEL_68;
    }
    unint64_t v15 = 0;
    uint64_t v31 = 0;
    while (1)
    {
      unint64_t v17 = v92;
      if ((unint64_t)v92 <= (unint64_t)v31) {
        break;
      }
      uint64_t v32 = *((void *)&v92 + 1);
      if (!*a9) {
        goto LABEL_71;
      }
      uint64_t v33 = v32 + v15;
      if (!*a9) {
        goto LABEL_71;
      }
      if (!*a9) {
        goto LABEL_71;
      }
      uint64_t v31 = (void *)((char *)v31 + 1);
      v15 += 24;
      if ((void *)i == v31) {
        goto LABEL_23;
      }
    }
LABEL_74:
    v56[4] = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v57 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v107 = 136315906;
    uint64_t v108 = "operator[]";
    __int16 v109 = 1024;
    int v110 = 468;
    __int16 v111 = 2048;
    long long v112 = v31;
    __int16 v113 = 2048;
    unint64_t v114 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_75;
  }
  if (*a9) {
    goto LABEL_68;
  }
}

void re::anonymous namespace'::storeRegisterDependenciesForType<int>(re::EvaluationTree *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a4[1];
  if (v7)
  {
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = a4[1];
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<unsigned int>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 24);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 24);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<float>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 40);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 40);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<re::Matrix3x3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 56);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 56);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<re::Matrix4x4<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 72);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 72);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<re::Quaternion<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 88);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 88);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<re::Vector2<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 104);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 104);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::storeRegisterDependenciesForType<re::Vector3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a4 + 120);
  if (v7)
  {
    uint64_t v14 = result;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = *(void *)(a4 + 120);
      if (v16 <= v15) {
        break;
      }
      if (v7 == v15) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::anonymous namespace'::storeRegisterDependencies(re::EvaluationTree *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a5;
  uint64_t v112 = *MEMORY[0x263EF8340];
  char v51 = 0;
  v50[0] = &unk_26E6DEC70;
  v50[1] = "Scratch Pad";
  if (a2 != 255)
  {
    unint64_t v14 = *(void *)(a7 + 24 * a4 + 8);
    if (v14 <= a5)
    {
LABEL_66:
      *(void *)&long long v53 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v76 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v64 = 136315906;
      *(void *)&v64[4] = "operator[]";
      *(_WORD *)&v64[12] = 1024;
      *(_DWORD *)&v64[14] = 468;
      *(_WORD *)&v64[18] = 2048;
      *(void *)&v64[20] = v11;
      *(_WORD *)&v64[28] = 2048;
      *(void *)&v64[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_67;
    }
    unint64_t v14 = *(void *)(a8 + 24 * a4 + 8);
    if (v14 <= a5)
    {
LABEL_67:
      *(void *)&long long v53 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v76 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v64 = 136315906;
      *(void *)&v64[4] = "operator[]";
      *(_WORD *)&v64[12] = 1024;
      *(_DWORD *)&v64[14] = 468;
      *(_WORD *)&v64[18] = 2048;
      *(void *)&v64[20] = v11;
      *(_WORD *)&v64[28] = 2048;
      *(void *)&v64[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_68:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v18);
      _os_crash();
      __break(1u);
    }
    uint64_t v15 = *(void *)(a7 + 24 * a4 + 16);
    uint64_t v16 = *(void *)(a8 + 24 * a4 + 16);
    unint64_t v17 = *(void *)(v15 + 8 * a5) - 1;
    *(void *)(v15 + 8 * a5) = v17;
    unint64_t v18 = *(void *)(v16 + 16 * a5 + 8);
    if (v18 <= v17) {
      goto LABEL_68;
    }
    uint64_t v19 = *(void *)(v16 + 16 * a5) + 16 * v17;
    *(unsigned char *)uint64_t v19 = a2;
    *(void *)(v19 + 8) = a3;
  }
  unint64_t v14 = *(void *)(a6 + 24 * a4 + 8);
  if (v14 <= a5)
  {
LABEL_65:
    *(void *)&long long v53 = 0;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v76 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v64 = 136315906;
    *(void *)&v64[4] = "operator[]";
    *(_WORD *)&v64[12] = 1024;
    *(_DWORD *)&v64[14] = 468;
    *(_WORD *)&v64[18] = 2048;
    *(void *)&v64[20] = v11;
    *(_WORD *)&v64[28] = 2048;
    *(void *)&v64[30] = v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_66;
  }
  uint64_t v20 = *(void *)(a6 + 24 * a4 + 16);
  if (!*(unsigned char *)(v20 + a5))
  {
    *(unsigned char *)(v20 + a5) = 1;
    re::EvaluationTree::getRegister((uint64_t)v49, a1, a4, a5);
    uint64_t v46 = &(&re::kEvaluationCommandDescriptions)[2 * v49[0]];
    uint64_t v45 = *((unsigned __int8 *)v46 + 9);
    if (*((unsigned char *)v46 + 9))
    {
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t v22 = *((unsigned __int8 *)v46 + v21 + 10);
        unint64_t v23 = *(void *)&v49[2 * v21 + 2];
        uint64_t v47 = v21;
        if (v22 != 253) {
          break;
        }
        uint64_t v29 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[]((uint64_t)a1 + 1608, v23);
        uint64_t v48 = *(void *)(v29 + 40);
        if (!v48) {
          goto LABEL_61;
        }
        uint64_t v30 = v29;
        for (unint64_t i = 0; i != v48; ++i)
        {
          uint64_t v32 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v30, i);
          uint64_t v33 = v32[5];
          if (v33 == -1) {
            goto LABEL_27;
          }
          unint64_t v27 = v33 - 0x7FFFFFFFFFFFFFFFLL;
          if (v33 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_26;
          }
          uint64_t v34 = v30;
          unint64_t v14 = *((void *)a1 + 88);
          do
          {
            if (v14 <= v27)
            {
              *(void *)&long long v53 = 0;
              long long v79 = 0u;
              long long v80 = 0u;
              long long v77 = 0u;
              long long v78 = 0u;
              long long v76 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)uint64_t v64 = 136315906;
              *(void *)&v64[4] = "operator[]";
              *(_WORD *)&v64[12] = 1024;
              *(_DWORD *)&v64[14] = 797;
              *(_WORD *)&v64[18] = 2048;
              *(void *)&v64[20] = v27;
              *(_WORD *)&v64[28] = 2048;
              *(void *)&v64[30] = v14;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_64;
            }
            uint64_t v33 = *(void *)(*((void *)a1 + 90) + 8 * v27);
            unint64_t v27 = v33 - 0x7FFFFFFFFFFFFFFFLL;
          }
          while (v33 - 0x7FFFFFFFFFFFFFFFLL >= 0);
          uint64_t v30 = v34;
LABEL_26:
LABEL_27:
          uint64_t v35 = (void *)*v32;
          uint64_t v36 = *(void *)(*v32 + 1304);
          *(void *)uint64_t v64 = *(void *)(*v32 + 1320);
          *(void *)&unsigned __int8 v64[8] = v36;
          uint64_t v37 = v35[168];
          *(void *)&v64[16] = v35[170];
          *(void *)&v64[24] = v37;
          uint64_t v38 = v35[173];
          *(void *)&v64[32] = v35[175];
          uint64_t v65 = v38;
          uint64_t v39 = v35[178];
          uint64_t v66 = v35[180];
          uint64_t v67 = v39;
          uint64_t v40 = v35[183];
          uint64_t v68 = v35[185];
          uint64_t v69 = v40;
          uint64_t v41 = v35[188];
          uint64_t v70 = v35[190];
          uint64_t v71 = v41;
          uint64_t v42 = v35[193];
          uint64_t v72 = v35[195];
          uint64_t v73 = v42;
          uint64_t v43 = v35[200];
          uint64_t v44 = v35[198];
          uint64_t v74 = v43;
          uint64_t v75 = v44;
          long long v86 = 0u;
          long long v87 = 0u;
          long long v84 = 0u;
          long long v85 = 0u;
          long long v82 = 0u;
          long long v83 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          long long v76 = 0u;
          long long v77 = 0u;
          re::EvaluationTree::resolveAliasRegisters((uint64_t)a1, (uint64_t)v50, (uint64_t *)v64, &v76);
          *(void *)&long long v53 = v77;
          *((void *)&v53 + 1) = *((void *)&v76 + 1);
          *(void *)&long long v54 = *((void *)&v78 + 1);
          *((void *)&v54 + 1) = v78;
          *(void *)&long long v55 = v80;
          *((void *)&v55 + 1) = *((void *)&v79 + 1);
          *(void *)&long long v56 = *((void *)&v81 + 1);
          *((void *)&v56 + 1) = v81;
          *(void *)&long long v57 = v83;
          *((void *)&v57 + 1) = *((void *)&v82 + 1);
          uint64_t v58 = *((void *)&v84 + 1);
          uint64_t v59 = v84;
          uint64_t v60 = v86;
          uint64_t v61 = *((void *)&v85 + 1);
          uint64_t v62 = *((void *)&v87 + 1);
          uint64_t v63 = v87;
          if (*((void *)&v86 + 1))
          {
            if ((void)v87)
            {
              (*(void (**)(void))(**((void **)&v86 + 1) + 40))();
              long long v87 = 0uLL;
            }
            *((void *)&v86 + 1) = 0;
          }
          if ((void)v85)
          {
            if (*((void *)&v85 + 1))
            {
              (*(void (**)(void))(*(void *)v85 + 40))();
              *((void *)&v85 + 1) = 0;
              *(void *)&long long v86 = 0;
            }
            *(void *)&long long v85 = 0;
          }
          if (*((void *)&v83 + 1))
          {
            if ((void)v84)
            {
              (*(void (**)(void))(**((void **)&v83 + 1) + 40))();
              long long v84 = 0uLL;
            }
            *((void *)&v83 + 1) = 0;
          }
          if ((void)v82)
          {
            if (*((void *)&v82 + 1))
            {
              (*(void (**)(void))(*(void *)v82 + 40))();
              *((void *)&v82 + 1) = 0;
              *(void *)&long long v83 = 0;
            }
            *(void *)&long long v82 = 0;
          }
          if (*((void *)&v80 + 1))
          {
            if ((void)v81)
            {
              (*(void (**)(void))(**((void **)&v80 + 1) + 40))();
              long long v81 = 0uLL;
            }
            *((void *)&v80 + 1) = 0;
          }
          if ((void)v79)
          {
            if (*((void *)&v79 + 1))
            {
              (*(void (**)(void))(*(void *)v79 + 40))();
              *((void *)&v79 + 1) = 0;
              *(void *)&long long v80 = 0;
            }
            *(void *)&long long v79 = 0;
          }
          if (*((void *)&v77 + 1))
          {
            if ((void)v78)
            {
              (*(void (**)(void))(**((void **)&v77 + 1) + 40))();
              long long v78 = 0uLL;
            }
            *((void *)&v77 + 1) = 0;
          }
          if ((void)v76 && *((void *)&v76 + 1)) {
            (*(void (**)(void))(*(void *)v76 + 40))();
          }
        }
LABEL_61:
        uint64_t v21 = v47 + 1;
        if (v47 + 1 == v45) {
          goto LABEL_8;
        }
      }
      if (v22 != 254)
      {
        goto LABEL_61;
      }
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      CallbackData = (const re::EvaluationCallbackData *)re::EvaluationTree::getCallbackData(a1, v23);
      re::EvaluationTree::resolveAliasRegisters(a1, (re::Allocator *)v50, CallbackData, (re::EvaluationCallbackData *)&v76);
      *(void *)uint64_t v64 = *((void *)&v77 + 1);
      *(void *)&unsigned __int8 v64[8] = v77;
      *(void *)&v64[16] = v79;
      *(void *)&v64[24] = *((void *)&v78 + 1);
      *(void *)&v64[32] = *((void *)&v80 + 1);
      uint64_t v65 = v80;
      uint64_t v66 = v82;
      uint64_t v67 = *((void *)&v81 + 1);
      uint64_t v68 = *((void *)&v83 + 1);
      uint64_t v69 = v83;
      uint64_t v70 = v85;
      uint64_t v71 = *((void *)&v84 + 1);
      uint64_t v72 = *((void *)&v86 + 1);
      uint64_t v73 = v86;
      uint64_t v74 = v88;
      uint64_t v75 = *((void *)&v87 + 1);
      uint64_t v25 = v89;
      if (!(void)v89)
      {
LABEL_17:
        re::EvaluationCallbackData::~EvaluationCallbackData((re::EvaluationCallbackData *)&v76);
        goto LABEL_61;
      }
      uint64_t v26 = 0;
      unint64_t v27 = 0;
      while (1)
      {
        unint64_t v14 = v89;
        if ((unint64_t)v89 <= v27) {
          break;
        }
        uint64_t v28 = *((void *)&v89 + 1) + v26;
        ++v27;
        v26 += 24;
        if (v25 == v27) {
          goto LABEL_17;
        }
      }
LABEL_64:
      uint64_t v52 = 0;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v53 = 0u;
      uint64_t v11 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v104 = 136315906;
      long long v105 = "operator[]";
      __int16 v106 = 1024;
      int v107 = 468;
      __int16 v108 = 2048;
      unint64_t v109 = v27;
      __int16 v110 = 2048;
      unint64_t v111 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_65;
    }
  }
LABEL_8:
  re::Allocator::~Allocator((re::Allocator *)v50);
}

uint64_t re::Result<re::Unit,re::DetailedError>::operator=(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    if (!*(unsigned char *)a2)
    {
      *(unsigned char *)a1 = 0;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      uint64_t v3 = *(void *)(a2 + 32);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(void *)(a2 + 24) = 0;
      uint64_t v4 = *(void *)(a2 + 40);
      *(void *)(a2 + 48) = 0;
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      *(void *)(a1 + 32) = v3;
      *(void *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v4;
      *(void *)(a2 + 32) = v6;
      *(void *)(a2 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v5;
    }
  }
  else if (*(unsigned char *)a2)
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
    *(unsigned char *)a1 = 1;
  }
  else
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    re::DynamicString::operator=((re::DynamicString *)(a1 + 24), (re::DynamicString *)(a2 + 24));
  }
  return a1;
}

void *re::EvaluationTree::getRegister(uint64_t a1, void *a2, unsigned __int8 a3, uint64_t a4)
{
  *(_DWORD *)a1 = -1;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  switch(a3)
  {
    case 0u:
      uint64_t result = re::EvaluationTree::getRegister<int>(a2, a4, (_OWORD *)a1);
      break;
    case 1u:
      uint64_t result = re::EvaluationTree::getRegister<unsigned int>(a2, a4, (_OWORD *)a1);
      break;
    case 2u:
      uint64_t result = re::EvaluationTree::getRegister<float>(a2, a4, (_OWORD *)a1);
      break;
    case 3u:
      uint64_t result = re::EvaluationTree::getRegister<re::Matrix3x3<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 4u:
      uint64_t result = re::EvaluationTree::getRegister<re::Matrix4x4<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 5u:
      uint64_t result = re::EvaluationTree::getRegister<re::Quaternion<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 6u:
      uint64_t result = re::EvaluationTree::getRegister<re::Vector2<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 7u:
      uint64_t result = re::EvaluationTree::getRegister<re::Vector3<float>>(a2, a4, (_OWORD *)a1);
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 885, a3);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233222E84);
  }
  return result;
}

void *re::EvaluationTree::getRegister<int>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[83] > v4)
    {
      unint64_t v3 = *(void *)(result[85] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[210] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[212] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<unsigned int>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[88] > v4)
    {
      unint64_t v3 = *(void *)(result[90] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[215] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[217] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<float>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[93] > v4)
    {
      unint64_t v3 = *(void *)(result[95] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[220] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[222] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<re::Matrix3x3<float>>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[98] > v4)
    {
      unint64_t v3 = *(void *)(result[100] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[225] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[227] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<re::Matrix4x4<float>>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[103] > v4)
    {
      unint64_t v3 = *(void *)(result[105] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[230] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[232] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<re::Quaternion<float>>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[108] > v4)
    {
      unint64_t v3 = *(void *)(result[110] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[235] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[237] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<re::Vector2<float>>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[113] > v4)
    {
      unint64_t v3 = *(void *)(result[115] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[240] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[242] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void *re::EvaluationTree::getRegister<re::Vector3<float>>(void *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[118] > v4)
    {
      unint64_t v3 = *(void *)(result[120] + 8 * v4);
      unint64_t v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_4;
      }
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[245] <= v3)
  {
LABEL_52:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (_OWORD *)(result[247] + 32 * v3);
  long long v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  uint64_t v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  uint64_t v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((unsigned char *)v7 + 9)) {
    return result;
  }
  uint64_t v9 = 0;
  do
  {
    unint64_t v10 = *((void *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_41;
    }
    uint64_t v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((unsigned char *)v7 + v9 + 10))
    {
      case 0:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          uint64_t v13 = *(void *)(result[85] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          uint64_t v13 = *(void *)(result[90] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_44:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          uint64_t v13 = *(void *)(result[95] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_45:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          uint64_t v13 = *(void *)(result[100] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_46:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          uint64_t v13 = *(void *)(result[105] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_47:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          uint64_t v13 = *(void *)(result[110] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_48:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        unint64_t v12 = (void *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          uint64_t v13 = *(void *)(result[115] + 8 * v10);
          unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0) {
            goto LABEL_40;
          }
        }
LABEL_49:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        unint64_t v12 = (void *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      uint64_t v13 = *(void *)(result[120] + 8 * v10);
      unint64_t v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *unint64_t v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void re::FixedArray<BOOL>::init<>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (a3)
  {
    uint64_t v5 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3, 1);
    a1[2] = v5;
    if (v5)
    {
      uint64_t v7 = v5;
      size_t v8 = a3 - 1;
      if (v8)
      {
        bzero(v5, v8);
        v7 += v8;
      }
      *uint64_t v7 = 0;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t re::FullBodyIKSolver::FullBodyIKSolver(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v16[4] = *MEMORY[0x263EF8340];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = (uint64_t *)(a1 + 16);
  uint64_t v7 = (void *)(a1 + 56);
  size_t v8 = (uint64_t *)(a1 + 104);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0u;
  uint64_t v9 = (uint64_t *)(a1 + 80);
  v14[0] = &unk_26E6C25E8;
  v14[3] = v14;
  uint64_t v15 = CoreIKGenericSolverCreate();
  uint64_t v16[3] = v16;
  v16[0] = &unk_26E6C25E8;
  std::unique_ptr<CoreIKGenericSolver,std::function<void ()(CoreIKGenericSolver*)>>::operator=[abi:nn180100](v6, &v15);
  std::unique_ptr<CoreIKGenericSolver,std::function<void ()(CoreIKGenericSolver*)>>::~unique_ptr[abi:nn180100](&v15);
  std::__function::__value_func<void ()(CoreIKGenericSolver *)>::~__value_func[abi:nn180100](v14);
  re::StringID::operator=((unint64_t *)a1, a3);
  unint64_t v10 = (_anonymous_namespace_ *)MEMORY[0x237DBA570](a2);
  uint64_t v11 = (_anonymous_namespace_ *)MEMORY[0x237DBA060](a2);
  return a1;
}

uint64_t *std::unique_ptr<CoreIKGenericSolver,std::function<void ()(CoreIKGenericSolver*)>>::operator=[abi:nn180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *a1;
  *a1 = v4;
  if (v5) {
    std::function<void ()(CoreIKGenericSolver *)>::operator()((uint64_t)(a1 + 1), v5);
  }
  std::__function::__value_func<void ()(CoreIKGenericSolver *)>::operator=[abi:nn180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

__n128 re::FullBodyIKSolver::copyPoseToInternal(re::FullBodyIKSolver *this, const re::RigDataValue *a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)a2 + 32);
  if (v2)
  {
    uint64_t v5 = 0;
    for (unint64_t i = 0; i != v2; ++i)
    {
      *(void *)&long long v11 = 0x3F8000003F800000;
      *((void *)&v11 + 1) = 1065353216;
      v12.n128_u64[0] = 0;
      v12.n128_u64[1] = 0x3F80000000000000;
      long long v13 = 0uLL;
      unint64_t v7 = re::RigDataValue::attributeValue(a2, i);
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v7, &v11);
      unint64_t v8 = *((void *)this + 14);
      if (v8 <= i)
      {
        uint64_t v14 = 0;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v23 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v15 = 136315906;
        uint64_t v16 = "operator[]";
        __int16 v17 = 1024;
        int v18 = 468;
        __int16 v19 = 2048;
        unint64_t v20 = i;
        __int16 v21 = 2048;
        unint64_t v22 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      __n128 result = v12;
      uint64_t v10 = *((void *)this + 15) + v5;
      *(_OWORD *)uint64_t v10 = v13;
      *(__n128 *)(v10 + 16) = result;
      v5 += 32;
    }
  }
  return result;
}

_OWORD *re::FullBodyIKSolver::copyInternalToPose(_OWORD *this, re::RigDataValue *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)a2 + 32);
  if (v2)
  {
    uint64_t v4 = (uint64_t)this;
    uint64_t v5 = 0;
    for (unint64_t i = 0; i != v2; ++i)
    {
      if (*(void *)(v4 + 112) <= i)
      {
        long long v15 = 0u;
        long long v16 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        long long v12 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      unint64_t v7 = (long long *)(*(void *)(v4 + 120) + v5);
      uint64_t v9 = *((void *)v7 + 2);
      uint64_t v8 = *((void *)v7 + 3);
      long long v10 = *v7;
      *(void *)&long long v12 = 0x3F8000003F800000;
      *((void *)&v12 + 1) = 1065353216;
      *(void *)&long long v13 = v9;
      *((void *)&v13 + 1) = v8;
      long long v14 = v10;
      unint64_t v11 = re::RigDataValue::attributeValue(a2, i);
      this = re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v11, &v12);
      v5 += 32;
    }
  }
  return this;
}

BOOL re::FullBodyIKSolver::solve(re::FullBodyIKSolver *a1, const re::RigDataValue *a2, re::RigDataValue *a3)
{
  re::FullBodyIKSolver::copyPoseToInternal(a1, a2);
  re::FullBodyIKSolver::applyTaskTargets((uint64_t)a1);
  int v6 = CoreIKGenericSolverSolve();
  if (v6 == 1)
  {
    uint64_t v7 = *((void *)a2 + 32);
    if (v7)
    {
      for (unint64_t i = 0; i != v7; ++i)
      {
        *(void *)&long long v12 = 0x3F8000003F800000;
        *((void *)&v12 + 1) = 1065353216;
        uint64_t v13 = 0;
        uint64_t v14 = 0x3F80000000000000;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        unint64_t v9 = re::RigDataValue::attributeValue(a2, i);
        re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v9, &v12);
        unint64_t v10 = re::RigDataValue::attributeValue(a3, i);
        re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v10, &v12);
      }
    }
  }
  else
  {
    re::FullBodyIKSolver::copyInternalToPose(a1, a3);
  }
  return v6 != 1;
}

uint64_t re::FullBodyIKSolver::applyTaskTargets(uint64_t this)
{
  if (*(void *)(this + 64))
  {
    uint64_t v1 = this;
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    uint64_t v4 = *(void *)(this + 16);
    do
    {
      MEMORY[0x237DBA340](v4, v3);
      if (CoreIKGenericConstraintHasLookAtEnabled())
      {
        if (*(void *)(v1 + 88) <= v3)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        CoreIKGenericConstraintSetLookAtTarget();
      }
      CoreIKGenericConstraintSetTargetTranslation();
      this = CoreIKGenericConstraintSetTargetOrientation();
      ++v3;
      v2 += 48;
    }
    while (v3 < *(void *)(v1 + 64));
  }
  return this;
}

uint64_t re::FullBodyIKSolver::taskName(re::FullBodyIKSolver *this)
{
  uint64_t v1 = MEMORY[0x237DBA340](*((void *)this + 2));
  uint64_t v2 = MEMORY[0x237DBA220](v1);
  return MEMORY[0x270F1A438](v2);
}

uint64_t re::FullBodyIKSolver::taskTargetName(re::FullBodyIKSolver *this)
{
  uint64_t v1 = MEMORY[0x237DBA340](*((void *)this + 2));
  uint64_t v2 = MEMORY[0x237DBA220](v1);
  return MEMORY[0x270F1A430](v2);
}

void re::FullBodyIKSolver::taskPositionEnabled(re::FullBodyIKSolver *this)
{
  uint64_t v1 = MEMORY[0x237DBA340](*((void *)this + 2));
  MEMORY[0x237DBA220](v1);
  JUMPOUT(0x237DBA470);
}

void re::FullBodyIKSolver::taskRotationEnabled(re::FullBodyIKSolver *this)
{
  uint64_t v1 = MEMORY[0x237DBA340](*((void *)this + 2));
  MEMORY[0x237DBA220](v1);
  JUMPOUT(0x237DBA450);
}

__n128 re::FullBodyIKSolver::taskLookAtTarget(re::FullBodyIKSolver *this, unint64_t a2)
{
  if (*((void *)this + 11) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(__n128 *)(*((void *)this + 12) + 16 * a2);
}

uint64_t re::FullBodyIKSolver::setTaskLookAtTarget(uint64_t result, unint64_t a2, __n128 a3)
{
  if (*(void *)(result + 88) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(__n128 *)(*(void *)(result + 96) + 16 * a2) = a3;
  return result;
}

uint64_t re::FullBodyIKSolver::setTaskTargetPosition(uint64_t result, unint64_t a2, __n128 a3)
{
  if (*(void *)(result + 64) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(__n128 *)(*(void *)(result + 72) + 48 * a2 + 32) = a3;
  return result;
}

__n128 re::FullBodyIKSolver::taskTargetRotation(re::FullBodyIKSolver *this, unint64_t a2)
{
  if (*((void *)this + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(__n128 *)(*((void *)this + 9) + 48 * a2 + 16);
}

uint64_t re::FullBodyIKSolver::setTaskTargetRotation(uint64_t this, unint64_t a2, simd_quatf a3)
{
  if (*(void *)(this + 64) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(simd_quatf *)(*(void *)(this + 72) + 48 * a2 + 16) = a3;
  return this;
}

uint64_t re::FullBodyIKSolver::setTaskTargetParameters(uint64_t a1, unint64_t a2, __n128 a3, double a4, __n128 a5)
{
  re::FullBodyIKSolver::setTaskTargetPosition(a1, a2, a3);
  MEMORY[0x237DBA340](*(void *)(a1 + 16), a2);
  CoreIKGenericConstraintSetTranslationTargetBlendWeight();
  simd_quatf v7 = (simd_quatf)a5;
  re::FullBodyIKSolver::setTaskTargetRotation(a1, a2, v7);
  MEMORY[0x237DBA340](*(void *)(a1 + 16), a2);
  return CoreIKGenericConstraintSetOrientationTargetBlendWeight();
}

void *re::allocInfo_FullBodyIKSolver(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73AD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73AD0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73AD8, "FullBodyIKSolver");
    __cxa_guard_release(&qword_26AF73AD0);
  }
  return &unk_26AF73AD8;
}

void re::initInfo_FullBodyIKSolver(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xE798B206CD368F8CLL;
  v10[1] = "FullBodyIKSolver";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73AC8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF73AC8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      simd_quatf v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "m_name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      _MergedGlobals_17 = v8;
      __cxa_guard_release(&qword_26AF73AC8);
    }
  }
  *((void *)this + 2) = 0x8000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &_MergedGlobals_17;
  *((void *)this + 9) = re::internal::defaultConstruct<re::FullBodyIKSolver>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::FullBodyIKSolver>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::FullBodyIKSolver>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::FullBodyIKSolver>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

double re::internal::defaultConstruct<re::FullBodyIKSolver>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  *(void *)(a3 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::FullBodyIKSolver>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  re::FixedArray<CoreIKTransform>::deinit(a3 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a3 + 10);
  re::FixedArray<CoreIKTransform>::deinit(a3 + 7);
  std::unique_ptr<CoreIKGenericSolver,std::function<void ()(CoreIKGenericSolver*)>>::~unique_ptr[abi:nn180100](a3 + 2);
  re::StringID::destroyString((re::StringID *)a3);
}

double re::internal::defaultConstructV2<re::FullBodyIKSolver>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  *(void *)(a1 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  return result;
}

void re::internal::defaultDestructV2<re::FullBodyIKSolver>(uint64_t *a1)
{
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 7);
  std::unique_ptr<CoreIKGenericSolver,std::function<void ()(CoreIKGenericSolver*)>>::~unique_ptr[abi:nn180100](a1 + 2);
  re::StringID::destroyString((re::StringID *)a1);
}

uint64_t re::introspect_FullBodyIKSolver(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"FullBodyIKSolver", (uint64_t (*)(re::internal *))re::allocInfo_FullBodyIKSolver, (re::IntrospectionBase *(*)(void))re::initInfo_FullBodyIKSolver, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FullBodyIKSolver>, this);
}

void std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::~__func()
{
}

void *std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26E6C25E8;
  return result;
}

void std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C25E8;
}

uint64_t std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::operator()()
{
  return CoreIKGenericSolverDestroy();
}

uint64_t std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::target_type()
{
}

void *std::__function::__value_func<void ()(CoreIKGenericSolver *)>::operator=[abi:nn180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<void ()(CoreIKGenericSolver *)>::operator=[abi:nn180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(CoreIKGenericSolver *)>::operator=[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void re::FixedArray<re::FullBodyIKSolver::CorePose>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 32 * a3;
  int v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    uint64_t v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  _OWORD *v8 = 0u;
  v8[1] = 0u;
}

void _ZN2re10FixedArrayIDv3_fE4initIJEEEvPNS_9AllocatorEmDpOT_(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 16 * a3;
  int v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    uint64_t v8 = (_OWORD *)((char *)v8 + v5 - 16);
  }
  _OWORD *v8 = 0u;
}

BOOL re::TimelineClip::childCount(re::TimelineClip *this)
{
  return *((void *)this + 9) != 0;
}

uint64_t re::TimelineClip::child(re::TimelineClip *this)
{
  return *((void *)this + 9);
}

double re::TimelineClip::totalDuration(re::TimelineClip *this)
{
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    if (*((unsigned char *)this + 80)) {
      double v3 = *((double *)this + 11);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*((unsigned char *)this + 96)) {
      double v5 = *((double *)this + 13);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*((unsigned char *)this + 136)) {
    double v4 = *((double *)this + 18);
  }
  return *((double *)this + 16) + v4 / *((float *)this + 38);
}

float re::TimelineClip::timelineDesc@<S0>(re::TimelineClip *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 9);
  if (v4)
  {
    if (*((unsigned char *)this + 80)) {
      double v5 = *((double *)this + 11);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*((unsigned char *)this + 96)) {
      double v7 = *((double *)this + 13);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*((unsigned char *)this + 136) || (double v8 = *((double *)this + 18), v8 == 0.0))
  {
    char v9 = *((unsigned char *)this + 156);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *((unsigned char *)this + 156);
  }
  float v10 = *((double *)this + 16);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *((float *)this + 38);
  if (*((unsigned char *)this + 120)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *((double *)this + 14);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *((unsigned char *)this + 16);
  return result;
}

void re::TimelineClip::~TimelineClip(re::TimelineClip *this)
{
  *(void *)this = &unk_26E6BF1F0;
  uint64_t v1 = (re::TimelineClip *)((char *)this + 24);
  re::DynamicString::deinit((re::TimelineClip *)((char *)this + 40));
  re::StringID::destroyString(v1);
}

{
  re::StringID *v1;
  uint64_t vars8;

  *(void *)this = &unk_26E6BF1F0;
  uint64_t v1 = (re::TimelineClip *)((char *)this + 24);
  re::DynamicString::deinit((re::TimelineClip *)((char *)this + 40));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

ArcSharedObject *re::BlendShapeWeightsDefinition::BlendShapeWeightsDefinition(ArcSharedObject *a1, uint64_t a2, const StringID **a3)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v6 + 16) = a2;
  *(void *)uint64_t v6 = &unk_26E6C26F8;
  *(_OWORD *)(v6 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  double v7 = (_anonymous_namespace_ *)(v6 + 24);
  *(_OWORD *)(v6 + 68) = 0u;
  *(void *)(v6 + 84) = 0x7FFFFFFFLL;
  *(void *)(v6 + 96) = 0;
  re::FixedArray<re::StringID>::init<>((void *)(v6 + 24), a2, (unint64_t)a3[1]);
  re::FixedArray<re::StringID>::operator=(v7, (uint64_t)a3);
  double v8 = a3[1];
  if (v8)
  {
    char v9 = *a3;
    uint64_t v10 = 16 * (void)v8;
    do
    {
      re::StringID::StringID((re::StringID *)v13, v9);
      unint64_t v11 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * ((v13[0] >> 31) ^ (v13[0] >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                         * ((v13[0] >> 31) ^ (v13[0] >> 1))) >> 27));
      *((void *)a1 + 12) ^= (*((void *)a1 + 12) << 6)
                            + (*((void *)a1 + 12) >> 2)
                            - 0x61C8864680B583E9
                            + (v11 ^ (v11 >> 31));
      re::StringID::destroyString((re::StringID *)v13);
      ++v9;
      v10 -= 16;
    }
    while (v10);
  }
  re::BlendShapeWeightsDefinition::buildWeightNameMap(a1);
  return a1;
}

void re::BlendShapeWeightsDefinition::buildWeightNameMap(re::BlendShapeWeightsDefinition *this)
{
  uint64_t v2 = (char *)this + 48;
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 48, *((void *)this + 3), 2 * *((_DWORD *)this + 8));
  *(void *)&v8.var0 = 0;
  if (*((void *)this + 4))
  {
    unint64_t v3 = 0;
    do
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, (StringID *)(*((void *)this + 5) + 16 * v3), &v8);
      unint64_t v3 = *(void *)&v8.var0 + 1;
      *(void *)&v8.var0 = v3;
      unint64_t v4 = *((void *)this + 4);
    }
    while (v3 < v4);
    unint64_t v9 = 0;
    if (v4)
    {
      for (i = 0; i < v4; unint64_t v9 = i)
      {
        uint64_t v6 = strrchr(*(char **)(*((void *)this + 5) + 16 * i + 8), 47);
        if (v6)
        {
          double v7 = v6 + 1;
          *(void *)&v8.var0 = 0;
          v8.var1 = "";
          re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, &v8, &v9);
          re::StringID::destroyString((re::StringID *)&v8);
          unint64_t i = v9;
          unint64_t v4 = *((void *)this + 4);
        }
        ++i;
      }
    }
  }
}

void re::BlendShapeWeights::init(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 3, v4);
}

void re::BlendShapeWeights::deinit(re::BlendShapeWeights *this)
{
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this);
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {

    *((void *)this + 3) = 0;
  }
}

void re::BlendShapeWeights::reset(uint64_t *a1, uint64_t *a2)
{
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 3, *a2);
  if (a1[1] != *(void *)(a1[3] + 32))
  {
    uint64_t v4 = (uint64_t *)*a1;
    if (!*a1)
    {
    }
    re::FixedArray<CoreIKTransform>::deinit(a1);
    unint64_t v5 = *(void *)(a1[3] + 32);
    re::FixedArray<int>::init<>(a1, (uint64_t)v4, v5);
  }
}

void *re::allocInfo_BlendShapeWeights(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_18))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73B68, "BlendShapeWeights");
    __cxa_guard_release(&_MergedGlobals_18);
  }
  return &unk_26AF73B68;
}

void re::initInfo_BlendShapeWeights(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0x3826001B6619E1D6;
  v10[1] = "BlendShapeWeights";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73B60, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF73B60);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      double v7 = re::IntrospectionInfo<re::FixedArray<float>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "weights";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73B58 = v8;
      __cxa_guard_release(&qword_26AF73B60);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF73B58;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BlendShapeWeights>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendShapeWeights>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendShapeWeights>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendShapeWeights>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

uint64_t *re::IntrospectionInfo<re::FixedArray<float>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info = (uint64_t)&unk_26E6C2740;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
    }
    unint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  uint64_t v6 = (re *)re::introspect_float((re *)1, a2);
  if (re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      double v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info, 0);
    qword_2687722E0 = 0x1800000004;
    dword_2687722E8 = v10;
    word_2687722EC = 0;
    *(void *)&xmmword_2687722F0 = 0;
    *((void *)&xmmword_2687722F0 + 1) = 0xFFFFFFFFLL;
    qword_268772300 = v9;
    unk_268772308 = 0;
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info = (uint64_t)&unk_26E6C2740;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      uint64_t v13 = v16;
    }
    else {
      uint64_t v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_2687722F0 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::BlendShapeWeights>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

void re::internal::defaultDestruct<re::BlendShapeWeights>(int a1, int a2, re::BlendShapeWeights *this)
{
}

double re::internal::defaultConstructV2<re::BlendShapeWeights>(_OWORD *a1)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_BlendShapeWeights(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendShapeWeights", (uint64_t (*)(re::internal *))re::allocInfo_BlendShapeWeights, (re::IntrospectionBase *(*)(void))re::initInfo_BlendShapeWeights, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendShapeWeights>, this);
}

uint64_t *re::AnimationValueTraits<re::BlendShapeWeights>::copy(uint64_t *result, uint64_t *a2)
{
  int v3 = result;
  uint64_t v4 = result[3];
  uint64_t v5 = *(void *)(v4 + 32);
  uint64_t v6 = a2[3];
  if (v5 == *(void *)(v6 + 32) && *(void *)(v4 + 96) == *(void *)(v6 + 96))
  {
    return re::FixedArray<float>::operator=(a2, (uint64_t)result);
  }
  else if (v5)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = v3[3];
      if (*(void *)(v9 + 32) <= v8) {
        break;
      }
      double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[3] + 48, (void *)(*(void *)(v9 + 40) + v7));
      if (result)
      {
        if (v3[1] <= v8) {
          goto LABEL_16;
        }
        if (a2[1] <= (unint64_t)*result) {
          goto LABEL_17;
        }
        *(_DWORD *)(a2[2] + 4 * *result) = *(_DWORD *)(v3[2] + 4 * v8);
      }
      ++v8;
      v7 += 16;
      if (v5 == v8) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_17:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

float re::AnimationValueTraits<re::BlendShapeWeights>::combine(void *a1, void *a2, void *a3)
{
  uint64_t v7 = a2;
  unint64_t v8 = a1;
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v9 = a1[3];
  int v10 = *(void **)(v9 + 32);
  uint64_t v11 = a2[3];
  if (v10 != *(void **)(v11 + 32) || *(void *)(v9 + 96) != *(void *)(v11 + 96))
  {
    uint64_t v18 = *(void *)(v7[3] + 32);
    unint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = 0;
    unint64_t v15 = *(void *)(v8[3] + 32);
    if (v15)
    {
      uint64_t v4 = 0;
      unint64_t v19 = 0;
      while (1)
      {
        uint64_t v20 = v8[3];
        unint64_t v13 = *(void *)(v20 + 32);
        if (v13 <= v19) {
          break;
        }
        __int16 v21 = (void *)((char *)v4 + *(void *)(v20 + 40));
        unint64_t v22 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, v21);
        if (v22)
        {
          unint64_t v3 = *v22;
          long long v23 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v7[3] + 48, v21);
          if (v23)
          {
            unint64_t v13 = v8[1];
            if (v13 <= v19) {
              goto LABEL_51;
            }
            unint64_t v13 = *v23;
            uint64_t v5 = (void *)v7[1];
            if ((unint64_t)v5 <= *v23) {
              goto LABEL_52;
            }
            uint64_t v5 = (void *)a3[1];
            if ((unint64_t)v5 <= v3) {
              goto LABEL_53;
            }
            float result = *(float *)(v8[2] + 4 * v19) + *(float *)(v7[2] + 4 * v13);
            *(float *)(a3[2] + 4 * v3) = result;
            unint64_t v3 = v31;
            if (v31 <= v13) {
              goto LABEL_54;
            }
            *(unsigned char *)(v32 + v13) = 1;
          }
          else
          {
            unint64_t v13 = v8[1];
            if (v13 <= v19) {
              goto LABEL_56;
            }
            unint64_t v13 = a3[1];
            if (v13 <= v3) {
              goto LABEL_57;
            }
            float result = *(float *)(v8[2] + 4 * v19);
            *(float *)(a3[2] + 4 * v3) = result;
          }
        }
        ++v19;
        v4 += 2;
        if (v15 == v19) {
          goto LABEL_28;
        }
      }
      uint64_t v33 = 0;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v34 = 136315906;
      uint64_t v35 = "operator[]";
      __int16 v36 = 1024;
      int v37 = 476;
      __int16 v38 = 2048;
      uint64_t v39 = (void *)v19;
      __int16 v40 = 2048;
      uint64_t v41 = (void *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_28:
      unint64_t v13 = *(void *)(v7[3] + 32);
      if (!v13)
      {
LABEL_38:
        if (v30)
        {
          if (v31) {
            (*(void (**)(void))(*(void *)v30 + 40))();
          }
        }
        return result;
      }
      unint64_t v19 = 0;
      unint64_t v8 = 0;
      while (1)
      {
        unint64_t v3 = v31;
        if (v31 <= (unint64_t)v8) {
          break;
        }
        if (!*((unsigned char *)v8 + v32))
        {
          uint64_t v24 = v7[3];
          unint64_t v3 = *(void *)(v24 + 32);
          if (v3 <= (unint64_t)v8) {
            goto LABEL_55;
          }
          long long v25 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (void *)(*(void *)(v24 + 40) + v19));
          if (v25)
          {
            unint64_t v3 = v7[1];
            if (v3 <= v13) {
              goto LABEL_58;
            }
            unint64_t v3 = *v25;
            unint64_t v15 = a3[1];
            if (v15 <= *v25) {
              goto LABEL_59;
            }
            float result = *(float *)(v7[2] + 4 * v13);
            *(float *)(a3[2] + 4 * v3) = result;
          }
        }
        unint64_t v8 = (void *)((char *)v8 + 1);
        v19 += 16;
        if ((void *)v13 == v8) {
          goto LABEL_38;
        }
      }
    }
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = v8;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v19;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v3;
    __int16 v40 = 2048;
    uint64_t v41 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = v8;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v19;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v3;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    uint64_t v33 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v3;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_60;
  }
  if (v9 == a3[3])
  {
    if (v10)
    {
      long long v26 = 0;
      unint64_t v13 = a1[1];
      uint64_t v27 = a1[2];
      unint64_t v8 = (void *)a2[1];
      uint64_t v28 = a2[2];
      uint64_t v7 = (void *)a3[1];
      uint64_t v29 = a3[2];
      while ((void *)v13 != v26)
      {
        if (v8 == v26) {
          goto LABEL_65;
        }
        if (v7 == v26) {
          goto LABEL_66;
        }
        float result = *(float *)(v27 + 4 * (void)v26) + *(float *)(v28 + 4 * (void)v26);
        *(float *)(v29 + 4 * (void)v26) = result;
        long long v26 = (void *)((char *)v26 + 1);
        if (v10 == v26) {
          return result;
        }
      }
LABEL_64:
      uint64_t v30 = 0;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v34 = 136315906;
      uint64_t v35 = "operator[]";
      __int16 v36 = 1024;
      int v37 = 476;
      __int16 v38 = 2048;
      uint64_t v39 = (void *)v13;
      __int16 v40 = 2048;
      uint64_t v41 = (void *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_65:
      uint64_t v30 = 0;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v34 = 136315906;
      uint64_t v35 = "operator[]";
      __int16 v36 = 1024;
      int v37 = 476;
      __int16 v38 = 2048;
      uint64_t v39 = v8;
      __int16 v40 = 2048;
      uint64_t v41 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      uint64_t v30 = 0;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v34 = 136315906;
      uint64_t v35 = "operator[]";
      __int16 v36 = 1024;
      int v37 = 468;
      __int16 v38 = 2048;
      uint64_t v39 = v7;
      __int16 v40 = 2048;
      uint64_t v41 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v10)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = v8[3];
      unint64_t v15 = *(void *)(v14 + 32);
      if (v15 <= v13) {
        break;
      }
      uint64_t v16 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (void *)(*(void *)(v14 + 40) + v12));
      if (v16)
      {
        unint64_t v15 = v8[1];
        if (v15 <= v13) {
          goto LABEL_61;
        }
        unint64_t v15 = v7[1];
        if (v15 <= v13) {
          goto LABEL_62;
        }
        unint64_t v15 = *v16;
        uint64_t v4 = (void *)a3[1];
        if ((unint64_t)v4 <= *v16) {
          goto LABEL_63;
        }
        float result = *(float *)(v8[2] + 4 * v13) + *(float *)(v7[2] + 4 * v13);
        *(float *)(a3[2] + 4 * v15) = result;
      }
      ++v13;
      v12 += 16;
      if (v10 == (void *)v13) {
        return result;
      }
    }
LABEL_60:
    uint64_t v30 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_61:
    uint64_t v30 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_62:
    uint64_t v30 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 476;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v13;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    uint64_t v30 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v34 = 136315906;
    uint64_t v35 = "operator[]";
    __int16 v36 = 1024;
    int v37 = 468;
    __int16 v38 = 2048;
    uint64_t v39 = (void *)v15;
    __int16 v40 = 2048;
    uint64_t v41 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_64;
  }
  return result;
}

void *re::AnimationValueTraits<re::BlendShapeWeights>::invert(void *result, void *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = result[3];
  uint64_t v5 = *(void *)(v4 + 32);
  uint64_t v6 = a2[3];
  if (v5 == *(void *)(v6 + 32) && *(void *)(v4 + 96) == *(void *)(v6 + 96))
  {
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v9 = result[1];
      uint64_t v8 = result[2];
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v9 != v7)
      {
        if (v11 == v7) {
          goto LABEL_22;
        }
        *(float *)(v10 + 4 * v7) = -*(float *)(v8 + 4 * v7);
        if (v5 == ++v7) {
          return result;
        }
      }
      goto LABEL_21;
    }
  }
  else if (v5)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = v3[3];
      if (*(void *)(v14 + 32) <= v13) {
        break;
      }
      float result = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[3] + 48, (void *)(*(void *)(v14 + 40) + v12));
      if (result)
      {
        if (v3[1] <= v13) {
          goto LABEL_19;
        }
        if (a2[1] <= *result) {
          goto LABEL_20;
        }
        *(float *)(a2[2] + 4 * *result) = -*(float *)(v3[2] + 4 * v13);
      }
      ++v13;
      v12 += 16;
      if (v5 == v13) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_22:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

_anonymous_namespace_ *re::AnimationValueTraits<re::BlendShapeWeights>::interpolate(_anonymous_namespace_ *result, void *a2, void *a3, float a4)
{
  uint64_t v9 = a2;
  unint64_t v10 = (unint64_t)result;
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v11 = *((void *)result + 3);
  uint64_t v12 = *(void **)(v11 + 32);
  uint64_t v13 = a2[3];
  if (v12 != *(void **)(v13 + 32) || *(void *)(v11 + 96) != *(void *)(v13 + 96))
  {
    uint64_t v18 = *(void *)(v9[3] + 32);
    unint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v32 = 0;
    unint64_t v17 = *(void *)(*(void *)(v10 + 24) + 32);
    if (v17)
    {
      uint64_t v5 = 0;
      unint64_t v19 = 0;
      float v20 = 1.0 - a4;
      while (1)
      {
        uint64_t v21 = *(void *)(v10 + 24);
        unint64_t v15 = *(void *)(v21 + 32);
        if (v15 <= v19) {
          break;
        }
        unint64_t v22 = (void *)((char *)v5 + *(void *)(v21 + 40));
        long long v23 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, v22);
        if (v23)
        {
          unint64_t v4 = *v23;
          uint64_t v24 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v9[3] + 48, v22);
          if (v24)
          {
            unint64_t v15 = *(void *)(v10 + 8);
            if (v15 <= v19) {
              goto LABEL_51;
            }
            unint64_t v15 = *v24;
            uint64_t v6 = (void *)v9[1];
            if ((unint64_t)v6 <= *v24) {
              goto LABEL_52;
            }
            uint64_t v6 = (void *)a3[1];
            if ((unint64_t)v6 <= v4) {
              goto LABEL_53;
            }
            *(float *)(a3[2] + 4 * v4) = (float)(*(float *)(v9[2] + 4 * v15) * a4)
                                       + (float)(*(float *)(*(void *)(v10 + 16) + 4 * v19) * v20);
            unint64_t v4 = v33;
            if (v33 <= v15) {
              goto LABEL_54;
            }
            *(unsigned char *)(v34 + v15) = 1;
          }
          else
          {
            unint64_t v15 = *(void *)(v10 + 8);
            if (v15 <= v19) {
              goto LABEL_56;
            }
            unint64_t v15 = a3[1];
            if (v15 <= v4) {
              goto LABEL_57;
            }
            *(float *)(a3[2] + 4 * v4) = (float)(a4 * 0.0) + (float)(*(float *)(*(void *)(v10 + 16) + 4 * v19) * v20);
          }
        }
        ++v19;
        v5 += 2;
        if (v17 == v19) {
          goto LABEL_28;
        }
      }
      uint64_t v35 = 0;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v36 = 136315906;
      int v37 = "operator[]";
      __int16 v38 = 1024;
      int v39 = 476;
      __int16 v40 = 2048;
      uint64_t v41 = (void *)v19;
      __int16 v42 = 2048;
      long long v43 = (void *)v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_28:
      unint64_t v15 = *(void *)(v9[3] + 32);
      if (!v15)
      {
LABEL_38:
        float result = v32;
        if (v32)
        {
          if (v33) {
            return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v32 + 40))();
          }
        }
        return result;
      }
      unint64_t v19 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v4 = v33;
        if (v33 <= v10) {
          break;
        }
        if (!*(unsigned char *)(v34 + v10))
        {
          uint64_t v25 = v9[3];
          unint64_t v4 = *(void *)(v25 + 32);
          if (v4 <= v10) {
            goto LABEL_55;
          }
          long long v26 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (void *)(*(void *)(v25 + 40) + v19));
          if (v26)
          {
            unint64_t v4 = v9[1];
            if (v4 <= v10) {
              goto LABEL_58;
            }
            unint64_t v4 = *v26;
            unint64_t v17 = a3[1];
            if (v17 <= *v26) {
              goto LABEL_59;
            }
            *(float *)(a3[2] + 4 * v4) = (float)(*(float *)(v9[2] + 4 * v10) * a4) + (float)((float)(1.0 - a4) * 0.0);
          }
        }
        ++v10;
        v19 += 16;
        if (v15 == v10) {
          goto LABEL_38;
        }
      }
    }
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v10;
    __int16 v42 = 2048;
    long long v43 = (void *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v19;
    __int16 v42 = 2048;
    long long v43 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    __int16 v42 = 2048;
    long long v43 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v4;
    __int16 v42 = 2048;
    long long v43 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    __int16 v42 = 2048;
    long long v43 = (void *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v10;
    __int16 v42 = 2048;
    long long v43 = (void *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v19;
    __int16 v42 = 2048;
    long long v43 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v4;
    __int16 v42 = 2048;
    long long v43 = (void *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v10;
    __int16 v42 = 2048;
    long long v43 = (void *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    uint64_t v35 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v4;
    __int16 v42 = 2048;
    long long v43 = (void *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_60;
  }
  if (v11 == a3[3])
  {
    if (v12)
    {
      uint64_t v27 = 0;
      unint64_t v15 = *((void *)result + 1);
      uint64_t v28 = *((void *)result + 2);
      unint64_t v10 = a2[1];
      uint64_t v29 = a2[2];
      uint64_t v9 = (void *)a3[1];
      uint64_t v30 = a3[2];
      float v31 = 1.0 - a4;
      while ((void *)v15 != v27)
      {
        if ((void *)v10 == v27) {
          goto LABEL_65;
        }
        if (v9 == v27) {
          goto LABEL_66;
        }
        *(float *)(v30 + 4 * (void)v27) = (float)(*(float *)(v29 + 4 * (void)v27) * a4)
                                            + (float)(*(float *)(v28 + 4 * (void)v27) * v31);
        uint64_t v27 = (void *)((char *)v27 + 1);
        if (v12 == v27) {
          return result;
        }
      }
LABEL_64:
      uint64_t v32 = 0;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v36 = 136315906;
      int v37 = "operator[]";
      __int16 v38 = 1024;
      int v39 = 476;
      __int16 v40 = 2048;
      uint64_t v41 = (void *)v15;
      __int16 v42 = 2048;
      long long v43 = (void *)v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_65:
      uint64_t v32 = 0;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v36 = 136315906;
      int v37 = "operator[]";
      __int16 v38 = 1024;
      int v39 = 476;
      __int16 v40 = 2048;
      uint64_t v41 = (void *)v10;
      __int16 v42 = 2048;
      long long v43 = (void *)v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      uint64_t v32 = 0;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v36 = 136315906;
      int v37 = "operator[]";
      __int16 v38 = 1024;
      int v39 = 468;
      __int16 v40 = 2048;
      uint64_t v41 = v9;
      __int16 v42 = 2048;
      long long v43 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v12)
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    while (1)
    {
      uint64_t v16 = *(void *)(v10 + 24);
      unint64_t v17 = *(void *)(v16 + 32);
      if (v17 <= v15) {
        break;
      }
      float result = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (void *)(*(void *)(v16 + 40) + v14));
      if (result)
      {
        unint64_t v17 = *(void *)(v10 + 8);
        if (v17 <= v15) {
          goto LABEL_61;
        }
        unint64_t v17 = v9[1];
        if (v17 <= v15) {
          goto LABEL_62;
        }
        unint64_t v17 = *(void *)result;
        uint64_t v5 = (void *)a3[1];
        if ((unint64_t)v5 <= *(void *)result) {
          goto LABEL_63;
        }
        *(float *)(a3[2] + 4 * v17) = (float)(*(float *)(v9[2] + 4 * v15) * a4)
                                    + (float)(*(float *)(*(void *)(v10 + 16) + 4 * v15) * (float)(1.0 - a4));
      }
      ++v15;
      v14 += 16;
      if (v12 == (void *)v15) {
        return result;
      }
    }
LABEL_60:
    uint64_t v32 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    __int16 v42 = 2048;
    long long v43 = (void *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_61:
    uint64_t v32 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    __int16 v42 = 2048;
    long long v43 = (void *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_62:
    uint64_t v32 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 476;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v15;
    __int16 v42 = 2048;
    long long v43 = (void *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    uint64_t v32 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v36 = 136315906;
    int v37 = "operator[]";
    __int16 v38 = 1024;
    int v39 = 468;
    __int16 v40 = 2048;
    uint64_t v41 = (void *)v17;
    __int16 v42 = 2048;
    long long v43 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_64;
  }
  return result;
}

void re::BlendShapeWeightsDefinition::~BlendShapeWeightsDefinition(re::BlendShapeWeightsDefinition *this)
{
  *(void *)this = &unk_26E6C26F8;
  uint64_t v2 = (void *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 6);
  re::FixedArray<re::StringID>::deinit(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6C26F8;
  uint64_t v2 = (void *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 6);
  re::FixedArray<re::StringID>::deinit(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SharedObject::allocator(re::SharedObject *this)
{
  return *((void *)this + 2);
}

void re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  uint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionFixedArray<float>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<float>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionFixedArray<float>::construct(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<float>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

void re::IntrospectionFixedArray<float>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  re::FixedArray<int>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 4;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<float>::deinit(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

uint64_t re::IntrospectionFixedArray<float>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<float>::isInitialized(uint64_t a1, void *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<float>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 4 * a3;
}

{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 4 * a3;
}

void *re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(void *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *float result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  return re::FixedArray<CoreIKTransform>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  re::FixedArray<int>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = a1[1];
    if (v9)
    {
      uint64_t v10 = (char *)a1[2];
      uint64_t v11 = 4 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 4;
        v11 -= 4;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 16) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1 = a1[2];
  uint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)(*(void *)a1 + 8);
  if (v1 < (int)v3) {
    a1[2] = ++v1;
  }
  if (v3 <= v1) {
    return 0;
  }
  else {
    return *(void *)(v2 + 16) + 4 * v1;
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

uint64_t re::internal::retargetingSolverCallback(uint64_t a1, uint64_t a2, re::RigDataValue *a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, uint64_t a9)
{
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (a4 == 1)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  if (a4 <= 2)
  {
LABEL_22:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (!a8)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v11 = (re::RigDataValue *)((char *)a3 + 288);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::internal::transferPose(v11, a9 + 40);
  re::internal::transferPose(a3, a9 + 16);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  int v12 = CoreIKSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKSolverGetConstraintCount();
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::internal::updateOutputBasedOnSolveResult(v12, (uint64_t)a3, (_OWORD *)(a9 + 16), a7);
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

uint64_t re::internal::retargetingSolverCompile(re::Allocator **a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  v31[4] = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (a3 == 1)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (a3 <= 2)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (a3 == 3)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5) {
    goto LABEL_11;
  }
  uint64_t v6 = *(_anonymous_namespace_ **)(a2[1] + 184);
  uint64_t v7 = (const re::RigDataValue *)a2[3];
  uint64_t v8 = *(_anonymous_namespace_ **)(a2[2] + 184);
  uint64_t v19 = *a4;
  uint64_t v9 = *(const char **)(*a2 + 232);
  size_t v10 = strlen(v9);
  uint64_t v11 = MEMORY[0x237DBA0C0](v9, v10);
  re::internal::makePoseFromRig(a1, v6, v11, (uint64_t)v30);
  re::internal::makeSourcePose(a1, v8, v11, (uint64_t)v29);
  uint64_t v12 = MEMORY[0x237DBA570](v11);
  re::internal::makePose(a1, v12, (uint64_t)v28);
  uint64_t v24 = 0;
  memset(v20, 0, sizeof(v20));
  int v21 = 0;
  memset(v22, 0, sizeof(v22));
  int v23 = 0;
  uint64_t v13 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v20, *a1);
  *(void *)&v25.var0 = 0x10643527A253C4;
  v25.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v20, &v25, (const re::RigDataValue *)v30);
  re::StringID::destroyString((re::StringID *)&v25);
  *(void *)&v25.var0 = 0x104A00692196D8;
  v25.var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v20, &v25, (const re::RigDataValue *)v29);
  re::StringID::destroyString((re::StringID *)&v25);
  *(void *)&v25.var0 = 0xF3F1BA25D000CB3ALL;
  v25.var1 = "SolverToComponentTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v20, &v25, v7);
  re::StringID::destroyString((re::StringID *)&v25);
  *(void *)&v25.var0 = 0xDC3EE39E3142978ELL;
  v25.var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v20, &v25, (re::RigDataValue *)v28);
  re::StringID::destroyString((re::StringID *)&v25);
  uint64_t v14 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 64, 8);
  *(void *)uint64_t v14 = MEMORY[0x237DBA0D0](v11);
  *(void *)(v14 + 8) = v13;
  *(_OWORD *)(v14 + 32) = 0u;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 16) = 0u;
  unint64_t v15 = MEMORY[0x237DBA570](v11);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v14 + 16), (uint64_t)v13, v15);
  unint64_t v16 = MEMORY[0x237DBA550](v11);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v14 + 40), (uint64_t)v13, v16);
  v31[0] = &unk_26E6C27D8;
  v31[1] = v13;
  v31[3] = v31;
  p_var1 = &v25.var1;
  *(void *)&v25.var0 = v14;
  v25.var1 = (char *)&unk_26E6C27D8;
  long long v26 = v13;
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v31);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v20, (uint64_t)a1, (uint64_t)re::internal::retargetingSolverCallback, (uint64_t *)&v25);
  double v17 = re::internal::bindCallbackOutputToNodeOutputPose(v6, (re::RigDataValue *)v28, v11, (uint64_t)a1, v19);
  MEMORY[0x237DBA110](v11, v17);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v25);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v22 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v20 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v28);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v29);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v30);
  return 1;
}

uint64_t re::internal::arvinoToArvinoRetargetNodeCallback(int a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, int a6, re::RigDataValue *a7, uint64_t a8, re::internal::AutoRetargetRigGraphNode *a9)
{
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (a4 == 1)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a4 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (a4 == 3)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (a4 <= 4)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  if (!a8)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t result = re::internal::AutoRetargetRigGraphNode::initialize(a9, (const re::RigDataValue *)(a3 + 576), (const re::RigDataValue *)(a3 + 864), (const re::RigDataValue *)(a3 + 1152), (const re::RigDataValue *)(a3 + 1152));
  if (result)
  {
    return re::internal::AutoRetargetRigGraphNode::solveAndUpdate(a9, a3, (const re::RigDataValue *)(a3 + 288), a7);
  }
  return result;
}

uint64_t re::internal::arvinoToArvinoRetargetNodeCompile(re::Allocator **a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_55;
  }
  if (a3 == 1)
  {
LABEL_55:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_56;
  }
  if (a3 <= 2)
  {
LABEL_56:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
LABEL_57:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5) {
    goto LABEL_57;
  }
  uint64_t v6 = *(uint64_t **)(*a2 + 184);
  uint64_t v7 = *(re::RigHierarchy **)(a2[1] + 184);
  uint64_t v8 = (const re::RigDataValue *)a2[2];
  uint64_t v14 = *a4;
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)v6, (uint64_t)v89);
  re::RigHierarchy::getBindPoseHierarchy((re::RigHierarchy *)v6, v9, (uint64_t)&v68);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v68, (uint64_t)v88);
  re::internal::makePoseFromRigHierarchy(a1, v7, (uint64_t)v87);
  re::RigHierarchy::getBindPoseHierarchy(v7, v10, (uint64_t)&v52);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v52, (uint64_t)v86);
  re::internal::makePose(a1, v6[27], (uint64_t)v85);
  uint64_t v51 = 0;
  memset(v47, 0, sizeof(v47));
  memset(v49, 0, sizeof(v49));
  int v48 = 0;
  int v50 = 0;
  uint64_t v13 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v47, *a1);
  *(void *)&v84[0].var0 = 0x10643527A253C4;
  v84[0].var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v47, v84, (const re::RigDataValue *)v89);
  re::StringID::destroyString((re::StringID *)v84);
  *(void *)&v84[0].var0 = 0x104A00692196D8;
  v84[0].var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v47, v84, (const re::RigDataValue *)v87);
  re::StringID::destroyString((re::StringID *)v84);
  *(void *)&v84[0].var0 = 0xFC2B6F833ABE967ELL;
  v84[0].var1 = "TargetBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v47, v84, (const re::RigDataValue *)v88);
  re::StringID::destroyString((re::StringID *)v84);
  *(void *)&v84[0].var0 = 0x8AE112C755FE2F92;
  v84[0].var1 = "SourceBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v47, v84, (const re::RigDataValue *)v86);
  re::StringID::destroyString((re::StringID *)v84);
  *(void *)&v84[0].var0 = 0xB88303615935B0FCLL;
  v84[0].var1 = "ModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v47, v84, v8);
  re::StringID::destroyString((re::StringID *)v84);
  *(void *)&v84[0].var0 = 0xDC3EE39E3142978ELL;
  v84[0].var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v47, v84, (re::RigDataValue *)v85);
  re::StringID::destroyString((re::StringID *)v84);
  long long v31 = v68;
  uint64_t v32 = v69;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v33, (uint64_t)v70);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v34, (uint64_t)v71);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)v35, v72);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)v36, v73);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)v37, v74);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v38, v75);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)v41, v78);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v44, v81);
  long long v15 = v52;
  uint64_t v16 = v53;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v17, (uint64_t)v54);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v18, (uint64_t)v55);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)v19, v56);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)v20, v57);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)v21, v58);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v22, v59);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)v25, v62);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v28, v65);
  re::internal::makeNodeUnique<re::internal::AutoRetargetRigGraphNode,re::Allocator,re::RigHierarchy,re::RigHierarchy>((re::internal::AutoRetargetRigGraphNode **)v84, v13, (const re::RigHierarchy *)&v31, (const re::RigHierarchy *)&v15);
  if (v28[0])
  {
    if (v30) {
      (*(void (**)(void))(*(void *)v28[0] + 40))();
    }
    uint64_t v30 = 0;
    memset(v28, 0, sizeof(v28));
    ++v29;
  }
  if (v25[0])
  {
    if (v27) {
      (*(void (**)(void))(*(void *)v25[0] + 40))();
    }
    uint64_t v27 = 0;
    memset(v25, 0, sizeof(v25));
    ++v26;
  }
  if (v22[0])
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v22[0] + 40))();
    }
    uint64_t v24 = 0;
    memset(v22, 0, sizeof(v22));
    ++v23;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v21);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v20);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v19);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v18);
  v11.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v17);
  if (v44[0])
  {
    if (v46) {
      (*(void (**)(double))(*(void *)v44[0] + 40))(v11.n128_f64[0]);
    }
    uint64_t v46 = 0;
    memset(v44, 0, sizeof(v44));
    ++v45;
  }
  if (v41[0])
  {
    if (v43) {
      (*(void (**)(__n128))(*(void *)v41[0] + 40))(v11);
    }
    uint64_t v43 = 0;
    memset(v41, 0, sizeof(v41));
    ++v42;
  }
  if (v38[0])
  {
    if (v40) {
      (*(void (**)(__n128))(*(void *)v38[0] + 40))(v11);
    }
    uint64_t v40 = 0;
    memset(v38, 0, sizeof(v38));
    ++v39;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v37);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v36);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v35);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v34);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v33);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v47, (uint64_t)a1, (uint64_t)re::internal::arvinoToArvinoRetargetNodeCallback, (uint64_t *)v84);
  re::internal::bindCallbackOutputToNodeOutputPose((re::RigHierarchy *)v6, (re::RigDataValue *)v85, v14, (uint64_t)a1);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)v84);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v49[8]);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v47 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v85);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v86);
  if (v65[0])
  {
    if (v67) {
      (*(void (**)(void))(*(void *)v65[0] + 40))();
    }
    uint64_t v67 = 0;
    memset(v65, 0, sizeof(v65));
    ++v66;
  }
  if (v62[0])
  {
    if (v64) {
      (*(void (**)(void))(*(void *)v62[0] + 40))();
    }
    uint64_t v64 = 0;
    memset(v62, 0, sizeof(v62));
    ++v63;
  }
  if (v59[0])
  {
    if (v61) {
      (*(void (**)(void))(*(void *)v59[0] + 40))();
    }
    uint64_t v61 = 0;
    memset(v59, 0, sizeof(v59));
    ++v60;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v58);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v57);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v56);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v55);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v54);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v87);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v88);
  if (v81[0])
  {
    if (v83) {
      (*(void (**)(void))(*(void *)v81[0] + 40))();
    }
    uint64_t v83 = 0;
    memset(v81, 0, sizeof(v81));
    ++v82;
  }
  if (v78[0])
  {
    if (v80) {
      (*(void (**)(void))(*(void *)v78[0] + 40))();
    }
    uint64_t v80 = 0;
    memset(v78, 0, sizeof(v78));
    ++v79;
  }
  if (v75[0])
  {
    if (v77) {
      (*(void (**)(void))(*(void *)v75[0] + 40))();
    }
    uint64_t v77 = 0;
    memset(v75, 0, sizeof(v75));
    ++v76;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v74);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v73);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v72);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v71);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v70);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v89);
  return 1;
}

void *re::internal::makeNodeUnique<re::internal::AutoRetargetRigGraphNode,re::Allocator,re::RigHierarchy,re::RigHierarchy>(re::internal::AutoRetargetRigGraphNode **a1, re::Allocator *a2, const re::RigHierarchy *a3, const re::RigHierarchy *a4)
{
  void v11[4] = *MEMORY[0x263EF8340];
  uint64_t v8 = (re::internal::AutoRetargetRigGraphNode *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 144, 8);
  uint64_t v9 = re::internal::AutoRetargetRigGraphNode::AutoRetargetRigGraphNode(v8, a2, a3, a4);
  v11[0] = &unk_26E6C2858;
  v11[1] = a2;
  _OWORD v11[3] = v11;
  a1[4] = (re::internal::AutoRetargetRigGraphNode *)(a1 + 1);
  *a1 = v9;
  a1[1] = (re::internal::AutoRetargetRigGraphNode *)&unk_26E6C2858;
  a1[2] = a2;
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v11);
}

uint64_t re::internal::bipedToBipedAutoRetargetNodeCallback(int a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, int a6, re::RigDataValue *a7, uint64_t a8, re::internal::AutoRetargetRigGraphNode *a9)
{
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a4 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (a4 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (a4 == 3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  if (a4 <= 4)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  if (a4 == 5)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (!a8)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t result = re::internal::AutoRetargetRigGraphNode::initialize(a9, (const re::RigDataValue *)(a3 + 576), (const re::RigDataValue *)(a3 + 864), (const re::RigDataValue *)(a3 + 1152), (const re::RigDataValue *)(a3 + 1440));
  if (result)
  {
    return re::internal::AutoRetargetRigGraphNode::solveAndUpdate(a9, a3, (const re::RigDataValue *)(a3 + 288), a7);
  }
  return result;
}

uint64_t re::internal::bipedToBipedAutoRetargetNodeCompile(re::Allocator **a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_56;
  }
  if (a3 == 1)
  {
LABEL_56:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_57;
  }
  if (a3 <= 2)
  {
LABEL_57:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_58;
  }
  if (a3 == 3)
  {
LABEL_58:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
LABEL_59:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5) {
    goto LABEL_59;
  }
  uint64_t v6 = *(uint64_t **)(*a2 + 184);
  uint64_t v7 = *(re::RigHierarchy **)(a2[1] + 184);
  uint64_t v9 = (const re::RigDataValue *)a2[2];
  uint64_t v8 = (const re::RigDataValue *)a2[3];
  uint64_t v15 = *a4;
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)v6, (uint64_t)v90);
  re::RigHierarchy::getBindPoseHierarchy((re::RigHierarchy *)v6, v10, (uint64_t)&v69);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v69, (uint64_t)v89);
  re::internal::makePoseFromRigHierarchy(a1, v7, (uint64_t)v88);
  re::RigHierarchy::getBindPoseHierarchy(v7, v11, (uint64_t)&v53);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v53, (uint64_t)v87);
  re::internal::makePose(a1, v6[27], (uint64_t)v86);
  uint64_t v52 = 0;
  memset(v48, 0, sizeof(v48));
  memset(v50, 0, sizeof(v50));
  int v49 = 0;
  int v51 = 0;
  uint64_t v14 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v48, *a1);
  *(void *)&v85[0].var0 = 0x10643527A253C4;
  v85[0].var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, (const re::RigDataValue *)v90);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0x104A00692196D8;
  v85[0].var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, (const re::RigDataValue *)v88);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0xFC2B6F833ABE967ELL;
  v85[0].var1 = "TargetBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, (const re::RigDataValue *)v89);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0x8AE112C755FE2F92;
  v85[0].var1 = "SourceBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, (const re::RigDataValue *)v87);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0xE3E7F62755B346DALL;
  v85[0].var1 = "TargetModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, v9);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0x8128E1FAEBA80E46;
  v85[0].var1 = "SourceModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v48, v85, v8);
  re::StringID::destroyString((re::StringID *)v85);
  *(void *)&v85[0].var0 = 0xDC3EE39E3142978ELL;
  v85[0].var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v48, v85, (re::RigDataValue *)v86);
  re::StringID::destroyString((re::StringID *)v85);
  long long v32 = v69;
  uint64_t v33 = v70;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v34, (uint64_t)v71);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v35, (uint64_t)v72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)v36, v73);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)v37, v74);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)v38, v75);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v39, v76);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)v42, v79);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v45, v82);
  long long v16 = v53;
  uint64_t v17 = v54;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v18, (uint64_t)v55);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v19, (uint64_t)v56);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)v20, v57);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)v21, v58);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)v22, v59);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v23, v60);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)v26, v63);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)v29, v66);
  re::internal::makeNodeUnique<re::internal::AutoRetargetRigGraphNode,re::Allocator,re::RigHierarchy,re::RigHierarchy>((re::internal::AutoRetargetRigGraphNode **)v85, v14, (const re::RigHierarchy *)&v32, (const re::RigHierarchy *)&v16);
  if (v29[0])
  {
    if (v31) {
      (*(void (**)(void))(*(void *)v29[0] + 40))();
    }
    uint64_t v31 = 0;
    memset(v29, 0, sizeof(v29));
    ++v30;
  }
  if (v26[0])
  {
    if (v28) {
      (*(void (**)(void))(*(void *)v26[0] + 40))();
    }
    uint64_t v28 = 0;
    memset(v26, 0, sizeof(v26));
    ++v27;
  }
  if (v23[0])
  {
    if (v25) {
      (*(void (**)(void))(*(void *)v23[0] + 40))();
    }
    uint64_t v25 = 0;
    memset(v23, 0, sizeof(v23));
    ++v24;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v22);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v21);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v20);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v19);
  v12.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v18);
  if (v45[0])
  {
    if (v47) {
      (*(void (**)(double))(*(void *)v45[0] + 40))(v12.n128_f64[0]);
    }
    uint64_t v47 = 0;
    memset(v45, 0, sizeof(v45));
    ++v46;
  }
  if (v42[0])
  {
    if (v44) {
      (*(void (**)(__n128))(*(void *)v42[0] + 40))(v12);
    }
    uint64_t v44 = 0;
    memset(v42, 0, sizeof(v42));
    ++v43;
  }
  if (v39[0])
  {
    if (v41) {
      (*(void (**)(__n128))(*(void *)v39[0] + 40))(v12);
    }
    uint64_t v41 = 0;
    memset(v39, 0, sizeof(v39));
    ++v40;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v38);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v37);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v36);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v35);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v34);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v48, (uint64_t)a1, (uint64_t)re::internal::bipedToBipedAutoRetargetNodeCallback, (uint64_t *)v85);
  re::internal::bindCallbackOutputToNodeOutputPose((re::RigHierarchy *)v6, (re::RigDataValue *)v86, v15, (uint64_t)a1);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)v85);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v50[8]);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v48 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v86);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v87);
  if (v66[0])
  {
    if (v68) {
      (*(void (**)(void))(*(void *)v66[0] + 40))();
    }
    uint64_t v68 = 0;
    memset(v66, 0, sizeof(v66));
    ++v67;
  }
  if (v63[0])
  {
    if (v65) {
      (*(void (**)(void))(*(void *)v63[0] + 40))();
    }
    uint64_t v65 = 0;
    memset(v63, 0, sizeof(v63));
    ++v64;
  }
  if (v60[0])
  {
    if (v62) {
      (*(void (**)(void))(*(void *)v60[0] + 40))();
    }
    uint64_t v62 = 0;
    memset(v60, 0, sizeof(v60));
    ++v61;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v59);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v58);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v57);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v56);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v55);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v88);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v89);
  if (v82[0])
  {
    if (v84) {
      (*(void (**)(void))(*(void *)v82[0] + 40))();
    }
    uint64_t v84 = 0;
    memset(v82, 0, sizeof(v82));
    ++v83;
  }
  if (v79[0])
  {
    if (v81) {
      (*(void (**)(void))(*(void *)v79[0] + 40))();
    }
    uint64_t v81 = 0;
    memset(v79, 0, sizeof(v79));
    ++v80;
  }
  if (v76[0])
  {
    if (v78) {
      (*(void (**)(void))(*(void *)v76[0] + 40))();
    }
    uint64_t v78 = 0;
    memset(v76, 0, sizeof(v76));
    ++v77;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)v75);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::deinit((uint64_t)v74);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::deinit((uint64_t)v73);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v72);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v71);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v90);
  return 1;
}

void re::internal::registerRetargetingSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE15D8;
  _OWORD v7[3] = *(_OWORD *)&off_264BE15E8;
  _OWORD v7[4] = xmmword_264BE15F8;
  v7[0] = xmmword_264BE15B8;
  v7[1] = *(_OWORD *)&off_264BE15C8;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::retargetingSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerArvinoToArvinoRetargetNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE1608;
  v7[1] = *(_OWORD *)&off_264BE1618;
  uint64_t v7[2] = xmmword_264BE1628;
  _OWORD v7[3] = *(_OWORD *)&off_264BE1638;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 3uLL, 1uLL, (unint64_t)re::internal::arvinoToArvinoRetargetNodeCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerBipedToBipedRetargetNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE1668;
  _OWORD v7[3] = *(_OWORD *)&off_264BE1678;
  _OWORD v7[4] = xmmword_264BE1688;
  v7[0] = xmmword_264BE1648;
  v7[1] = *(_OWORD *)&off_264BE1658;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::bipedToBipedAutoRetargetNodeCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6C27D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C27D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, void *a2)
{
  uint64_t v2 = (void *)*a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    MEMORY[0x237DBA120](*v2);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 5);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 2);
    unint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_33CoreIKRetargetingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_33CoreIKRetargetingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_;
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6C2858;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE7__cloneEPNS0_6__baseISH_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C2858;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EEclEOSD_(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (*v2) {
      MEMORY[0x237DBA120]();
    }
    re::FixedArray<CoreIKTransform>::deinit(v2 + 13);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 10);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 7);
    re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v2 + 4);
    re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v2 + 1);
    unint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_24AutoRetargetRigGraphNodeENS_9AllocatorEJNS_12RigHierarchyES4_EEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_24AutoRetargetRigGraphNodeENS_9AllocatorEJNS_12RigHierarchyES4_EEEDaPT0_DpT1_EUlPvE_;
}

void re::introspect_AnimationHandoffType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73BE8, memory_order_acquire) & 1) == 0)
  {
    int v24 = (re *)__cxa_guard_acquire(&qword_26AF73BE8);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      int v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)int v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "SnapshotAndReplace";
      qword_26AF73C20 = (uint64_t)v26;
      int v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Replace";
      qword_26AF73C28 = (uint64_t)v28;
      int v29 = re::introspectionAllocator(v28);
      int v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)int v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "Compose";
      qword_26AF73C30 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      long long v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)long long v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "Stop";
      qword_26AF73C38 = (uint64_t)v32;
      uint64_t v33 = re::introspectionAllocator(v32);
      uint64_t v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "UpdateBaseAndCompose";
      qword_26AF73C40 = (uint64_t)v34;
      uint64_t v35 = re::introspectionAllocator(v34);
      uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = 5;
      *(void *)(v36 + 16) = "ComposeAndUpdateBase";
      qword_26AF73C48 = v36;
      __cxa_guard_release(&qword_26AF73BE8);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73BF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73BF0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF73C50, "AnimationHandoffType", 4, 4, 1, 1);
    qword_26AF73C50 = (uint64_t)&unk_26E715E00;
    qword_26AF73C90 = (uint64_t)&re::introspect_AnimationHandoffType(BOOL)::enumTable;
    dword_26AF73C60 = 9;
    __cxa_guard_release(&qword_26AF73BF0);
  }
  if ((_MergedGlobals_19 & 1) == 0)
  {
    _MergedGlobals_19 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF73C50, a2);
    uint64_t v38 = 0x8FFDC97622DE77ECLL;
    int v39 = "AnimationHandoffType";
    v42[0] = 208862;
    v42[1] = "int";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v42);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v42);
      unint64_t v4 = (unsigned int *)qword_26AF73C90;
      v41[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  __n128 v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v40.var0 = 2 * v10;
            v40.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v14, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    float v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v40.var0 = 2 * v18;
              v40.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v22, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v23);
      xmmword_26AF73C70 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "AnimationHandoffType", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_AnimationHandoffDesc(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73BF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73BF8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73C98, "AnimationHandoffDesc");
    __cxa_guard_release(&qword_26AF73BF8);
  }
  return &unk_26AF73C98;
}

void re::initInfo_AnimationHandoffDesc(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x8FFDC97622CF569ALL;
  v17[1] = "AnimationHandoffDesc";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73C00, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF73C00);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "fadeDuration";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x400000001;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73C08 = v8;
      uint64_t v9 = (re *)re::introspectionAllocator((re *)v8);
      re::introspect_AnimationHandoffType(v9, v10);
      uint64_t v11 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "type";
      *(void *)(v11 + 16) = &qword_26AF73C50;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 2;
      *(_DWORD *)(v11 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF73C10 = v11;
      __n128 v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_BOOL((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "layerOnly";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x800000003;
      *(_DWORD *)(v15 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF73C18 = v15;
      __cxa_guard_release(&qword_26AF73C00);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF73C08;
  *((void *)this + 9) = re::internal::defaultConstruct<re::AnimationHandoffDesc>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::AnimationHandoffDesc>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::AnimationHandoffDesc>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::AnimationHandoffDesc>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

void re::internal::defaultConstruct<re::AnimationHandoffDesc>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(a3 + 8) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 12) = 0x80000000;
  *(void *)(a3 + 16) = "";
}

uint64_t re::internal::defaultConstructV2<re::AnimationHandoffDesc>(uint64_t result)
{
  *(unsigned char *)(result + 8) = 0;
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 12) = 0x80000000;
  *(void *)(result + 16) = "";
  return result;
}

uint64_t re::introspect_AnimationHandoffDesc(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AnimationHandoffDesc", (uint64_t (*)(re::internal *))re::allocInfo_AnimationHandoffDesc, (re::IntrospectionBase *(*)(void))re::initInfo_AnimationHandoffDesc, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AnimationHandoffDesc>, this);
}

void re::TimelineGroup::timelineDesc(re::TimelineGroup *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 10);
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*((void *)this + 11);
    uint64_t v6 = 8 * v4;
    double v7 = 0.0;
    do
    {
      uint64_t v8 = *v5++;
      double v9 = (*(double (**)(uint64_t))(*(void *)v8 + 40))(v8);
      if (v7 < v9) {
        double v7 = v9;
      }
      v6 -= 8;
    }
    while (v6);
    float v10 = v7;
  }
  else
  {
    float v10 = 0.0;
  }
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v10;
  *(void *)(a2 + 8) = 1065353216;
  *(float *)(a2 + 16) = v10;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 25) = *((unsigned char *)this + 16);
}

double re::TimelineGroup::totalDuration(re::TimelineGroup *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (!v1) {
    return 0.0;
  }
  uint64_t v2 = (uint64_t *)*((void *)this + 11);
  uint64_t v3 = 8 * v1;
  double v4 = 0.0;
  do
  {
    uint64_t v5 = *v2++;
    double v6 = (*(double (**)(uint64_t))(*(void *)v5 + 40))(v5);
    if (v4 < v6) {
      double v4 = v6;
    }
    v3 -= 8;
  }
  while (v3);
  return v4;
}

void re::TimelineGroup::~TimelineGroup(re::TimelineGroup *this)
{
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::TimelineGroup *)((char *)this + 40));
  re::StringID::destroyString((re::TimelineGroup *)((char *)this + 24));
}

{
  uint64_t vars8;

  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9);
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::TimelineGroup *)((char *)this + 40));
  re::StringID::destroyString((re::TimelineGroup *)((char *)this + 24));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TimelineGroup::childCount(re::TimelineGroup *this)
{
  return *((void *)this + 10);
}

uint64_t re::TimelineGroup::child(re::TimelineGroup *this, unint64_t a2)
{
  if (*((void *)this + 10) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*((void *)this + 11) + 8 * a2);
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks(re::internal::CoreIKFootPlacementSolverNodeHelper *this, const re::RigDataValue *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t result = CoreIKFootPlacementSolverGetGenericSolver();
  uint64_t v4 = *((void *)a2 + 32);
  if (v4)
  {
    uint64_t v5 = result;
    for (unint64_t i = 0; i != v4; ++i)
    {
      double v7 = (re::RigDataValue *)re::RigDataValue::attributeValue(a2, i);
      re::internal::getRuntimeValue<re::internal::IKLookAtTaskSettings>(v7, (uint64_t)&v8);
      MEMORY[0x237DBA340](v5, v9);
      uint64_t result = CoreIKGenericConstraintSetLookAtParameters();
    }
  }
  return result;
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(float32x4_t *a1, re::RigDataValue *a2, float32x4_t *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t result = CoreIKFootPlacementSolverGetConstraintCount();
  if (result)
  {
    uint64_t v7 = result;
    unint64_t v8 = 0;
    for (uint64_t i = 0; i != v7; ++i)
    {
      uint64_t v10 = MEMORY[0x237DBA1E0](a1->i64[0], i);
      uint64_t result = CoreIKFootPlacementConstraintIsRayTracing();
      if (result)
      {
        float v21 = a1[3].f32[0] * 0.5;
        float32x4_t v22 = a1[2];
        uint64_t v11 = (re::internal *)re::RigDataValue::attributeValue(a2, v8);
        re::internal::getSRTFromRDV(v11, v23);
        float32x4_t v12 = a3[1];
        float32x4_t v13 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL);
        float32x4_t v14 = vnegq_f32(v12);
        float32x4_t v15 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v24, v24), (int8x16_t)v24, 0xCuLL), v14), (float32x4_t)v24, v13);
        int32x4_t v16 = (int32x4_t)vaddq_f32(v15, v15);
        float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL);
        int32x4_t v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v14), v17, v13);
        a1[1] = vsubq_f32(vaddq_f32(a3[2], vmulq_f32(*a3, vaddq_f32(vaddq_f32((float32x4_t)v24, vmulq_laneq_f32(v17, v12, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL)))), vmulq_n_f32(v22, v21));
        re::internal::RayCaster::cast((float32x4_t *)a1[4].i64, (uint64_t)&a1[1], (uint64_t)v23);
        if (LOBYTE(v23[0]))
        {
          CoreIKFootPlacementConstraintSetRayTraceParameters();
          v19.n128_u32[0] = 1.0;
          v20.n128_u32[0] = 1.0;
        }
        else
        {
          v19.n128_u64[0] = 0;
          v20.n128_u64[0] = 0;
        }
        uint64_t result = MEMORY[0x237DBA1A0](v10, v19, v20);
        ++v8;
      }
    }
  }
  return result;
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate(re::internal::CoreIKFootPlacementSolverNodeHelper *this, const re::RigDataValue *a2, re::RigDataValue *a3)
{
  CoreIKFootPlacementSolverGetGenericSolver();
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  int v6 = CoreIKGenericSolverSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKFootPlacementSolverGetGenericSolver();
    CoreIKGenericSolverGetConstraintCount();
    CoreIKFootPlacementSolverGetGenericSolver();
    CoreIKGenericSolverGetJointCount();
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::internal::updateOutputBasedOnSolveResult(v6, (uint64_t)a2, (re::internal::CoreIKFootPlacementSolverNodeHelper *)((char *)this + 184), a3);
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

uint64_t re::internal::footPlacementSolverCallback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, float32x4_t *a9)
{
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  unint64_t v9 = a4;
  if (a4 == 1)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  if (a4 <= 2)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, v9);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 576), &v37);
  if (v9 == 3)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 864), &v34);
  if (v9 <= 4)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (v9 == 5)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a8)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  _Q2 = (int32x4_t)v38;
  float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL);
  float32x4_t v17 = vnegq_f32(v38);
  int32x4_t v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v35, v35), (int8x16_t)v35, 0xCuLL), v17), (float32x4_t)v35, v16);
  _S7 = v35.i32[3];
  float32x4_t v20 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL), (float32x4_t)v35, v38, 3), v38, (float32x4_t)v35, 3);
  __asm { FMLA            S3, S7, V2.S[3] }
  float32x4_t v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v36, v36), (int8x16_t)v36, 0xCuLL), v17), (float32x4_t)v36, v16);
  int32x4_t v27 = (int32x4_t)vaddq_f32(v26, v26);
  float32x4_t v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
  int32x4_t v29 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v17), v28, v16);
  v20.i32[3] = _S3;
  v33[0] = vmulq_f32(v37, v34);
  v33[1] = v20;
  void v33[2] = vaddq_f32(v39, vmulq_f32(v37, vaddq_f32(vaddq_f32((float32x4_t)v36, vmulq_laneq_f32(v28, v38, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL))));
  __asm { FMOV            V5.4S, #-1.0 }
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverSetWorldToSolverTransform();
  re::RigDataValue::getRuntimeValue<float>(a3 + 1440, v31);
  CoreIKFootPlacementSolverSetBodyControllerParameters();
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(a9, (re::RigDataValue *)(a3 + 288), v33);
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9->i64[0], (const re::RigDataValue *)(a3 + 1152));
  re::internal::transferPose((re::RigDataValue *)a3, (uint64_t)&a9[11].i64[1]);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9, (const re::RigDataValue *)a3, a7);
}

uint64_t re::internal::footPlacementSolverCompile(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  v34[37] = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (a3 == 1)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (a3 <= 2)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (a3 == 3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v10 = a2[1];
  uint64_t v11 = *(_anonymous_namespace_ **)(*a2 + 184);
  float32x4_t v12 = (const re::RigDataValue *)a2[2];
  uint64_t v13 = (const re::RigDataValue *)a2[3];
  v33[0] = (const char *)0x51C691EF1C9C00D8;
  v33[1] = "IKLookAtTaskSettings[0]";
  re::internal::makeRigDataValue((re::Allocator **)a1, v33, (uint64_t)v34);
  re::StringID::destroyString((re::StringID *)v33);
  if (a3 == 5) {
    re::RigDataValue::operator=(v34, a2[4]);
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  uint64_t v15 = *a4;
  size_t v16 = strlen(*(const char **)(v10 + 232));
  uint64_t v17 = MEMORY[0x237DBA0C0](*(void *)(v10 + 232), v16);
  re::internal::makePoseFromRig((re::Allocator **)a1, v11, v17, (uint64_t)v33);
  uint64_t v18 = MEMORY[0x237DBA570](v17);
  re::internal::makePose((re::Allocator **)a1, v18, (uint64_t)v32);
  __n128 v19 = *(re::Allocator **)a1;
  re::internal::makeNodeUnique<re::internal::CoreIKFootPlacementSolverNodeHelper,re::Allocator,CoreIKRig *,std::reference_wrapper<re::CollisionWorld const>>(v31, *(void *)a1, v17, *(void *)(*(void *)(a1 + 16) + 56));
  re::internal::makeModelSpacePoseForRayTracingJoints((re::Allocator **)a1, v11, *(void *)v31[0], (uint64_t)v30);
  unint64_t v20 = re::RigHierarchy::jointName(v11, 0);
  re::internal::makeModelSpaceJointPoseRDV((re::Allocator **)a1, v11, *(const char **)(v20 + 8), (re::RigDataValue *)v29);
  uint64_t v28 = 0;
  memset(v24, 0, sizeof(v24));
  int v25 = 0;
  memset(v26, 0, sizeof(v26));
  int v27 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v24, v19);
  *(void *)&v23.var0 = 0x76F1BA5D1EB6;
  v23.var1 = "InputPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, (const re::RigDataValue *)v33);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0x10988E7944E83FE6;
  v23.var1 = "ModelSpaceRayCastTransforms";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, (const re::RigDataValue *)v30);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0x1F85042B1B4E4034;
  v23.var1 = "WorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, v13);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0xF5F802EF32C90F2;
  v23.var1 = "SolverTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, (const re::RigDataValue *)v29);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0x1D028121B777EB8;
  v23.var1 = "LookAtTasks";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, (const re::RigDataValue *)v34);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0x4DF90C13235A0886;
  v23.var1 = "HipOffsetMultiplier";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v24, &v23, v12);
  re::StringID::destroyString((re::StringID *)&v23);
  *(void *)&v23.var0 = 0x10498EC9357CACLL;
  v23.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v24, &v23, (re::RigDataValue *)v32);
  re::StringID::destroyString((re::StringID *)&v23);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v24, a1, (uint64_t)re::internal::footPlacementSolverCallback, v31);
  double v21 = re::internal::bindCallbackOutputToNodeOutputPose(v11, (re::RigDataValue *)v32, v17, a1, v15);
  MEMORY[0x237DBA110](v17, v21);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v26 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v24 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v29);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v30);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100](v31);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v32);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v33);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v34);
  return 1;
}

void *re::internal::makeNodeUnique<re::internal::CoreIKFootPlacementSolverNodeHelper,re::Allocator,CoreIKRig *,std::reference_wrapper<re::CollisionWorld const>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v13[4] = *MEMORY[0x263EF8340];
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 224, 16);
  *(void *)uint64_t v8 = CoreIKFootPlacementSolverCreate();
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_DWORD *)(v8 + 48) = 0;
  *(void *)(v8 + 64) = a4;
  *(void *)(v8 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  *(void *)(v8 + 88) = 0;
  *(void *)(v8 + 84) = 0xFFFFFFFF00000001;
  *(_OWORD *)(v8 + 124) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 1re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v8 + 108) = 0u;
  *(_OWORD *)(v8 + 92) = 0u;
  *(_DWORD *)(v8 + 128) = 1;
  *(void *)(v8 + 144) = 0;
  *(void *)(v8 + 152) = 0;
  *(void *)(v8 + 136) = 0;
  *(_DWORD *)(v8 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
  *(void *)(v8 + 176) = a2;
  *(void *)(v8 + 192) = 0;
  *(void *)(v8 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = 0;
  *(void *)(v8 + 184) = 0;
  *(unsigned char *)(v8 + 208) = 1;
  unint64_t v9 = MEMORY[0x237DBA570](a3);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v8 + 184), a2, v9);
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverGetTargetRestPose();
  float32x4_t v11 = vmulq_f32(v10, v10);
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = xmmword_23435FD90;
  *(float *)(v8 + 48) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0])* 4.0;
  v13[0] = &unk_26E6C2958;
  v13[1] = a2;
  v13[3] = v13;
  a1[4] = (uint64_t)(a1 + 1);
  *a1 = v8;
  a1[1] = (uint64_t)&unk_26E6C2958;
  a1[2] = a2;
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v13);
}

uint64_t re::internal::footPlacementDebugSolverCallback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, float32x4_t *a9)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (a4 <= 3)
  {
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, a4);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 864), &v44);
  if (a4 == 4)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 1152), &v41);
  _Q2 = (int32x4_t)v45;
  float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL);
  float32x4_t v17 = vnegq_f32(v45);
  int32x4_t v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v42, v42), (int8x16_t)v42, 0xCuLL), v17), (float32x4_t)v42, v16);
  _S7 = v42.i32[3];
  float32x4_t v20 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL), (float32x4_t)v42, v45, 3), v45, (float32x4_t)v42, 3);
  __asm { FMLA            S3, S7, V2.S[3] }
  float32x4_t v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v43, v43), (int8x16_t)v43, 0xCuLL), v17), (float32x4_t)v43, v16);
  int32x4_t v27 = (int32x4_t)vaddq_f32(v26, v26);
  float32x4_t v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
  int32x4_t v29 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v17), v28, v16);
  v20.i32[3] = _S3;
  v40[0] = vmulq_f32(v44, v41);
  v40[1] = v20;
  v40[2] = vaddq_f32(v46, vmulq_f32(v44, vaddq_f32(vaddq_f32((float32x4_t)v43, vmulq_laneq_f32(v28, v45, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL))));
  __asm { FMOV            V5.4S, #-1.0 }
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverSetWorldToSolverTransform();
  re::RigDataValue::getRuntimeValue<float>(a3 + 576, v31);
  CoreIKFootPlacementSolverSetBodyControllerParameters();
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(a9, (re::RigDataValue *)(a3 + 288), v40);
  if (a4 <= 5)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v32, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9->i64[0], (const re::RigDataValue *)(a3 + 1440));
  uint64_t GenericSolver = CoreIKFootPlacementSolverGetGenericSolver();
  if (a4 == 6)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v34, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 6, 6);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  uint64_t v35 = GenericSolver;
  re::internal::GameRigSettingsUpdateHelper::updateRigJointSettings((re::RigDataValue *)(a3 + 1728));
  if (a4 <= 7)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v36, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 7, 7);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  re::internal::GameRigSettingsUpdateHelper::updateRigTaskSettings((re::RigDataValue *)(a3 + 2016), v35);
  if (a4 == 8)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 8, 8);
    _os_crash();
    __break(1u);
LABEL_21:
    re::internal::assertLog((re::internal *)6, v38, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  re::internal::GameRigSettingsUpdateHelper::updateRigSolverSettings((re::RigDataValue *)(a3 + 2304), v35);
  re::internal::transferPose((re::RigDataValue *)a3, (uint64_t)&a9[11].i64[1]);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (!a8) {
    goto LABEL_21;
  }
  return re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9, (const re::RigDataValue *)a3, a7);
}

uint64_t re::internal::footPlacementSolverDebugCompile(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a3 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  float32x4_t v10 = *(_anonymous_namespace_ **)(*(void *)a2 + 184);
  float32x4_t v11 = *(const char **)(*(void *)(a2 + 8) + 232);
  size_t v12 = strlen(v11);
  uint64_t v13 = MEMORY[0x237DBA0C0](v11, v12);
  re::internal::makePoseFromRig((re::Allocator **)a1, v10, v13, (uint64_t)v36);
  uint64_t v14 = MEMORY[0x237DBA570](v13);
  re::internal::makePose((re::Allocator **)a1, v14, (uint64_t)v35);
  uint64_t v15 = *(re::Allocator **)a1;
  re::internal::makeNodeUnique<re::internal::CoreIKFootPlacementSolverNodeHelper,re::Allocator,CoreIKRig *,std::reference_wrapper<re::CollisionWorld const>>(v34, *(void *)a1, v13, *(void *)(*(void *)(a1 + 16) + 56));
  re::internal::makeModelSpacePoseForRayTracingJoints((re::Allocator **)a1, v10, *(void *)v34[0], (uint64_t)v33);
  unint64_t v16 = re::RigHierarchy::jointName(v10, 0);
  re::internal::makeModelSpaceJointPoseRDV((re::Allocator **)a1, v10, *(const char **)(v16 + 8), (re::RigDataValue *)v32);
  uint64_t v31 = 0;
  memset(v27, 0, sizeof(v27));
  int v28 = 0;
  memset(v29, 0, sizeof(v29));
  int v30 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v27, v15);
  *(void *)&v26.var0 = 0x76F1BA5D1EB6;
  v26.var1 = "InputPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, (const re::RigDataValue *)v36);
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x10988E7944E83FE6;
  v26.var1 = "ModelSpaceRayCastTransforms";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, (const re::RigDataValue *)v33);
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x4DF90C13235A0886;
  v26.var1 = "HipOffsetMultiplier";
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 16));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x1F85042B1B4E4034;
  v26.var1 = "WorldTransform";
  if (a3 == 3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 24));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0xF5F802EF32C90F2;
  v26.var1 = "SolverTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, (const re::RigDataValue *)v32);
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x80FA33623D02F274;
  v26.var1 = "LookAtTaskSettings";
  if (a3 <= 4)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 32));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x608B8AAFAB2B677ALL;
  v26.var1 = "RigJointSettings";
  if (a3 == 5)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 40));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x963E12F0C5BD5BB0;
  v26.var1 = "RigTaskSettings";
  if (a3 <= 6)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v21, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 6, 6, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 48));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x86B1473B92D2CCCCLL;
  v26.var1 = "RigSolverSettings";
  if (a3 == 7)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 7, 7, *(void *)&v26.var0, v26.var1);
    _os_crash();
    __break(1u);
LABEL_21:
    re::internal::assertLog((re::internal *)6, v23, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v27, &v26, *(const re::RigDataValue **)(a2 + 56));
  re::StringID::destroyString((re::StringID *)&v26);
  *(void *)&v26.var0 = 0x10498EC9357CACLL;
  v26.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v27, &v26, (re::RigDataValue *)v35);
  re::StringID::destroyString((re::StringID *)&v26);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v27, a1, (uint64_t)re::internal::footPlacementDebugSolverCallback, v34);
  if (!a5) {
    goto LABEL_21;
  }
  double v24 = re::internal::bindCallbackOutputToNodeOutputPose(v10, (re::RigDataValue *)v35, v13, a1, *a4);
  if (v13) {
    MEMORY[0x237DBA110](v13, v24);
  }
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v29 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v27 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v32);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v33);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100](v34);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v35);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v36);
  return 1;
}

void re::internal::registerFootPlacementSolverNoLookAtNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE16B8;
  _OWORD v7[3] = *(_OWORD *)&off_264BE16C8;
  _OWORD v7[4] = xmmword_264BE16D8;
  v7[0] = xmmword_264BE1698;
  v7[1] = *(_OWORD *)&off_264BE16A8;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerFootPlacementSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  uint64_t v7[2] = xmmword_264BE1708;
  _OWORD v7[3] = *(_OWORD *)&off_264BE1718;
  _OWORD v7[4] = xmmword_264BE1728;
  _OWORD v7[5] = *(_OWORD *)&off_264BE1738;
  v7[0] = xmmword_264BE16E8;
  v7[1] = *(_OWORD *)&off_264BE16F8;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 5uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerFootPlacementSolverDebugNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  _OWORD v7[6] = xmmword_264BE17A8;
  v7[7] = *(_OWORD *)&off_264BE17B8;
  v7[8] = xmmword_264BE17C8;
  uint64_t v7[2] = xmmword_264BE1768;
  _OWORD v7[3] = *(_OWORD *)&off_264BE1778;
  _OWORD v7[4] = xmmword_264BE1788;
  _OWORD v7[5] = *(_OWORD *)&off_264BE1798;
  v7[0] = xmmword_264BE1748;
  v7[1] = *(_OWORD *)&off_264BE1758;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 8uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverDebugCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6C2958;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C2958;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EEclEOSI_(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    CoreIKFootPlacementSolverDestroy();
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v2 + 184));
    re::BucketArray<re::CollisionCastHit,10ul>::deinit(v2 + 112);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v2 + 112);
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_35CoreIKFootPlacementSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperIKNS_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_35CoreIKFootPlacementSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperIKNS_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_;
}

uint64_t re::internal::feetSlidingSolverCallback(uint64_t a1, uint64_t a2, re::RigDataValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, uint64_t a9)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  re::internal::transferPose(a3, a9 + 16);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (!a8) {
    goto LABEL_19;
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  int v15 = MEMORY[0x237DBA030](*(void *)a9, *(void *)(a9 + 32), *(void *)(a9 + 24));
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::internal::updateOutputBasedOnSolveResult(v15, (uint64_t)a3, (_OWORD *)(a9 + 16), a7);
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

uint64_t re::internal::feetSlidingSolverCompile(re::Allocator **a1, void *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  v27[4] = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  if (a3 == 1)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5) {
    goto LABEL_7;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = *a4;
  uint64_t v8 = *(const char **)(*a2 + 232);
  size_t v9 = strlen(v8);
  uint64_t v10 = MEMORY[0x237DBA0C0](v8, v9);
  uint64_t v11 = (uint64_t)*a1;
  size_t v12 = (uint64_t *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)*a1 + 32))(*a1, 40, 8);
  *size_t v12 = CoreIKCreateACPSlidingSolverFromRig();
  v12[1] = v11;
  v12[3] = 0;
  v12[4] = 0;
  uint64_t v12[2] = 0;
  unint64_t v13 = MEMORY[0x237DBA570](v10);
  re::FixedArray<CoreIKTransform>::init<>(v12 + 2, v11, v13);
  v25[0] = &unk_26E6C29D8;
  v25[1] = v11;
  void v25[3] = v25;
  v27[3] = v27;
  StringID v26 = v12;
  v27[0] = &unk_26E6C29D8;
  v27[1] = v11;
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v25);
  uint64_t v14 = *(_anonymous_namespace_ **)(v6 + 184);
  re::internal::makePoseFromRig(a1, v14, v10, (uint64_t)v25);
  uint64_t v15 = MEMORY[0x237DBA570](v10);
  re::internal::makePose(a1, v15, (uint64_t)v24);
  uint64_t v23 = 0;
  memset(v19, 0, sizeof(v19));
  int v20 = 0;
  memset(v21, 0, sizeof(v21));
  int v22 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v19, *a1);
  *(void *)&v18.var0 = 0x10643527A253C4;
  v18.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v19, &v18, (const re::RigDataValue *)v25);
  re::StringID::destroyString((re::StringID *)&v18);
  *(void *)&v18.var0 = 0x10498EC9357CACLL;
  v18.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v19, &v18, (re::RigDataValue *)v24);
  re::StringID::destroyString((re::StringID *)&v18);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v19, (uint64_t)a1, (uint64_t)re::internal::feetSlidingSolverCallback, (uint64_t *)&v26);
  double v16 = re::internal::bindCallbackOutputToNodeOutputPose(v14, (re::RigDataValue *)v24, v10, (uint64_t)a1, v7);
  MEMORY[0x237DBA110](v10, v16);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v21 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v19 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v24);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v25);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v26);
  return 1;
}

void re::internal::registerFeetSlidingSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[0] = xmmword_264BE17D8;
  v7[1] = *(_OWORD *)&off_264BE17E8;
  uint64_t v7[2] = xmmword_264BE17F8;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 2uLL, 1uLL, (unint64_t)re::internal::feetSlidingSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6C29D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C29D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    CoreIKDestroyACPSlidingSolver();
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v2 + 16));
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_32CoreIKACPSlidingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_32CoreIKACPSlidingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_;
}

uint64_t re::AnimationController::indexOf(uint64_t this, const re::Timeline *a2, uint64_t a3)
{
  uint64_t v3 = this;
  if (*(void *)a2
    && (this = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)a2 + (*((uint64_t *)a2 + 1) >> 56 << 6) + 72, *((void *)a2 + 1))) != 0)
  {
    if (a3)
    {
      uint64_t v6 = *(void *)(this + 128);
      uint64_t v5 = *(void *)(this + 136);
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        uint64_t v8 = *(void **)(this + 136);
        while (*v8 != a3)
        {
          ++v8;
          v7 -= 8;
          if (!v7)
          {
            uint64_t v8 = (void *)(v5 + 8 * v6);
            break;
          }
        }
      }
      else
      {
        uint64_t v8 = *(void **)(this + 136);
      }
      uint64_t v9 = ((uint64_t)v8 - v5) >> 3;
      if (v9 == v6)
      {
        char v10 = 0;
      }
      else
      {
        *(void *)(v3 + 8) = v9;
        char v10 = 1;
      }
      *(unsigned char *)uint64_t v3 = v10;
    }
    else
    {
      *(unsigned char *)uint64_t v3 = 1;
      *(void *)(v3 + 8) = 0;
    }
  }
  else
  {
    *(unsigned char *)uint64_t v3 = 0;
  }
  return this;
}

void re::AnimationController::pause(re::AnimationController *this)
{
  if (*(void *)this)
  {
    uint64_t v1 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    if (v1)
    {
      re::internal::TimelineTree::setPaused(v1, 1);
    }
  }
}

void re::AnimationController::resume(re::AnimationController *this)
{
  if (*(void *)this)
  {
    uint64_t v1 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    if (v1)
    {
      re::internal::TimelineTree::setPaused(v1, 0);
    }
  }
}

double re::AnimationController::stop(re::AnimationController *this, double result)
{
  if (*(void *)this)
  {
    float v2 = *(float *)&result;
    uint64_t v4 = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    if (v4)
    {
      uint64_t v5 = (re::internal::TimelineTree *)v4;
      uint64_t v6 = *(re::AnimationManager **)this;
      if (v2 <= 0.0)
      {
        return re::AnimationManager::remove(v6, v5, 1);
      }
      else
      {
        int v7 = 3;
        char v8 = 0;
        char v9 = 1;
        int v10 = 0;
        float v11 = v2;
        re::AnimationManager::addFadeOutHandoffBehavior(v6, (uint64_t)v5, (uint64_t)&v7);
      }
    }
  }
  return result;
}

void re::AnimationController::updateAndApply(re::AnimationController *this)
{
  if (*(void *)this)
  {
    uint64_t v2 = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    if (v2)
    {
      uint64_t v3 = (re::internal::TimelineTree *)v2;
      uint64_t v4 = *(re::AnimationManager **)this;
      re::AnimationManager::updateAndApplyAnimations(v4, v3);
    }
  }
}

uint64_t re::AnimationController::isPaused(re::AnimationController *this)
{
  if (!*(void *)this) {
    return 0;
  }
  uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
  if (result)
  {
    do
    {
      uint64_t v2 = result;
      uint64_t result = *(void *)(result + 200);
    }
    while (result);
    return *(unsigned __int8 *)(v2 + 185) == 1;
  }
  return result;
}

void *re::AnimationController::setParentClockOrTimebase(void *this, void *a2)
{
  if (*this)
  {
    uint64_t v3 = this;
    this = (void *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1]);
    if (this)
    {
      if (a2) {
        uint64_t v4 = a2;
      }
      else {
        uint64_t v4 = *(void **)(*v3 + 64);
      }
      return (void *)re::internal::TimelineTree::setParentClockOrTimebase((uint64_t)this, v4);
    }
  }
  return this;
}

uint64_t re::internal::TimelineTree::setParentClockOrTimebase(uint64_t this, void *cf)
{
  if (!*(void *)(this + 200))
  {
    uint64_t v3 = this;
    CFTypeID v4 = CFGetTypeID(cf);
    CFTypeID TypeID = CMClockGetTypeID();
    uint64_t v6 = *(OpaqueCMTimebase **)(v3 + 192);
    if (v4 == TypeID)
    {
      return CMTimebaseSetSourceClock(v6, (CMClockRef)cf);
    }
    else
    {
      return CMTimebaseSetSourceTimebase(v6, (CMTimebaseRef)cf);
    }
  }
  return this;
}

void *re::AnimationController::timebase@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  if (*this
    && (this = (void *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1])) != 0)
  {
    do
    {
      uint64_t v3 = this;
      this = (void *)this[25];
    }
    while (this);
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 8) = v3[24];
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  return this;
}

float re::AnimationController::speed(re::AnimationController *this)
{
  if (!*(void *)this) {
    return NAN;
  }
  uint64_t v1 = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
  if (!v1) {
    return NAN;
  }
  do
  {
    uint64_t v2 = v1;
    uint64_t v1 = *(void *)(v1 + 200);
  }
  while (v1);
  return *(float *)(v2 + 188);
}

uint64_t re::AnimationController::setSpeed(uint64_t this, float a2)
{
  if (*(void *)this)
  {
    this = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*(uint64_t *)(this + 8) >> 56 << 6) + 72, *(void *)(this + 8));
    if (this)
    {
      if (!*(void *)(this + 200))
      {
        *(float *)(this + 188) = a2;
        if (!*(unsigned char *)(this + 185))
        {
          uint64_t v3 = *(OpaqueCMTimebase **)(this + 192);
          return CMTimebaseSetRate(v3, a2);
        }
      }
    }
  }
  return this;
}

uint64_t re::AnimationController::timeline(re::AnimationController *this)
{
  if (!*(void *)this) {
    return 0;
  }
  uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
  if (result)
  {
    if (!*(void *)(result + 128))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return **(void **)(result + 136);
  }
  return result;
}

uint64_t re::AnimationController::clock@<X0>(re::AnimationController *this@<X0>, const re::Timeline *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t result = re::AnimationController::indexOf((uint64_t)v13, this, (uint64_t)a2);
  if (v13[0])
  {
    if (*(void *)this) {
      uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    }
    else {
      uint64_t result = 0;
    }
    unint64_t v7 = v14;
    unint64_t v8 = *(void *)(result + 56);
    if (v8 <= v14)
    {
      uint64_t v15 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v24 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v16 = 136315906;
      uint64_t v17 = "operator[]";
      __int16 v18 = 1024;
      int v19 = 468;
      __int16 v20 = 2048;
      unint64_t v21 = v7;
      __int16 v22 = 2048;
      unint64_t v23 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v9 = *(void *)(result + 64);
    uint64_t v10 = v9 + 72 * v14;
    *(_OWORD *)a3 = *(_OWORD *)v10;
    LODWORD(v10) = *(unsigned __int8 *)(v10 + 16);
    *(unsigned char *)(a3 + 16) = v10;
    if (v10) {
      *(void *)(a3 + 24) = *(void *)(v9 + 72 * v7 + 24);
    }
    uint64_t v11 = v9 + 72 * v7;
    long long v12 = *(_OWORD *)(v11 + 48);
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(v11 + 32);
    *(_OWORD *)(a3 + 48) = v12;
    int v6 = *(_DWORD *)(v11 + 64);
  }
  else
  {
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(void *)(a3 + 64) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(unsigned char *)a3 = 1;
    *(_DWORD *)(a3 + 60) = 0;
    *(void *)(a3 + 36) = 0;
    *(void *)(a3 + 44) = 0;
    *(void *)(a3 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 0;
    int v6 = 2;
  }
  *(_DWORD *)(a3 + 64) = v6;
  return result;
}

void re::AnimationController::time(re::AnimationController *this@<X0>, uint64_t a2@<X8>)
{
  if (*(void *)this
    && (uint64_t v3 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1))) != 0)
  {
    Float64 v4 = re::internal::TimelineTree::currentTime(v3);
    *(unsigned char *)a2 = 1;
    *(Float64 *)(a2 + 8) = v4;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

void *re::AnimationController::setTime(void *this, double a2)
{
  if (*this)
  {
    this = (void *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1]);
    if (this)
    {
      return (void *)re::internal::TimelineTree::setCurrentTime((uint64_t)this, a2);
    }
  }
  return this;
}

uint64_t re::internal::TimelineTree::setCurrentTime(uint64_t this, double a2)
{
  if (!*(void *)(this + 200))
  {
    uint64_t v2 = *(OpaqueCMTimebase **)(this + 192);
    CMTimeMake(&time, (unint64_t)(a2 * 18000.0 + 0.5), 18000);
    return CMTimebaseSetTime(v2, &time);
  }
  return this;
}

float re::AnimationController::blendFactor(re::AnimationController *this, const re::Timeline *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  re::AnimationController::indexOf((uint64_t)v11, this, (uint64_t)a2);
  if (!v11[0]) {
    return NAN;
  }
  if (*(void *)this) {
    uint64_t v3 = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v5 = v12;
  unint64_t v6 = *(void *)(v3 + 80);
  if (v6 <= v12)
  {
    uint64_t v13 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    uint64_t v15 = "operator[]";
    __int16 v16 = 1024;
    int v17 = 468;
    __int16 v18 = 2048;
    unint64_t v19 = v5;
    __int16 v20 = 2048;
    unint64_t v21 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v7 = (unsigned __int8 *)(*(void *)(v3 + 88) + 12 * v12);
  unint64_t v8 = v7 + 8;
  int v10 = *v7;
  uint64_t v9 = v7 + 4;
  if (v10) {
    uint64_t v9 = v8;
  }
  return *(float *)v9;
}

uint64_t re::AnimationController::setBlendFactor(re::AnimationController *this, float a2, const re::Timeline *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t result = re::AnimationController::indexOf((uint64_t)v8, this, (uint64_t)a3);
  if (v8[0])
  {
    if (*(void *)this) {
      uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
    }
    else {
      uint64_t result = 0;
    }
    unint64_t v6 = v9;
    unint64_t v7 = *(void *)(result + 80);
    if (v7 <= v9)
    {
      uint64_t v10 = 0;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v19 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v11 = 136315906;
      unint64_t v12 = "operator[]";
      __int16 v13 = 1024;
      int v14 = 468;
      __int16 v15 = 2048;
      unint64_t v16 = v6;
      __int16 v17 = 2048;
      unint64_t v18 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(float *)(*(void *)(result + 88) + 12 * v9 + 4) = a2;
  }
  return result;
}

uint64_t re::AnimationController::userData(re::AnimationController *this)
{
  if (!*(void *)this) {
    return 0;
  }
  uint64_t result = re::DataArray<re::internal::TimelineTree>::tryGet(*(void *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((void *)this + 1));
  if (result) {
    return *(void *)(result + 168);
  }
  return result;
}

unsigned char *re::RigDataTypeClass::rigDataTypeParser@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v140 = *MEMORY[0x263EF8340];
  unint64_t v6 = re::RigDataParser::parseAlphaNumeric((uint64_t *)a2);
  size_t v8 = v7;
  if (strncmp(v6, "struct", v7)) {
    goto LABEL_3;
  }
  if (aStruct_0[v8]) {
    goto LABEL_3;
  }
  uint64_t v24 = (char *)(*(void *)a2 + *(void *)(a2 + 8) - (void)&v6[v8]);
  *(void *)&v135.var0 = &v6[v8];
  v135.var1 = v24;
  long long v25 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v135);
  if (!v26) {
    goto LABEL_3;
  }
  uint64_t v27 = v25;
  long long v28 = v26;
  unint64_t v29 = *(void *)a2 + *(void *)(a2 + 8);
  *(void *)&v135.var0 = &v26[(void)v25];
  v135.var1 = (char *)(v29 - (unint64_t)&v26[(void)v25]);
  int v30 = re::RigDataParser::parseWhitespace((uint64_t *)&v135);
  uint64_t v32 = &v30[v31];
  size_t v33 = (unint64_t)&v30[v31] < v29;
  if (strncmp(&v30[v31], "{", v33)) {
    goto LABEL_3;
  }
  if (!asc_23445148B[v33])
  {
    uint64_t v34 = &v32[v33];
    *(void *)&v118.var0 = v27;
    v118.var1 = v28;
    *(void *)&v119.var0 = 0;
    v119.var1 = 0;
    LODWORD(vre::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 1;
    long long v122 = 0;
    uint64_t v123 = 0;
    uint64_t v121 = 0;
    int v124 = 0;
    uint64_t v35 = *(void *)a2;
    uint64_t v36 = *(void *)(a2 + 8);
    unint64_t v37 = *(void *)a2 + v36;
    if ((unint64_t)v34 >= v37)
    {
      char v112 = 1;
      uint64_t v64 = 0;
      __int16 v117 = 0;
      unint64_t v38 = 0;
    }
    else
    {
      unint64_t v111 = 0;
      __int16 v117 = 0;
      unint64_t v38 = 0;
      char v112 = 1;
      while (1)
      {
        *(void *)&v135.var0 = v34;
        v135.var1 = (char *)(v37 - (void)v34);
        float32x4_t v39 = re::RigDataParser::parseWhitespace((uint64_t *)&v135);
        float32x4_t v41 = &v39[v40];
        size_t v42 = (unint64_t)&v39[v40] < v37;
        if (!strncmp(&v39[v40], "}", v42) && !asc_2344515DA[v42]) {
          break;
        }
        int32x4_t v43 = (char *)(*(void *)a2 + *(void *)(a2 + 8) - (void)v34);
        *(void *)&v135.var0 = v34;
        v135.var1 = v43;
        float32x4_t v44 = re::RigDataParser::parseTypeName((uint64_t *)&v135);
        if (!v45) {
          goto LABEL_54;
        }
        float32x4_t v46 = v44;
        uint64_t v47 = v45;
        int v48 = (char *)(*(void *)a2 + *(void *)(a2 + 8) - ((unint64_t)v45 + (void)v44));
        *(void *)&v135.var0 = (char *)v45 + (void)v44;
        v135.var1 = v48;
        int v49 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v135);
        if (!v50) {
          goto LABEL_54;
        }
        int v51 = v49;
        size_t v52 = v50;
        __int16 v113 = v46;
        uint64_t v115 = v47;
        long long v53 = &v49[v50];
        unint64_t v54 = *(void *)a2 + *(void *)(a2 + 8);
        *(void *)&v135.var0 = &v49[v50];
        v135.var1 = (char *)(v54 - (void)&v49[v50]);
        long long v55 = re::RigDataParser::parseWhitespace((uint64_t *)&v135);
        long long v57 = &v55[v56];
        size_t v58 = (unint64_t)v57 < v54;
        int v116 = v57;
        if (strncmp(v57, ";", v58) || asc_2344557A3[v58]) {
          goto LABEL_54;
        }
        if (v38)
        {
          unint64_t v59 = 0;
          while (1)
          {
            uint64_t v60 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[]((uint64_t)&v119, v59);
            if (*(void *)(v60 + 8) == v52 && !memcmp(*(const void **)v60, v51, v52)) {
              break;
            }
            if (v38 == ++v59) {
              goto LABEL_29;
            }
          }
        }
        else
        {
LABEL_29:
          int v61 = (char *)memchr(v51, 46, v52);
          if (v61) {
            uint64_t v62 = v61;
          }
          else {
            uint64_t v62 = v53;
          }
          if (v62 - v51 == v52)
          {
            var1 = v117;
            if (v38 + 1 > 8 * (uint64_t)v117)
            {
              re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(&v119, (v38 + 8) >> 3);
              var1 = v119.var1;
            }
            uint64_t v64 = v38 >> 3;
            __int16 v117 = var1;
            if ((unint64_t)var1 <= v38 >> 3) {
              goto LABEL_89;
            }
            char v112 = v120;
            uint64_t v65 = (StringID *)&v121;
            unint64_t v111 = v122;
            if ((v120 & 1) == 0) {
              uint64_t v65 = v122;
            }
            uint64_t v66 = *((void *)&v65->var0 + v64);
            unint64_t v67 = v38 & 7;
            unint64_t v38 = ++v123;
            ++v124;
            uint64_t v68 = (char **)(v66 + 32 * v67);
            *uint64_t v68 = v51;
            v68[1] = (char *)v52;
            v68[2] = v113;
            v68[3] = (char *)v115;
          }
        }
        uint64_t v34 = (char *)&v116[v58];
        uint64_t v35 = *(void *)a2;
        uint64_t v36 = *(void *)(a2 + 8);
        unint64_t v37 = *(void *)a2 + v36;
        if ((unint64_t)&v116[v58] >= v37) {
          goto LABEL_87;
        }
      }
      uint64_t v34 = &v41[v42];
      uint64_t v35 = *(void *)a2;
      uint64_t v36 = *(void *)(a2 + 8);
LABEL_87:
      uint64_t v64 = (uint64_t)v111;
    }
    long long v88 = (char *)(v35 + v36);
    *(void *)&v135.var0 = v34;
    v135.var1 = (char *)(v35 + v36 - (void)v34);
    long long v89 = re::RigDataParser::parseWhitespace((uint64_t *)&v135);
    if (&v89[v90] == v88)
    {
      *(void *)&v135.var0 = 0;
      v135.var1 = "";
      v126[0] = 13;
      re::StringID::StringID((re::StringID *)&v126[8], &v135);
      uint64_t v129 = 0;
      *(void *)&v126[32] = 0;
      uint64_t v127 = 0;
      *(void *)&v126[24] = 0;
      int v128 = 0;
      re::StringID::destroyString((re::StringID *)&v135);
      long long v102 = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(&v126[24], v38);
      ++v128;
      if (v38)
      {
        unint64_t v103 = 0;
        int v104 = &v121;
        if ((v112 & 1) == 0) {
          int v104 = (uint64_t *)v64;
        }
        unint64_t v114 = v104;
        while ((unint64_t)v117 > v103 >> 3)
        {
          uint64_t v64 = v114[v103 >> 3] + 32 * (v103 & 7);
          __int16 v106 = *(const char **)v64;
          size_t v105 = *(void *)(v64 + 8);
          *(void *)&v135.var0 = 0;
          v135.var1 = "";
          int v107 = *(const char **)(v64 + 16);
          size_t v108 = *(void *)(v64 + 24);
          *(void *)&unsigned long long v136 = 0;
          *((void *)&v136 + 1) = "";
          re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add((_anonymous_namespace_ *)&v126[24], (uint64_t *)&v135);
          re::StringID::destroyString((re::StringID *)&v136);
          re::StringID::destroyString((re::StringID *)&v135);
          if (v38 == ++v103) {
            goto LABEL_74;
          }
        }
        uint64_t v125 = 0;
        long long v138 = 0u;
        long long v139 = 0u;
        unsigned long long v136 = 0u;
        long long v137 = 0u;
        StringID v135 = (StringID)0;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v130 = 136315906;
        *(void *)&v130[4] = "operator[]";
        *(_WORD *)&v130[12] = 1024;
        *(_DWORD *)&v130[14] = 866;
        __int16 v131 = 2048;
        unint64_t v132 = v103 >> 3;
        __int16 v133 = 2048;
        unint64_t v134 = v117;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_89:
        *(void *)unint64_t v130 = 0;
        long long v138 = 0u;
        long long v139 = 0u;
        unsigned long long v136 = 0u;
        long long v137 = 0u;
        StringID v135 = (StringID)0;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v126 = 136315906;
        *(void *)&v126[4] = "operator[]";
        *(_WORD *)&v126[12] = 1024;
        *(_DWORD *)&v126[14] = 858;
        *(_WORD *)&v126[18] = 2048;
        *(void *)&v126[20] = v64;
        *(_WORD *)&v126[28] = 2048;
        *(void *)&v126[30] = v117;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
LABEL_74:
      *(unsigned char *)&v135.var0 = 1;
      LOBYTE(v135.var1) = v126[0];
      re::StringID::StringID((re::StringID *)&v136, (const StringID *)&v126[8]);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v137, (uint64_t *)&v126[24]);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v126[24]);
      re::StringID::destroyString((re::StringID *)&v126[8]);
    }
    else
    {
LABEL_54:
      *(unsigned char *)&v135.var0 = 0;
    }
    if (v38)
    {
      for (unint64_t i = 0; i != v38; ++i)
        re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[]((uint64_t)&v119, i);
    }
    if (v117)
    {
      do
        re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)&v119);
      while (v119.var1);
    }
    if (*(void *)&v119.var0 && (v120 & 1) == 0) {
      (*(void (**)(void))(**(void **)&v119.var0 + 40))();
    }
    if (v135.var0)
    {
      *(unsigned char *)&v118.var0 = v135.var1;
      re::StringID::StringID((re::StringID *)&v118.var1, (const StringID *)&v136);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v119.var1, (uint64_t *)&v137);
      *(unsigned char *)a3 = 1;
      *(unsigned char *)(a3 + 8) = v118.var0;
      re::StringID::StringID((re::StringID *)(a3 + 16), (const StringID *)&v118.var1);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray(a3 + 32, (uint64_t *)&v119.var1);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v119.var1);
      re::StringID::destroyString((re::StringID *)&v118.var1);
      return re::Optional<re::RigDataTypeClass>::~Optional(&v135);
    }
  }
  else
  {
LABEL_3:
    *(unsigned char *)&v135.var0 = 0;
  }
  unint64_t v9 = re::RigDataParser::parseAlphaNumeric((uint64_t *)a2);
  if (!v10) {
    goto LABEL_44;
  }
  int v11 = v9;
  size_t v12 = v10;
  __int16 v13 = &v9[v10];
  unint64_t v14 = *(void *)a2 + *(void *)(a2 + 8);
  *(void *)&v118.var0 = &v9[v10];
  v118.var1 = (char *)(v14 - (void)&v9[v10]);
  __int16 v15 = re::RigDataParser::parseWhitespace((uint64_t *)&v118);
  __int16 v17 = &v15[v16];
  size_t v18 = (unint64_t)&v15[v16] < v14;
  if (strncmp(&v15[v16], "[", v18) || asc_234451684[v18])
  {
    long long v19 = (char *)(*(void *)a2 + *(void *)(a2 + 8));
    *(void *)&v118.var0 = v13;
    v118.var1 = (char *)(v19 - v13);
    long long v20 = re::RigDataParser::parseWhitespace((uint64_t *)&v118);
    if (&v20[v21] == v19)
    {
      uint64_t v22 = 1;
      while (1)
      {
        long long v23 = *re::RigDataTypeDescriptions::rigDataTypeDescription(v22, v21);
        if (!strncmp(v11, v23, v12) && !v23[v12]) {
          break;
        }
        if (++v22 == 14) {
          goto LABEL_44;
        }
      }
      long long v86 = (_anonymous_namespace_ *)re::RigDataTypeDescriptions::rigDataTypeDescription(v22, v21);
      long long v87 = *(const char **)v86;
      *(void *)&v118.var0 = 0;
      v118.var1 = "";
      v126[0] = v22;
      goto LABEL_49;
    }
LABEL_44:
    *(unsigned char *)&v118.var0 = 0;
    goto LABEL_45;
  }
  long long v69 = (char *)(*(void *)a2 + *(void *)(a2 + 8) - (void)&v17[v18]);
  *(void *)&v118.var0 = &v17[v18];
  v118.var1 = v69;
  uint64_t v70 = re::RigDataParser::parseNumeric((uint64_t *)&v118);
  uint64_t v72 = v71;
  unint64_t v73 = *(void *)a2 + *(void *)(a2 + 8);
  *(void *)&v118.var0 = &v70[v71];
  v118.var1 = (char *)(v73 - (void)&v70[v71]);
  uint64_t v74 = re::RigDataParser::parseWhitespace((uint64_t *)&v118);
  int v76 = &v74[v75];
  size_t v77 = (unint64_t)&v74[v75] < v73;
  if (strncmp(&v74[v75], "]", v77)) {
    goto LABEL_44;
  }
  if (asc_234451686[v77]) {
    goto LABEL_44;
  }
  uint64_t v78 = &v76[v77];
  int v79 = (char *)(*(void *)a2 + *(void *)(a2 + 8));
  *(void *)&v118.var0 = v78;
  v118.var1 = (char *)(v79 - v78);
  int v80 = re::RigDataParser::parseWhitespace((uint64_t *)&v118);
  if (&v80[v81] != v79) {
    goto LABEL_44;
  }
  if (!v72)
  {
    *(void *)&v118.var0 = 0;
    v118.var1 = "";
    v126[0] = 12;
LABEL_49:
    re::StringID::StringID((re::StringID *)&v126[8], &v118);
    uint64_t v129 = 0;
    *(void *)&v126[32] = 0;
    uint64_t v127 = 0;
    *(void *)&v126[24] = 0;
    int v128 = 0;
    re::StringID::destroyString((re::StringID *)&v118);
    *(unsigned char *)&v118.var0 = 1;
    LOBYTE(v118.var1) = v126[0];
    re::StringID::StringID((re::StringID *)&v119, (const StringID *)&v126[8]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v120, (uint64_t *)&v126[24]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v126[24]);
    goto LABEL_50;
  }
  unint64_t v91 = 0;
  do
  {
    unint64_t v92 = v91;
    uint64_t v94 = *v70++;
    uint64_t v93 = v94;
    unint64_t v91 = v94 + 10 * v91 - 48;
    --v72;
  }
  while (v72);
  *(void *)&v118.var0 = 0;
  v118.var1 = "";
  v126[0] = 11;
  re::StringID::StringID((re::StringID *)&v126[8], &v118);
  uint64_t v129 = 0;
  *(void *)&v126[32] = 0;
  uint64_t v127 = 0;
  *(void *)&v126[24] = 0;
  int v128 = 0;
  re::StringID::destroyString((re::StringID *)&v118);
  long long v96 = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(&v126[24], v91);
  ++v128;
  v118.var1 = 0;
  *(void *)&v119.var0 = 0;
  v119.var1 = 0;
  re::DynamicString::setCapacity(&v118, 0);
  if (v91)
  {
    uint64_t v97 = 0;
    uint64_t v98 = v93 + 10 * v92 - 48;
    do
    {
      long long v99 = (_anonymous_namespace_ *)re::DynamicString::assignf((re::DynamicString *)&v118, "value[%zu]", v97);
      if ((uint64_t)v118.var1) {
        long long v100 = *(const char **)&v119.var0;
      }
      else {
        long long v100 = (char *)&v118.var1 + 1;
      }
      *(void *)unint64_t v130 = 0;
      *(void *)&v130[8] = "";
      re::StringID::StringID((re::StringID *)&v130[16], (const StringID *)&v126[8]);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add((_anonymous_namespace_ *)&v126[24], (uint64_t *)v130);
      re::StringID::destroyString((re::StringID *)&v130[16]);
      re::StringID::destroyString((re::StringID *)v130);
      ++v97;
    }
    while (v98 != v97);
  }
  if (*(void *)&v118.var0 && ((uint64_t)v118.var1 & 1) != 0) {
    (*(void (**)(void))(**(void **)&v118.var0 + 40))();
  }
  *(unsigned char *)&v118.var0 = 1;
  LOBYTE(v118.var1) = v126[0];
  re::StringID::StringID((re::StringID *)&v119, (const StringID *)&v126[8]);
  re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v120, (uint64_t *)&v126[24]);
  re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v126[24]);
LABEL_50:
  re::StringID::destroyString((re::StringID *)&v126[8]);
  if (v118.var0)
  {
    v126[0] = v118.var1;
    re::StringID::StringID((re::StringID *)&v126[8], &v119);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v126[24], &v120);
    *(unsigned char *)a3 = 1;
    *(unsigned char *)(a3 + 8) = v126[0];
    re::StringID::StringID((re::StringID *)(a3 + 16), (const StringID *)&v126[8]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray(a3 + 32, (uint64_t *)&v126[24]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v126[24]);
    re::StringID::destroyString((re::StringID *)&v126[8]);
    goto LABEL_46;
  }
LABEL_45:
  *(void *)&v126[16] = 0;
  *(void *)&v126[24] = 0;
  *(_OWORD *)uint64_t v126 = a1;
  re::DynamicString::setCapacity(v126, 0x40uLL);
  re::DynamicString::append((re::DynamicString *)v126, "Unknown rig data type: ", 0x17uLL);
  re::DynamicString::append((re::DynamicString *)v126, *(const char **)a2, *(void *)(a2 + 8));
  long long v82 = *(_OWORD *)v126;
  uint64_t v83 = *(void *)&v126[16];
  uint64_t v84 = *(void *)&v126[24];
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = 5000;
  *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v82;
  *(void *)(a3 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v83;
  *(void *)(a3 + 48) = v84;
LABEL_46:
  re::Optional<re::RigDataTypeClass>::~Optional(&v118);
  return re::Optional<re::RigDataTypeClass>::~Optional(&v135);
}

void re::RigDataTypeClass::attributeType(uint64_t a1@<X0>, re::RigEnvironment *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v9 = *(void **)a3;
  size_t v8 = *(void *)(a3 + 8);
  size_t v10 = *(void *)a3 + v8;
  size_t v11 = (size_t)memchr(*(void **)a3, 46, v8);
  if (v11) {
    size_t v12 = v11;
  }
  else {
    size_t v12 = v10;
  }
  size_t v13 = v12 - (void)v9;
  if (v12 - (void)v9 == v8)
  {
    long long v38 = *(_OWORD *)a3;
  }
  else
  {
    *(void *)&long long v38 = v9;
    *((void *)&v38 + 1) = v12 - (void)v9;
  }
  if (*(unsigned char *)a1 == 12)
  {
    re::RigDataParser::extractArrayIndex((uint64_t *)&v38, (uint64_t)v31);
    if (!v31[0])
    {
      *(_OWORD *)(a4 + 8) = *(_OWORD *)&v31[8];
      long long v25 = v32;
      uint64_t v26 = v33;
      uint64_t v27 = v34;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 24) = v25;
      *(void *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v26;
      *(void *)(a4 + 48) = v27;
      return;
    }
    unint64_t v14 = (StringID *)(a1 + 8);
    goto LABEL_10;
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    unint64_t v14 = (StringID *)(*(void *)(a1 + 56) + 16);
    uint64_t v17 = 32 * v16;
    while (1)
    {
      size_t v11 = strlen(v14[-1].var1);
      if (*((void *)&v38 + 1) == v11)
      {
        size_t v11 = memcmp((const void *)v38, v14[-1].var1, *((size_t *)&v38 + 1));
        if (!v11) {
          break;
        }
      }
      v14 += 2;
      v17 -= 32;
      if (!v17) {
        goto LABEL_17;
      }
    }
LABEL_10:
    if (v13 == v8)
    {
      re::StringID::StringID((re::StringID *)v31, v14);
      *(unsigned char *)a4 = 1;
      uint64_t v15 = *(void *)&v31[8];
      *(void *)(a4 + 8) = *(void *)v31;
      *(void *)(a4 + 16) = v15;
      *(void *)uint64_t v31 = 0;
      *(void *)&v31[8] = "";
      re::StringID::destroyString((re::StringID *)v31);
    }
    else
    {
      re::RigEnvironment::lookupRigDataType(a2, (const char **)v14, v31);
      if (v31[0])
      {
        *(void *)&long long v35 = re::Slice<char>::range((void *)a3, v13 + 1, *(void *)(a3 + 8));
        *((void *)&v35 + 1) = v24;
        re::RigDataTypeClass::attributeType(&v31[8], a2, &v35);
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"Unknown child attribute type: %s", (re::DynamicString *)&v35, v14->var1);
        long long v28 = v35;
        unint64_t v29 = v36;
        uint64_t v30 = v37;
        *(unsigned char *)a4 = 0;
        *(void *)(a4 + 8) = 5000;
        *(void *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(a4 + 24) = v28;
        *(void *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v29;
        *(void *)(a4 + 48) = v30;
      }
      re::Optional<re::RigDataTypeClass>::~Optional(v31);
    }
    return;
  }
LABEL_17:
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v18 = *(void *)(a3 + 8);
  if (v18) {
    size_t v19 = v18 + 1;
  }
  else {
    size_t v19 = 0;
  }
  *((void *)&v35 + 1) = 0;
  re::DynamicString::setCapacity(&v35, v19);
  re::DynamicString::operator=((re::DynamicString *)&v35, a3);
  if (BYTE8(v35)) {
    long long v20 = v36;
  }
  else {
    long long v20 = (char *)&v35 + 9;
  }
  re::DynamicString::format((re::DynamicString *)"Attribute name could not be resolved: %s", (re::DynamicString *)v31, v20);
  long long v21 = *(_OWORD *)v31;
  uint64_t v22 = *(void *)&v31[16];
  uint64_t v23 = v32;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 5003;
  *(void *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v21;
  *(void *)(a4 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v22;
  *(void *)(a4 + 48) = v23;
  if (void)v35 && (BYTE8(v35)) {
    (*(void (**)(void))(*(void *)v35 + 40))();
  }
}

uint64_t re::Slice<char>::range(void *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::RigDataTypeClass::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  int v3 = *a2;
  if (v2 == 12)
  {
    if (v3 == 12) {
      return re::StringID::operator==((void *)a1 + 1, (void *)a2 + 1);
    }
  }
  else if (v2 == v3)
  {
    return re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::operator==((uint64_t)(a1 + 24), (uint64_t)(a2 + 24));
  }
  return 0;
}

BOOL re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  int v3 = *(void **)(a1 + 32);
  Float64 v4 = &v3[4 * v2];
  unint64_t v5 = *(void **)(a2 + 32);
  while (1)
  {
    BOOL result = re::StringID::operator==(v3, v5);
    if (!result) {
      break;
    }
    size_t v7 = v3 + 2;
    size_t v8 = v5 + 2;
    BOOL result = re::StringID::operator==(v7, v8);
    if (!result) {
      break;
    }
    int v3 = v7 + 2;
    unint64_t v5 = v8 + 2;
    if (v3 == v4) {
      return 1;
    }
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  int v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)result)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(result, v10);
      }
      else
      {
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v5 = *((void *)v3 + 2);
  }
  size_t v11 = (unint64_t *)(*((void *)v3 + 4) + 32 * v5);
  uint64_t v12 = *a2;
  *size_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *size_t v11 = *a2 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
  v11[1] = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  uint64_t v13 = a2[2];
  void v11[2] = v11[2] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  void v11[2] = a2[2] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  _OWORD v11[3] = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)"";
  ++*((void *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 32 * (a2 & 7);
}

void *re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        BOOL result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          BOOL result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 256, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              BOOL result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            BOOL result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    BOOL result = (void *)re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

char *re::RigDataParser::parseWhitespace(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v4 = -v1;
    uint64_t v5 = MEMORY[0x263EF8318];
    while (1)
    {
      unsigned int v6 = *(char *)v1;
      if ((v6 & 0x80000000) != 0)
      {
        if (!__maskrune(v6, 0x4000uLL)) {
          return (char *)*a1;
        }
      }
      else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x4000) == 0)
      {
        return (char *)*a1;
      }
      ++v1;
      --v4;
      if (!--v2)
      {
        uint64_t v1 = *a1;
        uint64_t v7 = a1[1];
        return (char *)(v1 + v7);
      }
    }
  }
  uint64_t v7 = 0;
  return (char *)(v1 + v7);
}

char *re::RigDataParser::parseAlphaNumeric(uint64_t *a1)
{
  uint64_t v2 = re::RigDataParser::parseWhitespace(a1);
  BOOL result = &v2[v3];
  unint64_t v5 = *a1 + a1[1];
  if ((unint64_t)result < v5)
  {
    unsigned int v6 = result;
    do
    {
      int v7 = *v6;
      if ((v7 - 48) >= 0xA && (v7 & 0xFFFFFFDF) - 65 > 0x19) {
        break;
      }
      ++v6;
    }
    while ((unint64_t)v6 < v5);
  }
  return result;
}

char *re::RigDataParser::parseNumeric(uint64_t *a1)
{
  uint64_t v2 = re::RigDataParser::parseWhitespace(a1);
  BOOL result = &v2[v3];
  unint64_t v5 = *a1 + a1[1];
  if ((unint64_t)result < v5)
  {
    unsigned int v6 = result;
    do
    {
      if (*v6 - 48 > 9) {
        break;
      }
      ++v6;
    }
    while ((unint64_t)v6 < v5);
  }
  return result;
}

char *re::RigDataParser::parseFloat(uint64_t *a1)
{
  uint64_t v2 = re::RigDataParser::parseWhitespace(a1);
  BOOL result = &v2[v3];
  unint64_t v5 = result + 1;
  if (*result != 45) {
    unint64_t v5 = result;
  }
  unint64_t v6 = *a1 + a1[1];
  if ((unint64_t)v5 >= v6)
  {
LABEL_7:
    int v7 = *v5;
  }
  else
  {
    while (1)
    {
      int v7 = *v5;
      if ((v7 - 48) > 9) {
        break;
      }
      if ((unint64_t)++v5 >= v6)
      {
        unint64_t v5 = (char *)(*a1 + a1[1]);
        goto LABEL_7;
      }
    }
  }
  if (v7 == 46)
  {
    int v8 = (unsigned __int8 *)(v5 + 1);
    do
    {
      unint64_t v9 = v8;
      if ((unint64_t)v8 >= v6) {
        break;
      }
      ++v8;
    }
    while (*v9 - 48 < 0xA);
  }
  return result;
}

char *re::RigDataParser::parseTypeName(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v18 = (char *)*a1;
  size_t v19 = v2;
  uint64_t v3 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v18);
  unint64_t v5 = v3;
  if (v4)
  {
    unint64_t v6 = *a1 + a1[1];
    uint64_t v18 = &v3[v4];
    size_t v19 = v6 - (void)&v3[v4];
    int v7 = re::RigDataParser::parseWhitespace((uint64_t *)&v18);
    unint64_t v9 = &v7[v8];
    size_t v10 = (unint64_t)&v7[v8] < v6;
    if (!strncmp(&v7[v8], "[", v10) && !str_4[v10])
    {
      size_t v11 = *a1 + a1[1] - (void)&v9[v10];
      uint64_t v18 = &v9[v10];
      size_t v19 = v11;
      unint64_t v12 = re::RigDataParser::parseNumeric((uint64_t *)&v18);
      unint64_t v13 = *a1 + a1[1];
      uint64_t v18 = &v12[v14];
      size_t v19 = v13 - (void)&v12[v14];
      uint64_t v15 = re::RigDataParser::parseWhitespace((uint64_t *)&v18);
      strncmp(&v15[v16], "]", (unint64_t)&v15[v16] < v13);
    }
  }
  return v5;
}

char *re::RigDataParser::extractArrayIndex@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = re::RigDataParser::parseAlphaNumeric(a1);
  size_t v6 = v5;
  int v7 = (_anonymous_namespace_ *)strncmp(v4, "value", v5);
  if (v7 || aValue[v6])
  {
    size_t v50 = 0;
    uint64_t v51 = 0;
    uint64_t v8 = a1[1];
    if (v8) {
      size_t v9 = v8 + 1;
    }
    else {
      size_t v9 = 0;
    }
    uint64_t v49 = 0;
    re::DynamicString::setCapacity(&v48, v9);
    re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
    if (v49) {
      size_t v10 = v50;
    }
    else {
      size_t v10 = (char *)&v49 + 1;
    }
    re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array value): %s", (re::DynamicString *)&v52, v10);
  }
  else
  {
    uint64_t v15 = &v4[v6];
    unint64_t v16 = *a1 + a1[1];
    *(void *)&long long v52 = v15;
    *((void *)&v52 + 1) = v16 - (void)v15;
    uint64_t v17 = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
    size_t v19 = &v17[v18];
    size_t v20 = (unint64_t)&v17[v18] < v16;
    long long v21 = (_anonymous_namespace_ *)strncmp(&v17[v18], "[", v20);
    if (v21 || str_4[v20])
    {
      size_t v50 = 0;
      uint64_t v51 = 0;
      uint64_t v22 = a1[1];
      if (v22) {
        size_t v23 = v22 + 1;
      }
      else {
        size_t v23 = 0;
      }
      uint64_t v49 = 0;
      re::DynamicString::setCapacity(&v48, v23);
      re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
      if (v49) {
        uint64_t v24 = v50;
      }
      else {
        uint64_t v24 = (char *)&v49 + 1;
      }
      re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array subscript): %s", (re::DynamicString *)&v52, v24);
    }
    else
    {
      size_t v25 = *a1 + a1[1] - (void)&v19[v20];
      *(void *)&long long v52 = &v19[v20];
      *((void *)&v52 + 1) = v25;
      uint64_t v26 = re::RigDataParser::parseNumeric((uint64_t *)&v52);
      if (v27)
      {
        long long v28 = v26;
        uint64_t v29 = v27;
        unint64_t v30 = *a1 + a1[1];
        *(void *)&long long v52 = &v26[v27];
        *((void *)&v52 + 1) = v30 - (void)&v26[v27];
        uint64_t v31 = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
        uint64_t v33 = &v31[v32];
        size_t v34 = (unint64_t)&v31[v32] < v30;
        long long v35 = (_anonymous_namespace_ *)strncmp(&v31[v32], "]", v34);
        if (v35 || str_1_5[v34])
        {
          size_t v50 = 0;
          uint64_t v51 = 0;
          uint64_t v36 = a1[1];
          if (v36) {
            size_t v37 = v36 + 1;
          }
          else {
            size_t v37 = 0;
          }
          uint64_t v49 = 0;
          re::DynamicString::setCapacity(&v48, v37);
          re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
          if (v49) {
            long long v38 = v50;
          }
          else {
            long long v38 = (char *)&v49 + 1;
          }
          re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array subscript end): %s", (re::DynamicString *)&v52, v38);
        }
        else
        {
          size_t v42 = &v33[v34];
          int32x4_t v43 = (char *)(*a1 + a1[1]);
          *(void *)&long long v52 = v42;
          *((void *)&v52 + 1) = v43 - v42;
          BOOL result = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
          if (&result[v44] == v43)
          {
            *(unsigned char *)a2 = 1;
            *(void *)(a2 + 8) = v28;
            *(void *)(a2 + 16) = v29;
            return result;
          }
          size_t v50 = 0;
          uint64_t v51 = 0;
          uint64_t v45 = a1[1];
          if (v45) {
            size_t v46 = v45 + 1;
          }
          else {
            size_t v46 = 0;
          }
          uint64_t v49 = 0;
          re::DynamicString::setCapacity(&v48, v46);
          re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
          if (v49) {
            uint64_t v47 = v50;
          }
          else {
            uint64_t v47 = (char *)&v49 + 1;
          }
          re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected only array value): %s", (re::DynamicString *)&v52, v47);
        }
      }
      else
      {
        size_t v50 = 0;
        uint64_t v51 = 0;
        uint64_t v39 = a1[1];
        if (v39) {
          size_t v40 = v39 + 1;
        }
        else {
          size_t v40 = 0;
        }
        uint64_t v49 = 0;
        re::DynamicString::setCapacity(&v48, v40);
        re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
        if (v49) {
          float32x4_t v41 = v50;
        }
        else {
          float32x4_t v41 = (char *)&v49 + 1;
        }
        re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array index): %s", (re::DynamicString *)&v52, v41);
      }
    }
  }
  long long v11 = v52;
  uint64_t v12 = v53;
  uint64_t v13 = v54;
  *(unsigned char *)a2 = 0;
  *(void *)(a2 + 8) = 5007;
  *(void *)(a2 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v11;
  *(void *)(a2 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v12;
  *(void *)(a2 + 48) = v13;
  BOOL result = (char *)v48;
  if (v48)
  {
    if (v49) {
      return (char *)(*(uint64_t (**)(void))(*v48 + 40))();
    }
  }
  return result;
}

float re::RigDataParser::stringToFloat(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t)*a1;
  uint64_t v2 = a1[1];
  int v3 = **a1;
  uint64_t v4 = (unsigned __int8 *)(v3 == 45);
  float result = 0.0;
  if (v2 != v4)
  {
    size_t v6 = (char *)&v2[v1];
    int v7 = (char *)&v4[v1];
    uint64_t v8 = &v2[~(unint64_t)v4];
    while (1)
    {
      int v9 = *v7;
      if (v9 == 46) {
        break;
      }
      float result = (float)(result * 10.0) + (float)(v9 - 48);
      ++v7;
      --v8;
      if (v7 == v6) {
        goto LABEL_9;
      }
    }
    if (v7 + 1 != v6)
    {
      float v10 = 1.0;
      uint64_t v11 = 1;
      do
      {
        float v10 = v10 * 0.1;
        float result = result + (float)((float)(v7[v11++] - 48) * v10);
        --v8;
      }
      while (v8);
    }
  }
LABEL_9:
  if (v3 == 45) {
    return -result;
  }
  return result;
}

uint64_t *re::FixedArray<float>::operator=(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = *a2;
    if (*result) {
      BOOL v4 = v2 == v3;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      *float result = v3;
      *a2 = v2;
      uint64_t v5 = result[1];
      uint64_t v6 = result[2];
      uint64_t v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      float result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

double re::KeyframeAnimation<float>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t re::KeyframeAnimation<float>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  unint64_t v6 = *(void *)(result + 88);
  unint64_t v7 = *(void *)(result + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(result + 112);
  }
  else {
    uint64_t v8 = *(void *)(result + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7) {
      goto LABEL_29;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    float result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        uint64_t v11 = *(float **)(result + 96);
        float v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            uint64_t v13 = *(float **)(result + 96);
            unint64_t v14 = v6;
            do
            {
              unint64_t v15 = v14 >> 1;
              unint64_t v16 = &v13[v14 >> 1];
              float v18 = *v16;
              uint64_t v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12) {
                uint64_t v13 = v17;
              }
              else {
                unint64_t v14 = v15;
              }
            }
            while (v14);
            unint64_t v19 = v13 - v11;
            if (!*(unsigned char *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                float v10 = *(float *)(*(void *)(result + 120) + 4 * v19);
                goto LABEL_30;
              }
LABEL_44:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            unint64_t v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                float v21 = v11[v20];
                float v22 = v11[v19] - v21;
                float v23 = 0.0;
                if (v22 > 0.0) {
                  float v23 = (float)(v12 - v21) / v22;
                }
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    float v10 = (float)(v23 * *(float *)(*(void *)(result + 120) + 4 * v19))
                        + (float)(*(float *)(*(void *)(result + 120) + 4 * v20) * (float)(1.0 - v23));
                    goto LABEL_30;
                  }
                  goto LABEL_43;
                }
LABEL_42:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_43:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
LABEL_41:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_42;
            }
LABEL_40:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_41;
          }
          if (v7 > v9)
          {
            float v10 = *(float *)(*(void *)(result + 120) + 4 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          float v10 = **(float **)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8) {
    goto LABEL_10;
  }
  float v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<double>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t re::KeyframeAnimation<double>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, double *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  unint64_t v6 = *(void *)(result + 88);
  unint64_t v7 = *(void *)(result + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(result + 112);
  }
  else {
    uint64_t v8 = *(void *)(result + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7) {
      goto LABEL_29;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    float result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        uint64_t v11 = *(float **)(result + 96);
        float v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            uint64_t v13 = *(float **)(result + 96);
            unint64_t v14 = v6;
            do
            {
              unint64_t v15 = v14 >> 1;
              unint64_t v16 = &v13[v14 >> 1];
              float v18 = *v16;
              uint64_t v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12) {
                uint64_t v13 = v17;
              }
              else {
                unint64_t v14 = v15;
              }
            }
            while (v14);
            unint64_t v19 = v13 - v11;
            if (!*(unsigned char *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                double v10 = *(double *)(*(void *)(result + 120) + 8 * v19);
                goto LABEL_30;
              }
LABEL_44:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            unint64_t v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                float v21 = v11[v20];
                float v22 = v11[v19] - v21;
                float v23 = 0.0;
                if (v22 > 0.0) {
                  float v23 = (float)(v12 - v21) / v22;
                }
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    double v10 = *(double *)(*(void *)(result + 120) + 8 * v19) * v23
                        + *(double *)(*(void *)(result + 120) + 8 * v20) * (float)(1.0 - v23);
                    goto LABEL_30;
                  }
                  goto LABEL_43;
                }
LABEL_42:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_43:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
LABEL_41:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_42;
            }
LABEL_40:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_41;
          }
          if (v7 > v9)
          {
            double v10 = *(double *)(*(void *)(result + 120) + 8 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          double v10 = **(double **)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8) {
    goto LABEL_10;
  }
  double v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t re::KeyframeAnimation<re::Vector2<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, float32x2_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_37;
  }
  unint64_t v6 = *(void *)(result + 88);
  unint64_t v7 = *(void *)(result + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(result + 112);
  }
  else {
    uint64_t v8 = *(void *)(result + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7) {
      goto LABEL_29;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    float result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        uint64_t v11 = *(float **)(result + 96);
        float v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            uint64_t v13 = *(float **)(result + 96);
            unint64_t v14 = v6;
            do
            {
              unint64_t v15 = v14 >> 1;
              unint64_t v16 = &v13[v14 >> 1];
              float v18 = *v16;
              uint64_t v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12) {
                uint64_t v13 = v17;
              }
              else {
                unint64_t v14 = v15;
              }
            }
            while (v14);
            unint64_t v19 = v13 - v11;
            if (!*(unsigned char *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                float32x2_t v10 = *(float32x2_t *)(*(void *)(result + 120) + 8 * v19);
                goto LABEL_30;
              }
LABEL_45:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            unint64_t v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                float v21 = v11[v20];
                float v22 = v11[v19] - v21;
                float v23 = 0.0;
                if (v22 > 0.0) {
                  float v23 = (float)(v12 - v21) / v22;
                }
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    *a6 = vadd_f32(vmul_n_f32(*(float32x2_t *)(*(void *)(result + 120) + 8 * v20), 1.0 - v23), vmul_n_f32(*(float32x2_t *)(*(void *)(result + 120) + 8 * v19), v23));
                    return result;
                  }
                  goto LABEL_44;
                }
LABEL_43:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_44:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_45;
              }
LABEL_42:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_43;
            }
LABEL_41:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_42;
          }
          if (v7 > v9)
          {
            float32x2_t v10 = *(float32x2_t *)(*(void *)(result + 120) + 8 * v9);
            goto LABEL_30;
          }
LABEL_40:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_41;
        }
        if (v7)
        {
LABEL_29:
          float32x2_t v10 = **(float32x2_t **)(result + 120);
          goto LABEL_30;
        }
LABEL_39:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_40;
      }
LABEL_38:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_39;
    }
LABEL_37:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  if (v8) {
    goto LABEL_10;
  }
  float32x2_t v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t re::KeyframeAnimation<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_37;
  }
  unint64_t v6 = *(void *)(result + 88);
  unint64_t v7 = *(void *)(result + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(result + 112);
  }
  else {
    uint64_t v8 = *(void *)(result + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7) {
      goto LABEL_29;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    float result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        uint64_t v11 = *(float **)(result + 96);
        float v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            uint64_t v13 = *(float **)(result + 96);
            unint64_t v14 = v6;
            do
            {
              unint64_t v15 = v14 >> 1;
              unint64_t v16 = &v13[v14 >> 1];
              float v18 = *v16;
              uint64_t v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12) {
                uint64_t v13 = v17;
              }
              else {
                unint64_t v14 = v15;
              }
            }
            while (v14);
            unint64_t v19 = v13 - v11;
            if (!*(unsigned char *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                float32x4_t v10 = *(float32x4_t *)(*(void *)(result + 120) + 16 * v19);
                goto LABEL_30;
              }
              goto LABEL_44;
            }
            unint64_t v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                float v21 = v11[v20];
                float v22 = v11[v19] - v21;
                float v23 = 0.0;
                if (v22 > 0.0) {
                  float v23 = (float)(v12 - v21) / v22;
                }
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    *a6 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 120) + 16 * v19), v23), *(float32x4_t *)(*(void *)(result + 120) + 16 * v20), 1.0 - v23);
                    return result;
                  }
LABEL_45:
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
                goto LABEL_43;
              }
LABEL_42:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_43:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_44:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_45;
            }
LABEL_41:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_42;
          }
          if (v7 > v9)
          {
            float32x4_t v10 = *(float32x4_t *)(*(void *)(result + 120) + 16 * v9);
            goto LABEL_30;
          }
LABEL_40:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_41;
        }
        if (v7)
        {
LABEL_29:
          float32x4_t v10 = *(float32x4_t *)*(void *)(result + 120);
          goto LABEL_30;
        }
LABEL_39:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_40;
      }
LABEL_38:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_39;
    }
LABEL_37:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  if (v8) {
    goto LABEL_10;
  }
  float32x4_t v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t re::KeyframeAnimation<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  unint64_t v6 = *(void *)(result + 88);
  unint64_t v7 = *(void *)(result + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(result + 112);
  }
  else {
    uint64_t v8 = *(void *)(result + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7) {
      goto LABEL_29;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    float result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        uint64_t v11 = *(float **)(result + 96);
        float v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            uint64_t v13 = *(float **)(result + 96);
            unint64_t v14 = v6;
            do
            {
              unint64_t v15 = v14 >> 1;
              unint64_t v16 = &v13[v14 >> 1];
              float v18 = *v16;
              uint64_t v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12) {
                uint64_t v13 = v17;
              }
              else {
                unint64_t v14 = v15;
              }
            }
            while (v14);
            unint64_t v19 = v13 - v11;
            if (!*(unsigned char *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                float32x4_t v10 = *(float32x4_t *)(*(void *)(result + 120) + 16 * v19);
                goto LABEL_30;
              }
              goto LABEL_42;
            }
            unint64_t v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                float v21 = v11[v20];
                float v22 = v11[v19] - v21;
                float v23 = 0.0;
                if (v22 > 0.0) {
                  float v23 = (float)(v12 - v21) / v22;
                }
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    float32x4_t v10 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 120) + 16 * v20), 1.0 - v23), vmulq_n_f32(*(float32x4_t *)(*(void *)(result + 120) + 16 * v19), v23));
                    goto LABEL_30;
                  }
LABEL_44:
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
LABEL_43:
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
              goto LABEL_41;
            }
LABEL_40:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_41:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_42:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_43;
          }
          if (v7 > v9)
          {
            float32x4_t v10 = *(float32x4_t *)(*(void *)(result + 120) + 16 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          float32x4_t v10 = *(float32x4_t *)*(void *)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8) {
    goto LABEL_10;
  }
  float32x4_t v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

void re::KeyframeAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_38:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
  unint64_t v6 = *(void *)(a1 + 88);
  unint64_t v7 = *(void *)(a1 + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(a1 + 112);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
    {
LABEL_31:
      long long v10 = *(_OWORD *)*(void *)(a1 + 120);
      goto LABEL_32;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
  }
  else if (!v8)
  {
    long long v10 = *a4;
LABEL_32:
    *(_OWORD *)a6 = v10;
    return;
  }
  if (!v6) {
    goto LABEL_38;
  }
  if (v6 <= v9)
  {
LABEL_39:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_40;
  }
  uint64_t v11 = *(float **)(a1 + 96);
  float v12 = *(double *)(a2 + 24);
  if (*v11 >= v12)
  {
    if (v7) {
      goto LABEL_31;
    }
LABEL_40:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_41:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_42:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_43;
  }
  if (v11[v9] <= v12)
  {
    if (v7 > v9)
    {
      long long v10 = *(_OWORD *)(*(void *)(a1 + 120) + 16 * v9);
      goto LABEL_32;
    }
    goto LABEL_41;
  }
  uint64_t v13 = *(float **)(a1 + 96);
  unint64_t v14 = v6;
  do
  {
    unint64_t v15 = v14 >> 1;
    unint64_t v16 = &v13[v14 >> 1];
    float v18 = *v16;
    uint64_t v17 = v16 + 1;
    v14 += ~(v14 >> 1);
    if (v18 < v12) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v14 = v15;
    }
  }
  while (v14);
  unint64_t v19 = v13 - v11;
  if (!*(unsigned char *)(a1 + 73) || v19 == v8)
  {
    if (v7 > v19)
    {
      long long v10 = *(_OWORD *)(*(void *)(a1 + 120) + 16 * v19);
      goto LABEL_32;
    }
LABEL_46:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v20 = v19 - 1;
  if (v6 <= v19 - 1) {
    goto LABEL_42;
  }
  if (v6 <= v19)
  {
LABEL_43:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_44:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_45;
  }
  float v21 = v11[v20];
  float v22 = v11[v19] - v21;
  float v23 = 0.0;
  if (v22 > 0.0) {
    float v23 = (float)(v12 - v21) / v22;
  }
  if (v7 <= v20) {
    goto LABEL_44;
  }
  if (v7 <= v19)
  {
LABEL_45:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_46;
  }
  uint64_t v24 = *(void *)(a1 + 120);
  re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)(v24 + 16 * v20), (float32x4_t *)(v24 + 16 * v19), a6, v23);
}

double re::KeyframeAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

void re::KeyframeAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_38;
  }
  unint64_t v7 = *(void *)(a1 + 88);
  unint64_t v8 = *(void *)(a1 + 112);
  if (v7 >= v8) {
    uint64_t v9 = *(void *)(a1 + 112);
  }
  else {
    uint64_t v9 = *(void *)(a1 + 88);
  }
  unint64_t v10 = v9 - 1;
  if (v9 == 1)
  {
    if (v8) {
      goto LABEL_29;
    }
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    float32x4_t v29 = 0u;
    a6 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v7)
    {
      if (v7 > v10)
      {
        unint64_t v14 = *(float **)(a1 + 96);
        float v15 = *(double *)(a2 + 24);
        if (*v14 < v15)
        {
          if (v14[v10] > v15)
          {
            unint64_t v16 = *(float **)(a1 + 96);
            unint64_t v17 = v7;
            do
            {
              unint64_t v18 = v17 >> 1;
              unint64_t v19 = &v16[v17 >> 1];
              float v21 = *v19;
              unint64_t v20 = v19 + 1;
              v17 += ~(v17 >> 1);
              if (v21 < v15) {
                unint64_t v16 = v20;
              }
              else {
                unint64_t v17 = v18;
              }
            }
            while (v17);
            unint64_t v22 = v16 - v14;
            if (*(unsigned char *)(a1 + 73) && v22 != v9)
            {
              unint64_t v23 = v22 - 1;
              if (v7 > v22 - 1)
              {
                if (v7 > v22)
                {
                  float v24 = v14[v23];
                  float v25 = v14[v22] - v24;
                  float v26 = 0.0;
                  if (v25 > 0.0) {
                    float v26 = (float)(v15 - v24) / v25;
                  }
                  if (v8 > v23)
                  {
                    if (v8 > v22)
                    {
                      re::lerp<float>((float32x4_t *)(*(void *)(a1 + 120) + 48 * v23), (float32x4_t *)(*(void *)(a1 + 120) + 48 * v22), &v29, v26);
                      long long v27 = v30;
                      *(float32x4_t *)a6 = v29;
                      *(_OWORD *)(a6 + 16) = v27;
                      *(_OWORD *)(a6 + 32) = v31;
                      return;
                    }
LABEL_46:
                    long long v32 = 0u;
                    long long v33 = 0u;
                    long long v30 = 0u;
                    long long v31 = 0u;
                    float32x4_t v29 = 0u;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
                  }
LABEL_45:
                  long long v32 = 0u;
                  long long v33 = 0u;
                  long long v30 = 0u;
                  long long v31 = 0u;
                  float32x4_t v29 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_46;
                }
                goto LABEL_43;
              }
LABEL_42:
              long long v32 = 0u;
              long long v33 = 0u;
              long long v30 = 0u;
              long long v31 = 0u;
              float32x4_t v29 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_43:
              long long v32 = 0u;
              long long v33 = 0u;
              long long v30 = 0u;
              long long v31 = 0u;
              float32x4_t v29 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_44;
            }
            if (v8 <= v22)
            {
LABEL_44:
              long long v32 = 0u;
              long long v33 = 0u;
              long long v30 = 0u;
              long long v31 = 0u;
              float32x4_t v29 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_45;
            }
            long long v28 = (long long *)(*(void *)(a1 + 120) + 48 * v22);
LABEL_30:
            long long v11 = *v28;
            long long v12 = v28[1];
            long long v13 = v28[2];
            goto LABEL_31;
          }
          if (v8 > v10)
          {
            long long v28 = (long long *)(*(void *)(a1 + 120) + 48 * v10);
            goto LABEL_30;
          }
LABEL_41:
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          float32x4_t v29 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_42;
        }
        if (v8)
        {
LABEL_29:
          long long v28 = *(long long **)(a1 + 120);
          goto LABEL_30;
        }
LABEL_40:
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        float32x4_t v29 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_41;
      }
LABEL_39:
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      float32x4_t v29 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_40;
    }
LABEL_38:
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    float32x4_t v29 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
  if (v9) {
    goto LABEL_10;
  }
  long long v11 = *a4;
  long long v12 = a4[1];
  long long v13 = a4[2];
LABEL_31:
  *(_OWORD *)(a6 + 16) = v12;
  *(_OWORD *)(a6 + 32) = v13;
  *(_OWORD *)a6 = v11;
}

double re::KeyframeAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

void re::KeyframeAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, int a5, void *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_40:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v6 = *(void *)(a1 + 88);
  unint64_t v7 = *(void *)(a1 + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(a1 + 112);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
    {
LABEL_31:
      a4 = *(void **)(a1 + 120);
      goto LABEL_32;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
  }
  else if (!v8)
  {
    goto LABEL_32;
  }
  if (!v6) {
    goto LABEL_40;
  }
  if (v6 <= v9)
  {
LABEL_41:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_42;
  }
  long long v11 = *(float **)(a1 + 96);
  float v12 = *(double *)(a2 + 24);
  if (*v11 >= v12)
  {
    if (v7) {
      goto LABEL_31;
    }
LABEL_42:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_43;
  }
  if (v11[v9] <= v12)
  {
    if (v7 > v9)
    {
      a4 = (void *)(*(void *)(a1 + 120) + 88 * v9);
      goto LABEL_32;
    }
LABEL_43:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_44;
  }
  long long v13 = *(float **)(a1 + 96);
  unint64_t v14 = v6;
  do
  {
    unint64_t v15 = v14 >> 1;
    unint64_t v16 = &v13[v14 >> 1];
    float v18 = *v16;
    unint64_t v17 = v16 + 1;
    v14 += ~(v14 >> 1);
    if (v18 < v12) {
      long long v13 = v17;
    }
    else {
      unint64_t v14 = v15;
    }
  }
  while (v14);
  unint64_t v19 = v13 - v11;
  if (!*(unsigned char *)(a1 + 73) || v19 == v8)
  {
    if (v7 <= v19) {
      goto LABEL_48;
    }
    a4 = (void *)(*(void *)(a1 + 120) + 88 * v19);
LABEL_32:
    re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
    return;
  }
  unint64_t v20 = v19 - 1;
  if (v6 <= v19 - 1)
  {
LABEL_44:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_45;
  }
  if (v6 <= v19)
  {
LABEL_45:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_46:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_47;
  }
  float v21 = v11[v20];
  float v22 = v11[v19] - v21;
  float v23 = 0.0;
  if (v22 > 0.0) {
    float v23 = (float)(v12 - v21) / v22;
  }
  if (v7 <= v20) {
    goto LABEL_46;
  }
  if (v7 <= v19)
  {
LABEL_47:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v24 = *(void *)(a1 + 120);
  re::AnimationValueTraits<re::SkeletalPose>::interpolate((void *)(v24 + 88 * v20), (void *)(v24 + 88 * v19), a6, v23);
}

double re::KeyframeAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return *(float *)(*(void *)(a1 + 96) + 4 * v1 - 4);
  }
  else {
    return 0.0;
  }
}

uint64_t *re::KeyframeAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, uint64_t *a6)
{
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_40:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v6 = *(void *)(a1 + 88);
  unint64_t v7 = *(void *)(a1 + 112);
  if (v6 >= v7) {
    uint64_t v8 = *(void *)(a1 + 112);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 88);
  }
  unint64_t v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
    {
LABEL_31:
      a4 = *(uint64_t **)(a1 + 120);
      goto LABEL_32;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
  }
  else if (!v8)
  {
    goto LABEL_32;
  }
  if (!v6) {
    goto LABEL_40;
  }
  if (v6 <= v9)
  {
LABEL_41:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_42;
  }
  long long v11 = *(float **)(a1 + 96);
  float v12 = *(double *)(a2 + 24);
  if (*v11 >= v12)
  {
    if (v7) {
      goto LABEL_31;
    }
LABEL_42:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_43;
  }
  if (v11[v9] <= v12)
  {
    if (v7 > v9)
    {
      a4 = (uint64_t *)(*(void *)(a1 + 120) + 32 * v9);
      goto LABEL_32;
    }
LABEL_43:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_44;
  }
  long long v13 = *(float **)(a1 + 96);
  unint64_t v14 = v6;
  do
  {
    unint64_t v15 = v14 >> 1;
    unint64_t v16 = &v13[v14 >> 1];
    float v18 = *v16;
    unint64_t v17 = v16 + 1;
    v14 += ~(v14 >> 1);
    if (v18 < v12) {
      long long v13 = v17;
    }
    else {
      unint64_t v14 = v15;
    }
  }
  while (v14);
  unint64_t v19 = v13 - v11;
  if (!*(unsigned char *)(a1 + 73) || v19 == v8)
  {
    if (v7 <= v19) {
      goto LABEL_48;
    }
    a4 = (uint64_t *)(*(void *)(a1 + 120) + 32 * v19);
LABEL_32:
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  }
  unint64_t v20 = v19 - 1;
  if (v6 <= v19 - 1)
  {
LABEL_44:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_45;
  }
  if (v6 <= v19)
  {
LABEL_45:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_46:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_47;
  }
  float v21 = v11[v20];
  float v22 = v11[v19] - v21;
  float v23 = 0.0;
  if (v22 > 0.0) {
    float v23 = (float)(v12 - v21) / v22;
  }
  if (v7 <= v20) {
    goto LABEL_46;
  }
  if (v7 <= v19)
  {
LABEL_47:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v24 = *(void *)(a1 + 120);
  return (uint64_t *)re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)(v24 + 32 * v20), (void *)(v24 + 32 * v19), a6, v23);
}

uint64_t *re::KeyframeAnimation<float>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2A58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<float>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2A58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<double>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2AD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<double>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2AD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::Vector2<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2B58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::Vector2<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2B58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::Vector3<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2BD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::Vector3<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2BD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::Vector4<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2C58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::Vector4<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2C58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::Quaternion<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2CD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::Quaternion<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2CD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::GenericSRT<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2D58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::GenericSRT<float>>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2D58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::SkeletalPose>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2DD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::SkeletalPose>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::SkeletalPose>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2DD8;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::SkeletalPose>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::KeyframeAnimation<re::BlendShapeWeights>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2E58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::BlendShapeWeights>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  return a1;
}

void re::KeyframeAnimation<re::BlendShapeWeights>::~KeyframeAnimation(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C2E58;
  uint64_t v2 = (re::DynamicString *)(a1 + 5);
  re::FixedArray<re::BlendShapeWeights>::deinit(a1 + 13);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 10);
  *a1 = (uint64_t)&unk_26E6BF1F0;
  re::DynamicString::deinit(v2);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  JUMPOUT(0x237DBCBD0);
}

BOOL re::TimelineEventData::addParameterDescription(void *a1, StringID *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v6 = (uint64_t)(a1 + 17);
  unint64_t v7 = (re *)re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v7 && *((void *)v7 + 1))
  {
    uint64_t v8 = *re::animationLogObjects(v7);
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (result)
    {
      var1 = a2->var1;
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = var1;
      _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Event parameter named %s was already declared.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    switch(a3)
    {
      case 1:
        *(void *)buf = a1[23];
        *(void *)&void buf[8] = 1;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[26])
        {
          re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_21:
          re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_22:
          re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_23:
          re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_24:
          re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_25:
          re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
        }
        ++a1[23];
        break;
      case 2:
        *(void *)buf = a1[29];
        *(void *)&void buf[8] = 2;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[32]) {
          goto LABEL_21;
        }
        ++a1[29];
        break;
      case 3:
        *(void *)buf = a1[35];
        *(void *)&void buf[8] = 3;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[38]) {
          goto LABEL_22;
        }
        ++a1[35];
        break;
      case 4:
        *(void *)buf = a1[41];
        *(void *)&void buf[8] = 4;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[44]) {
          goto LABEL_23;
        }
        ++a1[41];
        break;
      case 5:
        *(void *)buf = a1[47];
        *(void *)&void buf[8] = 5;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[50]) {
          goto LABEL_24;
        }
        ++a1[47];
        break;
      case 6:
        *(void *)buf = a1[53];
        *(void *)&void buf[8] = 6;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[56]) {
          goto LABEL_25;
        }
        ++a1[53];
        break;
      default:
        return 1;
    }
    return 1;
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(uint64_t a1, StringID *a2, _OWORD *a3)
{
  unint64_t v6 = 0xBF58476D1CE4E5B9 * ((*(void *)&a2->var0 >> 31) ^ (*(void *)&a2->var0 >> 1));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v7 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    uint64_t result = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t result = re::StringID::operator==((void *)(v10 + 40 * v9 + 8), a2);
    if (result) {
      return result;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 40 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

void re::TimelineEventData::addEvent(re::TimelineEventData *this, uint64_t a2)
{
  BOOL v4 = this;
  uint64_t v83 = *MEMORY[0x263EF8340];
  unint64_t v5 = *((void *)this + 23);
  if (v5)
  {
    for (unint64_t i = 0; i < v5; ++i)
    {
      LODWORD(v78) = 0;
      this = (re::TimelineEventData *)re::DynamicArray<float>::insert((void *)v4 + 24, i + v5 * a2, &v78);
      unint64_t v5 = *((void *)v4 + 23);
    }
  }
  unint64_t v7 = *((void *)v4 + 29);
  if (v7)
  {
    unint64_t v8 = 0;
    unint64_t v9 = *((void *)v4 + 32);
    while (1)
    {
      unint64_t v10 = v8 + v7 * a2;
      unint64_t v11 = v9 + 1;
      if (v9 + 1 <= v10) {
        break;
      }
      if (v9 >= *((void *)v4 + 31))
      {
        this = (re::TimelineEventData *)re::DynamicArray<float>::growCapacity((void *)v4 + 30, v9 + 1);
        unint64_t v9 = *((void *)v4 + 32);
      }
      uint64_t v12 = *((void *)v4 + 34);
      uint64_t v13 = (_DWORD *)(v12 + 4 * v9);
      if (v9 > v10)
      {
        *uint64_t v13 = *(v13 - 1);
        uint64_t v14 = v12 + 4 * v10;
        if (v13 - 1 != (_DWORD *)v14)
        {
          this = (re::TimelineEventData *)memmove((void *)(v14 + 4), (const void *)v14, (size_t)v13 - v14 - 4);
          uint64_t v12 = *((void *)v4 + 34);
          unint64_t v9 = *((void *)v4 + 32);
        }
        uint64_t v13 = (_DWORD *)(v12 + 4 * v10);
      }
      *uint64_t v13 = 0;
      *((void *)v4 + 32) = ++v9;
      ++*((_DWORD *)v4 + 66);
      ++v8;
      unint64_t v7 = *((void *)v4 + 29);
      if (v8 >= v7) {
        goto LABEL_14;
      }
    }
    long long v69 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v73 = 136315906;
    *(void *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    __int16 v74 = 2048;
    unint64_t v75 = v8 + a2 * v7;
    __int16 v76 = 2048;
    unint64_t v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_77;
  }
LABEL_14:
  unint64_t v15 = *((void *)v4 + 35);
  if (v15)
  {
    unint64_t v8 = 0;
    unint64_t v7 = (unint64_t)"";
    while (1)
    {
      unint64_t v2 = v15 * a2;
      unint64_t v10 = v15 * a2 + v8;
      unint64_t v16 = *((void *)v4 + 38);
      unint64_t v11 = v16 + 1;
      if (v16 + 1 <= v10) {
        break;
      }
      if (v16 >= *((void *)v4 + 37))
      {
        re::DynamicArray<re::StringID>::growCapacity((void *)v4 + 36, v16 + 1);
        unint64_t v16 = *((void *)v4 + 38);
      }
      unint64_t v17 = (void *)(*((void *)v4 + 40) + 16 * v16);
      if (v16 <= v10)
      {
        *unint64_t v17 = 0;
        v17[1] = "";
        *(void *)unint64_t v73 = 0;
        *(void *)&v73[8] = "";
      }
      else
      {
        uint64_t v18 = *(v17 - 1);
        *unint64_t v17 = *(v17 - 2);
        v17[1] = v18;
        *(v17 - 2) = 0;
        *(v17 - 1) = "";
        uint64_t v19 = *((void *)v4 + 40);
        uint64_t v20 = *((void *)v4 + 38);
        float v21 = (uint64_t *)(v19 + 16 * v20 - 16);
        if (v21 != (uint64_t *)(v19 + 16 * v10))
        {
          uint64_t v22 = 16 * (v8 + v2) - 16 * v20 + 16;
          unint64_t v2 = v19 + 16 * v20 - 16;
          do
          {
            uint64_t v23 = *(void *)(v2 - 16);
            v2 -= 16;
            uint64_t v24 = *(v21 - 1);
            uint64_t v25 = *v21;
            *(v21 - 1) = (uint64_t)"";
            *(void *)unint64_t v2 = 0;
            uint64_t v26 = v21[1];
            v21[1] = v24;
            *(void *)&long long v78 = v23 & 0xFFFFFFFFFFFFFFFELL | v25 & 1;
            *((void *)&v78 + 1) = v26;
            *float v21 = v23;
            re::StringID::destroyString((re::StringID *)&v78);
            float v21 = (uint64_t *)v2;
            v22 += 16;
          }
          while (v22);
          uint64_t v19 = *((void *)v4 + 40);
        }
        long long v27 = (void *)(v19 + 16 * v10);
        *(void *)unint64_t v73 = 0;
        *(void *)&v73[8] = "";
        uint64_t v28 = v27[1];
        uint64_t v29 = *v27 & 1;
        v27[1] = "";
        *(void *)&long long v78 = v29;
        *((void *)&v78 + 1) = v28;
        *long long v27 = 0;
        re::StringID::destroyString((re::StringID *)&v78);
      }
      ++*((void *)v4 + 38);
      ++*((_DWORD *)v4 + 78);
      re::StringID::destroyString((re::StringID *)v73);
      ++v8;
      unint64_t v15 = *((void *)v4 + 35);
      if (v8 >= v15) {
        goto LABEL_27;
      }
    }
LABEL_77:
    long long v69 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    a2 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v73 = 136315906;
    *(void *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    __int16 v74 = 2048;
    unint64_t v75 = v10;
    __int16 v76 = 2048;
    unint64_t v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_78:
    long long v69 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v73 = 136315906;
    *(void *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    __int16 v74 = 2048;
    unint64_t v75 = v8 + a2 * v7;
    __int16 v76 = 2048;
    unint64_t v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_79:
    uint64_t v72 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v73 = 136315906;
    *(void *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    __int16 v74 = 2048;
    unint64_t v75 = v10;
    __int16 v76 = 2048;
    unint64_t v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_80;
  }
LABEL_27:
  unint64_t v7 = *((void *)v4 + 41);
  if (v7)
  {
    unint64_t v8 = 0;
    unint64_t v30 = *((void *)v4 + 44);
    do
    {
      unint64_t v10 = v8 + v7 * a2;
      unint64_t v11 = v30 + 1;
      if (v30 + 1 <= v10) {
        goto LABEL_78;
      }
      if (v30 >= *((void *)v4 + 43))
      {
        this = (re::TimelineEventData *)re::DynamicArray<re::Vector4<float>>::growCapacity((void *)v4 + 42, v30 + 1);
        unint64_t v30 = *((void *)v4 + 44);
      }
      uint64_t v31 = *((void *)v4 + 46) + 16 * v30;
      if (v30 > v10)
      {
        *(_OWORD *)uint64_t v31 = *(_OWORD *)(v31 - 16);
        uint64_t v32 = *((void *)v4 + 46);
        uint64_t v33 = v32 + 16 * v10;
        uint64_t v34 = v32 + 16 * *((void *)v4 + 44) - 16;
        if (v34 != v33)
        {
          this = (re::TimelineEventData *)memmove((void *)(v33 + 16), (const void *)v33, v34 - v33);
          uint64_t v32 = *((void *)v4 + 46);
        }
        uint64_t v31 = v32 + 16 * v10;
      }
      *(void *)uint64_t v31 = 0;
      *(void *)(v31 + 8) = 0;
      unint64_t v30 = *((void *)v4 + 44) + 1;
      *((void *)v4 + 44) = v30;
      ++*((_DWORD *)v4 + 90);
      ++v8;
      unint64_t v7 = *((void *)v4 + 41);
    }
    while (v8 < v7);
  }
  unint64_t v35 = *((void *)v4 + 47);
  if (v35)
  {
    for (unint64_t j = 0; j < v35; ++j)
    {
      unint64_t v2 = v35 * a2;
      unint64_t v10 = v35 * a2 + j;
      long long v69 = 0;
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      unint64_t v37 = *((void *)v4 + 50);
      unint64_t v11 = v37 + 1;
      if (v37 + 1 <= v10) {
        goto LABEL_79;
      }
      if (v37 >= *((void *)v4 + 49))
      {
        re::DynamicArray<re::FixedArray<unsigned char>>::growCapacity((void *)v4 + 48, v37 + 1);
        unint64_t v37 = *((void *)v4 + 50);
      }
      uint64_t v38 = *((void *)v4 + 52);
      uint64_t v39 = (re::TimelineEventData **)(v38 + 24 * v37);
      if (v37 <= v10)
      {
        uint64_t v49 = v38 + 24 * v37;
        *uint64_t v39 = 0;
        v39[1] = 0;
        v39[2] = 0;
        *uint64_t v39 = v69;
        long long v69 = 0;
        *(void *)(v49 + 8) = v70;
        uint64_t v70 = 0;
        uint64_t v50 = *(void *)(v49 + 16);
        *(void *)(v49 + 16) = v71;
        uint64_t v71 = v50;
      }
      else
      {
        uint64_t v40 = v38 + 24 * v37;
        v39[1] = 0;
        v39[2] = 0;
        uint64_t v41 = *(void *)(v40 - 16);
        *uint64_t v39 = *(re::TimelineEventData **)(v40 - 24);
        *(void *)(v40 - 24) = 0;
        *(void *)(v40 - 16) = 0;
        uint64_t v42 = *(void *)(v40 + 16);
        uint64_t v43 = *(void *)(v40 - 8);
        *(void *)(v40 + 8) = v41;
        *(void *)(v40 + 16) = v43;
        *(void *)(v40 - 8) = v42;
        uint64_t v44 = *((void *)v4 + 52);
        uint64_t v45 = *((void *)v4 + 50);
        size_t v46 = (uint64_t *)(v44 + 24 * v45 - 24);
        if (v46 != (uint64_t *)(v44 + 24 * v10))
        {
          uint64_t v47 = -24 * v45 + 24 * (j + v2) + 24;
          do
          {
            int v48 = v46 - 3;
            re::FixedArray<float>::operator=(v46, v46 - 3);
            size_t v46 = v48;
            v47 += 24;
          }
          while (v47);
          uint64_t v44 = *((void *)v4 + 52);
        }
        re::FixedArray<float>::operator=((uint64_t *)(v44 + 24 * v10), (uint64_t *)&v69);
      }
      ++*((void *)v4 + 50);
      ++*((_DWORD *)v4 + 102);
      this = v69;
      if (v69 && v70) {
        this = (re::TimelineEventData *)(*(uint64_t (**)(void))(*(void *)v69 + 40))();
      }
      unint64_t v35 = *((void *)v4 + 47);
    }
  }
  unint64_t v51 = *((void *)v4 + 53);
  if (v51)
  {
    unint64_t v52 = 0;
    while (1)
    {
      uint64_t v53 = v51 * a2;
      unint64_t v2 = v51 * a2 + v52;
      unint64_t v54 = *((void *)v4 + 56);
      unint64_t v11 = v54 + 1;
      if (v54 + 1 <= v2) {
        break;
      }
      unint64_t v55 = *((void *)v4 + 55);
      if (v54 >= v55)
      {
        if (v55 < v11)
        {
          if (*((void *)v4 + 54))
          {
            unint64_t v56 = 2 * v55;
            if (!v55) {
              unint64_t v56 = 8;
            }
            if (v56 <= v11) {
              unint64_t v57 = v11;
            }
            else {
              unint64_t v57 = v56;
            }
            this = (re::TimelineEventData *)re::DynamicArray<re::ObjCObject>::setCapacity((void *)v4 + 54, v57);
          }
          else
          {
            this = (re::TimelineEventData *)re::DynamicArray<re::ObjCObject>::setCapacity((void *)v4 + 54, v11);
            ++*((_DWORD *)v4 + 114);
          }
        }
        unint64_t v54 = *((void *)v4 + 56);
      }
      uint64_t v58 = *((void *)v4 + 58);
      if (v54 <= v2)
      {
        *(void *)(v58 + 8 * v54) = 0;
      }
      else
      {
        unint64_t v59 = (void *)(v58 + 8 * v54);
        uint64_t v60 = *(v59 - 1);
        *(v59 - 1) = 0;
        *unint64_t v59 = v60;
        uint64_t v61 = *((void *)v4 + 58);
        uint64_t v62 = *((void *)v4 + 56);
        int v63 = (void **)(v61 + 8 * v62 - 8);
        if (v63 != (void **)(v61 + 8 * v2))
        {
          uint64_t v64 = 8 * (v52 + v53) - 8 * v62 + 8;
          uint64_t v65 = (void **)(v61 + 8 * v62 - 8);
          do
          {
            uint64_t v66 = *--v65;
            *uint64_t v65 = 0;
            unint64_t v67 = *v63;
            *int v63 = v66;

            int v63 = v65;
            v64 += 8;
          }
          while (v64);
          uint64_t v61 = *((void *)v4 + 58);
        }
        uint64_t v68 = *(void **)(v61 + 8 * v2);
        *(void *)(v61 + 8 * v2) = 0;

        unint64_t v54 = *((void *)v4 + 56);
      }
      *((void *)v4 + 56) = v54 + 1;
      ++*((_DWORD *)v4 + 114);
      ++v52;
      unint64_t v51 = *((void *)v4 + 53);
      if (v52 >= v51) {
        return;
      }
    }
LABEL_80:
    long long v69 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v78 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v73 = 136315906;
    *(void *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    __int16 v74 = 2048;
    unint64_t v75 = v2;
    __int16 v76 = 2048;
    unint64_t v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::EventTimeline::setEventData(re::EventTimeline *this, const re::TimelineEventData *a2, re::Allocator *a3)
{
  unint64_t v6 = (ArcSharedObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 584, 8);
  ArcSharedObject::ArcSharedObject(v6, 0);
  uint64_t v7[2] = a3;
  *unint64_t v7 = &unk_26E6C3048;
  re::TimelineEventData::TimelineEventData((re::TimelineEventData *)(v7 + 3), a2);
  uint64_t v8 = *((void *)this + 10);
  *((void *)this + 10) = v6;
  if (v8)
  {
  }
}

void re::TimelineEventData::addEvent(re::TimelineEventData *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X1>, uint64_t a5@<X8>)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (a3 < 0.0)
  {
    *(unsigned char *)a5 = 0;
    return;
  }
  if (a3 == 0.0)
  {
    unint64_t v7 = *((void *)this + 14);
    if (!v7)
    {
LABEL_24:
      unint64_t v8 = 0;
      goto LABEL_25;
    }
    unint64_t v8 = 0;
    uint64_t v9 = *((void *)this + 16);
    while (*(float *)(v9 + 4 * v8) < a2)
    {
      if (v7 == ++v8)
      {
        unint64_t v8 = *((void *)this + 14);
        break;
      }
    }
    if (!v8) {
      goto LABEL_25;
    }
    if (v7 <= v8 - 1)
    {
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v21 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_30;
    }
    if (*(float *)(v9 + 4 * (v8 - 1)) < a2)
    {
LABEL_25:
      float v18 = a2;
      *(float *)&long long v21 = v18;
      re::DynamicArray<float>::insert((void *)this + 12, v8, &v21);
      re::TimelineEventData::addEvent(this, *((void *)this + 4) + v8);
      unint64_t v19 = *((void *)this + 4) + v8;
      *(unsigned char *)a5 = 1;
      *(void *)(a5 + 8) = v19;
      return;
    }
    re::internal::assertLog((re::internal *)5, a4, "assertion failure: '%s' (%s:line %i) Can not add skip only, fence event at time %f. It overlaps with an existing fence event.", "false", "addEvent", 127, *(void *)&a2);
    _os_crash();
    __break(1u);
  }
  double v10 = a3;
  unint64_t v11 = *((void *)this + 4);
  if (!v11)
  {
    uint64_t v14 = (void *)((char *)this + 16);
LABEL_27:
    unint64_t v12 = 0;
    float v17 = a2;
    goto LABEL_28;
  }
  unint64_t v12 = 0;
  uint64_t v13 = *((void *)this + 6);
  while (*(float *)(v13 + 4 * v12) < a2)
  {
    if (v11 == ++v12)
    {
      unint64_t v12 = *((void *)this + 4);
      break;
    }
  }
  uint64_t v14 = (void *)((char *)this + 16);
  if (!v12) {
    goto LABEL_27;
  }
  unint64_t v15 = v12 - 1;
  if (v11 <= v12 - 1)
  {
LABEL_30:
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_31:
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*((void *)this + 9) <= v15) {
    goto LABEL_31;
  }
  float v16 = *(float *)(v13 + 4 * v15) + *(float *)(*((void *)this + 11) + 4 * v15);
  float v17 = a2;
  if (v16 > v17 && vabds_f32(v16, v17) >= (float)((float)((float)(fabsf(v17) + fabsf(v16)) + 1.0) * 0.00001))
  {
    re::internal::assertLog((re::internal *)6, a4, "assertion failure: '%s' (%s:line %i) Can not add event inteval at time %f with duration %f. It overlaps with an existing event.", "false", "addEvent", 143, *(void *)&a2, *(void *)&v10);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
LABEL_28:
  *(float *)&long long v21 = v17;
  re::DynamicArray<float>::insert(v14, v12, &v21);
  float v20 = v10;
  *(float *)&long long v21 = v20;
  re::DynamicArray<float>::insert((void *)this + 7, v12, &v21);
  re::TimelineEventData::addEvent(this, v12);
  *(unsigned char *)a5 = 1;
  *(void *)(a5 + 8) = v12;
}

void *re::DynamicArray<float>::insert(void *this, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = this[2];
  if (v4 + 1 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v6 = this;
  if (v4 >= this[1])
  {
    this = re::DynamicArray<float>::growCapacity(this, v4 + 1);
    unint64_t v4 = v6[2];
  }
  uint64_t v7 = v6[4];
  unint64_t v8 = (_DWORD *)(v7 + 4 * v4);
  if (v4 <= a2)
  {
    _DWORD *v8 = *a3;
  }
  else
  {
    _DWORD *v8 = *(v8 - 1);
    uint64_t v9 = v7 + 4 * a2;
    if (v8 - 1 != (_DWORD *)v9)
    {
      this = memmove((void *)(v9 + 4), (const void *)v9, (size_t)v8 - v9 - 4);
      uint64_t v7 = v6[4];
      unint64_t v4 = v6[2];
    }
    *(_DWORD *)(v7 + 4 * a2) = *a3;
  }
  v6[2] = v4 + 1;
  ++*((_DWORD *)v6 + 6);
  return this;
}

double re::TimelineEventData::totalDuration(re::TimelineEventData *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    float v2 = *(float *)(*((void *)this + 6) + 4 * v1 - 4)
  }
       + *(float *)(*((void *)this + 11) + 4 * *((void *)this + 9) - 4);
  else {
    float v2 = 0.0;
  }
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 16) + 4 * v3;
    if (v2 < *(float *)(v4 - 4)) {
      return *(float *)(v4 - 4);
    }
  }
  return v2;
}

uint64_t re::TimelineEventData::parameterName(re::TimelineEventData *this, unint64_t a2)
{
  if (*((unsigned int *)this + 41) <= a2) {
    return 0;
  }
  uint64_t v2 = *((unsigned int *)this + 42);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)*((void *)this + 19);
    while (1)
    {
      int v5 = *v4;
      v4 += 10;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 42);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 == v3) {
    return 0;
  }
  if (a2)
  {
    uint64_t v7 = 0;
    while (1)
    {
      ++v7;
      int v8 = v2 <= (int)v3 + 1 ? v3 + 1 : *((_DWORD *)this + 42);
      int v9 = v3;
      while (1)
      {
        unsigned int v10 = v9 + 1;
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v10;
        if ((*(_DWORD *)(*((void *)this + 19) + 40 * v10) & 0x80000000) != 0) {
          goto LABEL_20;
        }
      }
      LODWORD(v3) = v8;
LABEL_20:
      if (v2 == v3) {
        return 0;
      }
      if (v7 == a2) {
        return *(void *)(*((void *)this + 19) + 40 * v10 + 16);
      }
    }
  }
  unsigned int v10 = v3;
  return *(void *)(*((void *)this + 19) + 40 * v10 + 16);
}

uint64_t re::EventTimeline::createInstance(re::EventTimeline *this, re::Allocator *a2, const re::BindNode *a3, const re::internal::TimelineTree *a4, uint64_t a5)
{
  switch(*(unsigned char *)(*((void *)this + 10) + 496))
  {
    case 0xFF:
    case 0:
    case 8:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C3090;
      goto LABEL_10;
    case 1:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C31C0;
      goto LABEL_10;
    case 2:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C3258;
      goto LABEL_10;
    case 3:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C32F0;
      goto LABEL_10;
    case 4:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C3388;
      goto LABEL_10;
    case 5:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C3420;
      goto LABEL_10;
    case 6:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C3128;
      goto LABEL_10;
    case 7:
      uint64_t v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 184, 8);
      uint64_t v9 = re::Timeline::Timeline(v5, 49);
      *(unsigned char *)(v9 + 72) = 0;
      unsigned int v10 = &unk_26E6C34B8;
LABEL_10:
      *(void *)uint64_t v9 = v10;
      *(unsigned char *)(v9 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
      *(void *)(v9 + 96) = 0;
      *(unsigned char *)(v9 + 104) = 0;
      *(unsigned char *)(v9 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 0;
      *(void *)(v9 + 128) = a4;
      *(void *)(v9 + 136) = this;
      *(void *)(v9 + 144) = a5;
      *(unsigned char *)(v9 + 152) = 0;
      *(unsigned char *)(v5 + 168) = 0;
      re::DynamicString::operator=((re::DynamicString *)(v5 + 40), (re::EventTimeline *)((char *)this + 40));
      *(unsigned char *)(v5 + 72) = *((unsigned char *)this + 72);
      *(_DWORD *)(v5 + 12) = *((_DWORD *)this + 3);
      *(unsigned char *)(v5 + 16) = *((unsigned char *)this + 16);
      re::StringID::operator=((unint64_t *)(v5 + 24), (uint64_t *)this + 3);
      break;
    default:
      return v5;
  }
  return v5;
}

uint64_t re::TypedEventTimelineInstance<float>::initAnimationState(uint64_t a1, uint64_t a2, long long *a3, unint64_t a4, double *a5, char a6)
{
  if (a3)
  {
    long long v11 = *a3;
    long long v12 = a3[1];
    long long v13 = a3[2];
    *(_OWORD *)(a2 + 41) = *(long long *)((char *)a3 + 41);
    *(_OWORD *)(a2 + 16) = v12;
    *(_OWORD *)(a2 + 32) = v13;
    *(_OWORD *)a2 = v11;
  }
  float v14 = re::TypedEventTimelineInstance<float>::rootAnimationTime(*(void *)(a1 + 128)) - *(double *)(a1 + 96);
  *(float *)(a2 + 4) = v14;
  unint64_t v15 = *(void **)(*(void *)(a1 + 136) + 80);
  unint64_t v16 = v15[7];
  BOOL v17 = a4 >= v16;
  unint64_t v18 = a4 - v16;
  if (!v17)
  {
    unint64_t v19 = v15 + 9;
    unint64_t v18 = a4;
LABEL_7:
    float v20 = *(float *)(*v19 + 4 * v18);
    goto LABEL_9;
  }
  if (v18 < v15[17])
  {
    unint64_t v19 = v15 + 19;
    goto LABEL_7;
  }
  float v20 = NAN;
LABEL_9:
  unint64_t v21 = v15[12];
  BOOL v17 = a4 >= v21;
  unint64_t v22 = a4 - v21;
  if (v17)
  {
    if (v22 >= v15[17]) {
      float v23 = NAN;
    }
    else {
      float v23 = 0.0;
    }
  }
  else
  {
    float v23 = *(float *)(v15[14] + 4 * a4);
  }
  char v24 = *(unsigned char *)a5;
  if (*(unsigned char *)a5)
  {
    double v25 = (a5[1] - v20) / v23;
    if (v25 > 1.0) {
      double v25 = 1.0;
    }
    if (v25 < 0.0) {
      double v25 = 0.0;
    }
    float v26 = v25;
  }
  else
  {
    float v26 = -1.0;
  }
  *(float *)(a2 + 8) = v26;
  *(unsigned char *)(a2 + 1) = 0;
  *(unsigned char *)(a2 + 2) = v24;
  uint64_t result = re::TypedEventTimelineInstance<float>::compositionChain(a1);
  if (result) {
    *(void *)(a2 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = result + 8;
  }
  *(unsigned char *)(a2 + 56) = a6;
  *(float *)(a2 + 48) = v20;
  *(float *)(a2 + 52) = v23;
  return result;
}

double re::TypedEventTimelineInstance<float>::rootAnimationTime(uint64_t a1)
{
  if (!*(void *)(a1 + 56))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(double *)(*(void *)(a1 + 64) + 8);
}

void re::TypedEventTimelineInstance<float>::raiseSkippedEvents(uint64_t a1, uint64_t a2, long long *a3, double a4, double a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v43 = a3;
  if (a4 != a5 && vabdd_f64(a4, a5) >= (fabs(a4) + fabs(a5) + 1.0) * 1.0e-12)
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 136) + 80);
    v40[0] = v9 + 24;
    v40[1] = &v42;
    v40[2] = &v41;
    float32x4_t v40[3] = a1;
    v40[4] = &v43;
    v40[5] = a2;
    if (a5 <= a4)
    {
      if (a5 < a4 && *(unsigned char *)(v9 + 536))
      {
        double v41 = a4;
        double v42 = a5;
        if ((int)*(void *)(v9 + 56) >= 1)
        {
          unint64_t v13 = *(void *)(v9 + 56) + 1;
          do
          {
            re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()((uint64_t)v40, (v13 - 2), 1, *(void *)(v9 + 56) - 1 == v13 - 2);
            --v13;
          }
          while (v13 > 1);
        }
        int v14 = *(unsigned __int8 *)(a1 + 168);
        if (*(unsigned char *)(a1 + 168))
        {
          uint64_t v5 = *(void *)(a1 + 176);
          *(unsigned char *)(a1 + 168) = 0;
        }
        if (*(unsigned char *)(a1 + 152)) {
          *(unsigned char *)(a1 + 152) = 0;
        }
        if ((int)*(void *)(v9 + 136) >= 1)
        {
          uint64_t v26 = *(void *)(v9 + 136) + 1;
          while (1)
          {
            unint64_t v27 = (v26 - 2);
            unint64_t v28 = *(void *)(v9 + 136);
            if (v28 <= v27)
            {
              *(void *)uint64_t v49 = 0;
              long long v59 = 0u;
              long long v60 = 0u;
              long long v57 = 0u;
              long long v58 = 0u;
              long long v56 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v45 = 136315906;
              size_t v46 = "operator[]";
              __int16 v47 = 1024;
              LODWORD(v48[0]) = 797;
              WORD2(v48[0]) = 2048;
              *(void *)((char *)v48 + 6) = (v26 - 2);
              HIWORD(v48[1]) = 2048;
              _OWORD v48[2] = v28;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_67:
              uint64_t v44 = 0;
              long long v59 = 0u;
              long long v60 = 0u;
              long long v57 = 0u;
              long long v58 = 0u;
              long long v56 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)uint64_t v49 = 136315906;
              *(void *)&v49[4] = "operator[]";
              __int16 v50 = 1024;
              int v51 = 476;
              __int16 v52 = 2048;
              uint64_t v53 = 0;
              __int16 v54 = 2048;
              uint64_t v55 = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_68:
              uint64_t v44 = 0;
              long long v59 = 0u;
              long long v60 = 0u;
              long long v57 = 0u;
              long long v58 = 0u;
              long long v56 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)uint64_t v49 = 136315906;
              *(void *)&v49[4] = "operator[]";
              __int16 v50 = 1024;
              int v51 = 476;
              __int16 v52 = 2048;
              uint64_t v53 = 0;
              __int16 v54 = 2048;
              uint64_t v55 = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            float v29 = *(float *)(*(void *)(v9 + 152) + 4 * v27);
            float v30 = v42;
            if (v29 <= v30) {
              break;
            }
            float v31 = fabsf(v29);
            if (vabds_f32(v29, v30) < (float)((float)((float)(v31 + fabsf(v30)) + 1.0) * 0.00001)) {
              break;
            }
            if (v42 < v29)
            {
              if (v41 > v29
                || v14
                && v5 == v27
                && ((float v32 = v41, v29 == v32)
                 || vabds_f32(v29, v32) < (float)((float)((float)(v31 + fabsf(v32)) + 1.0) * 0.00001)))
              {
                LOWORD(v45) = 255;
                BYTE2(v45) = 0;
                size_t v46 = 0;
                memset((char *)v48 + 2, 0, 41);
                unint64_t v33 = *(void *)(v9 + 56) + v27;
                LOBYTE(v38[0]) = 0;
                re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v45, v43, v33, v38, 1);
                id WeakRetained = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
                unint64_t v35 = *(void **)(a1 + 128);
                if (!v35[7]) {
                  goto LABEL_68;
                }
                if (WeakRetained) {
                  uint64_t v36 = WeakRetained - 8;
                }
                else {
                  uint64_t v36 = 0;
                }
                unint64_t v37 = v36 + 8;
                (*(void (**)(char *, uint64_t, void, uint64_t, void, unint64_t, uint64_t, int *, double))(*(void *)v36 + 40))(v36, 10, v35[21], a2, *(void *)(a1 + 136), v33, a1, &v45, *(double *)(v35[8] + 8));
              }
            }
            if ((unint64_t)--v26 <= 1) {
              return;
            }
          }
          if (v29 == v30 || vabds_f32(v29, v30) < (float)((float)((float)(fabsf(v29) + fabsf(v30)) + 1.0) * 0.00001))
          {
            if (!*(unsigned char *)(a1 + 168)) {
              *(unsigned char *)(a1 + 168) = 1;
            }
            *(void *)(a1 + 176) = v27;
          }
        }
      }
    }
    else
    {
      double v41 = a5;
      double v42 = a4;
      unint64_t v10 = *(void *)(v9 + 56);
      if (v10)
      {
        for (unint64_t i = 0; i < v10; ++i)
        {
          re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()((uint64_t)v40, i, 0, i == v10 - 1);
          unint64_t v10 = *(void *)(v9 + 56);
        }
      }
      int v12 = *(unsigned __int8 *)(a1 + 152);
      if (*(unsigned char *)(a1 + 152))
      {
        uint64_t v6 = *(void *)(a1 + 160);
        *(unsigned char *)(a1 + 152) = 0;
      }
      if (*(unsigned char *)(a1 + 168)) {
        *(unsigned char *)(a1 + 168) = 0;
      }
      unint64_t v15 = *(void *)(v9 + 136);
      if (v15)
      {
        uint64_t v16 = 0;
        while (1)
        {
          float v17 = *(float *)(*(void *)(v9 + 152) + 4 * v16);
          float v18 = v41;
          if (v17 >= v18) {
            break;
          }
          float v19 = fabsf(v17);
          if (vabds_f32(v17, v18) < (float)((float)((float)(v19 + fabsf(v18)) + 1.0) * 0.00001)) {
            break;
          }
          if (v41 > v17)
          {
            if (v42 < v17
              || v12
              && v6 == v16
              && ((float v20 = v42, v17 == v20)
               || vabds_f32(v17, v20) < (float)((float)((float)(v19 + fabsf(v20)) + 1.0) * 0.00001)))
            {
              LOWORD(v45) = 255;
              BYTE2(v45) = 0;
              size_t v46 = 0;
              memset((char *)v48 + 2, 0, 41);
              unint64_t v21 = v16 + *(void *)(v9 + 56);
              LOBYTE(v39[0]) = 0;
              re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v45, v43, v21, v39, 0);
              unint64_t v22 = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
              float v23 = *(void **)(a1 + 128);
              if (!v23[7]) {
                goto LABEL_67;
              }
              if (v22) {
                char v24 = v22 - 8;
              }
              else {
                char v24 = 0;
              }
              double v25 = v24 + 8;
              (*(void (**)(char *, uint64_t, void, uint64_t, void, unint64_t, uint64_t, int *, double))(*(void *)v24 + 40))(v24, 10, v23[21], a2, *(void *)(a1 + 136), v21, a1, &v45, *(double *)(v23[8] + 8));

              unint64_t v15 = *(void *)(v9 + 136);
            }
          }
          if (++v16 >= v15) {
            return;
          }
        }
        if (v17 == v18 || vabds_f32(v17, v18) < (float)((float)((float)(fabsf(v17) + fabsf(v18)) + 1.0) * 0.00001))
        {
          if (!*(unsigned char *)(a1 + 152)) {
            *(unsigned char *)(a1 + 152) = 1;
          }
          *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v16;
        }
      }
    }
  }
}

void re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()(uint64_t a1, unint64_t a2, char a3, int a4)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void **)a1;
  unint64_t v6 = *(void *)(*(void *)a1 + 32);
  if (v6 <= a2)
  {
    *(void *)char v24 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v20 = 136315906;
    unint64_t v21 = "operator[]";
    __int16 v22 = 1024;
    LODWORD(v23[0]) = 797;
    WORD2(v23[0]) = 2048;
    *(void *)((char *)v23 + 6) = a2;
    HIWORD(v23[1]) = 2048;
    v23[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    *(void *)char v24 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v20 = 136315906;
    unint64_t v21 = "operator[]";
    __int16 v22 = 1024;
    LODWORD(v23[0]) = 797;
    WORD2(v23[0]) = 2048;
    *(void *)((char *)v23 + 6) = a2;
    HIWORD(v23[1]) = 2048;
    v23[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_17;
  }
  float v8 = *(float *)(v5[6] + 4 * a2);
  if (**(double **)(a1 + 8) >= v8) {
    return;
  }
  unint64_t v6 = v5[9];
  if (v6 <= a2) {
    goto LABEL_16;
  }
  uint64_t v10 = *(void *)(a1 + 24);
  float v11 = v8 + *(float *)(v5[11] + 4 * a2);
  if (a4)
  {
    if (**(double **)(a1 + 16) <= v11) {
      return;
    }
  }
  else
  {
    float v12 = **(double **)(a1 + 16);
    if (v11 > v12 && vabds_f32(v11, v12) >= (float)((float)((float)(fabsf(v11) + fabsf(v12)) + 1.0) * 0.00001)) {
      return;
    }
  }
  LOWORD(v20) = 255;
  BYTE2(v20) = 0;
  unint64_t v21 = 0;
  memset((char *)v23 + 2, 0, 41);
  unint64_t v13 = **(long long ***)(a1 + 32);
  LOBYTE(v19[0]) = 0;
  re::TypedEventTimelineInstance<float>::initAnimationState(v10, (uint64_t)&v20, v13, a2, v19, a3);
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(*(void *)(v10 + 128) + 176));
  unint64_t v15 = *(void **)(v10 + 128);
  if (!v15[7])
  {
LABEL_17:
    _OWORD v19[2] = 0.0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v31 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v24 = 136315906;
    *(void *)&v24[4] = "operator[]";
    __int16 v25 = 1024;
    int v26 = 476;
    __int16 v27 = 2048;
    uint64_t v28 = 0;
    __int16 v29 = 2048;
    uint64_t v30 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (WeakRetained) {
    float v17 = WeakRetained - 8;
  }
  else {
    float v17 = 0;
  }
  float v18 = v17 + 8;
  (*(void (**)(char *, uint64_t, void, uint64_t, void, unint64_t, uint64_t, int *, double))(*(void *)v17 + 40))(v17, 10, v15[21], v16, *(void *)(v10 + 136), a2, v10, &v20, *(double *)(v15[8] + 8));
}

void re::TypedEventTimelineInstance<float>::timelineRemoved(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  __int16 v21 = 255;
  char v22 = 0;
  int v23 = 0;
  int v24 = 0;
  long long v25 = 0u;
  memset(v26, 0, 25);
  uint64_t v2 = re::TypedEventTimelineInstance<float>::compositionChain(a1);
  if (v2) {
    v26[1] = v2 + 8;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void *)(a1 + 88);
    LOBYTE(v20[0]) = 0;
    re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v21, 0, v3, v20, 0);
    id WeakRetained = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
    uint64_t v5 = *(void **)(a1 + 128);
    unint64_t v6 = *(void *)(a1 + 144);
    unint64_t v7 = v5[7];
    if (v7 <= v6) {
      goto LABEL_16;
    }
    uint64_t v8 = v5[21];
    if (WeakRetained) {
      uint64_t v9 = WeakRetained - 8;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = v5[8];
    uint64_t v11 = v10 + 72 * v6;
    float v12 = v9 + 8;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, __int16 *, double))(*(void *)v9 + 40))(v9, 7, v8, v11, *(void *)(a1 + 136), *(void *)(a1 + 88), a1, &v21, *(double *)(v10 + 8));

    if (*(unsigned char *)(a1 + 80)) {
      *(unsigned char *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
    }
  }
  unint64_t v13 = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  int v14 = *(void **)(a1 + 128);
  unint64_t v6 = *(void *)(a1 + 144);
  unint64_t v7 = v14[7];
  if (v7 <= v6)
  {
    uint64_t v27 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v28 = 136315906;
    __int16 v29 = "operator[]";
    __int16 v30 = 1024;
    int v31 = 476;
    __int16 v32 = 2048;
    unint64_t v33 = v6;
    __int16 v34 = 2048;
    unint64_t v35 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    uint64_t v27 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v28 = 136315906;
    __int16 v29 = "operator[]";
    __int16 v30 = 1024;
    int v31 = 476;
    __int16 v32 = 2048;
    unint64_t v33 = v6;
    __int16 v34 = 2048;
    unint64_t v35 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v15 = v14[21];
  if (v13) {
    uint64_t v16 = v13 - 8;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = v14[8];
  uint64_t v18 = v17 + 72 * v6;
  float v19 = v16 + 8;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, double))(*(void *)v16 + 40))(v16, 11, v15, v18, *(void *)(a1 + 136), -1, a1, &v21, *(double *)(v17 + 8));
}

void re::TypedEventTimelineInstance<float>::processEvents(uint64_t a1, long long *a2, long long *a3)
{
  uint64_t v12 = (uint64_t)&v110;
  uint64_t v120 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a2 + 16))
  {
    if (*(unsigned char *)(a1 + 80))
    {
      LOWORD(v110) = 255;
      BYTE2(v110) = 0;
      *(void *)((char *)&v110 + 4) = 0;
      long long v111 = 0u;
      memset(v112, 0, 25);
      unint64_t v26 = *(void *)(a1 + 88);
      LOBYTE(v99[0]) = 0;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v26, v99, 0);
      id WeakRetained = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
      uint64_t v28 = WeakRetained ? (uint64_t)(WeakRetained - 8) : 0;
      uint64_t v29 = *(void *)(a1 + 128);
      uint64_t v30 = *(void *)(v29 + 168);
      double v31 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v29);
      (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, void, void, uint64_t, long long *, double))(*(void *)v28 + 40))(v28, 7, v30, a2, *(void *)(a1 + 136), *(void *)(a1 + 88), a1, &v110, v31);

      if (*(unsigned char *)(a1 + 80)) {
        goto LABEL_94;
      }
    }
    goto LABEL_114;
  }
  uint64_t v13 = *(void *)(*(void *)(a1 + 136) + 80);
  double v14 = *((double *)a2 + 3);
  if (!*(unsigned char *)(a1 + 104))
  {
    char v32 = *((float *)a2 + 9) < 0.0;
    goto LABEL_59;
  }
  uint64_t v15 = *(void **)(a1 + 128);
  unint64_t v3 = *(void *)(a1 + 144);
  unint64_t v16 = v15[7];
  if (v16 <= v3) {
    goto LABEL_119;
  }
  unint64_t v16 = v15[4];
  if (v16 <= v3)
  {
LABEL_120:
    v105[0] = 0;
    long long v113 = 0u;
    long long v111 = 0u;
    memset(v112, 0, sizeof(v112));
    long long v110 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v117) = 136315906;
    *(void *)(v12 + 1re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = "operator[]";
    WORD6(v117) = 1024;
    *(_DWORD *)(v12 + 190) = 476;
    WORD1(v118) = 2048;
    *(void *)(v12 + 196) = v3;
    WORD6(v118) = 2048;
    *(void *)(v12 + 206) = v16;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_121:
    uint64_t v109 = 0;
    long long v118 = 0u;
    memset(v119, 0, sizeof(v119));
    long long v117 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v114 = 136315906;
    *(void *)(v12 + 132) = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)(v12 + 142) = 476;
    *(_WORD *)&v114[18] = 2048;
    *(void *)(v12 + 148) = v16;
    __int16 v115 = 2048;
    *(void *)(v12 + 158) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_122;
  }
  double v17 = *(double *)(a1 + 112);
  uint64_t v18 = v15[8];
  int v19 = *(unsigned __int8 *)(v18 + 72 * v3 + 56);
  if (*(_DWORD *)(v18 + 72 * v3 + 48) != *(_DWORD *)(v18 + 72 * v3 + 52))
  {
    uint64_t v33 = v15[5] + 28 * v3;
    double v8 = *(float *)(v33 + 12);
    double v7 = *(float *)(v33 + 16);
    goto LABEL_44;
  }
  re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)&v110);
  uint64_t v108 = 0;
  v105[1] = 0;
  uint64_t v106 = 0;
  int v107 = 0;
  v105[0] = &v110;
  re::DynamicArray<int>::setCapacity(v105, 0);
  ++v107;
  LODWORD(v117) = *(void *)(a1 + 144);
  re::DynamicArray<int>::add(v105, &v117);
  uint64_t v20 = *(void *)(a1 + 128);
  do
  {
    uint64_t v21 = v20;
    uint64_t v20 = *(void *)(v20 + 200);
  }
  while (v20);
  v22.n128_f64[0] = CMTimebaseGetRate(*(CMTimebaseRef *)(v21 + 192));
  int v23 = *(void **)(a1 + 128);
  unint64_t v16 = *(void *)(a1 + 144);
  unint64_t v3 = v23[1];
  if (v3 <= v16) {
    goto LABEL_121;
  }
  unint64_t v3 = *(unsigned int *)(v23[2] + 4 * v16);
  int v104 = v3;
  if ((v3 & 0x80000000) != 0)
  {
    unint64_t v3 = 0;
    goto LABEL_40;
  }
  uint64_t v77 = v13;
  float v6 = v22.n128_f64[0];
  unint64_t v16 = 72;
  while (1)
  {
    unint64_t v24 = v23[7];
    if (v24 <= v3)
    {
      uint64_t v109 = 0;
      long long v118 = 0u;
      memset(v119, 0, sizeof(v119));
      long long v117 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v114 = 136315906;
      *(void *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(void *)&v114[20] = v3;
      __int16 v115 = 2048;
      unint64_t v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_116:
      uint64_t v109 = 0;
      long long v118 = 0u;
      memset(v119, 0, sizeof(v119));
      long long v117 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v114 = 136315906;
      *(void *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(void *)&v114[20] = v3;
      __int16 v115 = 2048;
      unint64_t v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_117:
      uint64_t v109 = 0;
      long long v118 = 0u;
      memset(v119, 0, sizeof(v119));
      long long v117 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v114 = 136315906;
      *(void *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(void *)&v114[20] = v3;
      __int16 v115 = 2048;
      unint64_t v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_118:
      uint64_t v109 = 0;
      long long v118 = 0u;
      memset(v119, 0, sizeof(v119));
      long long v117 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v114 = 136315906;
      *(void *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(void *)&v114[20] = v4;
      __int16 v115 = 2048;
      unint64_t v116 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_119:
      v105[0] = 0;
      long long v113 = 0u;
      long long v111 = 0u;
      memset(v112, 0, sizeof(v112));
      long long v110 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v117) = 136315906;
      *(void *)(v12 + 1re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = "operator[]";
      WORD6(v117) = 1024;
      *(_DWORD *)(v12 + 190) = 476;
      WORD1(v118) = 2048;
      *(void *)(v12 + 196) = v3;
      WORD6(v118) = 2048;
      *(void *)(v12 + 206) = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_120;
    }
    unint64_t v24 = v23[4];
    if (v24 <= v3) {
      goto LABEL_116;
    }
    uint64_t v25 = v23[8] + 72 * v3;
    v19 ^= *(unsigned __int8 *)(v25 + 56);
    if (*(_DWORD *)(v25 + 48) != *(_DWORD *)(v25 + 52)) {
      break;
    }
    re::DynamicArray<int>::add(v105, &v104);
    int v23 = *(void **)(a1 + 128);
    unint64_t v3 = v104;
    unint64_t v24 = v23[1];
    if (v24 <= v104) {
      goto LABEL_117;
    }
    unint64_t v3 = *(unsigned int *)(v23[2] + 4 * v104);
    int v104 = v3;
    if ((v3 & 0x80000000) != 0)
    {
      unint64_t v3 = 0;
      goto LABEL_39;
    }
  }
  uint64_t v34 = v23[5] + 28 * v3;
  v22.n128_u32[0] = *(_DWORD *)(v34 + 12);
  double v8 = v22.n128_f32[0];
  double v7 = *(float *)(v34 + 16);
  uint64_t v35 = v106;
  unint64_t v3 = 1;
  if (v106)
  {
    unint64_t v16 = 1;
    uint64_t v12 = 1;
    do
    {
      uint64_t v36 = v35 - 1;
      unint64_t v4 = *(int *)(v108 + 4 * v36);
      uint64_t v37 = *(void *)(a1 + 128);
      unint64_t v5 = *(void *)(v37 + 32);
      if (v5 <= v4) {
        goto LABEL_118;
      }
      long long v38 = (long long *)(*(void *)(v37 + 40) + 28 * (int)v4);
      long long v39 = *v38;
      *(_OWORD *)&v114[12] = *(long long *)((char *)v38 + 12);
      *(_OWORD *)unint64_t v114 = v39;
      v114[25] = 3;
      uint64_t v106 = v36;
      ++v107;
      LOBYTE(v117) = 1;
      *((void *)&v117 + 1) = 0;
      LOBYTE(v118) = 0;
      LOBYTE(v119[0]) = 0;
      *(void *)((char *)&v119[1] + 12) = 0x200000000;
      *(void *)((char *)v119 + 4) = 0;
      *(void *)((char *)v119 + 12) = 0;
      *(void *)((char *)&v119[1] + 1) = 0;
      v102[0] = v16;
      if (!v16) {
        goto LABEL_124;
      }
      double v103 = v8;
      re::AnimationClock::update((char *)&v117, (uint64_t)v102, (uint64_t)v114, v6);
      v100[0] = v12;
      if (!v12) {
        goto LABEL_125;
      }
      if ((_BYTE)v118)
      {
        double v8 = *((double *)&v118 + 1);
        unint64_t v16 = v16;
      }
      else
      {
        unint64_t v16 = 0;
      }
      double v101 = v7;
      re::AnimationClock::update((char *)&v117, (uint64_t)v100, (uint64_t)v114, v6);
      v22.n128_u64[0] = *((void *)&v118 + 1);
      if ((_BYTE)v118)
      {
        double v7 = *((double *)&v118 + 1);
        uint64_t v12 = v12;
      }
      else
      {
        uint64_t v12 = 0;
      }
      uint64_t v35 = v106;
    }
    while (v106);
    unint64_t v3 = 1;
    uint64_t v12 = (uint64_t)&v110;
  }
LABEL_39:
  uint64_t v13 = v77;
LABEL_40:
  if (v105[0] && v108) {
    (*(void (**)(__n128))(*(void *)v105[0] + 40))(v22);
  }
  re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)&v110);
  if (v3)
  {
LABEL_44:
    if (v19)
    {
      long long v87 = *a2;
      if (*((unsigned char *)a2 + 16)) {
        uint64_t v89 = *((void *)a2 + 3);
      }
      long long v40 = a2[3];
      long long v90 = a2[2];
      long long v91 = v40;
      int v92 = *((_DWORD *)a2 + 16);
      re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v87, a3, v17, v8 + -0.00100000005);
      double v17 = v7 + 0.00100000005;
    }
    else
    {
      long long v93 = *a2;
      if (*((unsigned char *)a2 + 16)) {
        uint64_t v95 = *((void *)a2 + 3);
      }
      long long v41 = a2[3];
      long long v96 = a2[2];
      long long v97 = v41;
      int v98 = *((_DWORD *)a2 + 16);
      re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v93, a3, v17, v7 + 0.00100000005);
      double v17 = v8 + -0.00100000005;
    }
  }
  long long v81 = *a2;
  if (*((unsigned char *)a2 + 16)) {
    uint64_t v83 = *((void *)a2 + 3);
  }
  long long v42 = a2[3];
  long long v84 = a2[2];
  long long v85 = v42;
  int v86 = *((_DWORD *)a2 + 16);
  re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v81, a3, v17, v14);
  if (*((float *)a2 + 9) >= 0.0)
  {
    if (!*(unsigned char *)(a1 + 104))
    {
      char v32 = 0;
      goto LABEL_59;
    }
    char v32 = v14 < *(double *)(a1 + 112);
  }
  else
  {
    char v32 = 1;
    if (!*(unsigned char *)(a1 + 104)) {
LABEL_59:
    }
      *(unsigned char *)(a1 + 104) = 1;
  }
  *(double *)(a1 + 112) = v14;
  if (*(unsigned char *)(v13 + 536) || (v32 & 1) == 0)
  {
    float v43 = v14;
    uint64_t v44 = *(void *)(v13 + 72);
    unint64_t v16 = *(void *)(v13 + 56);
    if (v16)
    {
      int v45 = *(float **)(v13 + 72);
      unint64_t v46 = *(void *)(v13 + 56);
      do
      {
        unint64_t v47 = v46 >> 1;
        int v48 = &v45[v46 >> 1];
        float v50 = *v48;
        uint64_t v49 = v48 + 1;
        v46 += ~(v46 >> 1);
        if (v43 + 0.00416666667 > v50) {
          int v45 = v49;
        }
        else {
          unint64_t v46 = v47;
        }
      }
      while (v46);
    }
    else
    {
      int v45 = *(float **)(v13 + 72);
    }
    uint64_t v51 = (uint64_t)v45 - v44;
    if (v51)
    {
      unint64_t v3 = (v51 >> 2) - 1;
      if (v16 > v3)
      {
        unint64_t v16 = *(void *)(v13 + 96);
        if (v16 > v3)
        {
          float v52 = *(float *)(v44 + 4 * v3) + *(float *)(*(void *)(v13 + 112) + 4 * v3);
          if (v52 <= v43 || vabds_f32(v43, v52) < (float)((float)((float)(fabsf(v43) + fabsf(v52)) + 1.0) * 0.00001)) {
            goto LABEL_75;
          }
          char v54 = 0;
LABEL_78:
          int v55 = 1;
          goto LABEL_79;
        }
LABEL_123:
        v105[0] = 0;
        long long v113 = 0u;
        long long v111 = 0u;
        memset(v112, 0, sizeof(v112));
        long long v110 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v117) = 136315906;
        *(void *)(v12 + 1re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = "operator[]";
        WORD6(v117) = 1024;
        *(_DWORD *)(v12 + 190) = 797;
        WORD1(v118) = 2048;
        *(void *)(v12 + 196) = v3;
        WORD6(v118) = 2048;
        *(void *)(v12 + 206) = v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_124:
        re::AnimationClock::update((char *)&v117, (uint64_t)v102, (uint64_t)v114, v6);
        re::internal::assertLog((re::internal *)4, v75, "assertion failure: '%s' (%s:line %i) ", "loopStart.hasValue()", "didLoop", 466);
        _os_crash();
        __break(1u);
LABEL_125:
        re::AnimationClock::update((char *)&v117, (uint64_t)v100, (uint64_t)v114, v6);
        re::internal::assertLog((re::internal *)4, v76, "assertion failure: '%s' (%s:line %i) ", "loopEnd.hasValue()", "didLoop", 469);
        _os_crash();
        __break(1u);
      }
LABEL_122:
      v105[0] = 0;
      long long v113 = 0u;
      long long v111 = 0u;
      memset(v112, 0, sizeof(v112));
      long long v110 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v117) = 136315906;
      *(void *)(v12 + 1re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = "operator[]";
      WORD6(v117) = 1024;
      *(_DWORD *)(v12 + 190) = 797;
      WORD1(v118) = 2048;
      *(void *)(v12 + 196) = v3;
      WORD6(v118) = 2048;
      *(void *)(v12 + 206) = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_123;
    }
LABEL_75:
    float v53 = re::TimelineEventData::totalDuration((re::TimelineEventData *)(v13 + 24));
    if (v53 == v43 || vabds_f32(v53, v43) < (float)((float)((float)(fabsf(v43) + fabsf(v53)) + 1.0) * 0.00001))
    {
      char v54 = 0;
      unint64_t v3 = *(void *)(v13 + 56) - 1;
      goto LABEL_78;
    }
    int v55 = 0;
    char v54 = 1;
LABEL_79:
    LOWORD(v110) = 255;
    BYTE2(v110) = 0;
    *(void *)((char *)&v110 + 4) = 0;
    long long v111 = 0u;
    memset(v112, 0, 25);
    int v56 = *(unsigned __int8 *)(a1 + 80);
    if ((v54 & 1) == 0 && *(unsigned char *)(a1 + 80))
    {
      unint64_t v57 = *(void *)(a1 + 88);
      if (v3 == v57)
      {
LABEL_110:
        LOBYTE(v78[0]) = 1;
        v78[1] = v14;
        re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v3, v78, v32);
        uint64_t v70 = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
        if (v70) {
          uint64_t v71 = v70 - 8;
        }
        else {
          uint64_t v71 = 0;
        }
        uint64_t v72 = *(void *)(a1 + 128);
        uint64_t v73 = *(void *)(v72 + 168);
        double v74 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v72);
        (*(void (**)(char *, uint64_t, uint64_t, long long *, void, void, uint64_t, long long *, double))(*(void *)v71 + 40))(v71, 6, v73, a2, *(void *)(a1 + 136), *(void *)(a1 + 88), a1, &v110, v74);

        goto LABEL_114;
      }
LABEL_86:
      LOBYTE(v80[0]) = 1;
      v80[1] = v14;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v57, v80, v32);
      long long v58 = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
      if (v58) {
        long long v59 = v58 - 8;
      }
      else {
        long long v59 = 0;
      }
      uint64_t v60 = *(void *)(a1 + 128);
      uint64_t v61 = *(void *)(v60 + 168);
      double v62 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v60);
      (*(void (**)(char *, uint64_t, uint64_t, long long *, void, void, uint64_t, long long *, double))(*(void *)v59 + 40))(v59, 7, v61, a2, *(void *)(a1 + 136), *(void *)(a1 + 88), a1, &v110, v62);

      int v56 = *(unsigned __int8 *)(a1 + 80);
      goto LABEL_90;
    }
    if (v56 | v55)
    {
      if (*(unsigned char *)(a1 + 80))
      {
        unint64_t v57 = *(void *)(a1 + 88);
        goto LABEL_86;
      }
LABEL_90:
      if (!(v56 | v55)) {
        goto LABEL_114;
      }
      char v63 = v54 ^ 1;
      if (!v56) {
        char v63 = 1;
      }
      if ((v63 & 1) == 0)
      {
LABEL_94:
        *(unsigned char *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
        goto LABEL_114;
      }
      if (v56) {
        char v64 = 1;
      }
      else {
        char v64 = v54;
      }
      if (v64)
      {
        *(void *)(a1 + 88) = v3;
        if (v54) {
          goto LABEL_108;
        }
      }
      else
      {
        *(unsigned char *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 1;
        *(void *)(a1 + 88) = v3;
      }
      LOBYTE(v79[0]) = 1;
      v79[1] = v14;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v3, v79, v32);
      uint64_t v65 = (char *)objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
      if (v65) {
        uint64_t v66 = v65 - 8;
      }
      else {
        uint64_t v66 = 0;
      }
      uint64_t v67 = *(void *)(a1 + 128);
      uint64_t v68 = *(void *)(v67 + 168);
      double v69 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v67);
      (*(void (**)(char *, uint64_t, uint64_t, long long *, void, unint64_t, uint64_t, long long *, double))(*(void *)v66 + 40))(v66, 5, v68, a2, *(void *)(a1 + 136), v3, a1, &v110, v69);

      int v56 = *(unsigned __int8 *)(a1 + 80);
    }
LABEL_108:
    if (v56)
    {
      unint64_t v3 = *(void *)(a1 + 88);
      goto LABEL_110;
    }
  }
LABEL_114:
  *(double *)(a1 + 96) = re::TypedEventTimelineInstance<float>::rootAnimationTime(*(void *)(a1 + 128));
}

void re::EventTimeline::~EventTimeline(re::EventTimeline *this)
{
  *(void *)this = &unk_26E6C2FB0;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {

    *((void *)this + 10) = 0;
  }
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::EventTimeline *)((char *)this + 40));
  re::StringID::destroyString((re::EventTimeline *)((char *)this + 24));
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6C2FB0;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {

    *((void *)this + 10) = 0;
  }
  *(void *)this = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::EventTimeline *)((char *)this + 40));
  re::StringID::destroyString((re::EventTimeline *)((char *)this + 24));
  JUMPOUT(0x237DBCBD0);
}

double re::EventTimeline::totalDuration(re::EventTimeline *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1) {
    return re::TimelineEventData::totalDuration((re::TimelineEventData *)(v1 + 24));
  }
  else {
    return 0.0;
  }
}

void re::EventTimeline::evaluateCore(uint64_t a1, uint64_t a2)
{
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(uint64_t a1, void *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v3 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  while (!re::StringID::operator==((void *)(v5 + 40 * v4 + 8), a2))
  {
    uint64_t v4 = *(_DWORD *)(v5 + 40 * v4) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v5 + 40 * v4 + 24;
}

void re::SharedEventData::~SharedEventData(re::SharedEventData *this)
{
  re::SharedEventData::~SharedEventData(this);
  JUMPOUT(0x237DBCBD0);
}

{
  re::StringID *v2;

  *(void *)this = &unk_26E6C3048;
  uint64_t v2 = (re::SharedEventData *)((char *)this + 24);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 544);

  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 63);
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 456);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)this + 408);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 312);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 264);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 216);
  re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 20);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 120);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 80);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 40);
  re::StringID::destroyString(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

re::TimelineEventData *re::TimelineEventData::TimelineEventData(re::TimelineEventData *this, const re::TimelineEventData *a2)
{
  uint64_t v4 = re::StringID::StringID(this, (const StringID *)a2);
  re::DynamicArray<float>::DynamicArray((uint64_t)v4 + 16, (uint64_t *)a2 + 2);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 56, (uint64_t *)a2 + 7);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 96, (uint64_t *)a2 + 12);
  re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)this + 136, (uint64_t)a2 + 136);
  *((void *)this + 23) = *((void *)a2 + 23);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 192, (uint64_t *)a2 + 24);
  *((void *)this + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *((void *)a2 + 29);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 240, (uint64_t *)a2 + 30);
  *((void *)this + 35) = *((void *)a2 + 35);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)this + 288, (uint64_t *)a2 + 36);
  *((void *)this + 41) = *((void *)a2 + 41);
  re::DynamicArray<re::Vector4<float>>::DynamicArray((uint64_t)this + 336, (uint64_t *)a2 + 42);
  *((void *)this + 47) = *((void *)a2 + 47);
  re::DynamicArray<re::FixedArray<unsigned char>>::DynamicArray((uint64_t)this + 384, (uint64_t *)a2 + 48);
  *((void *)this + 53) = *((void *)a2 + 53);
  re::DynamicArray<re::ObjCObject>::DynamicArray((uint64_t)this + 432, (uint64_t *)a2 + 54);
  *((unsigned char *)this + 472) = *((unsigned char *)a2 + 472);
  re::FixedArray<unsigned char>::FixedArray((void *)this + 60, (uint64_t *)a2 + 60);
  *((void *)this + 63) = *((id *)a2 + 63);
  *((unsigned char *)this + 512) = *((unsigned char *)a2 + 512);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 520, (uint64_t *)a2 + 65);
  return this;
}

uint64_t re::DynamicArray<float>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<int>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  signed int v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    double v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    double v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      signed int v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    double v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        unint64_t v9 = 0xBF58476D1CE4E5B9 * ((*(void *)(v8 + v6 + 8) >> 31) ^ (*(void *)(v8 + v6 + 8) >> 1));
        unint64_t v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (_OWORD *)(v8 + v6 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 40;
    }
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 40;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v8;
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v15, 0, 36);
      *(void *)&v15[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v15, v4, a2);
      long long v5 = *(_OWORD *)v15;
      *(_OWORD *)uint64_t v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v15[16];
      *(void *)&v15[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v15[24];
      *(_OWORD *)&v15[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v15[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v15[16] + v10) & 0x80000000) != 0)
          {
            unint64_t v12 = 0xBF58476D1CE4E5B9
                * ((*(void *)(*(void *)&v15[16] + v10 + 8) >> 31) ^ (*(void *)(*(void *)&v15[16] + v10 + 8) >> 1));
            unint64_t v13 = (0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) ^ ((0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) >> 31);
            re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v13 % *(unsigned int *)(a1 + 24), v13, (StringID *)(*(void *)&v15[16] + v10 + 8));
            unsigned int v9 = *(_DWORD *)&v15[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v15);
    }
  }
  else
  {
    if (a2) {
      signed int v14 = a2;
    }
    else {
      signed int v14 = 3;
    }
  }
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 40 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 40 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 40 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 40 * v9 + 8), a4);
  *(_OWORD *)(*(void *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

double re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 8));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 40;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::DynamicArray<re::Vector4<float>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::Vector4<float>>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Vector4<float>>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<re::Vector4<float>>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Vector4<float>>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (void)v5);
      unint64_t v5 = v3[2];
    }
    double result = (void **)memcpy((char *)v3[4] + 16 * (void)v5, (const void *)(*(void *)(a2 + 32) + 16 * (void)v5), 16 * v4 - 16 * (void)v5);
  }
  else if (v4)
  {
    double result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::FixedArray<unsigned char>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::FixedArray<unsigned char>>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

void *re::DynamicArray<re::FixedArray<unsigned char>>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)a1, *(void *)(a2 + 16));
    double result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 24 * *(void *)(a1 + 16)), *(uint64_t **)(a1 + 32));
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9 != v4)
    {
      uint64_t v10 = 3 * v9;
      unint64_t v11 = (uint64_t *)(*(void *)(a2 + 32) + 8 * v10);
      double result = (void *)(*(void *)(a1 + 32) + 8 * v10);
      uint64_t v12 = 24 * v4 - 8 * v10;
      do
      {
        int v13 = re::FixedArray<unsigned char>::FixedArray(result, v11);
        v11 += 3;
        double result = v13 + 3;
        v12 -= 24;
      }
      while (v12);
    }
  }
  else
  {
    double result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 24 * v4), *(uint64_t **)(a1 + 32));
    uint64_t v6 = *(void *)(a1 + 16);
    if (v4 != v6)
    {
      int v7 = (uint64_t *)(*(void *)(a1 + 32) + 24 * v4);
      uint64_t v8 = 24 * v6 - 24 * v4;
      do
      {
        double result = (void *)re::FixedArray<CoreIKTransform>::deinit(v7);
        v7 += 3;
        v8 -= 24;
      }
      while (v8);
    }
  }
  *(void *)(a1 + 16) = v4;
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::FixedArray<unsigned char>::operator=(a3, v4);
      v4 += 3;
      a3 += 3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t *re::FixedArray<unsigned char>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<BOOL>::init<>(a1, v4, a2[1]);
LABEL_7:
      re::FixedArray<unsigned char>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

void *re::FixedArray<unsigned char>::copy(void *result, uint64_t a2)
{
  size_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      uint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    double result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::DynamicArray<re::ObjCObject>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::ObjCObject>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::ObjCObject>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::ObjCObject>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  unint64_t v5 = a1[2];
  if (v4 >= v5)
  {
    re::DynamicArray<re::ObjCObject>::setCapacity(a1, *(void *)(a2 + 16));
    int v13 = *(id **)(a2 + 32);
    uint64_t v14 = a1[2];
    uint64_t v15 = (id *)a1[4];
    if (v14)
    {
      uint64_t v16 = 8 * v14;
      do
      {
        double v17 = re::ObjCObject::operator=(v15, v13++);
        uint64_t v15 = v17 + 1;
        v16 -= 8;
      }
      while (v16);
      uint64_t v15 = (id *)a1[4];
      uint64_t v14 = a1[2];
      int v13 = *(id **)(a2 + 32);
    }
    if (v14 != v4)
    {
      uint64_t v18 = &v13[v14];
      int v19 = &v15[v14];
      uint64_t v20 = 8 * v4 - 8 * v14;
      do
      {
        uint64_t v21 = *v18++;
        *v19++ = v21;
        v20 -= 8;
      }
      while (v20);
    }
  }
  else
  {
    uint64_t v6 = (id *)a1[4];
    if (v4)
    {
      int v7 = *(id **)(a2 + 32);
      uint64_t v8 = 8 * v4;
      do
      {
        uint64_t v9 = re::ObjCObject::operator=(v6, v7++);
        uint64_t v6 = v9 + 1;
        v8 -= 8;
      }
      while (v8);
      uint64_t v6 = (id *)a1[4];
      unint64_t v5 = a1[2];
    }
    if (v4 != v5)
    {
      uint64_t v10 = &v6[v4];
      uint64_t v11 = 8 * v5 - 8 * v4;
      do
      {
        uint64_t v12 = *v10++;

        v11 -= 8;
      }
      while (v11);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::ObjCObject>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::ObjCObject>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      int v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (void **)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          unsigned int *v8 = 0;
          *v11++ = v12;
          int v13 = *v8++;

          v10 -= 8;
        }
        while (v10);
        uint64_t v8 = (void **)v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, void **))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::FixedArray<unsigned char>::FixedArray(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *a2;
  if (v4)
  {
    re::FixedArray<BOOL>::init<>(a1, v4, a2[1]);
    re::FixedArray<unsigned char>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<char const*>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<float *>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<char const*>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<char const*>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<float *>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 8 * (void)v5);
      unint64_t v5 = v3[2];
    }
    double result = (void **)memcpy((char *)v3[4] + 8 * (void)v5, (const void *)(*(void *)(a2 + 32) + 8 * (void)v5), 8 * v4 - 8 * (void)v5);
  }
  else if (v4)
  {
    double result = (void **)memmove(result[4], *(const void **)(a2 + 32), 8 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::ObjCObject>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void ***)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 8 * v4;
        do
        {
          uint64_t v6 = *v3++;

          v5 -= 8;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void ***)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, void **))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::FixedArray<unsigned char>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::TypedEventTimelineInstance<float>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<float>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<float>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<float>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<float>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      double v31 = a6;
      int v32 = 0;
      char v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(void *)((char *)&v24 + 4) = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      char v30 = 0;
      LOBYTE(v24) = v15;
      uint64_t v25 = a4;
      uint64_t v26 = a5;
      uint64_t v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v18 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v20 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v23 = *(_DWORD *)(a2 + 64);
      long long v21 = v16;
      long long v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v33) {
          *double v31 = 0;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::GenericSRT<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::GenericSRT<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::GenericSRT<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      int v32 = a6;
      int v33 = 0;
      char v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(void *)((char *)&v25 + 4) = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      LOBYTE(v25) = v15;
      uint64_t v26 = a4;
      uint64_t v27 = a5;
      uint64_t v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v19 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v21 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v24 = *(_DWORD *)(a2 + 64);
      long long v22 = v16;
      long long v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v34)
        {
          long long v18 = v32;
          void *v32 = 0x3F8000003F800000;
          v18[1] = 1065353216;
          void v18[2] = 0;
          v18[3] = 0x3F80000000000000;
          v18[4] = 0;
          v18[5] = 0;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<double>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<double>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<double>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<double>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      char v31 = a6;
      int v32 = 0;
      char v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(void *)((char *)&v24 + 4) = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      char v30 = 0;
      LOBYTE(v24) = v15;
      uint64_t v25 = a4;
      uint64_t v26 = a5;
      uint64_t v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v18 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v20 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v23 = *(_DWORD *)(a2 + 64);
      long long v21 = v16;
      long long v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v33) {
          *char v31 = 0;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::Vector2<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector2<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::Vector2<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      char v31 = a6;
      int v32 = 0;
      char v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(void *)((char *)&v24 + 4) = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      char v30 = 0;
      LOBYTE(v24) = v15;
      uint64_t v25 = a4;
      uint64_t v26 = a5;
      uint64_t v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v18 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v20 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v23 = *(_DWORD *)(a2 + 64);
      long long v21 = v16;
      long long v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v33) {
          *char v31 = 0;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::Vector3<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector3<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::Vector3<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      char v31 = a6;
      int v32 = 0;
      char v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(void *)((char *)&v24 + 4) = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      char v30 = 0;
      LOBYTE(v24) = v15;
      uint64_t v25 = a4;
      uint64_t v26 = a5;
      uint64_t v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v18 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v20 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v23 = *(_DWORD *)(a2 + 64);
      long long v21 = v16;
      long long v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v33) {
          *char v31 = 0u;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::Vector4<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector4<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::Vector4<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      int v32 = a6;
      int v33 = 0;
      char v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(void *)((char *)&v25 + 4) = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      LOBYTE(v25) = v15;
      uint64_t v26 = a4;
      uint64_t v27 = a5;
      uint64_t v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v19 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v21 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v24 = *(_DWORD *)(a2 + 64);
      long long v22 = v16;
      long long v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v34)
        {
          long long v18 = v32;
          void *v32 = 0;
          v18[1] = 0;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::Quaternion<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::Quaternion<float>>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::Quaternion<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      int v32 = a6;
      int v33 = 0;
      char v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(void *)((char *)&v25 + 4) = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      LOBYTE(v25) = v15;
      uint64_t v26 = a4;
      uint64_t v27 = a5;
      uint64_t v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v19 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v21 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v24 = *(_DWORD *)(a2 + 64);
      long long v22 = v16;
      long long v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(unsigned char *)(a1 + 72) && *(unsigned char *)(a2 + 16))
      {
        if (v34)
        {
          long long v18 = v32;
          void *v32 = 0;
          v18[1] = 0x3F80000000000000;
        }
      }
    }
  }
}

void *re::TypedEventTimelineInstance<re::SkeletalPose>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  unint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::TypedEventTimelineInstance<re::SkeletalPose>::~TypedEventTimelineInstance(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TypedEventTimelineInstance<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 40))();
}

uint64_t re::TypedEventTimelineInstance<re::SkeletalPose>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      uint64_t v34 = a6;
      int v35 = 0;
      char v36 = 1;
      *(_WORD *)((char *)&v27 + 1) = 0;
      *(void *)((char *)&v27 + 4) = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      char v33 = 0;
      LOBYTE(v27) = v15;
      uint64_t v28 = a4;
      uint64_t v29 = a5;
      uint64_t v30 = &v34;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      long long v21 = *(_OWORD *)a2;
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v23 = *(void *)(a2 + 24);
      }
      long long v16 = *(_OWORD *)(a2 + 32);
      long long v17 = *(_OWORD *)(a2 + 48);
      int v26 = *(_DWORD *)(a2 + 64);
      long long v24 = v16;
      long long v25 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v21, &v27);
      if (!v35)
      {
        if (*(unsigned char *)(a1 + 72))
        {
          if (*(unsigned char *)(a2 + 16))
          {
            if (v36)
            {
              uint64_t v18 = *(void *)(v34 + 24);
              if (v18)
              {
                long long v19 = *(void **)(v34 + 32);
                uint64_t v20 = &v19[6 * v18];
                do
                {
                  *long long v19 = 0x3F8000003F800000;
                  v19[1] = 1065353216;
                  _OWORD v19[2] = 0;
                  double v19[3] = 0x3F80000000000000;
                  v19[4] = 0;
                  v19[5] = 0;
                  v19 += 6;
                }
                while (v19 != v20);
              }
            }
          }
        }
      }
    }
  }
}

void *re::RigGraphCompilation::init(re::RigGraphCompilation *this, re::Allocator *a2)
{
  unint64_t v3 = this;
  re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::init((uint64_t)this, (uint64_t)a2, 1uLL);
  *((void *)v3 + 7) = a2;
  re::DynamicArray<re::RigDataValue>::setCapacity((void *)v3 + 7, 0);
  *((void *)v3 + 12) = a2;
  unint64_t v3 = (re::RigGraphCompilation *)((char *)v3 + 96);
  ++*((_DWORD *)v3 - 4);
  uint64_t result = re::DynamicArray<re::RigDataValue>::setCapacity(v3, 0);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  uint64_t result = re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::RigGraphCompilation::setRuntimeContext(uint64_t this, re::EvaluationContext *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 72);
  if (v4)
  {
    uint64_t v5 = *(void *)(this + 88);
    uint64_t v6 = 288 * v4;
    do
    {
      this = re::RigDataValue::setRuntimeContext(v5, a2);
      v5 += 288;
      v6 -= 288;
    }
    while (v6);
  }
  uint64_t v7 = *(void *)(v3 + 112);
  if (v7)
  {
    uint64_t v8 = *(void *)(v3 + 128);
    uint64_t v9 = 288 * v7;
    do
    {
      this = re::RigDataValue::setRuntimeContext(v8, a2);
      v8 += 288;
      v9 -= 288;
    }
    while (v9);
  }
  return this;
}

uint64_t re::RigGraphCompilation::setInputOutputValues(void *a1, re::EvaluationContextManager *a2, void **a3, void **a4)
{
  re::DynamicArray<re::RigDataValue>::operator=((uint64_t)(a1 + 7), a3);
  uint64_t v7 = a1[9];
  if (v7)
  {
    uint64_t v8 = (re::RigDataValue *)a1[11];
    uint64_t v9 = 288 * v7;
    do
    {
      if (*((unsigned char *)v8 + 32) != 10) {
        re::RigDataValue::resolveRuntimeInputValues(v8, a2);
      }
      uint64_t v8 = (re::RigDataValue *)((char *)v8 + 288);
      v9 -= 288;
    }
    while (v9);
  }
  uint64_t result = re::DynamicArray<re::RigDataValue>::operator=((uint64_t)(a1 + 12), a4);
  uint64_t v11 = a1[14];
  if (v11)
  {
    uint64_t v12 = a1[16];
    uint64_t v13 = 288 * v11;
    do
    {
      if (*(unsigned char *)(v12 + 32) != 10) {
        uint64_t result = (uint64_t)re::RigDataValue::resolveRuntimeOutputValues((void *)v12, a2);
      }
      v12 += 288;
      v13 -= 288;
    }
    while (v13);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigDataValue>::operator=(uint64_t a1, void **a2)
{
  unint64_t v4 = (unint64_t)a2[1];
  if (*(void *)a1)
  {
    if (v4)
    {
      re::DynamicArray<re::RigDataValue>::copy((void *)a1, 0, *a2, v4);
      re::DynamicArray<re::RigDataValue>::resize(a1, (unint64_t)a2[1]);
    }
    else
    {
      re::DynamicArray<re::RigDataValue>::clear((re::RigDataValue *)a1);
    }
  }
  else if (v4)
  {
    re::DynamicArray<re::RigDataValue>::setCapacity((void *)a1, v4);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::RigDataValue>::copy((void *)a1, 0, *a2, (uint64_t)a2[1]);
  }
  return a1;
}

uint64_t *re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 2560, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::add(uint64_t a1, void *a2)
{
  uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::ensureCapacity((_anonymous_namespace_ *)a1);
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v5 = a1 + 24;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)(v5 + 8 * v6) = *a2;
  *(void *)(a1 + 8) = v6 + 1;
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  uint64_t v1 = result;
  if (!*(void *)result)
  {
    unint64_t v7 = *((void *)v1 + 1) + 1;
    uint64_t result = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v1, v7);
    *((_DWORD *)v1 + 4) += 2;
    return result;
  }
  unint64_t v2 = *((void *)result + 1);
  if (*((unsigned char *)result + 16))
  {
    unint64_t v4 = v2 + 1;
    if (v4 < 3) {
      return result;
    }
    unint64_t v6 = 4;
    goto LABEL_12;
  }
  unint64_t v3 = *((void *)result + 3);
  BOOL v5 = v2 >= v3;
  unint64_t v4 = v2 + 1;
  BOOL v5 = !v5 || v3 >= v4;
  if (!v5)
  {
    unint64_t v6 = 2 * v3;
LABEL_12:
    if (v6 <= v4) {
      unint64_t v8 = v4;
    }
    else {
      unint64_t v8 = v6;
    }
    return (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(result, v8);
  }
  return result;
}

void *re::DynamicArray<re::RigDataValue>::copy(void *this, unint64_t a2, void *a3, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unint64_t v6 = this;
  unint64_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "copy";
    WORD6(v15) = 1024;
    HIWORD(v15) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_13;
  }
  if (v7 >= v8)
  {
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(a3, &a3[36 * a4], (void *)(this[4] + 288 * a2));
  }
  else
  {
    re::DynamicArray<re::RigDataValue>::growCapacity(this, a2 + a4);
    uint64_t v10 = v6[2];
    uint64_t v11 = (const re::RigDataValue *)&a3[36 * (v10 - a2)];
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(a3, v11, (void *)(v6[4] + 288 * a2));
    if (v10 - a2 != v4)
    {
      this = (void *)(v6[4] + 288 * v6[2]);
      uint64_t v12 = 288 * a2 + 288 * v4 - 288 * v10;
      do
      {
        uint64_t v13 = re::RigDataValue::RigDataValue((re::RigDataValue *)this, v11);
        uint64_t v11 = (const re::RigDataValue *)((char *)v11 + 288);
        this = (void *)((char *)v13 + 288);
        v12 -= 288;
      }
      while (v12);
    }
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

void *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(void *result, void *a2, void *a3)
{
  if (result != a2)
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      uint64_t result = re::RigDataValue::operator=(a3, v5);
      v5 += 288;
      a3 += 36;
    }
    while ((void *)v5 != a2);
  }
  return result;
}

uint64_t re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > v3 << 6)
  {
    re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 64) >> 6);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 6)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 6));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 40 * (v2 & 0x3F);
}

uint64_t std::__function::__value_func<void ()(void *)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

double re::FromToByAnimation<float>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<float>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5, float *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t result = *(void *)(a1 + 112);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 16))(result, a7);
    }
    float v18 = 0.0;
    int v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(unsigned char *)(a1 + 88))
    {
      long long v15 = (float *)(a1 + 92);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 96))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 104))
        {
          float v18 = *(float *)(a1 + 100) - *(float *)(a1 + 108);
          long long v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      float v16 = *v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 96))
      {
        long long v17 = (float *)(a1 + 100);
      }
      else if (*(unsigned char *)(a1 + 104))
      {
        float v18 = *v15 + *(float *)(a1 + 108);
        long long v17 = &v18;
      }
      else if (v14)
      {
        long long v17 = a4;
      }
      else
      {
        long long v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0) {
        float v16 = *v17;
      }
      else {
        float v16 = (float)(a7.n128_f32[0] * *v17) + (float)(*v15 * (float)(1.0 - a7.n128_f32[0]));
      }
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<double>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double *a5, double *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t result = *(void *)(a1 + 136);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 16))(result, a7);
    }
    double v18 = 0.0;
    int v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(unsigned char *)(a1 + 88))
    {
      long long v15 = (double *)(a1 + 96);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 104))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 120))
        {
          double v18 = *(double *)(a1 + 112) - *(double *)(a1 + 128);
          long long v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      double v16 = *v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 104))
      {
        long long v17 = (double *)(a1 + 112);
      }
      else if (*(unsigned char *)(a1 + 120))
      {
        double v18 = *v15 + *(double *)(a1 + 128);
        long long v17 = &v18;
      }
      else if (v14)
      {
        long long v17 = a4;
      }
      else
      {
        long long v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0) {
        double v16 = *v17;
      }
      else {
        double v16 = *v17 * a7.n128_f32[0] + *v15 * (float)(1.0 - a7.n128_f32[0]);
      }
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, float32x2_t *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t result = *(void *)(a1 + 136);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 16))(result, a7);
    }
    float32x2_t v18 = 0;
    int v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(unsigned char *)(a1 + 88))
    {
      long long v15 = (float32x2_t *)(a1 + 96);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 104))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 120))
        {
          float32x2_t v18 = vsub_f32(*(float32x2_t *)(a1 + 112), *(float32x2_t *)(a1 + 128));
          long long v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      float32x2_t v16 = *v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 104))
      {
        long long v17 = (float32x2_t *)(a1 + 112);
      }
      else if (*(unsigned char *)(a1 + 120))
      {
        float32x2_t v18 = vadd_f32(*v15, *(float32x2_t *)(a1 + 128));
        long long v17 = &v18;
      }
      else if (v14)
      {
        long long v17 = a4;
      }
      else
      {
        long long v17 = a5;
      }
      if (a7.n128_f32[0] != 1.0)
      {
        *a6 = vadd_f32(vmul_n_f32(*v15, 1.0 - a7.n128_f32[0]), vmul_n_f32(*v17, a7.n128_f32[0]));
        return result;
      }
      float32x2_t v16 = *v17;
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t result = *(void *)(a1 + 192);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 16))(result, a7);
    }
    float32x4_t v18 = 0u;
    int v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(unsigned char *)(a1 + 96))
    {
      long long v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 128))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 160))
        {
          float32x4_t v18 = vsubq_f32(*(float32x4_t *)(a1 + 144), *(float32x4_t *)(a1 + 176));
          long long v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      float32x4_t v16 = *v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 128))
      {
        long long v17 = (float32x4_t *)(a1 + 144);
      }
      else if (*(unsigned char *)(a1 + 160))
      {
        float32x4_t v18 = vaddq_f32(*v15, *(float32x4_t *)(a1 + 176));
        long long v17 = &v18;
      }
      else if (v14)
      {
        long long v17 = a4;
      }
      else
      {
        long long v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0) {
        float32x4_t v16 = *v17;
      }
      else {
        float32x4_t v16 = vmlaq_n_f32(vmulq_n_f32(*v17, a7.n128_f32[0]), *v15, 1.0 - a7.n128_f32[0]);
      }
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t result = *(void *)(a1 + 192);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 16))(result, a7);
    }
    float32x4_t v18 = 0uLL;
    int v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(unsigned char *)(a1 + 96))
    {
      long long v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 128))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 160))
        {
          float32x4_t v18 = vsubq_f32(*(float32x4_t *)(a1 + 144), *(float32x4_t *)(a1 + 176));
          long long v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      float32x4_t v16 = *v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 128))
      {
        long long v17 = (float32x4_t *)(a1 + 144);
      }
      else if (*(unsigned char *)(a1 + 160))
      {
        float32x4_t v18 = vaddq_f32(*v15, *(float32x4_t *)(a1 + 176));
        long long v17 = &v18;
      }
      else if (v14)
      {
        long long v17 = a4;
      }
      else
      {
        long long v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0) {
        float32x4_t v16 = *v17;
      }
      else {
        float32x4_t v16 = vaddq_f32(vmulq_n_f32(*v15, 1.0 - a7.n128_f32[0]), vmulq_n_f32(*v17, a7.n128_f32[0]));
      }
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t *a4, float32x4_t *a5, uint64_t *a6, __n128 a7)
{
  if (a3)
  {
    double v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    float v12 = 1.0;
    if (fabs(v11) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v11;
    }
    if (v12 <= 1.0) {
      a7.n128_f32[0] = v12;
    }
    if (a7.n128_f32[0] < 0.0) {
      a7.n128_f32[0] = 0.0;
    }
    uint64_t v13 = *(void *)(a1 + 192);
    if (v13) {
      (*(void (**)(uint64_t, __n128))(*(void *)v13 + 16))(v13, a7);
    }
    long long v33 = xmmword_23435FBB0;
    int v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(unsigned char *)(a1 + 96))
    {
      long long v15 = (int32x4_t *)(a1 + 112);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 128))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 160))
        {
          long long v33 = *(_OWORD *)(a1 + 176);
          _V1.S[3] = HIDWORD(v33);
          _Q2 = (int32x4_t)vnegq_f32((float32x4_t)v33);
          float32x4_t v19 = *(float32x4_t *)(a1 + 144);
          _Q5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), (float32x4_t)v33), v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL));
          float32x4_t v21 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q5, _Q5), (int8x16_t)_Q5, 0xCuLL), v19, (float32x4_t)v33, 3);
          _Q5.i32[0] = v19.i32[3];
          float32x4_t v22 = vmlsq_laneq_f32(v21, (float32x4_t)v33, v19, 3);
          __asm { FMLA            S2, S5, V1.S[3] }
          v22.i32[3] = _Q2.i32[0];
          long long v33 = (__int128)v22;
          long long v15 = (int32x4_t *)&v33;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      float32x4_t v16 = *(float32x4_t *)v15;
    }
    else
    {
      if (*(unsigned char *)(a1 + 128))
      {
        long long v27 = (float32x4_t *)(a1 + 144);
      }
      else if (*(unsigned char *)(a1 + 160))
      {
        _Q1 = *(float32x4_t *)(a1 + 176);
        _Q4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*v15, *v15), *(int8x16_t *)v15, 0xCuLL), vnegq_f32(_Q1)), *(float32x4_t *)v15, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
        float32x4_t v30 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q4, _Q4), (int8x16_t)_Q4, 0xCuLL), *(float32x4_t *)v15, _Q1, 3);
        _Q4.i32[0] = HIDWORD(*(unsigned long long *)v15);
        float32x4_t v31 = vmlaq_laneq_f32(v30, _Q1, *(float32x4_t *)v15, 3);
        __asm { FMLA            S2, S4, V1.S[3] }
        v31.i32[3] = _S2;
        long long v33 = (__int128)v31;
        long long v27 = (float32x4_t *)&v33;
      }
      else if (v14)
      {
        long long v27 = (float32x4_t *)a4;
      }
      else
      {
        long long v27 = a5;
      }
      if (a7.n128_f32[0] != 1.0)
      {
        re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)v15, v27, a6, a7.n128_f32[0]);
        return;
      }
      float32x4_t v16 = *v27;
    }
    *(float32x4_t *)a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

double re::FromToByAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6)
{
  if (a3)
  {
    double v10 = *(double *)(a1 + 80);
    float v11 = 1.0;
    float v12 = 1.0;
    if (fabs(v10) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v10;
    }
    if (v12 <= 1.0) {
      float v11 = v12;
    }
    if (v11 >= 0.0) {
      float v13 = v11;
    }
    else {
      float v13 = 0.0;
    }
    uint64_t v14 = *(void *)(a1 + 288);
    if (v14) {
      float v13 = (*(float (**)(uint64_t, float))(*(void *)v14 + 16))(v14, v13);
    }
    v35.i64[0] = 0x3F8000003F800000;
    v35.i64[1] = 1065353216;
    v36.i64[0] = 0;
    v36.i64[1] = 0x3F80000000000000;
    float32x4_t v37 = 0uLL;
    if (*(unsigned char *)(a1 + 96))
    {
      long long v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      long long v15 = a4;
      if (*(unsigned char *)(a1 + 160))
      {
        long long v15 = a4;
        if (*(unsigned char *)(a1 + 224))
        {
          float32x4_t v19 = *(float32x4_t *)(a1 + 256);
          float32x4_t v20 = *(float32x4_t *)(a1 + 272);
          __asm { FMOV            V3.4S, #1.0 }
          float32x4_t v26 = vdivq_f32(_Q3, *(float32x4_t *)(a1 + 240));
          int32x4_t v27 = (int32x4_t)vnegq_f32(v19);
          float32x4_t v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
          v27.i32[3] = v19.i32[3];
          float32x4_t v29 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v19), v20, v28);
          int32x4_t v30 = (int32x4_t)vaddq_f32(v29, v29);
          float32x4_t v31 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v30, v30), (int8x16_t)v30, 0xCuLL);
          float32x4_t v32 = vaddq_f32(v20, vmulq_laneq_f32(v31, v19, 3));
          int32x4_t v33 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL), v19), v31, v28);
          float32x4_t v35 = v26;
          int32x4_t v36 = v27;
          float32x4_t v37 = vmulq_f32(vaddq_f32(v32, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v33, v33), (int8x16_t)v33, 0xCuLL)), vnegq_f32(v26));
          long long v15 = &v35;
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(a1 + 176), &v35, &v35);
        }
      }
    }
    if (v13 == 0.0)
    {
      float32x4_t v16 = *v15;
      float32x4_t v17 = v15[1];
      float32x4_t v18 = v15[2];
LABEL_26:
      a6[1] = v17;
      a6[2] = v18;
      *a6 = v16;
      return;
    }
    if (*(unsigned char *)(a1 + 160))
    {
      a5 = (float32x4_t *)(a1 + 176);
    }
    else if (*(unsigned char *)(a1 + 224))
    {
      a5 = &v35;
      re::AnimationValueTraits<re::GenericSRT<float>>::combine(v15, (float32x4_t *)(a1 + 240), &v35);
    }
    else if (*(unsigned char *)(a1 + 96))
    {
      a5 = a4;
    }
    if (v13 == 1.0)
    {
      float32x4_t v16 = *a5;
      float32x4_t v17 = a5[1];
      float32x4_t v18 = a5[2];
      goto LABEL_26;
    }
    re::lerp<float>(v15, a5, v38, v13);
    float32x4_t v34 = v38[1];
    *a6 = v38[0];
    a6[1] = v34;
    a6[2] = v38[2];
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

double re::FromToByAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, void *a6)
{
  if (a3)
  {
    double v10 = *(double *)(a1 + 80);
    float v11 = 1.0;
    float v12 = 1.0;
    if (fabs(v10) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v10;
    }
    if (v12 <= 1.0) {
      float v11 = v12;
    }
    if (v11 >= 0.0) {
      float v13 = v11;
    }
    else {
      float v13 = 0.0;
    }
    uint64_t v14 = *(void *)(a1 + 376);
    if (v14) {
      float v13 = (*(float (**)(uint64_t, float))(*(void *)v14 + 16))(v14, v13);
    }
    v18[0] = 0;
    v18[1] = (uint64_t)"";
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    int v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    if (*(unsigned char *)(a1 + 88))
    {
      int v15 = 0;
      float32x4_t v16 = (uint64_t *)(a1 + 96);
    }
    else if (*(unsigned char *)(a1 + 184) && *(unsigned char *)(a1 + 280))
    {
      float32x4_t v16 = v18;
      re::SkeletalPose::init(v18, a4 + 10);
      re::AnimationValueTraits<re::SkeletalPose>::invert((void *)(a1 + 288), v18);
      re::AnimationValueTraits<re::SkeletalPose>::combine((void *)(a1 + 192), v18, v18);
      int v15 = 1;
    }
    else
    {
      int v15 = 0;
      float32x4_t v16 = a4;
    }
    if (v13 == 0.0)
    {
      re::AnimationValueTraits<re::SkeletalPose>::copy(v16, a6);
LABEL_28:
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)v18);
      return;
    }
    if (*(unsigned char *)(a1 + 184))
    {
      a4 = (uint64_t *)(a1 + 192);
    }
    else if (*(unsigned char *)(a1 + 280))
    {
      float32x4_t v17 = a4 + 10;
      a4 = v18;
      re::SkeletalPose::init(v18, v17);
      re::AnimationValueTraits<re::SkeletalPose>::combine(v16, (void *)(a1 + 288), v18);
      int v15 = 1;
    }
    else if (!*(unsigned char *)(a1 + 88))
    {
      a4 = a5;
    }
    if (v13 == 1.0)
    {
      re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
      if (!v15) {
        goto LABEL_28;
      }
    }
    else
    {
      re::AnimationValueTraits<re::SkeletalPose>::interpolate(v16, a4, a6, v13);
      if (!v15) {
        goto LABEL_28;
      }
    }
    re::SkeletalPose::deinit((re::SkeletalPose *)v18);
    goto LABEL_28;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  _os_crash();
  __break(1u);
}

double re::FromToByAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  if (a3)
  {
    double v10 = *(double *)(a1 + 80);
    float v11 = 1.0;
    float v12 = 1.0;
    if (fabs(v10) >= 1.0e-12) {
      float v12 = *(double *)(a2 + 24) / v10;
    }
    if (v12 <= 1.0) {
      float v11 = v12;
    }
    if (v11 >= 0.0) {
      float v13 = v11;
    }
    else {
      float v13 = 0.0;
    }
    uint64_t v14 = *(void *)(a1 + 208);
    if (v14) {
      float v13 = (*(float (**)(uint64_t, float))(*(void *)v14 + 16))(v14, v13);
    }
    memset(v18, 0, sizeof(v18));
    if (*(unsigned char *)(a1 + 88))
    {
      int v15 = 0;
      float32x4_t v16 = (uint64_t *)(a1 + 96);
    }
    else if (*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 168))
    {
      float32x4_t v16 = (uint64_t *)v18;
      re::BlendShapeWeights::init((uint64_t *)v18, a4 + 3);
      re::AnimationValueTraits<re::BlendShapeWeights>::invert((void *)(a1 + 176), v18);
      re::AnimationValueTraits<re::BlendShapeWeights>::combine((void *)(a1 + 136), v18, v18);
      int v15 = 1;
    }
    else
    {
      int v15 = 0;
      float32x4_t v16 = a4;
    }
    if (v13 == 0.0)
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::copy(v16, a6);
LABEL_28:
      re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)v18);
      return;
    }
    if (*(unsigned char *)(a1 + 128))
    {
      a4 = (uint64_t *)(a1 + 136);
    }
    else if (*(unsigned char *)(a1 + 168))
    {
      float32x4_t v17 = a4 + 3;
      a4 = (uint64_t *)v18;
      re::BlendShapeWeights::init((uint64_t *)v18, v17);
      re::AnimationValueTraits<re::BlendShapeWeights>::combine(v16, (void *)(a1 + 176), v18);
      int v15 = 1;
    }
    else if (!*(unsigned char *)(a1 + 88))
    {
      a4 = a5;
    }
    if (v13 == 1.0)
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
      if (!v15) {
        goto LABEL_28;
      }
    }
    else
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)v16, a4, a6, v13);
      if (!v15) {
        goto LABEL_28;
      }
    }
    re::BlendShapeWeights::deinit((re::BlendShapeWeights *)v18);
    goto LABEL_28;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  _os_crash();
  __break(1u);
}

uint64_t re::FromToByAnimation<re::SkeletalPose>::~FromToByAnimation(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C3550;
  if (*(unsigned char *)(a1 + 280)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 288));
  }
  if (*(unsigned char *)(a1 + 184)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 192));
  }
  if (*(unsigned char *)(a1 + 88)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 96));
  }
  *(void *)a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::FromToByAnimation<re::SkeletalPose>::~FromToByAnimation(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C3550;
  if (*(unsigned char *)(a1 + 280)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 288));
  }
  if (*(unsigned char *)(a1 + 184)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 192));
  }
  if (*(unsigned char *)(a1 + 88)) {
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 96));
  }
  *(void *)a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::FromToByAnimation<re::BlendShapeWeights>::~FromToByAnimation(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C35D0;
  if (*(unsigned char *)(a1 + 168)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 176));
  }
  if (*(unsigned char *)(a1 + 128)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 136));
  }
  if (*(unsigned char *)(a1 + 88)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 96));
  }
  *(void *)a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::FromToByAnimation<re::BlendShapeWeights>::~FromToByAnimation(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C35D0;
  if (*(unsigned char *)(a1 + 168)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 176));
  }
  if (*(unsigned char *)(a1 + 128)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 136));
  }
  if (*(unsigned char *)(a1 + 88)) {
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 96));
  }
  *(void *)a1 = &unk_26E6BF1F0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<float>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    long long v19 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v31 = 0;
    long long v20 = "Cannot make additive values, output values expected to match input values size.";
    long long v21 = (uint8_t *)&v31;
    goto LABEL_33;
  }
  if (!*(void *)(a2 + 8))
  {
    long long v19 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    long long v20 = "Cannot make additive values, base values array size must not be zero.";
    long long v21 = buf;
LABEL_33:
    _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    return 0;
  }
  uint64_t result = 1;
  if (a4)
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(void *)a1;
    double v8 = 0.0;
    unint64_t v9 = a4;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, a2, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v9);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v15);
        _os_crash();
        __break(1u);
        goto LABEL_65;
      }
      double v10 = *(unsigned __int8 **)(v7 + 8 * v6);
      float v11 = *(unsigned __int8 **)(a3 + 8 * v6);
      int v12 = *v11;
      if ((*v10 != 0) != (*v11 != 0) && (v12 | *v10) != 0)
      {
        if (*v10) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = v12 == 0;
        }
        if (v17)
        {
          if (*v10) {
            BOOL v18 = v12 == 0;
          }
          else {
            BOOL v18 = 0;
          }
          if (v18)
          {
            *float v11 = 1;
            *((_DWORD *)v11 + 1) = *((_DWORD *)v10 + 1);
          }
          else
          {
            *((_DWORD *)v11 + 1) = *((_DWORD *)v10 + 1);
            unint64_t v9 = *((void *)a1 + 1);
          }
        }
        else
        {
          *float v11 = 0;
        }
      }
      if (v9 <= v6) {
        goto LABEL_63;
      }
      uint64_t v7 = *(void *)a1;
      uint64_t v14 = *(void *)(*(void *)a1 + 8 * v6);
      unint64_t v15 = *(void *)(a2 + 8);
      if (*(unsigned char *)v14)
      {
        if (v15 <= v6) {
          goto LABEL_64;
        }
        float v16 = **(float **)(*(void *)a2 + 8 * v6);
        *(float *)&double v8 = -v16;
        *(float *)(*(void *)(a3 + 8 * v6) + 4) = *(float *)(v14 + 4) - v16;
        unint64_t v15 = *(void *)(a2 + 8);
      }
      ++v6;
    }
    while (v9 > v6 && v15 > v6);
    uint64_t result = 1;
    if (v9 <= v6) {
      return result;
    }
    unint64_t v22 = v6;
    if (a4 <= v6) {
      unint64_t v23 = v6;
    }
    else {
      unint64_t v23 = a4;
    }
    if (a4 <= v6) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = a4;
    }
    while (v6 != v22)
    {
      uint64_t v24 = *(unsigned __int8 **)(v7 + 8 * v22);
      long long v25 = *(unsigned __int8 **)(a3 + 8 * v22);
      int v26 = *v25;
      a2 = *v25 != 0;
      if ((*v24 != 0) != a2 && (v26 | *v24) != 0)
      {
        if (*v24) {
          BOOL v28 = 1;
        }
        else {
          BOOL v28 = v26 == 0;
        }
        if (v28)
        {
          if (*v24) {
            BOOL v29 = v26 == 0;
          }
          else {
            BOOL v29 = 0;
          }
          if (v29)
          {
            *long long v25 = 1;
            *((_DWORD *)v25 + 1) = *((_DWORD *)v24 + 1);
          }
          else
          {
            *((_DWORD *)v25 + 1) = *((_DWORD *)v24 + 1);
            unint64_t v9 = *((void *)a1 + 1);
          }
        }
        else
        {
          *long long v25 = 0;
        }
      }
      if (v9 <= v22) {
        goto LABEL_66;
      }
      uint64_t v7 = *(void *)a1;
      *(float *)(*(void *)(a3 + 8 * v22) + 4) = *(float *)&v8
                                                  + *(float *)(*(void *)(*(void *)a1 + 8 * v22) + 4);
      if (v9 <= ++v22) {
        return 1;
      }
    }
LABEL_65:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v23, a4);
    _os_crash();
    __break(1u);
LABEL_66:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v9);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<double>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    long long v19 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v31 = 0;
    long long v20 = "Cannot make additive values, output values expected to match input values size.";
    long long v21 = (uint8_t *)&v31;
    goto LABEL_33;
  }
  if (!*(void *)(a2 + 8))
  {
    long long v19 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    long long v20 = "Cannot make additive values, base values array size must not be zero.";
    long long v21 = buf;
LABEL_33:
    _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    return 0;
  }
  uint64_t result = 1;
  if (a4)
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(void *)a1;
    double v8 = 0.0;
    unint64_t v9 = a4;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, a2, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v9);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v15);
        _os_crash();
        __break(1u);
        goto LABEL_65;
      }
      double v10 = *(unsigned __int8 **)(v7 + 8 * v6);
      float v11 = *(unsigned __int8 **)(a3 + 8 * v6);
      int v12 = *v11;
      if ((*v10 != 0) != (*v11 != 0) && (v12 | *v10) != 0)
      {
        if (*v10) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = v12 == 0;
        }
        if (v17)
        {
          if (*v10) {
            BOOL v18 = v12 == 0;
          }
          else {
            BOOL v18 = 0;
          }
          if (v18)
          {
            *float v11 = 1;
            *((void *)v11 + 1) = *((void *)v10 + 1);
          }
          else
          {
            *((void *)v11 + 1) = *((void *)v10 + 1);
            unint64_t v9 = *((void *)a1 + 1);
          }
        }
        else
        {
          *float v11 = 0;
        }
      }
      if (v9 <= v6) {
        goto LABEL_63;
      }
      uint64_t v7 = *(void *)a1;
      uint64_t v14 = *(void *)(*(void *)a1 + 8 * v6);
      unint64_t v15 = *(void *)(a2 + 8);
      if (*(unsigned char *)v14)
      {
        if (v15 <= v6) {
          goto LABEL_64;
        }
        double v16 = **(double **)(*(void *)a2 + 8 * v6);
        double v8 = -v16;
        *(double *)(*(void *)(a3 + 8 * v6) + 8) = *(double *)(v14 + 8) - v16;
        unint64_t v15 = *(void *)(a2 + 8);
      }
      ++v6;
    }
    while (v9 > v6 && v15 > v6);
    uint64_t result = 1;
    if (v9 <= v6) {
      return result;
    }
    unint64_t v22 = v6;
    if (a4 <= v6) {
      unint64_t v23 = v6;
    }
    else {
      unint64_t v23 = a4;
    }
    if (a4 <= v6) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = a4;
    }
    while (v6 != v22)
    {
      uint64_t v24 = *(unsigned __int8 **)(v7 + 8 * v22);
      long long v25 = *(unsigned __int8 **)(a3 + 8 * v22);
      int v26 = *v25;
      a2 = *v25 != 0;
      if ((*v24 != 0) != a2 && (v26 | *v24) != 0)
      {
        if (*v24) {
          BOOL v28 = 1;
        }
        else {
          BOOL v28 = v26 == 0;
        }
        if (v28)
        {
          if (*v24) {
            BOOL v29 = v26 == 0;
          }
          else {
            BOOL v29 = 0;
          }
          if (v29)
          {
            *long long v25 = 1;
            *((void *)v25 + 1) = *((void *)v24 + 1);
          }
          else
          {
            *((void *)v25 + 1) = *((void *)v24 + 1);
            unint64_t v9 = *((void *)a1 + 1);
          }
        }
        else
        {
          *long long v25 = 0;
        }
      }
      if (v9 <= v22) {
        goto LABEL_66;
      }
      uint64_t v7 = *(void *)a1;
      *(double *)(*(void *)(a3 + 8 * v22) + 8) = v8 + *(double *)(*(void *)(*(void *)a1 + 8 * v22) + 8);
      if (v9 <= ++v22) {
        return 1;
      }
    }
LABEL_65:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v23, a4);
    _os_crash();
    __break(1u);
LABEL_66:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v9);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Vector2<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    BOOL v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v31 = 0;
    long long v19 = "Cannot make additive values, output values expected to match input values size.";
    long long v20 = (uint8_t *)&v31;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    BOOL v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    long long v19 = "Cannot make additive values, base values array size must not be zero.";
    long long v20 = buf;
LABEL_34:
    _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    return 0;
  }
  uint64_t result = 1;
  if (a4)
  {
    unint64_t v6 = 0;
    float32x2_t v7 = 0;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)&v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      double v8 = *(unsigned __int8 **)(*(void *)a1 + 8 * v6);
      unint64_t v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      int v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8) {
          BOOL v16 = 1;
        }
        else {
          BOOL v16 = v10 == 0;
        }
        if (v16)
        {
          if (*v8) {
            BOOL v17 = v10 == 0;
          }
          else {
            BOOL v17 = 0;
          }
          if (v17) {
            *unint64_t v9 = 1;
          }
          *((void *)v9 + 1) = *((void *)v8 + 1);
        }
        else
        {
          *unint64_t v9 = 0;
        }
      }
      unint64_t v12 = *((void *)a1 + 1);
      if (v12 <= v6) {
        goto LABEL_65;
      }
      float v13 = *(float32x2_t **)(*(void *)a1 + 8 * v6);
      unint64_t v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6) {
          goto LABEL_66;
        }
        float32x2_t v15 = **(float32x2_t **)(*a2 + 8 * v6);
        float32x2_t v7 = vneg_f32(v15);
        *(float32x2_t *)(*(void *)(a3 + 8 * v6) + 8) = vsub_f32(v13[1], v15);
        unint64_t v12 = *((void *)a1 + 1);
        unint64_t v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    uint64_t result = 1;
    if (v12 <= v6) {
      return result;
    }
    unint64_t v21 = v6;
    if (a4 <= v6) {
      unint64_t v22 = v6;
    }
    else {
      unint64_t v22 = a4;
    }
    if (a4 <= v6) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = a4;
    }
    while (v6 != v21)
    {
      unint64_t v23 = *(unsigned __int8 **)(*(void *)a1 + 8 * v21);
      uint64_t v24 = *(unsigned __int8 **)(a3 + 8 * v21);
      int v25 = *v24;
      if ((*v23 != 0) != (*v24 != 0) && (v25 | *v23) != 0)
      {
        if (*v23) {
          BOOL v28 = 1;
        }
        else {
          BOOL v28 = v25 == 0;
        }
        if (v28)
        {
          if (*v23) {
            BOOL v29 = v25 == 0;
          }
          else {
            BOOL v29 = 0;
          }
          if (v29) {
            *uint64_t v24 = 1;
          }
          *((void *)v24 + 1) = *((void *)v23 + 1);
        }
        else
        {
          *uint64_t v24 = 0;
        }
      }
      unint64_t v27 = *((void *)a1 + 1);
      if (v27 <= v21) {
        goto LABEL_68;
      }
      *(float32x2_t *)(*(void *)(a3 + 8 * v21) + 8) = vadd_f32(v7, *(float32x2_t *)(*(void *)(*(void *)a1 + 8 * v21) + 8));
      if (*((void *)a1 + 1) <= ++v21) {
        return 1;
      }
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v22, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v27);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Vector3<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    BOOL v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v31 = 0;
    long long v19 = "Cannot make additive values, output values expected to match input values size.";
    long long v20 = (uint8_t *)&v31;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    BOOL v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    long long v19 = "Cannot make additive values, base values array size must not be zero.";
    long long v20 = buf;
LABEL_34:
    _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    return 0;
  }
  uint64_t result = 1;
  if (a4)
  {
    unint64_t v6 = 0;
    float32x4_t v7 = 0uLL;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)v7.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      double v8 = *(unsigned __int8 **)(*(void *)a1 + 8 * v6);
      unint64_t v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      int v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8) {
          BOOL v16 = 1;
        }
        else {
          BOOL v16 = v10 == 0;
        }
        if (v16)
        {
          if (*v8) {
            BOOL v17 = v10 == 0;
          }
          else {
            BOOL v17 = 0;
          }
          if (v17) {
            *unint64_t v9 = 1;
          }
          *((_OWORD *)v9 + 1) = *((_OWORD *)v8 + 1);
        }
        else
        {
          *unint64_t v9 = 0;
        }
      }
      unint64_t v12 = *((void *)a1 + 1);
      if (v12 <= v6) {
        goto LABEL_65;
      }
      float v13 = *(float32x4_t **)(*(void *)a1 + 8 * v6);
      unint64_t v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6) {
          goto LABEL_66;
        }
        float32x4_t v15 = *(float32x4_t *)*(void *)(*a2 + 8 * v6);
        float32x4_t v7 = vnegq_f32(v15);
        *(float32x4_t *)(*(void *)(a3 + 8 * v6) + 16) = vsubq_f32(v13[1], v15);
        unint64_t v12 = *((void *)a1 + 1);
        unint64_t v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    uint64_t result = 1;
    if (v12 <= v6) {
      return result;
    }
    unint64_t v21 = v6;
    if (a4 <= v6) {
      unint64_t v22 = v6;
    }
    else {
      unint64_t v22 = a4;
    }
    if (a4 <= v6) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = a4;
    }
    while (v6 != v21)
    {
      unint64_t v23 = *(unsigned __int8 **)(*(void *)a1 + 8 * v21);
      uint64_t v24 = *(unsigned __int8 **)(a3 + 8 * v21);
      int v25 = *v24;
      if ((*v23 != 0) != (*v24 != 0) && (v25 | *v23) != 0)
      {
        if (*v23) {
          BOOL v28 = 1;
        }
        else {
          BOOL v28 = v25 == 0;
        }
        if (v28)
        {
          if (*v23) {
            BOOL v29 = v25 == 0;
          }
          else {
            BOOL v29 = 0;
          }
          if (v29) {
            *uint64_t v24 = 1;
          }
          *((_OWORD *)v24 + 1) = *((_OWORD *)v23 + 1);
        }
        else
        {
          *uint64_t v24 = 0;
        }
      }
      unint64_t v27 = *((void *)a1 + 1);
      if (v27 <= v21) {
        goto LABEL_68;
      }
      *(float32x4_t *)(*(void *)(a3 + 8 * v21) + 16) = vaddq_f32(v7, *(float32x4_t *)(*(void *)(*(void *)a1 + 8 * v21) + 16));
      if (*((void *)a1 + 1) <= ++v21) {
        return 1;
      }
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v22, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v27);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Quaternion<float>>(re *a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    int v25 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int16 v46 = 0;
    int v26 = "Cannot make additive values, output values expected to match input values size.";
    unint64_t v27 = (uint8_t *)&v46;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    int v25 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    int v26 = "Cannot make additive values, base values array size must not be zero.";
    unint64_t v27 = buf;
LABEL_34:
    _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, v26, v27, 2u);
    return 0;
  }
  uint64_t result = 1;
  if (a4)
  {
    unint64_t v6 = 0;
    float32x4_t v7 = (float32x4_t)xmmword_23435FBB0;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)v7.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      double v8 = *(unsigned __int8 **)(*(void *)a1 + 8 * v6);
      unint64_t v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      int v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8) {
          BOOL v23 = 1;
        }
        else {
          BOOL v23 = v10 == 0;
        }
        if (v23)
        {
          if (*v8) {
            BOOL v24 = v10 == 0;
          }
          else {
            BOOL v24 = 0;
          }
          if (v24) {
            *unint64_t v9 = 1;
          }
          *((_OWORD *)v9 + 1) = *((_OWORD *)v8 + 1);
        }
        else
        {
          *unint64_t v9 = 0;
        }
      }
      unint64_t v12 = *((void *)a1 + 1);
      if (v12 <= v6) {
        goto LABEL_65;
      }
      float v13 = *(float32x4_t **)(*(void *)a1 + 8 * v6);
      unint64_t v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6) {
          goto LABEL_66;
        }
        _Q1 = *(float32x4_t *)*(void *)(*a2 + 8 * v6);
        float32x4_t v7 = vnegq_f32(_Q1);
        float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
        v7.i32[3] = _Q1.i32[3];
        _Q3 = v13[1];
        _Q4 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), _Q1), _Q3, v16);
        float32x4_t v19 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), _Q4, 0xCuLL), _Q3, _Q1, 3), _Q1, _Q3, 3);
        _Q3.i32[0] = _Q3.i32[3];
        __asm { FMLA            S4, S3, V1.S[3] }
        v19.i32[3] = _Q4.i32[0];
        *(float32x4_t *)(*(void *)(a3 + 8 * v6) + 16) = v19;
        unint64_t v12 = *((void *)a1 + 1);
        unint64_t v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    uint64_t result = 1;
    if (v12 <= v6) {
      return result;
    }
    unint64_t v28 = v6;
    float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
    float32x4_t v30 = vnegq_f32(v7);
    _S3 = v7.i32[3];
    float32x4_t v32 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 3);
    if (a4 <= v6) {
      unint64_t v33 = v6;
    }
    else {
      unint64_t v33 = a4;
    }
    if (a4 <= v6) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = a4;
    }
    while (v6 != v28)
    {
      float32x4_t v34 = *(unsigned __int8 **)(*(void *)a1 + 8 * v28);
      float32x4_t v35 = *(unsigned __int8 **)(a3 + 8 * v28);
      int v36 = *v35;
      if ((*v34 != 0) != (*v35 != 0) && (v36 | *v34) != 0)
      {
        if (*v34) {
          BOOL v43 = 1;
        }
        else {
          BOOL v43 = v36 == 0;
        }
        if (v43)
        {
          if (*v34) {
            BOOL v44 = v36 == 0;
          }
          else {
            BOOL v44 = 0;
          }
          if (v44) {
            *float32x4_t v35 = 1;
          }
          *((_OWORD *)v35 + 1) = *((_OWORD *)v34 + 1);
        }
        else
        {
          *float32x4_t v35 = 0;
        }
      }
      unint64_t v38 = *((void *)a1 + 1);
      if (v38 <= v28) {
        goto LABEL_68;
      }
      _Q5 = *(float32x4_t *)(*(void *)(*(void *)a1 + 8 * v28) + 16);
      int8x16_t v40 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), v30), _Q5, v29);
      float32x4_t v41 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), v40, 0xCuLL), _Q5, v32), v7, _Q5, 3);
      __asm { FMLA            S7, S3, V5.S[3] }
      v41.i32[3] = _S7;
      *(float32x4_t *)(*(void *)(a3 + 8 * v28++) + 16) = v41;
      if (*((void *)a1 + 1) <= v28) {
        return 1;
      }
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v33, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v28, v38);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::GenericSRT<float>>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*((void *)a1 + 1) != a4)
  {
    float32x4_t v35 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    float32x4_t v37 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_34;
  }
  unint64_t v4 = a2;
  if (!*(void *)(a2 + 8))
  {
    float32x4_t v35 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    float32x4_t v37 = "Cannot make additive values, base values array size must not be zero.";
LABEL_34:
    _os_log_error_impl(&dword_233120000, v35, OS_LOG_TYPE_ERROR, v37, buf, 2u);
    return 0;
  }
  *(void *)buf = 0x3F8000003F800000;
  *(void *)&void buf[8] = 1065353216;
  v49.i64[0] = 0;
  v49.i64[1] = 0x3F80000000000000;
  float32x4_t v50 = 0uLL;
  if (!a4) {
    return 1;
  }
  unint64_t v8 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v47 = _Q0;
  uint64_t v13 = 1;
  do
  {
    if (a4 == v8)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
LABEL_66:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, v18);
      _os_crash();
      __break(1u);
LABEL_67:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, v20);
      _os_crash();
      __break(1u);
      goto LABEL_68;
    }
    unint64_t v14 = *(unsigned __int8 **)(*(void *)a1 + 8 * v8);
    float32x4_t v15 = *(unsigned __int8 **)(a3 + 8 * v8);
    int v16 = *v15;
    if ((*v14 != 0) != (*v15 != 0) && (v16 | *v14) != 0)
    {
      if (*v14) {
        BOOL v31 = 1;
      }
      else {
        BOOL v31 = v16 == 0;
      }
      if (v31)
      {
        if (*v14) {
          BOOL v32 = v16 == 0;
        }
        else {
          BOOL v32 = 0;
        }
        if (v32) {
          *float32x4_t v15 = 1;
        }
        long long v33 = *((_OWORD *)v14 + 1);
        long long v34 = *((_OWORD *)v14 + 3);
        *((_OWORD *)v15 + 2) = *((_OWORD *)v14 + 2);
        *((_OWORD *)v15 + 3) = v34;
        *((_OWORD *)v15 + 1) = v33;
      }
      else
      {
        *float32x4_t v15 = 0;
      }
    }
    unint64_t v18 = *((void *)a1 + 1);
    if (v18 <= v8) {
      goto LABEL_66;
    }
    uint64_t v19 = *(void *)a1;
    unint64_t v20 = *(void *)(v4 + 8);
    if (**(unsigned char **)(*(void *)a1 + 8 * v8))
    {
      if (v20 <= v8) {
        goto LABEL_67;
      }
      unint64_t v21 = *(float32x4_t **)(*(void *)v4 + 8 * v8);
      float32x4_t v22 = v21[1];
      float32x4_t v23 = v21[2];
      int8x16_t v24 = (int8x16_t)vnegq_f32(v22);
      float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL);
      v24.i32[3] = v22.i32[3];
      float32x4_t v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v22), v23, v25);
      int8x16_t v27 = (int8x16_t)vaddq_f32(v26, v26);
      float32x4_t v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), v27, 0xCuLL);
      float32x4_t v29 = vaddq_f32(v23, vmulq_laneq_f32(v28, v22, 3));
      int8x16_t v30 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v22), v28, v25);
      *(float32x4_t *)buf = vdivq_f32(v47, *v21);
      int8x16_t v49 = v24;
      float32x4_t v50 = vmulq_f32(vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL)), vnegq_f32(*(float32x4_t *)buf));
      re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(void *)(v19 + 8 * v8) + 16), (float32x4_t *)buf, (float32x4_t *)(*(void *)(a3 + 8 * v8) + 16));
      unint64_t v18 = *((void *)a1 + 1);
      unint64_t v20 = *(void *)(v4 + 8);
    }
    ++v8;
  }
  while (v18 > v8 && v20 > v8);
  if (v18 <= v8) {
    return 1;
  }
  unint64_t v4 = v8;
  if (a4 <= v8) {
    uint64_t v13 = v8;
  }
  else {
    uint64_t v13 = a4;
  }
  if (a4 <= v8) {
    unint64_t v8 = v8;
  }
  else {
    unint64_t v8 = a4;
  }
  while (v8 != v4)
  {
    unint64_t v38 = *(unsigned __int8 **)(*(void *)a1 + 8 * v4);
    long long v39 = *(unsigned __int8 **)(a3 + 8 * v4);
    int v40 = *v39;
    if ((*v38 != 0) != (*v39 != 0) && (v40 | *v38) != 0)
    {
      if (*v38) {
        BOOL v43 = 1;
      }
      else {
        BOOL v43 = v40 == 0;
      }
      if (v43)
      {
        if (*v38) {
          BOOL v44 = v40 == 0;
        }
        else {
          BOOL v44 = 0;
        }
        if (v44) {
          *long long v39 = 1;
        }
        long long v45 = *((_OWORD *)v38 + 1);
        long long v46 = *((_OWORD *)v38 + 3);
        *((_OWORD *)v39 + 2) = *((_OWORD *)v38 + 2);
        *((_OWORD *)v39 + 3) = v46;
        *((_OWORD *)v39 + 1) = v45;
      }
      else
      {
        *long long v39 = 0;
      }
    }
    unint64_t v42 = *((void *)a1 + 1);
    if (v42 <= v4) {
      goto LABEL_69;
    }
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(void *)(*(void *)a1 + 8 * v4) + 16), (float32x4_t *)buf, (float32x4_t *)(*(void *)(a3 + 8 * v4) + 16));
    if (*((void *)a1 + 1) <= ++v4) {
      return 1;
    }
  }
LABEL_68:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, a4);
  _os_crash();
  __break(1u);
LABEL_69:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, v42);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::SkeletalPose>(re *a1, void *a2, uint64_t a3, void *a4)
{
  if (*((void **)a1 + 1) != a4)
  {
    unint64_t v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    uint64_t v19 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_32;
  }
  unint64_t v4 = a2;
  if (!a2[1])
  {
    unint64_t v18 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    uint64_t v19 = "Cannot make additive values, base values array size must not be zero.";
LABEL_32:
    _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, v19, buf, 2u);
    return 0;
  }
  *(void *)buf = 0;
  unint64_t v21 = "";
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  int v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  re::SkeletalPose::init((uint64_t *)buf, (uint64_t *)(*(void *)*a2 + 80));
  unint64_t v9 = 0;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10 && v4[1])
  {
    unint64_t v9 = 0;
    while (a4 != (void *)v9)
    {
      unint64_t v8 = *(uint64_t **)(*(void *)a1 + 8 * v9);
      float v11 = *(unsigned __int8 **)(a3 + 8 * v9);
      if ((*(unsigned char *)v8 != 0) != (*v11 != 0))
      {
        re::Optional<re::SkeletalPose>::operator=(v11, v8);
        unint64_t v10 = *((void *)a1 + 1);
      }
      if (v10 <= v9) {
        goto LABEL_34;
      }
      unint64_t v12 = v4[1];
      if (**(unsigned char **)(*(void *)a1 + 8 * v9))
      {
        if (v12 <= v9) {
          goto LABEL_37;
        }
        re::AnimationValueTraits<re::SkeletalPose>::invert(*(void **)(*v4 + 8 * v9), buf);
        unint64_t v14 = *((void *)a1 + 1);
        if (v14 <= v9) {
          goto LABEL_38;
        }
        re::AnimationValueTraits<re::SkeletalPose>::combine((void *)(*(void *)(*(void *)a1 + 8 * v9) + 8), buf, (void *)(*(void *)(a3 + 8 * v9) + 8));
        unint64_t v10 = *((void *)a1 + 1);
        unint64_t v12 = v4[1];
      }
      if (v10 <= ++v9 || v12 <= v9)
      {
        unint64_t v9 = v9;
        goto LABEL_17;
      }
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
    _os_crash();
    __break(1u);
LABEL_34:
    re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v10);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_17:
    if (v10 <= v9)
    {
LABEL_26:
      re::SkeletalPose::deinit((re::SkeletalPose *)buf);
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)buf);
      return 1;
    }
    if ((unint64_t)a4 <= v9) {
      unint64_t v4 = (void *)v9;
    }
    else {
      unint64_t v4 = a4;
    }
    while (v4 != (void *)v9)
    {
      float32x4_t v15 = *(uint64_t **)(*(void *)a1 + 8 * v9);
      int v16 = *(unsigned __int8 **)(a3 + 8 * v9);
      if ((*(unsigned char *)v15 != 0) != (*v16 != 0))
      {
        re::Optional<re::SkeletalPose>::operator=(v16, v15);
        unint64_t v10 = *((void *)a1 + 1);
      }
      if (v10 <= v9) {
        goto LABEL_36;
      }
      re::AnimationValueTraits<re::SkeletalPose>::combine((void *)(*(void *)(*(void *)a1 + 8 * v9) + 8), buf, (void *)(*(void *)(a3 + 8 * v9) + 8));
      ++v9;
      unint64_t v10 = *((void *)a1 + 1);
      if (v10 <= v9) {
        goto LABEL_26;
      }
    }
  }
  re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  _os_crash();
  __break(1u);
LABEL_36:
  re::internal::assertLog((re::internal *)6, (uint64_t)v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v10);
  _os_crash();
  __break(1u);
LABEL_37:
  re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v12);
  _os_crash();
  __break(1u);
LABEL_38:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v14);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::OrbitAnimation::OrbitAnimation(re::OrbitAnimation *this)
{
  uint64_t v1 = re::Timeline::Timeline((uint64_t)this, 37);
  *(unsigned char *)(v1 + 72) = 0;
  *(void *)uint64_t v1 = &unk_26E6C3728;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v1 + 76) = _D0;
  *(_WORD *)(v1 + 84) = 1;
  *(_OWORD *)(v1 + 96) = xmmword_23435FD60;
  *(_DWORD *)(v1 + 112) = 0;
  *(void *)(v1 + 128) = 0x3F8000003F800000;
  *(void *)(v1 + 136) = 1065353216;
  *(void *)(v1 + 144) = 0;
  *(void *)(v1 + 152) = 0x3F80000000000000;
  double result = 0.0;
  *(_OWORD *)(v1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0u;
  *(void *)(v1 + 176) = 0x3F8000003F800000;
  *(void *)(v1 + 184) = 1065353216;
  *(void *)(v1 + 192) = 0;
  *(void *)(v1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = 0x3F80000000000000;
  *(_OWORD *)(v1 + 208) = 0u;
  return result;
}

float32x4_t re::OrbitAnimation::computeOrbitTransform(float32x4_t *a1, uint64_t a2, float a3)
{
  float v5 = a1[7].f32[0] + (float)((float)(a3 * 6.2832) * a1[5].f32[0]);
  float v6 = -v5;
  if (!a1[5].i8[4]) {
    float v6 = v5;
  }
  float32x4_t v7 = a1[6];
  float32x4_t v8 = vmulq_f32(v7, v7);
  LODWORD(vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u32[0];
  if (fabsf(v9) >= 1.0e-10)
  {
    float v10 = v9;
    float32x2_t v11 = vrsqrte_f32((float32x2_t)LODWORD(v9));
    float32x2_t v12 = vmul_f32(v11, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v11, v11)));
    float32x4_t v7 = vmulq_n_f32(v7, vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v12, v12))).f32[0]);
  }
  float32x4_t v66 = v7;
  _KR00_8 = __sincosf_stret(v6 * 0.5);
  *(float32x2_t *)v14.f32 = vmul_n_f32(*(float32x2_t *)v66.f32, _KR00_8.__sinval);
  v14.i32[2] = vmuls_lane_f32(_KR00_8.__sinval, v66, 2);
  float32x4_t v15 = v14;
  v15.i32[3] = LODWORD(_KR00_8.__cosval);
  if (a1[4].i8[8])
  {
    _Q3 = a1[12];
    float32x4_t v17 = a1[13];
    __asm { FMOV            V5.4S, #1.0 }
    float32x4_t v23 = a1[10];
    float32x4_t v24 = vdivq_f32(_Q5, a1[11]);
    int32x4_t v25 = (int32x4_t)vnegq_f32(_Q3);
    float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v25, v25), (int8x16_t)v25, 0xCuLL);
    float32x4_t v27 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), _Q3), v17, v26);
    int32x4_t v28 = (int32x4_t)vaddq_f32(v27, v27);
    float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v28, v28), (int8x16_t)v28, 0xCuLL);
    int32x4_t v30 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL), _Q3), v29, v26);
    float32x4_t v31 = vaddq_f32(vaddq_f32(v17, vmulq_laneq_f32(v29, _Q3, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v30, v30), (int8x16_t)v30, 0xCuLL));
    int32x4_t v32 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), _Q3), v14, v26);
    float32x4_t v33 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v32, v32), (int8x16_t)v32, 0xCuLL), v14, _Q3, 3), _Q3, v15, 3);
    __asm { FMLA            S2, S1, V3.S[3] }
    float32x4_t v35 = vmlaq_f32(vmulq_f32(_Q3, (float32x4_t)0), (float32x4_t)0, v26);
    int32x4_t v36 = (int32x4_t)vaddq_f32(v35, v35);
    _Q1 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v36, v36), (int8x16_t)v36, 0xCuLL);
    float32x4_t v38 = vaddq_f32(vmulq_laneq_f32(_Q1, _Q3, 3), (float32x4_t)0);
    int32x4_t v39 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL), _Q3), _Q1, v26);
    float32x4_t v40 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL));
    _Q6 = a1[9];
    float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL);
    float32x4_t v43 = vnegq_f32(v33);
    int32x4_t v44 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q6, (int32x4_t)_Q6), (int8x16_t)_Q6, 0xCuLL), v43), _Q6, v42);
    int8x16_t v47 = (int8x16_t)vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL), _Q6, _S2), v33, _Q6, 3);
    float32x4_t v45 = vsubq_f32(vmulq_f32(v24, v40), vmulq_f32(v24, v31));
    float32x4_t v46 = vmulq_f32(a1[8], v24);
    __asm { FMLA            S1, S2, V6.S[3] }
    v47.i32[3] = _Q1.i32[0];
    float32x4_t v48 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v43), v23, v42);
    int32x4_t v49 = (int32x4_t)vaddq_f32(v48, v48);
    float32x4_t v50 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v49, v49), (int8x16_t)v49, 0xCuLL);
    float32x4_t v51 = vaddq_f32(v23, vmulq_n_f32(v50, _S2));
    int32x4_t v52 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v50, 0xCuLL), v43), v50, v42);
    float32x4_t v53 = vmulq_f32(v24, vaddq_f32(v51, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v52, v52), (int8x16_t)v52, 0xCuLL)));
    _Q5 = (float32x4_t)xmmword_23435FBB0;
  }
  else
  {
    float32x4_t v46 = a1[8];
    _Q5 = a1[9];
    float32x4_t v55 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL);
    float32x4_t v56 = vnegq_f32(v14);
    int32x4_t v57 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), v56), _Q5, v55);
    int8x16_t v47 = (int8x16_t)vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v57, v57), (int8x16_t)v57, 0xCuLL), _Q5, v15, 3), v14, _Q5, 3);
    __asm { FMLA            S2, S1, V5.S[3] }
    v47.i32[3] = _S2;
    float32x4_t v59 = a1[10];
    float32x4_t v60 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), (int8x16_t)v59, 0xCuLL), v56), v59, v55);
    int32x4_t v61 = (int32x4_t)vaddq_f32(v60, v60);
    float32x4_t v62 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v61, v61), (int8x16_t)v61, 0xCuLL);
    float32x4_t v63 = vaddq_f32(v59, vmulq_laneq_f32(v62, v15, 3));
    int32x4_t v64 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL), v56), v62, v55);
    float32x4_t v51 = (float32x4_t)vuzp1q_s32(v64, v64);
    float32x4_t v45 = vaddq_f32(v63, (float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v64, 0xCuLL));
    float32x4_t v53 = 0uLL;
  }
  v51.i32[0] = 0;
  float32x4_t result = vaddq_f32(v53, v45);
  v53.i8[0] = a1[5].i8[5];
  *(float32x4_t *)a2 = v46;
  *(int8x16_t *)(a2 + 16) = vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8((int8x16_t)v53, (int8x16_t)v51), 0), (int8x16_t)_Q5, v47);
  *(float32x4_t *)(a2 + 32) = result;
  return result;
}

void re::OrbitAnimation::evaluateCore(float32x4_t *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  if (a3)
  {
    float v6 = *(double *)(a2 + 24) / a1[4].f32[3];
    re::OrbitAnimation::computeOrbitTransform(a1, a6, v6);
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

void re::OrbitAnimation::~OrbitAnimation(re::OrbitAnimation *this)
{
  *(void *)this = &unk_26E6BF1F0;
  uint64_t v1 = (re::OrbitAnimation *)((char *)this + 24);
  re::DynamicString::deinit((re::OrbitAnimation *)((char *)this + 40));
  re::StringID::destroyString(v1);
}

{
  re::StringID *v1;
  uint64_t vars8;

  *(void *)this = &unk_26E6BF1F0;
  uint64_t v1 = (re::OrbitAnimation *)((char *)this + 24);
  re::DynamicString::deinit((re::OrbitAnimation *)((char *)this + 40));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

double re::OrbitAnimation::totalDuration(re::OrbitAnimation *this)
{
  return *((float *)this + 19);
}

uint64_t re::EvaluationOutputHandle<re::Matrix4x4<float>>::bindEvaluationOutput<re::Matrix4x4<float>>(void *a1, const re::IntrospectionBase *a2, char a3)
{
  {
    float32x4_t v8 = a2;
    a2 = v8;
    if (v9)
    {
      re::introspect<re::Matrix4x4<float>>(void)::info = (_UNKNOWN *)re::introspect_Matrix4x4F(0);
      a2 = v8;
    }
  }
  re::makeBindPoint((re *)re::introspect<re::Matrix4x4<float>>(void)::info, a2, (uint64_t)&v10);
  float v5 = (void *)*a1;
  uint64_t v12 = v10;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v13, v11);
  uint64_t v6 = re::EvaluationContextManager::bindOutputHandle<re::Matrix4x4<float>>(v5, (uint64_t)a1, &v12, a3);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11);
  return v6;
}

void re::FixedArray<re::EvaluationOutputHandle<re::GenericSRT<float>>>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 16 * a3;
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  float32x4_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    float32x4_t v8 = (void *)((char *)v8 + v5 - 16);
  }
  void *v8 = 0;
  v8[1] = 0;
}

void *re::RigEvaluation::init@<X0>(re::RigEvaluation *this@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  re::RigEvaluation::initRigDefinitionData(this, a2, a3, (uint64_t)v9);
  if (v9[0])
  {
    *(void *)this = a2;
    re::RigDefinition::operator=((uint64_t)this + 8, (uint64_t)a3);
    re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 1224, (uint64_t)a2, 3);
    *((void *)this + 186) = a2;
    float32x4_t result = re::DynamicArray<re::internal::RigIKCall>::setCapacity((void *)this + 186, 0);
    ++*((_DWORD *)this + 378);
    *(unsigned char *)a4 = 1;
  }
  else
  {
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v10;
    float32x4_t result = re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v11);
  }
  if (!v9[0])
  {
    float32x4_t result = (void *)v11;
    if (v11)
    {
      if (v12) {
        return (void *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::RigEvaluation::initRigDefinitionData@<X0>(re::RigEvaluation *this@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = (unint64_t *)a3;
  uint64_t v7 = a2;
  uint64_t v150 = *MEMORY[0x263EF8340];
  re::validateRigDefinitionData(a2, a3, (uint64_t)v131);
  if (!v131[0])
  {
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v132;
    uint64_t result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v133);
    goto LABEL_140;
  }
  re::FixedArray<re::FixedArray<float>>::init<>((uint64_t *)this + 168, (uint64_t)v7, v6[95]);
  re::FixedArray<re::FixedArray<float>>::init<>((uint64_t *)this + 171, (uint64_t)v7, v6[95]);
  re::FixedArray<re::TwoBoneIKOptions>::init<>((uint64_t *)this + 174, (uint64_t)v7, v6[95]);
  re::FixedArray<re::FABRIKOptions>::init<>((void *)this + 177, (uint64_t)v7, v6[100]);
  re::FixedArray<re::SplineIKOptions>::init<>((uint64_t)this + 1440, (uint64_t)v7, v6[105]);
  re::FixedArray<re::internal::RigIKCall>::init<>((uint64_t *)this + 165, (uint64_t)v7, v6[125]);
  unint64_t v11 = v6[125];
  *((void *)this + 183) = v7;
  *((void *)this + 184) = v11;
  uint64_t v115 = a4;
  uint64_t v120 = v7;
  uint64_t v121 = v6;
  if (v11)
  {
    if (v11 >> 60) {
      goto LABEL_175;
    }
    uint64_t v12 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)v7 + 32))(v7, 16 * v11, 8);
    *((void *)this + 185) = v12;
    if (!v12)
    {
LABEL_176:
      re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_177:
      re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) Unexpected Rig IK Handle Type: %u.", "!\"Unreachable code\"", "initRigDefinitionData", 1748, v18);
      _os_crash();
      __break(1u);
    }
    unint64_t v14 = v11 - 1;
    if (v11 != 1)
    {
      do
      {
        *(unsigned char *)uint64_t v12 = 0;
        *(void *)(v12 + 8) = -1;
        v12 += 16;
        --v14;
      }
      while (v14);
    }
    *(unsigned char *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = -1;
    if (v6[125])
    {
      unint64_t v15 = 0;
      int v16 = (char *)&v139[1];
      unint64_t v116 = this;
      do
      {
        unint64_t v17 = v6[127];
        uint64_t v18 = *(unsigned __int8 *)(v17 + 16 * v15);
        switch(v18)
        {
          case 3:
            unint64_t v54 = v17 + 16 * v15;
            float32x4_t v56 = *(char ***)(v54 + 8);
            float32x4_t v55 = (char **)(v54 + 8);
            unint64_t v4 = v56;
            unint64_t v20 = v6[105];
            if (v20 <= (unint64_t)v56) {
              goto LABEL_153;
            }
            int32x4_t v57 = (char **)*((void *)this + 181);
            if (v57 <= v4) {
              goto LABEL_155;
            }
            unint64_t v58 = v6[107];
            unint64_t v59 = v58 + 240 * (void)v4;
            uint64_t v60 = *((void *)this + 182) + 80 * (void)v4;
            *(float *)uint64_t v60 = *(float *)v59 * *(float *)v59;
            uint64_t v61 = *(void *)(v59 + 120);
            uint64_t v62 = *(void *)(v59 + 104);
            *(void *)(v60 + 8) = v61;
            *(void *)(v60 + 16) = v62;
            long long v22 = *v55;
            int v16 = (char *)*((void *)this + 181);
            if (v16 <= *v55) {
              goto LABEL_157;
            }
            unint64_t v63 = v58 + 240 * (void)v4;
            uint64_t v64 = *((void *)this + 182);
            *(_DWORD *)(v64 + 80 * (void)v22 + 64) = *(_DWORD *)(v63 + 224);
            unint64_t v65 = *(void *)(v63 + 64);
            if (*(void *)(v63 + 160) != -1)
            {
              ++v65;
              uint64_t v66 = v64 + 80 * (void)v22;
              *(unsigned char *)(v66 + 24) = 1;
              *(_OWORD *)(v66 + 32) = *(_OWORD *)(v58 + 240 * (void)v4 + 176);
            }
            uint64_t v123 = v4;
            unint64_t v119 = v58;
            if (*(void *)(v58 + 240 * (void)v4 + 168) != -1)
            {
              long long v22 = *v55;
              int v16 = (char *)*((void *)this + 181);
              if (v16 <= *v55) {
                goto LABEL_174;
              }
              ++v65;
              uint64_t v67 = *((void *)this + 182) + 80 * (void)v22;
              *(unsigned char *)(v67 + 25) = 1;
              *(_OWORD *)(v67 + 48) = *(_OWORD *)(v58 + 240 * (void)v4 + 192);
            }
            *(void *)&long long v136 = re::solverSplineIK;
            int v16 = (char *)&v136 + 8;
            long long v137 = 0uLL;
            *((void *)&v136 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v136 + 1, (uint64_t)v7, 1uLL);
            long long v138 = 0uLL;
            v139[0] = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v138, (uint64_t)v7, 1uLL);
            uint64_t v5 = (char *)&v139[1];
            memset(&v139[1], 0, 24);
            *(void *)uint64_t v140 = v65;
            memset(&v140[8], 0, 32);
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v140[16], (uint64_t)v7, v65);
            *(void *)&long long v141 = 0;
            *((void *)&v141 + 1) = v15;
            long long v22 = (char *)*((void *)this + 166);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_160;
            }
            uint64_t v68 = *((void *)this + 167) + 136 * v15;
            *(void *)uint64_t v68 = v136;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 8), (uint64_t *)&v136 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 32), (uint64_t *)&v138);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 56), &v139[1]);
            *(_OWORD *)(v68 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)v140;
            re::FixedArray<float>::operator=((uint64_t *)(v68 + 96), (uint64_t *)&v140[16]);
            *(_OWORD *)(v68 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v141;
            uint64_t v6 = v121;
            if (*(void *)&v140[16])
            {
              if (*(void *)&v140[24])
              {
                (*(void (**)(void))(**(void **)&v140[16] + 40))();
                *(void *)&v140[24] = 0;
                *(void *)&v140[32] = 0;
              }
              *(void *)&v140[16] = 0;
            }
            unint64_t v4 = (char **)v140;
            if (v139[1])
            {
              if (v139[2])
              {
                (*(void (**)(void))(*(void *)v139[1] + 40))();
                v139[2] = 0;
                v139[3] = 0;
              }
              v139[1] = 0;
            }
            if ((void)v138)
            {
              if (*((void *)&v138 + 1))
              {
                (*(void (**)(void))(*(void *)v138 + 40))();
                *((void *)&v138 + 1) = 0;
                v139[0] = 0;
              }
              *(void *)&long long v138 = 0;
            }
            if (*((void *)&v136 + 1) && (void)v137) {
              (*(void (**)(void))(**((void **)&v136 + 1) + 40))();
            }
            long long v22 = (char *)*((void *)this + 166);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_161;
            }
            uint64_t v69 = *((void *)this + 167);
            if (!*(void *)(v69 + 136 * v15 + 16)) {
              goto LABEL_162;
            }
            **(void **)(v69 + 136 * v15 + 24) = *(void *)(v119 + 240 * (void)v123 + 128);
            long long v22 = (char *)*((void *)this + 166);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_163;
            }
            if (!*(void *)(v69 + 136 * v15 + 40)) {
              goto LABEL_164;
            }
            **(void **)(v69 + 136 * v15 + 48) = *(void *)(v119 + 240 * (void)v123 + 136);
            long long v22 = (char *)*((void *)this + 184);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_165;
            }
            uint64_t v70 = *v55;
            uint64_t v71 = *((void *)this + 185) + 16 * v15;
            *(unsigned char *)uint64_t v71 = 3;
            *(void *)(v71 + 8) = v70;
            break;
          case 2:
            unint64_t v72 = v17 + 16 * v15;
            double v74 = *(char **)(v72 + 8);
            uint64_t v73 = (uint64_t *)(v72 + 8);
            long long v22 = v74;
            int v16 = (char *)v6[100];
            if (v16 <= v74) {
              goto LABEL_154;
            }
            int v16 = (char *)*((void *)this + 178);
            if (v16 <= v22) {
              goto LABEL_156;
            }
            int v124 = v73;
            unint64_t v75 = v6[102] + ((void)v22 << 7);
            uint64_t v76 = (uint64_t)v7;
            unint64_t v77 = *(void *)(v75 + 96);
            *(_DWORD *)(*((void *)this + 179) + 8 * (void)v22) = *(_DWORD *)(v75 + 120);
            *(void *)&long long v136 = re::solverFABRIK;
            long long v129 = 0uLL;
            unint64_t v78 = *(void *)(v75 + 16);
            *(void *)&long long v129 = *(void *)(v75 + 32);
            *((void *)&v129 + 1) = v78;
            long long v137 = 0uLL;
            *((void *)&v136 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v136 + 1, v76, v78);
            re::FixedArray<unsigned long>::copy((void *)&v136 + 1, (const void **)&v129);
            uint64_t v127 = 0;
            unint64_t v128 = 0;
            unint64_t v79 = *(void *)(v75 + 56);
            uint64_t v127 = *(const void **)(v75 + 72);
            unint64_t v128 = v79;
            v139[0] = 0;
            long long v138 = 0uLL;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v138, v76, v79);
            re::FixedArray<unsigned long>::copy(&v138, &v127);
            uint64_t v125 = 0;
            unint64_t v126 = 0;
            unint64_t v80 = *(void *)(v75 + 96);
            uint64_t v125 = *(const void **)(v75 + 112);
            unint64_t v126 = v80;
            memset(&v139[1], 0, 24);
            re::FixedArray<unsigned long>::init<>(&v139[1], v76, v80);
            re::FixedArray<unsigned long>::copy(&v139[1], &v125);
            memset(v140, 0, sizeof(v140));
            int v16 = &v140[16];
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v140[16], v76, v77);
            long long v141 = 0uLL;
            long long v22 = (char *)*((void *)this + 166);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_158;
            }
            uint64_t v5 = (char *)v15;
            uint64_t v81 = *((void *)this + 167) + 136 * v15;
            *(void *)uint64_t v81 = v136;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v81 + 8), (uint64_t *)&v136 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v81 + 32), (uint64_t *)&v138);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v81 + 56), &v139[1]);
            unint64_t v4 = (char **)v140;
            *(_OWORD *)(v81 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)v140;
            re::FixedArray<float>::operator=((uint64_t *)(v81 + 96), (uint64_t *)&v140[16]);
            *(_OWORD *)(v81 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v141;
            uint64_t v7 = v120;
            uint64_t v6 = v121;
            if (*(void *)&v140[16])
            {
              if (*(void *)&v140[24])
              {
                (*(void (**)(void))(**(void **)&v140[16] + 40))();
                *(void *)&v140[24] = 0;
                *(void *)&v140[32] = 0;
              }
              *(void *)&v140[16] = 0;
            }
            this = v116;
            if (v139[1])
            {
              if (v139[2])
              {
                (*(void (**)(void))(*(void *)v139[1] + 40))();
                v139[2] = 0;
                v139[3] = 0;
              }
              v139[1] = 0;
            }
            if ((void)v138)
            {
              if (*((void *)&v138 + 1))
              {
                (*(void (**)(void))(*(void *)v138 + 40))();
                *((void *)&v138 + 1) = 0;
                v139[0] = 0;
              }
              *(void *)&long long v138 = 0;
            }
            if (*((void *)&v136 + 1) && (void)v137) {
              (*(void (**)(void))(**((void **)&v136 + 1) + 40))();
            }
            long long v22 = (char *)*((void *)v116 + 184);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_159;
            }
            uint64_t v82 = *v124;
            uint64_t v83 = *((void *)v116 + 185) + 16 * v15;
            *(unsigned char *)uint64_t v83 = 2;
            *(void *)(v83 + 8) = v82;
            break;
          case 1:
            unint64_t v19 = v17 + 16 * v15;
            unint64_t v21 = *(char **)(v19 + 8);
            unint64_t v4 = (char **)(v19 + 8);
            unint64_t v20 = (unint64_t)v21;
            long long v22 = (char *)v6[95];
            if (v22 <= v21) {
              goto LABEL_152;
            }
            unint64_t v122 = v6[97];
            uint64_t v23 = (uint64_t)v7;
            unint64_t v24 = v122 + 240 * v20;
            float32x4_t v26 = *(char **)(v24 + 96);
            int32x4_t v25 = (char **)(v24 + 96);
            long long v22 = v26;
            long long v129 = 0uLL;
            uint64_t v130 = 0;
            unint64_t v117 = v122 + 240 * v20;
            unint64_t v118 = 2 * (void)v26;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v129, v23, 2 * (void)v26);
            if (v26)
            {
              int v16 = 0;
              unint64_t v27 = 0;
              int32x4_t v28 = (void *)(v122 + 240 * v20);
              float32x4_t v29 = v28 + 14;
              uint64_t v30 = v130;
              float32x4_t v31 = v28 + 17;
              int32x4_t v32 = v28 + 19;
              while (1)
              {
                uint64_t v5 = *v25;
                if ((unint64_t)*v25 <= v27) {
                  break;
                }
                uint64_t v5 = (char *)*((void *)&v129 + 1);
                if (*((void *)&v129 + 1) <= (unint64_t)v16) {
                  goto LABEL_146;
                }
                *(void *)(v30 + 8 * (void)v16) = *(void *)(*v29 + 8 * v27);
                uint64_t v5 = (char *)*v31;
                if (*v31 <= v27) {
                  goto LABEL_147;
                }
                uint64_t v6 = (unint64_t *)(v16 + 1);
                uint64_t v5 = (char *)*((void *)&v129 + 1);
                if (*((void *)&v129 + 1) <= (unint64_t)(v16 + 1)) {
                  goto LABEL_148;
                }
                *(void *)(v30 + 8 * (void)v16 + 8) = *(void *)(*v32 + 8 * v27++);
                v16 += 2;
                if (v22 == (char *)v27) {
                  goto LABEL_20;
                }
              }
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v27;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_146:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_147:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v27;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_148:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v6;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_149:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_150:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_151:
              *(void *)__int16 v142 = 0;
              unint64_t v20 = (unint64_t)&v136;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v25;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_152:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v20;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_153:
              *(void *)__int16 v142 = 0;
              long long v22 = (char *)&v136;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v4;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v20;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_154:
              *(void *)__int16 v142 = 0;
              int32x4_t v57 = (char **)&v136;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 797;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_155:
              *(void *)__int16 v142 = 0;
              long long v22 = (char *)&v136;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v4;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v57;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_156:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_157:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              unint64_t v15 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_158:
              uint64_t v135 = 0;
              long long v148 = 0u;
              long long v149 = 0u;
              memset(v147, 0, sizeof(v147));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)__int16 v142 = 136315906;
              *(void *)&v142[4] = "operator[]";
              *(_WORD *)&v142[12] = 1024;
              *(_DWORD *)&v142[14] = 468;
              __int16 v143 = 2048;
              unint64_t v144 = v15;
              __int16 v145 = 2048;
              int32x4_t v146 = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_159:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v15;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_160:
              *(void *)&long long v129 = 0;
              long long v148 = 0u;
              long long v149 = 0u;
              memset(v147, 0, sizeof(v147));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)__int16 v142 = 136315906;
              *(void *)&v142[4] = "operator[]";
              *(_WORD *)&v142[12] = 1024;
              *(_DWORD *)&v142[14] = 468;
              __int16 v143 = 2048;
              unint64_t v144 = v15;
              __int16 v145 = 2048;
              int32x4_t v146 = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_161:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v15;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_162:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              unint64_t v15 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = 0;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_163:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v15;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_164:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              unint64_t v15 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = 0;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_165:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v15;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_166:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_167:
              uint64_t v127 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_168:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_169:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_170:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_171:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              unint64_t v15 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v16;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_172:
              uint64_t v135 = 0;
              long long v148 = 0u;
              long long v149 = 0u;
              memset(v147, 0, sizeof(v147));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)__int16 v142 = 136315906;
              *(void *)&v142[4] = "operator[]";
              *(_WORD *)&v142[12] = 1024;
              *(_DWORD *)&v142[14] = 468;
              __int16 v143 = 2048;
              unint64_t v144 = v15;
              __int16 v145 = 2048;
              int32x4_t v146 = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_173:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v15;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v22;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_174:
              *(void *)__int16 v142 = 0;
              memset(v139, 0, sizeof(v139));
              long long v137 = 0u;
              long long v138 = 0u;
              long long v136 = 0u;
              unint64_t v11 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v147[0]) = 136315906;
              *(void *)((char *)v147 + 4) = "operator[]";
              WORD2(v147[1]) = 1024;
              *(_DWORD *)((char *)&v147[1] + 6) = 468;
              WORD1(v147[2]) = 2048;
              *(void *)((char *)&v147[2] + 4) = v22;
              WORD2(v147[3]) = 2048;
              *(void *)((char *)&v147[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_175:
              re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v11);
              _os_crash();
              __break(1u);
              goto LABEL_176;
            }
LABEL_20:
            long long v22 = *v4;
            int v16 = (char *)*((void *)this + 169);
            if (v16 <= *v4) {
              goto LABEL_166;
            }
            unint64_t v33 = v122 + 240 * v20;
            unint64_t v36 = *(void *)(v33 + 176);
            long long v34 = (char **)(v33 + 176);
            float32x4_t v35 = (char **)v36;
            re::FixedArray<int>::init<>((uint64_t *)(*((void *)this + 170) + 24 * (void)v22), (uint64_t)v120, v36);
            if (v36)
            {
              int32x4_t v25 = 0;
              int v16 = *v34;
              while (v16 != (char *)v25)
              {
                long long v22 = *v4;
                uint64_t v5 = (char *)*((void *)this + 169);
                if (v5 <= *v4) {
                  goto LABEL_150;
                }
                uint64_t v37 = *((void *)this + 170);
                uint64_t v5 = *(char **)(v37 + 24 * (void)v22 + 8);
                if (v5 <= (char *)v25) {
                  goto LABEL_151;
                }
                *(float *)(*(void *)(v37 + 24 * (void)v22 + 16) + 4 * (void)v25) = *(float *)(*(void *)(v122 + 240 * v20 + 192) + 4 * (void)v25)
                                                                                           * 0.017453;
                int32x4_t v25 = (char **)((char *)v25 + 1);
                if (v35 == v25) {
                  goto LABEL_27;
                }
              }
              goto LABEL_149;
            }
LABEL_27:
            unint64_t v38 = v122 + 240 * v20;
            *(void *)__int16 v142 = 0;
            *(void *)&v142[8] = 0;
            uint64_t v39 = *(void *)(v38 + 232);
            uint64_t v40 = *(void *)(v38 + 216);
            *(void *)__int16 v142 = v39;
            *(void *)&v142[8] = v40;
            long long v22 = *v4;
            int v16 = (char *)*((void *)this + 172);
            if (v16 <= *v4) {
              goto LABEL_167;
            }
            re::FixedArray<int>::operator=((_anonymous_namespace_ *)(*((void *)this + 173) + 24 * (void)v22), (uint64_t)v142);
            int v16 = *v4;
            long long v22 = (char *)*((void *)this + 169);
            if (v22 <= *v4) {
              goto LABEL_168;
            }
            long long v22 = (char *)*((void *)this + 175);
            if (v22 <= v16) {
              goto LABEL_169;
            }
            uint64_t v41 = *((void *)this + 170) + 24 * (void)v16;
            uint64_t v42 = *(void *)(v41 + 8);
            uint64_t v43 = *((void *)this + 176) + 32 * (void)v16;
            *(void *)(v43 + 16) = *(void *)(v41 + 16);
            *(void *)(v43 + 24) = v42;
            int v16 = *v4;
            long long v22 = (char *)*((void *)this + 172);
            if (v22 <= *v4) {
              goto LABEL_170;
            }
            long long v22 = (char *)*((void *)this + 175);
            if (v22 <= v16) {
              goto LABEL_171;
            }
            uint64_t v44 = *((void *)this + 173) + 24 * (void)v16;
            uint64_t v45 = *(void *)(v44 + 8);
            float32x4_t v46 = (void *)(*((void *)this + 176) + 32 * (void)v16);
            *float32x4_t v46 = *(void *)(v44 + 16);
            v46[1] = v45;
            *(void *)&long long v136 = re::solverTwoBoneIK;
            uint64_t v127 = 0;
            unint64_t v128 = 0;
            unint64_t v47 = *(void *)(v117 + 16);
            uint64_t v127 = *(const void **)(v117 + 32);
            unint64_t v128 = v47;
            uint64_t v5 = (char *)&v136 + 8;
            long long v137 = 0uLL;
            *((void *)&v136 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v136 + 1, (uint64_t)v120, v47);
            re::FixedArray<unsigned long>::copy((void *)&v136 + 1, &v127);
            unint64_t v48 = v122 + 240 * v20;
            uint64_t v125 = 0;
            unint64_t v126 = 0;
            unint64_t v49 = *(void *)(v48 + 56);
            uint64_t v125 = *(const void **)(v48 + 72);
            unint64_t v126 = v49;
            int v16 = (char *)&v138;
            v139[0] = 0;
            long long v138 = 0uLL;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v138, (uint64_t)v120, v49);
            re::FixedArray<unsigned long>::copy(&v138, &v125);
            *(_OWORD *)&v139[1] = v129;
            uint64_t v50 = v130;
            uint64_t v130 = 0;
            long long v129 = 0uLL;
            v139[3] = v50;
            memset(v140, 0, sizeof(v140));
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v140[16], (uint64_t)v120, v118);
            long long v141 = 0uLL;
            long long v22 = (char *)*((void *)this + 166);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_172;
            }
            uint64_t v51 = *((void *)this + 167) + 136 * v15;
            *(void *)uint64_t v51 = v136;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 8), (uint64_t *)&v136 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 32), (uint64_t *)&v138);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 56), &v139[1]);
            *(_OWORD *)(v51 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)v140;
            re::FixedArray<float>::operator=((uint64_t *)(v51 + 96), (uint64_t *)&v140[16]);
            *(_OWORD *)(v51 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v141;
            uint64_t v7 = v120;
            uint64_t v6 = v121;
            if (*(void *)&v140[16])
            {
              if (*(void *)&v140[24])
              {
                (*(void (**)(void))(**(void **)&v140[16] + 40))();
                *(void *)&v140[24] = 0;
                *(void *)&v140[32] = 0;
              }
              *(void *)&v140[16] = 0;
            }
            if (v139[1])
            {
              if (v139[2])
              {
                (*(void (**)(void))(*(void *)v139[1] + 40))();
                v139[2] = 0;
                v139[3] = 0;
              }
              v139[1] = 0;
            }
            if ((void)v138)
            {
              if (*((void *)&v138 + 1))
              {
                (*(void (**)(void))(*(void *)v138 + 40))();
                *((void *)&v138 + 1) = 0;
                v139[0] = 0;
              }
              *(void *)&long long v138 = 0;
            }
            if (*((void *)&v136 + 1) && (void)v137) {
              (*(void (**)(void))(**((void **)&v136 + 1) + 40))();
            }
            long long v22 = (char *)*((void *)this + 184);
            if ((unint64_t)v22 <= v15) {
              goto LABEL_173;
            }
            int32x4_t v52 = *v4;
            uint64_t v53 = *((void *)this + 185) + 16 * v15;
            *(unsigned char *)uint64_t v53 = 1;
            *(void *)(v53 + 8) = v52;
            if ((void)v129 && *((void *)&v129 + 1)) {
              (*(void (**)(void))(*(void *)v129 + 40))();
            }
            break;
          default:
            goto LABEL_177;
        }
        ++v15;
      }
      while (v15 < v6[125]);
    }
  }
  unint64_t v84 = v6[130];
  if (v84)
  {
    re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 1176, (uint64_t)v7, 4 * v84);
    unint64_t v84 = v6[130];
  }
  v147[0] = 0;
  if (!v84)
  {
    unint64_t v102 = 0;
    goto LABEL_139;
  }
  unint64_t v85 = 0;
  int v86 = (void *)((char *)this + 1176);
  while (1)
  {
    uint64_t v87 = v6[132] + 56 * v85;
    long long v90 = *(char **)(v87 + 8);
    uint64_t v89 = (char **)(v87 + 8);
    long long v88 = v90;
    size_t v91 = re::RigEvaluation::HashString::operator()((int)&v136, v90);
    if (*v86)
    {
      uint64_t v92 = *(unsigned int *)(*((void *)this + 148) + 4 * (v91 % *((unsigned int *)this + 300)));
      if (v92 != 0x7FFFFFFF) {
        break;
      }
    }
LABEL_113:
    uint64_t v95 = *v89;
    *(void *)&long long v136 = v95;
    size_t v96 = re::RigEvaluation::HashString::operator()((int)v142, v95);
    unint64_t v97 = v96;
    if (*v86)
    {
      unint64_t v98 = v96 % *((unsigned int *)this + 300);
      uint64_t v99 = *(unsigned int *)(*((void *)this + 148) + 4 * v98);
      if (v99 != 0x7FFFFFFF)
      {
        uint64_t v100 = *((void *)this + 149);
        do
        {
          uint64_t v101 = v100 + 32 * v99;
          if (!strcmp(*(const char **)(v101 + 16), v95)) {
            goto LABEL_121;
          }
          uint64_t v99 = *(_DWORD *)(v101 + 8) & 0x7FFFFFFF;
        }
        while (v99 != 0x7FFFFFFF);
      }
    }
    else
    {
      LODWORD(v98) = 0;
    }
    re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>((uint64_t)this + 1176, v98, v97, &v136, v147);
    ++*((_DWORD *)this + 304);
LABEL_121:
    v147[0] = ++v85;
    uint64_t v6 = v121;
    unint64_t v102 = v121[130];
    if (v85 >= v102)
    {
      *(void *)&long long v136 = 0;
      if (v102)
      {
        unint64_t v103 = 0;
        while (1)
        {
          int v104 = strrchr(*(char **)(v6[132] + 56 * v103 + 8), 47);
          if (v104) {
            break;
          }
LABEL_134:
          *(void *)&long long v136 = ++v103;
          if (v103 >= v102) {
            goto LABEL_139;
          }
        }
        size_t v105 = v104 + 1;
        v147[0] = v104 + 1;
        size_t v106 = re::RigEvaluation::HashString::operator()((int)v142, v104 + 1);
        unint64_t v107 = v106;
        if (*v86)
        {
          unint64_t v108 = v106 % *((unsigned int *)this + 300);
          uint64_t v109 = *(unsigned int *)(*((void *)this + 148) + 4 * v108);
          if (v109 != 0x7FFFFFFF)
          {
            uint64_t v110 = *((void *)this + 149);
            do
            {
              uint64_t v111 = v110 + 32 * v109;
              if (!strcmp(*(const char **)(v111 + 16), v105)) {
                goto LABEL_133;
              }
              uint64_t v109 = *(_DWORD *)(v111 + 8) & 0x7FFFFFFF;
            }
            while (v109 != 0x7FFFFFFF);
          }
        }
        else
        {
          LODWORD(v108) = 0;
        }
        re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>((uint64_t)this + 1176, v108, v107, v147, &v136);
        ++*((_DWORD *)this + 304);
LABEL_133:
        uint64_t v6 = v121;
        unint64_t v102 = v121[130];
        goto LABEL_134;
      }
LABEL_139:
      re::FixedArray<re::EvaluationSRT>::init<>((void *)this + 159, (uint64_t)v120, v102);
      re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)this + 162, (uint64_t)v120, v6[130]);
      uint64_t result = (uint64_t)re::FixedArray<unsigned long>::init<unsigned long const&>((void *)this + 144, (uint64_t)v120, v6[130], &re::RigPose::kInvalidIndex);
      *(unsigned char *)uint64_t v115 = 1;
      goto LABEL_140;
    }
  }
  uint64_t v93 = *((void *)this + 149);
  while (1)
  {
    uint64_t v94 = v93 + 32 * v92;
    if (!strcmp(*(const char **)(v94 + 16), v88)) {
      break;
    }
    uint64_t v92 = *(_DWORD *)(v94 + 8) & 0x7FFFFFFF;
    if (v92 == 0x7FFFFFFF) {
      goto LABEL_113;
    }
  }
  uint64_t result = re::DynamicString::format(v120, (re::Allocator *)"Rig contains multiple nodes named '%s'", (re::DynamicString *)&v136, *v89);
  long long v113 = v136;
  long long v114 = v137;
  *(unsigned char *)uint64_t v115 = 0;
  *(void *)(v115 + 8) = 3000;
  *(void *)(v115 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(v115 + 24) = v113;
  *(_OWORD *)(v115 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v114;
LABEL_140:
  if (!v131[0])
  {
    uint64_t result = v133;
    if (v133)
    {
      if (v134) {
        return (*(uint64_t (**)(void))(*(void *)v133 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::RigDefinition::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::DynamicArray<re::RigComponentConstraint>::operator=(a1, (uint64_t *)a2);
  re::DynamicArray<re::RigComponentConstraint>::operator=(v4 + 40, (uint64_t *)(a2 + 40));
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a2 + 80);
    if (*(void *)(a1 + 80))
    {
      uint64_t v6 = (void *)(a1 + 80);
      if (v5)
      {
        re::DynamicArray<re::RigBasicConstraint>::copy(v6, a2 + 80);
        ++*(_DWORD *)(a1 + 104);
      }
      else
      {
        re::DynamicArray<re::RigBasicConstraint>::clear((uint64_t)v6);
      }
    }
    else if (v5)
    {
      unint64_t v7 = *(void *)(a2 + 96);
      *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = v5;
      re::DynamicArray<re::RigBasicConstraint>::setCapacity((void *)(a1 + 80), v7);
      ++*(_DWORD *)(a1 + 104);
      re::DynamicArray<re::RigBasicConstraint>::copy((void *)(a1 + 80), a2 + 80);
    }
    uint64_t v8 = *(void *)(a2 + 120);
    if (*(void *)(a1 + 120))
    {
      int v9 = (void *)(a1 + 120);
      if (v8)
      {
        re::DynamicArray<re::RigAimConstraint>::copy(v9, a2 + 120);
        ++*(_DWORD *)(a1 + 144);
      }
      else
      {
        re::DynamicArray<re::RigAimConstraint>::clear((uint64_t)v9);
      }
    }
    else if (v8)
    {
      unint64_t v10 = *(void *)(a2 + 136);
      *(void *)(a1 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v8;
      re::DynamicArray<re::RigAimConstraint>::setCapacity((void *)(a1 + 120), v10);
      ++*(_DWORD *)(a1 + 144);
      re::DynamicArray<re::RigAimConstraint>::copy((void *)(a1 + 120), a2 + 120);
    }
    uint64_t v11 = *(void *)(a2 + 160);
    if (*(void *)(a1 + 160))
    {
      if (v11) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 160), a2 + 160);
      }
      else {
        *(void *)(a1 + 176) = 0;
      }
      ++*(_DWORD *)(a1 + 184);
    }
    else if (v11)
    {
      unint64_t v12 = *(void *)(a2 + 176);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v11;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 160), v12);
      ++*(_DWORD *)(a1 + 184);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 160), a2 + 160);
    }
  }
  re::DynamicArray<float>::operator=(a1 + 200, (uint64_t *)(a2 + 200));
  re::DynamicArray<float>::operator=(a1 + 240, (uint64_t *)(a2 + 240));
  re::DynamicArray<float>::operator=(a1 + 280, (uint64_t *)(a2 + 280));
  if (a1 != a2)
  {
    uint64_t v13 = *(void *)(a2 + 320);
    if (*(void *)(a1 + 320))
    {
      if (v13) {
        re::DynamicArray<re::Matrix3x3<float>>::copy((void **)(a1 + 320), a2 + 320);
      }
      else {
        *(void *)(a1 + 336) = 0;
      }
      ++*(_DWORD *)(a1 + 344);
    }
    else if (v13)
    {
      unint64_t v14 = *(void *)(a2 + 336);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 320) = v13;
      re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)(a1 + 320), v14);
      ++*(_DWORD *)(a1 + 344);
      re::DynamicArray<re::Matrix3x3<float>>::copy((void **)(a1 + 320), a2 + 320);
    }
    uint64_t v15 = *(void *)(a2 + 360);
    if (*(void *)(a1 + 360))
    {
      if (v15) {
        re::DynamicArray<re::Matrix4x4<float>>::copy((void **)(a1 + 360), a2 + 360);
      }
      else {
        *(void *)(a1 + 376) = 0;
      }
      ++*(_DWORD *)(a1 + 384);
    }
    else if (v15)
    {
      unint64_t v16 = *(void *)(a2 + 376);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360) = v15;
      re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)(a1 + 360), v16);
      ++*(_DWORD *)(a1 + 384);
      re::DynamicArray<re::Matrix4x4<float>>::copy((void **)(a1 + 360), a2 + 360);
    }
    uint64_t v17 = *(void *)(a2 + 400);
    if (*(void *)(a1 + 400))
    {
      if (v17) {
        re::DynamicArray<re::Quaternion<float>>::copy((void **)(a1 + 400), a2 + 400);
      }
      else {
        *(void *)(a1 + 416) = 0;
      }
      ++*(_DWORD *)(a1 + 424);
    }
    else if (v17)
    {
      unint64_t v18 = *(void *)(a2 + 416);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 400) = v17;
      re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)(a1 + 400), v18);
      ++*(_DWORD *)(a1 + 424);
      re::DynamicArray<re::Quaternion<float>>::copy((void **)(a1 + 400), a2 + 400);
    }
    uint64_t v19 = *(void *)(a2 + 440);
    if (*(void *)(a1 + 440))
    {
      if (v19) {
        re::DynamicArray<unsigned long>::copy((void **)(a1 + 440), a2 + 440);
      }
      else {
        *(void *)(a1 + 456) = 0;
      }
      ++*(_DWORD *)(a1 + 464);
    }
    else if (v19)
    {
      unint64_t v20 = *(void *)(a2 + 456);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 440) = v19;
      re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)(a1 + 440), v20);
      ++*(_DWORD *)(a1 + 464);
      re::DynamicArray<unsigned long>::copy((void **)(a1 + 440), a2 + 440);
    }
  }
  re::DynamicArray<re::Vector3<float>>::operator=(a1 + 480, (uint64_t *)(a2 + 480));
  if (a1 == a2)
  {
    long long v22 = *(_OWORD *)(a2 + 560);
    long long v23 = *(_OWORD *)(a2 + 576);
    long long v24 = *(_OWORD *)(a2 + 608);
    *(_OWORD *)(a1 + 592) = *(_OWORD *)(a2 + 592);
    *(_OWORD *)(a1 + 608) = v24;
    *(_OWORD *)(a1 + 560) = v22;
    *(_OWORD *)(a1 + 576) = v23;
  }
  else
  {
    uint64_t v21 = *(void *)(a2 + 520);
    if (*(void *)(a1 + 520))
    {
      if (v21) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 520), a2 + 520);
      }
      else {
        *(void *)(a1 + 536) = 0;
      }
      ++*(_DWORD *)(a1 + 544);
    }
    else if (v21)
    {
      unint64_t v25 = *(void *)(a2 + 536);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 520) = v21;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 520), v25);
      ++*(_DWORD *)(a1 + 544);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 520), a2 + 520);
    }
    long long v26 = *(_OWORD *)(a2 + 560);
    long long v27 = *(_OWORD *)(a2 + 576);
    long long v28 = *(_OWORD *)(a2 + 608);
    *(_OWORD *)(a1 + 592) = *(_OWORD *)(a2 + 592);
    *(_OWORD *)(a1 + 608) = v28;
    *(_OWORD *)(a1 + 560) = v26;
    *(_OWORD *)(a1 + 576) = v27;
    uint64_t v29 = *(void *)(a2 + 624);
    if (*(void *)(a1 + 624))
    {
      if (v29) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 624), a2 + 624);
      }
      else {
        *(void *)(a1 + 6re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      }
      ++*(_DWORD *)(a1 + 648);
    }
    else if (v29)
    {
      unint64_t v30 = *(void *)(a2 + 640);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 624) = v29;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 624), v30);
      ++*(_DWORD *)(a1 + 648);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 624), a2 + 624);
    }
    uint64_t v31 = *(void *)(a2 + 664);
    if (*(void *)(a1 + 664))
    {
      if (v31) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 664), a2 + 664);
      }
      else {
        *(void *)(a1 + 6re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
      }
      ++*(_DWORD *)(a1 + 688);
    }
    else if (v31)
    {
      unint64_t v32 = *(void *)(a2 + 680);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 664) = v31;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 664), v32);
      ++*(_DWORD *)(a1 + 688);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 664), a2 + 664);
    }
    uint64_t v33 = *(void *)(a2 + 704);
    if (*(void *)(a1 + 704))
    {
      if (v33) {
        re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 704), a2 + 704);
      }
      else {
        *(void *)(a1 + 720) = 0;
      }
      ++*(_DWORD *)(a1 + 728);
    }
    else if (v33)
    {
      unint64_t v34 = *(void *)(a2 + 720);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 704) = v33;
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a1 + 704), v34);
      ++*(_DWORD *)(a1 + 728);
      re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 704), a2 + 704);
    }
    uint64_t v35 = *(void *)(a2 + 744);
    if (*(void *)(a1 + 744))
    {
      unint64_t v36 = (void *)(a1 + 744);
      if (v35)
      {
        re::DynamicArray<re::RigTwoBoneIKHandles>::copy(v36, a2 + 744);
        ++*(_DWORD *)(a1 + 768);
      }
      else
      {
        re::DynamicArray<re::RigTwoBoneIKHandles>::clear((uint64_t)v36);
      }
    }
    else if (v35)
    {
      unint64_t v37 = *(void *)(a2 + 760);
      *(void *)(a1 + re::DynamicArray<re::RigTwoBoneIKHandles>::deinit((uint64_t)this + 744) = v35;
      re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((void *)(a1 + 744), v37);
      ++*(_DWORD *)(a1 + 768);
      re::DynamicArray<re::RigTwoBoneIKHandles>::copy((void *)(a1 + 744), a2 + 744);
    }
    uint64_t v38 = *(void *)(a2 + 784);
    if (*(void *)(a1 + 784))
    {
      uint64_t v39 = (void *)(a1 + 784);
      if (v38)
      {
        re::DynamicArray<re::RigSingleChainIKHandles>::copy(v39, a2 + 784);
        ++*(_DWORD *)(a1 + 808);
      }
      else
      {
        re::DynamicArray<re::RigSingleChainIKHandles>::clear((uint64_t)v39);
      }
    }
    else if (v38)
    {
      unint64_t v40 = *(void *)(a2 + 800);
      *(void *)(a1 + re::DynamicArray<re::RigSingleChainIKHandles>::deinit((uint64_t)this + 784) = v38;
      re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((void *)(a1 + 784), v40);
      ++*(_DWORD *)(a1 + 808);
      re::DynamicArray<re::RigSingleChainIKHandles>::copy((void *)(a1 + 784), a2 + 784);
    }
    uint64_t v41 = *(void *)(a2 + 824);
    if (*(void *)(a1 + 824))
    {
      uint64_t v42 = (void *)(a1 + 824);
      if (v41)
      {
        re::DynamicArray<re::RigSplineIKHandle>::copy(v42, a2 + 824);
        ++*(_DWORD *)(a1 + 848);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKHandle>::clear((uint64_t)v42);
      }
    }
    else if (v41)
    {
      unint64_t v43 = *(void *)(a2 + 840);
      *(void *)(a1 + re::DynamicArray<re::RigSplineIKHandle>::deinit((uint64_t)this + 824) = v41;
      re::DynamicArray<re::RigSplineIKHandle>::setCapacity((void *)(a1 + 824), v43);
      ++*(_DWORD *)(a1 + 848);
      re::DynamicArray<re::RigSplineIKHandle>::copy((void *)(a1 + 824), a2 + 824);
    }
    uint64_t v44 = *(void *)(a2 + 864);
    if (*(void *)(a1 + 864))
    {
      if (v44) {
        re::DynamicArray<re::RigTransform>::copy((void **)(a1 + 864), a2 + 864);
      }
      else {
        *(void *)(a1 + 8re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
      }
      ++*(_DWORD *)(a1 + 888);
    }
    else if (v44)
    {
      unint64_t v45 = *(void *)(a2 + 880);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 864) = v44;
      re::DynamicArray<re::RigTransform>::setCapacity((void *)(a1 + 864), v45);
      ++*(_DWORD *)(a1 + 888);
      re::DynamicArray<re::RigTransform>::copy((void **)(a1 + 864), a2 + 864);
    }
    uint64_t v46 = *(void *)(a2 + 904);
    if (*(void *)(a1 + 904))
    {
      if (v46) {
        re::DynamicArray<re::RigJoint>::copy((void **)(a1 + 904), a2 + 904);
      }
      else {
        *(void *)(a1 + 920) = 0;
      }
      ++*(_DWORD *)(a1 + 928);
    }
    else if (v46)
    {
      unint64_t v47 = *(void *)(a2 + 920);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 904) = v46;
      re::DynamicArray<re::RigJoint>::setCapacity((void *)(a1 + 904), v47);
      ++*(_DWORD *)(a1 + 928);
      re::DynamicArray<re::RigJoint>::copy((void **)(a1 + 904), a2 + 904);
    }
    uint64_t v48 = *(void *)(a2 + 944);
    if (*(void *)(a1 + 944))
    {
      if (v48) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 944), a2 + 944);
      }
      else {
        *(void *)(a1 + 960) = 0;
      }
      ++*(_DWORD *)(a1 + 968);
    }
    else if (v48)
    {
      unint64_t v49 = *(void *)(a2 + 960);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 944) = v48;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 944), v49);
      ++*(_DWORD *)(a1 + 968);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 944), a2 + 944);
    }
    uint64_t v50 = *(void *)(a2 + 984);
    if (*(void *)(a1 + 984))
    {
      if (v50) {
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 984), a2 + 984);
      }
      else {
        *(void *)(a1 + 1000) = 0;
      }
      ++*(_DWORD *)(a1 + 1008);
    }
    else if (v50)
    {
      unint64_t v51 = *(void *)(a2 + 1000);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 984) = v50;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 984), v51);
      ++*(_DWORD *)(a1 + 1008);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 984), a2 + 984);
    }
    uint64_t v52 = *(void *)(a2 + 1024);
    if (*(void *)(a1 + 1024))
    {
      uint64_t v53 = (void *)(a1 + 1024);
      if (v52)
      {
        re::DynamicArray<re::RigNode>::copy(v53, a2 + 1024);
        ++*(_DWORD *)(a1 + 1048);
      }
      else
      {
        re::DynamicArray<re::RigNode>::clear((uint64_t)v53);
      }
    }
    else if (v52)
    {
      unint64_t v54 = *(void *)(a2 + 1040);
      *(void *)(a1 + re::DynamicArray<re::RigNode>::deinit((uint64_t)this + 1024) = v52;
      re::DynamicArray<re::RigNode>::setCapacity((void *)(a1 + 1024), v54);
      ++*(_DWORD *)(a1 + 1048);
      re::DynamicArray<re::RigNode>::copy((void *)(a1 + 1024), a2 + 1024);
    }
    uint64_t v55 = *(void *)(a2 + 1064);
    if (*(void *)(a1 + 1064))
    {
      if (v55) {
        re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 1064), a2 + 1064);
      }
      else {
        *(void *)(a1 + 10re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
      }
      ++*(_DWORD *)(a1 + 1088);
    }
    else if (v55)
    {
      unint64_t v56 = *(void *)(a2 + 1080);
      *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 1064) = v55;
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a1 + 1064), v56);
      ++*(_DWORD *)(a1 + 1088);
      re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 1064), a2 + 1064);
    }
    uint64_t v57 = *(void *)(a2 + 1104);
    if (*(void *)(a1 + 1104))
    {
      uint64_t v58 = a1 + 1104;
      if (v57)
      {
        re::DynamicArray<re::RigPose>::copy(v58, a2 + 1104);
        ++*(_DWORD *)(a1 + 1128);
      }
      else
      {
        re::DynamicArray<re::RigPose>::clear(v58);
      }
    }
    else if (v57)
    {
      unint64_t v59 = *(void *)(a2 + 1120);
      *(void *)(a1 + re::DynamicArray<re::RigPose>::deinit((uint64_t)this + 1104) = v57;
      re::DynamicArray<re::RigPose>::setCapacity((void *)(a1 + 1104), v59);
      ++*(_DWORD *)(a1 + 1128);
      re::DynamicArray<re::RigPose>::copy(a1 + 1104, a2 + 1104);
    }
  }
  return a1;
}

void re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  unint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_261, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void *re::RigEvaluation::init@<X0>(uint64_t a1@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  re::RigEvaluation::initRigDefinitionData((re::RigEvaluation *)a1, a2, a3, (uint64_t)v9);
  if (v9[0])
  {
    *(void *)a1 = a2;
    uint64_t result = re::RigDefinition::operator=((_OWORD *)(a1 + 8), a3);
    *(unsigned char *)a4 = 1;
  }
  else
  {
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v10;
    uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v11);
  }
  if (!v9[0])
  {
    uint64_t result = v11;
    if (v11)
    {
      if (v12) {
        return (void *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  return result;
}

_OWORD *re::RigDefinition::operator=(_OWORD *a1, _OWORD *a2)
{
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1, (uint64_t)a2);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 40, (uint64_t)a2 + 40);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 5), (uint64_t)(a2 + 5));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 120, (uint64_t)a2 + 120);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 10), (uint64_t)(a2 + 10));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 200, (uint64_t)a2 + 200);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 15), (uint64_t)(a2 + 15));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 280, (uint64_t)a2 + 280);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 20), (uint64_t)(a2 + 20));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 360, (uint64_t)a2 + 360);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 25), (uint64_t)(a2 + 25));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 440, (uint64_t)a2 + 440);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 30), (uint64_t)(a2 + 30));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 520, (uint64_t)a2 + 520);
  long long v4 = a2[38];
  long long v6 = a2[35];
  long long v5 = a2[36];
  a1[37] = a2[37];
  a1[38] = v4;
  a1[35] = v6;
  a1[36] = v5;
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 39), (uint64_t)(a2 + 39));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 664, (uint64_t)a2 + 664);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 44), (uint64_t)(a2 + 44));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 744, (uint64_t)a2 + 744);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 49), (uint64_t)(a2 + 49));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 824, (uint64_t)a2 + 824);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 54), (uint64_t)(a2 + 54));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 904, (uint64_t)a2 + 904);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 59), (uint64_t)(a2 + 59));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 984, (uint64_t)a2 + 984);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 64), (uint64_t)(a2 + 64));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 1064, (uint64_t)a2 + 1064);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 69), (uint64_t)(a2 + 69));
  return a1;
}

uint64_t re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(uint64_t a1, char **a2)
{
  size_t v4 = re::RigEvaluation::HashString::operator()((int)&v10, *a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = *a2;
  while (1)
  {
    uint64_t v8 = v6 + 32 * v5;
    if (!strcmp(*(const char **)(v8 + 16), v7)) {
      break;
    }
    uint64_t v5 = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v8 + 24;
}

uint64_t re::RigDefinition::deinit(re::RigDefinition *this)
{
  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this);
  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40);
  re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80);
  re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160);
  re::DynamicRegisterIdTable::deinit((re::RigDefinition *)((char *)this + 200));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 520);
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 624);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 664);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 704);
  re::DynamicArray<re::RigTwoBoneIKHandles>::deinit((uint64_t)this + 744);
  re::DynamicArray<re::RigSingleChainIKHandles>::deinit((uint64_t)this + 784);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 864);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 904);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 944);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 984);
  re::DynamicArray<re::RigNode>::deinit((uint64_t)this + 1024);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 1064);
  return re::DynamicArray<re::RigPose>::deinit((uint64_t)this + 1104);
}

void *re::FixedArray<re::internal::RigIKCall>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 136 * v2;
      uint64_t v5 = (uint64_t *)(result[2] + 96);
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v5);
        re::FixedArray<CoreIKTransform>::deinit(v5 - 5);
        re::FixedArray<CoreIKTransform>::deinit(v5 - 8);
        re::FixedArray<CoreIKTransform>::deinit(v5 - 11);
        v5 += 17;
        v4 -= 136;
      }
      while (v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      void *v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::RigIKCall>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 136 * v4;
        uint64_t v6 = (uint64_t *)(v3 + 96);
        do
        {
          re::FixedArray<CoreIKTransform>::deinit(v6);
          re::FixedArray<CoreIKTransform>::deinit(v6 - 5);
          re::FixedArray<CoreIKTransform>::deinit(v6 - 8);
          re::FixedArray<CoreIKTransform>::deinit(v6 - 11);
          v6 += 17;
          v5 -= 136;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::RigEvaluation::reset(re::RigEvaluation *this)
{
  uint64_t v2 = *((void *)this + 160);
  if (v2 >= 1) {
    memset(*((void **)this + 161), 255, 24 * (24 * v2 / 0x18uLL - ((unint64_t)(24 * v2) > 0x17)) + 24);
  }
  uint64_t v3 = *((void *)this + 163);
  if (v3 >= 1) {
    memset(*((void **)this + 164), 255, 8 * (v3 - ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  }
  uint64_t v4 = *((void *)this + 145);
  if (v4 >= 1) {
    memset(*((void **)this + 146), 255, 8 * (v4 - ((v4 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  }
  return re::DynamicArray<re::internal::RigIKCall>::clear((uint64_t)this + 1488);
}

uint64_t re::DynamicArray<re::internal::RigIKCall>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 136 * v2;
    uint64_t v4 = (uint64_t *)(*(void *)(result + 32) + 96);
    do
    {
      re::FixedArray<CoreIKTransform>::deinit(v4);
      re::FixedArray<CoreIKTransform>::deinit(v4 - 5);
      re::FixedArray<CoreIKTransform>::deinit(v4 - 8);
      uint64_t result = re::FixedArray<CoreIKTransform>::deinit(v4 - 11);
      v4 += 17;
      v3 -= 136;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

BOOL re::RigEvaluation::bindLocalSpaceJointInput(uint64_t a1, char *a2, long long *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  v11[0] = a2;
  uint64_t v5 = (unint64_t *)re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(a1 + 1176, v11);
  if (v5)
  {
    unint64_t v6 = *v5;
    unint64_t v7 = *(void *)(a1 + 1280);
    if (v7 <= *v5)
    {
      v11[1] = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v20 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v12 = 136315906;
      uint64_t v13 = "operator[]";
      __int16 v14 = 1024;
      int v15 = 468;
      __int16 v16 = 2048;
      unint64_t v17 = v6;
      __int16 v18 = 2048;
      unint64_t v19 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v8 = *(void *)(a1 + 1288) + 24 * v6;
    long long v9 = *a3;
    *(void *)(v8 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v8 = v9;
  }
  return v5 != 0;
}

BOOL re::RigEvaluation::bindModelSpaceJointInput(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  v9[0] = a2;
  uint64_t v5 = (unint64_t *)re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(a1 + 1176, v9);
  if (v5)
  {
    unint64_t v6 = *v5;
    unint64_t v7 = *(void *)(a1 + 1304);
    if (v7 <= *v5)
    {
      v9[1] = 0;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v18 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v10 = 136315906;
      uint64_t v11 = "operator[]";
      __int16 v12 = 1024;
      int v13 = 468;
      __int16 v14 = 2048;
      unint64_t v15 = v6;
      __int16 v16 = 2048;
      unint64_t v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(void *)(*(void *)(a1 + 1312) + 8 * v6) = a3;
  }
  return v5 != 0;
}

BOOL re::RigEvaluation::setDefaultPose(re::RigEvaluation *this, unint64_t a2)
{
  uint64_t v4 = *((void *)this + 146);
  uint64_t v5 = *((void *)this + 145);
  if (v5 >= 1) {
    memset(*((void **)this + 146), 255, 8 * (v5 - ((v5 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  }
  unint64_t v6 = *((void *)this + 141);
  if (v6 > a2)
  {
    uint64_t v7 = *((void *)this + 143) + 32 * a2;
    uint64_t v9 = *(void *)(v7 + 16);
    uint64_t v8 = (unint64_t *)(v7 + 16);
    if (v9)
    {
      unint64_t v10 = 0;
      uint64_t v11 = (void *)(*((void *)this + 143) + 32 * a2 + 24);
      do
      {
        unint64_t v12 = v10 + *v11;
        if (*((void *)this + 136) <= v12)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_11:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        unint64_t v13 = *(void *)(*((void *)this + 138) + 24 * v12 + 16);
        if (*((void *)this + 145) <= v13) {
          goto LABEL_11;
        }
        *(void *)(v4 + 8 * v13) = v12;
        ++v10;
      }
      while (v10 < *v8);
    }
  }
  return v6 > a2;
}

void re::RigEvaluation::constructEvaluationCommands(unint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  char v18 = 0;
  v17[0] = &unk_26E6DEC70;
  v17[1] = "Scratch Pad";
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  re::FixedArray<char const*>::init<>(&v14, (uint64_t)v17, a3);
  if (a3)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v15;
    unint64_t v12 = (uint64_t *)(a2 + 8);
    do
    {
      if (v11 == v10)
      {
        uint64_t v19 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v30 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v20 = 136315906;
        long long v21 = "operator[]";
        __int16 v22 = 1024;
        int v23 = 468;
        __int16 v24 = 2048;
        unint64_t v25 = v11;
        __int16 v26 = 2048;
        unint64_t v27 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v13 = *v12;
      v12 += 2;
      *(void *)(v16 + 8 * v10++) = v13;
    }
    while (a3 != v10);
  }
  else
  {
    unint64_t v11 = v15;
  }
  re::RigEvaluation::constructEvaluationCommands(a1, v16, v11, a4, a5);
  if (v14 && v15) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  re::Allocator::~Allocator((re::Allocator *)v17);
}

{
  void *v5;
  unint64_t v7;
  _anonymous_namespace_ *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unint64_t *v22;
  int v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  float32x4_t v34;
  int8x16_t v42;
  float32x4_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned char *v56;
  uint64_t v57;
  unsigned char *v58;
  _anonymous_namespace_ *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  unint64_t v64;
  unint64_t *v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  _anonymous_namespace_ *v69;
  uint64_t v70;
  unint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t *v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned __int8 *v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  char *v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  char *v100;
  unint64_t v101;
  char *v102;
  __n128 *v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  const float *v110;
  float32x4_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _anonymous_namespace_ *v119;
  unint64_t v120;
  _anonymous_namespace_ *v121;
  char *v122;
  unint64_t *v123;
  uint64_t v124;
  char *v125;
  unint64_t *v126;
  uint64_t v127;
  __n128 *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  void *v133;
  void *v134;
  uint64_t v135;
  unint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t *v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  const char *v155;
  __n128 v156;
  float32x4_t v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  _anonymous_namespace_ *v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  unint64_t v173;
  void *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  _DWORD *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  __n128 *v195;
  _anonymous_namespace_ *v196;
  uint64_t v197;
  unint64_t v198;
  uint64_t v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  float *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  __n128 *v213;
  uint64_t v214;
  _DWORD *v215;
  uint64_t v216;
  __n128 *v217;
  uint64_t v218;
  void *v219;
  unint64_t appended;
  uint64_t v221;
  int v222;
  uint64_t v223;
  uint64_t v224;
  _anonymous_namespace_ *v225;
  uint64_t v226;
  unint64_t v227;
  uint64_t v228;
  float v229;
  unint64_t *v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  unint64_t v234;
  uint64_t v235;
  uint64_t v236;
  _anonymous_namespace_ *v237;
  unint64_t v238;
  uint64_t v239;
  void *v240;
  unint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  uint64_t v246;
  float v247;
  unint64_t v248;
  uint64_t v249;
  uint64_t v250;
  float v251;
  float v252;
  uint64_t v253;
  unint64_t v254;
  uint64_t v255;
  uint64_t v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  __n128 v262;
  unint64_t ConstrainedComponents;
  uint64_t v264;
  int v265;
  char *v266;
  unint64_t *v267;
  unint64_t v268;
  uint64_t v269;
  unint64_t v270;
  uint64_t v271;
  uint64_t v272;
  unint64_t v273;
  unint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  unint64_t v279;
  uint64_t v280;
  int v281;
  int v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  unint64_t v286;
  uint64_t v287;
  void *v288;
  uint64_t v289;
  float v290;
  unint64_t v291;
  unint64_t *v292;
  unint64_t v293;
  unint64_t v294;
  float v295;
  uint64_t v296;
  void *v297;
  float v298;
  uint64_t v299;
  void *v300;
  uint64_t v301;
  char *v302;
  unint64_t *v303;
  unint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  unint64_t v309;
  uint64_t v310;
  unint64_t v311;
  unint64_t v312;
  uint64_t v313;
  void *v314;
  unint64_t v315;
  uint64_t v316;
  unint64_t v317;
  unint64_t v318;
  uint64_t v319;
  void *v320;
  __n128 *v321;
  uint64_t v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  unint64_t v326;
  void *v327;
  unint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  unint64_t v332;
  uint64_t v333;
  unint64_t v334;
  uint64_t v335;
  unint64_t v336;
  unint64_t v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unint64_t v345;
  uint64_t v346;
  uint64_t v347;
  unint64_t v348;
  void *v349;
  unint64_t v350;
  uint64_t v351;
  unint64_t v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  __n128 v357;
  unint64_t v358;
  unint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  unint64_t v363;
  uint64_t v364;
  unint64_t v365;
  _anonymous_namespace_ *v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  void *v371;
  unint64_t Rotation;
  unint64_t Scale;
  uint64_t v374;
  uint64_t v375;
  unint64_t v376;
  uint64_t v377;
  uint64_t v378;
  unint64_t v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  unint64_t v383;
  uint64_t v384;
  unint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  __n128 v389;
  unint64_t v390;
  uint64_t v391;
  unint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  __n128 *v397;
  uint64_t v398;
  uint64_t v399;
  unint64_t v400;
  uint64_t v401;
  unint64_t v402;
  uint64_t v403;
  uint64_t v404;
  unint64_t v405;
  unint64_t v406;
  unint64_t v407;
  uint64_t v408;
  unint64_t v409;
  float v410;
  unint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  unint64_t *v416;
  uint64_t v417;
  uint64_t v418;
  unint64_t v419;
  uint64_t v420;
  unint64_t v421;
  uint64_t v422;
  unint64_t *v423;
  __n128 v424;
  float32x4_t v425;
  __n128 v426;
  float32x4_t v427;
  unint64_t v428;
  unint64_t *v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  int v435;
  unint64_t v436;
  unint64_t v437;
  unint64_t v438;
  int v439;
  _anonymous_namespace_ *v440;
  _anonymous_namespace_ *v441;
  _anonymous_namespace_ *v442;
  _anonymous_namespace_ *v443;
  _anonymous_namespace_ *v444;
  _anonymous_namespace_ *v445;
  _anonymous_namespace_ *v446;
  _anonymous_namespace_ *v447;
  _anonymous_namespace_ *v448;
  unsigned int *v452;
  uint64_t v453;
  void *v454;
  _anonymous_namespace_ *v455;
  _anonymous_namespace_ *v456;
  uint64_t v457;
  unint64_t v458;
  unint64_t v459;
  _anonymous_namespace_ *v460;
  unint64_t *v461;
  _anonymous_namespace_ *v462;
  _anonymous_namespace_ *v463;
  unint64_t v464;
  _anonymous_namespace_ *v465;
  unint64_t v466;
  _anonymous_namespace_ *v467;
  _anonymous_namespace_ *v468;
  _anonymous_namespace_ *v469;
  unint64_t v470;
  unint64_t v471;
  uint64_t v472;
  unsigned __int8 *v473;
  unint64_t *v474;
  unint64_t *v475;
  void *v476;
  _anonymous_namespace_ *v477;
  unint64_t v478;
  uint64_t v479;
  unint64_t *v480;
  unint64_t v481;
  unint64_t v482;
  void *v483;
  unint64_t v484;
  _anonymous_namespace_ *v485;
  _anonymous_namespace_ *v486;
  _anonymous_namespace_ *v487;
  _anonymous_namespace_ *v488;
  _anonymous_namespace_ *v489;
  _anonymous_namespace_ *v490;
  _anonymous_namespace_ *v491;
  _anonymous_namespace_ *v492;
  _anonymous_namespace_ *v493;
  _anonymous_namespace_ *v494;
  unint64_t v495;
  _anonymous_namespace_ *v496;
  _anonymous_namespace_ *v497;
  unint64_t *v498;
  void *v499;
  uint64_t v500;
  _anonymous_namespace_ *v501;
  _anonymous_namespace_ *v502;
  _anonymous_namespace_ *v503;
  unint64_t *v504;
  unint64_t v505;
  unint64_t v506;
  unsigned __int8 *v507;
  void *v508;
  unint64_t v509;
  _anonymous_namespace_ *v510;
  _anonymous_namespace_ *v511;
  _anonymous_namespace_ *v512;
  _anonymous_namespace_ *v513;
  _anonymous_namespace_ *v514;
  _anonymous_namespace_ *v515;
  _anonymous_namespace_ *v516;
  _anonymous_namespace_ *v517;
  void *v518;
  void *v519;
  void *v520;
  _anonymous_namespace_ *v521;
  _anonymous_namespace_ *v522;
  _anonymous_namespace_ *v523;
  _anonymous_namespace_ *v524;
  _anonymous_namespace_ *v525;
  _anonymous_namespace_ *v526;
  _anonymous_namespace_ *v527;
  uint64_t v528;
  _anonymous_namespace_ *v529;
  _anonymous_namespace_ *v530;
  _anonymous_namespace_ *v531;
  unint64_t v532;
  _anonymous_namespace_ *v533;
  long long v534;
  long long v535;
  long long v536;
  long long v537;
  long long v538;
  long long v539;
  long long v540;
  long long v541;
  long long v542;
  long long v543;
  long long v544;
  long long v545;
  unint64_t v546;
  unint64_t v547;
  uint64_t v548;
  unint64_t v549;
  unint64_t v550;
  uint64_t v551;
  uint64_t v552;
  unint64_t v553;
  uint64_t v554;
  __n128 v555[2];
  unsigned char v556[24];
  uint64_t v557;
  unint64_t v558;
  uint64_t v559;
  uint64_t v560;
  void *v561;
  uint64_t v562;
  uint64_t v563;
  unint64_t v564;
  uint64_t v565;
  uint64_t v566;
  unint64_t v567;
  uint64_t v568;
  uint64_t v569;
  unint64_t v570;
  uint64_t v571;
  void v572[2];
  char v573;
  uint64_t v574;
  __n128 v575[3];
  long long v576;
  long long v577;
  long long v578;
  long long v579;
  long long v580;
  long long v581;
  long long v582;
  long long v583;
  long long v584;
  __n128 v585;
  float32x4_t v586;
  long long v587;
  long long v588;
  long long v589;
  _OWORD v590[2];
  uint64_t v591;
  uint64_t v592;
  long long v593;
  long long v594;
  long long v595;
  long long v596;
  long long v597;
  uint64_t v598;
  unint64_t v599;
  long long v600;
  long long v601;
  long long v602;
  long long v603;
  unsigned char v604[28];
  __int16 v605;
  unsigned char v606[10];
  unint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t *v611[4];
  long long v612;
  long long v613;
  long long v614;
  long long v615;
  uint64_t v616;
  int v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  int v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  int v625;
  long long v626;
  long long v627;
  int v628;
  uint64_t v629;
  unsigned char v630[28];
  __int16 v631;
  unint64_t v632;
  uint64_t v633;

  uint64_t v7 = a1;
  v633 = *MEMORY[0x263EF8340];
  v572[1] = "Scratch Pad";
  v573 = 0;
  v572[0] = &unk_26E6DEC70;
  v611[0] = 0;
  v612 = 0u;
  v613 = 0u;
  v614 = 0u;
  v615 = 0u;
  v616 = 0;
  v617 = 1;
  v620 = 0;
  v618 = 0;
  v619 = 0;
  v621 = 0;
  v624 = 0;
  v622 = 0;
  v623 = 0;
  v625 = 0;
  v629 = 0;
  v626 = 0u;
  v627 = 0u;
  v628 = 0;
  uint64_t v8 = *(_anonymous_namespace_ **)(a1 + 1048);
  v570 = 0;
  v569 = 0;
  v571 = 0;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v569, (uint64_t)v572, (unint64_t)v8);
  v567 = 0;
  v566 = 0;
  v568 = 0;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v566, (uint64_t)v572, (unint64_t)v8);
  v564 = 0;
  v563 = 0;
  v565 = 0;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v563, (uint64_t)v572, (unint64_t)v8);
  v561 = 0;
  v560 = 0;
  v562 = 0;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v560, (uint64_t)v572, (unint64_t)v8);
  v558 = 0;
  v557 = 0;
  v559 = 0;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v557, (uint64_t)v572, (unint64_t)v8);
  v520 = (void *)v7;
  v532 = (unint64_t)v8;
  v533 = (_anonymous_namespace_ *)a4;
  if (!v8)
  {
    uint64_t v13 = 0;
    *(void *)v556 = v572;
    *(_OWORD *)&v556[8] = 0u;
    v555[0].n128_u64[0] = (unint64_t)v572;
    *(__n128 *)((char *)v555 + 8) = 0u;
    goto LABEL_52;
  }
  uint64_t v9 = 0;
  uint64_t v10 = -1;
  unint64_t v11 = 0x7FFFFFFFFFFFFFFELL;
  unint64_t v12 = 0x8000000000000001;
  do
  {
    v585.n128_u64[0] = -1;
    re::DynamicArray<unsigned long>::add((void *)(a4 + 808), &v585);
    uint64_t v13 = v567;
    if (v567 <= v9) {
      goto LABEL_599;
    }
    *(void *)(v568 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *(void *)(a4 + 824) + 0x7FFFFFFFFFFFFFFELL;
    v585.n128_u64[0] = -1;
    re::DynamicArray<unsigned long>::add((void *)(a4 + 808), &v585);
    uint64_t v13 = v564;
    if (v564 <= v9)
    {
LABEL_600:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_601:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_602:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_603:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_604:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_605:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_606:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_607:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_608:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_609:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_610:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_611:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_612:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_613:
      *(void *)&v534 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_614;
    }
    *(void *)(v565 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *(void *)(a4 + 824) + 0x7FFFFFFFFFFFFFFELL;
    v585.n128_u64[0] = -1;
    re::DynamicArray<unsigned long>::add((void *)(a4 + 808), &v585);
    uint64_t v13 = (unint64_t)v561;
    if ((unint64_t)v561 <= v9) {
      goto LABEL_601;
    }
    *(void *)(v562 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *(void *)(a4 + 824) + 0x7FFFFFFFFFFFFFFELL;
    v585.n128_u64[0] = -1;
    re::DynamicArray<unsigned long>::add((void *)(a4 + 808), &v585);
    uint64_t v13 = v558;
    if (v558 <= v9) {
      goto LABEL_602;
    }
    unint64_t v15 = v559;
    *(void *)(v559 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *(void *)(a4 + 824) + 0x7FFFFFFFFFFFFFFELL;
    uint64_t v13 = (unint64_t)v561;
    if ((unint64_t)v561 <= v9) {
      goto LABEL_603;
    }
    uint64_t v13 = v567;
    if (v567 <= v9) {
      goto LABEL_604;
    }
    uint64_t v16 = v7;
    unint64_t v17 = v562;
    uint64_t v13 = *(void *)(v562 + 8 * v9) - 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v7 = *(void *)(a4 + 824);
    if (v7 <= v13) {
      goto LABEL_605;
    }
    char v18 = *(void *)(a4 + 840);
    *(void *)(v18 + 8 * v13) = *(void *)(v568 + 8 * v9);
    uint64_t v13 = v558;
    if (v558 <= v9) {
      goto LABEL_606;
    }
    uint64_t v13 = (unint64_t)v561;
    if ((unint64_t)v561 <= v9) {
      goto LABEL_607;
    }
    uint64_t v13 = *(void *)(v15 + 8 * v9) - 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v7 = *(void *)(a4 + 824);
    if (v7 <= v13) {
      goto LABEL_608;
    }
    *(void *)(v18 + 8 * v13) = *(void *)(v17 + 8 * v9++);
    uint64_t v7 = v16;
  }
  while (v8 != (_anonymous_namespace_ *)v9);
  uint64_t v19 = a4;
  a4 = 0;
  unint64_t v12 = 0;
  v528 = v19 + 1664;
  v529 = (_anonymous_namespace_ *)(v19 + 1824);
  int v20 = 32;
  do
  {
    uint64_t v9 = *(void *)(v7 + 1048);
    if (v9 <= v12) {
      goto LABEL_610;
    }
    uint64_t v9 = *(void *)(v7 + 1160);
    if (v9 <= v12) {
      goto LABEL_611;
    }
    uint64_t v9 = *(void *)(v7 + 1064);
    uint64_t v10 = *(void *)(*(void *)(v7 + 1168) + 8 * v12);
    if (v10 == -1)
    {
      __int16 v22 = (unint64_t *)(v9 + v20 - 8);
      long long v21 = (unsigned __int8 *)(v9 + v20 - 16);
    }
    else
    {
      unint64_t v11 = *(void *)(v7 + 1088);
      if (v11 <= v10) {
        goto LABEL_625;
      }
      long long v21 = (unsigned __int8 *)(*(void *)(v7 + 1104) + 24 * v10);
      __int16 v22 = (unint64_t *)(v21 + 8);
    }
    int v23 = *v21;
    uint64_t v10 = *v22;
    if (v23 == 2)
    {
      unint64_t v11 = *(void *)(v7 + 928);
      if (v11 <= v10) {
        goto LABEL_635;
      }
      long long v30 = *(void *)(v7 + 944) + 96 * v10;
      long long v31 = *(unsigned __int8 *)(v30 + 80);
      v585 = (__n128)xmmword_23435FBB0;
      re::convertIntrinsicEulersToQuaternions<float>(v30 + 32, 1, v31, (uint64_t)&v585, 1);
      _Q1 = *(float32x4_t *)(v30 + 16);
      _Q3 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v585, (int32x4_t)v585), (int8x16_t)v585, 0xCuLL), vnegq_f32(_Q1)), (float32x4_t)v585, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
      unint64_t v34 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), _Q3, 0xCuLL), (float32x4_t)v585, _Q1, 3);
      _Q3.i32[0] = v585.n128_i32[3];
      _Q2 = vmlaq_laneq_f32(v34, _Q1, (float32x4_t)v585, 3);
      __asm { FMLA            S0, S3, V1.S[3] }
      _Q5 = *(float32x4_t *)(v30 + 48);
      uint64_t v42 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), vnegq_f32(_Q2)), _Q5, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL));
      unint64_t v43 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), v42, 0xCuLL), _Q5, _S0), _Q2, _Q5, 3);
      __asm { FMLA            S2, S0, V5.S[3] }
      v43.i32[3] = _Q2.i32[0];
      uint64_t v44 = *(void *)(v30 + 72);
      long long v29 = *(void *)v30;
      long long v28 = *(void *)(v30 + 8);
      v585.n128_u64[0] = *(void *)(v30 + 64);
      v585.n128_u64[1] = v44;
      v586 = v43;
    }
    else
    {
      if (v23 != 1) {
        goto LABEL_818;
      }
      unint64_t v11 = *(void *)(v7 + 888);
      if (v11 <= v10) {
        goto LABEL_634;
      }
      __int16 v24 = *(void *)(v7 + 904) + (v10 << 6);
      uint64_t v13 = *(void *)(v24 + 32);
      unint64_t v11 = *(void *)(v24 + 40);
      unint64_t v25 = *(unsigned __int8 *)(v24 + 48);
      v585 = (__n128)xmmword_23435FBB0;
      re::convertIntrinsicEulersToQuaternions<float>(v24 + 16, 1, v25, (uint64_t)&v585, 1);
      __int16 v26 = v585.n128_u64[1];
      unint64_t v27 = v585.n128_u64[0];
      long long v29 = *(void *)v24;
      long long v28 = *(void *)(v24 + 8);
      v585.n128_u64[0] = v13;
      v585.n128_u64[1] = v11;
      v586.i64[0] = v27;
      v586.i64[1] = v26;
    }
    *(void *)&v587 = v29;
    *((void *)&v587 + 1) = v28;
    re::EvaluationTree::createInputRegister(v533, &v585, v575);
    unint64_t v45 = re::EvaluationTree::constructMatrix4x4(v533, v575[0].n128_i64[0], v575[0].n128_i64[1], v575[1].n128_i64[0]);
    uint64_t v10 = *(void *)(v7 + 1280);
    if (v10 <= v12) {
      goto LABEL_612;
    }
    uint64_t v13 = v45;
    uint64_t v46 = (uint64_t *)(*(void *)(v7 + 1288) + a4);
    uint64_t v14 = *v46;
    unint64_t v11 = v45;
    if (*v46 != -1)
    {
      unint64_t v47 = v46[1];
      unint64_t v11 = v45;
      if (v47 != -1)
      {
        uint64_t v48 = v46[2];
        unint64_t v11 = v45;
        if (v48 != -1) {
          unint64_t v11 = re::EvaluationTree::constructMatrix4x4(v533, v14, v47, v48);
        }
      }
    }
    uint64_t v10 = v570;
    if (v570 <= v12) {
      goto LABEL_613;
    }
    uint64_t v5 = (void *)v7;
    *(void *)(v571 + 8 * v12) = v13;
    uint64_t v7 = *(void *)(v9 + v20);
    uint64_t v10 = v564;
    if (v7 == -1)
    {
      if (v564 <= v12) {
        goto LABEL_642;
      }
      uint64_t v9 = *(void *)(v565 + 8 * v12) - 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v10 = *((void *)v533 + 103);
      if (v10 <= v9) {
        goto LABEL_643;
      }
      uint64_t v55 = *((void *)v533 + 105);
      *(void *)(v55 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v13;
      uint64_t v9 = v567;
      if (v567 <= v12) {
        goto LABEL_644;
      }
      uint64_t v9 = *(void *)(v568 + 8 * v12) - 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v10 = *((void *)v533 + 103);
      if (v10 <= v9) {
        goto LABEL_645;
      }
      *(void *)(v55 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v11;
    }
    else
    {
      if (v564 <= v12) {
        goto LABEL_626;
      }
      if (v564 <= v7) {
        goto LABEL_627;
      }
      unint64_t v49 = *(void *)(v565 + 8 * v12);
      uint64_t v5 = *(void **)(v565 + 8 * v7);
      v585.n128_u32[0] = 28;
      v586 = 0uLL;
      v585.n128_u64[1] = 0;
      re::DynamicArray<re::EvaluationRegister>::add(v529, (uint64_t)&v585);
      uint64_t v8 = v533;
      uint64_t v50 = *((void *)v533 + 230) - 1;
      unint64_t v51 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v50);
      *(void *)(v51 + 8) = v5;
      *(void *)(v51 + 16) = v13;
      uint64_t v10 = v49 - 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v13 = *((void *)v533 + 103);
      if (v13 <= v10) {
        goto LABEL_628;
      }
      *(void *)(*((void *)v533 + 105) + 8 * v10) = v50;
      uint64_t v10 = v567;
      uint64_t v5 = v520;
      if (v567 <= v12) {
        goto LABEL_629;
      }
      uint64_t v9 = *(void *)(v9 + v20);
      uint64_t v10 = v558;
      if (v558 <= v9) {
        goto LABEL_630;
      }
      uint64_t v52 = *(void *)(v568 + 8 * v12);
      uint64_t v53 = *(void *)(v559 + 8 * v9);
      v585.n128_u32[0] = 28;
      v586 = 0uLL;
      v585.n128_u64[1] = 0;
      re::DynamicArray<re::EvaluationRegister>::add(v529, (uint64_t)&v585);
      uint64_t v13 = *((void *)v533 + 230) - 1;
      unint64_t v54 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v13);
      *(void *)(v54 + 8) = v53;
      *(void *)(v54 + 16) = v11;
      uint64_t v9 = v52 - 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v10 = *((void *)v533 + 103);
      if (v10 <= v9) {
        goto LABEL_631;
      }
      *(void *)(*((void *)v533 + 105) + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v13;
      uint64_t v8 = (_anonymous_namespace_ *)v532;
    }
    ++v12;
    v20 += 56;
    a4 += 24;
    uint64_t v7 = (unint64_t)v5;
  }
  while (v8 != (_anonymous_namespace_ *)v12);
  memset(v556, 0, sizeof(v556));
  uint64_t v9 = (unint64_t)v572;
  re::FixedArray<unsigned long>::init<unsigned long const&>(v556, (uint64_t)v572, (unint64_t)v8, &re::RigNode::kInvalidIndex);
  memset(v555, 0, 24);
  re::FixedArray<unsigned long>::init<unsigned long const&>(v555, (uint64_t)v572, (unint64_t)v8, &re::RigNode::kInvalidIndex);
  unint64_t v56 = (unsigned char *)(*(uint64_t (**)(void *, _anonymous_namespace_ *, uint64_t))(v572[0] + 32))(v572, v8, 1);
  if (!v56)
  {
LABEL_747:
    re::internal::assertLog((re::internal *)4, v57, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    goto LABEL_748;
  }
  uint64_t v13 = (unint64_t)v56;
  uint64_t v58 = v56;
  if (v8 != (_anonymous_namespace_ *)1)
  {
    bzero(v56, (size_t)v8 - 1);
    uint64_t v58 = (char *)v8 + v13 - 1;
  }
  *uint64_t v58 = 0;
  a4 = (unint64_t)v533;
LABEL_52:
  *(void *)&v536 = 0;
  *(void *)&v535 = 0;
  DWORD2(v535) = 0;
  v534 = (unint64_t)v572;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(&v534, (unint64_t)v8);
  ++DWORD2(v535);
  v553 = 0;
  v552 = 0;
  v554 = 0;
  unint64_t v59 = (_anonymous_namespace_ *)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v552, (uint64_t)v572, (unint64_t)v8);
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v9 = a4 + 808;
    unint64_t v12 = 0x7FFFFFFFFFFFFFFELL;
    do
    {
      v585.n128_u64[0] = -1;
      unint64_t v59 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::add((void *)(a4 + 808), &v585);
      unint64_t v11 = v553;
      if (v553 <= v10) {
        goto LABEL_609;
      }
      *(void *)(v554 + 8 * v10++) = *(void *)(a4 + 824) + 0x7FFFFFFFFFFFFFFELL;
    }
    while (v8 != (_anonymous_namespace_ *)v10);
  }
  uint64_t v60 = 0;
  v454 = (void *)(v7 + 8);
  uint64_t v61 = *(void *)(v7 + 1328);
  v607 = *(void *)(v7 + 1336);
  v608 = v61;
  v497 = (_anonymous_namespace_ *)(a4 + 1824);
  v528 = a4 + 1664;
  v530 = (_anonymous_namespace_ *)v13;
  uint64_t v5 = (void *)v7;
  uint64_t v62 = *(void *)(v7 + 1504);
  v609 = *(void *)(v7 + 1520);
  v610 = v62;
  uint64_t v8 = (_anonymous_namespace_ *)0x8000000000000001;
  unint64_t v63 = (uint64_t *)&v607;
  while (1)
  {
    v515 = (_anonymous_namespace_ *)v60;
    v521 = (_anonymous_namespace_ *)*(&v607 + 2 * v60 + 1);
    if (v521) {
      break;
    }
LABEL_112:
    unint64_t v63 = (uint64_t *)(&v607 + 2 * ((void)v515 + 1));
    uint64_t v60 = 1;
    if (v515 == (_anonymous_namespace_ *)1)
    {
      if (!(void)v535) {
        goto LABEL_615;
      }
      unint64_t v80 = *v5;
      uint64_t v81 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v5 + 32))(*v5, 168, 8);
      *(_OWORD *)uint64_t v81 = 0u;
      *(_OWORD *)(v81 + 16) = 0u;
      *(_OWORD *)(v81 + 32) = 0u;
      *(_OWORD *)(v81 + 48) = 0u;
      *(_OWORD *)(v81 + 64) = 0u;
      *(_OWORD *)(v81 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0u;
      *(_OWORD *)(v81 + 96) = 0u;
      *(_OWORD *)(v81 + 112) = 0u;
      *(_OWORD *)(v81 + 128) = 0u;
      *(_OWORD *)(v81 + 144) = 0u;
      *(void *)(v81 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
      v575[0].n128_u64[0] = (unint64_t)&unk_26E6C37C0;
      v575[0].n128_u64[1] = v80;
      v575[1].n128_u64[1] = (unint64_t)v575;
      unint64_t v12 = (unint64_t)&v585.n128_u64[1];
      v585.n128_u64[0] = v81;
      *(void *)&v587 = &v585.n128_u64[1];
      v585.n128_u64[1] = (unint64_t)&unk_26E6C37C0;
      v586.i64[0] = v80;
      std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::operator=[abi:nn180100]((uint64_t *)v611, (uint64_t *)&v585);
      std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v585);
      std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::~__value_func[abi:nn180100](v575);
      re::FixedArray<re::internal::RigIKCall>::init<>(v611[0], *v5, v5[188] + v5[166]);
      uint64_t v82 = v611[0];
      re::FixedArray<re::FixedArray<float>>::operator=(v611[0] + 6, v5 + 168);
      re::FixedArray<re::FixedArray<float>>::operator=(v82 + 9, v5 + 171);
      re::FixedArray<re::TwoBoneIKOptions>::operator=((uint64_t)(v82 + 12), (uint64_t)(v5 + 174));
      re::FixedArray<re::FABRIKOptions>::operator=((uint64_t)(v82 + 15), (uint64_t)(v5 + 177));
      re::FixedArray<re::SplineIKOptions>::operator=((uint64_t)(v82 + 18), (uint64_t)(v5 + 180));
      *(void *)&v606[2] = 0;
      memset(v604, 0, sizeof(v604));
      unint64_t v11 = v532;
      uint64_t v8 = (_anonymous_namespace_ *)v528;
      if (v5[166])
      {
        uint64_t v13 = 0;
        v486 = (_anonymous_namespace_ *)(a4 + 488);
        v492 = (_anonymous_namespace_ *)(a4 + 168);
        v516 = (_anonymous_namespace_ *)(a4 + 608);
        v518 = (void *)(a4 + 288);
        v522 = (_anonymous_namespace_ *)(a4 + 1944);
        do
        {
          uint64_t v10 = 240;
          uint64_t v9 = v611[0][1];
          if (v9 <= v13) {
            goto LABEL_803;
          }
          uint64_t v83 = v5[167] + 136 * v13;
          unint64_t v84 = v611[0][2] + 136 * v13;
          *(void *)unint64_t v84 = *(void *)v83;
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v84 + 8), v83 + 8);
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v84 + 32), v83 + 32);
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v84 + 56), v83 + 56);
          *(_OWORD *)(v84 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)(v83 + 80);
          re::FixedArray<re::Vector3<float>>::operator=((uint64_t *)(v84 + 96), v83 + 96);
          *(_OWORD *)(v84 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = *(_OWORD *)(v83 + 120);
          uint64_t v9 = v5[184];
          if (v9 <= v13) {
            goto LABEL_804;
          }
          int v86 = (unsigned __int8 *)(v5[185] + 16 * v13);
          uint64_t v87 = *((void *)v86 + 1);
          long long v88 = *v86;
          if (v88 == 3)
          {
            uint64_t v9 = v5[166];
            if (v9 <= v13) {
              goto LABEL_813;
            }
            v464 = v87;
            v466 = v13;
            uint64_t v13 = *(void *)(v5[167] + 136 * v13 + 128);
            uint64_t v9 = v5[106];
            if (v9 <= v13) {
              goto LABEL_816;
            }
            v468 = (_anonymous_namespace_ *)v5[108];
            v470 = v13;
            size_t v91 = (char *)v468 + 240 * v13;
            uint64_t v92 = *((void *)v91 + 3);
            memset(v630, 0, 24);
            re::FixedArray<re::EvaluationRegisterId<int>>::init<>(v630, (uint64_t)v572, v92);
            v512 = (_anonymous_namespace_ *)(v91 + 24);
            uint64_t v13 = *((void *)v91 + 3);
            uint64_t v93 = v11;
            if (v13)
            {
              uint64_t v94 = 0;
              unint64_t v11 = 0;
              while (1)
              {
                uint64_t v9 = *(void *)v512;
                if (*(void *)v512 <= v11) {
                  goto LABEL_772;
                }
                uint64_t v95 = (unint64_t *)(*((void *)v468 + 30 * v470 + 5) + v94);
                v585.n128_u32[0] = 4;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                uint64_t v10 = (unint64_t)v533;
                v585.n128_u64[0] = *((void *)v533 + 230) - 1;
                re::DynamicArray<unsigned long>::add(v492, &v585);
                re::DynamicArray<re::Matrix4x4<float>>::add(v486, (uint64_t)(v95 + 2));
                uint64_t v9 = *v95;
                uint64_t v5 = v561;
                if ((unint64_t)v561 <= *v95) {
                  break;
                }
                size_t v96 = *(void *)(*((void *)v533 + 25) + 8 * *((void *)v533 + 23) - 8);
                unint64_t v97 = *(void *)(v562 + 8 * v9);
                v585.n128_u32[0] = 28;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                uint64_t v9 = *((void *)v533 + 230) - 1;
                unint64_t v98 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v9);
                *(void *)(v98 + 8) = v97;
                *(void *)(v98 + 16) = v96;
                uint64_t v8 = *(_anonymous_namespace_ **)&v630[8];
                if (*(void *)&v630[8] <= v11) {
                  goto LABEL_774;
                }
                *(void *)(*(void *)&v630[16] + 8 * v11++) = v9;
                v94 += 80;
                uint64_t v5 = v520;
                uint64_t v93 = v532;
                uint64_t v8 = (_anonymous_namespace_ *)v528;
                if (v13 == v11) {
                  goto LABEL_132;
                }
              }
LABEL_773:
              v549 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              v575[0].n128_u32[0] = 136315906;
              *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
              v575[0].n128_u16[6] = 1024;
              *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
              v575[1].n128_u16[1] = 2048;
              *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
              v575[1].n128_u16[6] = 2048;
              *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = (unint64_t)v5;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_774:
              v549 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              v575[0].n128_u32[0] = 136315906;
              *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
              v575[0].n128_u16[6] = 1024;
              *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
              v575[1].n128_u16[1] = 2048;
              *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
              v575[1].n128_u16[6] = 2048;
              *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = (unint64_t)v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_775:
              *(void *)v604 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              v575[0].n128_u32[0] = 136315906;
              *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
              v575[0].n128_u16[6] = 1024;
              *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
              v575[1].n128_u16[1] = 2048;
              *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
              v575[1].n128_u16[6] = 2048;
              *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v532;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_776;
            }
LABEL_132:
            uint64_t v99 = v611[0];
            uint64_t v9 = v611[0][1];
            uint64_t v13 = v466;
            if (v9 <= v466) {
              goto LABEL_819;
            }
            unint64_t v11 = v93;
            *(void *)(v611[0][2] + 136 * v466 + 88) = *(void *)&v604[16];
            uint64_t v100 = (char *)v468 + 240 * v470;
            v477 = (_anonymous_namespace_ *)*((void *)v100 + 8);
            v480 = (unint64_t *)(v100 + 64);
            a4 = (unint64_t)v533;
            if (v477)
            {
              uint64_t v101 = 0;
              unint64_t v102 = (char *)v468 + 240 * v470;
              v474 = (unint64_t *)(v102 + 144);
              v475 = (unint64_t *)(v102 + 80);
              do
              {
                uint64_t v9 = *v480;
                if (*v480 <= v101) {
                  goto LABEL_783;
                }
                uint64_t v13 = *v475;
                v585.n128_u32[0] = 7;
                v495 = v101;
                unint64_t v103 = (__n128 *)(v13 + 96 * v101);
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
                re::DynamicArray<unsigned long>::add(v518, &v585);
                re::DynamicArray<re::Vector3<float>>::add(v516, v103 + 5);
                uint64_t v9 = *v474;
                uint64_t v10 = (unint64_t)v561;
                if ((unint64_t)v561 <= *v474) {
                  goto LABEL_784;
                }
                uint64_t v10 = v564;
                if (v564 <= v9) {
                  goto LABEL_785;
                }
                uint64_t v10 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
                int v104 = *(void *)(v562 + 8 * v9);
                size_t v105 = *(void *)(v565 + 8 * v9);
                v585.n128_u32[0] = 20;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                size_t v106 = *(void *)(a4 + 1840) - 1;
                uint64_t v8 = (_anonymous_namespace_ *)v528;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v106) + 8) = v105;
                uint64_t v5 = (void *)v528;
                v585.n128_u32[0] = 28;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                unint64_t v11 = *(void *)(a4 + 1840) - 1;
                unint64_t v107 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v11);
                *(void *)(v107 + 8) = v104;
                *(void *)(v107 + 16) = v106;
                v585.n128_u32[0] = 43;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                v513 = (_anonymous_namespace_ *)(*(void *)(a4 + 1960) - 1);
                unint64_t v108 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, (unint64_t)v513);
                *(void *)(v108 + 8) = v11;
                *(void *)(v108 + 16) = v10;
                v575[0] = 0uLL;
                v585.n128_u32[0] = 7;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
                re::DynamicArray<unsigned long>::add(v518, &v585);
                re::DynamicArray<re::Vector3<float>>::add(v516, v575);
                v546 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
                v505 = v103[1].n128_u64[0];
                if (v505)
                {
                  a4 = 0;
                  uint64_t v109 = v13 + 96 * v495;
                  v499 = (void *)(v109 + 72);
                  v502 = (_anonymous_namespace_ *)(v109 + 56);
                  do
                  {
                    uint64_t v9 = *(void *)v502;
                    if (*(void *)v502 <= a4) {
                      goto LABEL_648;
                    }
                    uint64_t v110 = (const float *)(*v499 + 4 * a4);
                    uint64_t v111 = vld1q_dup_f32(v110);
                    v575[0] = (__n128)v111;
                    v585.n128_u32[0] = 7;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                    v585.n128_u64[0] = *((void *)v533 + 245) - 1;
                    re::DynamicArray<unsigned long>::add(v518, &v585);
                    re::DynamicArray<re::Vector3<float>>::add(v516, v575);
                    uint64_t v9 = v103[1].n128_u64[0];
                    if (v9 <= a4) {
                      goto LABEL_649;
                    }
                    unint64_t v11 = *(void *)(v103[2].n128_u64[0] + 8 * a4);
                    uint64_t v9 = *(void *)&v630[8];
                    if (*(void *)&v630[8] <= v11) {
                      goto LABEL_650;
                    }
                    uint64_t v10 = (unint64_t)v533;
                    char v112 = *(void *)(*((void *)v533 + 40) + 8 * *((void *)v533 + 38) - 8);
                    long long v113 = v546;
                    long long v114 = *(void *)(*(void *)&v630[16] + 8 * v11);
                    v585.n128_u32[0] = 43;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    uint64_t v8 = (_anonymous_namespace_ *)v103;
                    re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                    uint64_t v115 = *((void *)v533 + 245) - 1;
                    unint64_t v116 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v115);
                    *(void *)(v116 + 8) = v114;
                    uint64_t v5 = (void *)v528;
                    *(void *)(v116 + 16) = v513;
                    v585.n128_u32[0] = 25;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                    uint64_t v13 = *((void *)v533 + 245) - 1;
                    unint64_t v117 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v13);
                    *(void *)(v117 + 8) = v115;
                    *(void *)(v117 + 16) = v112;
                    v585.n128_u32[0] = 8;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
                    unint64_t v11 = *((void *)v533 + 245) - 1;
                    unint64_t v118 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v11);
                    *(void *)(v118 + 8) = v113;
                    *(void *)(v118 + 16) = v13;
                    v546 = v11;
                    ++a4;
                  }
                  while (v505 != a4);
                }
                uint64_t v8 = (_anonymous_namespace_ *)v5;
                re::DynamicArray<unsigned long>::add(v604, &v546);
                uint64_t v101 = v495 + 1;
                uint64_t v5 = v520;
                unint64_t v11 = v532;
                a4 = (unint64_t)v533;
              }
              while ((_anonymous_namespace_ *)(v495 + 1) != v477);
              uint64_t v99 = v611[0];
              uint64_t v13 = v466;
            }
            uint64_t v9 = v99[19];
            unint64_t v119 = (_anonymous_namespace_ *)v464;
            if (v9 <= v464) {
              goto LABEL_820;
            }
            uint64_t v9 = v99[1];
            if (v9 <= v13) {
              goto LABEL_821;
            }
            *(void *)(v99[2] + 136 * v13 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v99[20] + 80 * v464;
            uint64_t v121 = v468;
            uint64_t v120 = v470;
            unint64_t v122 = (char *)v468 + 240 * v470;
            int v124 = *((void *)v122 + 20);
            uint64_t v123 = (unint64_t *)(v122 + 160);
            if (v124 != -1)
            {
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
              re::DynamicArray<unsigned long>::add(v518, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v516, (__n128 *)v468 + 15 * v470 + 11);
              uint64_t v9 = *v123;
              uint64_t v10 = (unint64_t)v561;
              if ((unint64_t)v561 <= *v123) {
                goto LABEL_822;
              }
              v585.n128_u64[0] = re::EvaluationTree::transformDirection(a4, *(void *)(v562 + 8 * v9), *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8));
              re::DynamicArray<unsigned long>::add(v604, &v585);
              uint64_t v121 = v468;
              uint64_t v120 = v470;
            }
            uint64_t v125 = (char *)v121 + 240 * v120;
            uint64_t v127 = *((void *)v125 + 21);
            unint64_t v126 = (unint64_t *)(v125 + 168);
            if (v127 != -1)
            {
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              unint64_t v128 = (__n128 *)((char *)v121 + 240 * v120 + 192);
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v522, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
              re::DynamicArray<unsigned long>::add(v518, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v516, v128);
              uint64_t v9 = *v126;
              uint64_t v10 = (unint64_t)v561;
              if ((unint64_t)v561 <= *v126) {
                goto LABEL_823;
              }
              v585.n128_u64[0] = re::EvaluationTree::transformDirection(a4, *(void *)(v562 + 8 * v9), *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8));
              re::DynamicArray<unsigned long>::add(v604, &v585);
            }
            if (*(void *)v630 && *(void *)&v630[8]) {
              (*(void (**)(void))(**(void **)v630 + 40))();
            }
          }
          else
          {
            if (v88 == 2)
            {
              uint64_t v89 = v611[0];
              uint64_t v9 = v611[0][16];
              if (v9 <= v87) {
                goto LABEL_814;
              }
              uint64_t v9 = v611[0][1];
              if (v9 <= v13) {
                goto LABEL_817;
              }
              long long v90 = v611[0][17] + 8 * v87;
            }
            else
            {
              if (v88 != 1) {
                goto LABEL_834;
              }
              uint64_t v89 = v611[0];
              uint64_t v9 = v611[0][13];
              if (v9 <= v87) {
                goto LABEL_812;
              }
              uint64_t v9 = v611[0][1];
              if (v9 <= v13) {
                goto LABEL_815;
              }
              long long v90 = v611[0][14] + 32 * v87;
            }
            *(void *)(v89[2] + 136 * v13 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v90;
          }
          ++v13;
        }
        while (v13 < v5[166]);
      }
      uint64_t v7 = v11;
      if (v5[188])
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        unint64_t v11 = 136;
        do
        {
          unint64_t v12 = v10 + v5[166];
          uint64_t v13 = v611[0][1];
          if (v13 <= v12) {
            goto LABEL_788;
          }
          long long v129 = v5[190] + v9;
          uint64_t v130 = v611[0][2] + 136 * v12;
          *(void *)uint64_t v130 = *(void *)v129;
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v130 + 8), v129 + 8);
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v130 + 32), v129 + 32);
          re::FixedArray<unsigned long>::operator=((uint64_t *)(v130 + 56), v129 + 56);
          *(_OWORD *)(v130 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)(v129 + 80);
          re::FixedArray<re::Vector3<float>>::operator=((uint64_t *)(v130 + 96), v129 + 96);
          *(_OWORD *)(v130 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = *(_OWORD *)(v129 + 120);
          uint64_t v5 = v520;
          ++v10;
          v9 += 136;
        }
        while (v10 < v520[188]);
      }
      __int16 v131 = v611[0];
      long long v132 = v611[0][1];
      if (v132)
      {
        uint64_t v133 = (void *)v611[0][2];
        char v134 = &v133[17 * v132];
        while (1)
        {
          uint64_t v135 = v133[2];
          if (v135) {
            break;
          }
LABEL_172:
          long long v139 = v133[5];
          if (v139)
          {
            uint64_t v140 = (unint64_t *)v133[6];
            long long v141 = *(void *)&v556[16];
            __int16 v142 = 8 * v139;
            do
            {
              uint64_t v9 = *v140;
              uint64_t v10 = *(void *)&v556[8];
              if (*(void *)&v556[8] <= *v140) {
                goto LABEL_720;
              }
              *v140++ = *(void *)(v141 + 8 * v9);
              v142 -= 8;
            }
            while (v142);
          }
          __int16 v143 = v133[8];
          if (v143)
          {
            unint64_t v144 = (unint64_t *)v133[9];
            __int16 v145 = *(void *)&v556[16];
            int32x4_t v146 = 8 * v143;
            while (1)
            {
              uint64_t v9 = *v144;
              uint64_t v10 = *(void *)&v556[8];
              if (*(void *)&v556[8] <= *v144) {
                break;
              }
              *v144++ = *(void *)(v145 + 8 * v9);
              v146 -= 8;
              if (!v146) {
                goto LABEL_180;
              }
            }
LABEL_721:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_722;
          }
LABEL_180:
          v133 += 17;
          if (v133 == v134) {
            goto LABEL_181;
          }
        }
        long long v136 = (unint64_t *)v133[3];
        long long v137 = *(void *)&v556[16];
        long long v138 = 8 * v135;
        while (1)
        {
          uint64_t v9 = *v136;
          uint64_t v10 = *(void *)&v556[8];
          if (*(void *)&v556[8] <= *v136) {
            break;
          }
          *v136++ = *(void *)(v137 + 8 * v9);
          v138 -= 8;
          if (!v138) {
            goto LABEL_172;
          }
        }
LABEL_719:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_720:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_721;
      }
LABEL_181:
      re::FixedArray<int>::init<>(v131 + 3, *v5, v535);
      long long v147 = v535;
      uint64_t v13 = (unint64_t)v530;
      if ((void)v535)
      {
        uint64_t v9 = 0;
        long long v148 = v536;
        long long v149 = v611[0];
        uint64_t v10 = v555[0].n128_u64[1];
        uint64_t v150 = v555[1].n128_u64[0];
        while (1)
        {
          unint64_t v11 = *(void *)(v148 + 8 * v9);
          if (v10 <= v11) {
            goto LABEL_797;
          }
          unint64_t v12 = v149[4];
          if (v12 <= v9) {
            break;
          }
          *(_DWORD *)(v149[5] + 4 * v9++) = *(void *)(v150 + 8 * v11);
          if (v147 == v9) {
            goto LABEL_186;
          }
        }
LABEL_798:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      else
      {
LABEL_186:
        v550 = 0;
        v549 = 0;
        v551 = 0;
        re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v549, (uint64_t)v572, v147);
        uint64_t v8 = (_anonymous_namespace_ *)v528;
        unint64_t v12 = v7;
        if (!(void)v535) {
          goto LABEL_651;
        }
        uint64_t v9 = 0;
        uint64_t v151 = v536;
        uint64_t v152 = v554;
        uint64_t v153 = v551;
        while (1)
        {
          uint64_t v10 = *(void *)(v151 + 8 * v9);
          unint64_t v11 = v553;
          if (v553 <= v10) {
            break;
          }
          unint64_t v11 = v550;
          if (v550 <= v9) {
            goto LABEL_800;
          }
          *(void *)(v153 + 8 * v9++) = *(void *)(v152 + 8 * v10);
          int v154 = v535;
          if (v9 >= (unint64_t)v535) {
            goto LABEL_652;
          }
        }
      }
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_800:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_801:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_802:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_803:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_804:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_805:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_806:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_807:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v10;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_808:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 468;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v10;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_809:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 789;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_810:
      v574 = 0;
      v576 = 0u;
      v577 = 0u;
      memset(v575, 0, sizeof(v575));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v630 = 136315906;
      *(void *)&v630[4] = "operator[]";
      *(_WORD *)&v630[12] = 1024;
      *(_DWORD *)&v630[14] = 789;
      *(_WORD *)&v630[18] = 2048;
      *(void *)&v630[20] = v9;
      v631 = 2048;
      v632 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_811:
      re::internal::assertLog((re::internal *)4, v170, "assertion failure: '%s' (%s:line %i) Unexpected rig parameter type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1456);
      _os_crash();
      __break(1u);
LABEL_812:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      v437 = v87;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v437;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_813:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_814:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      v438 = v87;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v438;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_815:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_816:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_817:
      *(void *)v630 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_818:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Unexpected rig node type.", "!\"Unreachable code\"", "constructEvaluationCommands", 728);
      _os_crash();
      __break(1u);
LABEL_819:
      v549 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_820:
      v549 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      uint64_t v10 = (unint64_t)v119;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_821:
      v549 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v13;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_822:
      v549 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_823:
      v549 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_824:
      re::internal::assertLog((re::internal *)4, v170, "assertion failure: '%s' (%s:line %i) Unexpected node channel type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1433);
      _os_crash();
      __break(1u);
LABEL_825:
      re::internal::assertLog((re::internal *)4, v170, "assertion failure: '%s' (%s:line %i) Invalid parameter rig node type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1417);
      _os_crash();
      __break(1u);
LABEL_826:
      re::internal::assertLog((re::internal *)4, v159, "assertion failure: '%s' (%s:line %i) Unexpected constraint type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1574);
      _os_crash();
      __break(1u);
LABEL_827:
      re::internal::assertLog((re::internal *)5, v170, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "constructEvaluationCommands", 1443, v180);
      _os_crash();
      __break(1u);
LABEL_828:
      re::internal::assertLog((re::internal *)5, v170, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "constructEvaluationCommands", 1451, v185);
      _os_crash();
      __break(1u);
LABEL_829:
      re::internal::assertLog((re::internal *)4, v159, "assertion failure: '%s' (%s:line %i) Unexpected rig destination type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1568);
      _os_crash();
      __break(1u);
LABEL_830:
      re::internal::assertLog((re::internal *)4, v243, "assertion failure: '%s' (%s:line %i) Unexpected aim constraint forward axis type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1260);
      _os_crash();
      __break(1u);
    }
  }
  unint64_t v11 = 0;
  v510 = (_anonymous_namespace_ *)v63;
  unint64_t v12 = *v63;
  do
  {
    uint64_t v64 = v12 + 136 * v11;
    uint64_t v66 = *(void *)(v64 + 64);
    unint64_t v65 = (unint64_t *)(v64 + 64);
    if (v66)
    {
      uint64_t v67 = 0;
      while (1)
      {
        *(void *)v630 = 0;
        uint64_t v7 = *v65;
        if (*v65 <= v67) {
          break;
        }
        a4 = *(void *)(*(void *)(v12 + 136 * v11 + 72) + 8 * v67);
        *(void *)v630 = a4;
        uint64_t v7 = *(void *)&v556[8];
        if (*(void *)&v556[8] <= a4) {
          goto LABEL_506;
        }
        if (*(void *)(*(void *)&v556[16] + 8 * a4) == -1)
        {
          *(void *)(*(void *)&v556[16] + 8 * a4) = v535;
          a4 = *(void *)v630;
          uint64_t v7 = v553;
          if (v553 <= *(void *)v630) {
            goto LABEL_507;
          }
          uint64_t v7 = (unint64_t)v561;
          if ((unint64_t)v561 <= *(void *)v630) {
            goto LABEL_508;
          }
          uint64_t v7 = *(void *)(v554 + 8 * *(void *)v630) - 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v68 = *((void *)v533 + 103);
          if (v68 <= v7) {
            goto LABEL_509;
          }
          *(void *)(*((void *)v533 + 105) + 8 * v7) = *(void *)(v562 + 8 * *(void *)v630);
          uint64_t v7 = *(void *)v630;
          if (v532 <= *(void *)v630) {
            goto LABEL_510;
          }
          *((unsigned char *)v530 + *(void *)v630) = 0;
          unint64_t v59 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::add(&v534, v630);
        }
        if (++v67 >= *v65) {
          goto LABEL_70;
        }
      }
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v67;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_506:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = a4;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_507:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = a4;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_508:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      uint64_t v68 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = a4;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_509:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v7;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v68;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_510:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v7;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v532;
      v439 = 38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_511;
    }
LABEL_70:
    ++v11;
  }
  while ((_anonymous_namespace_ *)v11 != v521);
  uint64_t v69 = 0;
  uint64_t v70 = *(void *)v510;
  a4 = (unint64_t)v533;
  uint64_t v7 = (unint64_t)v497;
  uint64_t v13 = (unint64_t)v530;
  v479 = *(void *)v510;
  while (1)
  {
    v485 = v69;
    v504 = (unint64_t *)(v70 + 136 * (void)v69 + 40);
    v491 = (_anonymous_namespace_ *)*v504;
    if (*v504) {
      break;
    }
LABEL_111:
    uint64_t v70 = v479;
    uint64_t v69 = (_anonymous_namespace_ *)((char *)v485 + 1);
    if ((_anonymous_namespace_ *)((char *)v485 + 1) == v521) {
      goto LABEL_112;
    }
  }
  uint64_t v10 = 0;
  uint64_t v71 = (unint64_t *)(v479 + 136 * (void)v69);
  v498 = v71 + 2;
  v501 = (_anonymous_namespace_ *)(v71 + 6);
  v494 = (_anonymous_namespace_ *)(v71 + 3);
  while (2)
  {
    uint64_t v9 = *v504;
    if (*v504 <= v10) {
      goto LABEL_717;
    }
    unint64_t v11 = *(void *)(*(void *)v501 + 8 * v10);
    *(void *)v630 = 0;
    uint64_t v9 = *v498;
    if (*v498 <= v10)
    {
LABEL_718:
      *(void *)v604 = 0;
      v589 = 0u;
      v588 = 0u;
      v587 = 0u;
      v586 = 0u;
      v585 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v575[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
      v575[0].n128_u16[6] = 1024;
      *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
      v575[1].n128_u16[1] = 2048;
      *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
      v575[1].n128_u16[6] = 2048;
      *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_719;
    }
    v511 = (_anonymous_namespace_ *)v10;
    *(void *)v630 = *(void *)(*(void *)v494 + 8 * v10);
    v549 = v11;
    uint64_t v9 = v11;
    if (v11 == *(void *)v630)
    {
LABEL_93:
      uint64_t v10 = *(void *)&v556[8];
      if (*(void *)&v556[8] <= v9) {
        goto LABEL_729;
      }
      if (*(void *)(*(void *)&v556[16] + 8 * v9) == -1)
      {
        *(void *)(*(void *)&v556[16] + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v535;
        uint64_t v9 = *(void *)v630;
        a4 = (unint64_t)v533;
        if (v532 <= *(void *)v630) {
          goto LABEL_775;
        }
        *(unsigned char *)(v13 + *(void *)v630) = 2;
        uint64_t v9 = *(void *)v630;
        uint64_t v10 = v553;
        if (v553 <= *(void *)v630)
        {
LABEL_776:
          *(void *)v604 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_777:
          *(void *)v604 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_778:
          *(void *)v604 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_779:
          *(void *)v630 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v604 = 136315906;
          *(void *)&v604[4] = "operator[]";
          *(_WORD *)&v604[12] = 1024;
          *(_DWORD *)&v604[14] = 468;
          *(_WORD *)&v604[18] = 2048;
          *(void *)&v604[20] = v9;
          v605 = 2048;
          *(void *)v606 = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_780:
          *(void *)v630 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v604 = 136315906;
          *(void *)&v604[4] = "operator[]";
          *(_WORD *)&v604[12] = 1024;
          *(_DWORD *)&v604[14] = 789;
          *(_WORD *)&v604[18] = 2048;
          *(void *)&v604[20] = v10;
          v605 = 2048;
          *(void *)v606 = v11;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_781:
          *(void *)v630 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v604 = 136315906;
          *(void *)&v604[4] = "operator[]";
          *(_WORD *)&v604[12] = 1024;
          *(_DWORD *)&v604[14] = 797;
          *(_WORD *)&v604[18] = 2048;
          *(void *)&v604[20] = 1;
          v605 = 2048;
          *(void *)v606 = 1;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_782:
          *(void *)v630 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v604 = 136315906;
          *(void *)&v604[4] = "operator[]";
          *(_WORD *)&v604[12] = 1024;
          *(_DWORD *)&v604[14] = 797;
          *(_WORD *)&v604[18] = 2048;
          *(void *)&v604[20] = 1;
          v605 = 2048;
          *(void *)v606 = 1;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_783:
          v549 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          uint64_t v10 = v101;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_784:
          v549 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_785:
          v549 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v575[0].n128_u32[0] = 136315906;
          *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
          v575[0].n128_u16[6] = 1024;
          *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
          v575[1].n128_u16[1] = 2048;
          *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
          v575[1].n128_u16[6] = 2048;
          *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_786;
        }
        uint64_t v10 = (unint64_t)v561;
        if ((unint64_t)v561 <= *(void *)v630) {
          goto LABEL_777;
        }
        uint64_t v10 = *(void *)(v554 + 8 * *(void *)v630) - 0x7FFFFFFFFFFFFFFFLL;
        unint64_t v12 = *((void *)v533 + 103);
        if (v12 <= v10) {
          goto LABEL_778;
        }
        *(void *)(*((void *)v533 + 105) + 8 * v10) = *(void *)(v562 + 8 * *(void *)v630);
        unint64_t v59 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::add(&v534, v630);
        uint64_t v9 = *(void *)v630;
      }
      else
      {
        a4 = (unint64_t)v533;
        if (v532 <= v9) {
          goto LABEL_749;
        }
        if (*(unsigned char *)(v13 + v9) != 2)
        {
          v426 = v585;
          v427 = v586;
          *(unsigned char *)a5 = 0;
          *(void *)(a5 + 8) = 3000;
          *(void *)(a5 + 16) = &re::AnimationErrorCategory(void)::instance;
          *(__n128 *)(a5 + 24) = v426;
          *(float32x4_t *)(a5 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v427;
          goto LABEL_194;
        }
      }
      if (v11 != v9)
      {
        unint64_t v75 = *(void *)&v556[16];
        uint64_t v76 = v555[1].n128_u64[0];
        uint64_t v9 = v5[131];
        do
        {
          if (v9 <= v11)
          {
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_617:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_618:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_619:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_620;
          }
          unint64_t v77 = v5[133] + 56 * v11;
          unint64_t v79 = *(void *)(v77 + 32);
          unint64_t v78 = (unint64_t *)(v77 + 32);
          uint64_t v9 = v79;
          uint64_t v10 = *(void *)&v556[8];
          if (*(void *)&v556[8] <= v79) {
            goto LABEL_617;
          }
          uint64_t v10 = v555[0].n128_u64[1];
          if (v555[0].n128_u64[1] <= v11) {
            goto LABEL_618;
          }
          *(void *)(v76 + 8 * v11) = *(void *)(v75 + 8 * v9);
          uint64_t v9 = v5[131];
          if (v9 <= v11) {
            goto LABEL_619;
          }
          unint64_t v11 = *v78;
        }
        while (*v78 != *(void *)v630);
      }
      uint64_t v10 = (unint64_t)v511 + 1;
      if ((_anonymous_namespace_ *)((char *)v511 + 1) == v491) {
        goto LABEL_111;
      }
      continue;
    }
    break;
  }
  a4 = v5[131];
  uint64_t v9 = v11;
  while (1)
  {
    if (a4 <= v9) {
      goto LABEL_636;
    }
    unint64_t v12 = *(void *)(v5[133] + 56 * v9 + 32);
    if (v12 == -1) {
      break;
    }
    uint64_t v10 = *(void *)&v556[8];
    if (*(void *)&v556[8] <= v9) {
      goto LABEL_637;
    }
    if (*(void *)(*(void *)&v556[16] + 8 * v9) == -1)
    {
      *(void *)(*(void *)&v556[16] + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v535;
      uint64_t v9 = v549;
      if (v532 <= v549)
      {
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v532;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_678:
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_679:
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_680:
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_681:
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_682:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v10;
        v605 = 2048;
        *(void *)v606 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_683:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v10;
        v605 = 2048;
        *(void *)v606 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_684:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v7;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_685:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v7;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_686:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v7;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_687:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v7;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_688:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v7;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_689:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        v436 = v238;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v436;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_690:
        *(void *)v556 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        uint64_t v10 = v328;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v10;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_691:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v10;
        v605 = 2048;
        *(void *)v606 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_692:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v10;
        v605 = 2048;
        *(void *)v606 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_693:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_694:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_695:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_696:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_697:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_698:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_699:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_700:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_701:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_702:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_703:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_704:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_705:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_706:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_707:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_708:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_709:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_710:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_711:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_712:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_713:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_714:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_715:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_716:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 468;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_717:
        *(void *)v604 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 476;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_718;
      }
      *(unsigned char *)(v13 + v54re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 1;
      uint64_t v9 = v549;
      uint64_t v10 = v553;
      if (v553 <= v549) {
        goto LABEL_678;
      }
      if (v553 <= v12) {
        goto LABEL_679;
      }
      uint64_t v10 = v570;
      if (v570 <= v549) {
        goto LABEL_680;
      }
      unint64_t v72 = *(void *)(v554 + 8 * v549);
      uint64_t v73 = *(void *)(v554 + 8 * v12);
      uint64_t v5 = *(void **)(v571 + 8 * v549);
      v585.n128_u32[0] = 28;
      v586 = 0uLL;
      v585.n128_u64[1] = 0;
      re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
      uint64_t v13 = (unint64_t)v533;
      uint64_t v9 = *((void *)v533 + 230) - 1;
      double v74 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v9);
      *(void *)(v74 + 8) = v73;
      *(void *)(v74 + 16) = v5;
      uint64_t v10 = v72 - 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v12 = *((void *)v533 + 103);
      if (v12 <= v72 - 0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_681;
      }
      *(void *)(*((void *)v533 + 105) + 8 * v10) = v9;
      unint64_t v59 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::add(&v534, &v549);
      uint64_t v9 = v549;
      uint64_t v5 = v520;
      a4 = v520[131];
      uint64_t v13 = (unint64_t)v530;
    }
    else
    {
      if (v532 <= v9) {
        goto LABEL_646;
      }
      if (*(unsigned char *)(v13 + v9) != 1)
      {
        float32x4_t v155 = "Effected IK node cannot be a target or root - circular dependency detected.";
        goto LABEL_193;
      }
    }
    if (a4 <= v9) {
      goto LABEL_638;
    }
    uint64_t v9 = *(void *)(v5[133] + 56 * v9 + 32);
    v549 = v9;
    if (v9 == *(void *)v630) {
      goto LABEL_93;
    }
  }
  float32x4_t v155 = "IK effector is not a valid chain to the root.";
LABEL_193:
  float32x4_t v156 = v585;
  int32x2_t v157 = v586;
  *(unsigned char *)a5 = 0;
  *(void *)(a5 + 8) = 3000;
  *(void *)(a5 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(__n128 *)(a5 + 24) = v156;
  *(float32x4_t *)(a5 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v157;
  a4 = (unint64_t)v533;
LABEL_194:
  unint64_t v158 = 0;
LABEL_195:
  unint64_t v12 = v532;
  uint64_t v8 = (_anonymous_namespace_ *)v528;
LABEL_196:
  if (v552 && v553) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v552 + 40))(v552, v554);
  }
  if ((void)v534 && (void)v536) {
    (*(void (**)(void, void))(*(void *)v534 + 40))(v534, v536);
  }
  if (v12) {
    (*(void (**)(void *, unint64_t))(v572[0] + 40))(v572, v13);
  }
  if (v555[0].n128_u64[0] && v555[0].n128_u64[1]) {
    (*(void (**)(unint64_t, unint64_t))(*(void *)v555[0].n128_u64[0] + 40))(v555[0].n128_u64[0], v555[1].n128_u64[0]);
  }
  if (*(void *)v556 && *(void *)&v556[8]) {
    (*(void (**)(void, void))(**(void **)v556 + 40))(*(void *)v556, *(void *)&v556[16]);
  }
  if (!v158) {
    goto LABEL_574;
  }
  v584 = 0u;
  v583 = 0u;
  v582 = 0u;
  v581 = 0u;
  v580 = 0u;
  v579 = 0u;
  v577 = 0u;
  v578 = 0u;
  v576 = 0u;
  memset(v575, 0, sizeof(v575));
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(v575, (uint64_t)v572, v5[28]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v575[1].n128_u64[1], (uint64_t)v572, v5[33]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v576, (uint64_t)v572, v5[38]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v577 + 1, (uint64_t)v572, v5[43]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v579, (uint64_t)v572, v5[48]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v580 + 1, (uint64_t)v572, v5[53]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v582, (uint64_t)v572, v5[58]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v583 + 1, (uint64_t)v572, v5[63]);
  v544 = 0u;
  v545 = 0u;
  v542 = 0u;
  v543 = 0u;
  v540 = 0u;
  v541 = 0u;
  v538 = 0u;
  v539 = 0u;
  v536 = 0u;
  v537 = 0u;
  uint64_t v10 = (unint64_t)&v534;
  v534 = 0u;
  v535 = 0u;
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v534, (uint64_t)v572, v5[71]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v535 + 1, (uint64_t)v572, v5[72]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v537, (uint64_t)v572, v5[73]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v538 + 1, (uint64_t)v572, v5[74]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v540, (uint64_t)v572, v5[75]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v541 + 1, (uint64_t)v572, v5[76]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v543, (uint64_t)v572, v5[77]);
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v544 + 1, (uint64_t)v572, v5[78]);
  if (v12)
  {
    unint64_t v11 = 0;
    v462 = (_anonymous_namespace_ *)(a4 + 288);
    v460 = (_anonymous_namespace_ *)(a4 + 608);
    v447 = (_anonymous_namespace_ *)(a4 + 328);
    v448 = (_anonymous_namespace_ *)(a4 + 8);
    v496 = (_anonymous_namespace_ *)(a4 + 1944);
    v445 = (_anonymous_namespace_ *)(a4 + 568);
    v446 = (_anonymous_namespace_ *)(a4 + 248);
    v455 = (_anonymous_namespace_ *)(a4 + 528);
    v456 = (_anonymous_namespace_ *)(a4 + 208);
    v503 = (_anonymous_namespace_ *)(a4 + 1864);
    v443 = (_anonymous_namespace_ *)(a4 + 168);
    v444 = (_anonymous_namespace_ *)(a4 + 1904);
    v441 = (_anonymous_namespace_ *)(a4 + 128);
    v442 = (_anonymous_namespace_ *)(a4 + 488);
    v440 = (_anonymous_namespace_ *)(a4 + 448);
    v517 = (_anonymous_namespace_ *)(a4 + 408);
    v519 = (void *)(a4 + 88);
    v514 = (_anonymous_namespace_ *)(a4 + 1744);
    v467 = (_anonymous_namespace_ *)(a4 + 48);
    v469 = (_anonymous_namespace_ *)(a4 + 1784);
    v463 = (_anonymous_namespace_ *)(a4 + 1704);
    v465 = (_anonymous_namespace_ *)(a4 + 368);
    while (1)
    {
      uint64_t v9 = v5[131];
      if (v9 <= v11) {
        goto LABEL_736;
      }
      uint64_t v9 = v567;
      if (v567 <= v11) {
        goto LABEL_737;
      }
      float32x4_t v160 = v5[133];
      float v161 = *(void *)(v568 + 8 * v11);
      v476 = (void *)(v160 + 56 * v11 + 40);
      v478 = v11;
      if (!*v476)
      {
        uint64_t v13 = *(void *)(v568 + 8 * v11);
        goto LABEL_474;
      }
      float32x4_t v162 = 0;
      v453 = v160 + 56 * v11;
      v461 = (unint64_t *)(v453 + 32);
      do
      {
        v500 = v161;
        uint64_t v9 = (unint64_t)v162 + *(void *)(v453 + 48);
        uint64_t v10 = v5[121];
        if (v10 <= v9) {
          goto LABEL_632;
        }
        v493 = v162;
        float32x4_t v163 = v5[123] + 16 * v9;
        uint64_t v7 = *(void *)(v163 + 8);
        switch(*(unsigned char *)v163)
        {
          case 1:
            uint64_t v9 = v5[3];
            if (v9 <= v7) {
              goto LABEL_684;
            }
            uint64_t v13 = v5[5] + 88 * v7;
            if ((*(unsigned char *)(v13 + 1) & *(unsigned char *)v13 & *(unsigned char *)(v13 + 2)) == (*(unsigned __int8 *)(v13 + 1) | *(unsigned __int8 *)v13 | *(unsigned __int8 *)(v13 + 2)))
            {
              uint64_t v10 = v564;
              unint64_t v11 = v478;
              if (v564 > v478)
              {
                float32x4_t v164 = *(void *)(v565 + 8 * v478);
                v585.n128_u32[0] = 37;
                unint64_t v12 = (unint64_t)&v585.n128_u64[1];
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                uint64_t v10 = (unint64_t)v496;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v11 = *(void *)(a4 + 1960) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v11)
                          + 8) = v164;
                v585.n128_u32[0] = 8;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                int32x2_t v165 = *(void *)(a4 + 1960) - 1;
                int32x2_t v166 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v165);
                *(void *)(v166 + 8) = v11;
                *(void *)(v166 + 16) = v9;
                v585.n128_u32[0] = 34;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
                int32x4_t v167 = *((void *)v533 + 225) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>((uint64_t)v8, v167)+ 8) = v500;
                v585.n128_u32[0] = 40;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                uint64_t v13 = *((void *)v533 + 230) - 1;
                int32x4_t v168 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v13);
                *(void *)(v168 + 8) = v167;
                *(void *)(v168 + 16) = v165;
                a4 = (unint64_t)v533;
                goto LABEL_470;
              }
LABEL_723:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v11;
              v605 = 2048;
              *(void *)v606 = v10;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_724:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v11;
              v605 = 2048;
              *(void *)v606 = v10;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_725:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v10;
              v605 = 2048;
              *(void *)v606 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_726:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v7;
              v605 = 2048;
              *(void *)v606 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_727:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 797;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v10;
              v605 = 2048;
              *(void *)v606 = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_728:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v7;
              v605 = 2048;
              *(void *)v606 = v10;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_729:
              *(void *)v604 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              v575[0].n128_u32[0] = 136315906;
              *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
              v575[0].n128_u16[6] = 1024;
              *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
              v575[1].n128_u16[1] = 2048;
              *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
              v575[1].n128_u16[6] = 2048;
              *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_730:
              v607 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 797;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v10;
              v605 = 2048;
              *(void *)v606 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_731;
            }
            uint64_t v10 = *v461;
            if (*v461 != -1)
            {
              unint64_t v11 = (unint64_t)v561;
              if ((unint64_t)v561 <= v10) {
                goto LABEL_742;
              }
              long long v253 = *(void *)(v562 + 8 * v10);
              v585.n128_u32[0] = 20;
              unint64_t v12 = (unint64_t)&v585.n128_u64[1];
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
              unint64_t v254 = *(void *)(a4 + 1840) - 1;
              *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v254)+ 8) = v253;
              v585.n128_u32[0] = 28;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
              a4 = *(void *)(a4 + 1840) - 1;
              uint64_t v255 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, a4);
              *(void *)(v255 + 8) = v254;
              *(void *)(v255 + 16) = v500;
              v500 = a4;
            }
            uint64_t v10 = v570;
            unint64_t v11 = v478;
            if (v570 <= v478) {
              goto LABEL_724;
            }
            long long v256 = *(void *)(v571 + 8 * v478);
            v585.n128_u32[0] = 37;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            unint64_t v12 = (unint64_t)v496;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            uint64_t v10 = (unint64_t)v533;
            uint64_t v257 = *((void *)v533 + 245) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v257) + 8) = v256;
            v585.n128_u32[0] = 8;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            uint64_t v258 = *((void *)v533 + 245) - 1;
            v259 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v258);
            *(void *)(v259 + 8) = v257;
            *(void *)(v259 + 16) = v9;
            v585.n128_u32[0] = 37;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            int v260 = *((void *)v533 + 245) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v260) + 8) = v500;
            uint64_t v261 = v258;
            a4 = (unint64_t)v533;
            v585.n128_u32[0] = 34;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            unint64_t v11 = *((void *)v533 + 225) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>((uint64_t)v8, v11)
                      + 8) = v500;
            v585.n128_u32[0] = 40;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
            uint64_t v13 = *((void *)v533 + 230) - 1;
            long long v264 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v13);
            *(void *)(v264 + 8) = v11;
            *(void *)(v264 + 16) = ConstrainedComponents;
            uint64_t v9 = *v461;
            if (*v461 == -1) {
              goto LABEL_470;
            }
            uint64_t v10 = (unint64_t)v561;
            if ((unint64_t)v561 <= v9) {
              goto LABEL_743;
            }
            goto LABEL_433;
          case 2:
            uint64_t v9 = v5[8];
            if (v9 <= v7) {
              goto LABEL_688;
            }
            uint64_t v13 = v5[10];
            v473 = (unsigned __int8 *)(v13 + 88 * v7);
            v246 = *((void *)v473 + 3);
            v524 = (_anonymous_namespace_ *)(v473 + 24);
            if (v246 == 2)
            {
              v286 = v13 + 88 * v7;
              v289 = *(void *)(v286 + 64);
              v288 = (void *)(v286 + 64);
              v287 = v289;
              unint64_t v12 = (unint64_t)&v585.n128_u64[1];
              if (!v289) {
                goto LABEL_396;
              }
              if (v287 == 1) {
                goto LABEL_781;
              }
              v290 = **(float **)(v13 + 88 * v7 + 80) + *(float *)(*(void *)(v13 + 88 * v7 + 80) + 4);
              if (v290 == 1.0 || vabds_f32(1.0, v290) < (float)((float)((float)(fabsf(v290) + 1.0) + 1.0) * 0.00001))
              {
LABEL_396:
                v291 = v13 + 88 * v7;
                v292 = *(unint64_t **)(v291 + 40);
                uint64_t v10 = v291 + 40;
                uint64_t v9 = *(void *)v524;
                if (*(void *)v524 > 1uLL)
                {
                  v294 = v293;
                  if (*v288) {
                    v295 = **(float **)(v13 + 88 * v7 + 80);
                  }
                  else {
                    v295 = 0.5;
                  }
                  *(float *)v604 = v295;
                  v585.n128_u32[0] = 2;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v514, (uint64_t)&v585);
                  v585.n128_u64[0] = *((void *)v533 + 220) - 1;
                  re::DynamicArray<unsigned long>::add(v519, &v585);
                  re::DynamicArray<float>::add(v517, (float *)v604);
                  v370 = *(void *)(*((void *)v533 + 15) + 8 * *((void *)v533 + 13) - 8);
                  v585.n128_u32[0] = 12;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                  uint64_t v13 = *((void *)v533 + 235) - 1;
                  v371 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v13);
                  v371[1] = v294;
                  v371[2] = a4;
                  v371[3] = v370;
                  goto LABEL_422;
                }
LABEL_748:
                *(void *)v630 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = 1;
                v605 = 2048;
                *(void *)v606 = v9;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_749:
                *(void *)v604 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                v575[0].n128_u32[0] = 136315906;
                *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
                v575[0].n128_u16[6] = 1024;
                *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
                v575[1].n128_u16[1] = 2048;
                *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
                v575[1].n128_u16[6] = 2048;
                *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v532;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_750;
              }
            }
            else
            {
              unint64_t v12 = (unint64_t)&v585.n128_u64[1];
              if (v246 == 1)
              {
                if (!*(void *)(v13 + 88 * v7 + 64)
                  || (uint64_t v247 = **(float **)(v13 + 88 * v7 + 80), v247 == 1.0)
                  || vabds_f32(1.0, v247) < (float)((float)((float)(fabsf(v247) + 1.0) + 1.0) * 0.00001))
                {
LABEL_422:
                  unint64_t v11 = (unint64_t)v8;
LABEL_423:
                  uint64_t v9 = v564;
                  uint64_t v10 = v478;
                  if (v564 <= v478) {
                    goto LABEL_691;
                  }
                  v329 = v11;
                  uint64_t v10 = (unint64_t)v533;
                  unint64_t Rotation = re::EvaluationTree::extractRotation(v533, *(void *)(v565 + 8 * v478));
                  unint64_t v12 = v500;
                  unint64_t Scale = re::EvaluationTree::extractScale(v533, v500);
                  v585.n128_u32[0] = 24;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                  uint64_t v8 = (_anonymous_namespace_ *)(*((void *)v533 + 235) - 1);
                  v374 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v329, (unint64_t)v8);
                  *(void *)(v374 + 8) = v13;
                  *(void *)(v374 + 16) = Rotation;
                  v585.n128_u32[0] = 37;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                  unint64_t v11 = *((void *)v533 + 245) - 1;
                  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v11) + 8) = v500;
                  uint64_t v13 = re::EvaluationTree::constructMatrix4x4(v533, Scale, (uint64_t)v8, v11);
                  if ((v473[1] & *v473 & v473[2]) == (v473[1] | *v473 | v473[2]))
                  {
                    a4 = (unint64_t)v533;
LABEL_426:
                    unsigned __int8 v225 = v493;
                    uint64_t v8 = (_anonymous_namespace_ *)v329;
                    goto LABEL_471;
                  }
                  LODWORD(v607) = 0;
                  v585.n128_u32[0] = 1;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                  v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                  re::DynamicArray<unsigned long>::add(v467, &v585);
                  re::DynamicArray<int>::add(v465, &v607);
                  uint64_t v9 = *v461;
                  unint64_t v12 = (unint64_t)v533;
                  v526 = *(_anonymous_namespace_ **)(*((void *)v533 + 10) + 8 * *((void *)v533 + 8) - 8);
                  if (*v461 == -1)
                  {
                    uint64_t v8 = (_anonymous_namespace_ *)v329;
                    v377 = v500;
                  }
                  else
                  {
                    uint64_t v10 = (unint64_t)v561;
                    if ((unint64_t)v561 <= v9) {
                      goto LABEL_744;
                    }
                    v375 = *(void *)(v562 + 8 * v9);
                    v585.n128_u32[0] = 20;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                    v376 = *((void *)v533 + 230) - 1;
                    *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v329, v376)
                              + 8) = v375;
                    v585.n128_u32[0] = 28;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                    v377 = *((void *)v533 + 230) - 1;
                    v378 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v329, v377);
                    *(void *)(v378 + 8) = v376;
                    *(void *)(v378 + 16) = v500;
                    v585.n128_u32[0] = 28;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                    v379 = *((void *)v533 + 230) - 1;
                    v380 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v329, v379);
                    *(void *)(v380 + 8) = v376;
                    *(void *)(v380 + 16) = v13;
                    unint64_t v12 = (unint64_t)v533;
                    uint64_t v13 = v379;
                    uint64_t v8 = (_anonymous_namespace_ *)v329;
                  }
                  v381 = re::EvaluationTree::extractRotation((void *)v12, v377);
                  v585.n128_u32[0] = 14;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  v382 = v377;
                  uint64_t v10 = (unint64_t)v496;
                  re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                  v383 = *(void *)(v12 + 1960) - 1;
                  v384 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v383);
                  unint64_t v12 = (unint64_t)v526;
                  *(void *)(v384 + 8) = v381;
                  *(void *)(v384 + 16) = v526;
                  v385 = re::EvaluationTree::extractRotation(v533, v13);
                  v585.n128_u32[0] = 14;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                  v386 = *((void *)v533 + 245) - 1;
                  v387 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v386);
                  *(void *)(v387 + 8) = v385;
                  *(void *)(v387 + 16) = v526;
                  v388 = v383;
                  a4 = (unint64_t)v533;
                  v585.n128_u32[0] = 13;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                  unint64_t v11 = *((void *)v533 + 235) - 1;
                  v391 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v11);
                  *(void *)(v391 + 8) = v390;
                  *(void *)(v391 + 16) = v526;
                  v392 = re::EvaluationTree::extractScale(v533, v382);
                  v585.n128_u32[0] = 37;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                  v393 = *((void *)v533 + 245) - 1;
                  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v393)+ 8) = v382;
                  uint64_t v13 = re::EvaluationTree::constructMatrix4x4(v533, v392, v11, v393);
                  uint64_t v9 = *v461;
                  if (*v461 == -1) {
                    goto LABEL_470;
                  }
                  uint64_t v10 = (unint64_t)v561;
                  if ((unint64_t)v561 > v9)
                  {
LABEL_433:
                    v394 = *(void *)(v562 + 8 * v9);
                    v585.n128_u32[0] = 28;
                    goto LABEL_443;
                  }
LABEL_745:
                  *(void *)v630 = 0;
                  v589 = 0u;
                  v588 = 0u;
                  v587 = 0u;
                  v586 = 0u;
                  v585 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v604 = 136315906;
                  *(void *)&v604[4] = "operator[]";
                  *(_WORD *)&v604[12] = 1024;
                  *(_DWORD *)&v604[14] = 468;
                  *(_WORD *)&v604[18] = 2048;
                  *(void *)&v604[20] = v9;
                  v605 = 2048;
                  *(void *)v606 = v10;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_746:
                  *(void *)v630 = 0;
                  v589 = 0u;
                  v588 = 0u;
                  v587 = 0u;
                  v586 = 0u;
                  v585 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v604 = 136315906;
                  *(void *)&v604[4] = "operator[]";
                  *(_WORD *)&v604[12] = 1024;
                  *(_DWORD *)&v604[14] = 468;
                  *(_WORD *)&v604[18] = 2048;
                  *(void *)&v604[20] = v10;
                  v605 = 2048;
                  *(void *)v606 = v12;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_747;
                }
              }
            }
            *(void *)&v604[8] = 0x3F80000000000000;
            *(void *)v604 = 0;
            v585.n128_u32[0] = 5;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
            v585.n128_u64[0] = *(void *)(a4 + 1880) - 1;
            re::DynamicArray<unsigned long>::add(v456, &v585);
            re::DynamicArray<re::Vector3<float>>::add(v455, (__n128 *)v604);
            v296 = *(void *)(a4 + 224);
            uint64_t v10 = *(void *)(*(void *)(a4 + 240) + 8 * v296 - 8);
            uint64_t v9 = *(void *)v524;
            if (*(void *)v524)
            {
              unint64_t v12 = 0;
              v297 = (void *)(v13 + 88 * v7);
              v508 = v297 + 5;
              v483 = v297 + 10;
              v490 = (_anonymous_namespace_ *)(v297 + 8);
              uint64_t v8 = *(_anonymous_namespace_ **)(*(void *)(a4 + 240) + 8 * v296 - 8);
              while (1)
              {
                unint64_t v11 = *(void *)v524;
                if (*(void *)v524 <= v12) {
                  break;
                }
                a4 = (unint64_t)v533;
                LODWORD(v607) = 0;
                uint64_t v13 = *(void *)v490;
                v298 = 1.0 / (float)v9;
                if (*(void *)v490)
                {
                  if (v13 <= v12) {
                    goto LABEL_633;
                  }
                  v298 = *(float *)(*v483 + 4 * v12);
                }
                *(float *)&v607 = v298;
                v585.n128_u32[0] = 2;
                uint64_t v7 = (unint64_t)&v585.n128_u64[1];
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v514, (uint64_t)&v585);
                v585.n128_u64[0] = *((void *)v533 + 220) - 1;
                re::DynamicArray<unsigned long>::add(v519, &v585);
                re::DynamicArray<float>::add(v517, (float *)&v607);
                v299 = *(void *)(*((void *)v533 + 15) + 8 * *((void *)v533 + 13) - 8);
                v585.n128_u32[0] = 12;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                a4 = *((void *)v533 + 235) - 1;
                v300 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v528, a4);
                v300[1] = v10;
                v300[2] = v11;
                v300[3] = v299;
                unint64_t v11 = v528;
                uint64_t v5 = v520;
                v585.n128_u32[0] = 24;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                uint64_t v13 = *((void *)v533 + 235) - 1;
                v301 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v528, v13);
                *(void *)(v301 + 8) = v8;
                *(void *)(v301 + 16) = a4;
                ++v12;
                uint64_t v8 = (_anonymous_namespace_ *)v13;
                if (v9 == v12) {
                  goto LABEL_423;
                }
              }
LABEL_614:
              *(void *)v630 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 797;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v12;
              v605 = 2048;
              *(void *)v606 = v11;
              v439 = 38;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_615:
              unint64_t v158 = 1;
              goto LABEL_195;
            }
            uint64_t v13 = *(void *)(*(void *)(a4 + 240) + 8 * v296 - 8);
            goto LABEL_422;
          case 3:
            uint64_t v9 = v5[13];
            if (v9 <= v7) {
              goto LABEL_686;
            }
            unint64_t v11 = v5[15];
            unint64_t v227 = v11 + 80 * v7;
            uint64_t v228 = *(void *)(v227 + 16);
            if (v228 == 1)
            {
              if (!*(void *)(v11 + 80 * v7 + 56)
                || (unint64_t v229 = **(float **)(v11 + 80 * v7 + 72), v229 == 1.0)
                || vabds_f32(1.0, v229) < (float)((float)((float)(fabsf(v229) + 1.0) + 1.0) * 0.00001))
              {
                v230 = *(unint64_t **)(v227 + 32);
                uint64_t v9 = *v230;
                uint64_t v10 = v564;
                if (v564 <= *v230) {
                  goto LABEL_733;
                }
                uint64_t v10 = (unint64_t)v561;
                if ((unint64_t)v561 <= v9) {
                  goto LABEL_734;
                }
                v231 = *(void *)(v565 + 8 * v9);
                uint64_t v232 = *(void *)(v562 + 8 * v9);
                v585.n128_u32[0] = 20;
                unint64_t v12 = (unint64_t)&v585.n128_u64[1];
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                unint64_t v11 = (unint64_t)v497;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                unint64_t v233 = *(void *)(a4 + 1840) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v233)+ 8) = v231;
                uint64_t v13 = 28;
                v585.n128_u32[0] = 28;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                unint64_t v234 = *(void *)(a4 + 1840) - 1;
                unint64_t v235 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v234);
                *(void *)(v235 + 8) = v232;
                *(void *)(v235 + 16) = v233;
                uint64_t v9 = v564;
                uint64_t v10 = v478;
                if (v564 <= v478) {
                  goto LABEL_735;
                }
                unint64_t v236 = *(void *)(v565 + 8 * v478);
                v585.n128_u32[0] = 28;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                v237 = v497;
LABEL_469:
                re::DynamicArray<re::EvaluationRegister>::add(v237, (uint64_t)&v585);
                uint64_t v13 = *(void *)(a4 + 1840) - 1;
                v412 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v13);
                *(void *)(v412 + 8) = v234;
                *(void *)(v412 + 16) = v236;
                goto LABEL_470;
              }
              unint64_t v12 = 80;
            }
            else
            {
              unint64_t v12 = 80;
              if (v228 == 2)
              {
                uint64_t v248 = v11 + 80 * v7;
                unint64_t v250 = *(void *)(v248 + 56);
                uint64_t v9 = v248 + 56;
                unint64_t v249 = v250;
                if (!v250) {
                  goto LABEL_363;
                }
                if (v249 == 1) {
                  goto LABEL_782;
                }
                uint64_t v251 = **(float **)(v11 + 80 * v7 + 72) + *(float *)(*(void *)(v11 + 80 * v7 + 72) + 4);
                if (v251 == 1.0 || vabds_f32(1.0, v251) < (float)((float)((float)(fabsf(v251) + 1.0) + 1.0) * 0.00001))
                {
LABEL_363:
                  uint64_t v10 = *(void *)(v227 + 16);
                  if (v10 <= 1) {
                    goto LABEL_771;
                  }
                  if (*(void *)v9) {
                    long long v252 = **(float **)(v11 + 80 * v7 + 72);
                  }
                  else {
                    long long v252 = 0.5;
                  }
                  *(float *)&v607 = v252;
                  v585.n128_u32[0] = 2;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v514, (uint64_t)&v585);
                  v585.n128_u64[0] = *(void *)(a4 + 1760) - 1;
                  re::DynamicArray<unsigned long>::add(v519, &v585);
                  re::DynamicArray<float>::add(v517, (float *)&v607);
                  v395 = *(void *)(*(void *)(a4 + 120) + 8 * *(void *)(a4 + 104) - 8);
                  memset(v556, 255, sizeof(v556));
                  re::EvaluationTree::lerp((void *)a4, (uint64_t *)v630, (uint64_t *)v604, v395, (unint64_t *)v556);
LABEL_467:
                  v411 = re::EvaluationTree::constructMatrix4x4((void *)a4, *(uint64_t *)v556, *(uint64_t *)&v556[8], *(uint64_t *)&v556[16]);
                  uint64_t v9 = v564;
                  uint64_t v10 = v478;
                  if (v564 > v478)
                  {
                    unint64_t v234 = v411;
                    unint64_t v236 = *(void *)(v565 + 8 * v478);
                    v585.n128_u32[0] = 28;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    v237 = v497;
                    goto LABEL_469;
                  }
LABEL_722:
                  *(void *)v630 = 0;
                  v589 = 0u;
                  v588 = 0u;
                  v587 = 0u;
                  v586 = 0u;
                  v585 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v604 = 136315906;
                  *(void *)&v604[4] = "operator[]";
                  *(_WORD *)&v604[12] = 1024;
                  *(_DWORD *)&v604[14] = 468;
                  *(_WORD *)&v604[18] = 2048;
                  *(void *)&v604[20] = v10;
                  v605 = 2048;
                  *(void *)v606 = v9;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_723;
                }
              }
            }
            memset(v630, 255, 24);
            v585.n128_u64[1] = 1065353216;
            v585.n128_u64[0] = 0x3F8000003F800000;
            v586.i64[1] = 0x3F80000000000000;
            v586.i64[0] = 0;
            v587 = 0uLL;
            re::EvaluationTree::createInputRegister((void *)a4, &v585, v630);
            *(_OWORD *)v556 = *(_OWORD *)v630;
            *(void *)&v556[16] = *(void *)&v630[16];
            uint64_t v10 = *(void *)(v227 + 16);
            if (!v10) {
              goto LABEL_467;
            }
            uint64_t v9 = 0;
            v409 = v11 + 80 * v7;
            unint64_t v11 = v409 + 56;
            unint64_t v12 = v409 + 72;
            while (1)
            {
              uint64_t v13 = *(void *)(v227 + 16);
              if (v13 <= v9) {
                break;
              }
              LODWORD(v552) = 0;
              uint64_t v13 = *(void *)v11;
              v410 = 1.0 / (float)v10;
              if (*(void *)v11)
              {
                if (v13 <= v9) {
                  goto LABEL_639;
                }
                v410 = *(float *)(*(void *)v12 + 4 * v9);
              }
              *(float *)&v552 = v410;
              v585.n128_u32[0] = 2;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v514, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1760) - 1;
              re::DynamicArray<unsigned long>::add(v519, &v585);
              re::DynamicArray<float>::add(v517, (float *)&v552);
              re::EvaluationTree::lerp((void *)a4, (uint64_t *)v630, (uint64_t *)&v607, *(void *)(*(void *)(a4 + 120) + 8 * *(void *)(a4 + 104) - 8), (unint64_t *)v604);
              re::EvaluationTree::additiveBlend((void *)a4, (uint64_t *)v556, (uint64_t *)v604, v585.n128_u64);
              *(__n128 *)v556 = v585;
              *(void *)&v556[16] = v586.i64[0];
              if (v10 == ++v9) {
                goto LABEL_467;
              }
            }
LABEL_620:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_621:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_622:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_623:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_624:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            uint64_t v10 = v173;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v10;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_625:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_626:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_627:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v7;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_628:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_629:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_630:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_631:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_632:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_633:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v12;
            v605 = 2048;
            *(void *)v606 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_634:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_635:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v10;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_636:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = a4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_637:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_638:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = a4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_639:
            v555[0].n128_u64[0] = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_640:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v11;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_641:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_642:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_643:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_644:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_645:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 789;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_646:
            *(void *)v604 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v532;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_647:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            v428 = v173;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v428;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_648:
            v549 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = a4;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_649:
            v549 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = a4;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_650:
            v549 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
            v439 = 38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_651:
            int v154 = 0;
LABEL_652:
            v547 = 0;
            v546 = 0;
            v548 = 0;
            re::FixedArray<re::EvaluationRegisterId<int>>::init<>(&v546, (uint64_t)v572, v154);
            v603 = 0u;
            v602 = 0u;
            v601 = 0u;
            v600 = 0u;
            v597 = 0u;
            v596 = 0u;
            v595 = 0u;
            v594 = 0u;
            v593 = 0u;
            memset(v590, 0, sizeof(v590));
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            v591 = *(void *)&v606[2];
            v592 = *(void *)&v604[16];
            *(void *)&v589 = v551;
            *((void *)&v589 + 1) = v550;
            v598 = v548;
            v599 = v547;
            if (!(void)v535)
            {
LABEL_667:
              if (v546 && v547) {
                (*(void (**)(unint64_t, uint64_t))(*(void *)v546 + 40))(v546, v548);
              }
              if (v549 && v550) {
                (*(void (**)(unint64_t, uint64_t))(*(void *)v549 + 40))(v549, v551);
              }
              if (*(void *)v604 && *(void *)&v606[2]) {
                (*(void (**)(void, void))(**(void **)v604 + 40))(*(void *)v604, *(void *)&v606[2]);
              }
              unint64_t v158 = 1;
              goto LABEL_196;
            }
            v429 = (unint64_t *)v536;
            v430 = *(void *)&v556[16];
            v431 = v568;
            v432 = v548;
            v433 = 8 * v535;
            v434 = v559;
            while (1)
            {
              uint64_t v9 = *v429;
              uint64_t v10 = *(void *)&v556[8];
              if (*(void *)&v556[8] <= *v429) {
                goto LABEL_801;
              }
              if (v12 <= v9) {
                goto LABEL_802;
              }
              uint64_t v10 = *(void *)(v430 + 8 * v9);
              v435 = *(unsigned __int8 *)(v13 + v9);
              if (v435 == 2) {
                break;
              }
              if (v435 == 1)
              {
                unint64_t v11 = v567;
                if (v567 <= v9) {
                  goto LABEL_805;
                }
                unint64_t v11 = v547;
                if (v547 <= v10) {
                  goto LABEL_807;
                }
                uint64_t v9 = *(void *)(v431 + 8 * v9) - 0x7FFFFFFFFFFFFFFFLL;
                unint64_t v11 = *(void *)(a4 + 824);
                if (v11 <= v9) {
                  goto LABEL_809;
                }
LABEL_665:
                *(void *)(*(void *)(a4 + 840) + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = *(void *)(v432 + 8 * v10);
              }
              ++v429;
              v433 -= 8;
              if (!v433) {
                goto LABEL_667;
              }
            }
            unint64_t v11 = v558;
            if (v558 <= v9) {
              goto LABEL_806;
            }
            unint64_t v11 = v547;
            if (v547 <= v10) {
              goto LABEL_808;
            }
            uint64_t v9 = *(void *)(v434 + 8 * v9) - 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v11 = *(void *)(a4 + 824);
            if (v11 <= v9) {
              goto LABEL_810;
            }
            goto LABEL_665;
          case 4:
            uint64_t v9 = v5[18];
            if (v9 <= v7) {
              goto LABEL_687;
            }
            v472 = *(void *)(v163 + 8);
            unint64_t v12 = (unint64_t)v8;
            uint64_t v5 = (void *)v5[20];
            v585.n128_u32[0] = 37;
            uint64_t v8 = (_anonymous_namespace_ *)&v585.n128_i8[8];
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            uint64_t v7 = (unint64_t)v496;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            unint64_t v11 = *(void *)(a4 + 1960) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v11) + 8) = v500;
            uint64_t v9 = v564;
            v238 = v478;
            if (v564 <= v478) {
              goto LABEL_689;
            }
            uint64_t v239 = *(void *)(v565 + 8 * v478);
            v585.n128_u32[0] = 37;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            unint64_t v240 = (void *)a4;
            unint64_t v241 = *(void *)(a4 + 1960) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v241) + 8) = v239;
            v482 = v241;
            v489 = (_anonymous_namespace_ *)v11;
            *(void *)v630 = v11;
            *(void *)&v630[8] = &v5[18 * v472];
            v607 = v241;
            v507 = *(unsigned __int8 **)&v630[8];
            v608 = *(void *)&v630[8];
            v523 = (_anonymous_namespace_ *)v5;
            unint64_t v242 = *(void *)&v630[8];
            if (*(void *)(v242 + 64) < 2uLL)
            {
              unint64_t v11 = (unint64_t)v462;
              unint64_t v12 = a4;
            }
            else
            {
              v585.n128_u32[0] = 29;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              unint64_t v244 = v240[245] - 1;
              *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v244) + 8) = a4;
              v585.n128_u32[0] = 29;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v245 = v240[245] - 1;
              *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v245) + 8) = v5;
              uint64_t v5 = (void *)v245;
              unint64_t v12 = v244;
              unint64_t v11 = (unint64_t)v462;
            }
            long long v265 = *((unsigned __int8 *)v523 + 144 * v472 + 4);
            if (v265 == 2)
            {
              *(_OWORD *)v604 = 0x3F80000000000000uLL;
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              uint64_t v7 = (unint64_t)v496;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              a4 = (unint64_t)v533;
              v585.n128_u64[0] = *((void *)v533 + 245) - 1;
              re::DynamicArray<unsigned long>::add((void *)v11, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v460, (__n128 *)v604);
              unint64_t v11 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
              long long v274 = v11;
              uint64_t v13 = v528;
            }
            else
            {
              v458 = v12;
              if (v265 == 1)
              {
                v302 = (char *)v523 + 144 * v472;
                v304 = *((void *)v302 + 16);
                v303 = (unint64_t *)(v302 + 128);
                uint64_t v9 = v304;
                uint64_t v10 = (unint64_t)v561;
                if ((unint64_t)v561 <= v304) {
                  goto LABEL_739;
                }
                v305 = *(void *)(v562 + 8 * v9);
                *(_OWORD *)v604 = 0x3F80000000000000uLL;
                v585.n128_u32[0] = 7;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                uint64_t v7 = (unint64_t)v496;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v12 = (unint64_t)v533;
                v585.n128_u64[0] = *((void *)v533 + 245) - 1;
                re::DynamicArray<unsigned long>::add((void *)v11, &v585);
                re::DynamicArray<re::Vector3<float>>::add(v460, (__n128 *)v604);
                uint64_t v10 = *(void *)(*(void *)(v12 + 320) + 8 * *(void *)(v12 + 304) - 8);
                v585.n128_u32[0] = 42;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v11 = *((void *)v533 + 245) - 1;
                uint64_t v13 = v528;
                v306 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v11);
                *(void *)(v306 + 8) = v305;
                *(void *)(v306 + 16) = v10;
                uint64_t v9 = *v303;
                a4 = v564;
                if (v564 <= *v303) {
                  goto LABEL_741;
                }
                v307 = *(void *)(v565 + 8 * v9);
                v585.n128_u32[0] = 42;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                long long v274 = *((void *)v533 + 245) - 1;
                v308 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v274);
                *(void *)(v308 + 8) = v307;
                *(void *)(v308 + 16) = v10;
                a4 = (unint64_t)v533;
              }
              else
              {
                if (*((unsigned char *)v523 + 144 * v472 + 4)) {
                  goto LABEL_830;
                }
                long long v266 = (char *)v523 + 144 * v472;
                long long v268 = *((void *)v266 + 16);
                long long v267 = (unint64_t *)(v266 + 128);
                uint64_t v9 = v268;
                uint64_t v10 = (unint64_t)v561;
                uint64_t v7 = (unint64_t)v496;
                unint64_t v11 = 31;
                if ((unint64_t)v561 <= v268) {
                  goto LABEL_738;
                }
                long long v269 = *(void *)(v562 + 8 * v9);
                a4 = 37;
                v585.n128_u32[0] = 37;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v12 = (unint64_t)v533;
                long long v270 = *((void *)v533 + 245) - 1;
                uint64_t v13 = v528;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v270) + 8) = v269;
                v585.n128_u32[0] = 31;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v11 = *((void *)v533 + 245) - 1;
                long long v271 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v11);
                *(void *)(v271 + 8) = v270;
                *(void *)(v271 + 16) = v489;
                uint64_t v9 = *v267;
                uint64_t v10 = v564;
                if (v564 <= *v267) {
                  goto LABEL_740;
                }
                long long v272 = *(void *)(v565 + 8 * v9);
                v585.n128_u32[0] = 37;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                long long v273 = *((void *)v533 + 245) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v273) + 8) = v272;
                v585.n128_u32[0] = 31;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                long long v274 = *((void *)v533 + 245) - 1;
                long long v275 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v528, v274);
                *(void *)(v275 + 8) = v273;
                *(void *)(v275 + 16) = v482;
                a4 = (unint64_t)v533;
              }
              unint64_t v12 = v458;
            }
            v585.n128_u32[0] = 15;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v309 = *(void *)(a4 + 1960) - 1;
            v310 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v309);
            *(void *)(v310 + 8) = v12;
            *(void *)(v310 + 16) = v11;
            v585.n128_u32[0] = 29;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v311 = *(void *)(a4 + 1960) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v311) + 8) = v309;
            v585.n128_u32[0] = 15;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v312 = *(void *)(a4 + 1960) - 1;
            v313 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v312);
            *(void *)(v313 + 8) = v311;
            *(void *)(v313 + 16) = v12;
            v585.n128_u32[0] = 38;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v484 = *(void *)(a4 + 1800) - 1;
            v314 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v484);
            v314[1] = v12;
            v314[2] = v312;
            v314[3] = v311;
            v585.n128_u32[0] = 15;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v315 = *(void *)(a4 + 1960) - 1;
            v316 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v315);
            *(void *)(v316 + 8) = v5;
            *(void *)(v316 + 16) = v274;
            v585.n128_u32[0] = 29;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v317 = *(void *)(a4 + 1960) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v317) + 8) = v315;
            v585.n128_u32[0] = 15;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v318 = *(void *)(a4 + 1960) - 1;
            v319 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v318);
            *(void *)(v319 + 8) = v317;
            *(void *)(v319 + 16) = v5;
            v585.n128_u32[0] = 38;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v459 = *(void *)(a4 + 1800) - 1;
            v320 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v459);
            v320[1] = v5;
            v320[2] = v318;
            v320[3] = v317;
            v321 = (__n128 *)((char *)v523 + 144 * v472);
            v585.n128_u32[0] = 7;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
            re::DynamicArray<unsigned long>::add(v462, &v585);
            unint64_t v12 = (unint64_t)v460;
            re::DynamicArray<re::Vector3<float>>::add(v460, v321 + 1);
            v322 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
            v585.n128_u32[0] = 7;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
            re::DynamicArray<unsigned long>::add(v462, &v585);
            re::DynamicArray<re::Vector3<float>>::add(v460, v321 + 2);
            v323 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
            v585.n128_u32[0] = 15;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)v7, (uint64_t)&v585);
            v324 = *(void *)(a4 + 1960) - 1;
            v325 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v13, v324);
            *(void *)(v325 + 8) = v322;
            *(void *)(v325 + 16) = v323;
            v585.n128_u32[0] = 38;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v326 = *(void *)(a4 + 1800) - 1;
            v327 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v326);
            v327[1] = v322;
            v327[2] = v323;
            uint64_t v5 = v469;
            v327[3] = v324;
            v585.n128_u32[0] = 33;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            unint64_t v11 = *(void *)(a4 + 1800) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v11) + 8) = v326;
            uint64_t v9 = v564;
            v328 = v478;
            if (v564 <= v478) {
              goto LABEL_690;
            }
            v329 = v13;
            v330 = *(void *)(v565 + 8 * v478);
            v585.n128_u32[0] = 34;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v331 = *(void *)(a4 + 1800) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v331) + 8) = v330;
            v585.n128_u32[0] = 27;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v332 = *(void *)(a4 + 1800) - 1;
            v333 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v13, v332);
            *(void *)(v333 + 8) = v459;
            *(void *)(v333 + 16) = v11;
            v585.n128_u32[0] = 27;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v334 = *(void *)(a4 + 1800) - 1;
            v335 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v334);
            *(void *)(v335 + 8) = v484;
            *(void *)(v335 + 16) = v11;
            v585.n128_u32[0] = 19;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v336 = *(void *)(a4 + 1800) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v336) + 8) = v332;
            v585.n128_u32[0] = 27;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v337 = *(void *)(a4 + 1800) - 1;
            v338 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v337);
            *(void *)(v338 + 8) = v334;
            *(void *)(v338 + 16) = v336;
            v585.n128_u32[0] = 27;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
            v339 = *(void *)(a4 + 1800) - 1;
            v340 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v339);
            *(void *)(v340 + 8) = v337;
            *(void *)(v340 + 16) = v331;
            v341 = re::EvaluationTree::extractScale((void *)a4, v500);
            if ((v507[1] & *v507 & v507[2]) == (v507[1] | *v507 | v507[2]))
            {
              *(_OWORD *)v604 = xmmword_23435FD50;
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              unint64_t v12 = (unint64_t)v496;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
              v525 = (_anonymous_namespace_ *)v339;
              re::DynamicArray<unsigned long>::add(v462, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v460, (__n128 *)v604);
              v342 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
              v585.n128_u32[0] = 25;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v509 = *(void *)(a4 + 1960) - 1;
              v343 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v509);
              *(void *)(v343 + 8) = v342;
              *(void *)(v343 + 16) = v341;
              *(_OWORD *)v556 = xmmword_23435FD60;
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
              re::DynamicArray<unsigned long>::add(v462, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v460, (__n128 *)v556);
              v344 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
              v585.n128_u32[0] = 25;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v345 = *(void *)(a4 + 1960) - 1;
              v346 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v345);
              *(void *)(v346 + 8) = v344;
              *(void *)(v346 + 16) = v341;
              v555[0] = (__n128)xmmword_23435FD80;
              v585.n128_u32[0] = 7;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1960) - 1;
              re::DynamicArray<unsigned long>::add(v462, &v585);
              re::DynamicArray<re::Vector3<float>>::add(v460, v555);
              uint64_t v10 = *(void *)(*(void *)(a4 + 320) + 8 * *(void *)(a4 + 304) - 8);
              v585.n128_u32[0] = 25;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              unint64_t v11 = *(void *)(a4 + 1960) - 1;
              v347 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v11);
              *(void *)(v347 + 8) = v10;
              *(void *)(v347 + 16) = v341;
              v585.n128_u32[0] = 38;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
              v348 = *(void *)(a4 + 1800) - 1;
              v349 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v348);
              v349[1] = v509;
              v349[2] = v345;
              v349[3] = v11;
              v585.n128_u32[0] = 27;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
              v350 = *(void *)(a4 + 1800) - 1;
              v351 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v350);
              *(void *)(v351 + 8) = v525;
              *(void *)(v351 + 16) = v348;
            }
            else
            {
              *(_DWORD *)v604 = 0;
              v585.n128_u32[0] = 1;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
              v585.n128_u64[0] = *(void *)(a4 + 1720) - 1;
              re::DynamicArray<unsigned long>::add(v467, &v585);
              re::DynamicArray<int>::add(v465, v604);
              uint64_t v10 = *(void *)(*(void *)(a4 + 80) + 8 * *(void *)(a4 + 64) - 8);
              v352 = re::EvaluationTree::extractRotation((void *)a4, v500);
              v585.n128_u32[0] = 35;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
              v353 = *(void *)(a4 + 1880) - 1;
              *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v329, v353) + 8) = v339;
              v585.n128_u32[0] = 14;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              unint64_t v12 = (unint64_t)v496;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              unint64_t v11 = *(void *)(a4 + 1960) - 1;
              v354 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v11);
              *(void *)(v354 + 8) = v352;
              *(void *)(v354 + 16) = v10;
              v585.n128_u32[0] = 14;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
              v355 = *(void *)(a4 + 1960) - 1;
              v356 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v329, v355);
              *(void *)(v356 + 8) = v353;
              *(void *)(v356 + 16) = v10;
              v585.n128_u32[0] = 13;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
              v359 = *(void *)(a4 + 1880) - 1;
              v360 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v329, v359);
              *(void *)(v360 + 8) = v358;
              *(void *)(v360 + 16) = v10;
              v585.n128_u32[0] = 39;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
              v350 = *(void *)(a4 + 1800) - 1;
              v361 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v329, v350);
              *(void *)(v361 + 8) = v341;
              *(void *)(v361 + 16) = v359;
            }
            uint64_t v5 = v520;
            v585.n128_u32[0] = 40;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
            uint64_t v13 = *(void *)(a4 + 1840) - 1;
            v362 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v329, v13);
            *(void *)(v362 + 8) = v350;
            *(void *)(v362 + 16) = v489;
            goto LABEL_426;
          case 5:
            uint64_t v9 = v5[91];
            if (v9 <= v7) {
              goto LABEL_685;
            }
            int32x4_t v169 = v5[93];
            memset(v630, 0, 24);
            float32x4_t v170 = *(unsigned int *)(v169 + 24 * v7);
            unint64_t v12 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v170 + 9);
            v457 = v169;
            if (!*((unsigned char *)&re::kEvaluationCommandDescriptions + 16 * v170 + 9)) {
              goto LABEL_331;
            }
            v452 = (unsigned int *)(v169 + 24 * v7);
            uint64_t v13 = 0;
            v471 = v7;
            uint64_t v7 = (unint64_t)v630;
            a4 = 56;
            v481 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v170 + 9);
            break;
          default:
            goto LABEL_826;
        }
        do
        {
          uint64_t v9 = v13 + *((void *)v452 + 1);
          uint64_t v10 = v5[86];
          if (v10 <= v9)
          {
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_599:
            *(void *)&v534 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            v575[0].n128_u32[0] = 136315906;
            *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
            v575[0].n128_u16[6] = 1024;
            *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
            v575[1].n128_u16[1] = 2048;
            *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v9;
            v575[1].n128_u16[6] = 2048;
            *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_600;
          }
          float32x4_t v171 = v5[88];
          __n128 v172 = *(unsigned __int8 *)(v171 + 16 * v9);
          if (v172 != 3)
          {
            if (v172 == 2)
            {
              uint64_t v9 = *(void *)(v171 + 16 * v9 + 8);
              uint64_t v10 = v5[68];
              if (v10 > v9)
              {
                v179 = v5[70];
                unint64_t v180 = *(unsigned __int8 *)(v179 + 16 * v9);
                switch(*(unsigned char *)(v179 + 16 * v9))
                {
                  case 0:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = v575[0].n128_u64[1];
                    if (v575[0].n128_u64[1] <= v9) {
                      goto LABEL_693;
                    }
                    uint64_t v181 = *(void *)(v575[1].n128_u64[0] + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_243;
                    }
                    uint64_t v10 = v5[28];
                    if (v10 <= v9) {
                      goto LABEL_752;
                    }
                    v182 = v5[30];
                    v585.n128_u32[0] = 0;
                    uint64_t v183 = (_DWORD *)(v182 + 4 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v8, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 210) - 1;
                    re::DynamicArray<unsigned long>::add(v448, &v585);
                    re::DynamicArray<int>::add(v447, v183);
                    uint64_t v10 = v575[0].n128_u64[1];
                    if (v575[0].n128_u64[1] <= v9) {
                      goto LABEL_767;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 5) + 8 * *((void *)v533 + 3) - 8);
                    *(void *)(v575[1].n128_u64[0] + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = v575[0].n128_u64[1];
LABEL_243:
                    if (v10 <= v9) {
                      goto LABEL_709;
                    }
                    goto LABEL_328;
                  case 1:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = v575[2].n128_u64[0];
                    if (v575[2].n128_u64[0] <= v9) {
                      goto LABEL_700;
                    }
                    uint64_t v181 = *(void *)(v575[2].n128_u64[1] + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_301;
                    }
                    uint64_t v10 = v5[33];
                    if (v10 <= v9) {
                      goto LABEL_757;
                    }
                    v214 = v5[35];
                    v585.n128_u32[0] = 1;
                    v215 = (_DWORD *)(v214 + 4 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                    re::DynamicArray<unsigned long>::add(v467, &v585);
                    re::DynamicArray<int>::add(v465, v215);
                    uint64_t v10 = v575[2].n128_u64[0];
                    if (v575[2].n128_u64[0] <= v9) {
                      goto LABEL_764;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 10) + 8 * *((void *)v533 + 8) - 8);
                    *(void *)(v575[2].n128_u64[1] + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = v575[2].n128_u64[0];
LABEL_301:
                    if (v10 <= v9) {
                      goto LABEL_714;
                    }
                    goto LABEL_328;
                  case 2:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = *((void *)&v576 + 1);
                    if (*((void *)&v576 + 1) <= v9) {
                      goto LABEL_695;
                    }
                    uint64_t v181 = *(void *)(v577 + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_269;
                    }
                    uint64_t v10 = v5[38];
                    if (v10 <= v9) {
                      goto LABEL_753;
                    }
                    uint64_t v206 = v5[40];
                    v585.n128_u32[0] = 2;
                    uint64_t v207 = (float *)(v206 + 4 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v514, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 220) - 1;
                    re::DynamicArray<unsigned long>::add(v519, &v585);
                    re::DynamicArray<float>::add(v517, v207);
                    uint64_t v10 = *((void *)&v576 + 1);
                    if (*((void *)&v576 + 1) <= v9) {
                      goto LABEL_760;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 15) + 8 * *((void *)v533 + 13) - 8);
                    *(void *)(v577 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = *((void *)&v576 + 1);
LABEL_269:
                    if (v10 <= v9) {
                      goto LABEL_710;
                    }
                    goto LABEL_328;
                  case 3:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = v578;
                    if ((unint64_t)v578 <= v9) {
                      goto LABEL_696;
                    }
                    uint64_t v181 = *(void *)(*((void *)&v578 + 1) + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_276;
                    }
                    uint64_t v10 = v5[43];
                    if (v10 <= v9) {
                      goto LABEL_754;
                    }
                    v208 = v5[45];
                    v585.n128_u32[0] = 3;
                    uint64_t v209 = v208 + 48 * v9;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 225) - 1;
                    re::DynamicArray<unsigned long>::add(v441, &v585);
                    re::DynamicArray<re::Matrix3x3<float>>::add(v440, v209);
                    uint64_t v10 = v578;
                    if ((unint64_t)v578 <= v9) {
                      goto LABEL_761;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 20) + 8 * *((void *)v533 + 18) - 8);
                    *(void *)(*((void *)&v578 + 1) + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = v578;
LABEL_276:
                    if (v10 <= v9) {
                      goto LABEL_711;
                    }
                    goto LABEL_328;
                  case 4:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = *((void *)&v579 + 1);
                    if (*((void *)&v579 + 1) <= v9) {
                      goto LABEL_697;
                    }
                    uint64_t v181 = *(void *)(v580 + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_283;
                    }
                    uint64_t v10 = v5[48];
                    if (v10 <= v9) {
                      goto LABEL_755;
                    }
                    v210 = v5[50];
                    v585.n128_u32[0] = 4;
                    uint64_t v211 = v210 + (v9 << 6);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 230) - 1;
                    re::DynamicArray<unsigned long>::add(v443, &v585);
                    re::DynamicArray<re::Matrix4x4<float>>::add(v442, v211);
                    uint64_t v10 = *((void *)&v579 + 1);
                    if (*((void *)&v579 + 1) <= v9) {
                      goto LABEL_762;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 25) + 8 * *((void *)v533 + 23) - 8);
                    *(void *)(v580 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = *((void *)&v579 + 1);
LABEL_283:
                    if (v10 <= v9) {
                      goto LABEL_712;
                    }
                    goto LABEL_328;
                  case 5:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = v581;
                    if ((unint64_t)v581 <= v9) {
                      goto LABEL_701;
                    }
                    uint64_t v181 = *(void *)(*((void *)&v581 + 1) + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_308;
                    }
                    uint64_t v10 = v5[53];
                    if (v10 <= v9) {
                      goto LABEL_758;
                    }
                    uint64_t v216 = v5[55];
                    v585.n128_u32[0] = 5;
                    uint64_t v217 = (__n128 *)(v216 + 16 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 235) - 1;
                    re::DynamicArray<unsigned long>::add(v456, &v585);
                    re::DynamicArray<re::Vector3<float>>::add(v455, v217);
                    uint64_t v10 = v581;
                    if ((unint64_t)v581 <= v9) {
                      goto LABEL_765;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 30) + 8 * *((void *)v533 + 28) - 8);
                    *(void *)(*((void *)&v581 + 1) + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = v581;
LABEL_308:
                    if (v10 <= v9) {
                      goto LABEL_715;
                    }
                    goto LABEL_328;
                  case 6:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = *((void *)&v582 + 1);
                    if (*((void *)&v582 + 1) <= v9) {
                      goto LABEL_707;
                    }
                    uint64_t v181 = *(void *)(v583 + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_315;
                    }
                    uint64_t v10 = v5[58];
                    if (v10 <= v9) {
                      goto LABEL_759;
                    }
                    uint64_t v218 = v5[60];
                    v585.n128_u32[0] = 6;
                    uint64_t v219 = (void *)(v218 + 8 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v444, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 240) - 1;
                    re::DynamicArray<unsigned long>::add(v446, &v585);
                    re::DynamicArray<unsigned long>::add(v445, v219);
                    uint64_t v10 = *((void *)&v582 + 1);
                    if (*((void *)&v582 + 1) <= v9) {
                      goto LABEL_766;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 35) + 8 * *((void *)v533 + 33) - 8);
                    *(void *)(v583 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = *((void *)&v582 + 1);
LABEL_315:
                    if (v10 <= v9) {
                      goto LABEL_716;
                    }
                    goto LABEL_328;
                  case 7:
                    uint64_t v9 = *(void *)(v179 + 16 * v9 + 8);
                    uint64_t v10 = v584;
                    if ((unint64_t)v584 <= v9) {
                      goto LABEL_706;
                    }
                    uint64_t v181 = *(void *)(*((void *)&v584 + 1) + 8 * v9);
                    if (v181 != -1) {
                      goto LABEL_290;
                    }
                    uint64_t v10 = v5[63];
                    if (v10 <= v9) {
                      goto LABEL_756;
                    }
                    v212 = v5[65];
                    v585.n128_u32[0] = 7;
                    uint64_t v213 = (__n128 *)(v212 + 16 * v9);
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                    unint64_t v11 = (unint64_t)v533;
                    v585.n128_u64[0] = *((void *)v533 + 245) - 1;
                    re::DynamicArray<unsigned long>::add(v462, &v585);
                    re::DynamicArray<re::Vector3<float>>::add(v460, v213);
                    uint64_t v10 = v584;
                    if ((unint64_t)v584 <= v9) {
                      goto LABEL_763;
                    }
                    uint64_t v181 = *(void *)(*((void *)v533 + 40) + 8 * *((void *)v533 + 38) - 8);
                    *(void *)(*((void *)&v584 + 1) + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v181;
                    uint64_t v10 = v584;
LABEL_290:
                    if (v10 <= v9) {
                      goto LABEL_713;
                    }
                    goto LABEL_328;
                  default:
                    goto LABEL_827;
                }
              }
              goto LABEL_622;
            }
            if (v172 != 1) {
              goto LABEL_811;
            }
            uint64_t v9 = *(void *)(v171 + 16 * v9 + 8);
            uint64_t v10 = v5[23];
            if (v10 <= v9) {
              goto LABEL_621;
            }
            v506 = v13;
            unint64_t v12 = v5[25] + 16 * v9;
            uint64_t v10 = v12 + 8;
            float32x4_t v173 = *(void *)(v12 + 8);
            uint64_t v9 = v5[131];
            if (v9 <= v173) {
              goto LABEL_624;
            }
            uint64_t v13 = v5[133];
            unint64_t v11 = *(void *)(v13 + 56 * v173 + 32);
            uint64_t v9 = (unint64_t)v561;
            if (v11 == -1)
            {
              if ((unint64_t)v561 <= v173) {
                goto LABEL_647;
              }
              uint64_t v9 = *(void *)(v562 + 8 * v173);
            }
            else
            {
              if ((unint64_t)v561 <= v11) {
                goto LABEL_640;
              }
              v487 = *(_anonymous_namespace_ **)(v12 + 8);
              float32x4_t v174 = v5;
              unint64_t v175 = *(void *)(v562 + 8 * v11);
              v585.n128_u32[0] = 20;
              a4 = (unint64_t)&v585.n128_u64[1];
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              uint64_t v176 = (uint64_t)v8;
              uint64_t v5 = v497;
              re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
              uint64_t v8 = v533;
              unint64_t v11 = *((void *)v533 + 230) - 1;
              *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v176, v11) + 8) = v175;
              uint64_t v9 = *(void *)v10;
              uint64_t v10 = (unint64_t)v561;
              if ((unint64_t)v561 <= v9) {
                goto LABEL_641;
              }
              v177 = *(void *)(v562 + 8 * v9);
              v585.n128_u32[0] = 28;
              v586 = 0uLL;
              v585.n128_u64[1] = 0;
              re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
              uint64_t v9 = *((void *)v533 + 230) - 1;
              unint64_t v178 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v176, v9);
              *(void *)(v178 + 8) = v11;
              *(void *)(v178 + 16) = v177;
              uint64_t v8 = (_anonymous_namespace_ *)v176;
              uint64_t v5 = v174;
              uint64_t v7 = (unint64_t)v630;
              a4 = 56;
              float32x4_t v173 = (unint64_t)v487;
            }
            BOOL v187 = *(unsigned __int8 *)v12;
            if (v187 != 3)
            {
              if (v187 == 2)
              {
                uint64_t v13 = v506;
                *(void *)&v630[8 * v506] = re::EvaluationTree::extractScale(v533, v9);
              }
              else
              {
                if (v187 != 1) {
                  goto LABEL_824;
                }
                uint64_t v188 = *(unsigned __int8 *)(v13 + 56 * v173 + 16);
                if (v188 != 2)
                {
                  if (v188 != 1) {
                    goto LABEL_825;
                  }
                  uint64_t v10 = *(void *)(v13 + 56 * v173 + 24);
                  unint64_t v11 = v5[111];
                  if (v11 <= v10) {
                    goto LABEL_682;
                  }
                  uint64_t v189 = v5[113];
                  *(_DWORD *)v604 = 0;
                  *(_DWORD *)v604 = *(unsigned __int8 *)(v189 + (v10 << 6) + 48);
                  unint64_t v11 = (unint64_t)v533;
                  unint64_t v190 = re::EvaluationTree::extractRotation(v533, v9);
                  v585.n128_u32[0] = 1;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                  v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                  re::DynamicArray<unsigned long>::add(v467, &v585);
                  re::DynamicArray<int>::add(v465, v604);
                  uint64_t v191 = *(void *)(*(void *)(v11 + 80) + 8 * *(void *)(v11 + 64) - 8);
                  v585.n128_u32[0] = 14;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                  uint64_t v9 = *((void *)v533 + 245) - 1;
                  v192 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v9);
                  *(void *)(v192 + 8) = v190;
                  *(void *)(v192 + 16) = v191;
                  uint64_t v13 = v506;
                  *(void *)&v630[8 * v506] = v9;
                  goto LABEL_263;
                }
                uint64_t v10 = *(void *)(v13 + 56 * v173 + 24);
                unint64_t v11 = v5[116];
                if (v11 <= v10) {
                  goto LABEL_683;
                }
                unint64_t v194 = v5[118];
                *(_DWORD *)v604 = 0;
                uint64_t v195 = (__n128 *)(v194 + 96 * v10);
                *(_DWORD *)v604 = v195[5].n128_u8[0];
                v196 = v533;
                v488 = (_anonymous_namespace_ *)re::EvaluationTree::extractRotation(v533, v9);
                v585.n128_u32[0] = 5;
                unint64_t v11 = (unint64_t)v8;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                v585.n128_u64[0] = *((void *)v533 + 235) - 1;
                re::DynamicArray<unsigned long>::add(v456, &v585);
                re::DynamicArray<re::Vector3<float>>::add(v455, v195 + 1);
                v197 = *(void *)(*((void *)v196 + 30) + 8 * *((void *)v196 + 28) - 8);
                v585.n128_u32[0] = 18;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                uint64_t v198 = *((void *)v533 + 235) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v198)+ 8) = v197;
                v585.n128_u32[0] = 5;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                v585.n128_u64[0] = *((void *)v533 + 235) - 1;
                re::DynamicArray<unsigned long>::add(v456, &v585);
                re::DynamicArray<re::Vector3<float>>::add(v455, v195 + 3);
                uint64_t v199 = *(void *)(*((void *)v196 + 30) + 8 * *((void *)v196 + 28) - 8);
                v585.n128_u32[0] = 18;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                v200 = *((void *)v533 + 235) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v200)+ 8) = v199;
                v585.n128_u32[0] = 24;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                uint64_t v201 = *((void *)v533 + 235) - 1;
                uint64_t v202 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v201);
                *(void *)(v202 + 8) = v198;
                *(void *)(v202 + 16) = v488;
                v585.n128_u32[0] = 24;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                a4 = 56;
                uint64_t v7 = (unint64_t)v630;
                re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                uint64_t v9 = *((void *)v533 + 235) - 1;
                uint64_t v203 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v9);
                *(void *)(v203 + 8) = v201;
                *(void *)(v203 + 16) = v200;
                v585.n128_u32[0] = 1;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                re::DynamicArray<unsigned long>::add(v467, &v585);
                re::DynamicArray<int>::add(v465, v604);
                v204 = *(void *)(*((void *)v196 + 10) + 8 * *((void *)v196 + 8) - 8);
                v585.n128_u32[0] = 14;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                unint64_t v193 = *((void *)v533 + 245) - 1;
                uint64_t v205 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v193);
                *(void *)(v205 + 8) = v9;
                *(void *)(v205 + 16) = v204;
LABEL_262:
                uint64_t v13 = v506;
                *(void *)&v630[8 * v506] = v193;
              }
LABEL_263:
              unint64_t v12 = v481;
              goto LABEL_329;
            }
            v585.n128_u32[0] = 37;
            v586 = 0uLL;
            v585.n128_u64[1] = 0;
            re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
            unint64_t v193 = *((void *)v533 + 245) - 1;
            *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v193) + 8) = v9;
            goto LABEL_262;
          }
          uint64_t v9 = *(void *)(v171 + 16 * v9 + 8);
          uint64_t v10 = v5[81];
          if (v10 <= v9) {
            goto LABEL_623;
          }
          unint64_t v184 = v5[83];
          unint64_t v185 = *(unsigned __int8 *)(v184 + 16 * v9);
          switch(*(unsigned char *)(v184 + 16 * v9))
          {
            case 0:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = *((void *)&v534 + 1);
              if (*((void *)&v534 + 1) <= v9) {
                goto LABEL_694;
              }
              unint64_t v186 = v535;
              break;
            case 1:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = v536;
              if ((unint64_t)v536 <= v9) {
                goto LABEL_708;
              }
              unint64_t v186 = *((void *)&v536 + 1);
              break;
            case 2:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = *((void *)&v537 + 1);
              if (*((void *)&v537 + 1) <= v9) {
                goto LABEL_698;
              }
              unint64_t v186 = v538;
              break;
            case 3:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = v539;
              if ((unint64_t)v539 <= v9) {
                goto LABEL_702;
              }
              unint64_t v186 = *((void *)&v539 + 1);
              break;
            case 4:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = *((void *)&v540 + 1);
              if (*((void *)&v540 + 1) <= v9) {
                goto LABEL_699;
              }
              unint64_t v186 = v541;
              break;
            case 5:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = v542;
              if ((unint64_t)v542 <= v9) {
                goto LABEL_703;
              }
              unint64_t v186 = *((void *)&v542 + 1);
              break;
            case 6:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = *((void *)&v543 + 1);
              if (*((void *)&v543 + 1) <= v9) {
                goto LABEL_704;
              }
              unint64_t v186 = v544;
              break;
            case 7:
              uint64_t v9 = *(void *)(v184 + 16 * v9 + 8);
              uint64_t v10 = v545;
              if ((unint64_t)v545 <= v9) {
                goto LABEL_705;
              }
              unint64_t v186 = *((void *)&v545 + 1);
              break;
            default:
              goto LABEL_828;
          }
          uint64_t v181 = *(void *)(v186 + 8 * v9);
LABEL_328:
          *(void *)&v630[8 * v13] = v181;
LABEL_329:
          ++v13;
        }
        while (v12 != v13);
        float32x4_t v170 = *v452;
        a4 = (unint64_t)v533;
        uint64_t v7 = v471;
LABEL_331:
        appended = re::EvaluationTree::appendEvaluationCommand((void *)a4, v170, (uint64_t *)v630, v12);
        uint64_t v10 = *(void *)(v457 + 24 * v7 + 16);
        unint64_t v11 = v5[86];
        if (v11 <= v10) {
          goto LABEL_692;
        }
        uint64_t v9 = appended;
        v221 = v5[88];
        uint64_t v222 = *(unsigned __int8 *)(v221 + 16 * v10);
        if (v222 == 1)
        {
          uint64_t v10 = *(void *)(v221 + 16 * v10 + 8);
          unint64_t v11 = v5[23];
          if (v11 > v10)
          {
            a4 = v5[25] + 16 * v10;
            uint64_t v13 = *(void *)(a4 + 8);
            uint64_t v10 = v5[131];
            if (v10 > v13)
            {
              uint64_t v10 = v5[133];
              v276 = v10 + 56 * v13;
              uint64_t v277 = *(void *)(v276 + 32);
              unint64_t v12 = v276 + 32;
              unint64_t v11 = v277;
              if (v277 == -1) {
                goto LABEL_385;
              }
              uint64_t v8 = (_anonymous_namespace_ *)v561;
              if ((unint64_t)v561 > v11)
              {
                v278 = *(void *)(v562 + 8 * v11);
                v585.n128_u32[0] = 20;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                v279 = *((void *)v533 + 230) - 1;
                *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v279) + 8) = v278;
                uint64_t v5 = v520;
                v585.n128_u32[0] = 28;
                v586 = 0uLL;
                v585.n128_u64[1] = 0;
                uint64_t v8 = (_anonymous_namespace_ *)v528;
                re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                unint64_t v11 = *((void *)v533 + 230) - 1;
                v280 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v11);
                *(void *)(v280 + 8) = v279;
                *(void *)(v280 + 16) = v500;
                v500 = v11;
LABEL_385:
                v281 = *(unsigned __int8 *)a4;
                if (v281 == 3)
                {
                  v585.n128_u32[0] = 34;
                  uint64_t v10 = (unint64_t)&v585.n128_u64[1];
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v469, (uint64_t)&v585);
                  a4 = (unint64_t)v533;
                  v363 = *((void *)v533 + 225) - 1;
                  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>((uint64_t)v8, v363)+ 8) = v500;
                  v585.n128_u32[0] = 40;
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                  uint64_t v13 = *((void *)v533 + 230) - 1;
                  v364 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v13);
                  *(void *)(v364 + 8) = v363;
                  *(void *)(v364 + 16) = v9;
                }
                else
                {
                  a4 = (unint64_t)v533;
                  if (v281 == 2)
                  {
                    uint64_t v10 = v500;
                    v365 = re::EvaluationTree::extractRotation(v533, v500);
                    v585.n128_u32[0] = 37;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                    unint64_t v11 = *((void *)v533 + 245) - 1;
                    *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v11)+ 8) = v500;
                    v366 = v533;
                    v367 = v9;
                    v368 = v365;
                    v369 = v11;
                  }
                  else
                  {
                    if (v281 != 1)
                    {
                      re::internal::assertLog((re::internal *)4, v159, "assertion failure: '%s' (%s:line %i) Unexpected node channel type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1545);
                      _os_crash();
                      __break(1u);
                      goto LABEL_832;
                    }
                    v282 = *(unsigned __int8 *)(v10 + 56 * v13 + 16);
                    if (v282 != 2)
                    {
                      if (v282 == 1)
                      {
                        uint64_t v10 = *(void *)(v10 + 56 * v13 + 24);
                        unint64_t v11 = v5[111];
                        if (v11 > v10)
                        {
                          v283 = v5[113];
                          *(_DWORD *)v604 = 0;
                          *(_DWORD *)v604 = *(unsigned __int8 *)(v283 + (v10 << 6) + 48);
                          v585.n128_u32[0] = 1;
                          uint64_t v10 = (unint64_t)&v585.n128_u64[1];
                          v586 = 0uLL;
                          v585.n128_u64[1] = 0;
                          re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                          v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                          re::DynamicArray<unsigned long>::add(v467, &v585);
                          re::DynamicArray<int>::add(v465, v604);
                          v284 = *(void *)(*((void *)v533 + 10) + 8 * *((void *)v533 + 8) - 8);
                          v585.n128_u32[0] = 13;
                          v586 = 0uLL;
                          v585.n128_u64[1] = 0;
                          re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                          unint64_t v11 = *((void *)v533 + 235) - 1;
                          v285 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)v8, v11);
                          *(void *)(v285 + 8) = v9;
                          *(void *)(v285 + 16) = v284;
                          goto LABEL_438;
                        }
LABEL_786:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 797;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_787:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 797;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_788:
                        *(void *)v630 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        v575[0].n128_u32[0] = 136315906;
                        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
                        v575[0].n128_u16[6] = 1024;
                        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
                        v575[1].n128_u16[1] = 2048;
                        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v12;
                        v575[1].n128_u16[6] = 2048;
                        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v13;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_789:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_790:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_791:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_792:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_793:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_794:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_795:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_796:
                        v607 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)v604 = 136315906;
                        *(void *)&v604[4] = "operator[]";
                        *(_WORD *)&v604[12] = 1024;
                        *(_DWORD *)&v604[14] = 468;
                        *(_WORD *)&v604[18] = 2048;
                        *(void *)&v604[20] = v10;
                        v605 = 2048;
                        *(void *)v606 = v11;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
LABEL_797:
                        *(void *)v630 = 0;
                        v589 = 0u;
                        v588 = 0u;
                        v587 = 0u;
                        v586 = 0u;
                        v585 = 0u;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        v575[0].n128_u32[0] = 136315906;
                        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
                        v575[0].n128_u16[6] = 1024;
                        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 468;
                        v575[1].n128_u16[1] = 2048;
                        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
                        v575[1].n128_u16[6] = 2048;
                        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v10;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
                        goto LABEL_798;
                      }
LABEL_832:
                      re::internal::assertLog((re::internal *)4, v159, "assertion failure: '%s' (%s:line %i) Invalid parameter rig node type.", "!\"Unreachable code\"", "constructEvaluationCommands", 1522);
                      _os_crash();
                      __break(1u);
LABEL_833:
                      re::internal::assertLog((re::internal *)5, v159, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "constructEvaluationCommands", 1562, v224);
                      _os_crash();
                      __break(1u);
LABEL_834:
                      re::internal::assertLog((re::internal *)5, v85, "assertion failure: '%s' (%s:line %i) Unknown Rig IK handle type: %u.", "!\"Unreachable code\"", "constructEvaluationCommands", 936, v88);
                      _os_crash();
                      __break(1u);
                      JUMPOUT(0x233259414);
                    }
                    uint64_t v10 = *(void *)(v10 + 56 * v13 + 24);
                    unint64_t v11 = v5[116];
                    if (v11 <= v10) {
                      goto LABEL_787;
                    }
                    v396 = v5[118];
                    *(_DWORD *)v604 = 0;
                    v397 = (__n128 *)(v396 + 96 * v10);
                    *(_DWORD *)v604 = v397[5].n128_u8[0];
                    v585.n128_u32[0] = 5;
                    uint64_t v10 = (unint64_t)&v585.n128_u64[1];
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    v585.n128_u64[0] = *((void *)v533 + 235) - 1;
                    re::DynamicArray<unsigned long>::add(v456, &v585);
                    re::DynamicArray<re::Vector3<float>>::add(v455, v397 + 1);
                    v527 = *(_anonymous_namespace_ **)(*((void *)v533 + 30) + 8 * *((void *)v533 + 28) - 8);
                    v585.n128_u32[0] = 5;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    v585.n128_u64[0] = *((void *)v533 + 235) - 1;
                    re::DynamicArray<unsigned long>::add(v456, &v585);
                    re::DynamicArray<re::Vector3<float>>::add(v455, v397 + 3);
                    v398 = *(void *)(*((void *)v533 + 30) + 8 * *((void *)v533 + 28) - 8);
                    v585.n128_u32[0] = 1;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v463, (uint64_t)&v585);
                    v585.n128_u64[0] = *((void *)v533 + 215) - 1;
                    re::DynamicArray<unsigned long>::add(v467, &v585);
                    re::DynamicArray<int>::add(v465, v604);
                    v399 = *(void *)(*((void *)v533 + 10) + 8 * *((void *)v533 + 8) - 8);
                    v585.n128_u32[0] = 13;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    v400 = *((void *)v533 + 235) - 1;
                    uint64_t v8 = (_anonymous_namespace_ *)v528;
                    v401 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v528, v400);
                    *(void *)(v401 + 8) = v9;
                    *(void *)(v401 + 16) = v399;
                    uint64_t v5 = v520;
                    v585.n128_u32[0] = 24;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    v402 = *((void *)v533 + 235) - 1;
                    v403 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v528, v402);
                    *(void *)(v403 + 8) = v527;
                    *(void *)(v403 + 16) = v400;
                    v585.n128_u32[0] = 24;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v503, (uint64_t)&v585);
                    unint64_t v11 = *((void *)v533 + 235) - 1;
                    v404 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v528, v11);
                    *(void *)(v404 + 8) = v402;
                    *(void *)(v404 + 16) = v398;
LABEL_438:
                    v405 = re::EvaluationTree::extractScale(v533, v500);
                    v585.n128_u32[0] = 37;
                    v586 = 0uLL;
                    v585.n128_u64[1] = 0;
                    re::DynamicArray<re::EvaluationRegister>::add(v496, (uint64_t)&v585);
                    v406 = *((void *)v533 + 245) - 1;
                    *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)v8, v406)+ 8) = v500;
                    v366 = v533;
                    v367 = v405;
                    v368 = v11;
                    v369 = v406;
                  }
                  uint64_t v13 = re::EvaluationTree::constructMatrix4x4(v366, v367, v368, v369);
                }
                uint64_t v9 = *(void *)v12;
                if (*(void *)v12 == -1) {
                  goto LABEL_470;
                }
                uint64_t v10 = (unint64_t)v561;
                if ((unint64_t)v561 > v9)
                {
                  v394 = *(void *)(v562 + 8 * v9);
                  v585.n128_u32[0] = 28;
LABEL_443:
                  v586 = 0uLL;
                  v585.n128_u64[1] = 0;
                  re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
                  v407 = *(void *)(a4 + 1840) - 1;
                  v408 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>((uint64_t)v8, v407);
                  *(void *)(v408 + 8) = v394;
                  *(void *)(v408 + 16) = v13;
                  uint64_t v13 = v407;
LABEL_470:
                  unsigned __int8 v225 = v493;
                  goto LABEL_471;
                }
LABEL_751:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_752:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_753:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_754:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_755:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_756:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_757:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_758:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_759:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 797;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_760:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_761:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_762:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_763:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_764:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_765:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_766:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_767:
                v607 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_768:
                *(void *)v630 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 468;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v11;
                v605 = 2048;
                *(void *)v606 = v9;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_769:
                *(void *)v630 = 0;
                v589 = 0u;
                v588 = 0u;
                v587 = 0u;
                v586 = 0u;
                v585 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v604 = 136315906;
                *(void *)&v604[4] = "operator[]";
                *(_WORD *)&v604[12] = 1024;
                *(_DWORD *)&v604[14] = 789;
                *(_WORD *)&v604[18] = 2048;
                *(void *)&v604[20] = v9;
                v605 = 2048;
                *(void *)v606 = v10;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_770;
              }
LABEL_750:
              v607 = 0;
              v589 = 0u;
              v588 = 0u;
              v587 = 0u;
              v586 = 0u;
              v585 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v604 = 136315906;
              *(void *)&v604[4] = "operator[]";
              *(_WORD *)&v604[12] = 1024;
              *(_DWORD *)&v604[14] = 468;
              *(_WORD *)&v604[18] = 2048;
              *(void *)&v604[20] = v11;
              v605 = 2048;
              *(void *)v606 = v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_751;
            }
LABEL_732:
            v607 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v13;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_733:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 476;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_734:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 476;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_735:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v10;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_736:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 797;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v11;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_737:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v11;
            v605 = 2048;
            *(void *)v606 = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_738:
            *(void *)v556 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_739:
            *(void *)v556 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_740:
            *(void *)v556 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_741:
            *(void *)v556 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = a4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_742:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v10;
            v605 = 2048;
            *(void *)v606 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_743:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_744:
            *(void *)v630 = 0;
            v589 = 0u;
            v588 = 0u;
            v587 = 0u;
            v586 = 0u;
            v585 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v604 = 136315906;
            *(void *)&v604[4] = "operator[]";
            *(_WORD *)&v604[12] = 1024;
            *(_DWORD *)&v604[14] = 468;
            *(_WORD *)&v604[18] = 2048;
            *(void *)&v604[20] = v9;
            v605 = 2048;
            *(void *)v606 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_745;
          }
LABEL_731:
          v607 = 0;
          v589 = 0u;
          v588 = 0u;
          v587 = 0u;
          v586 = 0u;
          v585 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v604 = 136315906;
          *(void *)&v604[4] = "operator[]";
          *(_WORD *)&v604[12] = 1024;
          *(_DWORD *)&v604[14] = 797;
          *(_WORD *)&v604[18] = 2048;
          *(void *)&v604[20] = v10;
          v605 = 2048;
          *(void *)v606 = v11;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_732;
        }
        if (v222 != 3) {
          goto LABEL_829;
        }
        uint64_t v10 = *(void *)(v221 + 16 * v10 + 8);
        unint64_t v11 = v5[81];
        if (v11 <= v10) {
          goto LABEL_730;
        }
        uint64_t v223 = v5[83];
        v224 = *(unsigned __int8 *)(v223 + 16 * v10);
        unsigned __int8 v225 = v493;
        switch(*(unsigned char *)(v223 + 16 * v10))
        {
          case 0:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = *((void *)&v534 + 1);
            if (*((void *)&v534 + 1) <= v10) {
              goto LABEL_789;
            }
            unint64_t v226 = v535;
            break;
          case 1:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = v536;
            if ((unint64_t)v536 <= v10) {
              goto LABEL_790;
            }
            unint64_t v226 = *((void *)&v536 + 1);
            break;
          case 2:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = *((void *)&v537 + 1);
            if (*((void *)&v537 + 1) <= v10) {
              goto LABEL_791;
            }
            unint64_t v226 = v538;
            break;
          case 3:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = v539;
            if ((unint64_t)v539 <= v10) {
              goto LABEL_792;
            }
            unint64_t v226 = *((void *)&v539 + 1);
            break;
          case 4:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = *((void *)&v540 + 1);
            if (*((void *)&v540 + 1) <= v10) {
              goto LABEL_793;
            }
            unint64_t v226 = v541;
            break;
          case 5:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = v542;
            if ((unint64_t)v542 <= v10) {
              goto LABEL_794;
            }
            unint64_t v226 = *((void *)&v542 + 1);
            break;
          case 6:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = *((void *)&v543 + 1);
            if (*((void *)&v543 + 1) <= v10) {
              goto LABEL_795;
            }
            unint64_t v226 = v544;
            break;
          case 7:
            uint64_t v10 = *(void *)(v223 + 16 * v10 + 8);
            unint64_t v11 = v545;
            if ((unint64_t)v545 <= v10) {
              goto LABEL_796;
            }
            unint64_t v226 = *((void *)&v545 + 1);
            break;
          default:
            goto LABEL_833;
        }
        *(void *)(v226 + 8 * v10) = appended;
        uint64_t v13 = v500;
LABEL_471:
        float32x4_t v162 = (_anonymous_namespace_ *)((char *)v225 + 1);
        float v161 = v13;
      }
      while ((unint64_t)v162 < *v476);
LABEL_474:
      uint64_t v9 = (unint64_t)v561;
      unint64_t v11 = v478;
      if ((unint64_t)v561 <= v478) {
        goto LABEL_768;
      }
      uint64_t v9 = *(void *)(v562 + 8 * v478) - 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v10 = *(void *)(a4 + 824);
      if (v10 <= v9) {
        goto LABEL_769;
      }
      v413 = *(void *)(a4 + 840);
      *(void *)(v413 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = v13;
      unint64_t v11 = v478 + 1;
      unint64_t v12 = v532;
      if (v478 + 1 == v532)
      {
        uint64_t v9 = 0;
        v414 = v559;
        while (1)
        {
          uint64_t v10 = v5[163];
          if (v10 <= v9) {
            break;
          }
          v415 = *(void *)(v5[164] + 8 * v9);
          if (v415 != -1)
          {
            uint64_t v10 = v558;
            if (v558 <= v9) {
              goto LABEL_779;
            }
            uint64_t v10 = *(void *)(v414 + 8 * v9) - 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v11 = *(void *)(a4 + 824);
            if (v11 <= v10) {
              goto LABEL_780;
            }
            *(void *)(v413 + 8 * v10) = v415;
          }
          if (v532 == ++v9) {
            goto LABEL_484;
          }
        }
LABEL_770:
        *(void *)v630 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 476;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = v9;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_771:
        v607 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v604 = 136315906;
        *(void *)&v604[4] = "operator[]";
        *(_WORD *)&v604[12] = 1024;
        *(_DWORD *)&v604[14] = 797;
        *(_WORD *)&v604[18] = 2048;
        *(void *)&v604[20] = 1;
        v605 = 2048;
        *(void *)v606 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_772:
        v549 = 0;
        v589 = 0u;
        v588 = 0u;
        v587 = 0u;
        v586 = 0u;
        v585 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v575[0].n128_u32[0] = 136315906;
        *(unint64_t *)((char *)v575[0].n128_u64 + 4) = (unint64_t)"operator[]";
        v575[0].n128_u16[6] = 1024;
        *(unsigned __int32 *)((char *)&v575[0].n128_u32[3] + 2) = 797;
        v575[1].n128_u16[1] = 2048;
        *(unint64_t *)((char *)v575[1].n128_u64 + 4) = v11;
        v575[1].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&v575[1].n128_u64[1] + 6) = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_773;
      }
    }
  }
LABEL_484:
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)&v612 + 1, *v5, a3);
  re::FixedArray<re::EvaluationSRT>::init<>(&v614, *v5, a3);
  if (!a3)
  {
LABEL_496:
    re::types::Ok<re::EvaluationRigState>::Ok(&v585, (uint64_t *)v611);
    re::Result<re::EvaluationRigState,re::DetailedError>::Result(a5, (uint64_t *)&v585);
    re::RigGraphCompilation::~RigGraphCompilation((re::RigGraphCompilation *)((char *)v590 + 8));
    if ((void)v589)
    {
      if (*((void *)&v589 + 1))
      {
        (*(void (**)(void, void))(*(void *)v589 + 40))(v589, *(void *)&v590[0]);
        *((void *)&v589 + 1) = 0;
        *(void *)&v590[0] = 0;
      }
      *(void *)&v589 = 0;
    }
    if (*((void *)&v587 + 1))
    {
      if ((void)v588)
      {
        (*(void (**)(void, void))(**((void **)&v587 + 1) + 40))(*((void *)&v587 + 1), *((void *)&v588 + 1));
        v588 = 0uLL;
      }
      *((void *)&v587 + 1) = 0;
    }
    std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v585);
    goto LABEL_512;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 0;
  v531 = (_anonymous_namespace_ *)(a4 + 1944);
  v532 = (unint64_t)(v520 + 147);
  uint64_t v5 = v497;
  while (1)
  {
    v416 = (unint64_t *)re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(v532, (char **)((char *)v8 + a2));
    if (!v416) {
      break;
    }
    uint64_t v10 = *v416;
    unint64_t v11 = v558;
    if (v558 <= *v416) {
      goto LABEL_725;
    }
    unint64_t v11 = v613;
    if ((unint64_t)v613 <= v7) {
      goto LABEL_726;
    }
    v417 = v559;
    unint64_t v11 = *(void *)(v559 + 8 * v10);
    *(void *)(*((void *)&v613 + 1) + 8 * v7) = v11;
    unint64_t v12 = v520[131];
    if (v12 <= v10) {
      goto LABEL_727;
    }
    uint64_t v10 = *(void *)(v520[133] + 56 * v10 + 32);
    if (v10 == -1)
    {
      v420 = v528;
    }
    else
    {
      unint64_t v12 = v558;
      if (v558 <= v10) {
        goto LABEL_746;
      }
      v418 = *(void *)(v417 + 8 * v10);
      v585.n128_u32[0] = 20;
      v586 = 0uLL;
      v585.n128_u64[1] = 0;
      re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
      v419 = *(void *)(a4 + 1840) - 1;
      *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v419) + 8) = v418;
      v585.n128_u32[0] = 28;
      v586 = 0uLL;
      v585.n128_u64[1] = 0;
      v420 = v528;
      re::DynamicArray<re::EvaluationRegister>::add(v497, (uint64_t)&v585);
      v421 = *(void *)(a4 + 1840) - 1;
      v422 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v528, v421);
      *(void *)(v422 + 8) = v419;
      *(void *)(v422 + 16) = v11;
      unint64_t v11 = v421;
    }
    unint64_t v12 = re::EvaluationTree::extractScale((void *)a4, v11);
    uint64_t v13 = re::EvaluationTree::extractRotation((void *)a4, v11);
    v585.n128_u32[0] = 37;
    v586 = 0uLL;
    v585.n128_u64[1] = 0;
    re::DynamicArray<re::EvaluationRegister>::add(v531, (uint64_t)&v585);
    a4 = *(void *)(a4 + 1960) - 1;
    *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v420, a4) + 8) = v11;
    uint64_t v10 = *((void *)&v614 + 1);
    if (*((void *)&v614 + 1) <= v7) {
      goto LABEL_728;
    }
    v423 = (unint64_t *)(v615 + v9);
    *v423 = v12;
    v423[1] = v13;
    v423[2] = a4;
    ++v7;
    v9 += 24;
    uint64_t v8 = (_anonymous_namespace_ *)((char *)v8 + 8);
    a4 = (unint64_t)v533;
    if (a3 == v7) {
      goto LABEL_496;
    }
  }
LABEL_511:
  re::DynamicString::format((re::DynamicString *)*v520, (re::Allocator *)"Output Joint '%s' does not exist.", (re::DynamicString *)&v585, *(void *)(a2 + 8 * v7), v439);
  v424 = v585;
  v425 = v586;
  *(unsigned char *)a5 = 0;
  *(void *)(a5 + 8) = 3002;
  *(void *)(a5 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(__n128 *)(a5 + 24) = v424;
  *(float32x4_t *)(a5 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = v425;
LABEL_512:
  if (*((void *)&v544 + 1))
  {
    if ((void)v545)
    {
      (*(void (**)(void))(**((void **)&v544 + 1) + 40))(*((void *)&v544 + 1));
      v545 = 0uLL;
    }
    *((void *)&v544 + 1) = 0;
  }
  if ((void)v543)
  {
    if (*((void *)&v543 + 1))
    {
      (*(void (**)(void))(*(void *)v543 + 40))(v543);
      *((void *)&v543 + 1) = 0;
      *(void *)&v544 = 0;
    }
    *(void *)&v543 = 0;
  }
  if (*((void *)&v541 + 1))
  {
    if ((void)v542)
    {
      (*(void (**)(void))(**((void **)&v541 + 1) + 40))(*((void *)&v541 + 1));
      v542 = 0uLL;
    }
    *((void *)&v541 + 1) = 0;
  }
  if ((void)v540)
  {
    if (*((void *)&v540 + 1))
    {
      (*(void (**)(void))(*(void *)v540 + 40))(v540);
      *((void *)&v540 + 1) = 0;
      *(void *)&v541 = 0;
    }
    *(void *)&v540 = 0;
  }
  if (*((void *)&v538 + 1))
  {
    if ((void)v539)
    {
      (*(void (**)(void))(**((void **)&v538 + 1) + 40))(*((void *)&v538 + 1));
      v539 = 0uLL;
    }
    *((void *)&v538 + 1) = 0;
  }
  if ((void)v537)
  {
    if (*((void *)&v537 + 1))
    {
      (*(void (**)(void))(*(void *)v537 + 40))(v537);
      *((void *)&v537 + 1) = 0;
      *(void *)&v538 = 0;
    }
    *(void *)&v537 = 0;
  }
  if (*((void *)&v535 + 1))
  {
    if ((void)v536)
    {
      (*(void (**)(void))(**((void **)&v535 + 1) + 40))(*((void *)&v535 + 1));
      v536 = 0uLL;
    }
    *((void *)&v535 + 1) = 0;
  }
  if ((void)v534 && *((void *)&v534 + 1)) {
    (*(void (**)(void))(*(void *)v534 + 40))(v534);
  }
  if (*((void *)&v583 + 1))
  {
    if ((void)v584)
    {
      (*(void (**)(void))(**((void **)&v583 + 1) + 40))(*((void *)&v583 + 1));
      v584 = 0uLL;
    }
    *((void *)&v583 + 1) = 0;
  }
  if ((void)v582)
  {
    if (*((void *)&v582 + 1))
    {
      (*(void (**)(void))(*(void *)v582 + 40))(v582);
      *((void *)&v582 + 1) = 0;
      *(void *)&v583 = 0;
    }
    *(void *)&v582 = 0;
  }
  if (*((void *)&v580 + 1))
  {
    if ((void)v581)
    {
      (*(void (**)(void))(**((void **)&v580 + 1) + 40))(*((void *)&v580 + 1));
      v581 = 0uLL;
    }
    *((void *)&v580 + 1) = 0;
  }
  if ((void)v579)
  {
    if (*((void *)&v579 + 1))
    {
      (*(void (**)(void))(*(void *)v579 + 40))(v579);
      *((void *)&v579 + 1) = 0;
      *(void *)&v580 = 0;
    }
    *(void *)&v579 = 0;
  }
  if (*((void *)&v577 + 1))
  {
    if ((void)v578)
    {
      (*(void (**)(void))(**((void **)&v577 + 1) + 40))(*((void *)&v577 + 1));
      v578 = 0uLL;
    }
    *((void *)&v577 + 1) = 0;
  }
  if ((void)v576)
  {
    if (*((void *)&v576 + 1))
    {
      (*(void (**)(void))(*(void *)v576 + 40))(v576);
      *((void *)&v576 + 1) = 0;
      *(void *)&v577 = 0;
    }
    *(void *)&v576 = 0;
  }
  if (v575[1].n128_u64[1])
  {
    if (v575[2].n128_u64[0])
    {
      (*(void (**)(unint64_t))(*(void *)v575[1].n128_u64[1] + 40))(v575[1].n128_u64[1]);
      v575[2] = 0uLL;
    }
    v575[1].n128_u64[1] = 0;
  }
  if (v575[0].n128_u64[0] && v575[0].n128_u64[1]) {
    (*(void (**)(unint64_t))(*(void *)v575[0].n128_u64[0] + 40))(v575[0].n128_u64[0]);
  }
LABEL_574:
  if (v557 && v558) {
    (*(void (**)(uint64_t))(*(void *)v557 + 40))(v557);
  }
  if (v560 && v561) {
    (*(void (**)(uint64_t))(*(void *)v560 + 40))(v560);
  }
  if (v563 && v564) {
    (*(void (**)(uint64_t))(*(void *)v563 + 40))(v563);
  }
  if (v566 && v567) {
    (*(void (**)(uint64_t))(*(void *)v566 + 40))(v566);
  }
  if (v569 && v570) {
    (*(void (**)(uint64_t))(*(void *)v569 + 40))(v569);
  }
  re::RigGraphCompilation::~RigGraphCompilation((re::RigGraphCompilation *)((char *)&v615 + 8));
  if ((void)v614)
  {
    if (*((void *)&v614 + 1))
    {
      (*(void (**)(void))(*(void *)v614 + 40))(v614);
      *((void *)&v614 + 1) = 0;
      *(void *)&v615 = 0;
    }
    *(void *)&v614 = 0;
  }
  if (*((void *)&v612 + 1))
  {
    if ((void)v613)
    {
      (*(void (**)(void))(**((void **)&v612 + 1) + 40))(*((void *)&v612 + 1));
      v613 = 0uLL;
    }
    *((void *)&v612 + 1) = 0;
  }
  std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::~unique_ptr[abi:nn180100]((uint64_t *)v611);
  re::Allocator::~Allocator((re::Allocator *)v572);
}

uint64_t *std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::operator=[abi:nn180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *a1;
  *a1 = v4;
  if (v5) {
    std::function<void ()(re::internal::RigIKCallbackData *)>::operator()((uint64_t)(a1 + 1), v5);
  }
  std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::operator=[abi:nn180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void re::FixedArray<re::internal::RigIKCall>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >= 0x1E1E1E1E1E1E1E2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 136, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 136 * a3;
  unint64_t v6 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 136 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 136);
    v8 += v5 - 136;
  }
  *((void *)v8 + 16) = 0;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
}

uint64_t *re::anonymous namespace'::rigIKCallbackFunction(re::_anonymous_namespace_ *this, re::EvaluationContext *a2, void *a3)
{
  uint64_t result = re::FixedArray<re::Matrix4x4<float>>::operator=((uint64_t *)this + 39, (uint64_t)this + 96);
  if (*((void *)a2 + 1))
  {
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *((void *)a2 + 2);
      uint64_t v8 = v7 + 136 * v6;
      uint64_t v9 = *(void *)(v8 + 80);
      if (v9) {
        break;
      }
      uint64_t v17 = v7 + 136 * v6;
      uint64_t v20 = *(void *)(v17 + 64);
      char v18 = (unint64_t *)(v17 + 64);
      uint64_t v19 = v20;
      if (v20)
      {
        unint64_t v21 = 0;
        __int16 v22 = (void *)(v7 + 136 * v6);
        int v23 = v22 + 9;
        __int16 v24 = v22 + 13;
        unint64_t v25 = v22 + 14;
        while (*v18 > v21)
        {
          unint64_t v26 = *(void *)(*v23 + 8 * v21);
          if (*((void *)this + 40) <= v26) {
            goto LABEL_20;
          }
          if (*v24 <= v21) {
            goto LABEL_21;
          }
          *(_OWORD *)(*v25 + 16 * v21++) = *(_OWORD *)(*((void *)this + 41) + (v26 << 6) + 48);
          if (v19 == v21) {
            goto LABEL_15;
          }
        }
LABEL_19:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_20:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_21:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
LABEL_15:
      unint64_t v27 = (void *)(v7 + 136 * v6);
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void, void, void, void, void, void, void, void, void, void, void))v8)(*((void *)this + 41), *((void *)this + 40), *((void *)a2 + 5), *((void *)a2 + 4), v27[3], v27[2], v27[6], v27[5], v27[14], v27[13], v27[15]);
      if ((unint64_t)++v6 >= *((void *)a2 + 1)) {
        return result;
      }
    }
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    unint64_t v12 = (void *)(v7 + 136 * v6);
    uint64_t v13 = v12 + 11;
    uint64_t v14 = v12 + 13;
    unint64_t v15 = v12 + 14;
    while (1)
    {
      unint64_t v16 = v11 + *v13;
      if (*((void *)this + 22) <= v16) {
        break;
      }
      if (*v14 <= v11) {
        goto LABEL_18;
      }
      *(_OWORD *)(*v15 + v10) = *(_OWORD *)(*((void *)this + 23) + 16 * v16);
      ++v11;
      v10 += 16;
      if (v9 == v11) {
        goto LABEL_15;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_19;
  }
  return result;
}

uint64_t re::anonymous namespace'::calculateWeightedConstraint<re::EvaluationRegisterId<re::Vector3<float>>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7)
{
  uint64_t v7 = a7;
  uint64_t v8 = a5;
  uint64_t v10 = a3;
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v13 = *(void *)(a4 + 16);
  if (v13 == 2)
  {
    uint64_t v17 = *(void *)(a5 + 16);
    if (!v17) {
      goto LABEL_13;
    }
    if (v17 == 1) {
      goto LABEL_31;
    }
    float v18 = **(float **)(a5 + 32) + *(float *)(*(void *)(a5 + 32) + 4);
    if (v18 == 1.0 || vabds_f32(1.0, v18) < (float)((float)((float)(fabsf(v18) + 1.0) + 1.0) * 0.00001))
    {
LABEL_13:
      uint64_t v19 = a6(a1, **(void **)(a4 + 32), a2, a3, a7);
      unint64_t v20 = *(void *)(a4 + 16);
      if (v20 <= 1)
      {
LABEL_30:
        uint64_t v50 = 0;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v56 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v51 = 136315906;
        *(void *)&v51[4] = "operator[]";
        *(_WORD *)&v51[12] = 1024;
        *(_DWORD *)&v51[14] = 797;
        __int16 v52 = 2048;
        uint64_t v53 = 1;
        __int16 v54 = 2048;
        uint64_t v55 = v20;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_31:
        uint64_t v50 = 0;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v56 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v51 = 136315906;
        *(void *)&v51[4] = "operator[]";
        *(_WORD *)&v51[12] = 1024;
        *(_DWORD *)&v51[14] = 797;
        __int16 v52 = 2048;
        uint64_t v53 = 1;
        __int16 v54 = 2048;
        uint64_t v55 = 1;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v21 = v19;
      uint64_t v22 = a6(a1, *(void *)(*(void *)(a4 + 32) + 8), a2, v10, v7);
      if (*(void *)(v8 + 16)) {
        float v23 = **(float **)(v8 + 32);
      }
      else {
        float v23 = 0.5;
      }
      *(float *)unint64_t v51 = v23;
      LODWORD(v56) = 2;
      long long v57 = 0uLL;
      *((void *)&v56 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 218), (uint64_t)&v56);
      *(void *)&long long v56 = a1[220] - 1;
      re::DynamicArray<unsigned long>::add(a1 + 11, &v56);
      re::DynamicArray<float>::add((_anonymous_namespace_ *)(a1 + 51), (float *)v51);
      uint64_t v39 = *(void *)(a1[15] + 8 * a1[13] - 8);
      LODWORD(v56) = 11;
      long long v57 = 0uLL;
      *((void *)&v56 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v56);
      unint64_t v37 = a1[245] - 1;
      unint64_t v40 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v37);
      v40[1] = v21;
      v40[2] = v22;
      float32x4_t v40[3] = v39;
      return v37;
    }
LABEL_16:
    *(void *)unint64_t v51 = 0;
    *(void *)&v51[8] = 0;
    LODWORD(v56) = 7;
    long long v57 = 0uLL;
    *((void *)&v56 + 1) = 0;
    unint64_t v45 = (_anonymous_namespace_ *)(a1 + 243);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v56);
    *(void *)&long long v56 = a1[245] - 1;
    uint64_t v24 = a4;
    unint64_t v25 = &v56;
    re::DynamicArray<unsigned long>::add(a1 + 36, &v56);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v51);
    unint64_t v26 = *(void *)(a1[40] + 8 * a1[38] - 8);
    unint64_t v27 = *(void *)(v24 + 16);
    if (v27)
    {
      uint64_t v43 = *(void *)(a1[40] + 8 * a1[38] - 8);
      uint64_t v44 = a2;
      unint64_t v28 = 0;
      uint64_t v42 = *(void *)(v24 + 16);
      uint64_t v41 = (uint64_t)(a1 + 208);
      float v29 = 1.0 / (float)v27;
      while (1)
      {
        unint64_t v20 = *(void *)(v24 + 16);
        if (v20 <= v28) {
          break;
        }
        uint64_t v30 = a6(a1, *(void *)(*(void *)(v24 + 32) + 8 * v28), v44, v10, v7);
        float v49 = 0.0;
        unint64_t v25 = *(long long **)(v8 + 16);
        float v31 = v29;
        if (v25)
        {
          if ((unint64_t)v25 <= v28) {
            goto LABEL_29;
          }
          float v31 = *(float *)(*(void *)(v8 + 32) + 4 * v28);
        }
        float v49 = v31;
        LODWORD(v56) = 2;
        long long v57 = 0uLL;
        *((void *)&v56 + 1) = 0;
        uint64_t v48 = v30;
        re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 218), (uint64_t)&v56);
        *(void *)&long long v56 = a1[220] - 1;
        re::DynamicArray<unsigned long>::add(a1 + 11, &v56);
        re::DynamicArray<float>::add((_anonymous_namespace_ *)(a1 + 51), &v49);
        uint64_t v32 = v8;
        uint64_t v33 = v10;
        uint64_t v34 = v7;
        uint64_t v35 = *(void *)(a1[15] + 8 * a1[13] - 8);
        LODWORD(v56) = 11;
        long long v57 = 0uLL;
        *((void *)&v56 + 1) = 0;
        re::DynamicArray<re::EvaluationRegister>::add(v45, (uint64_t)&v56);
        unint64_t v25 = (long long *)(a1[245] - 1);
        unint64_t v36 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v41, (unint64_t)v25);
        v36[1] = v43;
        v36[2] = v48;
        v36[3] = v35;
        uint64_t v7 = v34;
        uint64_t v10 = v33;
        uint64_t v8 = v32;
        LODWORD(v56) = 8;
        long long v57 = 0uLL;
        *((void *)&v56 + 1) = 0;
        re::DynamicArray<re::EvaluationRegister>::add(v45, (uint64_t)&v56);
        unint64_t v37 = a1[245] - 1;
        uint64_t v38 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v41, v37);
        *(void *)(v38 + 8) = v26;
        *(void *)(v38 + 16) = v25;
        ++v28;
        unint64_t v26 = v37;
        if (v42 == v28) {
          return v37;
        }
      }
      uint64_t v50 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v56 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v51 = 136315906;
      *(void *)&v51[4] = "operator[]";
      *(_WORD *)&v51[12] = 1024;
      *(_DWORD *)&v51[14] = 797;
      __int16 v52 = 2048;
      uint64_t v53 = v28;
      __int16 v54 = 2048;
      uint64_t v55 = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_29:
      uint64_t v50 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v56 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v51 = 136315906;
      *(void *)&v51[4] = "operator[]";
      *(_WORD *)&v51[12] = 1024;
      *(_DWORD *)&v51[14] = 797;
      __int16 v52 = 2048;
      uint64_t v53 = v28;
      __int16 v54 = 2048;
      uint64_t v55 = (uint64_t)v25;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_30;
    }
    return *(void *)(a1[40] + 8 * a1[38] - 8);
  }
  if (v13 != 1) {
    goto LABEL_16;
  }
  if (*(void *)(a5 + 16))
  {
    float v14 = **(float **)(a5 + 32);
    if (v14 != 1.0 && vabds_f32(1.0, v14) >= (float)((float)((float)(fabsf(v14) + 1.0) + 1.0) * 0.00001)) {
      goto LABEL_16;
    }
  }
  uint64_t v15 = **(void **)(a4 + 32);
  return a6(a1, v15, a2, a3, a7);
}

unint64_t re::anonymous namespace'::calculatePointConstraint(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (*(void *)(a3 + 8) <= a2)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v7 = *(void *)(*(void *)(a3 + 16) + 8 * a2);
  uint64_t v8 = a1 + 1664;
  uint64_t v9 = (_anonymous_namespace_ *)(a1 + 1944);
  LODWORD(v16) = 37;
  long long v17 = 0uLL;
  *((void *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 1944), (uint64_t)&v16);
  unint64_t v10 = *(void *)(a1 + 1960) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v10) + 8) = v7;
  if (*(void *)(a4 + 8) <= a2) {
    goto LABEL_5;
  }
  uint64_t v11 = *(void *)(*(void *)(a4 + 16) + 8 * a2);
  LODWORD(v16) = 37;
  long long v17 = 0uLL;
  *((void *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v9, (uint64_t)&v16);
  unint64_t v12 = *(void *)(a1 + 1960) - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v12) + 8) = v11;
  LODWORD(v16) = 31;
  long long v17 = 0uLL;
  *((void *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v9, (uint64_t)&v16);
  unint64_t v13 = *(void *)(a1 + 1960) - 1;
  uint64_t v14 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v13);
  *(void *)(v14 + 8) = v12;
  *(void *)(v14 + 16) = v10;
  return v13;
}

unint64_t re::anonymous namespace'::extractConstrainedComponents(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  v8.i32[0] = *a2;
  v8.i32[1] = a2[1];
  __asm { FMOV            V1.2S, #1.0 }
  a5.n128_u64[0] = (unint64_t)vbic_s8(_D1, (int8x8_t)vceqz_s32(v8));
  float v14 = 1.0;
  if (!a2[2]) {
    float v14 = 0.0;
  }
  a5.n128_f32[2] = v14;
  __n128 v23 = a5;
  LODWORD(v24) = 7;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v15 = a1 + 36;
  long long v16 = (_anonymous_namespace_ *)(a1 + 76);
  uint64_t v17 = (uint64_t)(a1 + 208);
  long long v18 = (_anonymous_namespace_ *)(a1 + 243);
  uint64_t v25 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v24);
  uint64_t v24 = a1[245] - 1;
  re::DynamicArray<unsigned long>::add(v15, &v24);
  re::DynamicArray<re::Vector3<float>>::add(v16, &v23);
  uint64_t v19 = *(void *)(a1[40] + 8 * a1[38] - 8);
  LODWORD(v24) = 10;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v18, (uint64_t)&v24);
  unint64_t v20 = a1[245] - 1;
  uint64_t v21 = (void *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v17, v20);
  v21[1] = a3;
  _OWORD v21[2] = a4;
  v21[3] = v19;
  return v20;
}

unint64_t re::anonymous namespace'::calculateOrientConstraint(void *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a3 <= a2)
  {
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v15 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v15 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t Rotation = re::EvaluationTree::extractRotation(a1, *(void *)(a4 + 8 * a2));
  if (*(void *)(a5 + 8) <= a2) {
    goto LABEL_5;
  }
  unint64_t v9 = Rotation;
  unint64_t v10 = re::EvaluationTree::extractRotation(a1, *(void *)(*(void *)(a5 + 16) + 8 * a2));
  LODWORD(v15) = 21;
  long long v16 = 0uLL;
  *((void *)&v15 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 233), (uint64_t)&v15);
  unint64_t v11 = a1[235] - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)(a1 + 208), v11) + 8) = v9;
  LODWORD(v15) = 24;
  long long v16 = 0uLL;
  *((void *)&v15 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 233), (uint64_t)&v15);
  unint64_t v12 = a1[235] - 1;
  uint64_t v13 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)(a1 + 208), v12);
  *(void *)(v13 + 8) = v10;
  *(void *)(v13 + 16) = v11;
  return v12;
}

uint64_t re::anonymous namespace'::rigNodeRotationOrder(void *a1, char a2, unint64_t a3)
{
  if (a2 != 1)
  {
    if (a1[115] > a3)
    {
      uint64_t v3 = (unsigned __int8 *)(a1[117] + 96 * a3 + 80);
      return *v3;
    }
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (a1[110] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_8;
  }
  uint64_t v3 = (unsigned __int8 *)(a1[112] + (a3 << 6) + 48);
  return *v3;
}

uint64_t re::anonymous namespace'::calculateParentConstraintSRT(unint64_t *a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (a4 <= a3)
  {
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v18 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v18 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (a6 <= a3) {
    goto LABEL_5;
  }
  uint64_t v9 = *(void *)(a5 + 8 * a3);
  uint64_t v10 = *(void *)(a7 + 8 * a3);
  uint64_t v11 = (uint64_t)(a2 + 208);
  unint64_t v12 = (_anonymous_namespace_ *)(a2 + 228);
  LODWORD(v18) = 20;
  long long v19 = 0uLL;
  *((void *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a2 + 228), (uint64_t)&v18);
  unint64_t v13 = a2[230] - 1;
  *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v11, v13) + 8) = v9;
  LODWORD(v18) = 28;
  long long v19 = 0uLL;
  *((void *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v12, (uint64_t)&v18);
  uint64_t v14 = a2[230] - 1;
  uint64_t v15 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v11, v14);
  *(void *)(v15 + 8) = v10;
  *(void *)(v15 + 16) = v13;
  *a1 = re::EvaluationTree::extractScale(a2, v14);
  a1[1] = re::EvaluationTree::extractRotation(a2, v14);
  LODWORD(v18) = 37;
  long long v19 = 0uLL;
  *((void *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a2 + 243), (uint64_t)&v18);
  unint64_t v16 = a2[245] - 1;
  uint64_t result = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v11, v16);
  *(void *)(result + 8) = v14;
  a1[2] = v16;
  return result;
}

uint64_t re::anonymous namespace'::calculateAimForwardDirection(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  int v7 = *(unsigned __int8 *)(a5[1] + 3);
  if (v7 == 2)
  {
    *(void *)uint64_t v24 = 0;
    *(void *)&v24[8] = 1065353216;
    LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 7;
    long long v30 = 0uLL;
    *((void *)&v29 + 1) = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
    *(void *)&long long v29 = a1[245] - 1;
    re::DynamicArray<unsigned long>::add(a1 + 36, &v29);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v24);
    return *(void *)(a1[40] + 8 * a1[38] - 8);
  }
  if (v7 == 1)
  {
    unint64_t v5 = *(void *)(a4 + 8);
    if (v5 > a2)
    {
      uint64_t v18 = *(void *)(*(void *)(a4 + 16) + 8 * a2);
      *(void *)uint64_t v24 = 0;
      *(void *)&v24[8] = 1065353216;
      uint64_t v19 = (uint64_t)(a1 + 208);
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 7;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      *(void *)&long long v29 = a1[245] - 1;
      re::DynamicArray<unsigned long>::add(a1 + 36, &v29);
      re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v24);
      uint64_t v20 = *(void *)(a1[40] + 8 * a1[38] - 8);
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 42;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      unint64_t v21 = a1[245] - 1;
      uint64_t v22 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v21);
      *(void *)(v22 + 8) = v18;
      *(void *)(v22 + 16) = v20;
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 29;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      unint64_t v17 = a1[245] - 1;
      *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v19, v17) + 8) = v21;
      return v17;
    }
    goto LABEL_11;
  }
  if (!*(unsigned char *)(a5[1] + 3))
  {
    unint64_t v9 = *(void *)(a4 + 8);
    if (v9 > a2)
    {
      uint64_t v11 = *(void *)(*(void *)(a4 + 16) + 8 * a2);
      uint64_t v12 = (uint64_t)(a1 + 208);
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 37;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      unint64_t v13 = a1[245] - 1;
      *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v13)
                + 8) = v11;
      uint64_t v14 = *a5;
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 31;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      unint64_t v15 = a1[245] - 1;
      uint64_t v16 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v15);
      *(void *)(v16 + 8) = v13;
      *(void *)(v16 + 16) = v14;
      LODWORD(v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = 29;
      long long v30 = 0uLL;
      *((void *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      unint64_t v17 = a1[245] - 1;
      *(void *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v17) + 8) = v15;
      return v17;
    }
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v29 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v24 = 136315906;
    *(void *)&v24[4] = "operator[]";
    *(_WORD *)&unsigned char v24[12] = 1024;
    *(_DWORD *)&v24[14] = 476;
    __int16 v25 = 2048;
    unint64_t v26 = a2;
    __int16 v27 = 2048;
    unint64_t v28 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_11:
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v29 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v24 = 136315906;
    *(void *)&v24[4] = "operator[]";
    *(_WORD *)&unsigned char v24[12] = 1024;
    *(_DWORD *)&v24[14] = 476;
    __int16 v25 = 2048;
    unint64_t v26 = a2;
    __int16 v27 = 2048;
    unint64_t v28 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected aim constraint forward axis type.", "!\"Unreachable code\"", "calculateAimForwardDirection", 233);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::FixedArray<re::FixedArray<float>>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >= 0xAAAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 24, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 24 * a3;
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 24 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  int32x2_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 24);
    int32x2_t v8 = (void *)((char *)v8 + v5 - 24);
  }
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v8[2] = 0;
}

void re::FixedArray<re::TwoBoneIKOptions>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 32 * a3;
  uint64_t v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  int32x2_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    int32x2_t v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  _OWORD *v8 = 0u;
  v8[1] = 0u;
}

void *re::FixedArray<re::FABRIKOptions>::init<>(void *result, uint64_t a2, unint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  if (!a3) {
    return result;
  }
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = result;
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 8 * a3, 4);
  unint64_t v4[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *result++ = 0x203DCCCCCDLL;
      --v6;
    }
    while (v6);
  }
  *uint64_t result = 0x203DCCCCCDLL;
  return result;
}

uint64_t re::FixedArray<re::SplineIKOptions>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (!a3) {
    return result;
  }
  if (a3 >= 0x333333333333334)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 80, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = result;
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 80 * a3, 16);
  *(void *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_DWORD *)uint64_t result = 1008981770;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(_WORD *)(result + 24) = 0;
      *(_OWORD *)(result + 32) = 0uLL;
      *(_OWORD *)(result + 48) = 0uLL;
      *(_DWORD *)(result + 64) = 0;
      result += 80;
      --v6;
    }
    while (v6);
  }
  *(_DWORD *)uint64_t result = 1008981770;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(_WORD *)(result + 24) = 0;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_DWORD *)(result + 64) = 0;
  return result;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::RigComponentConstraint>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::RigComponentConstraint>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::RigComponentConstraint>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::RigComponentConstraint>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigComponentConstraint>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 88 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = a1[4];
      uint64_t v12 = 88 * v9;
      uint64_t v13 = 88 * v4;
      do
      {
        uint64_t v14 = v11 + v12;
        __int16 v15 = *(_WORD *)(v10 + v12);
        *(unsigned char *)(v14 + 2) = *(unsigned char *)(v10 + v12 + 2);
        *(_WORD *)uint64_t v14 = v15;
        re::DynamicArray<unsigned long>::DynamicArray(v11 + v12 + 8, (uint64_t *)(v10 + v12 + 8));
        uint64_t result = re::DynamicArray<float>::DynamicArray(v11 + v12 + 48, (uint64_t *)(v10 + v12 + 48));
        v13 -= 88;
        v10 += 88;
        v11 += 88;
      }
      while (v12 != v13);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 88 * v4, a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = -88 * v4 + 88 * v6;
      uint64_t v8 = 88 * v4 + a1[4] + 48;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v8);
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v8 - 40);
        v8 += 88;
        v7 -= 88;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      __int16 v6 = *(_WORD *)v5;
      *(unsigned char *)(a3 + 2) = *(unsigned char *)(v5 + 2);
      *(_WORD *)a3 = v6;
      re::DynamicArray<unsigned long>::operator=(a3 + 8, (uint64_t *)(v5 + 8));
      uint64_t result = re::DynamicArray<float>::operator=(a3 + 48, (uint64_t *)(v5 + 48));
      v5 += 88;
      a3 += 88;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigBasicConstraint>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 80 * a1[2]), a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = 5 * v9;
      uint64_t v11 = (uint64_t *)(*(void *)(a2 + 32) + 16 * v10);
      uint64_t v12 = a1[4] + 16 * v10;
      uint64_t v13 = 80 * v4 - 16 * v10;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v12, v11);
        uint64_t result = re::DynamicArray<float>::DynamicArray(v12 + 40, v11 + 5);
        v11 += 10;
        v12 += 80;
        v13 -= 80;
      }
      while (v13);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 80 * v4), a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = a1[4] + 80 * v4;
      uint64_t v8 = 80 * v6 - 80 * v4;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v7 + 40);
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v7);
        v7 += 80;
        v8 -= 80;
      }
      while (v8);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)result != a2)
  {
    uint64_t v5 = (uint64_t *)result;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, v5);
      uint64_t result = re::DynamicArray<float>::operator=(a3 + 40, v5 + 5);
      v5 += 10;
      a3 += 80;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigAimConstraint>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = v10 + 144 * v4;
      uint64_t v12 = a1[4];
      uint64_t v13 = 144 * v9;
      do
      {
        uint64_t v14 = v10 + v13;
        uint64_t v15 = v12 + v13;
        long long v16 = *(_OWORD *)(v10 + v13);
        long long v17 = *(_OWORD *)(v10 + v13 + 32);
        *(_OWORD *)(v15 + 16) = *(_OWORD *)(v10 + v13 + 16);
        *(_OWORD *)(v15 + 32) = v17;
        *(_OWORD *)uint64_t v15 = v16;
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13 + 48, (uint64_t *)(v10 + v13 + 48));
        uint64_t result = re::DynamicArray<float>::DynamicArray(v12 + v13 + 88, (uint64_t *)(v10 + v13 + 88));
        *(void *)(v15 + 128) = *(void *)(v10 + v13 + 128);
        v10 += 144;
        v12 += 144;
      }
      while (v14 + 144 != v11);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * v4, a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = 144 * v6 - 144 * v4;
      uint64_t v8 = a1[4] + 144 * v4 + 48;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v8 + 40);
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v8);
        v8 += 144;
        v7 -= 144;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      long long v6 = *(_OWORD *)v5;
      long long v7 = *(_OWORD *)(v5 + 32);
      *(_OWORD *)(a3 + 16) = *(_OWORD *)(v5 + 16);
      *(_OWORD *)(a3 + 32) = v7;
      *(_OWORD *)a3 = v6;
      re::DynamicArray<unsigned long>::operator=(a3 + 48, (uint64_t *)(v5 + 48));
      uint64_t result = re::DynamicArray<float>::operator=(a3 + 88, (uint64_t *)(v5 + 88));
      *(void *)(a3 + 128) = *(void *)(v5 + 128);
      v5 += 144;
      a3 += 144;
    }
    while (v5 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigNodeChannel>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, *(void *)(a2 + 16));
    uint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (void)v5);
      uint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 16 * (void)v5, (const void *)(*(void *)(a2 + 32) + 16 * (void)v5), 16 * v4 - 16 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::Vector3<float>>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4) {
        re::DynamicArray<re::Quaternion<float>>::copy((void **)a1, (uint64_t)a2);
      }
      else {
        *(void *)(a1 + 16) = 0;
      }
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::Quaternion<float>>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<re::Matrix3x3<float>>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 48 * (void)v5);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 48 * (void)v5, (const void *)(*(void *)(a2 + 32) + 48 * (void)v5), 48 * v4 - 48 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 48 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::Matrix4x4<float>>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Matrix4x4<float>>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), (void)v5 << 6);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 64 * (void)v5, (const void *)(*(void *)(a2 + 32) + ((void)v5 << 6)), (v4 << 6) - ((void)v5 << 6));
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), v4 << 6);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::Quaternion<float>>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Quaternion<float>>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (void)v5);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 16 * (void)v5, (const void *)(*(void *)(a2 + 32) + 16 * (void)v5), 16 * v4 - 16 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::RigExpression>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 24 * (void)v5);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 24 * (void)v5, (const void *)(*(void *)(a2 + 32) + 24 * (void)v5), 24 * v4 - 24 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 24 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::RigTwoBoneIKHandles>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 240 * a1[2]), a1[4]);
    uint64_t v10 = a1[2];
    if (v10 != v4)
    {
      uint64_t v11 = *(void *)(a2 + 32);
      uint64_t v12 = a1[4];
      uint64_t v13 = 240 * v10;
      uint64_t v14 = 240 * v4;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13, (uint64_t *)(v11 + v13));
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13 + 40, (uint64_t *)(v11 + v13 + 40));
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13 + 80, (uint64_t *)(v11 + v13 + 80));
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13 + 120, (uint64_t *)(v11 + v13 + 120));
        re::DynamicArray<float>::DynamicArray(v12 + v13 + 160, (uint64_t *)(v11 + v13 + 160));
        uint64_t result = re::DynamicArray<float>::DynamicArray(v12 + v13 + 200, (uint64_t *)(v11 + v13 + 200));
        v14 -= 240;
        v11 += 240;
        v12 += 240;
      }
      while (v13 != v14);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 240 * v4), a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = a1[4];
      uint64_t v8 = 240 * v4;
      uint64_t v9 = 240 * v6;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v7 + v8 + 200);
        re::DynamicArray<unsigned long>::deinit(v7 + v8 + 160);
        re::DynamicArray<unsigned long>::deinit(v7 + v8 + 120);
        re::DynamicArray<unsigned long>::deinit(v7 + v8 + 80);
        re::DynamicArray<unsigned long>::deinit(v7 + v8 + 40);
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v7 + v8);
        v9 -= 240;
        v7 += 240;
      }
      while (v8 != v9);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v5 = (uint64_t *)result;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, v5);
      re::DynamicArray<unsigned long>::operator=(a3 + 40, v5 + 5);
      re::DynamicArray<unsigned long>::operator=(a3 + 80, v5 + 10);
      re::DynamicArray<unsigned long>::operator=(a3 + 120, v5 + 15);
      re::DynamicArray<float>::operator=(a3 + 160, v5 + 20);
      uint64_t result = re::DynamicArray<float>::operator=(a3 + 200, v5 + 25);
      v5 += 30;
      a3 += 240;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigSingleChainIKHandles>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + (a1[2] << 7), a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = v8 << 7;
      uint64_t v12 = v4 << 7;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v10 + v11, (uint64_t *)(v9 + v11));
        re::DynamicArray<unsigned long>::DynamicArray(v10 + v11 + 40, (uint64_t *)(v9 + v11 + 40));
        re::DynamicArray<unsigned long>::DynamicArray(v10 + v11 + 80, (uint64_t *)(v9 + v11 + 80));
        *(_DWORD *)(v10 + v11 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = *(_DWORD *)(v9 + v11 + 120);
        v12 -= 128;
        v9 += 128;
        v10 += 128;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + (v4 << 7), a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4] + (v4 << 7);
      uint64_t v7 = (v5 << 7) - (v4 << 7);
      do
      {
        re::DynamicArray<unsigned long>::deinit(v6 + 80);
        re::DynamicArray<unsigned long>::deinit(v6 + 40);
        re::DynamicArray<unsigned long>::deinit(v6);
        v6 += 128;
        v7 -= 128;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

float std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, (uint64_t *)v5);
      re::DynamicArray<unsigned long>::operator=(a3 + 40, (uint64_t *)(v5 + 40));
      re::DynamicArray<unsigned long>::operator=(a3 + 80, (uint64_t *)(v5 + 80));
      float result = *(float *)(v5 + 120);
      *(float *)(a3 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = result;
      v5 += 128;
      a3 += 128;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigSplineIKHandle>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigSplineIKHandle>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 240 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 240 * v8;
      uint64_t v12 = 240 * v4;
      do
      {
        uint64_t v13 = v10 + v11;
        uint64_t v14 = v9 + v11;
        *(_DWORD *)uint64_t v13 = *(_DWORD *)(v9 + v11);
        *(void *)(v10 + v11 + 8) = 0;
        *(void *)(v13 + 16) = 0;
        *(void *)(v13 + 24) = 0;
        *(_DWORD *)(v13 + 32) = 0;
        uint64_t v15 = *(void *)(v9 + v11 + 8);
        *(void *)(v13 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
        if (v15)
        {
          unint64_t v16 = *(void *)(v14 + 24);
          *(void *)(v10 + v11 + 8) = v15;
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)(v10 + v11 + 8), v16);
          ++*(_DWORD *)(v13 + 32);
          re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(v10 + v11 + 8), v9 + v11 + 8);
        }
        *(void *)(v13 + 48) = 0;
        uint64_t v17 = v13 + 48;
        *(void *)(v17 + 8) = 0;
        *(void *)(v17 + 16) = 0;
        *(_DWORD *)(v17 + 24) = 0;
        uint64_t v20 = *(void *)(v14 + 48);
        uint64_t v19 = v14 + 48;
        uint64_t v18 = v20;
        *(void *)(v17 + 32) = 0;
        if (v20)
        {
          unint64_t v21 = *(void *)(v9 + v11 + 64);
          *(void *)uint64_t v17 = v18;
          re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)v17, v21);
          ++*(_DWORD *)(v10 + v11 + 72);
          re::DynamicArray<re::RigSplineIKControlPoint>::copy(v17, v19);
        }
        uint64_t v22 = v10 + v11;
        re::DynamicArray<float>::DynamicArray(v10 + v11 + 88, (uint64_t *)(v9 + v11 + 88));
        long long v23 = *(_OWORD *)(v9 + v11 + 128);
        long long v24 = *(_OWORD *)(v9 + v11 + 160);
        *(_OWORD *)(v22 + 144) = *(_OWORD *)(v9 + v11 + 144);
        *(_OWORD *)(v22 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v24;
        *(_OWORD *)(v22 + 128) = v23;
        long long v25 = *(_OWORD *)(v9 + v11 + 176);
        long long v26 = *(_OWORD *)(v9 + v11 + 192);
        long long v27 = *(_OWORD *)(v9 + v11 + 208);
        *(_DWORD *)(v22 + 224) = *(_DWORD *)(v9 + v11 + 224);
        *(_OWORD *)(v22 + 192) = v26;
        *(_OWORD *)(v22 + 208) = v27;
        *(_OWORD *)(v22 + 176) = v25;
        v9 += 240;
        v10 += 240;
        v12 -= 240;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 240 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = -240 * v4 + 240 * v5;
      uint64_t v7 = 240 * v4 + a1[4] + 88;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v7);
        re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v7 - 40);
        re::DynamicArray<unsigned long>::deinit(v7 - 80);
        v7 += 240;
        v6 -= 240;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

__n128 std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a1 + v6;
      uint64_t v8 = a3 + v6;
      *(_DWORD *)(a3 + v6) = *(_DWORD *)(a1 + v6);
      uint64_t v9 = (void *)(a3 + v6 + 8);
      if (a3 != a1)
      {
        uint64_t v10 = *(void *)(a1 + v6 + 8);
        if (*v9)
        {
          if (v10)
          {
            re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(a3 + v6 + 8), a1 + v6 + 8);
            uint64_t v11 = a3 + v6;
          }
          else
          {
            uint64_t v11 = a3 + v6;
            *(void *)(a3 + v6 + 24) = 0;
          }
          ++*(_DWORD *)(v11 + 32);
        }
        else if (v10)
        {
          unint64_t v12 = *(void *)(a1 + v6 + 24);
          *uint64_t v9 = v10;
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)(a3 + v6 + 8), v12);
          ++*(_DWORD *)(a3 + v6 + 32);
          re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(a3 + v6 + 8), a1 + v6 + 8);
        }
        uint64_t v13 = *(void *)(a1 + v6 + 48);
        if (*(void *)(a3 + v6 + 48))
        {
          uint64_t v14 = a3 + v6 + 48;
          if (v13)
          {
            re::DynamicArray<re::RigSplineIKControlPoint>::copy(v14, a1 + v6 + 48);
            ++*(_DWORD *)(a3 + v6 + 72);
          }
          else
          {
            re::DynamicArray<re::RigSplineIKControlPoint>::clear(v14);
          }
        }
        else if (v13)
        {
          unint64_t v15 = *(void *)(a1 + v6 + 64);
          *(void *)(a3 + v6 + 48) = v13;
          re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)(a3 + v6 + 48), v15);
          ++*(_DWORD *)(a3 + v6 + 72);
          re::DynamicArray<re::RigSplineIKControlPoint>::copy(a3 + v6 + 48, a1 + v6 + 48);
        }
      }
      re::DynamicArray<float>::operator=(v8 + 88, (uint64_t *)(v7 + 88));
      long long v17 = *(_OWORD *)(v7 + 144);
      long long v16 = *(_OWORD *)(v7 + 160);
      *(_OWORD *)(v8 + 128) = *(_OWORD *)(v7 + 128);
      *(_OWORD *)(v8 + 144) = v17;
      *(_OWORD *)(v8 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v16;
      long long v19 = *(_OWORD *)(v7 + 192);
      __n128 result = *(__n128 *)(v7 + 208);
      long long v20 = *(_OWORD *)(v7 + 176);
      *(_DWORD *)(v8 + 224) = *(_DWORD *)(v7 + 224);
      *(_OWORD *)(v8 + 192) = v19;
      *(__n128 *)(v8 + 208) = result;
      *(_OWORD *)(v8 + 176) = v20;
      v6 += 240;
    }
    while (v7 + 240 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigSplineIKJoint>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, *(void *)(a2 + 16));
    uint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 80 * (void)v5);
      uint64_t v5 = v3[2];
    }
    __n128 result = (void **)memcpy((char *)v3[4] + 80 * (void)v5, (const void *)(*(void *)(a2 + 32) + 80 * (void)v5), 80 * v4 - 80 * (void)v5);
  }
  else if (v4)
  {
    __n128 result = (void **)memmove(result[4], *(const void **)(a2 + 32), 80 * v4);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void re::DynamicArray<re::RigSplineIKControlPoint>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((void *)a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>(*(__n128 **)(a2 + 32), (__n128 *)(*(void *)(a2 + 32) + 96 * *(void *)(a1 + 16)), *(__n128 **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = 96 * v8;
      uint64_t v12 = 96 * v4;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v10 + v11, (uint64_t *)(v9 + v11));
        re::DynamicArray<float>::DynamicArray(v10 + v11 + 40, (uint64_t *)(v9 + v11 + 40));
        *(_OWORD *)(v10 + v11 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(_OWORD *)(v9 + v11 + 80);
        v12 -= 96;
        v9 += 96;
        v10 += 96;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>(*(__n128 **)(a2 + 32), (__n128 *)(*(void *)(a2 + 32) + 96 * v4), *(__n128 **)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 32) + 96 * v4;
      uint64_t v7 = 96 * v5 - 96 * v4;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v6 + 40);
        re::DynamicArray<unsigned long>::deinit(v6);
        v6 += 96;
        v7 -= 96;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
}

__n128 std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      re::DynamicArray<unsigned long>::operator=((uint64_t)a3, (uint64_t *)v5);
      re::DynamicArray<float>::operator=((uint64_t)&a3[2].n128_i64[1], &v5[2].n128_i64[1]);
      __n128 result = v5[5];
      a3[5] = result;
      v5 += 6;
      a3 += 6;
    }
    while (v5 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigTransform>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigTransform>::setCapacity(result, *(void *)(a2 + 16));
    uint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), ((void)v5 << 6) - 15);
      uint64_t v5 = v3[2];
    }
    __n128 result = (void **)memcpy((char *)v3[4] + 64 * (void)v5, (const void *)(*(void *)(a2 + 32) + ((void)v5 << 6)), (v4 << 6) - ((void)v5 << 6));
  }
  else if (v4)
  {
    __n128 result = (void **)memmove(result[4], *(const void **)(a2 + 32), (v4 << 6) - 15);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::RigJoint>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigJoint>::setCapacity(result, *(void *)(a2 + 16));
    uint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 96 * (void)v5 - 15);
      uint64_t v5 = v3[2];
    }
    __n128 result = (void **)memcpy((char *)v3[4] + 96 * (void)v5, (const void *)(*(void *)(a2 + 32) + 96 * (void)v5), 96 * v4 - 96 * (void)v5);
  }
  else if (v4)
  {
    __n128 result = (void **)memmove(result[4], *(const void **)(a2 + 32), 96 * v4 - 15);
  }
  uint64_t v3[2] = (void *)v4;
  return result;
}

void re::DynamicArray<re::RigNode>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigNode>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 56 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = 56 * v8;
      uint64_t v10 = *(void *)(a2 + 32) + v9;
      uint64_t v11 = (re::StringID *)(a1[4] + v9);
      uint64_t v12 = 56 * v4 - v9;
      do
      {
        uint64_t v13 = re::StringID::StringID(v11, (const StringID *)v10);
        long long v14 = *(_OWORD *)(v10 + 16);
        long long v15 = *(_OWORD *)(v10 + 32);
        *((void *)v13 + 6) = *(void *)(v10 + 48);
        *((_OWORD *)v13 + 1) = v14;
        *((_OWORD *)v13 + 2) = v15;
        v10 += 56;
        uint64_t v11 = (re::StringID *)((char *)v13 + 56);
        v12 -= 56;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 56 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(a1[4] + 56 * v4);
      uint64_t v7 = -56 * v4 + 56 * v5;
      do
      {
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 56);
        v7 -= 56;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      __n128 result = *(__n128 *)(v5 + 16);
      long long v7 = *(_OWORD *)(v5 + 32);
      *(void *)(a3 + 48) = *(void *)(v5 + 48);
      *(__n128 *)(a3 + 16) = result;
      *(_OWORD *)(a3 + 32) = v7;
      v5 += 56;
      a3 += 56;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigPose>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::RigPose>::setCapacity((void *)a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(*(__n128 **)(a2 + 32), (__n128 *)(*(void *)(a2 + 32) + 32 * *(void *)(a1 + 16)), *(__n128 **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32) + 32 * v8;
      uint64_t v10 = (re::StringID *)(*(void *)(a1 + 32) + 32 * v8);
      uint64_t v11 = 32 * v4 - 32 * v8;
      do
      {
        uint64_t v12 = re::StringID::StringID(v10, (const StringID *)v9);
        *((_OWORD *)v12 + 1) = *(_OWORD *)(v9 + 16);
        v9 += 32;
        uint64_t v10 = (re::StringID *)((char *)v12 + 32);
        v11 -= 32;
      }
      while (v11);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(*(__n128 **)(a2 + 32), (__n128 *)(*(void *)(a2 + 32) + 32 * v4), *(__n128 **)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(*(void *)(a1 + 32) + 32 * v4);
      uint64_t v7 = 32 * v5 - 32 * v4;
      do
      {
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 32);
        v7 -= 32;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      re::StringID::operator=(a3->n128_u64, (uint64_t *)v5);
      __n128 result = v5[1];
      a3[1] = result;
      v5 += 2;
      a3 += 2;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)a2;
    if (*(void *)result) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4 || v2 == v3)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)__n128 result = v3;
      *(void *)(result + 8) = v7;
      *(void *)a2 = v2;
      *(void *)(a2 + 8) = v6;
      uint64_t v8 = *(void *)(result + 16);
      *(void *)(result + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v8;
      uint64_t v9 = *(void *)(result + 32);
      *(void *)(result + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      __n128 result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

void *re::FixedArray<re::FixedArray<float>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      BOOL v4 = (uint64_t *)result[2];
      uint64_t v5 = 24 * v2;
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v4);
        v4 += 3;
        v5 -= 24;
      }
      while (v5);
      __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      void *v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::FixedArray<re::FixedArray<float>>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 == a2) {
    return (uint64_t)a1;
  }
  uint64_t v4 = *a2;
  if (*a1)
  {
    if (!v4) {
      return (uint64_t)a1;
    }
  }
  else
  {
    if (!v4) {
      return (uint64_t)a1;
    }
    re::FixedArray<re::FixedArray<float>>::init<>(a1, v4, a2[1]);
  }
  uint64_t v5 = a2[1];
  if (a1[1] == v5)
  {
    if (v5)
    {
      uint64_t v6 = a2[2];
      uint64_t v7 = (uint64_t *)a1[2];
      uint64_t v8 = 24 * v5;
      do
      {
        re::FixedArray<float>::operator=(v7, v6);
        v6 += 24;
        v7 += 3;
        v8 -= 24;
      }
      while (v8);
    }
    return (uint64_t)a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::TwoBoneIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a2;
  if (*(void *)a1)
  {
    if (!v4) {
      return a1;
    }
  }
  else
  {
    if (!v4) {
      return a1;
    }
    re::FixedArray<re::TwoBoneIKOptions>::init<>((uint64_t *)a1, v4, *(void *)(a2 + 8));
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) == v5)
  {
    if (v5) {
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 32 * v5);
    }
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::FABRIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a2;
  if (*(void *)a1)
  {
    if (!v4) {
      return a1;
    }
  }
  else
  {
    if (!v4) {
      return a1;
    }
    re::FixedArray<re::FABRIKOptions>::init<>((void *)a1, v4, *(void *)(a2 + 8));
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) == v5)
  {
    if (v5) {
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 8 * v5);
    }
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::SplineIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a2;
  if (*(void *)a1)
  {
    if (!v4) {
      return a1;
    }
  }
  else
  {
    if (!v4) {
      return a1;
    }
    re::FixedArray<re::SplineIKOptions>::init<>(a1, v4, *(void *)(a2 + 8));
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) == v5)
  {
    if (v5) {
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 80 * v5 - 12);
    }
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::FixedArray<unsigned long>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<unsigned long>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<unsigned long>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<re::Vector3<float>>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::Vector3<float>>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::Vector3<float>>::copy(a1, a2);
    }
  }
  return a1;
}

void *re::FixedArray<re::Vector3<float>>::copy(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      uint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 16 * v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::Matrix4x4<float>>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::Matrix4x4<float>>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::Matrix4x4<float>>::copy(a1, a2);
    }
  }
  return a1;
}

void *re::FixedArray<re::Matrix4x4<float>>::copy(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      uint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, v2 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<unsigned long>::operator=(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = *a2;
    if (*result) {
      BOOL v4 = v2 == v3;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      *uint64_t result = v3;
      *a2 = v2;
      uint64_t v5 = result[1];
      uint64_t v6 = result[2];
      uint64_t v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      uint64_t result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::EvaluationContextManager::bindOutputHandle<re::Matrix4x4<float>>(void *a1, uint64_t a2, uint64_t *a3, char a4)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (!a3[3]) {
    return 0;
  }
  uint64_t v7 = *a3;
  uint64_t v8 = &qword_268772000;
  {
    *(void *)long long v15 = a2;
    uint64_t v8 = &qword_268772000;
    a2 = *(void *)v15;
    if (v14)
    {
      re::introspect<re::Matrix4x4<float>>(void)::info = (_UNKNOWN *)re::introspect_Matrix4x4F(0);
      uint64_t v8 = &qword_268772000;
      a2 = *(void *)v15;
    }
  }
  if (v7 != v8[102]) {
    return 0;
  }
  unint64_t v10 = *(void *)(a2 + 8);
  v19[0] = v10;
  if (v10 >= a1[248])
  {
    re::DynamicArray<re::EvaluationContextManager::BindPointReference>::resize(a1 + 246, v10 + 1);
  }
  else if (*(void *)(a1[250] + 56 * v10 + 24))
  {
    return 0;
  }
  re::DynamicArray<unsigned long>::add(a1 + 291, v19);
  uint64_t v16 = *a3;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v17, a3 + 1);
  char v18 = a4;
  uint64_t v11 = v19[0];
  unint64_t v12 = a1[248];
  if (v12 <= v19[0])
  {
    v19[1] = 0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v28 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v20 = 136315906;
    unint64_t v21 = "operator[]";
    __int16 v22 = 1024;
    int v23 = 789;
    __int16 v24 = 2048;
    uint64_t v25 = v11;
    __int16 v26 = 2048;
    unint64_t v27 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v13 = a1[250] + 56 * v19[0];
  *(void *)uint64_t v13 = v16;
  re::DynamicArray<re::RigDataValue>::operator=(v13 + 8, (uint64_t)v17);
  *(unsigned char *)(v13 + 48) = v18;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v17);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v17);
  return 1;
}

void *re::DynamicArray<re::internal::RigIKCall>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::RigIKCall>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x88uLL))
        {
          uint64_t v2 = 136 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 136 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 136, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 136 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = *(void *)v8;
          v11[1] = 0;
          void v11[2] = 0;
          _OWORD v11[3] = 0;
          unint64_t v12 = (uint64_t *)(v8 + 8);
          v11[1] = *(void *)(v8 + 8);
          *(void *)(v8 + 8) = 0;
          uint64_t v13 = v11[3];
          uint64_t v14 = *(void *)(v8 + 24);
          void v11[2] = *(void *)(v8 + 16);
          _OWORD v11[3] = v14;
          *(void *)(v8 + 16) = 0;
          *(void *)(v8 + 24) = v13;
          void v11[4] = 0;
          uint64_t v11[5] = 0;
          uint64_t v11[6] = 0;
          long long v15 = (uint64_t *)(v8 + 32);
          void v11[4] = *(void *)(v8 + 32);
          *(void *)(v8 + 32) = 0;
          uint64_t v16 = v11[6];
          uint64_t v17 = *(void *)(v8 + 48);
          uint64_t v11[5] = *(void *)(v8 + 40);
          uint64_t v11[6] = v17;
          *(void *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
          *(void *)(v8 + 48) = v16;
          v11[7] = 0;
          unsigned char v11[8] = 0;
          v11[9] = 0;
          char v18 = (uint64_t *)(v8 + 56);
          v11[7] = *(void *)(v8 + 56);
          *(void *)(v8 + 56) = 0;
          uint64_t v19 = v11[9];
          uint64_t v20 = *(void *)(v8 + 72);
          unsigned char v11[8] = *(void *)(v8 + 64);
          v11[9] = v20;
          *(void *)(v8 + 64) = 0;
          *(void *)(v8 + 72) = v19;
          *((_OWORD *)v11 + 5) = *(_OWORD *)(v8 + 80);
          v11[13] = 0;
          v11[14] = 0;
          v11[12] = 0;
          uint64_t v22 = *(void *)(v8 + 96);
          uint64_t v21 = v8 + 96;
          v11[12] = v22;
          *(void *)uint64_t v21 = 0;
          uint64_t v23 = v11[14];
          uint64_t v24 = *(void *)(v21 + 16);
          v11[13] = *(void *)(v21 + 8);
          v11[14] = v24;
          *(void *)(v21 + 8) = 0;
          *(void *)(v21 + 16) = v23;
          *(_OWORD *)(v11 + 15) = *(_OWORD *)(v21 + 24);
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)v21);
          re::FixedArray<CoreIKTransform>::deinit(v18);
          re::FixedArray<CoreIKTransform>::deinit(v15);
          re::FixedArray<CoreIKTransform>::deinit(v12);
          uint64_t v8 = v21 + 40;
          v11 += 17;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

size_t re::RigEvaluation::HashString::operator()(int a1, char *__s)
{
  unint64_t v4[2] = *MEMORY[0x263EF8340];
  size_t result = strlen(__s);
  if (result)
  {
    MurmurHash3_x64_128((uint64_t)__s, result, 0, v4);
    return (v4[1] + (v4[0] << 6) + (v4[0] >> 2) - 0x61C8864680B583E9) ^ v4[0];
  }
  return result;
}

void re::FixedArray<char const*>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 8 * a3;
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 8 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 8);
    uint64_t v8 = (void *)((char *)v8 + v5 - 8);
  }
  void *v8 = 0;
}

void *std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::internal::RigIKCallbackData,std::function<void ()(re::internal::RigIKCallbackData*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::internal::RigIKCallbackData *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::function<void ()(re::internal::RigIKCallbackData *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v8);
  }
  else
  {
    uint64_t v3 = std::__throw_bad_function_call[abi:nn180100]();
    re::convertIntrinsicEulersToQuaternions<float>((uint64_t)v3, v4, v5, v6, v7);
  }
}

void re::convertIntrinsicEulersToQuaternions<float>(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  switch(a3)
  {
    case 0:
      if (!a2) {
        return;
      }
      uint64_t v7 = 0;
      uint64_t v8 = (float *)(a1 + 8);
      uint64_t v9 = (float *)(a4 + 8);
      while (a5 != v7)
      {
        __float2 v10 = __sincosf_stret(*(v8 - 2) * 0.5);
        __float2 v11 = __sincosf_stret(*(v8 - 1) * 0.5);
        float v12 = *v8;
        v8 += 4;
        __float2 v13 = __sincosf_stret(v12 * 0.5);
        *(v9 - 2) = (float)((float)(v10.__cosval * v11.__sinval) * v13.__sinval)
                  + (float)((float)(v10.__sinval * v11.__cosval) * v13.__cosval);
        *(v9 - 1) = (float)((float)(v10.__cosval * v11.__sinval) * v13.__cosval)
                  - (float)((float)(v10.__sinval * v11.__cosval) * v13.__sinval);
        *uint64_t v9 = (float)((float)(v10.__sinval * v11.__sinval) * v13.__cosval)
            + (float)((float)(v10.__cosval * v11.__cosval) * v13.__sinval);
        v9[1] = (float)((float)(v10.__cosval * v11.__cosval) * v13.__cosval)
              - (float)((float)(v10.__sinval * v11.__sinval) * v13.__sinval);
        v9 += 4;
        if (a2 == ++v7) {
          return;
        }
      }
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_33;
    case 1:
      if (!a2) {
        return;
      }
      uint64_t v14 = 0;
      long long v15 = (float *)(a1 + 8);
      uint64_t v16 = (float *)(a4 + 8);
      while (a5 != v14)
      {
        __float2 v17 = __sincosf_stret(*(v15 - 2) * 0.5);
        __float2 v18 = __sincosf_stret(*(v15 - 1) * 0.5);
        float v19 = *v15;
        v15 += 4;
        __float2 v20 = __sincosf_stret(v19 * 0.5);
        *(v16 - 2) = (float)((float)(v17.__cosval * v18.__sinval) * v20.__sinval)
                   + (float)((float)(v17.__sinval * v18.__cosval) * v20.__cosval);
        *(v16 - 1) = (float)((float)(v17.__sinval * v18.__cosval) * v20.__sinval)
                   + (float)((float)(v17.__cosval * v18.__sinval) * v20.__cosval);
        float v21 = -(float)(v17.__sinval * v18.__sinval);
        *uint64_t v16 = (float)(v20.__cosval * v21) + (float)((float)(v17.__cosval * v18.__cosval) * v20.__sinval);
        v16[1] = (float)(v20.__sinval * v21) + (float)((float)(v17.__cosval * v18.__cosval) * v20.__cosval);
        v16 += 4;
        if (a2 == ++v14) {
          return;
        }
      }
LABEL_33:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_34;
    case 2:
      if (!a2) {
        return;
      }
      uint64_t v22 = 0;
      uint64_t v23 = (float *)(a1 + 8);
      uint64_t v24 = (float *)(a4 + 8);
      while (a5 != v22)
      {
        __float2 v25 = __sincosf_stret(*(v23 - 2) * 0.5);
        __float2 v26 = __sincosf_stret(*(v23 - 1) * 0.5);
        float v27 = *v23;
        v23 += 4;
        __float2 v28 = __sincosf_stret(v27 * 0.5);
        *(v24 - 2) = (float)((float)(v25.__sinval * v26.__cosval) * v28.__cosval)
                   - (float)((float)(v25.__cosval * v26.__sinval) * v28.__sinval);
        *(v24 - 1) = (float)((float)(v25.__sinval * v26.__cosval) * v28.__sinval)
                   + (float)((float)(v25.__cosval * v26.__sinval) * v28.__cosval);
        *uint64_t v24 = (float)((float)(v25.__sinval * v26.__sinval) * v28.__cosval)
             + (float)((float)(v25.__cosval * v26.__cosval) * v28.__sinval);
        v24[1] = (float)((float)(v25.__cosval * v26.__cosval) * v28.__cosval)
               - (float)((float)(v25.__sinval * v26.__sinval) * v28.__sinval);
        v24 += 4;
        if (a2 == ++v22) {
          return;
        }
      }
LABEL_34:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_35;
    case 3:
      if (!a2) {
        return;
      }
      uint64_t v29 = 0;
      long long v30 = (float *)(a1 + 8);
      long long v31 = (float *)(a4 + 8);
      while (a5 != v29)
      {
        __float2 v32 = __sincosf_stret(*(v30 - 2) * 0.5);
        __float2 v33 = __sincosf_stret(*(v30 - 1) * 0.5);
        float v34 = *v30;
        v30 += 4;
        __float2 v35 = __sincosf_stret(v34 * 0.5);
        *(v31 - 2) = (float)((float)(v32.__sinval * v33.__cosval) * v35.__cosval)
                   - (float)((float)(v32.__cosval * v33.__sinval) * v35.__sinval);
        *(v31 - 1) = (float)((float)(v32.__cosval * v33.__sinval) * v35.__cosval)
                   - (float)((float)(v32.__sinval * v33.__cosval) * v35.__sinval);
        *long long v31 = (float)((float)(v32.__sinval * v33.__sinval) * v35.__cosval)
             + (float)((float)(v32.__cosval * v33.__cosval) * v35.__sinval);
        v31[1] = (float)((float)(v32.__sinval * v33.__sinval) * v35.__sinval)
               + (float)((float)(v32.__cosval * v33.__cosval) * v35.__cosval);
        v31 += 4;
        if (a2 == ++v29) {
          return;
        }
      }
LABEL_35:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_36;
    case 4:
      if (!a2) {
        return;
      }
      uint64_t v36 = 0;
      unint64_t v37 = (float *)(a1 + 8);
      uint64_t v38 = (float *)(a4 + 8);
      while (a5 != v36)
      {
        __float2 v39 = __sincosf_stret(*(v37 - 2) * 0.5);
        __float2 v40 = __sincosf_stret(*(v37 - 1) * 0.5);
        float v41 = *v37;
        v37 += 4;
        __float2 v42 = __sincosf_stret(v41 * 0.5);
        *(v38 - 2) = (float)((float)(v39.__cosval * v40.__sinval) * v42.__sinval)
                   + (float)((float)(v39.__sinval * v40.__cosval) * v42.__cosval);
        *(v38 - 1) = (float)((float)(v39.__cosval * v40.__sinval) * v42.__cosval)
                   - (float)((float)(v39.__sinval * v40.__cosval) * v42.__sinval);
        *uint64_t v38 = (float)((float)(v39.__cosval * v40.__cosval) * v42.__sinval)
             - (float)((float)(v39.__sinval * v40.__sinval) * v42.__cosval);
        v38[1] = (float)((float)(v39.__sinval * v40.__sinval) * v42.__sinval)
               + (float)((float)(v39.__cosval * v40.__cosval) * v42.__cosval);
        v38 += 4;
        if (a2 == ++v36) {
          return;
        }
      }
LABEL_36:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_37;
    case 5:
      if (!a2) {
        return;
      }
      uint64_t v43 = 0;
      uint64_t v44 = (float *)(a1 + 8);
      unint64_t v45 = (float *)(a4 + 8);
      do
      {
        if (a5 == v43)
        {
LABEL_37:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
          _os_crash();
          __break(1u);
LABEL_38:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown rotation order", "!\"Unreachable code\"", "convertIntrinsicEulersToQuaternions", 554);
          _os_crash();
          __break(1u);
          JUMPOUT(0x23325E2ECLL);
        }
        __float2 v46 = __sincosf_stret(*(v44 - 2) * 0.5);
        __float2 v47 = __sincosf_stret(*(v44 - 1) * 0.5);
        float v48 = *v44;
        v44 += 4;
        __float2 v49 = __sincosf_stret(v48 * 0.5);
        *(v45 - 2) = (float)((float)(v46.__sinval * v47.__cosval) * v49.__cosval)
                   - (float)((float)(v46.__cosval * v47.__sinval) * v49.__sinval);
        *(v45 - 1) = (float)((float)(v46.__sinval * v47.__cosval) * v49.__sinval)
                   + (float)((float)(v46.__cosval * v47.__sinval) * v49.__cosval);
        *unint64_t v45 = (float)((float)(v46.__cosval * v47.__cosval) * v49.__sinval)
             - (float)((float)(v46.__sinval * v47.__sinval) * v49.__cosval);
        v45[1] = (float)((float)(v46.__sinval * v47.__sinval) * v49.__sinval)
               + (float)((float)(v46.__cosval * v47.__cosval) * v49.__cosval);
        v45 += 4;
        ++v43;
      }
      while (a2 != v43);
      return;
    default:
      goto LABEL_38;
  }
}

void std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::~__func()
{
}

void *std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::__clone(uint64_t a1)
{
  size_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *size_t result = &unk_26E6C37C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C37C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::operator()(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 18);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 15);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 12);
    re::FixedArray<re::FixedArray<float>>::deinit(v2 + 9);
    re::FixedArray<re::FixedArray<float>>::deinit(v2 + 6);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 3);
    re::FixedArray<re::internal::RigIKCall>::deinit(v2);
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::operator=[abi:nn180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::operator=[abi:nn180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::operator=[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *re::types::Ok<re::EvaluationRigState>::Ok(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *a1 = v4;
  std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::__value_func[abi:nn180100]((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  uint64_t v5 = a2[6];
  a1[5] = a2[5];
  a1[6] = v5;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v6 = a1[7];
  a1[7] = a2[7];
  a2[7] = v6;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  uint64_t v7 = a2[9];
  a1[8] = a2[8];
  a1[9] = v7;
  a2[8] = 0;
  a2[9] = 0;
  uint64_t v8 = a1[10];
  a1[10] = a2[10];
  a2[10] = v8;
  re::RigGraphCompilation::RigGraphCompilation((uint64_t)(a1 + 11), (uint64_t)(a2 + 11));
  return a1;
}

uint64_t re::Result<re::EvaluationRigState,re::DetailedError>::Result(uint64_t a1, uint64_t *a2)
{
  *(unsigned char *)a1 = 1;
  uint64_t v4 = *a2;
  *a2 = 0;
  *(void *)(a1 + 8) = v4;
  std::__function::__value_func<void ()(re::internal::RigIKCallbackData *)>::__value_func[abi:nn180100](a1 + 16, (uint64_t)(a2 + 1));
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v5 = a2[6];
  *(void *)(a1 + 48) = a2[5];
  *(void *)(a1 + 56) = v5;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v6 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2[7];
  a2[7] = v6;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  *(void *)(a1 + 88) = 0;
  uint64_t v7 = a2[9];
  *(void *)(a1 + 72) = a2[8];
  *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = v7;
  a2[8] = 0;
  a2[9] = 0;
  uint64_t v8 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = a2[10];
  a2[10] = v8;
  re::RigGraphCompilation::RigGraphCompilation(a1 + 96, (uint64_t)(a2 + 11));
  return a1;
}

void *re::FixedArray<unsigned long>::copy(void *result, const void **a2)
{
  uint64_t v2 = (const void *)result[1];
  if (v2 == a2[1])
  {
    if (v2)
    {
      uint64_t v3 = *a2;
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 8 * (void)v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
    size_t result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

void re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  uint64_t v13 = *(void *)(a1 + 8);
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)uint64_t v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 2);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 32 * v18) = v15;
            *(void *)(*(void *)(a1 + 16) + 32 * v18 + 16) = *v14;
            *(void *)(*(void *)(a1 + 16) + 32 * v18 + 24) = v14[1];
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

double re::makeSkeletalPoseJointBindNode@<D0>(re *this@<X0>, const re::BindPoint *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (!*((void *)this + 3)) {
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)this;
  unint64_t v7 = 0x268771000uLL;
  {
    unint64_t v7 = 0x268771000;
    if (v13)
    {
      re::introspect<re::SkeletalPose>(void)::info = re::internal::getOrCreateInfo((re::internal *)"SkeletalPose", (uint64_t (*)(re::internal *))re::allocInfo_SkeletalPose, (re::IntrospectionBase *(*)(void))re::initInfo_SkeletalPose, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SkeletalPose>, 0);
      unint64_t v7 = 0x268771000;
    }
  }
  if (v6 == *(void *)(v7 + 3872)
    && (uint64_t v8 = re::BindPoint::valueUntyped(this), *(void *)(v8 + 24) > (unint64_t)a2))
  {
    {
      if (v8)
      {
        re::introspect<re::GenericSRT<float>>(void)::info = re::introspect_SRT(0);
      }
    }
    *(void *)a3 = re::introspect<re::GenericSRT<float>>(void)::info;
    *(void *)(a3 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 32) = 0;
    *(void *)(a3 + 8) = 0;
    memset(v14, 0, sizeof(v14));
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a3 + 8), v14);
    double v9 = re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v14);
    uint64_t v10 = *(void *)(a3 + 40) + 32 * *(void *)(a3 + 24);
    *(void *)(v10 - 32) = 0;
                                                      + 32))(v9);
    *unint64_t v11 = &unk_26E6C3898;
    v11[1] = *(void *)this;
    re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(v11 + 2), (uint64_t *)this + 1);
    v11[7] = a2;
    *(void *)(v10 - 16) = v11;
  }
  else
  {
LABEL_7:
    *(void *)(a3 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
    double result = 0.0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 0;
  }
  return result;
}

__n128 re::EvaluationSkeletalPoseInputHandle::set(re::EvaluationSkeletalPoseInputHandle *this, const re::SkeletalPose *a2)
{
  if (*((void *)this + 1))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      if (*((void *)a2 + 3) <= v4)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      long long v5 = (void *)(*((void *)this + 2) + v3);
      uint64_t v6 = *v5;
      unint64_t v7 = v5[1];
      if (*(void *)(*v5 + 2736) <= v7) {
        goto LABEL_8;
      }
      uint64_t v8 = *((void *)a2 + 4) + v2;
      uint64_t v9 = *(void *)(v6 + 2744) + 48 * v7;
      __n128 result = *(__n128 *)v8;
      long long v11 = *(_OWORD *)(v8 + 32);
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v9 + 32) = v11;
      *(__n128 *)uint64_t v9 = result;
      ++v4;
      v3 += 16;
      v2 += 48;
    }
    while (v4 < *((void *)this + 1));
  }
  return result;
}

__n128 re::EvaluationSkeletalPoseOutputHandle::get(re::EvaluationSkeletalPoseOutputHandle *this, re::SkeletalPose *a2)
{
  if (*((void *)this + 1))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      if (*((void *)a2 + 3) <= v4)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      long long v5 = (void *)(*((void *)this + 2) + v3);
      uint64_t v6 = *v5;
      unint64_t v7 = v5[1];
      if (*(void *)(*v5 + 2952) <= v7) {
        goto LABEL_8;
      }
      uint64_t v8 = *((void *)a2 + 4) + v2;
      uint64_t v9 = *(void *)(v6 + 2960) + 48 * v7;
      __n128 result = *(__n128 *)v9;
      long long v11 = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(v8 + 16) = *(_OWORD *)(v9 + 16);
      *(_OWORD *)(v8 + 32) = v11;
      *(__n128 *)uint64_t v8 = result;
      ++v4;
      v3 += 16;
      v2 += 48;
    }
    while (v4 < *((void *)this + 1));
  }
  return result;
}

uint64_t *re::SkeletalPoseJointDefinition::SkeletalPoseJointDefinition(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v8 + 16) = a2;
  *(void *)uint64_t v8 = &unk_26E6C3850;
  *(void *)(v8 + 24) = 0;
  uint64_t v9 = (unint64_t *)(v8 + 24);
  *(void *)(v8 + 32) = "";
  *(_OWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  uint64_t v10 = (unint64_t *)(v8 + 40);
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_DWORD *)(v8 + 168) = 0;
  *(void *)(v8 + 172) = 0x7FFFFFFFLL;
  *(_OWORD *)(v8 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 228) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  long long v11 = (_anonymous_namespace_ *)(v8 + 184);
  *(void *)(v8 + 244) = 0x7FFFFFFFLL;
  re::FixedArray<re::StringID>::init<>((void *)(v8 + 184), a2, *(void *)(a3 + 8));
  re::FixedArray<re::StringID>::operator=(v11, a3);
  re::SkeletalPoseJointDefinition::buildJointNameMap((re::SkeletalPoseJointDefinition *)a1);
  if (a4 && a4[2])
  {
    re::StringID::operator=(v9, a4);
    re::FixedArray<re::StringID>::operator=(v10, (uint64_t)(a4 + 2));
    re::FixedArray<unsigned int>::operator=(a1 + 8, (uint64_t)(a4 + 5));
    re::FixedArray<re::GenericSRT<float>>::operator=(a1 + 11, (uint64_t)(a4 + 8));
    re::FixedArray<re::Matrix4x4<float>>::operator=(a1 + 14, (uint64_t)(a4 + 11));
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)(a1 + 17), (uint64_t)(a4 + 14));
  }
  return a1;
}

uint64_t re::SkeletalPoseJointDefinition::SkeletalPoseJointDefinition(uint64_t a1, void *a2, const StringID *a3)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26E6C3850;
  re::StringID::StringID((re::StringID *)(a1 + 24), a3);
  re::FixedArray<re::StringID>::FixedArray((unint64_t *)(a1 + 40), (uint64_t)&a3[1]);
  re::FixedArray<unsigned int>::FixedArray((uint64_t *)(a1 + 64), (uint64_t)&a3[2].var1);
  re::FixedArray<re::GenericSRT<float>>::FixedArray((void *)(a1 + 88), (uint64_t)&a3[4]);
  re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(a1 + 112), (uint64_t)&a3[5].var1);
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(a1 + 136, (uint64_t)&a3[7]);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = 0;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 184) = *a2;
  *(void *)(a1 + 192) = v6;
  *a2 = 0;
  a2[1] = 0;
  uint64_t v7 = *(void *)(a1 + 200);
  *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 200) = a2[2];
  a2[2] = v7;
  *(_DWORD *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 244) = 0x7FFFFFFFLL;
  re::SkeletalPoseJointDefinition::buildJointNameMap((re::SkeletalPoseJointDefinition *)a1);
  return a1;
}

void re::SkeletalPoseJointDefinition::buildJointNameMap(re::SkeletalPoseJointDefinition *this)
{
  uint64_t v2 = (char *)this + 208;
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 208, *((void *)this + 23), 2 * *((_DWORD *)this + 48));
  *(void *)&v8.var0 = 0;
  if (*((void *)this + 24))
  {
    unint64_t v3 = 0;
    do
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, (StringID *)(*((void *)this + 25) + 16 * v3), &v8);
      unint64_t v3 = *(void *)&v8.var0 + 1;
      *(void *)&v8.var0 = v3;
      unint64_t v4 = *((void *)this + 24);
    }
    while (v3 < v4);
    unint64_t v9 = 0;
    if (v4)
    {
      for (i = 0; i < v4; unint64_t v9 = i)
      {
        uint64_t v6 = strrchr(*(char **)(*((void *)this + 25) + 16 * i + 8), 47);
        if (v6)
        {
          uint64_t v7 = v6 + 1;
          *(void *)&v8.var0 = 0;
          v8.var1 = "";
          re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, &v8, &v9);
          re::StringID::destroyString((re::StringID *)&v8);
          unint64_t i = v9;
          unint64_t v4 = *((void *)this + 24);
        }
        ++i;
      }
    }
  }
}

void re::EvaluationSkeletalPose::createInputHandle(re::EvaluationSkeletalPose *this@<X0>, re::EvaluationContextManager *a2@<X1>, void *a3@<X8>)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  a3[2] = 0;
  unint64_t v6 = *((void *)this + 1);
  a3[1] = v6;
  if (v6)
  {
    if (v6 >> 60)
    {
LABEL_14:
      re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v6);
      _os_crash();
      __break(1u);
LABEL_15:
      re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    uint64_t v8 = 2 * v6;
    a3[2] = v9;
    if (!v9) {
      goto LABEL_15;
    }
    long long v11 = v9;
    int v12 = v9;
    if (v6 != 1)
    {
      bzero(v9, v8 * 8 - 16);
      int v12 = &v11[v8 - 2];
    }
    *int v12 = 0;
    v12[1] = 0;
  }
  else
  {
    long long v11 = 0;
  }
  if (*((void *)this + 1))
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    for (unint64_t i = v11 + 1; ; i += 2)
    {
      unint64_t v16 = (__n128 *)(*((void *)this + 2) + v13);
      v18[0] = 0x3F8000003F800000;
      v18[1] = 1065353216;
      _OWORD v18[2] = 0;
      v18[3] = 0x3F80000000000000;
      v18[4] = 0;
      v18[5] = 0;
      re::DynamicArray<re::EvaluationSRT>::add((re::EvaluationContextManager *)((char *)a2 + 328), v16);
      re::DynamicArray<re::Matrix3x3<float>>::add((re::EvaluationContextManager *)((char *)a2 + 688), (uint64_t)v18);
      if (v6 == v14) {
        break;
      }
      uint64_t v17 = *((void *)a2 + 43) - 1;
      *(i - 1) = (uint64_t)a2;
      *unint64_t i = v17;
      ++v14;
      v13 += 24;
      if (v14 >= *((void *)this + 1)) {
        return;
      }
    }
    v18[7] = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v27 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v19 = 136315906;
    uint64_t v20 = "operator[]";
    __int16 v21 = 1024;
    int v22 = 468;
    __int16 v23 = 2048;
    unint64_t v24 = v6;
    __int16 v25 = 2048;
    unint64_t v26 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
}

void re::EvaluationSkeletalPose::createOutputHandle(re::EvaluationSkeletalPose *this@<X0>, re::EvaluationContextManager *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t v6 = *((void *)this + 1);
  if (*((void *)this + 1))
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      re::DynamicArray<re::EvaluationSRT>::add((re::EvaluationContextManager *)((char *)a2 + 1768), (__n128 *)(*((void *)this + 2) + v7));
      if (a3[1] <= v9)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = *((void *)a2 + 223) - 1;
      long long v11 = (void *)(a3[2] + v8);
      *long long v11 = a2;
      v11[1] = v10;
      ++v9;
      v8 += 16;
      v7 += 24;
    }
    while (v9 < *((void *)this + 1));
  }
}

uint64_t re::SkeletalPose::SkeletalPose(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  re::FixedArray<re::GenericSRT<float>>::init<>((void *)(a1 + 16), a2, *(void *)(*a3 + 192));
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(a1 + 80), *a3);
  return a1;
}

void re::SkeletalPose::init(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 10, v4);
}

void re::SkeletalPose::deinit(re::SkeletalPose *this)
{
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 2);
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {

    *((void *)this + 10) = 0;
  }
}

void re::SkeletalPose::reset(void *a1, uint64_t *a2)
{
  unint64_t v3 = a1 + 10;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 10, *a2);
  if (a1[3] != *(void *)(a1[10] + 192))
  {
    uint64_t v7 = (uint64_t *)a1[2];
    long long v5 = a1 + 2;
    unint64_t v6 = v7;
    if (!v7)
    {
    }
    re::FixedArray<CoreIKTransform>::deinit(v5);
    unint64_t v8 = *(void *)(*v3 + 192);
    re::FixedArray<re::GenericSRT<float>>::init<>(v5, (uint64_t)v6, v8);
  }
}

void *re::allocInfo_SkeletalPose(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_20))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73D38, "SkeletalPose");
    __cxa_guard_release(&_MergedGlobals_20);
  }
  return &unk_26AF73D38;
}

void re::initInfo_SkeletalPose(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x3D0B75488F9EC5D4;
  v17[1] = "SkeletalPose";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73D18, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF73D18);
    if (v4)
    {
      long long v5 = re::introspectionAllocator(v4);
      unint64_t v6 = re::IntrospectionInfo<re::FixedArray<re::GenericSRT<float>>>::get(1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "jointTransforms";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0x1000000001;
      *(_DWORD *)(v7 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF73D20 = v7;
      unint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "poseMask";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x2800000002;
      *(_DWORD *)(v11 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF73D28 = v11;
      int v12 = re::introspectionAllocator((re *)v11);
      unint64_t v14 = re::IntrospectionInfo<re::StringID>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "name";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 3;
      *(_DWORD *)(v15 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF73D30 = v15;
      __cxa_guard_release(&qword_26AF73D18);
    }
  }
  *((void *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF73D20;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::SkeletalPose>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::SkeletalPose>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::SkeletalPose>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::SkeletalPose>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info = (uint64_t)&unk_26E6C3968;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  unint64_t v6 = (re *)re::introspect_BOOL((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info, 0);
    qword_268772350 = 0x2800000003;
    dword_268772358 = v10;
    word_26877235C = 0;
    *(void *)&xmmword_268772360 = 0;
    *((void *)&xmmword_268772360 + 1) = 0xFFFFFFFFLL;
    qword_268772370 = v9;
    unk_268772378 = 0;
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info = (uint64_t)&unk_26E6C3968;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      uint64_t v13 = v16;
    }
    else {
      uint64_t v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_268772360 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::SkeletalPose>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = "";
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(void *)(a3 + 72) = 0;
  *(void *)(a3 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  return result;
}

void re::internal::defaultDestruct<re::SkeletalPose>(int a1, int a2, re::SkeletalPose *this)
{
}

double re::internal::defaultConstructV2<re::SkeletalPose>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = "";
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  return result;
}

uint64_t re::introspect_SkeletalPose(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SkeletalPose", (uint64_t (*)(re::internal *))re::allocInfo_SkeletalPose, (re::IntrospectionBase *(*)(void))re::initInfo_SkeletalPose, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SkeletalPose>, this);
}

void *re::AnimationValueTraits<re::SkeletalPose>::copy(void *result, void *a2)
{
  int v3 = result;
  uint64_t v4 = result[10];
  if (v4 == a2[10])
  {
    return re::FixedArray<re::GenericSRT<float>>::operator=(a2 + 2, (uint64_t)(result + 2));
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 192);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      while (1)
      {
        uint64_t v9 = v3[10];
        if (*(void *)(v9 + 192) <= v8) {
          break;
        }
        double result = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, (void *)(*(void *)(v9 + 200) + v6));
        if (result)
        {
          if (v3[3] <= v8) {
            goto LABEL_15;
          }
          if (a2[3] <= *result) {
            goto LABEL_16;
          }
          int v10 = (long long *)(v3[4] + v7);
          uint64_t v11 = (_OWORD *)(a2[4] + 48 * *result);
          long long v12 = *v10;
          long long v13 = v10[2];
          v11[1] = v10[1];
          void v11[2] = v13;
          *uint64_t v11 = v12;
        }
        ++v8;
        v7 += 48;
        v6 += 16;
        if (v5 == v8) {
          return result;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_15:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_16:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return result;
}

void re::AnimationValueTraits<re::SkeletalPose>::combine(void *a1, void *a2, void *a3)
{
  unint64_t v8 = a1;
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v9 = a1[10];
  if (v9 == a2[10])
  {
    long long v13 = *(void **)(v9 + 192);
    if (v9 == a3[10])
    {
      if (v13)
      {
        uint64_t v32 = 0;
        unint64_t v15 = 0;
        while (1)
        {
          unint64_t v12 = v8[3];
          if (v12 <= v15) {
            break;
          }
          unint64_t v12 = a2[3];
          if (v12 <= v15) {
            goto LABEL_63;
          }
          unint64_t v12 = a3[3];
          if (v12 <= v15) {
            goto LABEL_64;
          }
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v32), (float32x4_t *)(a2[4] + v32), (float32x4_t *)(a3[4] + v32));
          ++v15;
          v32 += 48;
          if (v13 == (void *)v15) {
            return;
          }
        }
LABEL_62:
        uint64_t v33 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v37 = 136315906;
        uint64_t v38 = "operator[]";
        __int16 v39 = 1024;
        int v40 = 476;
        __int16 v41 = 2048;
        __float2 v42 = (void *)v15;
        __int16 v43 = 2048;
        unint64_t v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        uint64_t v33 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v37 = 136315906;
        uint64_t v38 = "operator[]";
        __int16 v39 = 1024;
        int v40 = 476;
        __int16 v41 = 2048;
        __float2 v42 = (void *)v15;
        __int16 v43 = 2048;
        unint64_t v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_64:
        uint64_t v33 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v37 = 136315906;
        uint64_t v38 = "operator[]";
        __int16 v39 = 1024;
        int v40 = 468;
        __int16 v41 = 2048;
        __float2 v42 = (void *)v15;
        __int16 v43 = 2048;
        unint64_t v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else if (v13)
    {
      uint64_t v29 = 0;
      unint64_t v12 = 0;
      unint64_t v15 = 0;
      unint64_t v3 = 48;
      while (1)
      {
        uint64_t v30 = v8[10];
        unint64_t v4 = *(void *)(v30 + 192);
        if (v4 <= v15) {
          goto LABEL_53;
        }
        long long v31 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (void *)(*(void *)(v30 + 200) + v29));
        if (v31)
        {
          unint64_t v4 = v8[3];
          if (v4 <= v15) {
            goto LABEL_55;
          }
          unint64_t v4 = a2[3];
          if (v4 <= v15) {
            goto LABEL_56;
          }
          unint64_t v4 = *v31;
          unint64_t v5 = a3[3];
          if (v5 <= *v31) {
            goto LABEL_57;
          }
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v12), (float32x4_t *)(a2[4] + v12), (float32x4_t *)(a3[4] + 48 * v4));
        }
        ++v15;
        v12 += 48;
        v29 += 16;
        if (v13 == (void *)v15) {
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v10 = *(void *)(a2[10] + 192);
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    uint64_t v11 = *(void **)(v8[10] + 192);
    if (v11)
    {
      unint64_t v12 = 0;
      unint64_t v3 = 0;
      long long v13 = 0;
      unint64_t v5 = 48;
      while (1)
      {
        uint64_t v14 = v8[10];
        unint64_t v15 = *(void *)(v14 + 192);
        if (v15 <= (unint64_t)v13) {
          break;
        }
        long long v16 = (void *)(*(void *)(v14 + 200) + v12);
        uint64_t v17 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, v16);
        if (v17)
        {
          unint64_t v4 = *v17;
          long long v18 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, v16);
          if (v18)
          {
            unint64_t v15 = v8[3];
            if (v15 <= (unint64_t)v13) {
              goto LABEL_49;
            }
            unint64_t v15 = *v18;
            unint64_t v5 = a2[3];
            if (v5 <= *v18) {
              goto LABEL_50;
            }
            unint64_t v5 = a3[3];
            if (v5 <= v4) {
              goto LABEL_51;
            }
            unint64_t v5 = 48;
            re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v3), (float32x4_t *)(a2[4] + 48 * v15), (float32x4_t *)(a3[4] + 48 * v4));
            unint64_t v4 = v34;
            if (v34 <= v15) {
              goto LABEL_52;
            }
            *(unsigned char *)(v35 + v15) = 1;
          }
          else
          {
            unint64_t v15 = v8[3];
            if (v15 <= (unint64_t)v13) {
              goto LABEL_58;
            }
            unint64_t v15 = a3[3];
            if (v15 <= v4) {
              goto LABEL_59;
            }
            int v19 = (long long *)(v8[4] + v3);
            uint64_t v20 = (_OWORD *)(a3[4] + 48 * v4);
            long long v21 = *v19;
            long long v22 = v19[2];
            v20[1] = v19[1];
            double v20[2] = v22;
            *uint64_t v20 = v21;
          }
        }
        long long v13 = (void *)((char *)v13 + 1);
        v3 += 48;
        v12 += 16;
        if (v11 == v13) {
          goto LABEL_16;
        }
      }
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = v13;
      __int16 v43 = 2048;
      unint64_t v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_48;
    }
LABEL_16:
    unint64_t v15 = *(void *)(a2[10] + 192);
    if (v15)
    {
      long long v13 = 0;
      unint64_t v8 = 0;
      while (1)
      {
        unint64_t v12 = v34;
        if (v34 <= (unint64_t)v8) {
          break;
        }
        if (!*((unsigned char *)v8 + v35))
        {
          uint64_t v23 = a2[10];
          unint64_t v12 = *(void *)(v23 + 192);
          if (v12 <= (unint64_t)v8) {
            goto LABEL_54;
          }
          unint64_t v24 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (void *)((char *)v13 + *(void *)(v23 + 200)));
          if (v24)
          {
            unint64_t v12 = a2[3];
            if (v12 <= v15) {
              goto LABEL_60;
            }
            unint64_t v12 = *v24;
            unint64_t v3 = a3[3];
            if (v3 <= *v24) {
              goto LABEL_61;
            }
            __int16 v25 = (long long *)(a2[4] + 48 * v15);
            unint64_t v26 = (_OWORD *)(a3[4] + 48 * v12);
            long long v27 = *v25;
            long long v28 = v25[2];
            v26[1] = v25[1];
            _OWORD v26[2] = v28;
            _OWORD *v26 = v27;
          }
        }
        unint64_t v8 = (void *)((char *)v8 + 1);
        v13 += 2;
        if ((void *)v15 == v8) {
          goto LABEL_26;
        }
      }
LABEL_48:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = v8;
      __int16 v43 = 2048;
      unint64_t v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_49:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = v13;
      __int16 v43 = 2048;
      unint64_t v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_50:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_51:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v4;
      __int16 v43 = 2048;
      unint64_t v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      uint64_t v33 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = v8;
      __int16 v43 = 2048;
      unint64_t v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      uint64_t v33 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_56:
      uint64_t v33 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      uint64_t v33 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v4;
      __int16 v43 = 2048;
      unint64_t v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = v13;
      __int16 v43 = 2048;
      unint64_t v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v4;
      __int16 v43 = 2048;
      unint64_t v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 476;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v15;
      __int16 v43 = 2048;
      unint64_t v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_61:
      uint64_t v36 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v37 = 136315906;
      uint64_t v38 = "operator[]";
      __int16 v39 = 1024;
      int v40 = 468;
      __int16 v41 = 2048;
      __float2 v42 = (void *)v12;
      __int16 v43 = 2048;
      unint64_t v44 = v3;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_62;
    }
LABEL_26:
    if (v33)
    {
      if (v34) {
        (*(void (**)(void))(*(void *)v33 + 40))();
      }
    }
  }
}

void *re::AnimationValueTraits<re::SkeletalPose>::invert(void *result, void *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = result[10];
  uint64_t v5 = *(void *)(v4 + 192);
  if (v4 == a2[10])
  {
    if (v5)
    {
      uint64_t v27 = 0;
      unint64_t v28 = 0;
      __asm { FMOV            V0.4S, #1.0 }
      while (result[3] > v28)
      {
        if (a2[3] <= v28) {
          goto LABEL_21;
        }
        uint64_t v30 = (float32x4_t *)(result[4] + v27);
        uint64_t v31 = a2[4] + v27;
        float32x4_t v32 = v30[1];
        float32x4_t v33 = v30[2];
        float32x4_t v34 = vdivq_f32(_Q0, *v30);
        int32x4_t v35 = (int32x4_t)vnegq_f32(v32);
        float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v35, v35), (int8x16_t)v35, 0xCuLL);
        v35.i32[3] = v32.i32[3];
        float32x4_t v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL), v32), v33, v36);
        int32x4_t v38 = (int32x4_t)vaddq_f32(v37, v37);
        float32x4_t v39 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v38, v38), (int8x16_t)v38, 0xCuLL);
        float32x4_t v40 = vaddq_f32(v33, vmulq_laneq_f32(v39, v32, 3));
        int32x4_t v41 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL), v32), v39, v36);
        *(float32x4_t *)uint64_t v31 = v34;
        *(int32x4_t *)(v31 + 16) = v35;
        *(float32x4_t *)(v31 + 32) = vmulq_f32(vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL)), vnegq_f32(v34));
        ++v28;
        v27 += 48;
        if (v5 == v28) {
          return result;
        }
      }
LABEL_20:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_21:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v42 = _Q0;
    while (1)
    {
      uint64_t v14 = v3[10];
      if (*(void *)(v14 + 192) <= v8) {
        break;
      }
      double result = (void *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, (void *)(*(void *)(v14 + 200) + v6));
      if (result)
      {
        if (v3[3] <= v8) {
          goto LABEL_18;
        }
        if (a2[3] <= *result) {
          goto LABEL_19;
        }
        unint64_t v15 = (float32x4_t *)(v3[4] + v7);
        uint64_t v16 = a2[4] + 48 * *result;
        float32x4_t v17 = v15[1];
        float32x4_t v18 = v15[2];
        float32x4_t v19 = vdivq_f32(v42, *v15);
        int32x4_t v20 = (int32x4_t)vnegq_f32(v17);
        float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL);
        v20.i32[3] = v17.i32[3];
        float32x4_t v22 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v17), v18, v21);
        int32x4_t v23 = (int32x4_t)vaddq_f32(v22, v22);
        float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL);
        float32x4_t v25 = vaddq_f32(v18, vmulq_laneq_f32(v24, v17, 3));
        int32x4_t v26 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), v17), v24, v21);
        *(float32x4_t *)uint64_t v16 = v19;
        *(int32x4_t *)(v16 + 16) = v20;
        *(float32x4_t *)(v16 + 32) = vmulq_f32(vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v26, v26), (int8x16_t)v26, 0xCuLL)), vnegq_f32(v19));
      }
      ++v8;
      v7 += 48;
      v6 += 16;
      if (v5 == v8) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_20;
  }
  return result;
}

void re::AnimationValueTraits<re::SkeletalPose>::interpolate(void *a1, void *a2, void *a3, float a4)
{
  uint64_t v10 = a1;
  uint64_t v62 = *MEMORY[0x263EF8340];
  uint64_t v11 = a1[10];
  if (v11 == a2[10])
  {
    unint64_t v15 = *(void *)(v11 + 192);
    if (v11 == a3[10])
    {
      if (v15)
      {
        uint64_t v40 = 0;
        unint64_t v17 = 0;
        while (1)
        {
          unint64_t v14 = v10[3];
          if (v14 <= v17) {
            break;
          }
          unint64_t v14 = a2[3];
          if (v14 <= v17) {
            goto LABEL_63;
          }
          unint64_t v14 = a3[3];
          if (v14 <= v17) {
            goto LABEL_64;
          }
          int32x4_t v41 = (float32x4_t *)(a3[4] + v40);
          re::lerp<float>((float32x4_t *)(v10[4] + v40), (float32x4_t *)(a2[4] + v40), &v57, a4);
          float32x4_t v42 = v57;
          float32x4_t v43 = v59;
          v41[1] = v58;
          void v41[2] = v43;
          *int32x4_t v41 = v42;
          ++v17;
          v40 += 48;
          if (v15 == v17) {
            return;
          }
        }
LABEL_62:
        *(void *)uint64_t v50 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        float32x4_t v58 = 0u;
        float32x4_t v59 = 0u;
        float32x4_t v57 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v48 = 136315906;
        *(void *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 476;
        *(_WORD *)&v48[18] = 2048;
        *(void *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(void *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        *(void *)uint64_t v50 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        float32x4_t v58 = 0u;
        float32x4_t v59 = 0u;
        float32x4_t v57 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v48 = 136315906;
        *(void *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 476;
        *(_WORD *)&v48[18] = 2048;
        *(void *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(void *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_64:
        *(void *)uint64_t v50 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        float32x4_t v58 = 0u;
        float32x4_t v59 = 0u;
        float32x4_t v57 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v48 = 136315906;
        *(void *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 468;
        *(_WORD *)&v48[18] = 2048;
        *(void *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(void *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else if (v15)
    {
      uint64_t v34 = 0;
      unint64_t v14 = 0;
      unint64_t v17 = 0;
      unint64_t v4 = 48;
      while (1)
      {
        uint64_t v35 = v10[10];
        unint64_t v5 = *(void *)(v35 + 192);
        if (v5 <= v17) {
          goto LABEL_53;
        }
        float32x4_t v36 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (void *)(*(void *)(v35 + 200) + v34));
        if (v36)
        {
          unint64_t v5 = v10[3];
          if (v5 <= v17) {
            goto LABEL_55;
          }
          unint64_t v5 = a2[3];
          if (v5 <= v17) {
            goto LABEL_56;
          }
          unint64_t v5 = *v36;
          unint64_t v6 = a3[3];
          if (v6 <= *v36) {
            goto LABEL_57;
          }
          float32x4_t v37 = (float32x4_t *)(a3[4] + 48 * v5);
          re::lerp<float>((float32x4_t *)(v10[4] + v14), (float32x4_t *)(a2[4] + v14), &v57, a4);
          float32x4_t v38 = v57;
          float32x4_t v39 = v59;
          v37[1] = v58;
          void v37[2] = v39;
          float32x4_t *v37 = v38;
        }
        ++v17;
        v14 += 48;
        v34 += 16;
        if (v15 == v17) {
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a2[10] + 192);
    unint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v44 = 0;
    uint64_t v13 = *(void *)(v10[10] + 192);
    if (v13)
    {
      unint64_t v14 = 0;
      unint64_t v4 = 0;
      unint64_t v15 = 0;
      unint64_t v6 = 48;
      while (1)
      {
        uint64_t v16 = v10[10];
        unint64_t v17 = *(void *)(v16 + 192);
        if (v17 <= v15) {
          break;
        }
        float32x4_t v18 = (void *)(*(void *)(v16 + 200) + v14);
        float32x4_t v19 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, v18);
        if (v19)
        {
          unint64_t v5 = *v19;
          int32x4_t v20 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, v18);
          if (v20)
          {
            unint64_t v17 = v10[3];
            if (v17 <= v15) {
              goto LABEL_49;
            }
            unint64_t v17 = *v20;
            unint64_t v6 = a2[3];
            if (v6 <= *v20) {
              goto LABEL_50;
            }
            unint64_t v6 = a3[3];
            if (v6 <= v5) {
              goto LABEL_51;
            }
            unint64_t v6 = 48;
            float32x4_t v21 = (float32x4_t *)(a3[4] + 48 * v5);
            re::lerp<float>((float32x4_t *)(v10[4] + v4), (float32x4_t *)(a2[4] + 48 * v17), &v57, a4);
            float32x4_t v22 = v57;
            float32x4_t v23 = v59;
            v21[1] = v58;
            _OWORD v21[2] = v23;
            *float32x4_t v21 = v22;
            unint64_t v5 = v45;
            if (v45 <= v17) {
              goto LABEL_52;
            }
            *(unsigned char *)(v46 + v17) = 1;
          }
          else
          {
            unint64_t v17 = v10[3];
            if (v17 <= v15) {
              goto LABEL_58;
            }
            uint64_t v24 = v10[4];
            *(void *)&v48[8] = 1065353216;
            *(void *)&v48[16] = 0;
            *(void *)long long v48 = 0x3F8000003F800000;
            *(void *)&v48[24] = 0x3F80000000000000;
            *(void *)&v48[32] = 0;
            uint64_t v49 = 0;
            unint64_t v17 = a3[3];
            if (v17 <= v5) {
              goto LABEL_59;
            }
            float32x4_t v25 = (float32x4_t *)(a3[4] + 48 * v5);
            re::lerp<float>((float32x4_t *)(v24 + v4), (float32x4_t *)v48, &v57, a4);
            float32x4_t v26 = v57;
            float32x4_t v27 = v59;
            v25[1] = v58;
            void v25[2] = v27;
            *float32x4_t v25 = v26;
          }
        }
        ++v15;
        v4 += 48;
        v14 += 16;
        if (v13 == v15) {
          goto LABEL_16;
        }
      }
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_48;
    }
LABEL_16:
    unint64_t v17 = *(void *)(a2[10] + 192);
    if (v17)
    {
      unint64_t v15 = 0;
      uint64_t v28 = 0;
      uint64_t v10 = 0;
      unint64_t v5 = 0x3F80000000000000;
      unint64_t v6 = 48;
      while (1)
      {
        unint64_t v14 = v45;
        if (v45 <= (unint64_t)v10) {
          break;
        }
        if (!*((unsigned char *)v10 + v46))
        {
          uint64_t v29 = a2[10];
          unint64_t v14 = *(void *)(v29 + 192);
          if (v14 <= (unint64_t)v10) {
            goto LABEL_54;
          }
          uint64_t v30 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (void *)(*(void *)(v29 + 200) + v15));
          if (v30)
          {
            unint64_t v14 = *v30;
            *(void *)&v48[8] = 1065353216;
            *(void *)&v48[16] = 0;
            *(void *)long long v48 = 0x3F8000003F800000;
            *(void *)&v48[24] = 0x3F80000000000000;
            *(void *)&v48[32] = 0;
            uint64_t v49 = 0;
            unint64_t v4 = a2[3];
            if (v4 <= (unint64_t)v10) {
              goto LABEL_60;
            }
            unint64_t v4 = a3[3];
            if (v4 <= v14) {
              goto LABEL_61;
            }
            uint64_t v31 = (float32x4_t *)(a3[4] + 48 * v14);
            re::lerp<float>((float32x4_t *)v48, (float32x4_t *)(a2[4] + v28), &v57, a4);
            float32x4_t v32 = v57;
            float32x4_t v33 = v59;
            v31[1] = v58;
            void v31[2] = v33;
            *uint64_t v31 = v32;
          }
        }
        uint64_t v10 = (void *)((char *)v10 + 1);
        v28 += 48;
        v15 += 16;
        if ((void *)v17 == v10) {
          goto LABEL_26;
        }
      }
LABEL_48:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v10;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_49:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_50:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_51:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v5;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v10;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_56:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v5;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      *(void *)uint64_t v50 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v48 = 136315906;
      *(void *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(void *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(void *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      uint64_t v47 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v50 = 136315906;
      *(void *)&v50[4] = "operator[]";
      __int16 v51 = 1024;
      int v52 = 468;
      __int16 v53 = 2048;
      __int16 v54 = (void *)v5;
      __int16 v55 = 2048;
      unint64_t v56 = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      uint64_t v47 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v50 = 136315906;
      *(void *)&v50[4] = "operator[]";
      __int16 v51 = 1024;
      int v52 = 476;
      __int16 v53 = 2048;
      __int16 v54 = v10;
      __int16 v55 = 2048;
      unint64_t v56 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_61:
      uint64_t v47 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      float32x4_t v58 = 0u;
      float32x4_t v59 = 0u;
      float32x4_t v57 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v50 = 136315906;
      *(void *)&v50[4] = "operator[]";
      __int16 v51 = 1024;
      int v52 = 468;
      __int16 v53 = 2048;
      __int16 v54 = (void *)v14;
      __int16 v55 = 2048;
      unint64_t v56 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_62;
    }
LABEL_26:
    if (v44)
    {
      if (v45) {
        (*(void (**)(void))(*(void *)v44 + 40))();
      }
    }
  }
}

uint64_t re::FixedArray<re::GenericSRT<float>>::slice(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4 + 1 <= a2)
  {
    uint64_t v6 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v7) = 136315906;
    *(void *)((char *)&v7 + 4) = "slice";
    WORD6(v7) = 1024;
    HIWORD(v7) = 502;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (__CFADD__(a2, a3))
  {
LABEL_6:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 508, a2, a3, v4, v6, v7);
    _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 512, a2, a3, v4);
    _os_crash();
    __break(1u);
  }
  if (a2 + a3 > v4) {
    goto LABEL_7;
  }
  return *(void *)(a1 + 16) + 48 * a2;
}

void re::SkeletalPoseJointDefinition::~SkeletalPoseJointDefinition(re::SkeletalPoseJointDefinition *this)
{
  *(void *)this = &unk_26E6C3850;
  uint64_t v2 = (re::SkeletalPoseJointDefinition *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::FixedArray<re::StringID>::deinit((void *)this + 23);
  re::Skeleton::~Skeleton(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::Skeleton *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6C3850;
  uint64_t v2 = (re::SkeletalPoseJointDefinition *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::FixedArray<re::StringID>::deinit((void *)this + 23);
  re::Skeleton::~Skeleton(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

unint64_t *re::FixedArray<re::StringID>::FixedArray(unint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::StringID>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::StringID>::copy(a1, a2);
  }
  return a1;
}

unint64_t *re::FixedArray<re::StringID>::copy(unint64_t *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      unint64_t v3 = *(uint64_t **)(a2 + 16);
      double result = (unint64_t *)result[2];
      uint64_t v4 = 16 * v2;
      do
      {
        unint64_t v5 = re::StringID::operator=(result, v3);
        v3 += 2;
        double result = v5 + 2;
        v4 -= 16;
      }
      while (v4);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    double result = (unint64_t *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<unsigned int>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<int>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<unsigned int>::copy(a1, a2);
  }
  return a1;
}

void *re::FixedArray<unsigned int>::copy(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      unint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 4 * v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    double result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::Matrix4x4<float>>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::Matrix4x4<float>>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::Matrix4x4<float>>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        unint64_t v9 = 0xBF58476D1CE4E5B9 * ((*(void *)(v8 + v6 + 8) >> 31) ^ (*(void *)(v8 + v6 + 8) >> 1));
        unint64_t v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<unsigned int &>(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (_DWORD *)(v8 + v6 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

unint64_t *re::FixedArray<re::StringID>::operator=(unint64_t *a1, uint64_t a2)
{
  if (a1 != (unint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::StringID>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::StringID>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<unsigned int>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<int>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<unsigned int>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::anonymous namespace'::SkeletalPoseJointBindPointImpl::~SkeletalPoseJointBindPointImpl(re::_anonymous_namespace_::SkeletalPoseJointBindPointImpl *this)
{
  uint64_t v1 = (char *)this + 16;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 16);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)this + 16;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 16);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
  JUMPOUT(0x237DBCBD0);
}

const char *re::internal::BindPointImpl<re::anonymous namespace'::SkeletalPoseJointBindPointImpl>::implTypeInfo()
{
  return "@";
}

uint64_t re::internal::BindPointImpl<re::anonymous namespace'::SkeletalPoseJointBindPointImpl>::copyInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26E6C3898;
  a2[1] = v4;
  uint64_t result = re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(a2 + 2), a1 + 2);
  a2[7] = a1[7];
  return result;
}

uint64_t re::internal::BindPointImpl<re::anonymous namespace'::SkeletalPoseJointBindPointImpl>::moveInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26E6C3898;
  a2[1] = v4;
  uint64_t result = re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(a2 + 2), a1 + 2);
  a2[7] = a1[7];
  return result;
}

BOOL re::internal::BindPointImpl<re::anonymous namespace'::SkeletalPoseJointBindPointImpl>::equals(uint64_t a1, void *a2)
{
  if ((char *)(*(uint64_t (**)(void *))(*a2 + 16))(a2) != "@") {
    return 0;
  }
  BOOL result = re::BindPoint::operator==((re::BindPoint *)(a1 + 8), (re::BindPoint *)(a2 + 1));
  if (result) {
    return *(void *)(a1 + 56) == a2[7];
  }
  return result;
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::hash(void *a1)
{
  if (a1[4]) {
    unint64_t v2 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 1));
  }
  else {
    unint64_t v2 = 0;
  }
  return (a1[7] + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::isWeak(uint64_t a1)
{
  return re::BindPoint::isWeak((re::BindPoint *)(a1 + 8));
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::isAlive(uint64_t a1)
{
  return re::BindPoint::isAlive((re::BindPoint *)(a1 + 8));
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::baseValueUntyped(uint64_t a1)
{
  uint64_t result = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 8));
  if (result)
  {
    unint64_t v3 = *(void *)(a1 + 56);
    if (*(void *)(result + 24) <= v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(void *)(result + 32) + 48 * v3;
  }
  return result;
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::supportsOverrideValue(uint64_t a1)
{
  return re::BindPoint::supportsOverrideValue((re::BindPoint *)(a1 + 8));
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::isOverridden(uint64_t a1)
{
  return re::BindPoint::isOverridden((re::BindPoint *)(a1 + 8));
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::setIsOverridden(uint64_t a1, int a2, int a3, int a4, uint64_t a5)
{
  return re::BindPoint::setIsOverridden(a1 + 8, a5);
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::overrideValueUntyped(uint64_t a1)
{
  uint64_t result = re::BindPoint::overrideValueUntyped((re::BindPoint *)(a1 + 8));
  if (result)
  {
    unint64_t v3 = *(void *)(a1 + 56);
    if (*(void *)(result + 24) <= v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(void *)(result + 32) + 48 * v3;
  }
  return result;
}

uint64_t re::anonymous namespace'::SkeletalPoseJointBindPointImpl::boundOwner()
{
  return 0;
}

void re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  uint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    unint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<BOOL>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<BOOL>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<BOOL>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<BOOL>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<BOOL>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<BOOL>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<BOOL>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<BOOL>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<BOOL>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<BOOL>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<BOOL>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  char v10 = 0;
  re::DynamicArray<BOOL>::add(this, &v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 2) + *((void *)this + 4) - 1);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<BOOL>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

unint64_t re::IntrospectionDynamicArray<BOOL>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + a3;
}

void re::DynamicArray<BOOL>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<BOOL>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1) {
      bzero((void *)(*(void *)(a1 + 32) + v4), a2 - v4);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<BOOL>::add(void *this, unsigned char *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<BOOL>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(unsigned char *)(v3[4] + v4) = *a2;
  uint64_t v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void *re::DynamicArray<BOOL>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<BOOL>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<BOOL>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<BOOL>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<BOOL>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<BOOL>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v12);
    re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)&v13);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      char v10 = *(void ***)(a1 + 32);
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v11, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v11, v10, a3, 0);
        char v10 = (void **)((char *)v10 + 1);
        --v9;
      }
      while (v9);
    }
  }
}

unint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::FixedArray<re::GenericSRT<float>>::copy(void *result, uint64_t a2, const void *a3, uint64_t a4)
{
  if (__CFADD__(a2, a4))
  {
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 362, result[1], a2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if ((unint64_t)(a2 + a4) > result[1])
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Too much data to copy.", "requiredSize <= m_size", "copy", 363);
    uint64_t result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  if (a4)
  {
    unint64_t v4 = (void *)(result[2] + 48 * a2);
    return memmove(v4, a3, 48 * a4);
  }
  return result;
}

void re::registerIKinemaAnimNodes(re *this, re::RigEnvironment *a2)
{
  uint64_t v3 = 0;
  unint64_t v4 = *(void *)this;
  do
  {
    size_t v5 = strlen((&re::registerIKinemaAnimNodes(re::RigEnvironment *)::kCustomStructs)[v3]);
    v27[0] = (&re::registerIKinemaAnimNodes(re::RigEnvironment *)::kCustomStructs)[v3];
    v27[1] = v5;
    re::RigDataTypeClass::rigDataTypeParser(v4, (uint64_t)v27, (uint64_t)v30);
    re::StringID::StringID((re::StringID *)v26, &v32);
    re::RigEnvironment::insertRigDataType(this, v26, (const re::RigDataTypeClass *)&v31, (uint64_t)v27);
    re::StringID::destroyString((re::StringID *)v26);
    if (!LOBYTE(v27[0]) && v28 && (v29 & 1) != 0) {
      (*(void (**)(void))(*(void *)v28 + 40))();
    }
    re::Result<re::RigDataTypeClass,re::DetailedError>::~Result(v30);
    ++v3;
  }
  while (v3 != 6);
  re::internal::registerMakeIKTask(this, v6);
  re::internal::registerMakeIKLookAtTask(this, v7);
  re::internal::registerMakeIKPenetrationCorrectionTask(this, v8);
  re::internal::registerMakeIKRigJointSettings(this, v9);
  re::internal::registerMakeIKRigTaskSettings(this, v10);
  re::internal::registerMakeIKRigSolverSettings(this, v11);
  re::internal::registerGenericSolverNode(this, v12);
  re::internal::registerGenericSolverNoLookAtNode(this, v13);
  re::internal::registerGenericSolverWithRigSettingsDebug(this, v14);
  re::internal::registerIKParametersComponentNode(this, v15);
  re::internal::registerFootPlacementSolverNoLookAtNode(this, v16);
  re::internal::registerFootPlacementSolverNode(this, v17);
  re::internal::registerFootPlacementSolverDebugNode(this, v18);
  re::internal::registerRetargetingSolverNode(this, v19);
  re::internal::registerPenetrationCorrectionSolverNode(this, v20);
  re::internal::registerArvinoToArvinoRetargetNode(this, v21);
  re::internal::registerBipedToBipedRetargetNode(this, v22);
  re::internal::registerFeetSlidingSolverNode(this, v23);
  re::internal::registerFilterSolverNode(this, v24);
  re::internal::registerFloorLevelSolverNode(this, v25);
}

BOOL re::AnimationClip<float>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<float>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<float>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<float>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<float>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<float>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<float>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<float>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float *a4, uint64_t a5, float *a6)
{
  uint64_t v45 = a2;
  unint64_t v46 = a3;
  if (a3)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      float v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      uint64_t v15 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float *, uint64_t, float *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
    }
    uint64_t v44 = 0;
    if (v33[0] && v34 == 1)
    {
      uint64_t v13 = *(void *)(v8 + 80);
      if (v13)
      {
        if (*(unsigned char *)(v8 + 88)) {
          uint64_t v14 = *(void *)(v8 + 96);
        }
        else {
          uint64_t v14 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
        if (*(unsigned char *)(v8 + 104)) {
          uint64_t v18 = *(void *)(v8 + 112);
        }
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v14 = 0;
      }
      uint64_t v35 = 0;
      char v38 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      char v42 = 0;
      v33[0] = 3;
      char v36 = 1;
      uint64_t v37 = v14;
      uint64_t v43 = 0x200000000;
      int v39 = 1065353216;
      uint64_t v24 = 0;
      char v27 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      v23[0] = 3;
      char v25 = 1;
      uint64_t v26 = v18;
      uint64_t v32 = 0x200000000;
      int v28 = 1065353216;
      if (*(unsigned char *)(v8 + 128)) {
        float32x4_t v19 = (char *)&v44;
      }
      else {
        float32x4_t v19 = (char *)&v44 + 4;
      }
      if (*(unsigned char *)(v8 + 128)) {
        int32x4_t v20 = (char *)&v44 + 4;
      }
      else {
        int32x4_t v20 = (char *)&v44;
      }
      (*(void (**)(uint64_t *, unsigned char *, uint64_t, float *, uint64_t, char *))(*v9 + 88))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float *, uint64_t, char *))(*v9 + 88))(v9, v23, 1, a4, a5, v20);
      *((float *)&v44 + 1) = (float)(*(float *)&v44 - *((float *)&v44 + 1)) * (float)(int)floorf(*(float *)(a2 + 60));
      uint64_t v21 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, v46);
      float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float *, uint64_t, float *))(*v9 + 88))(v9, v21, v22, a4, a5, a6);
      float v17 = *a6 + *((float *)&v44 + 1);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
  float result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<double>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<double>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<double>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<double>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<double>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<double>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<double>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<double>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, double *a4, uint64_t a5, double *a6)
{
  uint64_t v46 = a2;
  unint64_t v47 = a3;
  if (a3)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      double v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      uint64_t v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double *, uint64_t, double *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
    }
    double v44 = 0.0;
    double v45 = 0.0;
    if (v33[0] && v34 == 1)
    {
      uint64_t v13 = *(void *)(v8 + 80);
      if (v13)
      {
        if (*(unsigned char *)(v8 + 88)) {
          uint64_t v14 = *(void *)(v8 + 96);
        }
        else {
          uint64_t v14 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
        if (*(unsigned char *)(v8 + 104)) {
          uint64_t v18 = *(void *)(v8 + 112);
        }
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v14 = 0;
      }
      uint64_t v35 = 0;
      char v38 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      char v42 = 0;
      v33[0] = 3;
      char v36 = 1;
      uint64_t v37 = v14;
      uint64_t v43 = 0x200000000;
      int v39 = 1065353216;
      uint64_t v24 = 0;
      char v27 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      v23[0] = 3;
      char v25 = 1;
      uint64_t v26 = v18;
      uint64_t v32 = 0x200000000;
      int v28 = 1065353216;
      if (*(unsigned char *)(v8 + 128)) {
        float32x4_t v19 = &v44;
      }
      else {
        float32x4_t v19 = &v45;
      }
      if (*(unsigned char *)(v8 + 128)) {
        int32x4_t v20 = &v45;
      }
      else {
        int32x4_t v20 = &v44;
      }
      (*(void (**)(uint64_t *, unsigned char *, uint64_t, double *, uint64_t, double *))(*v9 + 88))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, double *, uint64_t, double *))(*v9 + 88))(v9, v23, 1, a4, a5, v20);
      double v45 = (v44 - v45) * (double)(int)vcvtms_s32_f32(*(float *)(a2 + 60));
      uint64_t v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double *, uint64_t, double *))(*v9 + 88))(v9, v21, v22, a4, a5, a6);
      double v17 = *a6 + v45;
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
  float result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Vector2<float>>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector2<float>>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::Vector2<float>>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::Vector2<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::Vector2<float>>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector2<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector2<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x2_t *a4, uint64_t a5, float32x2_t *a6)
{
  uint64_t v45 = a2;
  unint64_t v46 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
    float result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v8 = result;
  unint64_t v9 = *(uint64_t **)(result + 80);
  if (!v9)
  {
    *a6 = *a4;
    return result;
  }
  if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    uint64_t v15 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
  }
  float32x2_t v43 = 0;
  float32x2_t v44 = 0;
  if (!v32[0] || v33 != 1) {
    goto LABEL_24;
  }
  uint64_t v13 = *(void *)(v8 + 80);
  if (v13)
  {
    if (*(unsigned char *)(v8 + 88)) {
      uint64_t v14 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v14 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    if (*(unsigned char *)(v8 + 104)) {
      uint64_t v17 = *(void *)(v8 + 112);
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v34 = 0;
  char v37 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  char v41 = 0;
  v32[0] = 3;
  char v35 = 1;
  uint64_t v36 = v14;
  uint64_t v42 = 0x200000000;
  int v38 = 1065353216;
  uint64_t v23 = 0;
  char v26 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  char v30 = 0;
  v22[0] = 3;
  char v24 = 1;
  uint64_t v25 = v17;
  uint64_t v31 = 0x200000000;
  int v27 = 1065353216;
  if (*(unsigned char *)(v8 + 128)) {
    uint64_t v18 = &v43;
  }
  else {
    uint64_t v18 = &v44;
  }
  if (*(unsigned char *)(v8 + 128)) {
    float32x4_t v19 = &v44;
  }
  else {
    float32x4_t v19 = &v43;
  }
  (*(void (**)(uint64_t *, unsigned char *, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 88))(v9, v32, 1, a4, a5, v18);
  (*(void (**)(uint64_t *, char *, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 88))(v9, v22, 1, a4, a5, v19);
  float32x2_t v44 = vmul_n_f32(vsub_f32(v43, v44), (float)(int)floorf(*(float *)(a2 + 60)));
  uint64_t v20 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, v46);
  float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 88))(v9, v20, v21, a4, a5, a6);
  *a6 = vadd_f32(*a6, v44);
  return result;
}

BOOL re::AnimationClip<re::Vector3<float>>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector3<float>>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::Vector3<float>>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::Vector3<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::Vector3<float>>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector3<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  uint64_t v46 = a2;
  unint64_t v47 = a3;
  if (a3)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      float32x4_t v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      uint64_t v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
    }
    float32x4_t v44 = 0u;
    float32x4_t v45 = 0u;
    if (v33[0] && v34 == 1)
    {
      uint64_t v13 = *(void *)(v8 + 80);
      if (v13)
      {
        if (*(unsigned char *)(v8 + 88)) {
          uint64_t v14 = *(void *)(v8 + 96);
        }
        else {
          uint64_t v14 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
        if (*(unsigned char *)(v8 + 104)) {
          uint64_t v18 = *(void *)(v8 + 112);
        }
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v14 = 0;
      }
      uint64_t v35 = 0;
      char v38 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      char v42 = 0;
      v33[0] = 3;
      char v36 = 1;
      uint64_t v37 = v14;
      uint64_t v43 = 0x200000000;
      int v39 = 1065353216;
      uint64_t v24 = 0;
      char v27 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      v23[0] = 3;
      char v25 = 1;
      uint64_t v26 = v18;
      uint64_t v32 = 0x200000000;
      int v28 = 1065353216;
      if (*(unsigned char *)(v8 + 128)) {
        float32x4_t v19 = &v44;
      }
      else {
        float32x4_t v19 = &v45;
      }
      if (*(unsigned char *)(v8 + 128)) {
        uint64_t v20 = &v45;
      }
      else {
        uint64_t v20 = &v44;
      }
      (*(void (**)(uint64_t *, unsigned char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v23, 1, a4, a5, v20);
      float32x4_t v45 = vmulq_n_f32(vsubq_f32(v44, v45), (float)(int)floorf(*(float *)(a2 + 60)));
      uint64_t v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v21, v22, a4, a5, a6);
      float32x4_t v17 = vaddq_f32(*a6, v45);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
  float result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Vector4<float>>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector4<float>>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::Vector4<float>>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::Vector4<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::Vector4<float>>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector4<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  uint64_t v46 = a2;
  unint64_t v47 = a3;
  if (a3)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      float32x4_t v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      uint64_t v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
    }
    float32x4_t v44 = 0u;
    float32x4_t v45 = 0u;
    if (v33[0] && v34 == 1)
    {
      uint64_t v13 = *(void *)(v8 + 80);
      if (v13)
      {
        if (*(unsigned char *)(v8 + 88)) {
          uint64_t v14 = *(void *)(v8 + 96);
        }
        else {
          uint64_t v14 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
        if (*(unsigned char *)(v8 + 104)) {
          uint64_t v18 = *(void *)(v8 + 112);
        }
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v14 = 0;
      }
      uint64_t v35 = 0;
      char v38 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      char v42 = 0;
      v33[0] = 3;
      char v36 = 1;
      uint64_t v37 = v14;
      uint64_t v43 = 0x200000000;
      int v39 = 1065353216;
      uint64_t v24 = 0;
      char v27 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      char v31 = 0;
      v23[0] = 3;
      char v25 = 1;
      uint64_t v26 = v18;
      uint64_t v32 = 0x200000000;
      int v28 = 1065353216;
      if (*(unsigned char *)(v8 + 128)) {
        float32x4_t v19 = &v44;
      }
      else {
        float32x4_t v19 = &v45;
      }
      if (*(unsigned char *)(v8 + 128)) {
        uint64_t v20 = &v45;
      }
      else {
        uint64_t v20 = &v44;
      }
      (*(void (**)(uint64_t *, unsigned char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v23, 1, a4, a5, v20);
      float32x4_t v45 = vmulq_n_f32(vsubq_f32(v44, v45), (float)(int)floorf(*(float *)(a2 + 60)));
      uint64_t v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v21, v22, a4, a5, a6);
      float32x4_t v17 = vaddq_f32(*a6, v45);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
  float result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Quaternion<float>>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::Quaternion<float>>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::Quaternion<float>>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Quaternion<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, int32x4_t *a4, uint64_t a5, int32x4_t *a6)
{
  uint64_t v60 = a2;
  unint64_t v61 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
    float result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v8 = result;
  unint64_t v9 = *(uint64_t **)(result + 80);
  if (!v9)
  {
    *a6 = *a4;
    return result;
  }
  if (*(unsigned char *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    uint64_t v15 = re::Slice<re::AnimationClock>::range(&v60, 1uLL, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, int32x4_t *, uint64_t, int32x4_t *))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
  }
  long long v58 = xmmword_23435FBB0;
  long long v59 = xmmword_23435FBB0;
  if (!v47[0] || v48 != 1) {
    goto LABEL_24;
  }
  uint64_t v13 = *(void *)(v8 + 80);
  if (v13)
  {
    if (*(unsigned char *)(v8 + 88)) {
      uint64_t v14 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v14 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    if (*(unsigned char *)(v8 + 104)) {
      uint64_t v17 = *(void *)(v8 + 112);
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v49 = 0;
  char v52 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  char v56 = 0;
  v47[0] = 3;
  char v50 = 1;
  uint64_t v51 = v14;
  uint64_t v57 = 0x200000000;
  int v53 = 1065353216;
  uint64_t v38 = 0;
  char v41 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  char v45 = 0;
  v37[0] = 3;
  char v39 = 1;
  uint64_t v40 = v17;
  uint64_t v46 = 0x200000000;
  int v42 = 1065353216;
  if (*(unsigned char *)(v8 + 128)) {
    uint64_t v18 = &v58;
  }
  else {
    uint64_t v18 = &v59;
  }
  if (*(unsigned char *)(v8 + 128)) {
    float32x4_t v19 = &v59;
  }
  else {
    float32x4_t v19 = &v58;
  }
  (*(void (**)(uint64_t *, unsigned char *, uint64_t, int32x4_t *, uint64_t, long long *))(*v9 + 88))(v9, v47, 1, a4, a5, v18);
  (*(void (**)(uint64_t *, char *, uint64_t, int32x4_t *, uint64_t, long long *))(*v9 + 88))(v9, v37, 1, a4, a5, v19);
  _Q2 = (int32x4_t)v58;
  int32x4_t v21 = (int32x4_t)vnegq_f32((float32x4_t)v59);
  _Q4 = (int32x4_t)vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL), vnegq_f32((float32x4_t)v58)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)v58, 0xCuLL), (float32x4_t)v59);
  float32x4_t v23 = vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q4, _Q4), (int8x16_t)_Q4, 0xCuLL), (float32x4_t)v59, (float32x4_t)v58, 3);
  _Q4.i32[0] = HIDWORD(v59);
  float32x4_t v24 = vmlaq_laneq_f32(v23, (float32x4_t)v58, (float32x4_t)v59, 3);
  __asm { FMLA            S0, S4, V2.S[3] }
  v24.i32[3] = _S0;
  long long v59 = (__int128)v24;
  re::AnimationValueTraits<re::Quaternion<float>>::repeat((float32x4_t *)&v59, vcvtms_s32_f32(*(float *)(a2 + 60)), (unint64_t *)&v59);
  uint64_t v30 = re::Slice<re::AnimationClock>::range(&v60, 1uLL, v61);
  float result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, int32x4_t *, uint64_t, int32x4_t *))(*v9 + 88))(v9, v30, v31, a4, a5, a6);
  _Q0 = (int32x4_t)v59;
  _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*a6, *a6), *(int8x16_t *)a6, 0xCuLL), vnegq_f32((float32x4_t)v59)), *(float32x4_t *)a6, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), (int8x16_t)v59, 0xCuLL));
  float32x4_t v34 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), *(float32x4_t *)a6, (float32x4_t)v59, 3);
  _Q3.i32[0] = HIDWORD(*(unsigned long long *)a6);
  float32x4_t v35 = vmlaq_laneq_f32(v34, (float32x4_t)v59, *(float32x4_t *)a6, 3);
  __asm { FMLA            S1, S3, V0.S[3] }
  v35.i32[3] = _S1;
  *a6 = (int32x4_t)v35;
  return result;
}

void re::AnimationValueTraits<re::Quaternion<float>>::repeat(float32x4_t *a1, int a2, unint64_t *a3)
{
  float v4 = (float)a2;
  float v5 = a1->f32[3];
  float v6 = fabsf(v5);
  if (v6 > 1.0 && fabsf(v6 + -1.0) >= (float)((float)((float)(v6 + 1.0) + 1.0) * 0.00001))
  {
    float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x7FC00000u);
  }
  else
  {
    float32x4_t v7 = *a1;
    float32x4_t v8 = vmulq_f32(v7, v7);
    float v9 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0]);
    if (fabsf(v9) >= 0.00001)
    {
      float32x4_t v19 = *a1;
      float v21 = (float)a2;
      float v11 = atanf(v9 / v5);
      float v4 = v21;
      float v12 = v11 / v9;
      *(float32x2_t *)v10.f32 = vmul_n_f32(*(float32x2_t *)v19.f32, v11 / v9);
      v10.i64[1] = COERCE_UNSIGNED_INT(vmuls_lane_f32(v12, v19, 2));
    }
    else
    {
      v7.i32[3] = 0;
      float32x4_t v10 = v7;
    }
  }
  float32x4_t v13 = vmulq_n_f32(v10, v4);
  float32x4_t v14 = vmulq_f32(v13, v13);
  float v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
  v16.i32[1] = v13.i32[1];
  v16.i32[0] = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL).u32[0];
  float v20 = v13.f32[0];
  float32x2_t v22 = v16;
  if (v15 > 0.00001)
  {
    float v17 = sinf(v15) / v15;
    float v20 = v20 * v17;
    float32x2_t v22 = vmul_n_f32(v22, v17);
  }
  float v18 = cosf(v15);
  *a3 = LODWORD(v20) | ((unint64_t)v22.u32[1] << 32);
  a3[1] = v22.u32[0] | ((unint64_t)LODWORD(v18) << 32);
}

BOOL re::AnimationClip<re::GenericSRT<float>>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::GenericSRT<float>>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::GenericSRT<float>>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

void re::AnimationClip<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, unint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v76 = a2;
  unint64_t v77 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
    _os_crash();
    __break(1u);
    return;
  }
  unint64_t v9 = *(uint64_t **)(a1 + 80);
  if (!v9)
  {
    long long v17 = *a4;
    long long v18 = a4[2];
    *(_OWORD *)(a6 + 16) = a4[1];
    *(_OWORD *)(a6 + 32) = v18;
    *(_OWORD *)a6 = v17;
    return;
  }
  if (*(unsigned char *)(a1 + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    uint64_t v15 = re::Slice<re::AnimationClock>::range(&v76, 1uLL, a3);
    (*(void (**)(uint64_t *, uint64_t, uint64_t, long long *, uint64_t, uint64_t))(*v9 + 88))(v9, v15, v16, a4, a5, a6);
    return;
  }
  v73.i64[0] = 0x3F8000003F800000;
  v73.i64[1] = 1065353216;
  v74.i64[0] = 0;
  v74.i64[1] = 0x3F80000000000000;
  float32x4_t v75 = 0uLL;
  v70.i64[0] = 0x3F8000003F800000;
  v70.i64[1] = 1065353216;
  v71.i64[0] = 0;
  v71.i64[1] = 0x3F80000000000000;
  float32x4_t v72 = 0uLL;
  if (!v59[0] || v60 != 1) {
    goto LABEL_24;
  }
  uint64_t v13 = *(void *)(a1 + 80);
  if (v13)
  {
    if (*(unsigned char *)(a1 + 88)) {
      uint64_t v14 = *(void *)(a1 + 96);
    }
    else {
      uint64_t v14 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    if (*(unsigned char *)(a1 + 104)) {
      uint64_t v19 = *(void *)(a1 + 112);
    }
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v61 = 0;
  char v64 = 0;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  char v68 = 0;
  v59[0] = 3;
  char v62 = 1;
  uint64_t v63 = v14;
  uint64_t v69 = 0x200000000;
  int v65 = 1065353216;
  uint64_t v50 = 0;
  char v53 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  char v57 = 0;
  v49[0] = 3;
  char v51 = 1;
  uint64_t v52 = v19;
  uint64_t v58 = 0x200000000;
  int v54 = 1065353216;
  if (*(unsigned char *)(a1 + 128)) {
    float v20 = &v70;
  }
  else {
    float v20 = &v73;
  }
  if (*(unsigned char *)(a1 + 128)) {
    float v21 = &v73;
  }
  else {
    float v21 = &v70;
  }
  (*(void (**)(uint64_t *, unsigned char *, uint64_t, long long *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v59, 1, a4, a5, v20);
  (*(void (**)(uint64_t *, char *, uint64_t, long long *, uint64_t, float32x4_t *))(*v9 + 88))(v9, v49, 1, a4, a5, v21);
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v27 = vdivq_f32(_Q3, v73);
  int32x4_t v28 = (int32x4_t)vnegq_f32(v74);
  float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v28, v28), (int8x16_t)v28, 0xCuLL);
  float32x4_t v30 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), (int8x16_t)v75, 0xCuLL), v74), v75, v29);
  int32x4_t v31 = (int32x4_t)vaddq_f32(v30, v30);
  float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL);
  _S7 = v74.i32[3];
  int32x4_t v34 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL), v74), v32, v29);
  float32x4_t v35 = vmulq_f32(vaddq_f32(vaddq_f32(v75, vmulq_laneq_f32(v32, v74, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL)), vnegq_f32(v27));
  _Q6 = (int32x4_t)v71;
  float32x4_t v37 = vmulq_f32(v27, v70);
  float32x4_t v38 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q6, _Q6), v71, 0xCuLL);
  float32x4_t v39 = vnegq_f32((float32x4_t)v71);
  int32x4_t v40 = (int32x4_t)vmlsq_f32(vmulq_f32(v29, v39), v38, v74);
  float32x4_t v41 = vmlaq_laneq_f32(vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL), v74, (float32x4_t)v71, 3), (float32x4_t)v71, v74, 3);
  __asm { FMLA            S1, S7, V6.S[3] }
  v41.i32[3] = _S1;
  float32x4_t v43 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL), v39), v35, v38);
  int32x4_t v44 = (int32x4_t)vaddq_f32(v43, v43);
  float32x4_t v45 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL);
  int32x4_t v46 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), (int8x16_t)v45, 0xCuLL), v39), v45, v38);
  float32x4_t v73 = v37;
  float32x4_t v74 = v41;
  float32x4_t v75 = vaddq_f32(v72, vmulq_f32(v70, vaddq_f32(vaddq_f32(v35, vmulq_laneq_f32(v45, (float32x4_t)v71, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v46, v46), (int8x16_t)v46, 0xCuLL))));
  v37.i32[0] = *(_DWORD *)(a2 + 60);
  re::AnimationValueTraits<re::GenericSRT<float>>::repeat(&v73, vcvtms_s32_f32(v37.f32[0]), &v73, v37);
  uint64_t v47 = re::Slice<re::AnimationClock>::range(&v76, 1uLL, v77);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, long long *, uint64_t, uint64_t))(*v9 + 88))(v9, v47, v48, a4, a5, a6);
  re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)a6, &v73, (float32x4_t *)a6);
}

float32x4_t re::AnimationValueTraits<re::GenericSRT<float>>::repeat(float32x4_t *a1, unsigned int a2, float32x4_t *a3, float32x4_t result)
{
  if (a2)
  {
    if ((a2 & 0x80000000) != 0)
    {
      float32x4_t v7 = a1[1];
      float32x4_t v8 = a1[2];
      __asm { FMOV            V3.4S, #1.0 }
      float32x4_t v6 = vdivq_f32(_Q3, *a1);
      int32x4_t v14 = (int32x4_t)vnegq_f32(v7);
      float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL);
      v14.i32[3] = v7.i32[3];
      float32x4_t v16 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v7), v8, v15);
      int32x4_t v17 = (int32x4_t)vaddq_f32(v16, v16);
      float32x4_t v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v17, v17), (int8x16_t)v17, 0xCuLL);
      float32x4_t v19 = vaddq_f32(v8, vmulq_laneq_f32(v18, v7, 3));
      int32x4_t v20 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v7), v18, v15);
      a3[1] = (float32x4_t)v14;
      a3[2] = vmulq_f32(vaddq_f32(v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL)), vnegq_f32(v6));
      a2 = -a2;
    }
    else
    {
      float32x4_t v4 = a1[2];
      float32x4_t v5 = *a1;
      a3[1] = a1[1];
      a3[2] = v4;
      *a3 = v5;
      float32x4_t v6 = *a3;
    }
    if (a2 <= 1)
    {
      float32x4_t v22 = (float32x4_t)xmmword_23435FBB0;
      float32x4_t v21 = (float32x4_t)xmmword_2343679C0;
      _Q2 = a3[1];
      float32x4_t v23 = a3[2];
      float32x4_t v25 = 0uLL;
    }
    else
    {
      float32x4_t v21 = (float32x4_t)xmmword_2343679C0;
      float32x4_t v22 = (float32x4_t)xmmword_23435FBB0;
      _Q2 = a3[1];
      float32x4_t v23 = a3[2];
      float32x4_t v25 = 0uLL;
      do
      {
        if (a2)
        {
          float32x4_t v21 = vmulq_f32(v21, v6);
          float32x4_t v37 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
          float32x4_t v38 = vnegq_f32(_Q2);
          int32x4_t v39 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v38), v22, v37);
          _S17 = _Q2.i32[3];
          _S18 = v22.i32[3];
          float32x4_t v42 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL), v22, _Q2, 3), _Q2, v22, 3);
          __asm { FMLA            S5, S18, V2.S[3] }
          v42.i32[3] = _S5;
          float32x4_t v44 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v38), v25, v37);
          int32x4_t v45 = (int32x4_t)vaddq_f32(v44, v44);
          float32x4_t v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v45, v45), (int8x16_t)v45, 0xCuLL);
          _Q18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), v38), v46, v37);
          float32x4_t v48 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v25, vmulq_laneq_f32(v46, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q18, _Q18), (int8x16_t)_Q18, 0xCuLL)));
          int32x4_t v49 = (int32x4_t)vmlaq_f32(vmulq_f32(v37, v38), _Q2, v37);
          float32x4_t v50 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v49, v49), (int8x16_t)v49, 0xCuLL), _Q2, _Q2, 3), _Q2, _Q2, 3);
          __asm { FMLA            S18, S17, V2.S[3] }
          v50.i32[3] = _Q18.i32[0];
          float32x4_t v25 = vaddq_f32(v23, v48);
          float32x4_t v51 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v38), v23, v37);
          int32x4_t v52 = (int32x4_t)vaddq_f32(v51, v51);
          float32x4_t v53 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v52, v52), (int8x16_t)v52, 0xCuLL);
          int32x4_t v54 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), v38), v53, v37);
          float32x4_t v55 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v23, vmulq_laneq_f32(v53, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v54, v54), (int8x16_t)v54, 0xCuLL)));
          float32x4_t v6 = vmulq_f32(v6, v6);
          float32x4_t v23 = vaddq_f32(v23, v55);
          --a2;
          _Q2 = v50;
          float32x4_t v22 = v42;
        }
        else
        {
          float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
          float32x4_t v27 = vnegq_f32(_Q2);
          float32x4_t v28 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v27), v23, v26);
          int32x4_t v29 = (int32x4_t)vaddq_f32(v28, v28);
          float32x4_t v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL);
          int32x4_t v31 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), v27), v30, v26);
          float32x4_t v32 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v23, vmulq_laneq_f32(v30, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL)));
          float32x4_t v6 = vmulq_f32(v6, v6);
          _Q7 = (int32x4_t)vmlaq_f32(vmulq_f32(v26, v27), _Q2, v26);
          float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q7, _Q7), (int8x16_t)_Q7, 0xCuLL);
          _Q7.i32[0] = _Q2.i32[3];
          float32x4_t v35 = vmlaq_laneq_f32(vmlaq_laneq_f32(v34, _Q2, _Q2, 3), _Q2, _Q2, 3);
          __asm { FMLA            S17, S7, V2.S[3] }
          v35.i32[3] = _S17;
          float32x4_t v23 = vaddq_f32(v23, v32);
          _Q2 = v35;
        }
        BOOL v56 = a2 > 3;
        a2 >>= 1;
      }
      while (v56);
    }
    float32x4_t v57 = vmulq_f32(v6, v21);
    float32x4_t v58 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
    float32x4_t v59 = vnegq_f32(_Q2);
    int32x4_t v60 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v59), v22, v58);
    float32x4_t v61 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v60, v60), (int8x16_t)v60, 0xCuLL), v22, _Q2, 3), _Q2, v22, 3);
    _S5 = v22.i32[3];
    __asm { FMLA            S17, S5, V2.S[3] }
    v61.i32[3] = _S17;
    float32x4_t v64 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v59), v25, v58);
    int32x4_t v65 = (int32x4_t)vaddq_f32(v64, v64);
    float32x4_t v66 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL);
    float32x4_t v67 = vaddq_f32(v25, vmulq_laneq_f32(v66, _Q2, 3));
    int32x4_t v68 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v66, (int32x4_t)v66), (int8x16_t)v66, 0xCuLL), v59), v66, v58);
    float result = vaddq_f32(v23, vmulq_f32(v6, vaddq_f32(v67, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v68, v68), (int8x16_t)v68, 0xCuLL))));
    *a3 = v57;
    a3[1] = v61;
    a3[2] = result;
  }
  else
  {
    a3->i64[0] = 0x3F8000003F800000;
    a3->i64[1] = 1065353216;
    a3[1].i64[0] = 0;
    a3[1].i64[1] = 0x3F80000000000000;
    a3[2].i64[0] = 0;
    a3[2].i64[1] = 0;
  }
  return result;
}

BOOL re::AnimationClip<re::SkeletalPose>::childCount(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::SkeletalPose>::child(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

double re::AnimationClip<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v3 = *(double *)(a1 + 96);
    }
    else {
      double v3 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    if (*(unsigned char *)(a1 + 104)) {
      double v5 = *(double *)(a1 + 112);
    }
    double v4 = v5 - v3;
  }
  else
  {
    double v4 = 0.0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    double v4 = *(double *)(a1 + 152);
  }
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

float re::AnimationClip<re::SkeletalPose>::timelineDesc@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 88)) {
      double v5 = *(double *)(a1 + 96);
    }
    else {
      double v5 = 0.0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    if (*(unsigned char *)(a1 + 104)) {
      double v7 = *(double *)(a1 + 112);
    }
    float v6 = v7 - v5;
  }
  else
  {
    float v6 = 0.0;
    double v5 = 0.0;
    double v7 = 0.0;
  }
  if (!*(unsigned char *)(a1 + 144) || (double v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    char v9 = *(unsigned char *)(a1 + 164);
    if (v9) {
      float v6 = INFINITY;
    }
  }
  else
  {
    float v6 = v8;
    char v9 = *(unsigned char *)(a1 + 164);
  }
  float v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  float v11 = *(float *)(a1 + 160);
  if (*(unsigned char *)(a1 + 128)) {
    float v11 = -v11;
  }
  float v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  float result = v7;
  float v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(unsigned char *)(a2 + 24) = v9;
  *(unsigned char *)(a2 + 25) = *(unsigned char *)(a1 + 16);
  return result;
}

uint64_t re::AnimationClip<re::SkeletalPose>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) == 1)
  {
    unint64_t v9 = a5 + 1;
    if (*(void *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    uint64_t v10 = *(void *)(*(void *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 80))(v10))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 168, 8);
      uint64_t v12 = re::AnimationClip<re::SkeletalPose>::AnimationClip(v11, v8);
      if (*(void *)(a4 + 128) > v9)
      {
        *(void *)(v12 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(*(void *)(a4 + 136) + 8 * v9);
        *(unsigned char *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::SkeletalPose>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

void *re::AnimationClip<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, void *a6)
{
  v56[0] = a2;
  v56[1] = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    a1 = _os_crash();
    __break(1u);
LABEL_10:
    uint64_t v20 = a1;
    v49[0] = 0;
    v49[1] = (uint64_t)"";
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    int v53 = 0;
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    v42[0] = 0;
    v42[1] = (uint64_t)"";
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    int v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    re::SkeletalPose::init(v49, v7 + 10);
    re::SkeletalPose::init(v42, v7 + 10);
    if (v31[0] && v32 == 1)
    {
      uint64_t v15 = *(void *)(v20 + 80);
      v14.n128_u64[0] = 0;
      uint64_t v16 = 0;
      if (v15)
      {
        if (*(unsigned char *)(v20 + 88)) {
          uint64_t v16 = *(void *)(v20 + 96);
        }
        (*(void (**)(uint64_t, __n128))(*(void *)v15 + 40))(v15, v14);
        if (*(unsigned char *)(v20 + 104)) {
          v14.n128_u64[0] = *(void *)(v20 + 112);
        }
      }
      uint64_t v33 = 0;
      char v36 = 0;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      char v40 = 0;
      v31[0] = 3;
      char v34 = 1;
      uint64_t v35 = v16;
      uint64_t v41 = 0x200000000;
      int v37 = 1065353216;
      uint64_t v22 = 0;
      char v25 = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      char v29 = 0;
      v21[0] = 3;
      char v23 = 1;
      unint64_t v24 = v14.n128_u64[0];
      uint64_t v30 = 0x200000000;
      int v26 = 1065353216;
      if (*(unsigned char *)(v20 + 128)) {
        int32x4_t v17 = v42;
      }
      else {
        int32x4_t v17 = v49;
      }
      if (*(unsigned char *)(v20 + 128)) {
        float32x4_t v18 = v49;
      }
      else {
        float32x4_t v18 = v42;
      }
      (*(void (**)(uint64_t *, unsigned char *, uint64_t, void *, uint64_t, uint64_t *))(*v8 + 88))(v8, v31, 1, v7, v6, v17);
      (*(void (**)(uint64_t *, char *, uint64_t, void *, uint64_t, uint64_t *))(*v8 + 88))(v8, v21, 1, v7, v6, v18);
      re::AnimationValueTraits<re::SkeletalPose>::invert(v49, v49);
      re::AnimationValueTraits<re::SkeletalPose>::combine(v49, v42, v49);
      re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) Not yet implemented.", "!\"Unreachable code\"", "repeat", 304);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 286);
    float result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  double v7 = a4;
  uint64_t v8 = *(uint64_t **)(a1 + 80);
  if (v8)
  {
    uint64_t v6 = a5;
    if (*(unsigned char *)(a1 + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      uint64_t v10 = re::Slice<re::AnimationClock>::range(v56, 1uLL, a3);
      return (void *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, void *, uint64_t, void *))(*v8 + 88))(v8, v10, v11, v7, v6, a6);
    }
    goto LABEL_10;
  }
  return re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
}

void *re::AnimationClip<float>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<float>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<double>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<double>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::Vector2<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::Vector2<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::Vector3<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::Vector3<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::Vector4<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::Vector4<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::Quaternion<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::Quaternion<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::GenericSRT<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::GenericSRT<float>>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

void *re::AnimationClip<re::SkeletalPose>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v2 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v2);
  return a1;
}

void re::AnimationClip<re::SkeletalPose>::~AnimationClip(void *a1)
{
  *a1 = &unk_26E6BF1F0;
  uint64_t v1 = (re::StringID *)(a1 + 3);
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AnimationClip<float>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<float>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3A00;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<double>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<double>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3A80;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::Vector2<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::Vector2<float>>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3B00;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::Vector3<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::Vector3<float>>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3B80;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::Vector4<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::Vector4<float>>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3C00;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::Quaternion<float>>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3C80;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::GenericSRT<float>>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3D00;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

uint64_t re::AnimationClip<re::SkeletalPose>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Animation<re::SkeletalPose>::Animation(a1, a2);
  *(void *)uint64_t result = &unk_26E6C3D80;
  *(void *)(result + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = *(void *)(a2 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  *(unsigned char *)(result + 88) = v4;
  if (v4) {
    *(void *)(result + 96) = *(void *)(a2 + 96);
  }
  int v5 = *(unsigned __int8 *)(a2 + 104);
  *(unsigned char *)(result + 104) = v5;
  if (v5) {
    *(void *)(result + 112) = *(void *)(a2 + 112);
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = v6;
  int v7 = *(unsigned __int8 *)(a2 + 144);
  *(unsigned char *)(result + 144) = v7;
  if (v7) {
    *(void *)(result + 152) = *(void *)(a2 + 152);
  }
  int v8 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(result + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(result + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v8;
  return result;
}

void *re::allocInfo_AudioAnimationState(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_21, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_21))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73DF8, "AudioAnimationState");
    __cxa_guard_release(&_MergedGlobals_21);
  }
  return &unk_26AF73DF8;
}

void re::initInfo_AudioAnimationState(re *this, re::IntrospectionBase *a2)
{
  v22[0] = 0x2D5905E6F33A1986;
  v22[1] = "AudioAnimationState";
  re::StringID::destroyString((re::StringID *)v22);
  *((_OWORD *)this + 2) = v23;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73DB8, memory_order_acquire) & 1) == 0)
  {
    int v4 = (re *)__cxa_guard_acquire(&qword_26AF73DB8);
    if (v4)
    {
      int v5 = re::introspectionAllocator(v4);
      int v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "speed";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x800000001;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73DD8 = v8;
      unint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_double((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "time";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 2;
      *(_DWORD *)(v12 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF73DE0 = v12;
      uint64_t v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_BOOL((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "prepared";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0xC00000003;
      *(_DWORD *)(v16 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF73DE8 = v16;
      int32x4_t v17 = re::introspectionAllocator((re *)v16);
      uint64_t v19 = re::introspect_size_t((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "animationCounter";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x1000000004;
      *(_DWORD *)(v20 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF73DF0 = v20;
      __cxa_guard_release(&qword_26AF73DB8);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF73DD8;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::AudioAnimationState>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::AudioAnimationState>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::AudioAnimationState>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::AudioAnimationState>;
  re::IntrospectionRegistry::add(this, v3);
  long long v21 = v23;
}

void re::internal::defaultConstruct<re::AudioAnimationState>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 12) = 0;
  *(void *)(a3 + 16) = 0;
}

uint64_t re::internal::defaultConstructV2<re::AudioAnimationState>(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 8) = 0;
  *(unsigned char *)(result + 12) = 0;
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t re::introspect_AudioAnimationState(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AudioAnimationState", (uint64_t (*)(re::internal *))re::allocInfo_AudioAnimationState, (re::IntrospectionBase *(*)(void))re::initInfo_AudioAnimationState, (void (*)(re::IntrospectionBase *))&unk_26AF73DC0, this);
}

uint64_t re::AudioAnimationTimeline::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3)
  {
    float v6 = *(double *)(a2 + 24);
    double v7 = v6;
    if (*(double *)(result + 80) <= v7)
    {
      double v9 = *(double *)(result + 88);
      BOOL v10 = v9 == v7;
      BOOL v11 = v9 < v7;
      if (v9 <= v7) {
        double v7 = 0.0;
      }
      *(double *)a6 = v7;
      *(_DWORD *)(a6 + 8) = *(_DWORD *)(a2 + 36);
      if (v11 || v10) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = *(void *)(a2 + 40);
      }
    }
    else
    {
      uint64_t v8 = 0;
      *(void *)a6 = 0;
      *(_DWORD *)(a6 + 8) = *(_DWORD *)(a2 + 36);
    }
    *(void *)(a6 + 16) = v8;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::AudioAnimationTimeline::totalDuration(re::AudioAnimationTimeline *this)
{
  return *((double *)this + 11) - *((double *)this + 10);
}

float re::AudioAnimationTimeline::timelineDesc@<S0>(re::AudioAnimationTimeline *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 1065353216;
  *(_DWORD *)(a2 + 20) = 0;
  *(_WORD *)(a2 + 24) = 0;
  double v3 = *((double *)this + 10);
  double v2 = *((double *)this + 11);
  float v4 = v2 - v3;
  *(float *)(a2 + 4) = v4;
  *(float *)&double v3 = v3;
  float result = v2;
  *(_DWORD *)(a2 + 12) = LODWORD(v3);
  *(float *)(a2 + 16) = result;
  return result;
}

double re::AudioAnimationTimeline::makeCompositionChain(re::AudioAnimationTimeline *this, Allocator *a2)
{
  uint64_t v2 = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 176, 8);
  double result = 0.0;
  *(_OWORD *)(v2 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 0u;
  *(void *)(v2 + 168) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v2 + 88) = 0;
  *(void *)(v2 + 96) = 0;
  *(unsigned char *)(v2 + 104) = 0;
  *(void *)(v2 + 144) = 0;
  *(unsigned char *)(v2 + 156) = 0;
  *(_DWORD *)(v2 + re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80) = 0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(void *)uint64_t v2 = &unk_26E6C3F88;
  return result;
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::prepare(uint64_t this)
{
  *(unsigned char *)(this + 168) = 1;
  return this;
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::update(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  uint64_t result = re::internal::AnimationCompositionChain<re::AudioAnimationState>::update((uint64_t)this);
  *((unsigned char *)this + 156) = *((unsigned char *)this + 168);
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::update(uint64_t result)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  uint64_t v62 = *(void *)(result + 72);
  if (!v62) {
    return result;
  }
  uint64_t v5 = result;
  float v6 = (re::BindPoint *)(result + 8);
  uint64_t result = re::BindPoint::isAlive((re::BindPoint *)(result + 8));
  if (!result) {
    return result;
  }
  uint64_t result = re::BindPoint::supportsOverrideValue(v6);
  uint64_t v68 = 0;
  int v69 = 0;
  char v70 = 0;
  uint64_t v71 = 0;
  char v72 = 0;
  int v58 = result;
  if (result)
  {
    uint64_t result = re::BindPoint::baseValueUntyped(v6);
    float32x4_t v57 = (uint64_t *)result;
  }
  else
  {
    char v72 = 1;
    uint64_t v71 = 0;
    float32x4_t v57 = &v68;
  }
  if (*(unsigned char *)(v5 + 112))
  {
    *(_OWORD *)(v5 + 144) = *(_OWORD *)(v5 + 120);
    *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = *(void *)(v5 + 136);
  }
  else
  {
    long long v8 = *(_OWORD *)v57;
    *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = v57[2];
    *(_OWORD *)(v5 + 144) = v8;
  }
  long long v9 = 0uLL;
  long long v66 = 0u;
  long long v67 = 0u;
  if (!*(void *)(v5 + 72)) {
    goto LABEL_88;
  }
  BOOL v56 = v6;
  unint64_t v4 = 0;
  LOBYTE(v60) = 0;
  int v10 = 0;
  float v6 = (re::BindPoint *)*(unsigned int *)(*(void *)(v5 + 88) + 16);
  uint64_t v61 = v5 + 144;
  uint64_t v63 = v57;
  int v64 = 0;
  char v65 = 0;
  double v11 = 0.0;
  float v12 = 0.0;
  unint64_t v13 = 24;
  char v59 = v58;
  while (1)
  {
    unint64_t v1 = *(void *)(v5 + 72);
    if (v1 <= v4)
    {
      uint64_t v73 = 0;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v82 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v74 = 136315906;
      float32x4_t v75 = "operator[]";
      __int16 v76 = 1024;
      int v77 = 789;
      __int16 v78 = 2048;
      unint64_t v79 = v4;
      __int16 v80 = 2048;
      uint64_t v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_82:
      uint64_t v73 = 0;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v82 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v74 = 136315906;
      float32x4_t v75 = "operator[]";
      __int16 v76 = 1024;
      int v77 = 476;
      __int16 v78 = 2048;
      unint64_t v79 = v2;
      __int16 v80 = 2048;
      uint64_t v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_83:
      re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
      _os_crash();
      __break(1u);
LABEL_84:
      uint64_t v73 = 0;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v82 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v74 = 136315906;
      float32x4_t v75 = "operator[]";
      __int16 v76 = 1024;
      int v77 = 476;
      __int16 v78 = 2048;
      unint64_t v79 = v2;
      __int16 v80 = 2048;
      uint64_t v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_85:
      uint64_t v73 = 0;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v82 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v74 = 136315906;
      float32x4_t v75 = "operator[]";
      __int16 v76 = 1024;
      int v77 = 476;
      __int16 v78 = 2048;
      unint64_t v79 = v2;
      __int16 v80 = 2048;
      uint64_t v81 = (re::BindPoint *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_86;
    }
    uint64_t v14 = *(void *)(v5 + 88);
    uint64_t v15 = v14 + 24 * v4;
    uint64_t v16 = (re::BindPoint *)*(unsigned int *)(v15 + 16);
    if (v6 != v16 && v10)
    {
      int v10 = 0;
      BOOL v17 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
      float v18 = v12 + *(float *)(v5 + 152);
      *(double *)(v5 + 144) = (v11 + *(double *)(v5 + 144)) * 0.5;
      *(float *)(v5 + 152) = v18 * 0.5;
      *(unsigned char *)(v5 + 156) = v17;
      *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
    }
    float v6 = v16;
    uint64_t v19 = *(void **)v15;
    unint64_t v2 = *(int *)(v15 + 8);
    unint64_t v1 = *(void *)(*(void *)v15 + 56);
    unint64_t v20 = v2 + 1;
    if (v1 <= v2 + 1) {
      unint64_t v21 = v2 + 1;
    }
    else {
      unint64_t v21 = *(void *)(*(void *)v15 + 56);
    }
    do
    {
      if (v21 == v20) {
        goto LABEL_22;
      }
      double v3 = (re::BindPoint *)v19[1];
      if ((unint64_t)v3 <= v20)
      {
        uint64_t v73 = 0;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v82 = 0u;
        uint64_t v5 = &_os_log_internal;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v74 = 136315906;
        float32x4_t v75 = "operator[]";
        __int16 v76 = 1024;
        int v77 = 476;
        __int16 v78 = 2048;
        unint64_t v79 = v20;
        __int16 v80 = 2048;
        uint64_t v81 = v3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_76;
      }
      int v22 = *(_DWORD *)(v19[2] + 4 * v20++);
    }
    while (v22 >= (int)v2);
    LODWORD(v21) = v20 - 1;
LABEL_22:
    if (v1 <= v2) {
      goto LABEL_82;
    }
    int v23 = v21 - v2;
    if (!v23) {
      goto LABEL_83;
    }
    unint64_t v1 = v19[16];
    if (v1 <= v2) {
      goto LABEL_84;
    }
    unint64_t v1 = v19[8];
    unint64_t v24 = (unsigned char *)(v1 + 72 * (int)v2);
    double v3 = *(re::BindPoint **)(v19[17] + 8 * v2);
    if (!v24[16]) {
      goto LABEL_42;
    }
    unint64_t v13 = v19[13];
    if (v13 <= v2) {
      goto LABEL_85;
    }
    float v25 = *(float *)(v19[14] + 4 * v2);
    float v26 = fabsf(v25);
    unint64_t v13 = 24;
    if (v26 < 0.00001) {
      goto LABEL_71;
    }
    if (v25 != 1.0 && fabsf(v25 + -1.0) >= (float)((float)((float)(v26 + 1.0) + 1.0) * 0.00001))
    {
      if (!BYTE8(v67)) {
        BYTE8(v67) = 1;
      }
      int v32 = (long long *)(v5 + 144);
      if (v10)
      {
        BOOL v33 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
        float v34 = v12 + *(float *)(v5 + 152);
        *(double *)&long long v66 = (v11 + *(double *)(v5 + 144)) * 0.5;
        *((float *)&v66 + 2) = v34 * 0.5;
        BYTE12(v66) = v33;
        *(void *)&long long v67 = 0;
        int v32 = &v66;
      }
      int v35 = v64;
      uint64_t result = (*(uint64_t (**)(re::BindPoint *, unsigned char *, void, long long *, uint64_t **, long long *))(*(void *)v3 + 88))(v3, v24, v23, v32, &v63, &v66);
      if (v64 != v35) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
      }
      if (*((unsigned char *)v3 + 72))
      {
        unint64_t v1 = *(void *)(v5 + 72);
        if (v1 <= v4) {
          goto LABEL_90;
        }
        if ((*(unsigned char *)(*(void *)(v5 + 88) + 24 * v4 + 20) & 4) != 0)
        {
          double v36 = *(double *)(v5 + 144);
          float v42 = *(float *)(v5 + 152);
          int v43 = *(unsigned __int8 *)(v5 + 156);
          *(double *)&long long v66 = (*(double *)&v66 + v36) * 0.5;
          *((float *)&v66 + 2) = (float)(*((float *)&v66 + 2) + v42) * 0.5;
          BYTE12(v66) = (BYTE12(v66) | v43) != 0;
          *(void *)&long long v67 = 0;
          int v38 = (v60 | v43) != 0;
          float v37 = (float)(v12 + v42) * 0.5;
          if (v10)
          {
            double v36 = (v11 + v36) * 0.5;
          }
          else
          {
            int v38 = v43;
            float v37 = v42;
          }
        }
        else
        {
          double v36 = *(double *)(v5 + 144);
          float v37 = *(float *)(v5 + 152);
          int v38 = *(unsigned __int8 *)(v5 + 156);
          if (v10)
          {
            int v38 = (v60 | v38) != 0;
            float v37 = (float)(v12 + v37) * 0.5;
            double v36 = (v11 + v36) * 0.5;
          }
          *(double *)&long long v66 = (v36 + *(double *)&v66) * 0.5;
          *((float *)&v66 + 2) = (float)(v37 + *((float *)&v66 + 2)) * 0.5;
          BYTE12(v66) = (BYTE12(v66) | v38) != 0;
          *(void *)&long long v67 = 0;
        }
      }
      else
      {
        double v36 = *(double *)(v5 + 144);
        float v37 = *(float *)(v5 + 152);
        int v38 = *(unsigned __int8 *)(v5 + 156);
        if (v10)
        {
          int v38 = (v60 | v38) != 0;
          float v37 = (float)(v12 + v37) * 0.5;
          double v36 = (v11 + v36) * 0.5;
        }
      }
      int v10 = 0;
      int v44 = v38 | BYTE12(v66);
      float v45 = (float)(v25 * *((float *)&v66 + 2)) + (float)(v37 * (float)(1.0 - v25));
      *(double *)(v5 + 144) = *(double *)&v66 * v25 + v36 * (float)(1.0 - v25);
      *(float *)(v5 + 152) = v45;
      *(unsigned char *)(v5 + 156) = v44 != 0;
      *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
      goto LABEL_71;
    }
    *(unsigned char *)(v14 + 24 * v4 + 20) &= ~4u;
    if (*((unsigned char *)v3 + 72)) {
      break;
    }
    char v65 = 1;
LABEL_42:
    uint64_t result = (*(uint64_t (**)(re::BindPoint *, unint64_t, void, uint64_t, uint64_t **, uint64_t))(*(void *)v3 + 88))(v3, v1 + 72 * (int)v2, v23, v61, &v63, v61);
LABEL_71:
    if (++v4 == v62)
    {
      if (v10)
      {
        int v46 = v60 | *(unsigned __int8 *)(v5 + 156);
        float v47 = (float)(v12 + *(float *)(v5 + 152)) * 0.5;
        *(double *)(v5 + 144) = (v11 + *(double *)(v5 + 144)) * 0.5;
        *(float *)(v5 + 152) = v47;
        *(unsigned char *)(v5 + 156) = v46 != 0;
        *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
      }
      return result;
    }
  }
  if (!BYTE8(v67)) {
    BYTE8(v67) = 1;
  }
  uint64_t v27 = (long long *)(v5 + 144);
  if (v10)
  {
    BOOL v28 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
    float v29 = v12 + *(float *)(v5 + 152);
    *(double *)&long long v66 = (v11 + *(double *)(v5 + 144)) * 0.5;
    *((float *)&v66 + 2) = v29 * 0.5;
    BYTE12(v66) = v28;
    *(void *)&long long v67 = 0;
    uint64_t v27 = &v66;
  }
  uint64_t result = (*(uint64_t (**)(re::BindPoint *, unint64_t, void, long long *, uint64_t **, long long *))(*(void *)v3 + 88))(v3, v1 + 72 * (int)v2, v23, v27, &v63, &v66);
  if (!v58)
  {
LABEL_39:
    double v30 = *(double *)&v66;
    float v31 = *((float *)&v66 + 2);
    if (v10)
    {
      int v60 = (BYTE12(v66) | v60) != 0;
      float v31 = (float)(v12 + *((float *)&v66 + 2)) * 0.5;
      double v30 = (v11 + *(double *)&v66) * 0.5;
    }
    else
    {
      int v60 = BYTE12(v66);
    }
    if (v59)
    {
      unint64_t v1 = *(void *)(v5 + 72);
      if (v1 <= v4) {
        goto LABEL_87;
      }
      char v59 = 0;
      int v10 = 1;
      if ((*(unsigned char *)(*(void *)(v5 + 88) + 24 * v4 + 20) & 2) != 0 && *v24 == 5)
      {
        BOOL v39 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
        float v40 = (float)(v31 + *(float *)(v5 + 152)) * 0.5;
        *(double *)(v5 + 144) = (v30 + *(double *)(v5 + 144)) * 0.5;
        *(float *)(v5 + 152) = v40;
        *(unsigned char *)(v5 + 156) = v39;
        *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
        uint64_t result = re::BindPoint::baseValueUntyped(v56);
        if (result)
        {
          long long v41 = *(_OWORD *)v61;
          *(void *)(result + 16) = *(void *)(v5 + 160);
          *(_OWORD *)uint64_t result = v41;
          uint64_t result = re::BindPoint::markAsWritten((uint64_t)v56);
        }
        unint64_t v1 = *(void *)(v5 + 72);
        if (v1 <= v4) {
          goto LABEL_89;
        }
        int v10 = 0;
        *(unsigned char *)(*(void *)(v5 + 88) + 24 * v4 + 20) &= ~2u;
        char v59 = 1;
        *unint64_t v24 = 1;
      }
    }
    else
    {
      char v59 = 0;
      int v10 = 1;
    }
    double v11 = v30;
    float v12 = v31;
    goto LABEL_71;
  }
  double v3 = *(re::BindPoint **)(v5 + 72);
  if ((unint64_t)v3 <= v4)
  {
LABEL_86:
    uint64_t v73 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = v4;
    __int16 v80 = 2048;
    uint64_t v81 = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_87:
    uint64_t v73 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = v4;
    __int16 v80 = 2048;
    uint64_t v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_88:
    uint64_t v63 = 0;
    long long v85 = v9;
    long long v86 = v9;
    long long v83 = v9;
    long long v84 = v9;
    long long v82 = v9;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = 0;
    __int16 v80 = 2048;
    uint64_t v81 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_89:
    uint64_t v73 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = v4;
    __int16 v80 = 2048;
    uint64_t v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_90:
    uint64_t v73 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = v4;
    __int16 v80 = 2048;
    uint64_t v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_91:
    uint64_t v73 = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v82 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v74 = 136315906;
    float32x4_t v75 = "operator[]";
    __int16 v76 = 1024;
    int v77 = 789;
    __int16 v78 = 2048;
    unint64_t v79 = v4;
    __int16 v80 = 2048;
    uint64_t v81 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(unsigned char *)(*(void *)(v5 + 88) + 24 * v4 + 20) & 1) == 0 || !*(unsigned char *)(v1 + 72 * (int)v2 + 32)) {
    goto LABEL_39;
  }
LABEL_76:
  double v48 = *(double *)&v66;
  float v49 = *((float *)&v66 + 2);
  float v50 = -*((float *)&v66 + 2);
  char v51 = BYTE12(v66);
  *(double *)(v5 + 144) = -*(double *)&v66;
  *(float *)(v5 + 152) = v50;
  *(unsigned char *)(v5 + 156) = v51;
  *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
  BOOL v52 = (v51 | *((unsigned char *)v57 + 12)) != 0;
  float v53 = (float)(*((float *)v57 + 2) - v49) * 0.5;
  *(double *)(v5 + 144) = (*(double *)v57 - v48) * 0.5;
  *(float *)(v5 + 152) = v53;
  *(unsigned char *)(v5 + 156) = v52;
  *(void *)(v5 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160) = 0;
  uint64_t v54 = re::BindPoint::baseValueUntyped(v56);
  if (v54)
  {
    long long v55 = *(_OWORD *)v61;
    *(void *)(v54 + 16) = *(void *)(v61 + 16);
    *(_OWORD *)uint64_t v54 = v55;
    re::BindPoint::markAsWritten((uint64_t)v56);
  }
  float v6 = *(re::BindPoint **)(v5 + 72);
  if ((unint64_t)v6 <= v4) {
    goto LABEL_91;
  }
  *(unsigned char *)(*(void *)(v5 + 88) + 24 * v4 + 20) &= ~1u;
  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::cleanup(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  *((unsigned char *)this + 168) = 0;
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((unsigned char *)this + 156) = 0;
  *((void *)this + 20) = 0;
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

void re::AudioAnimationTimeline::~AudioAnimationTimeline(re::AudioAnimationTimeline *this)
{
  *(void *)this = &unk_26E6BF1F0;
  unint64_t v1 = (re::AudioAnimationTimeline *)((char *)this + 24);
  re::DynamicString::deinit((re::AudioAnimationTimeline *)((char *)this + 40));
  re::StringID::destroyString(v1);
}

{
  re::StringID *v1;
  uint64_t vars8;

  *(void *)this = &unk_26E6BF1F0;
  unint64_t v1 = (re::AudioAnimationTimeline *)((char *)this + 24);
  re::DynamicString::deinit((re::AudioAnimationTimeline *)((char *)this + 40));
  re::StringID::destroyString(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Animation<re::AudioAnimationState>::animationValueType()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73DD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73DD0))
  {
    qword_26AF73DC8 = re::internal::getOrCreateInfo((re::internal *)"AudioAnimationState", (uint64_t (*)(re::internal *))re::allocInfo_AudioAnimationState, (re::IntrospectionBase *(*)(void))re::initInfo_AudioAnimationState, (void (*)(re::IntrospectionBase *))&unk_26AF73DC0, 0);
    __cxa_guard_release(&qword_26AF73DD0);
  }
  return qword_26AF73DC8;
}

uint64_t re::AudioAnimationTimeline::isValidBindPoint()
{
  return 1;
}

_DWORD *re::AnimationImpl<re::AudioAnimationState>::evaluate(_DWORD *result, unsigned char *a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  if (a3)
  {
    if (a2[16]) {
      BOOL v6 = *a2 == 2;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6 || (long long v7 = *a4, *(void *)(a6 + 16) = *((void *)a4 + 2), *(_OWORD *)a6 = v7, result[2] == 49))
    {
      long long v8 = *(uint64_t (**)(void))(*(void *)result + 96);
      return (_DWORD *)v8();
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    uint64_t result = (_DWORD *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationImpl<re::AudioAnimationState>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, a2, a3, a4, *a5);
}

void re::internal::AudioAnimationTimelineCompositionChain::~AudioAnimationTimelineCompositionChain(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::~AnimationCompositionChain((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1;
  *(void *)(a1 + 8) = *a2;
  unint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<re::BindPoint::BindPointData>::operator=(a1 + 16, a2 + 1);
  v3 += 56;
  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)v3, 0);
  ++*(_DWORD *)(v3 + 24);
  return re::BindPoint::baseValueUntyped((re::BindPoint *)a2);
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t result = a1 + 56;
  if (v3)
  {
    if (*(unsigned char *)(a1 + 112)) {
      *(unsigned char *)(a1 + 112) = 0;
    }
    return re::DynamicArray<unsigned long>::deinit(result);
  }
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::apply(uint64_t a1)
{
  unint64_t v2 = (re::BindPoint *)(a1 + 8);
  uint64_t result = re::BindPoint::isAlive((re::BindPoint *)(a1 + 8));
  if (result)
  {
    if (*(void *)(a1 + 72))
    {
      return re::BindPoint::setValue<re::AudioAnimationState>((uint64_t)v2, (long long *)(a1 + 144));
    }
    else
    {
      if (*(unsigned char *)(a1 + 104))
      {
        if (re::BindPoint::isOverridden(v2))
        {
          uint64_t v4 = re::BindPoint::overrideValueUntyped(v2);
          uint64_t v5 = re::BindPoint::baseValueUntyped(v2);
          if (v5)
          {
            long long v6 = *(_OWORD *)v4;
            *(void *)(v5 + 16) = *(void *)(v4 + 16);
            *(_OWORD *)uint64_t v5 = v6;
            re::BindPoint::markAsWritten((uint64_t)v2);
          }
        }
      }
      return re::BindPoint::setIsOverridden((uint64_t)v2, 0);
    }
  }
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::takeSnapshot(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 72))
  {
    if (!*(unsigned char *)(result + 112)) {
      *(unsigned char *)(result + 112) = 1;
    }
    *(_OWORD *)(result + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = *(_OWORD *)(result + 144);
    uint64_t v2 = *(void *)(result + 160);
    goto LABEL_14;
  }
  if (re::BindPoint::supportsOverrideValue((re::BindPoint *)(result + 8)))
  {
    if (!*(unsigned char *)(v1 + 112))
    {
      *(unsigned char *)(v1 + 112) = 1;
      *(void *)(v1 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 0;
      *(_DWORD *)(v1 + 128) = 0;
      *(unsigned char *)(v1 + 132) = 0;
      *(void *)(v1 + 136) = 0;
    }
    uint64_t result = re::BindPoint::baseValueUntyped((re::BindPoint *)(v1 + 8));
LABEL_13:
    uint64_t v2 = *(void *)(result + 16);
    *(_OWORD *)(v1 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = *(_OWORD *)result;
LABEL_14:
    *(void *)(v1 + 136) = v2;
    return result;
  }
  uint64_t result = re::BindPoint::isAlive((re::BindPoint *)(v1 + 8));
  if (result)
  {
    if (!*(unsigned char *)(v1 + 112))
    {
      *(unsigned char *)(v1 + 112) = 1;
      *(void *)(v1 + re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120) = 0;
      *(_DWORD *)(v1 + 128) = 0;
      *(unsigned char *)(v1 + 132) = 0;
      *(void *)(v1 + 136) = 0;
    }
    uint64_t result = re::BindPoint::valueUntyped((re::BindPoint *)(v1 + 8));
    goto LABEL_13;
  }
  if (*(unsigned char *)(v1 + 112)) {
    *(unsigned char *)(v1 + 112) = 0;
  }
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::~AnimationCompositionChain(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C4010;
  uint64_t v2 = a1 + 56;
  if (*(void *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 112)) {
      *(unsigned char *)(a1 + 112) = 0;
    }
    re::DynamicArray<unsigned long>::deinit(a1 + 56);
  }
  *(void *)a1 = &unk_26E6BEEB8;
  re::DynamicArray<unsigned long>::deinit(v2);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit(a1 + 16);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit(a1 + 16);
  return a1;
}

void re::internal::AnimationCompositionChain<re::AudioAnimationState>::~AnimationCompositionChain(uint64_t a1)
{
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::~AnimationCompositionChain(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::BindPoint::setValue<re::AudioAnimationState>(uint64_t result, long long *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(result + 24);
  if (v2)
  {
    uint64_t v4 = (re::BindPoint *)result;
    MEMORY[0x270FA5388](result);
    long long v6 = (void *)((char *)v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v5 >= 0x200) {
      size_t v7 = 512;
    }
    else {
      size_t v7 = v5;
    }
    bzero((char *)v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = *((void *)v4 + 3);
    do
    {
      if (v10 == v9)
      {
        v17[1] = 0;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v26 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v18 = 136315906;
        uint64_t v19 = "operator[]";
        __int16 v20 = 1024;
        int v21 = 797;
        __int16 v22 = 2048;
        uint64_t v23 = v10;
        __int16 v24 = 2048;
        uint64_t v25 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      double v11 = (void *)(*((void *)v4 + 5) + v8);
      if (!*v11) {
        double v11 = (void *)v11[2];
      }
      v6[v9++] = v11;
      v8 += 32;
    }
    while (v2 != v9);
    uint64_t v12 = v2 - 1;
    uint64_t v13 = (*(uint64_t (**)(void, void, void *, uint64_t))(*(void *)*v6 + 120))(*v6, 0, v6 + 1, v12);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t result = re::BindPoint::isOverridden(v4);
      if (!result
        || *(double *)v14 != *(double *)a2
        || *(float *)(v14 + 8) != *((float *)a2 + 2)
        || *(unsigned __int8 *)(v14 + 12) != *((unsigned __int8 *)a2 + 12))
      {
        long long v15 = *a2;
        *(void *)(v14 + 16) = *((void *)a2 + 2);
        *(_OWORD *)uint64_t v14 = v15;
        re::BindPoint::setIsOverridden((uint64_t)v4, 1);
        return re::BindPoint::markAsWritten((uint64_t)v4);
      }
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void, void, void *, uint64_t))(*(void *)*v6 + 88))(*v6, 0, v6 + 1, v12);
      if (result
        && (*(double *)result != *(double *)a2
         || *(float *)(result + 8) != *((float *)a2 + 2)
         || *(unsigned __int8 *)(result + 12) != *((unsigned __int8 *)a2 + 12)))
      {
        long long v16 = *a2;
        *(void *)(result + 16) = *((void *)a2 + 2);
        *(_OWORD *)uint64_t result = v16;
        return re::BindPoint::markAsWritten((uint64_t)v4);
      }
    }
  }
  return result;
}

void *re::allocInfo_AnimationService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_22, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_22))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF73E78, "AnimationService");
    __cxa_guard_release(&_MergedGlobals_22);
  }
  return &unk_26AF73E78;
}

void re::initInfo_AnimationService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x1D19303ADC189562;
  v5[1] = "AnimationService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_AnimationService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_AnimationService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AnimationService", (uint64_t (*)(re::internal *))re::allocInfo_AnimationService, (re::IntrospectionBase *(*)(void))re::initInfo_AnimationService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AnimationService>, this);
}

void *re::allocInfo_BlendParameterInputNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73EF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73EF8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF74150, "BlendParameterInputNode");
    __cxa_guard_release(&qword_26AF73EF8);
  }
  return &unk_26AF74150;
}

void re::initInfo_BlendParameterInputNode(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xA1A56AFCB4DA42A8;
  v14[1] = "BlendParameterInputNode";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F00, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF73F00);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      size_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73F78 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      double v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "defaultValueIndex";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1000000002;
      *(_DWORD *)(v12 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF73F80 = v12;
      __cxa_guard_release(&qword_26AF73F00);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF73F78;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::BlendParameterInputNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendParameterInputNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendParameterInputNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendParameterInputNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

re::StringID *re::internal::defaultConstruct<re::BlendParameterInputNode>(uint64_t a1, uint64_t a2, re::StringID *a3)
{
  uint64_t result = re::StringID::invalid(a3);
  *((_DWORD *)a3 + 4) = -1;
  return result;
}

void re::internal::defaultDestruct<re::BlendParameterInputNode>(int a1, int a2, re::StringID *this)
{
}

re::StringID *re::internal::defaultConstructV2<re::BlendParameterInputNode>(re::StringID *a1)
{
  uint64_t result = re::StringID::invalid(a1);
  *((_DWORD *)a1 + 4) = -1;
  return result;
}

void *re::allocInfo_BlendValueInputNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73F10))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF741C8, "BlendValueInputNode");
    __cxa_guard_release(&qword_26AF73F10);
  }
  return &unk_26AF741C8;
}

void re::initInfo_BlendValueInputNode(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x26A7E5732D4BEA18;
  v14[1] = "BlendValueInputNode";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F18, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF73F18);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      size_t v7 = re::IntrospectionInfo<re::StringID>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF73F88 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      double v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "blendValueIndex";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1000000002;
      *(_DWORD *)(v12 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF73F90 = v12;
      __cxa_guard_release(&qword_26AF73F18);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF73F88;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::BlendValueInputNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendValueInputNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendValueInputNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendValueInputNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

re::StringID *re::internal::defaultConstruct<re::BlendValueInputNode>(uint64_t a1, uint64_t a2, re::StringID *a3)
{
  uint64_t result = re::StringID::invalid(a3);
  *((_DWORD *)a3 + 4) = 0;
  return result;
}

void re::internal::defaultDestruct<re::BlendValueInputNode>(int a1, int a2, re::StringID *this)
{
}

re::StringID *re::internal::defaultConstructV2<re::BlendValueInputNode>(re::StringID *a1)
{
  uint64_t result = re::StringID::invalid(a1);
  *((_DWORD *)a1 + 4) = 0;
  return result;
}

void re::introspect_BlendType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F28, memory_order_acquire) & 1) == 0)
  {
    __int16 v24 = (re *)__cxa_guard_acquire(&qword_26AF73F28);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      long long v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)long long v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Unknown";
      qword_26AF73FB8 = (uint64_t)v26;
      long long v27 = re::introspectionAllocator(v26);
      long long v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)long long v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Invert";
      qword_26AF73FC0 = (uint64_t)v28;
      long long v29 = re::introspectionAllocator(v28);
      long long v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)long long v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "Identity";
      qword_26AF73FC8 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      int v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)int v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "Repeat";
      qword_26AF73FD0 = (uint64_t)v32;
      BOOL v33 = re::introspectionAllocator(v32);
      float v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)float v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "Interpolate";
      qword_26AF73FD8 = (uint64_t)v34;
      int v35 = re::introspectionAllocator(v34);
      double v36 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)double v36 = 1;
      *((void *)v36 + 1) = 5;
      *((void *)v36 + 2) = "AdditiveBlend";
      qword_26AF73FE0 = (uint64_t)v36;
      float v37 = re::introspectionAllocator(v36);
      int v38 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, 24, 8);
      *(_DWORD *)int v38 = 1;
      *((void *)v38 + 1) = 6;
      *((void *)v38 + 2) = "WeightedAdditiveBlend";
      qword_26AF73FE8 = (uint64_t)v38;
      BOOL v39 = re::introspectionAllocator(v38);
      uint64_t v40 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v39 + 32))(v39, 24, 8);
      *(_DWORD *)uint64_t v40 = 1;
      *(void *)(v40 + 8) = 7;
      *(void *)(v40 + 16) = "BlendTypeCount";
      qword_26AF73FF0 = v40;
      __cxa_guard_release(&qword_26AF73F28);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73F30))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF740B8, "BlendType", 1, 1, 1, 1);
    qword_26AF740B8 = (uint64_t)&unk_26E715E00;
    qword_26AF740F8 = (uint64_t)&re::introspect_BlendType(BOOL)::enumTable;
    dword_26AF740C8 = 9;
    __cxa_guard_release(&qword_26AF73F30);
  }
  if ((_MergedGlobals_23 & 1) == 0)
  {
    _MergedGlobals_23 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF740B8, a2);
    uint64_t v42 = 0x6BF759AE6616;
    int v43 = "BlendType";
    v46[0] = 0x31CD534126;
    v46[1] = "uint8_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v46);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v46);
      long long v4 = (unsigned int *)qword_26AF740F8;
      v45[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v46, &v42, 1, 1, (uint64_t)v45);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v44.var0 = 2 * v10;
            v44.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v46, v14, &v44);
            re::StringID::destroyString((re::StringID *)&v44);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              BOOL v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    __int16 v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v44.var0 = 2 * v18;
              v44.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v46, v22, &v44);
              re::StringID::destroyString((re::StringID *)&v44);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v46, v23);
      xmmword_26AF740D8 = (__int128)v44;
      re::StringID::destroyString((re::StringID *)&v42);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v46);
      re::internal::assertLog((re::internal *)5, v41, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "BlendType", v42, v43);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_BlendNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73F38))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF74240, "BlendNode");
    __cxa_guard_release(&qword_26AF73F38);
  }
  return &unk_26AF74240;
}

void re::initInfo_BlendNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0x6BF759A8A3A6;
  v21[1] = "BlendNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F40, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF73F40);
    if (v4)
    {
      unint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_BlendType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "blendType";
      *(void *)(v7 + 16) = &qword_26AF740B8;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF73F98 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_uint32_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "blendNodeParameterIndexStart";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x400000002;
      *(_DWORD *)(v11 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF73FA0 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_uint32_t((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "blendNodeOptionIndexStart";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x800000003;
      *(_DWORD *)(v15 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF73FA8 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_uint32_t((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "outputBlendValueIndex";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0xC00000004;
      *(_DWORD *)(v19 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF73FB0 = v19;
      __cxa_guard_release(&qword_26AF73F40);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF73F98;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::BlendNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

void re::internal::defaultConstruct<re::BlendNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 4) = 0;
}

uint64_t re::internal::defaultConstructV2<re::BlendNode>(uint64_t result)
{
  *(unsigned char *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 4) = 0;
  return result;
}

void *re::allocInfo_BlendTreeDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF73F50))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF742B8, "BlendTreeDefinition");
    __cxa_guard_release(&qword_26AF73F50);
  }
  return &unk_26AF742B8;
}

void re::initInfo_BlendTreeDefinition(re *this, re::IntrospectionBase *a2)
{
  v38[0] = 0x498A493E4355D444;
  v38[1] = "BlendTreeDefinition";
  re::StringID::destroyString((re::StringID *)v38);
  *((_OWORD *)this + 2) = v39;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F58, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF73F58);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "defaultUInt32s";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF74100 = v8;
      uint64_t v9 = (re *)re::introspectionAllocator((re *)v8);
      re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get(v9);
      uint64_t v10 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "parameterInputUInt32Nodes";
      *(void *)(v10 + 16) = &qword_26AF73FF8;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x2800000002;
      *(_DWORD *)(v10 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF74108 = v10;
      uint64_t v11 = re::introspectionAllocator((re *)v10);
      int v13 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "defaultFloats";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x5000000003;
      *(_DWORD *)(v14 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF74110 = v14;
      uint64_t v15 = (re *)re::introspectionAllocator((re *)v14);
      re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get(v15);
      uint64_t v16 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "parameterInputFloatNodes";
      *(void *)(v16 + 16) = &qword_26AF73FF8;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x7800000004;
      *(_DWORD *)(v16 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF74118 = v16;
      BOOL v17 = re::introspectionAllocator((re *)v16);
      uint64_t v19 = re::introspect_uint32_t((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "blendValueCount";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0xA000000005;
      *(_DWORD *)(v20 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF74120 = v20;
      int v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::introspect_uint32_t((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "blendOutputIndex";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0xA400000006;
      *(_DWORD *)(v24 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF74128 = v24;
      uint64_t v25 = (re *)re::introspectionAllocator((re *)v24);
      re::IntrospectionInfo<re::DynamicArray<re::BlendValueInputNode>>::get(v25);
      uint64_t v26 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *(void *)(v26 + 8) = "blendValueInputNodes";
      *(void *)(v26 + 16) = &qword_26AF74038;
      *(void *)(v26 + 24) = 0;
      *(void *)(v26 + 32) = 0xA800000007;
      *(_DWORD *)(v26 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v26 + 48) = 0;
      *(void *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_26AF74130 = v26;
      long long v27 = re::introspectionAllocator((re *)v26);
      long long v29 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 72, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = "blendNodeParameters";
      *(void *)(v30 + 16) = v29;
      *(void *)(v30 + 24) = 0;
      *(void *)(v30 + 32) = 0xD000000008;
      *(_DWORD *)(v30 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v30 + 48) = 0;
      *(void *)(v30 + 56) = 0;
      *(_DWORD *)(v30 + 64) = 0;
      qword_26AF74138 = v30;
      uint64_t v31 = re::introspectionAllocator((re *)v30);
      BOOL v33 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v32);
      uint64_t v34 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 72, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *(void *)(v34 + 8) = "blendNodeOptions";
      *(void *)(v34 + 16) = v33;
      *(void *)(v34 + 24) = 0;
      *(void *)(v34 + 32) = 0xF800000009;
      *(_DWORD *)(v34 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v34 + 48) = 0;
      *(void *)(v34 + 56) = 0;
      *(_DWORD *)(v34 + 64) = 0;
      qword_26AF74140 = v34;
      int v35 = (re *)re::introspectionAllocator((re *)v34);
      re::IntrospectionInfo<re::DynamicArray<re::BlendNode>>::get(v35);
      uint64_t v36 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 72, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = "blendNodes";
      *(void *)(v36 + 16) = &qword_26AF74078;
      *(void *)(v36 + 24) = 0;
      *(void *)(v36 + 32) = 0x1200000000ALL;
      *(_DWORD *)(v36 + re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40) = 0;
      *(void *)(v36 + 48) = 0;
      *(void *)(v36 + 56) = 0;
      *(_DWORD *)(v36 + 64) = 0;
      qword_26AF74148 = v36;
      __cxa_guard_release(&qword_26AF73F58);
    }
  }
  *((void *)this + 2) = 0x14800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 10;
  *((void *)this + 8) = &qword_26AF74100;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::BlendTreeDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BlendTreeDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BlendTreeDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BlendTreeDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v37 = v39;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info = (uint64_t)&unk_26E6C4068;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
    }
    unint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  unint64_t v6 = (re *)re::introspect_uint32_t((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info, 0);
    qword_2687723B0 = 0x2800000003;
    dword_2687723B8 = v10;
    word_2687723BC = 0;
    *(void *)&xmmword_2687723C0 = 0;
    *((void *)&xmmword_2687723C0 + 1) = 0xFFFFFFFFLL;
    qword_2687723D0 = v9;
    unk_2687723D8 = 0;
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info = (uint64_t)&unk_26E6C4068;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      int v13 = v16;
    }
    else {
      int v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_2687723C0 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F60, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF73F60);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF73FF8);
      qword_26AF73FF8 = (uint64_t)&unk_26E6C4100;
      __cxa_guard_release(&qword_26AF73F60);
    }
  }
  if ((byte_26AF73EF1 & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF73F08;
    if (qword_26AF73F08
      || (uint64_t v1 = re::allocInfo_BlendParameterInputNode(a1),
          qword_26AF73F08 = (uint64_t)v1,
          re::initInfo_BlendParameterInputNode((re *)v1, v2),
          (byte_26AF73EF1 & 1) == 0))
    {
      byte_26AF73EF1 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF73FF8, 0);
      qword_26AF74008 = 0x2800000003;
      dword_26AF74010 = v3;
      word_26AF74014 = 0;
      *(void *)&xmmword_26AF74018 = 0;
      *((void *)&xmmword_26AF74018 + 1) = 0xFFFFFFFFLL;
      qword_26AF74028 = (uint64_t)v1;
      unk_26AF74030 = 0;
      qword_26AF73FF8 = (uint64_t)&unk_26E6C4100;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF73FF8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        unint64_t v6 = *(const char **)&v16[7];
      }
      else {
        unint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF74018 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendValueInputNode>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F68, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF73F68);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF74038);
      qword_26AF74038 = (uint64_t)&unk_26E6C4198;
      __cxa_guard_release(&qword_26AF73F68);
    }
  }
  if ((byte_26AF73EF2 & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF73F20;
    if (qword_26AF73F20
      || (uint64_t v1 = re::allocInfo_BlendValueInputNode(a1),
          qword_26AF73F20 = (uint64_t)v1,
          re::initInfo_BlendValueInputNode((re *)v1, v2),
          (byte_26AF73EF2 & 1) == 0))
    {
      byte_26AF73EF2 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF74038, 0);
      qword_26AF74048 = 0x2800000003;
      dword_26AF74050 = v3;
      word_26AF74054 = 0;
      *(void *)&xmmword_26AF74058 = 0;
      *((void *)&xmmword_26AF74058 + 1) = 0xFFFFFFFFLL;
      qword_26AF74068 = (uint64_t)v1;
      unk_26AF74070 = 0;
      qword_26AF74038 = (uint64_t)&unk_26E6C4198;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF74038, (const re::IntrospectionBase *)&v14);
      if (v15) {
        unint64_t v6 = *(const char **)&v16[7];
      }
      else {
        unint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF74058 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}