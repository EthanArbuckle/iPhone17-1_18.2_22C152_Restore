void re::importSkinningAndSkeletalAnimations(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, re::AnimationMetaData *a5@<X4>, unsigned __int8 *a6@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  int v16;
  double v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  unint64_t v25;
  id v26;
  uint64_t vars8;

  v26 = a1;
  re::DynamicArray<re::ModelIOSkeleton>::clear(a2);
  re::DynamicArray<re::ModelIOSkinningData>::clear(a3);
  re::DynamicArray<re::SkeletalPoseSampledAnimation>::clear((uint64_t)a4);
  re::AnimationMetaData::deinit(a5);
  [v26 frameInterval];
  *((void *)a5 + 43) = v11;
  v12 = [v26 count];
  if (v12)
  {
    v13 = v12;
    v14 = 0;
    while (1)
    {
      v15 = [v26 objectAtIndexedSubscript:v14];
      skinnedMeshTraverseNode(v15, a2, a3, a5, a6);
      v16 = *a6;

      if (!v16) {
        break;
      }
      if (v13 == ++v14) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    [v26 frameInterval];
    if (v17 > 0.0
      && ([v26 animations],
          v18 = objc_claimAutoreleasedReturnValue(),
          v19 = [v18 count],
          v18,
          v19))
    {
      v20 = 0;
      while (1)
      {
        v21 = [v26 animations];
        v22 = [v21 objects];
        v23 = [v22 objectAtIndexedSubscript:v20];
        processAnimationObject(v23, a4, (unint64_t)a5, (uint64_t)a6);

        if (!*a6) {
          break;
        }
        ++v20;
        v24 = [v26 animations];
        v25 = [v24 count];

        if (v20 >= v25) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      *a6 = 1;
    }
  }
}

void re::DynamicArray<re::ModelIOSkeleton>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = 168 * v2;
    do
    {
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v4 + v3 + 120));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 96));
      re::FixedArray<re::StringID>::deinit((void *)(v4 + v3 + 72));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 48));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 24));
      re::StringID::destroyString((re::StringID *)(v4 + v3));
      v3 += 168;
    }
    while (v5 != v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::DynamicArray<re::ModelIOSkinningData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = 224 * v2;
    do
    {
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 200));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 176));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 152));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 128));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + v3 + 104));
      re::DynamicString::deinit((re::DynamicString *)(v4 + v3 + 72));
      v3 += 224;
    }
    while (v5 != v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::DynamicArray<re::SkeletalPoseSampledAnimation>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = &v3[15 * v2];
    uint64_t v5 = v3;
    do
    {
      *uint64_t v5 = &unk_26E6C0FD0;
      re::FixedArray<re::SkeletalPose>::deinit(v5 + 11);
      *uint64_t v5 = &unk_26E6BF1F0;
      re::DynamicString::deinit((re::DynamicString *)(v5 + 5));
      re::StringID::destroyString((re::StringID *)(v5 + 3));
      v3 += 15;
      v5 += 15;
    }
    while (v5 != v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void skinnedMeshTraverseNode(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _anonymous_namespace_ *a4@<X3>, unsigned __int8 *a5@<X8>)
{
  id v9 = a1;
  if (v9)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      processForMeshData((uint64_t)v21, v9, a2, a3, a4);
      if (v21[0])
      {
        v10 = [v9 name];
        v11 = v10;
        if (v10)
        {
          v10 = (void *)[v10 UTF8String];
          v12 = (const char *)v10;
        }
        else
        {
          v12 = "(unnamed)";
        }
        double v13 = re::DynamicArray<re::DynamicString>::add(a4, &v24);
        if ((void)v24)
        {
          if (BYTE8(v24)) {
            (*(void (**)(double))(*(void *)v24 + 40))(v13);
          }
          long long v24 = 0u;
          long long v25 = 0u;
        }
      }
    }
    else
    {
      v21[0] = 1;
    }
  }
  else
  {
    v21[0] = 0;
    *(void *)&long long v22 = 1024;
    *((void *)&v22 + 1) = &re::AnimationErrorCategory(void)::instance;
    v23[0] = v24;
    v23[1] = v25;
  }

  if (!v21[0])
  {
    *a5 = 0;
    *(_OWORD *)(a5 + 8) = v22;
    *((void *)a5 + 3) = *(void *)&v23[0];
    *((void *)a5 + 6) = *((void *)&v23[1] + 1);
    *((_OWORD *)a5 + 2) = *(_OWORD *)((char *)v23 + 8);
    memset(v23, 0, sizeof(v23));
LABEL_24:
    if (*(void *)&v23[0] && (BYTE8(v23[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v23[0] + 40))();
    }
    goto LABEL_27;
  }
  v14 = [v9 children];
  uint64_t v15 = [v14 count];
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    while (1)
    {
      v18 = [v14 objects];
      v19 = [v18 objectAtIndexedSubscript:v17];

      skinnedMeshTraverseNode(v19, a2, a3, a4);
      LODWORD(v18) = *a5;

      if (!v18) {
        break;
      }
      if (v16 == ++v17) {
        goto LABEL_19;
      }
    }
  }
  else
  {
LABEL_19:
    int v20 = v21[0];
    *a5 = v21[0];
    if (!v20)
    {
      *(_OWORD *)(a5 + 8) = v22;
      *((void *)a5 + 3) = *(void *)&v23[0];
      *((void *)a5 + 6) = *((void *)&v23[1] + 1);
      *((_OWORD *)a5 + 2) = *(_OWORD *)((char *)v23 + 8);
      memset(v23, 0, sizeof(v23));
    }
  }

  if (!v21[0]) {
    goto LABEL_24;
  }
LABEL_27:
}

uint64_t re::isSkinnedMesh(re *this, const MDLMesh *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v2 = this;
  uint64_t v3 = v2;
  if (v2)
  {
    long long v11 = 0u;
    long long v12 = 0u;
    long long v10 = 0u;
    uint64_t v4 = [(re *)v2 components];
    uint64_t v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v10;
      while (2)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v10 != v6) {
            objc_enumerationMutation(v4);
          }
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v5 = 1;
            goto LABEL_12;
          }
        }
        uint64_t v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  else
  {
    uint64_t v5 = 0;
  }

  return v5;
}

void *re::DynamicArray<re::ModelIOSkeleton>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      result = (void *)*result;
      if (!*v5)
      {
        result = (void *)re::DynamicArray<re::ModelIOSkeleton>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          uint64_t v2 = 168 * a2;
          result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        long long v10 = &v8[21 * v9];
        v21 = v7;
        do
        {
          uint64_t v11 = *v8;
          unint64_t *v7 = *v7 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          unint64_t *v7 = *v8 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
          v7[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          *((_DWORD *)v7 + 4) = *((_DWORD *)v8 + 4);
          v7[4] = 0;
          v7[5] = 0;
          v7[3] = 0;
          v7[3] = v8[3];
          v8[3] = 0;
          unint64_t v12 = v7[5];
          unint64_t v13 = v8[5];
          v7[4] = v8[4];
          v7[5] = v13;
          v8[4] = 0;
          v8[5] = v12;
          v7[7] = 0;
          v7[8] = 0;
          v7[6] = 0;
          v7[6] = v8[6];
          v8[6] = 0;
          unint64_t v14 = v7[8];
          unint64_t v15 = v8[8];
          v7[7] = v8[7];
          v7[8] = v15;
          v8[7] = 0;
          v8[8] = v14;
          v7[9] = 0;
          v7[10] = 0;
          v7[11] = 0;
          v7[9] = v8[9];
          v8[9] = 0;
          unint64_t v16 = v7[11];
          unint64_t v17 = v8[11];
          v7[10] = v8[10];
          v7[11] = v17;
          v8[10] = 0;
          v8[11] = v16;
          v7[12] = 0;
          v7[13] = 0;
          v7[14] = 0;
          v7[12] = v8[12];
          v8[12] = 0;
          unint64_t v18 = v7[14];
          unint64_t v19 = v8[14];
          v7[13] = v8[13];
          v7[14] = v19;
          v8[13] = 0;
          v8[14] = v18;
          *(_OWORD *)(v7 + 15) = 0u;
          int v20 = v7 + 15;
          *((_DWORD *)v20 + 8) = 0;
          *((_OWORD *)v20 + 1) = 0u;
          *(void *)((char *)v20 + 36) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v20, v8 + 15);
          re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v8 + 15);
          re::FixedArray<CoreIKTransform>::deinit(v8 + 12);
          re::FixedArray<re::StringID>::deinit(v8 + 9);
          re::FixedArray<CoreIKTransform>::deinit(v8 + 6);
          re::FixedArray<CoreIKTransform>::deinit(v8 + 3);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 21;
          v7 = v20 + 6;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
        v7 = v21;
      }
      result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::FixedArray<simd_double4x4>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 57)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 128, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  unint64_t v5 = a3 << 7;
  uint64_t v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3 << 7, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 128);
    v8 = (_OWORD *)((char *)v8 + v5 - 128);
  }
  v8[6] = 0u;
  v8[7] = 0u;
  v8[4] = 0u;
  v8[5] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  _OWORD *v8 = 0u;
  v8[1] = 0u;
}

void *re::DynamicArray<re::ModelIOSkinningData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      result = (void *)*result;
      if (!*v5)
      {
        result = (void *)re::DynamicArray<re::ModelIOSkinningData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xE0uLL))
        {
          uint64_t v2 = 224 * a2;
          result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 224 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 224, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        long long v10 = &v8[28 * v9];
        v34 = v7;
        do
        {
          *(_OWORD *)uint64_t v7 = *(_OWORD *)v8;
          long long v11 = *((_OWORD *)v8 + 1);
          long long v12 = *((_OWORD *)v8 + 2);
          long long v13 = *((_OWORD *)v8 + 3);
          *((_DWORD *)v7 + 16) = *((_DWORD *)v8 + 16);
          *((_OWORD *)v7 + 2) = v12;
          *((_OWORD *)v7 + 3) = v13;
          *((_OWORD *)v7 + 1) = v11;
          *(_OWORD *)(v7 + 9) = 0u;
          *(_OWORD *)(v7 + 11) = 0u;
          unint64_t v14 = (re::DynamicString *)(v8 + 9);
          v7[9] = v8[9];
          v8[9] = 0;
          v7[12] = v8[12];
          v8[12] = 0;
          uint64_t v16 = v7[10];
          uint64_t v15 = v7[11];
          uint64_t v17 = v8[11];
          v7[10] = v8[10];
          v7[11] = v17;
          v8[10] = v16;
          v8[11] = v15;
          v7[13] = 0;
          v7[14] = 0;
          v7[15] = 0;
          unint64_t v18 = v8 + 13;
          v7[13] = v8[13];
          v8[13] = 0;
          uint64_t v19 = v7[15];
          uint64_t v20 = v8[15];
          v7[14] = v8[14];
          v7[15] = v20;
          v8[14] = 0;
          v8[15] = v19;
          v7[16] = 0;
          v7[17] = 0;
          v7[18] = 0;
          v21 = v8 + 16;
          v7[16] = v8[16];
          v8[16] = 0;
          uint64_t v22 = v7[18];
          uint64_t v23 = v8[18];
          v7[17] = v8[17];
          v7[18] = v23;
          v8[17] = 0;
          v8[18] = v22;
          v7[19] = 0;
          v7[20] = 0;
          v7[21] = 0;
          long long v24 = v8 + 19;
          v7[19] = v8[19];
          v8[19] = 0;
          uint64_t v25 = v7[21];
          uint64_t v26 = v8[21];
          v7[20] = v8[20];
          v7[21] = v26;
          v8[20] = 0;
          v8[21] = v25;
          v7[22] = 0;
          v7[23] = 0;
          v7[24] = 0;
          v27 = v8 + 22;
          v7[22] = v8[22];
          v8[22] = 0;
          uint64_t v28 = v7[24];
          uint64_t v29 = v8[24];
          v7[23] = v8[23];
          v7[24] = v29;
          v8[23] = 0;
          v8[24] = v28;
          v7[25] = 0;
          v7[26] = 0;
          v7[27] = 0;
          uint64_t v31 = v8[25];
          v30 = v8 + 25;
          v7[25] = v31;
          uint64_t *v30 = 0;
          uint64_t v32 = v7[27];
          uint64_t v33 = v30[2];
          v7[26] = v30[1];
          v7[27] = v33;
          v30[1] = 0;
          v30[2] = v32;
          re::FixedArray<CoreIKTransform>::deinit(v30);
          re::FixedArray<CoreIKTransform>::deinit(v27);
          re::FixedArray<CoreIKTransform>::deinit(v24);
          re::FixedArray<CoreIKTransform>::deinit(v21);
          re::FixedArray<CoreIKTransform>::deinit(v18);
          re::DynamicString::deinit(v14);
          v8 = v30 + 3;
          v7 += 28;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
        uint64_t v7 = v34;
      }
      result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::types::Ok<re::GeomSkeleton>::Ok(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = a2[4];
  a2[4] = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v6 = a2[6];
  *(void *)(a1 + 40) = a2[5];
  *(void *)(a1 + 48) = v6;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = a2[7];
  a2[7] = v7;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v8 = a2[9];
  *(void *)(a1 + 64) = a2[8];
  *(void *)(a1 + 72) = v8;
  a2[8] = 0;
  a2[9] = 0;
  uint64_t v9 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = a2[10];
  a2[10] = v9;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t v10 = a2[12];
  *(void *)(a1 + 88) = a2[11];
  *(void *)(a1 + 96) = v10;
  a2[11] = 0;
  a2[12] = 0;
  uint64_t v11 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = a2[13];
  a2[13] = v11;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 148) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 112), a2 + 14);
  return a1;
}

uint64_t re::Result<re::GeomSkeleton,re::DetailedError>::Result(uint64_t a1, uint64_t *a2)
{
  *(unsigned char *)a1 = 1;
  uint64_t v3 = *a2;
  *(void *)(a1 + 8) = *(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)(a1 + 8) = *a2 & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + 16) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 24) = a2[2];
  *(void *)(a1 + 32) = v4;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = a2[4];
  a2[4] = v5;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a2[6];
  *(void *)(a1 + 48) = a2[5];
  *(void *)(a1 + 56) = v6;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2[7];
  a2[7] = v7;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  uint64_t v8 = a2[9];
  *(void *)(a1 + 72) = a2[8];
  *(void *)(a1 + 80) = v8;
  a2[8] = 0;
  a2[9] = 0;
  uint64_t v9 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = a2[10];
  a2[10] = v9;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v10 = a2[12];
  *(void *)(a1 + 96) = a2[11];
  *(void *)(a1 + 104) = v10;
  a2[11] = 0;
  a2[12] = 0;
  uint64_t v11 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = a2[13];
  a2[13] = v11;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 156) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 120), a2 + 14);
  return a1;
}

void re::types::Ok<re::SkeletalPoseSampledAnimationAssetData>::Ok(uint64_t a1, uint64_t a2)
{
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(a1, a2);
  *(void *)uint64_t v3 = &unk_26E6D0D68;
  *(void *)(v3 + 136) = 0;
  *(void *)(v3 + 144) = 0;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = 0;
  uint64_t v4 = *(void *)(v3 + 128);
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v4;
  uint64_t v5 = *(void *)(v3 + 144);
  *(void *)(v3 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v5;
  *(void *)(v3 + 184) = 0;
  *(void *)(v3 + 160) = 0;
  *(void *)(v3 + 168) = 0;
  *(void *)(v3 + 152) = 0;
  *(_DWORD *)(v3 + 176) = 0;
  uint64_t v6 = *(void *)(a2 + 160);
  *(void *)(v3 + 152) = *(void *)(a2 + 152);
  *(void *)(v3 + 160) = v6;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  uint64_t v7 = *(void *)(v3 + 168);
  *(void *)(v3 + 168) = *(void *)(a2 + 168);
  *(void *)(a2 + 168) = v7;
  uint64_t v8 = *(void *)(v3 + 184);
  *(void *)(v3 + 184) = *(void *)(a2 + 184);
  *(void *)(a2 + 184) = v8;
  ++*(_DWORD *)(a2 + 176);
  ++*(_DWORD *)(v3 + 176);
  LOWORD(v8) = *(_WORD *)(a2 + 192);
  *(unsigned char *)(v3 + 194) = *(unsigned char *)(a2 + 194);
  *(_WORD *)(v3 + 192) = v8;
}

uint64_t re::Result<re::SkeletalPoseSampledAnimationAssetData,re::DetailedError>::Result(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 1;
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(a1 + 8, a2);
  *(void *)(a1 + 8) = &unk_26E6D0D68;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = 0;
  uint64_t v4 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 136) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v4;
  uint64_t v5 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v5;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  uint64_t v6 = *(void *)(a2 + 160);
  *(void *)(a1 + 160) = *(void *)(a2 + 152);
  *(void *)(a1 + 168) = v6;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  uint64_t v7 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = *(void *)(a2 + 168);
  *(void *)(a2 + 168) = v7;
  uint64_t v8 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = *(void *)(a2 + 184);
  *(void *)(a2 + 184) = v8;
  ++*(_DWORD *)(a2 + 176);
  ++*(_DWORD *)(a1 + 184);
  LOWORD(v8) = *(_WORD *)(a2 + 192);
  *(unsigned char *)(a1 + 202) = *(unsigned char *)(a2 + 194);
  *(_WORD *)(a1 + 200) = v8;
  return a1;
}

void *re::DynamicArray<re::SkeletalPoseSampledAnimation>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      result = (void *)*result;
      if (!*v5)
      {
        result = (void *)re::DynamicArray<re::SkeletalPoseSampledAnimation>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x78uLL))
        {
          uint64_t v2 = 120 * a2;
          result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 120 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 120, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 120 * v9;
        do
        {
          long long v12 = (void *)(v8 + v10);
          re::SampledAnimation<re::SkeletalPose>::SampledAnimation((uint64_t)&v7[v10 / 8], (void *)(v8 + v10));
          *(void *)uint64_t v13 = &unk_26E6C1190;
          __int16 v14 = *(_WORD *)(v8 + v10 + 112);
          *(unsigned char *)(v13 + 114) = *(unsigned char *)(v8 + v10 + 114);
          *(_WORD *)(v13 + 112) = v14;
          void *v12 = &unk_26E6C0FD0;
          re::FixedArray<re::SkeletalPose>::deinit((void *)(v8 + v10 + 88));
          void *v12 = &unk_26E6BF1F0;
          re::DynamicString::deinit((re::DynamicString *)(v8 + v10 + 40));
          re::StringID::destroyString((re::StringID *)(v8 + v10 + 24));
          v10 += 120;
        }
        while (v11 != v10);
        uint64_t v8 = v5[4];
      }
      result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::internal::DataPayload::DataPayload(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, uint64_t a9)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = a2;
  *(void *)a1 = &unk_26E715800;
  *(unsigned char *)(a1 + 32) = a7;
  *(unsigned char *)(a1 + 33) = a3;
  *(void *)(a1 + 40) = a4;
  *(void *)(a1 + 48) = a5;
  if (a8) {
    uint64_t v17 = a8;
  }
  else {
    uint64_t v17 = a2;
  }
  *(void *)(a1 + 56) = a6;
  *(void *)(a1 + 64) = v17;
  *(void *)(a1 + 96) = 0;
  if (a9)
  {
    *(void *)(a1 + 72) = &unk_26E715848;
    *(void *)(a1 + 80) = a9;
    *(void *)(a1 + 96) = a1 + 72;
  }
  return a1;
}

void re::internal::DataPayload::~DataPayload(re::internal::DataPayload *this)
{
  v8[3] = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26E715800;
  uint64_t v2 = *((void *)this + 8);
  uint64_t v3 = *((void *)this + 12);
  v6[0] = v2;
  if (!v3) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  uint64_t v4 = (char *)this + 72;
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v6);
  v6[0] = &unk_26E715848;
  v6[1] = re::internal::DataPayload::defaultFreeFunction;
  uint64_t v7 = (char *)v6;
  if ((void *)((char *)this + 72) != v6)
  {
    uint64_t v5 = (char *)*((void *)this + 12);
    if (v5 == v4)
    {
      uint64_t v7 = 0;
      v8[0] = &unk_26E715848;
      v8[1] = re::internal::DataPayload::defaultFreeFunction;
      (*(void (**)(char *, void *))(*((void *)this + 9) + 24))((char *)this + 72, v6);
      (*(void (**)(void))(**((void **)this + 12) + 32))(*((void *)this + 12));
      *((void *)this + 12) = 0;
      uint64_t v7 = (char *)v6;
      (*(void (**)(void *, char *))(v8[0] + 24))(v8, (char *)this + 72);
      (*(void (**)(void *))(v8[0] + 32))(v8);
    }
    else
    {
      *((void *)this + 9) = &unk_26E715848;
      *((void *)this + 10) = re::internal::DataPayload::defaultFreeFunction;
      uint64_t v7 = v5;
    }
    *((void *)this + 12) = v4;
  }
  std::__function::__value_func<void ()(void const*)>::~__value_func[abi:nn180100](v6);
  *((void *)this + 3) = 0;
  *((void *)this + 8) = 0;
  std::__function::__value_func<void ()(void const*)>::~__value_func[abi:nn180100]((void *)this + 9);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::internal::DataPayload::~DataPayload(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::GeomModelDescriptor::makeCFDataPayload(uint64_t *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  CFRetain(v4);
  int v6 = 0;
  switch(*(unsigned char *)(a2 + 8))
  {
    case 0:
    case 1:
      goto LABEL_6;
    case 2:
    case 3:
      int v6 = 1;
      goto LABEL_6;
    case 4:
    case 5:
    case 6:
    case 0xB:
      int v6 = 3;
      goto LABEL_6;
    case 7:
    case 8:
      int v6 = 7;
      goto LABEL_6;
    case 9:
    case 0xA:
      int v6 = 15;
LABEL_6:
      unsigned int BytePtr = CFDataGetBytePtr((CFDataRef)v4);
      char v8 = (((*(_DWORD *)(a2 + 24) + BytePtr) | (*(_DWORD *)(a2 + 24) + BytePtr + *(_DWORD *)(a2 + 32))) & v6) == 0;
      uint64_t v9 = (re *)CFDataGetBytePtr((CFDataRef)v4);
      unint64_t v10 = re::globalAllocators(v9);
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 104, 8);
      uint64_t result = re::internal::DataPayload::DataPayload(v11, (uint64_t)v9, *(unsigned char *)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 32), *(void *)(a2 + 24), v8, (uint64_t)v4, (uint64_t)re::internal::freeCoreFoundationData);
      break;
    default:
      uint64_t result = 0;
      if (*(unsigned __int8 *)(a2 + 8) != 255)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Unsupported type", "!\"Unreachable code\"", "alignOfGeomModelValueType", 110);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D3F724);
      }
      return result;
  }
  *a1 = result;
  return result;
}

_anonymous_namespace_ *re::GeomModelDescriptor::validateIndexType@<X0>(_anonymous_namespace_ *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 < 6)
  {
    *(unsigned char *)a3 = 1;
  }
  else
  {
    long long v4 = v7;
    uint64_t v5 = v8;
    uint64_t v6 = v9;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 100;
    *(void *)(a3 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v4;
    *(void *)(a3 + 40) = v5;
    *(void *)(a3 + 48) = v6;
  }
  return result;
}

__n128 re::GeomModelDescriptor::validateIfCoreAttribute@<Q0>(uint64_t a1@<X1>, int a2@<W2>, int a3@<W3>, uint64_t a4@<X8>)
{
  if (*(void *)(a1 + 8)) {
    long long v7 = *(const char **)(a1 + 16);
  }
  else {
    long long v7 = (const char *)(a1 + 9);
  }
  uint64_t v8 = (_anonymous_namespace_ *)strcmp(v7, "vertexPosition");
  if (!v8)
  {
    if ((a3 & 0xFFFFFFFD) != 9)
    {
      uint64_t v15 = "Only float[3] supported for positions.";
      goto LABEL_35;
    }
    if (a2 != 1)
    {
      uint64_t v15 = "Position must be at the vertex rate.";
      goto LABEL_35;
    }
LABEL_30:
    *(unsigned char *)a4 = 1;
    return result;
  }
  unint64_t v10 = (_anonymous_namespace_ *)strcmp(v7, "vertexUV");
  if (!v10)
  {
    if (a3 != 8)
    {
      uint64_t v15 = "Only float[2] supported for uvs.";
      goto LABEL_35;
    }
    if ((a2 & 0xFFFFFFFD) != 1)
    {
      uint64_t v15 = "Uvs must be at either the vertex or face-varying rate.";
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  uint64_t v11 = (_anonymous_namespace_ *)strcmp(v7, "vertexNormal");
  if (!v11)
  {
    if ((a3 & 0xFFFFFFFD) != 9)
    {
      uint64_t v15 = "Only float[3] supported for normals.";
      goto LABEL_35;
    }
    if ((a2 - 4) <= 0xFFFFFFFC)
    {
      uint64_t v15 = "Normals must be at the vertex, face, or face-varying rate.";
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  long long v12 = (_anonymous_namespace_ *)strcmp(v7, "vertexTangent");
  if (!v12)
  {
    if ((a3 & 0xFFFFFFFD) != 9)
    {
      uint64_t v15 = "Only float[3] supported for tangents.";
      goto LABEL_35;
    }
    if ((a2 & 0xFFFFFFFD) != 1)
    {
      uint64_t v15 = "Tangents must be at the vertex or face-varying rate.";
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  uint64_t v13 = (_anonymous_namespace_ *)strcmp(v7, "vertexBitangent");
  if (!v13)
  {
    if ((a3 & 0xFFFFFFFD) != 9)
    {
      uint64_t v15 = "Only float[3] supported for bitangents.";
      goto LABEL_35;
    }
    if ((a2 & 0xFFFFFFFD) != 1)
    {
      uint64_t v15 = "Bitangents must be at the vertex or face-varying rate.";
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  __int16 v14 = (_anonymous_namespace_ *)strcmp(v7, "vertexColor");
  if (v14) {
    goto LABEL_30;
  }
  if (a3 != 10)
  {
    uint64_t v15 = "Only float[4] supported for colors.";
    goto LABEL_35;
  }
  if (a2 != 4) {
    goto LABEL_30;
  }
  uint64_t v15 = "Colors cannot be at the user-managed rate.";
LABEL_35:
  __n128 result = v18;
  uint64_t v16 = v19;
  uint64_t v17 = v20;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 100;
  *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
  *(__n128 *)(a4 + 24) = result;
  *(void *)(a4 + 40) = v16;
  *(void *)(a4 + 48) = v17;
  return result;
}

void re::GeomModelDescriptor::setSurfaceTopology(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (!*(void *)a3)
  {
    long long v14 = *(_OWORD *)v25;
    uint64_t v15 = *(void *)&v25[16];
    uint64_t v16 = v26;
    *(unsigned char *)a5 = 0;
    *(void *)(a5 + 8) = 100;
    *(void *)(a5 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a5 + 24) = v14;
    *(void *)(a5 + 40) = v15;
    *(void *)(a5 + 48) = v16;
    return;
  }
  unint64_t v10 = re::GeomModelDescriptor::validateIndexType(a1, *(unsigned __int8 *)(a3 + 8), (uint64_t)v25);
  if (v25[0])
  {
    if (!*(void *)a4)
    {
      uint64_t v17 = "Null vertex indices per face buffer.";
LABEL_20:
      long long v18 = v21;
      uint64_t v19 = v22;
      uint64_t v20 = v23;
      *(unsigned char *)a5 = 0;
      *(void *)(a5 + 8) = 100;
      *(void *)(a5 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a5 + 24) = v18;
      *(void *)(a5 + 40) = v19;
      *(void *)(a5 + 48) = v20;
      goto LABEL_21;
    }
    re::GeomModelDescriptor::validateIndexType(v10, *(unsigned __int8 *)(a4 + 8), (uint64_t)&v21);
    uint64_t v11 = (_anonymous_namespace_ *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)v25, (uint64_t)&v21);
    if (!(_BYTE)v21)
    {
      uint64_t v11 = v23;
      if (v23)
      {
        if (v24) {
          uint64_t v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v23 + 40))();
        }
      }
    }
    if (v25[0])
    {
      if (*(void *)(a3 + 32) && *(void *)(a4 + 32))
      {
        *((void *)a1 + 2) = a2;
        *((void *)a1 + 3) = *(void *)(a3 + 16);
        re::GeomModelDescriptor::makeCFDataPayload((uint64_t *)&v21, a3);
        uint64_t v12 = *((void *)a1 + 4);
        *((void *)a1 + 4) = v21;
        if (v12) {

        }
        re::GeomModelDescriptor::makeCFDataPayload((uint64_t *)&v21, a4);
        uint64_t v13 = *((void *)a1 + 5);
        *((void *)a1 + 5) = v21;
        if (v13) {

        }
        *(unsigned char *)a5 = 1;
        goto LABEL_21;
      }
      uint64_t v17 = "Zero stride provided.";
      goto LABEL_20;
    }
  }
  *(unsigned char *)a5 = 0;
  *(_OWORD *)(a5 + 8) = *(_OWORD *)&v25[8];
  *(void *)(a5 + 24) = v26;
  *(void *)(a5 + 48) = v28;
  *(_OWORD *)(a5 + 32) = v27;
  uint64_t v28 = 0;
  uint64_t v26 = 0;
  long long v27 = 0uLL;
LABEL_21:
  if (!v25[0] && v26 && (v27 & 1) != 0) {
    (*(void (**)(void))(*(void *)v26 + 40))();
  }
}

void re::GeomModelDescriptor::makeFromGeomMeshes(_anonymous_namespace_ *a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = (unint64_t)a1;
  uint64_t v229 = *MEMORY[0x263EF8340];
  __int16 v190 = 0;
  char v191 = 0;
  long long v192 = 0u;
  memset(v193, 0, sizeof(v193));
  long long v194 = 0u;
  long long v195 = 0u;
  uint64_t v196 = 0x7FFFFFFFLL;
  memset(v197, 0, sizeof(v197));
  int v198 = 0;
  memset(v199, 0, sizeof(v199));
  uint64_t v200 = 0x7FFFFFFFLL;
  *((void *)&v201 + 1) = 0;
  long long v202 = 0uLL;
  uint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v201, 0);
  if (!*(void *)(v3 + 16))
  {
    re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)&v209, (uint64_t)&v190);
    *a2 = 1;
    re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)(a2 + 8), (uint64_t)&v209);
    if ((void)v216)
    {
      if (BYTE8(v216)) {
        (*(void (**)(void))(*(void *)v216 + 40))();
      }
      long long v216 = 0u;
      long long v217 = 0u;
    }
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v215);
    re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)v214);
    v156.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v212);
    if (*((void *)&v211 + 1))
    {

      *((void *)&v211 + 1) = 0;
    }
    if ((void)v211)
    {

      *(void *)&long long v211 = 0;
    }
    if (v209.n128_u64[1]) {

    }
    goto LABEL_465;
  }
  v160 = a2;
  uint64_t v6 = *(void *)(v3 + 32);
  unint64_t v7 = *(unsigned int *)(v6 + 40);
  uint64_t v189 = 0;
  v187[2] = 0;
  v187[1] = 0;
  int v188 = 0;
  re::DynamicArray<int>::setCapacity(v187, v7);
  ++v188;
  int v186 = 0;
  unint64_t v9 = *(void *)(v6 + 40);
  if (v9)
  {
    unsigned int v10 = 0;
    do
    {
      re::DynamicArray<int>::add(v187, &v186);
      ++v10;
      unint64_t v9 = *(void *)(v6 + 40);
    }
    while (v10 < v9);
  }
  unint64_t v11 = (unint64_t)v225;
  unint64_t v12 = *(void *)(v3 + 16);
  if (v12 >= 2)
  {
    unint64_t v9 = 1;
    while (1)
    {
      ++v186;
      if (v12 <= v9) {
        break;
      }
      LODWORD(v2) = -1;
      while (1)
      {
        uint64_t v13 = *(void *)(v3 + 32);
        unint64_t v2 = (v2 + 1);
        if (v2 >= *(_DWORD *)(v13 + 736 * v9 + 40)) {
          break;
        }
        re::DynamicArray<int>::add(v187, &v186);
        unint64_t v12 = *(void *)(v3 + 16);
        if (v12 <= v9) {
          goto LABEL_479;
        }
      }
      canAppendGeomMeshToGeomMesh = (_anonymous_namespace_ *)re::internal::canAppendGeomMeshToGeomMesh((re::internal *)(v13 + 736 * v9), (const re::GeomMesh *)v6, v8);
      if ((canAppendGeomMeshToGeomMesh & 1) == 0)
      {
        __n128 v156 = v209;
        long long v158 = v210;
        unsigned char *v160 = 0;
        *((void *)v160 + 1) = 100;
        *((void *)v160 + 2) = re::AssetErrorCategory(void)::instance;
        *(__n128 *)(v160 + 24) = v156;
        *(_OWORD *)(v160 + 40) = v158;
        goto LABEL_462;
      }
      unint64_t v12 = *(void *)(v3 + 16);
      if (v12 <= v9) {
        goto LABEL_481;
      }
      re::internal::appendGeomMeshToGeomMesh((_DWORD *)(*(void *)(v3 + 32) + 736 * v9), v6);
      unint64_t v9 = (v9 + 1);
      unint64_t v12 = *(void *)(v3 + 16);
      if (v12 <= v9)
      {
        unint64_t v9 = *(void *)(v6 + 40);
        goto LABEL_16;
      }
    }
LABEL_479:
    v225[0] = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(location[0]) = 136315906;
    *(id *)((char *)location + 4) = "operator[]";
    WORD2(location[1]) = 1024;
    *(_DWORD *)((char *)&location[1] + 6) = 789;
    WORD1(location[2]) = 2048;
    *(id *)((char *)&location[2] + 4) = (id)v9;
    WORD2(location[3]) = 2048;
    *(id *)((char *)&location[3] + 6) = (id)v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_480:
    v225[0] = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(location[0]) = 136315906;
    *(id *)((char *)location + 4) = "operator[]";
    WORD2(location[1]) = 1024;
    *(_DWORD *)((char *)&location[1] + 6) = 797;
    WORD1(location[2]) = 2048;
    *(id *)((char *)&location[2] + 4) = (id)v12;
    WORD2(location[3]) = 2048;
    *(id *)((char *)&location[3] + 6) = (id)v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_481:
    v225[0] = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(location[0]) = 136315906;
    *(id *)((char *)location + 4) = "operator[]";
    WORD2(location[1]) = 1024;
    *(_DWORD *)((char *)&location[1] + 6) = 789;
    WORD1(location[2]) = 2048;
    *(id *)((char *)&location[2] + 4) = (id)v9;
    WORD2(location[3]) = 2048;
    *(id *)((char *)&location[3] + 6) = (id)v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_482:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_483:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v2;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_484:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_485:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v2;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_486:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_487:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v2;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_488:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_489:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_490:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_491:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_492:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 797;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v12;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_493:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_494:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_495:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_496:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_497:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_498:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v11;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_499:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_500:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_501:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_502:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_503:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_504:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v3;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_505:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_506:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_507:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_508:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_509:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_510:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v2;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_511:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_512:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_513:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_514:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    uint64_t v80 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 797;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v9;
    HIWORD(v206[1]) = 2048;
    v206[2] = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_515:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v80;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_516:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v80;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_517:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    unint64_t v9 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v80;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_518:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_519:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v11;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_520:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_521:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_522:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v3;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_523:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_524:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "copy";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 643;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = -1;
    HIWORD(v206[1]) = 2048;
    v206[2] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_525:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "copy";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 643;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = -1;
    HIWORD(v206[1]) = 2048;
    v206[2] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_526:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    size_t v81 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "copy";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 643;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = -1;
    HIWORD(v206[1]) = 2048;
    v206[2] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_527:
    re::internal::assertLog((re::internal *)7, v24, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v11, v11, v2);
    _os_crash();
    __break(1u);
LABEL_528:
    re::internal::assertLog((re::internal *)7, v28, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v3, v3, v2);
    _os_crash();
    __break(1u);
LABEL_529:
    re::internal::assertLog((re::internal *)7, v51, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v3, v3, v81);
    _os_crash();
    __break(1u);
LABEL_530:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_531:
    uint64_t v203 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)(v11 + 116) = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)(v11 + 126) = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)(v11 + 132) = v2;
    *(_WORD *)&v228[28] = 2048;
    *(void *)(v11 + 142) = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_532:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_533:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_534:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_535:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_536:
    uint64_t __src = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v228 = 136315906;
    *(void *)&v228[4] = "operator[]";
    *(_WORD *)&v228[12] = 1024;
    *(_DWORD *)&v228[14] = 601;
    *(_WORD *)&v228[18] = 2048;
    *(void *)&v228[20] = v12;
    *(_WORD *)&v228[28] = 2048;
    *(void *)&v228[30] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_537:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v12;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_538:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_539:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v2;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_540:
    *(void *)v228 = 0;
    long long v213 = 0u;
    long long v212 = 0u;
    long long v210 = 0u;
    long long v211 = 0u;
    __n128 v209 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v204 = 136315906;
    *(void *)&v204[4] = "operator[]";
    __int16 v205 = 1024;
    LODWORD(v206[0]) = 601;
    WORD2(v206[0]) = 2048;
    *(void *)((char *)v206 + 6) = v9;
    HIWORD(v206[1]) = 2048;
    v206[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_541:
    re::internal::assertLog((re::internal *)4, v30, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_542:
    re::internal::assertLog((re::internal *)4, v32, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_543:
    re::internal::assertLog((re::internal *)4, v34, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_544:
    re::internal::assertLog((re::internal *)4, v36, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_545:
    re::internal::assertLog((re::internal *)4, v46, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_546:
    re::internal::assertLog((re::internal *)4, v48, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_547:
    re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_548:
    re::internal::assertLog((re::internal *)4, v28, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_549:
    re::internal::assertLog((re::internal *)4, v51, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
  }
LABEL_16:
  uint64_t v185 = 0;
  memset(v183, 0, sizeof(v183));
  int v184 = 0;
  uint64_t v182 = 0;
  *(void *)v180 = 0;
  v179[0] = 0;
  v179[1] = 0;
  int v181 = 0;
  if (v9)
  {
    uint64_t v15 = 0;
    unint64_t v12 = 0;
    unint64_t v2 = (unint64_t)v207;
    unint64_t v3 = 3;
    do
    {
      LOBYTE(v178[0]) = 0;
      if (v9 <= v12) {
        goto LABEL_480;
      }
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)(v6 + 56) + v15;
      do
      {
        *(_DWORD *)&v207[v16] = *(_DWORD *)(v17 + v16);
        v16 += 4;
      }
      while (v16 != 16);
      if (v208 == -1) {
        char v18 = 3;
      }
      else {
        char v18 = 4;
      }
      LOBYTE(v178[0]) = v18;
      re::DynamicArray<unsigned char>::add(v183, v178);
      re::DynamicArray<float>::copy(v179, *(unint64_t *)v180, v207, LOBYTE(v178[0]));
      ++v12;
      unint64_t v9 = *(void *)(v6 + 40);
      v15 += 16;
    }
    while (v12 < v9);
  }
  re::makeNSDataFromGeomArray<unsigned char>((uint64_t)v178, (uint64_t)v183);
  re::makeNSDataFromGeomArray<unsigned int>((uint64_t)v177, (uint64_t)v179);
  uint64_t v19 = v175;
  re::GeomModelDescriptor::setSurfaceTopology((_anonymous_namespace_ *)&v190, *(unsigned int *)(v6 + 16), (uint64_t)v178, (uint64_t)v177, (uint64_t)v175);
  if (!v175[0] && v176[0])
  {
    uint64_t v19 = (const char *)v176;
    if (v176[1]) {
      (*(void (**)(void))(*(void *)v176[0] + 40))();
    }
    memset(v176, 0, sizeof(v176));
  }
  if (*(_DWORD *)(v6 + 640))
  {
    unint64_t v3 = 0;
    uint64_t v20 = (re::internal::GeomAttributeManager *)(v6 + 64);
    v161 = (re::internal::GeomAttributeManager *)(v6 + 64);
    uint64_t v162 = v6;
    while (1)
    {
      long long v21 = (_anonymous_namespace_ *)re::internal::GeomAttributeManager::attributeByIndex(v20, v3);
      uint64_t v22 = (uint64_t)v21;
      unint64_t v172 = 0;
      LOBYTE(v173) = -1;
      long long v174 = 0uLL;
      *((void *)&v173 + 1) = 0;
      if (*((unsigned char *)v21 + 16) == 3) {
        break;
      }
      switch(*((unsigned char *)v21 + 17))
      {
        case 0:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)
            || (uint64_t v26 = (re::Data *)re::internal::GeomTypedAttribute<short>::operator[](v22, 0),
                !(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)))
          {
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_551:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_552:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_553:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_554:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_555:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_556:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_557:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_558:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_559:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_560:
            *(void *)v204 = 0;
            long long v213 = 0u;
            long long v212 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            __n128 v209 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v225[0]) = 136315906;
            *(id *)((char *)v225 + 4) = "operator[]";
            WORD2(v225[1]) = 1024;
            *(_DWORD *)((char *)&v225[1] + 6) = 601;
            WORD1(v225[2]) = 2048;
            *(id *)((char *)&v225[2] + 4) = 0;
            WORD2(v225[3]) = 2048;
            *(id *)((char *)&v225[3] + 6) = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            JUMPOUT(0x233D45FB0);
          }
          unsigned int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v26, (const void *)(2 * v27), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 2;
          goto LABEL_83;
        case 1:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_551;
          }
          v53 = (re::Data *)re::internal::GeomTypedAttribute<short>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_551;
          }
          unsigned int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v53, (const void *)(2 * v54), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 3;
LABEL_83:
          location[2] = (id)(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22);
          long long v55 = xmmword_23436C460;
          goto LABEL_116;
        case 2:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_552;
          }
          v56 = (re::Data *)re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_552;
          }
          unsigned int v57 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v56, (const void *)(4 * v57), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 4;
          goto LABEL_94;
        case 3:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_553;
          }
          v58 = (re::Data *)re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_553;
          }
          unsigned int v59 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v58, (const void *)(4 * v59), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          char v60 = 5;
          goto LABEL_93;
        case 4:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_554;
          }
          v61 = (re::Data *)re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_554;
          }
          unsigned int v62 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v61, (const void *)(4 * v62), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          char v60 = 6;
LABEL_93:
          LOBYTE(location[1]) = v60;
LABEL_94:
          location[2] = (id)(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22);
          long long v55 = xmmword_23437DC70;
          goto LABEL_116;
        case 5:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_555;
          }
          v63 = (re::Data *)re::internal::GeomTypedAttribute<double>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_555;
          }
          unsigned int v64 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v63, (const void *)(8 * v64), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 7;
          goto LABEL_101;
        case 6:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_556;
          }
          v65 = (re::Data *)re::internal::GeomTypedAttribute<double>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_556;
          }
          unsigned int v66 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v65, (const void *)(8 * v66), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 8;
LABEL_101:
          location[2] = (id)(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22);
          long long v55 = xmmword_2343C0850;
          goto LABEL_116;
        case 7:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_557;
          }
          v67 = (re::Data *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_557;
          }
          unsigned int v68 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v67, (const void *)(16 * v68), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          char v69 = 9;
          goto LABEL_108;
        case 8:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_558;
          }
          v70 = (re::Data *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_558;
          }
          unsigned int v71 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v70, (const void *)(16 * v71), v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          char v69 = 10;
LABEL_108:
          LOBYTE(location[1]) = v69;
          location[2] = (id)(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22);
          long long v55 = xmmword_23440AC70;
          goto LABEL_116;
        case 9:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_559;
          }
          v72 = (re::Data *)re::internal::GeomTypedAttribute<signed char>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_559;
          }
          unsigned int v73 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v72, (const void *)v73, v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 1;
          goto LABEL_115;
        case 0xA:
          if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21)) {
            goto LABEL_560;
          }
          v74 = (re::Data *)re::internal::GeomTypedAttribute<signed char>::operator[](v22, 0);
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22)) {
            goto LABEL_560;
          }
          unsigned int v75 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          re::Data::makeDataWithBytes(v74, (const void *)v75, v228);
          location[0] = 0;
          LOBYTE(location[1]) = -1;
          memset(&location[2], 0, 24);
          re::ObjCObject::operator=(location, (id *)v228);
          LOBYTE(location[1]) = 0;
LABEL_115:
          location[2] = (id)(*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22);
          long long v55 = xmmword_234361D20;
LABEL_116:
          *(_OWORD *)&location[3] = v55;

          unint64_t v9 = (unint64_t)location[0];
          location[0] = 0;
          unint64_t v172 = v9;
          long long v173 = *(_OWORD *)&location[1];
          long long v174 = *(_OWORD *)&location[3];

LABEL_117:
          uint64_t v19 = *(const char **)(v22 + 8);
          re::GeomModelDescriptor::setAttribute(&v190, (uint64_t)&v209, *(unsigned __int8 *)(v22 + 16), (uint64_t)&v172, 0, (uint64_t)v166);
          if (v166[0] || !v167) {
            goto LABEL_416;
          }
          if (v168) {
            (*(void (**)(void))(*(void *)v167 + 40))();
          }
          v76 = &v167;
          break;
        default:
          unint64_t v9 = 0;
          goto LABEL_117;
      }
LABEL_415:
      *(_OWORD *)v76 = 0u;
      *((_OWORD *)v76 + 1) = 0u;
LABEL_416:
      if (v209.n128_u64[0] && (v209.n128_u8[8] & 1) != 0) {
        (*(void (**)(void))(*(void *)v209.n128_u64[0] + 40))();
      }

      unint64_t v3 = (v3 + 1);
      if (v3 >= *(_DWORD *)(v6 + 640)) {
        goto LABEL_420;
      }
    }
    switch(*((unsigned char *)v21 + 17))
    {
      case 0:
        int v163 = v3;
        uint64_t v23 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21);
        if (v23)
        {
          uint64_t v25 = re::internal::GeomTypedAttribute<short>::operator[](v22, 0);
          uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          LODWORD(v6) = v23;
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v25 = 0;
        }
        unint64_t v9 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (v9)
        {
          unint64_t v12 = 0;
          while (1)
          {
            v209.n128_u32[0] = v12;
            int v77 = *(unsigned __int8 *)(v22 + 204);
            if (v77 == 2) {
              break;
            }
            if (v77 == 1)
            {
              if (*(void *)(v22 + 224) <= v12) {
                goto LABEL_160;
              }
              v78 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v12);
LABEL_134:
              unint64_t v2 = *v78;
              if (v2 != -1) {
                goto LABEL_135;
              }
              goto LABEL_160;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_547;
            }
            if (v12 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v2 = v12;
LABEL_135:
              unint64_t v3 = *(void *)(v22 + 88);
              if (v3 <= v2) {
                goto LABEL_512;
              }
              v79 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v2);
              uint64_t v80 = *v79;
              if (v6 <= v80) {
                goto LABEL_515;
              }
              unint64_t v11 = v79[1];
              unint64_t v3 = v79[2];
              unint64_t v2 = v79[3];
              LOWORD(__src) = *(_WORD *)(v25 + 2 * v80);
              if (v6 <= v11) {
                goto LABEL_518;
              }
              WORD1(__src) = *(_WORD *)(v25 + 2 * v11);
              if (v6 <= v3) {
                goto LABEL_521;
              }
              WORD2(__src) = *(_WORD *)(v25 + 2 * v3);
              if (v2 == -1)
              {
                unint64_t v2 = 3;
              }
              else
              {
                if (v6 <= v2) {
                  goto LABEL_538;
                }
                HIWORD(__src) = *(_WORD *)(v25 + 2 * v2);
                unint64_t v2 = 4;
              }
              unint64_t v11 = (unint64_t)location[2];
              if (location[2] == (id)-1) {
                goto LABEL_524;
              }
              size_t v81 = (size_t)location[2] + v2;
              if (__CFADD__(location[2], v2)) {
                goto LABEL_527;
              }
              if (location[2] >= (id)v81)
              {
                uint64_t v23 = (uint64_t)memmove((char *)location[4] + 2 * (uint64_t)location[2], &__src, 2 * v2);
              }
              else
              {
                if (location[1] < (id)v81)
                {
                  if (location[0])
                  {
                    unint64_t v82 = 8;
                    if (location[1]) {
                      unint64_t v82 = 2 * (uint64_t)location[1];
                    }
                    if (v82 <= v81) {
                      v83 = (char *)location[2] + v2;
                    }
                    else {
                      v83 = (char *)v82;
                    }
                    re::DynamicArray<unsigned short>::setCapacity(location, (unint64_t)v83);
                  }
                  else
                  {
                    re::DynamicArray<unsigned short>::setCapacity(location, v11 + v2);
                    ++LODWORD(location[3]);
                  }
                }
                v84 = (char *)location[4];
                int64_t v85 = (int64_t)location[2] - v11;
                if (location[2] != (id)v11)
                {
                  memmove((char *)location[4] + 2 * v11, &__src, 2 * v85);
                  unint64_t v11 = (unint64_t)location[2];
                  v84 = (char *)location[4];
                }
                uint64_t v23 = (uint64_t)memcpy(&v84[2 * v11], (char *)&__src + 2 * v85, (char *)&__src + 2 * v2 - ((char *)&__src + 2 * v85));
                location[2] = (id)v81;
              }
              ++LODWORD(location[3]);
            }
LABEL_160:
            if (++v12 == v9)
            {
              v86 = (re::Data *)location[4];
              v87 = (const void *)(2 * (uint64_t)location[2]);
              unint64_t v11 = (unint64_t)v225;
              goto LABEL_388;
            }
          }
          uint64_t v23 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v23 == -1) {
            goto LABEL_160;
          }
          v78 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v23 + 4);
          goto LABEL_134;
        }
        v87 = 0;
        v86 = 0;
LABEL_388:
        re::Data::makeDataWithBytes(v86, v87, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 2;
        v225[2] = location[2];
        long long v149 = xmmword_23436C460;
        goto LABEL_405;
      case 1:
        int v163 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v29 = re::internal::GeomTypedAttribute<short>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v29 = 0;
        }
        unint64_t v9 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (v9)
        {
          unint64_t v12 = 0;
          while (1)
          {
            v209.n128_u32[0] = v12;
            int v88 = *(unsigned __int8 *)(v22 + 204);
            if (v88 == 2) {
              break;
            }
            if (v88 == 1)
            {
              if (*(void *)(v22 + 224) <= v12) {
                goto LABEL_191;
              }
              v90 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v12);
LABEL_174:
              unint64_t v2 = *v90;
              if (v2 != -1) {
                goto LABEL_175;
              }
              goto LABEL_191;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_548;
            }
            if (v12 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v2 = v12;
LABEL_175:
              unint64_t v3 = *(void *)(v22 + 88);
              if (v3 <= v2) {
                goto LABEL_513;
              }
              v91 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v2);
              uint64_t v80 = *v91;
              if (v6 <= v80) {
                goto LABEL_516;
              }
              unint64_t v11 = v91[1];
              unint64_t v3 = v91[2];
              unint64_t v2 = v91[3];
              LOWORD(__src) = *(_WORD *)(v29 + 2 * v80);
              if (v6 <= v11) {
                goto LABEL_519;
              }
              WORD1(__src) = *(_WORD *)(v29 + 2 * v11);
              if (v6 <= v3) {
                goto LABEL_522;
              }
              WORD2(__src) = *(_WORD *)(v29 + 2 * v3);
              if (v2 == -1)
              {
                unint64_t v2 = 3;
              }
              else
              {
                if (v6 <= v2) {
                  goto LABEL_539;
                }
                HIWORD(__src) = *(_WORD *)(v29 + 2 * v2);
                unint64_t v2 = 4;
              }
              unint64_t v3 = (unint64_t)location[2];
              if (location[2] == (id)-1) {
                goto LABEL_525;
              }
              size_t v81 = (size_t)location[2] + v2;
              if (__CFADD__(location[2], v2)) {
                goto LABEL_528;
              }
              if (location[2] >= (id)v81)
              {
                memmove((char *)location[4] + 2 * (uint64_t)location[2], &__src, 2 * v2);
              }
              else
              {
                re::DynamicArray<unsigned short>::growCapacity(location, (unint64_t)location[2] + v2);
                unint64_t v11 = (unint64_t)location[2] - v3;
                if (location[2] != (id)v3)
                {
                  memmove((char *)location[4] + 2 * v3, &__src, 2 * v11);
                  unint64_t v3 = (unint64_t)location[2];
                }
                memcpy((char *)location[4] + 2 * v3, (char *)&__src + 2 * v11, (char *)&__src + 2 * v2 - ((char *)&__src + 2 * v11));
                location[2] = (id)v81;
              }
              ++LODWORD(location[3]);
            }
LABEL_191:
            if (++v12 == v9)
            {
              v92 = (re::Data *)location[4];
              v93 = (const void *)(2 * (uint64_t)location[2]);
              goto LABEL_390;
            }
          }
          uint64_t v89 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v89 == -1) {
            goto LABEL_191;
          }
          v90 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v89 + 4);
          goto LABEL_174;
        }
        v93 = 0;
        v92 = 0;
LABEL_390:
        re::Data::makeDataWithBytes(v92, v93, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 3;
        v225[2] = location[2];
        unint64_t v11 = (unint64_t)v225;
        long long v149 = xmmword_23436C460;
        goto LABEL_405;
      case 2:
        int v163 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v31 = re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v31 = 0;
        }
        uint64_t v94 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (v94)
        {
          unint64_t v9 = 0;
          while (1)
          {
            v209.n128_u32[0] = v9;
            int v95 = *(unsigned __int8 *)(v22 + 204);
            if (v95 == 2) {
              break;
            }
            if (v95 == 1)
            {
              if (*(void *)(v22 + 224) <= v9) {
                goto LABEL_206;
              }
              v97 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_205:
              unint64_t v12 = *v97;
              if (v12 != -1) {
                goto LABEL_207;
              }
              goto LABEL_206;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_541;
            }
            if (v9 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v12 = v9;
LABEL_207:
              unint64_t v2 = *(void *)(v22 + 88);
              if (v2 <= v12) {
                goto LABEL_488;
              }
              v99 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
              unint64_t v11 = *v99;
              if (v6 <= v11) {
                goto LABEL_494;
              }
              unint64_t v3 = v99[1];
              unint64_t v2 = v99[2];
              unint64_t v12 = v99[3];
              *(_DWORD *)v228 = *(_DWORD *)(v31 + 4 * v11);
              if (v6 <= v3) {
                goto LABEL_500;
              }
              *(_DWORD *)&v228[4] = *(_DWORD *)(v31 + 4 * v3);
              if (v6 <= v2) {
                goto LABEL_506;
              }
              *(_DWORD *)&v228[8] = *(_DWORD *)(v31 + 4 * v2);
              if (v12 == -1)
              {
                uint64_t v98 = 3;
              }
              else
              {
                if (v6 <= v12) {
                  goto LABEL_532;
                }
                *(_DWORD *)&v228[12] = *(_DWORD *)(v31 + 4 * v12);
                uint64_t v98 = 4;
              }
              goto LABEL_215;
            }
LABEL_206:
            uint64_t v98 = 0;
LABEL_215:
            re::DynamicArray<float>::copy(location, (unint64_t)location[2], v228, v98);
            if (++v9 == v94)
            {
              v100 = (re::Data *)location[4];
              v101 = (const void *)(4 * (uint64_t)location[2]);
              goto LABEL_392;
            }
          }
          uint64_t v96 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v96 == -1) {
            goto LABEL_206;
          }
          v97 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v96 + 4);
          goto LABEL_205;
        }
        v101 = 0;
        v100 = 0;
LABEL_392:
        re::Data::makeDataWithBytes(v100, v101, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 4;
        v225[2] = location[2];
        unint64_t v11 = (unint64_t)v225;
        goto LABEL_395;
      case 3:
        int v164 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v33 = re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v33 = 0;
        }
        uint64_t v102 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (!v102) {
          goto LABEL_240;
        }
        unint64_t v9 = 0;
        while (1)
        {
          v209.n128_u32[0] = v9;
          int v103 = *(unsigned __int8 *)(v22 + 204);
          if (v103 == 2) {
            break;
          }
          if (v103 == 1)
          {
            if (*(void *)(v22 + 224) <= v9) {
              goto LABEL_230;
            }
            v105 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_229:
            unint64_t v12 = *v105;
            if (v12 != -1) {
              goto LABEL_231;
            }
            goto LABEL_230;
          }
          if (*(unsigned char *)(v22 + 204)) {
            goto LABEL_542;
          }
          if (v9 < *(unsigned int *)(v22 + 208))
          {
            unint64_t v12 = v9;
LABEL_231:
            unint64_t v2 = *(void *)(v22 + 88);
            if (v2 <= v12) {
              goto LABEL_489;
            }
            v107 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
            unint64_t v11 = *v107;
            if (v6 <= v11) {
              goto LABEL_495;
            }
            unint64_t v3 = v107[1];
            unint64_t v2 = v107[2];
            unint64_t v12 = v107[3];
            *(_DWORD *)v228 = *(_DWORD *)(v33 + 4 * v11);
            if (v6 <= v3) {
              goto LABEL_501;
            }
            *(_DWORD *)&v228[4] = *(_DWORD *)(v33 + 4 * v3);
            if (v6 <= v2) {
              goto LABEL_507;
            }
            *(_DWORD *)&v228[8] = *(_DWORD *)(v33 + 4 * v2);
            if (v12 == -1)
            {
              uint64_t v106 = 3;
            }
            else
            {
              if (v6 <= v12) {
                goto LABEL_533;
              }
              *(_DWORD *)&v228[12] = *(_DWORD *)(v33 + 4 * v12);
              uint64_t v106 = 4;
            }
            goto LABEL_239;
          }
LABEL_230:
          uint64_t v106 = 0;
LABEL_239:
          re::DynamicArray<float>::copy(location, (unint64_t)location[2], v228, v106);
          if (++v9 == v102)
          {
LABEL_240:
            re::makeNSDataFromGeomArray<unsigned int>((uint64_t)v225, (uint64_t)location);
LABEL_343:
            if (location[0] && location[4]) {
              (*(void (**)(id))(*(void *)location[0] + 40))(location[0]);
            }
            unint64_t v9 = (unint64_t)v225[0];
            v225[0] = 0;
            unint64_t v172 = v9;
            long long v173 = *(_OWORD *)&v225[1];
            long long v174 = *(_OWORD *)&v225[3];

            unint64_t v11 = (unint64_t)v225;
            uint64_t v20 = v161;
            uint64_t v6 = v162;
            LODWORD(v3) = v164;
LABEL_410:
            uint64_t v19 = *(const char **)(v22 + 8);
            re::GeomModelDescriptor::setAttribute(&v190, (uint64_t)&v209, *(unsigned __int8 *)(v22 + 16), (uint64_t)&v172, 0, (uint64_t)v169);
            if (!v169[0] && v170)
            {
              if (v171) {
                (*(void (**)(void))(*(void *)v170 + 40))();
              }
              v76 = &v170;
              goto LABEL_415;
            }
            goto LABEL_416;
          }
        }
        uint64_t v104 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
        if (v104 == -1) {
          goto LABEL_230;
        }
        v105 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v104 + 4);
        goto LABEL_229;
      case 4:
        int v163 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v35 = re::internal::GeomTypedAttribute<int>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v35 = 0;
        }
        uint64_t v108 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (v108)
        {
          unint64_t v9 = 0;
          while (1)
          {
            v209.n128_u32[0] = v9;
            int v109 = *(unsigned __int8 *)(v22 + 204);
            if (v109 == 2) {
              break;
            }
            if (v109 == 1)
            {
              if (*(void *)(v22 + 224) <= v9) {
                goto LABEL_254;
              }
              v111 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_253:
              unint64_t v12 = *v111;
              if (v12 != -1) {
                goto LABEL_255;
              }
              goto LABEL_254;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_543;
            }
            if (v9 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v12 = v9;
LABEL_255:
              unint64_t v2 = *(void *)(v22 + 88);
              if (v2 <= v12) {
                goto LABEL_490;
              }
              v113 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
              unint64_t v11 = *v113;
              if (v6 <= v11) {
                goto LABEL_496;
              }
              unint64_t v3 = v113[1];
              unint64_t v2 = v113[2];
              unint64_t v12 = v113[3];
              *(_DWORD *)v228 = *(_DWORD *)(v35 + 4 * v11);
              if (v6 <= v3) {
                goto LABEL_502;
              }
              *(_DWORD *)&v228[4] = *(_DWORD *)(v35 + 4 * v3);
              if (v6 <= v2) {
                goto LABEL_508;
              }
              *(_DWORD *)&v228[8] = *(_DWORD *)(v35 + 4 * v2);
              if (v12 == -1)
              {
                uint64_t v112 = 3;
              }
              else
              {
                if (v6 <= v12) {
                  goto LABEL_534;
                }
                *(_DWORD *)&v228[12] = *(_DWORD *)(v35 + 4 * v12);
                uint64_t v112 = 4;
              }
              goto LABEL_263;
            }
LABEL_254:
            uint64_t v112 = 0;
LABEL_263:
            re::DynamicArray<float>::copy(location, (unint64_t)location[2], v228, v112);
            if (++v9 == v108)
            {
              v114 = (re::Data *)location[4];
              v115 = (const void *)(4 * (uint64_t)location[2]);
              unint64_t v11 = (unint64_t)v225;
              goto LABEL_394;
            }
          }
          uint64_t v110 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v110 == -1) {
            goto LABEL_254;
          }
          v111 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v110 + 4);
          goto LABEL_253;
        }
        v115 = 0;
        v114 = 0;
LABEL_394:
        re::Data::makeDataWithBytes(v114, v115, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 6;
        v225[2] = location[2];
LABEL_395:
        long long v149 = xmmword_23437DC70;
        goto LABEL_405;
      case 5:
        int v163 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v37 = re::internal::GeomTypedAttribute<double>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v37 = 0;
        }
        uint64_t v116 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (v116)
        {
          unint64_t v9 = 0;
          while (1)
          {
            v209.n128_u32[0] = v9;
            int v117 = *(unsigned __int8 *)(v22 + 204);
            if (v117 == 2) {
              break;
            }
            if (v117 == 1)
            {
              if (*(void *)(v22 + 224) <= v9) {
                goto LABEL_278;
              }
              v119 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_277:
              unint64_t v12 = *v119;
              if (v12 != -1) {
                goto LABEL_279;
              }
              goto LABEL_278;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_544;
            }
            if (v9 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v12 = v9;
LABEL_279:
              unint64_t v2 = *(void *)(v22 + 88);
              if (v2 <= v12) {
                goto LABEL_491;
              }
              v121 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
              unint64_t v11 = *v121;
              if (v6 <= v11) {
                goto LABEL_497;
              }
              unint64_t v3 = v121[1];
              unint64_t v2 = v121[2];
              unint64_t v12 = v121[3];
              *(void *)v228 = *(void *)(v37 + 8 * v11);
              if (v6 <= v3) {
                goto LABEL_503;
              }
              *(void *)&v228[8] = *(void *)(v37 + 8 * v3);
              if (v6 <= v2) {
                goto LABEL_509;
              }
              *(void *)&v228[16] = *(void *)(v37 + 8 * v2);
              if (v12 == -1)
              {
                uint64_t v120 = 3;
              }
              else
              {
                if (v6 <= v12) {
                  goto LABEL_535;
                }
                *(void *)&v228[24] = *(void *)(v37 + 8 * v12);
                uint64_t v120 = 4;
              }
              goto LABEL_287;
            }
LABEL_278:
            uint64_t v120 = 0;
LABEL_287:
            re::DynamicArray<double>::copy(location, (unint64_t)location[2], v228, v120);
            if (++v9 == v116)
            {
              v122 = (re::Data *)location[4];
              v123 = (const void *)(8 * (uint64_t)location[2]);
              unint64_t v11 = (unint64_t)v225;
              goto LABEL_397;
            }
          }
          uint64_t v118 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v118 == -1) {
            goto LABEL_278;
          }
          v119 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v118 + 4);
          goto LABEL_277;
        }
        v123 = 0;
        v122 = 0;
LABEL_397:
        re::Data::makeDataWithBytes(v122, v123, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 7;
        v225[2] = location[2];
        long long v149 = xmmword_2343C0850;
        goto LABEL_405;
      case 6:
        re::GeomAttributeFaceVaryingLayout<re::Vector2<float>>::GeomAttributeFaceVaryingLayout(&__src, (uint64_t)v21);
        unint64_t v12 = *(unsigned int *)(__src + 88);
        memset(v228, 0, 32);
        location[4] = 0;
        memset(location, 0, 28);
        if (v12)
        {
          uint64_t v38 = 0;
          do
          {
            unsigned int v39 = re::GeomAttributeFaceVaryingLayout<re::Vector2<float>>::faceVertexValueIndices(&__src, v38, (uint64_t)&v221);
            if (v39)
            {
              unint64_t v2 = v221;
              unint64_t v9 = v220;
              if (v220 <= v221) {
                goto LABEL_482;
              }
              *(void *)v228 = *(void *)(v219 + 8 * v221);
              unint64_t v2 = v222;
              if (v220 <= v222) {
                goto LABEL_484;
              }
              *(void *)&v228[8] = *(void *)(v219 + 8 * v222);
              unint64_t v2 = v223;
              if (v220 <= v223) {
                goto LABEL_486;
              }
              *(void *)&v228[16] = *(void *)(v219 + 8 * v223);
              if (v39 == 4)
              {
                unint64_t v2 = v224;
                if (v220 <= v224) {
                  goto LABEL_530;
                }
                *(void *)&v228[24] = *(void *)(v219 + 8 * v224);
              }
            }
            re::DynamicArray<re::Vector2<float>>::copy(location, (unint64_t)location[2], v228, v39);
            uint64_t v38 = (v38 + 1);
          }
          while (v12 != v38);
          v40 = (re::Data *)location[4];
          v41 = (const void *)(8 * (uint64_t)location[2]);
        }
        else
        {
          v41 = 0;
          v40 = 0;
        }
        re::Data::makeDataWithBytes(v40, v41, &v209);
        v225[0] = 0;
        LOBYTE(v225[1]) = -1;
        memset(&v225[2], 0, 24);
        re::ObjCObject::operator=(v225, (id *)&v209);
        LOBYTE(v225[1]) = 8;
        v225[2] = location[2];
        *(_OWORD *)&v225[3] = xmmword_2343C0850;

        id v124 = location[0];
        if (!location[0]) {
          goto LABEL_408;
        }
        goto LABEL_406;
      case 7:
        re::GeomAttributeFaceVaryingLayout<re::Vector3<float>>::GeomAttributeFaceVaryingLayout(&__src, (uint64_t)v21);
        unint64_t v12 = *(unsigned int *)(__src + 88);
        long long v227 = 0u;
        memset(location, 0, sizeof(location));
        v225[4] = 0;
        memset(v225, 0, 28);
        if (v12)
        {
          uint64_t v42 = 0;
          do
          {
            unsigned int v43 = re::GeomAttributeFaceVaryingLayout<re::Vector2<float>>::faceVertexValueIndices(&__src, v42, (uint64_t)&v221);
            if (v43)
            {
              unint64_t v2 = v221;
              unint64_t v9 = v220;
              if (v220 <= v221) {
                goto LABEL_483;
              }
              *(_OWORD *)location = *(_OWORD *)(v219 + 16 * v221);
              unint64_t v2 = v222;
              if (v220 <= v222) {
                goto LABEL_485;
              }
              *(_OWORD *)&location[2] = *(_OWORD *)(v219 + 16 * v222);
              unint64_t v2 = v223;
              if (v220 <= v223) {
                goto LABEL_487;
              }
              *(_OWORD *)&location[4] = *(_OWORD *)(v219 + 16 * v223);
              if (v43 == 4)
              {
                unint64_t v2 = v224;
                if (v220 <= v224) {
                  goto LABEL_531;
                }
                long long v227 = *(_OWORD *)(v219 + 16 * v224);
              }
            }
            re::DynamicArray<re::Vector3<float>>::copy(v225, (unint64_t)v225[2], (char *)location, v43);
            uint64_t v42 = (v42 + 1);
          }
          while (v12 != v42);
          v44 = (re::Data *)v225[4];
          v45 = (const void *)(16 * (uint64_t)v225[2]);
        }
        else
        {
          v45 = 0;
          v44 = 0;
        }
        re::Data::makeDataWithBytes(v44, v45, &v209);
        *(void *)v204 = 0;
        v204[8] = -1;
        memset((char *)v206 + 2, 0, 24);
        re::ObjCObject::operator=((id *)v204, (id *)&v209);
        v204[8] = 9;
        *(id *)((char *)v206 + 2) = v225[2];
        *(_OWORD *)((char *)&v206[1] + 2) = xmmword_23440AC70;

        id v125 = v225[0];
        if (!v225[0]) {
          goto LABEL_402;
        }
        goto LABEL_400;
      case 8:
        int v165 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v47 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v47 = 0;
        }
        uint64_t v126 = *(unsigned int *)(v22 + 88);
        long long v227 = 0u;
        memset(location, 0, sizeof(location));
        v225[4] = 0;
        memset(v225, 0, 28);
        if (v126)
        {
          unint64_t v9 = 0;
          while (1)
          {
            v209.n128_u32[0] = v9;
            int v127 = *(unsigned __int8 *)(v22 + 204);
            if (v127 == 2) {
              break;
            }
            if (v127 == 1)
            {
              if (*(void *)(v22 + 224) <= v9) {
                goto LABEL_308;
              }
              v129 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_307:
              unint64_t v12 = *v129;
              if (v12 != -1) {
                goto LABEL_309;
              }
              goto LABEL_308;
            }
            if (*(unsigned char *)(v22 + 204)) {
              goto LABEL_545;
            }
            if (v9 < *(unsigned int *)(v22 + 208))
            {
              unint64_t v12 = v9;
LABEL_309:
              unint64_t v2 = *(void *)(v22 + 88);
              if (v2 <= v12) {
                goto LABEL_492;
              }
              v131 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
              unint64_t v11 = *v131;
              if (v6 <= v11) {
                goto LABEL_498;
              }
              unint64_t v3 = v131[1];
              unint64_t v2 = v131[2];
              unint64_t v12 = v131[3];
              *(_OWORD *)location = *(_OWORD *)(v47 + 16 * v11);
              if (v6 <= v3) {
                goto LABEL_504;
              }
              *(_OWORD *)&location[2] = *(_OWORD *)(v47 + 16 * v3);
              if (v6 <= v2) {
                goto LABEL_510;
              }
              *(_OWORD *)&location[4] = *(_OWORD *)(v47 + 16 * v2);
              if (v12 == -1)
              {
                uint64_t v130 = 3;
              }
              else
              {
                if (v6 <= v12) {
                  goto LABEL_536;
                }
                long long v227 = *(_OWORD *)(v47 + 16 * v12);
                uint64_t v130 = 4;
              }
              goto LABEL_317;
            }
LABEL_308:
            uint64_t v130 = 0;
LABEL_317:
            re::DynamicArray<re::Vector4<float>>::copy(v225, (unint64_t)v225[2], (char *)location, v130);
            if (++v9 == v126)
            {
              v132 = (re::Data *)v225[4];
              v133 = (const void *)(16 * (uint64_t)v225[2]);
              unint64_t v11 = (unint64_t)v225;
              goto LABEL_399;
            }
          }
          uint64_t v128 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
          if (v128 == -1) {
            goto LABEL_308;
          }
          v129 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v128 + 4);
          goto LABEL_307;
        }
        v133 = 0;
        v132 = 0;
LABEL_399:
        re::Data::makeDataWithBytes(v132, v133, &v209);
        *(void *)v204 = 0;
        v204[8] = -1;
        memset((char *)v206 + 2, 0, 24);
        re::ObjCObject::operator=((id *)v204, (id *)&v209);
        v204[8] = 10;
        *(id *)((char *)v206 + 2) = v225[2];
        *(_OWORD *)((char *)&v206[1] + 2) = xmmword_23440AC70;

        id v125 = v225[0];
        uint64_t v20 = v161;
        uint64_t v6 = v162;
        LODWORD(v3) = v165;
        if (v225[0])
        {
LABEL_400:
          if (v225[4]) {
            (*(void (**)(id))(*(void *)v125 + 40))(v125);
          }
        }
LABEL_402:
        unint64_t v9 = *(void *)v204;
        *(void *)v204 = 0;
        unint64_t v172 = v9;
        v150 = (id *)&v204[8];
        goto LABEL_409;
      case 9:
        int v164 = v3;
        if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21))
        {
          uint64_t v49 = re::internal::GeomTypedAttribute<signed char>::operator[](v22, 0);
          LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v49 = 0;
        }
        uint64_t v134 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (!v134) {
          goto LABEL_342;
        }
        unint64_t v9 = 0;
        while (1)
        {
          v209.n128_u32[0] = v9;
          int v135 = *(unsigned __int8 *)(v22 + 204);
          if (v135 == 2) {
            break;
          }
          if (v135 == 1)
          {
            if (*(void *)(v22 + 224) <= v9) {
              goto LABEL_332;
            }
            v137 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v9);
LABEL_331:
            unint64_t v12 = *v137;
            if (v12 == -1) {
              goto LABEL_332;
            }
            goto LABEL_333;
          }
          if (*(unsigned char *)(v22 + 204)) {
            goto LABEL_546;
          }
          if (v9 >= *(unsigned int *)(v22 + 208))
          {
LABEL_332:
            size_t v138 = 0;
            goto LABEL_341;
          }
          unint64_t v12 = v9;
LABEL_333:
          unint64_t v2 = *(void *)(v22 + 88);
          if (v2 <= v12) {
            goto LABEL_493;
          }
          v139 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v12);
          unint64_t v11 = *v139;
          if (v6 <= v11) {
            goto LABEL_499;
          }
          unint64_t v3 = v139[1];
          unint64_t v2 = v139[2];
          unint64_t v12 = v139[3];
          LOBYTE(__src) = *(unsigned char *)(v49 + v11);
          if (v6 <= v3) {
            goto LABEL_505;
          }
          BYTE1(__src) = *(unsigned char *)(v49 + v3);
          if (v6 <= v2) {
            goto LABEL_511;
          }
          BYTE2(__src) = *(unsigned char *)(v49 + v2);
          if (v12 == -1)
          {
            size_t v138 = 3;
          }
          else
          {
            if (v6 <= v12) {
              goto LABEL_537;
            }
            BYTE3(__src) = *(unsigned char *)(v49 + v12);
            size_t v138 = 4;
          }
LABEL_341:
          re::DynamicArray<REFrameAnalysisBottleneck>::copy(location, (unint64_t)location[2], (char *)&__src, v138);
          if (++v9 == v134)
          {
LABEL_342:
            re::makeNSDataFromGeomArray<unsigned char>((uint64_t)v225, (uint64_t)location);
            goto LABEL_343;
          }
        }
        uint64_t v136 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
        if (v136 == -1) {
          goto LABEL_332;
        }
        v137 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v136 + 4);
        goto LABEL_331;
      case 0xA:
        int v163 = v3;
        uint64_t v50 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)v21 + 16))(v21);
        if (v50)
        {
          uint64_t v52 = re::internal::GeomTypedAttribute<signed char>::operator[](v22, 0);
          uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
          LODWORD(v6) = v50;
        }
        else
        {
          LODWORD(v6) = 0;
          uint64_t v52 = 0;
        }
        unint64_t v11 = *(unsigned int *)(v22 + 88);
        location[4] = 0;
        memset(location, 0, 28);
        if (!v11)
        {
          id v148 = 0;
          v147 = 0;
LABEL_404:
          re::Data::makeDataWithBytes(v147, v148, &v209);
          v225[0] = 0;
          LOBYTE(v225[1]) = -1;
          memset(&v225[2], 0, 24);
          re::ObjCObject::operator=(v225, (id *)&v209);
          LOBYTE(v225[1]) = 0;
          v225[2] = location[2];
          unint64_t v11 = (unint64_t)v225;
          long long v149 = xmmword_234361D20;
LABEL_405:
          *(_OWORD *)&v225[3] = v149;

          id v124 = location[0];
          uint64_t v20 = v161;
          uint64_t v6 = v162;
          LODWORD(v3) = v163;
          if (location[0])
          {
LABEL_406:
            if (location[4]) {
              (*(void (**)(id))(*(void *)v124 + 40))(v124);
            }
          }
LABEL_408:
          unint64_t v9 = (unint64_t)v225[0];
          v225[0] = 0;
          unint64_t v172 = v9;
          v150 = &v225[1];
LABEL_409:
          long long v151 = *((_OWORD *)v150 + 1);
          long long v173 = *(_OWORD *)v150;
          long long v174 = v151;

          goto LABEL_410;
        }
        unint64_t v2 = 0;
        break;
      default:
        unint64_t v9 = 0;
        goto LABEL_410;
    }
    while (1)
    {
      v209.n128_u32[0] = v2;
      int v140 = *(unsigned __int8 *)(v22 + 204);
      if (v140 == 2) {
        break;
      }
      if (v140 == 1)
      {
        if (*(void *)(v22 + 224) <= v2) {
          goto LABEL_385;
        }
        v141 = (unsigned int *)(*(void *)(v22 + 240) + 4 * v2);
LABEL_359:
        unint64_t v9 = *v141;
        if (v9 != -1) {
          goto LABEL_360;
        }
        goto LABEL_385;
      }
      if (*(unsigned char *)(v22 + 204)) {
        goto LABEL_549;
      }
      if (v2 < *(unsigned int *)(v22 + 208))
      {
        unint64_t v9 = v2;
LABEL_360:
        unint64_t v12 = *(void *)(v22 + 88);
        if (v12 <= v9) {
          goto LABEL_514;
        }
        v142 = (unsigned int *)(*(void *)(v22 + 104) + 16 * v9);
        uint64_t v80 = *v142;
        if (v6 <= v80) {
          goto LABEL_517;
        }
        unint64_t v3 = v142[1];
        unint64_t v12 = v142[2];
        unint64_t v9 = v142[3];
        LOBYTE(__src) = *(unsigned char *)(v52 + v80);
        if (v6 <= v3) {
          goto LABEL_520;
        }
        BYTE1(__src) = *(unsigned char *)(v52 + v3);
        if (v6 <= v12) {
          goto LABEL_523;
        }
        BYTE2(__src) = *(unsigned char *)(v52 + v12);
        if (v9 == -1)
        {
          size_t v81 = 3;
        }
        else
        {
          if (v6 <= v9) {
            goto LABEL_540;
          }
          BYTE3(__src) = *(unsigned char *)(v52 + v9);
          size_t v81 = 4;
        }
        unint64_t v3 = (unint64_t)location[2];
        if (location[2] == (id)-1) {
          goto LABEL_526;
        }
        unint64_t v9 = (unint64_t)location[2] + v81;
        if (__CFADD__(location[2], v81)) {
          goto LABEL_529;
        }
        if (location[2] >= (id)v9)
        {
          uint64_t v50 = (uint64_t)memmove((char *)location[4] + (unint64_t)location[2], &__src, v81);
        }
        else
        {
          if (location[1] < (id)v9)
          {
            if (location[0])
            {
              unint64_t v143 = 8;
              if (location[1]) {
                unint64_t v143 = 2 * (uint64_t)location[1];
              }
              if (v143 <= v9) {
                v144 = (char *)location[2] + v81;
              }
              else {
                v144 = (char *)v143;
              }
              re::DynamicArray<BOOL>::setCapacity(location, (unint64_t)v144);
            }
            else
            {
              re::DynamicArray<BOOL>::setCapacity(location, v3 + v81);
              ++LODWORD(location[3]);
            }
          }
          v145 = (char *)location[4];
          v146 = (char *)location[2] - v3;
          if (location[2] != (id)v3)
          {
            memmove((char *)location[4] + v3, &__src, (size_t)location[2] - v3);
            unint64_t v3 = (unint64_t)location[2];
            v145 = (char *)location[4];
          }
          uint64_t v50 = (uint64_t)memcpy(&v145[v3], (char *)&__src + (void)v146, (char *)&__src + v81 - ((char *)&__src + (void)v146));
          location[2] = (id)v9;
        }
        ++LODWORD(location[3]);
      }
LABEL_385:
      if (++v2 == v11)
      {
        v147 = (re::Data *)location[4];
        id v148 = location[2];
        goto LABEL_404;
      }
    }
    uint64_t v50 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v22 + 208), (unsigned int *)&v209);
    if (v50 == -1) {
      goto LABEL_385;
    }
    v141 = (unsigned int *)(*(void *)(v22 + 216) + 8 * v50 + 4);
    goto LABEL_359;
  }
LABEL_420:
  re::makeNSDataFromGeomArray<unsigned int>((uint64_t)location, (uint64_t)v187);
  v153 = re::GeomModelDescriptor::validateIndexType(v152, LOBYTE(location[1]), (uint64_t)&v209);
  if (!location[0])
  {
    v157 = "No material assignements supplied.";
LABEL_438:
    char v155 = 0;
    LOBYTE(v2) = v225[1];
    unint64_t v9 = (unint64_t)v225[2];
    uint64_t v19 = (const char *)v225[0];
    goto LABEL_439;
  }
  if (!location[4])
  {
    v157 = "Zero stride provided.";
    goto LABEL_438;
  }
  re::GeomModelDescriptor::makeCFDataPayload((uint64_t *)v225, (uint64_t)location);
  uint64_t v154 = *(void *)((char *)&v192 + 4);
  *(id *)((char *)&v192 + 4) = v225[0];
  if (v154) {

  }
  char v155 = 1;
LABEL_439:
  if (!v209.n128_u8[0] && *((void *)&v210 + 1) && (v211 & 1) != 0) {
    (*(void (**)(void))(**((void **)&v210 + 1) + 40))();
  }
  if (v19) {
    char v159 = v155;
  }
  else {
    char v159 = 1;
  }
  if (v159 & 1) == 0 && (v2) {
    (*(void (**)(const char *, unint64_t))(*(void *)v19 + 40))(v19, v9);
  }
  re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)&v209, (uint64_t)&v190);
  unsigned char *v160 = 1;
  re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)(v160 + 8), (uint64_t)&v209);
  if ((void)v216)
  {
    if (BYTE8(v216)) {
      (*(void (**)(void))(*(void *)v216 + 40))();
    }
    long long v216 = 0u;
    long long v217 = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v215);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)v214);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v212);
  if (*((void *)&v211 + 1))
  {

    *((void *)&v211 + 1) = 0;
  }
  if ((void)v211)
  {

    *(void *)&long long v211 = 0;
  }
  if (v209.n128_u64[1]) {

  }
  if (v179[0] && v182) {
    (*(void (**)(void))(*(void *)v179[0] + 40))();
  }
  if (v183[0] && v185) {
    (*(void (**)(void))(*(void *)v183[0] + 40))();
  }
LABEL_462:
  if (v187[0] && v189) {
    (*(void (**)(void))(*(void *)v187[0] + 40))();
  }
LABEL_465:
  if ((void)v201)
  {
    if (BYTE8(v201)) {
      (*(void (**)(__n128))(*(void *)v201 + 40))(v156);
    }
    long long v201 = 0u;
    long long v202 = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v199[8]);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)v197);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v193[7]);
  if (*(void *)&v193[5])
  {

    *(void *)&v193[5] = 0;
  }
  if (*(void *)&v193[3])
  {

    *(void *)&v193[3] = 0;
  }
  if (*(void *)((char *)&v192 + 4)) {
}
  }

void re::makeNSDataFromGeomArray<unsigned char>(uint64_t a1, uint64_t a2)
{
  re::Data::makeDataWithBytes(*(re::Data **)(a2 + 32), *(const void **)(a2 + 16), &v4);
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = -1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  re::ObjCObject::operator=((id *)a1, &v4);
  *(unsigned char *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = xmmword_234361D20;
}

void re::makeNSDataFromGeomArray<unsigned int>(uint64_t a1, uint64_t a2)
{
  re::Data::makeDataWithBytes(*(re::Data **)(a2 + 32), (const void *)(4 * *(void *)(a2 + 16)), &v4);
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = -1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  re::ObjCObject::operator=((id *)a1, &v4);
  *(unsigned char *)(a1 + 8) = 5;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = xmmword_23437DC70;
}

re::DynamicString *re::GeomModelDescriptor::setAttribute@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  if (*(unsigned __int8 *)(a4 + 8) == 255)
  {
    long long v25 = v51;
    long long v26 = v52;
    *(unsigned char *)a6 = 0;
    *(void *)(a6 + 8) = 100;
    *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a6 + 24) = v25;
    *(_OWORD *)(a6 + 40) = v26;
    return result;
  }
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    uint64_t v13 = (const re::DynamicString *)v12;
  }
  else {
    uint64_t v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v40, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v40, a3, *(unsigned __int8 *)(a4 + 8), (uint64_t)v35);
  if (v35[0])
  {
    char v32 = 4;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    CFDataPayload = re::DynamicString::operator=((re::DynamicString *)&v30, (re::DynamicString *)&v40);
    char v32 = a3;
    if (*(void *)a4)
    {
      if (*(void *)(a4 + 32))
      {
        CFDataPayload = (_anonymous_namespace_ *)re::GeomModelDescriptor::makeCFDataPayload((uint64_t *)&v51, a4);
        uint64_t v16 = v33;
        uint64_t v33 = v51;
        if (v16) {

        }
        if (!a5)
        {
LABEL_16:
          char v18 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v40);
          if (v18)
          {
            unint64_t v19 = *v18;
            unint64_t v20 = a1[14];
            if (v20 <= *v18)
            {
              uint64_t v42 = 0;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v51 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v43 = 136315906;
              v44 = "operator[]";
              __int16 v45 = 1024;
              int v46 = 789;
              __int16 v47 = 2048;
              unint64_t v48 = v19;
              __int16 v49 = 2048;
              unint64_t v50 = v20;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            long long v21 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v19), (re::DynamicString *)&v30);
            *((unsigned char *)v21 + 32) = v32;
            uint64_t v22 = *((void *)v21 + 5);
            *((void *)v21 + 5) = v33;
            uint64_t v33 = v22;
            uint64_t v23 = *((void *)v21 + 6);
            *((void *)v21 + 6) = v34;
            uint64_t v34 = v23;
          }
          else
          {
            *(void *)&long long v51 = a1[14];
            re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v40, &v51);
            re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v30);
          }
          *(unsigned char *)a6 = 1;
LABEL_27:
          if (v34)
          {

            uint64_t v34 = 0;
          }
          if (v33)
          {

            uint64_t v33 = 0;
          }
          if (v30 && (v31 & 1) != 0) {
            (*(void (**)(void))(*(void *)v30 + 40))();
          }
          if (v35[0]) {
            goto LABEL_38;
          }
          goto LABEL_35;
        }
        if (!*(void *)a5)
        {
          unsigned int v27 = "Null indices value buffer.";
          goto LABEL_24;
        }
        if (*(void *)(a5 + 32))
        {
          re::GeomModelDescriptor::validateIndexType(CFDataPayload, *(unsigned __int8 *)(a5 + 8), a6);
          if (!*(unsigned char *)a6) {
            goto LABEL_27;
          }
          re::GeomModelDescriptor::makeCFDataPayload((uint64_t *)&v51, a5);
          uint64_t v17 = v34;
          uint64_t v34 = v51;
          if (v17) {

          }
          goto LABEL_16;
        }
      }
      unsigned int v27 = "Zero stride provided.";
    }
    else
    {
      unsigned int v27 = "Null values buffer.";
    }
LABEL_24:
    long long v28 = v51;
    long long v29 = v52;
    *(unsigned char *)a6 = 0;
    *(void *)(a6 + 8) = 100;
    *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a6 + 24) = v28;
    *(_OWORD *)(a6 + 40) = v29;
    goto LABEL_27;
  }
  *(unsigned char *)a6 = 0;
  *(_OWORD *)(a6 + 8) = v36;
  *(void *)(a6 + 24) = v37;
  *(void *)(a6 + 48) = v39;
  *(_OWORD *)(a6 + 32) = v38;
  uint64_t v39 = 0;
  uint64_t v37 = 0;
  long long v38 = 0uLL;
LABEL_35:
  if (v37 && (v38 & 1) != 0) {
    (*(void (**)(void))(*(void *)v37 + 40))();
  }
LABEL_38:
  __n128 result = v40;
  if (v40)
  {
    if (v41) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v40 + 40))();
    }
  }
  return result;
}

re::DynamicString *re::GeomModelDescriptor::AttributeData::AttributeData(re::GeomModelDescriptor::AttributeData *this)
{
  *((unsigned char *)this + 32) = 4;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  return result;
}

double re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomModelDescriptor::AttributeData>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 56 * v4;
  double result = 0.0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v10 = *(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v7;
  *(void *)(v5 + 16) = v8;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 16) = v9;
  *(unsigned char *)(v5 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(v5 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::GeomModelDescriptor::addAttributeAlias@<Q0>(re::GeomModelDescriptor *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (char *)this + 48;
  uint64_t v9 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 48, (uint64_t)a2);
  if (v9)
  {
    uint64_t v10 = (unint64_t *)v9;
    if (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)v8, (uint64_t)a3)&& !(BOOL v11 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)this + 136, (uint64_t)a3)))
    {
      uint64_t v15 = "Alias with same name as existing attribute";
    }
    else
    {
      if (*((void *)a3 + 1)) {
        uint64_t v12 = (const char *)*((void *)a3 + 2);
      }
      else {
        uint64_t v12 = (char *)a3 + 9;
      }
      uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexPosition");
      if (v13)
      {
        uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexUV");
        if (v13)
        {
          uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexNormal");
          if (v13)
          {
            uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexTangent");
            if (v13)
            {
              uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexBitangent");
              if (v13)
              {
                uint64_t v13 = (_anonymous_namespace_ *)strcmp(v12, "vertexColor");
                if (v13)
                {
                  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace((uint64_t)this + 136, a3, a2);
                  v18.n128_u64[0] = *v10;
                  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace((uint64_t)v8, a3, &v18);
                  *(unsigned char *)a4 = 1;
                  return result;
                }
              }
            }
          }
        }
      }
      uint64_t v15 = "Alias with core attribute name";
    }
  }
  else
  {
    uint64_t v15 = "Alias for missing attribute";
  }
  __n128 result = v18;
  uint64_t v16 = v19;
  uint64_t v17 = v20;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 100;
  *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
  *(__n128 *)(a4 + 24) = result;
  *(void *)(a4 + 40) = v16;
  *(void *)(a4 + 48) = v17;
  return result;
}

uint64_t re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(uint64_t a1, re::DynamicString *a2, void *a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v12, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    uint64_t result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v8, v7, a2, a3);
    goto LABEL_9;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t result = re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2);
    if (result) {
      break;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  *(void *)(v10 + 56 * v9 + 48) = *a3;
LABEL_9:
  ++*(_DWORD *)(a1 + 40);
  return result;
}

uint64_t re::GeomModelDescriptor::removeAttributeAlias@<X0>(re::GeomModelDescriptor *this@<X0>, const re::DynamicString *a2@<X1>, unsigned char *a3@<X8>)
{
  unint64_t v6 = (char *)this + 136;
  uint64_t result = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)this + 136, (uint64_t)a2);
  if (result)
  {
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)v6, (uint64_t)a2);
    uint64_t result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)this + 48, (uint64_t)a2);
  }
  *a3 = 1;
  return result;
}

__n128 re::GeomModelDescriptor::setMaterialAssignmentsPerFace@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v14[0] = a2;
  v14[1] = a3;
  if (a3)
  {
    re::GeomModelDescriptor::makeSlicePayload<unsigned int>((re *)v14, (uint64_t *)&v11);
    unint64_t v7 = v11.n128_u64[0];
    v11.n128_u64[0] = 0;
    uint64_t v8 = *((void *)a1 + 1);
    *((void *)a1 + 1) = v7;
    if (v8)
    {

      if (v11.n128_u64[0]) {
    }
      }
    *(unsigned char *)a4 = 1;
  }
  else
  {
    __n128 result = v11;
    uint64_t v9 = v12;
    uint64_t v10 = v13;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 100;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a4 + 24) = result;
    *(void *)(a4 + 40) = v9;
    *(void *)(a4 + 48) = v10;
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<unsigned int>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  unint64_t v6 = *((void *)a1 + 1);
  if (!v6)
  {
    size_t v9 = 0;
    uint64_t v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 62) && 4 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v4[2] + 32))(v4[2], (4 * v6 + 16) | 3, 0);
    uint64_t v8 = (void *)((v7 + 19) & 0xFFFFFFFFFFFFFFFCLL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 4 * v6);
    size_t v9 = 4 * *((void *)a1 + 1);
LABEL_6:
    uint64_t v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    uint64_t v10 = *((void *)a1 + 1);
    uint64_t v14 = 4;
    uint64_t v15 = v10;
    int v13 = 0;
    char v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, re::ConvertToGeomModelValueType<unsigned int>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<unsigned int>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 4, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

unint64_t *re::GeomModelDescriptor::deleteAttribute@<X0>(re::GeomModelDescriptor *this@<X0>, const re::DynamicString *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  unint64_t v6 = (char *)this + 48;
  uint64_t result = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 48, (uint64_t)a2);
  if (!result)
  {
    *a3 = 1;
    return result;
  }
  uint64_t v8 = result;
  size_t v9 = &v60;
  unint64_t v10 = *result;
  __n128 v11 = (char *)*((void *)this + 14);
  if ((unint64_t)v11 <= *result)
  {
LABEL_68:
    uint64_t v49 = 0;
    v9[3] = 0u;
    v9[4] = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v52 = 136315906;
    long long v53 = "operator[]";
    __int16 v54 = 1024;
    int v55 = 789;
    __int16 v56 = 2048;
    unint64_t v57 = v10;
    __int16 v58 = 2048;
    unsigned int v59 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_69;
  }
  uint64_t v48 = (uint64_t)v6;
  __int16 v45 = a3;
  re::DynamicString::DynamicString((re::DynamicString *)&v49, (const re::DynamicString *)(*((void *)this + 16) + 56 * v10));
  unint64_t v46 = *((void *)this + 14);
  unint64_t v3 = *v8;
  unint64_t v47 = v46 - 1;
  if (v46 - 1 != *v8)
  {
    unint64_t v6 = (char *)*((void *)this + 14);
    if (!v46)
    {
LABEL_69:
      uint64_t v51 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v52 = 136315906;
      long long v53 = "operator[]";
      __int16 v54 = 1024;
      int v55 = 789;
      __int16 v56 = 2048;
      unint64_t v57 = v47;
      __int16 v58 = 2048;
      unsigned int v59 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_70;
    }
    if (v46 <= v3)
    {
LABEL_70:
      uint64_t v51 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v52 = 136315906;
      long long v53 = "operator[]";
      __int16 v54 = 1024;
      int v55 = 789;
      __int16 v56 = 2048;
      unint64_t v57 = v3;
      __int16 v58 = 2048;
      unsigned int v59 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_71:
      uint64_t v51 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v52 = 136315906;
      long long v53 = "operator[]";
      __int16 v54 = 1024;
      int v55 = 789;
      __int16 v56 = 2048;
      unint64_t v57 = v10;
      __int16 v58 = 2048;
      unsigned int v59 = v11;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v12 = *((void *)this + 16);
    uint64_t v13 = v12 + 56 * v47;
    uint64_t v14 = v12 + 56 * v3;
    re::DynamicString::operator=((re::DynamicString *)v14, (re::DynamicString *)v13);
    *(unsigned char *)(v14 + 32) = *(unsigned char *)(v13 + 32);
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v14 + 40), *(void *)(v13 + 40));
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v14 + 48), *(void *)(v13 + 48));
    unint64_t v10 = *v8;
    __n128 v11 = (char *)*((void *)this + 14);
    if ((unint64_t)v11 <= *v8) {
      goto LABEL_71;
    }
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(v48, (re::DynamicString *)(*((void *)this + 16) + 56 * v10), v8);
    uint64_t v15 = (char *)*((unsigned int *)this + 42);
    if (v15)
    {
      __n128 v11 = 0;
      uint64_t v16 = (int *)(*((void *)this + 19) + 8);
      while (1)
      {
        int v17 = *v16;
        v16 += 20;
        if (v17 < 0) {
          break;
        }
        if (v15 == ++v11)
        {
          __n128 v11 = (char *)*((unsigned int *)this + 42);
          break;
        }
      }
    }
    else
    {
      __n128 v11 = 0;
    }
    if (v15 != v11)
    {
      unint64_t v3 = v11;
      unsigned int v18 = *((_DWORD *)this + 42);
      while (1)
      {
        unint64_t v10 = *v8;
        unint64_t v6 = (char *)*((void *)this + 14);
        if ((unint64_t)v6 <= *v8) {
          break;
        }
        uint64_t v19 = *((void *)this + 19);
        if (re::DynamicString::operator==(v19 + 80 * v3 + 48, *((void *)this + 16) + 56 * v10))
        {
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(v48, (re::DynamicString *)(v19 + 80 * v3 + 16), v8);
          unsigned int v18 = *((_DWORD *)this + 42);
        }
        if (v18 <= (int)v11 + 1) {
          uint64_t v20 = (char *)(v11 + 1);
        }
        else {
          uint64_t v20 = (char *)v18;
        }
        while (1)
        {
          unint64_t v3 = (v11 + 1);
          if (v20 - 1 == v11) {
            break;
          }
          LODWORD(v11) = v11 + 1;
          long long v21 = (char *)v3;
          if ((*(_DWORD *)(*((void *)this + 19) + 80 * v3 + 8) & 0x80000000) != 0) {
            goto LABEL_26;
          }
        }
        long long v21 = v20;
LABEL_26:
        __n128 v11 = v21;
        if (v15 == v21) {
          goto LABEL_27;
        }
      }
      uint64_t v51 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v52 = 136315906;
      long long v53 = "operator[]";
      __int16 v54 = 1024;
      int v55 = 789;
      __int16 v56 = 2048;
      unint64_t v57 = v10;
      __int16 v58 = 2048;
      unsigned int v59 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_68;
    }
  }
LABEL_27:
  uint64_t v22 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v48, (uint64_t)&v49);
  unint64_t v23 = *((void *)this + 14);
  if (v23 < v47)
  {
    if (*((void *)this + 13) < v47)
    {
      uint64_t v22 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomModelDescriptor::AttributeData>::setCapacity((void *)this + 12, v47);
      unint64_t v23 = *((void *)this + 14);
    }
    uint64_t v24 = v45;
    if (v23 < v47)
    {
      unint64_t v25 = ~v23 + v46;
      uint64_t v26 = 56 * v23;
      do
      {
        uint64_t v27 = *((void *)this + 16) + v26;
        *(unsigned char *)(v27 + 32) = 4;
        v26 += 56;
        *(void *)(v27 + 40) = 0;
        *(void *)(v27 + 48) = 0;
        --v25;
      }
      while (v25);
    }
LABEL_41:
    *((void *)this + 14) = v47;
    ++*((_DWORD *)this + 30);
    goto LABEL_42;
  }
  uint64_t v24 = v45;
  if (v23 > v47)
  {
    uint64_t v28 = 56 * v46;
    unint64_t v29 = v46 - 1;
    do
    {
      uint64_t v30 = *((void *)this + 16) + v28;
      uint64_t v31 = *(void *)(v30 - 8);
      if (v31)
      {

        *(void *)(v30 - 8) = 0;
      }
      uint64_t v32 = *(void *)(v30 - 16);
      if (v32)
      {

        *(void *)(v30 - 16) = 0;
      }
      re::DynamicString::deinit((re::DynamicString *)(v30 - 56));
      ++v29;
      v28 += 56;
    }
    while (v29 < *((void *)this + 14));
    goto LABEL_41;
  }
LABEL_42:
  *(void *)&long long v62 = 0;
  *(void *)&long long v61 = 0;
  long long v60 = 0uLL;
  DWORD2(v61) = 0;
  uint64_t v33 = *((unsigned int *)this + 42);
  if (v33)
  {
    uint64_t v34 = 0;
    uint64_t v35 = (int *)(*((void *)this + 19) + 8);
    while (1)
    {
      int v36 = *v35;
      v35 += 20;
      if (v36 < 0) {
        break;
      }
      if (v33 == ++v34)
      {
        LODWORD(v34) = *((_DWORD *)this + 42);
        break;
      }
    }
  }
  else
  {
    LODWORD(v34) = 0;
  }
  if (v33 != v34)
  {
    uint64_t v37 = (char *)this + 136;
    uint64_t v38 = v34;
    unsigned int v39 = *((_DWORD *)this + 42);
    do
    {
      uint64_t v40 = *((void *)this + 19);
      if (re::DynamicString::operator==(v40 + 80 * v38 + 48, (uint64_t)&v49))
      {
        re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&v60, (re::DynamicString *)(v40 + 80 * v38 + 16));
        unsigned int v39 = *((_DWORD *)this + 42);
      }
      if (v39 <= (int)v34 + 1) {
        unsigned int v41 = v34 + 1;
      }
      else {
        unsigned int v41 = v39;
      }
      while (1)
      {
        uint64_t v38 = (v34 + 1);
        if (v41 - 1 == v34) {
          break;
        }
        LODWORD(v34) = v34 + 1;
        unsigned int v42 = v38;
        if ((*(_DWORD *)(*((void *)this + 19) + 80 * v38 + 8) & 0x80000000) != 0) {
          goto LABEL_59;
        }
      }
      unsigned int v42 = v41;
LABEL_59:
      LODWORD(v34) = v42;
    }
    while (v33 != v42);
    if ((void)v61)
    {
      uint64_t v43 = v62;
      uint64_t v44 = 32 * v61;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)v37, v43);
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v48, v43);
        v43 += 32;
        v44 -= 32;
      }
      while (v44);
    }
  }
  *uint64_t v24 = 1;
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v60);
  uint64_t result = (unint64_t *)v49;
  if (v49)
  {
    if (v50) {
      return (unint64_t *)(*(uint64_t (**)(void))(*(void *)v49 + 40))();
    }
  }
  return result;
}

uint64_t re::GeomModelDescriptor::emptyAttribute(re::GeomModelDescriptor *this)
{
  v1 = &unk_2687A0000;
  {
    v1 = (void *)&unk_2687A0000;
    if (v3) {
      operator new();
    }
  }
  return v1[386];
}

void std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::~__func()
{
}

void *std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E715848;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E715848;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::operator()(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void))(a1 + 8))(*a2);
}

uint64_t std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<void (*)(void const*),std::allocator<void (*)(void const*)>,void ()(void const*)>::target_type()
{
}

void *std::__function::__value_func<void ()(void const*)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *re::DynamicArray<re::GeomModelDescriptor::AttributeData>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomModelDescriptor::AttributeData>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomModelDescriptor::AttributeData>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::GeomModelDescriptor::AttributeData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomModelDescriptor::AttributeData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 56 * v9;
        __n128 v11 = v7;
        do
        {
          *(_OWORD *)__n128 v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          void *v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          *((unsigned char *)v11 + 32) = *(unsigned char *)(v8 + 32);
          v11[5] = *(void *)(v8 + 40);
          *(void *)(v8 + 40) = 0;
          v11[6] = *(void *)(v8 + 48);
          *(void *)(v8 + 48) = 0;
          uint64_t v16 = *(void *)(v8 + 40);
          if (v16)
          {

            *(void *)(v8 + 40) = 0;
          }
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 56;
          v11 += 7;
          v10 -= 56;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<unsigned int>(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>@<X0>(re *a1@<X0>, char *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, int *a5@<X4>, char *a6@<X5>, uint64_t *a7@<X6>, uint64_t a8@<X7>, uint64_t *a9@<X8>)
{
  unsigned int v18 = re::globalAllocators(a1);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[2] + 32))(v18[2], 104, 8);
  uint64_t result = re::internal::DataPayload::DataPayload(v19, *(void *)a1, *a2, *a3, *a4, *a5, *a6, *a7, a8);
  *a9 = result;
  return result;
}

void re::internal::createGeomMeshFromMDLSubmesh(re::internal *this@<X0>, MDLMesh *a2@<X1>, re::GeomMesh *a3@<X8>)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  uint64_t v6 = this;
  unint64_t v7 = a2;
  unsigned int v59 = a3;
  re::GeomMesh::GeomMesh(a3, 0);
  uint64_t v69 = 0;
  v66[1] = 0;
  unint64_t v67 = 0;
  v66[0] = 0;
  int v68 = 0;
  unint64_t v9 = v67;
  if (!v67) {
    goto LABEL_48;
  }
  int v55 = [(re::internal *)v6 vertexDescriptor];
  uint64_t v10 = [v55 attributeNamed:@"position"];
  uint64_t v11 = [v10 bufferIndex];
  uint64_t v12 = [(MDLMesh *)v7 faceIndexing];

  __int16 v54 = v10;
  if (!v12) {
    goto LABEL_5;
  }
  uint64_t v13 = [(MDLMesh *)v7 faceIndexing];
  uint64_t v14 = [v13 objectAtIndexedSubscript:v11];
  unsigned int v15 = [v14 unsignedIntValue];

  unsigned int v16 = v15;
  if (v9 <= v15)
  {
    *(void *)v84 = 0;
    memset(v75, 0, 32);
    long long v73 = 0u;
    long long v74 = 0u;
    *(_OWORD *)v72 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v91[0]) = 136315906;
    *(void *)((char *)v91 + 4) = "operator[]";
    WORD6(v91[0]) = 1024;
    *(_DWORD *)((char *)v91 + 14) = 789;
    WORD1(v91[1]) = 2048;
    *(void *)((char *)&v91[1] + 4) = v15;
    WORD6(v91[1]) = 2048;
    *(void *)((char *)&v91[1] + 14) = v9;
    LODWORD(v53) = 38;
    int v52 = v91;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    unsigned int v16 = 0;
  }
  uint64_t v17 = v69;
  uint64_t v18 = v69 + 80 * v16;
  uint64_t v21 = *(void *)(v18 + 56);
  uint64_t v19 = (unint64_t *)(v18 + 56);
  unsigned int v20 = v21;
  unsigned int v22 = *((_DWORD *)v19 - 10);
  re::GeomMeshBuilder::GeomMeshBuilder((re *)v72, (uint64_t)v59);
  if (LODWORD(v72[1]) > v22 && v74 && (v74 - 1) > (unint64_t)v74)
  {
    while (1)
      ;
  }
  LODWORD(v72[1]) = v22;
  unsigned int v76 = v22;
  if (v77)
  {
    unint64_t v23 = v78;
    uint64_t v24 = 8 * v77;
    do
    {
      uint64_t v25 = *v23++;
      (*(void (**)(uint64_t, void))(*(void *)v25 + 72))(v25, v76);
      v24 -= 8;
    }
    while (v24);
  }
  unint64_t v57 = v7;
  __int16 v58 = v6;
  if (v74 > v20)
  {
    int v26 = v83;
    if (v83)
    {
      unsigned int v27 = 0;
      do
      {
        uint64_t v28 = (re::internal *)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)&v82, v27);
        re::internal::accessFaceVaryingAttributeSubmesh(v28, v29);
        ++v27;
      }
      while (v26 != v27);
    }
  }
  re::DynamicArray<re::GeomCell4>::resize(&v73, v20);
  unsigned int v79 = v20;
  if (v80)
  {
    uint64_t v30 = v81;
    uint64_t v31 = 8 * v80;
    do
    {
      uint64_t v32 = *v30++;
      (*(void (**)(uint64_t, void))(*(void *)v32 + 72))(v32, v79);
      v31 -= 8;
    }
    while (v31);
  }
  if (v20)
  {
    unint64_t v33 = 0;
    uint64_t v34 = 8;
    while (1)
    {
      unint64_t v35 = *v19;
      if (*v19 <= v33) {
        break;
      }
      re::GeomMeshBuilder::setFaceVertices((uint64_t)v72, v33++, *(_DWORD *)(*(void *)(v17 + 80 * v16 + 72) + v34 - 8), *(_DWORD *)(*(void *)(v17 + 80 * v16 + 72) + v34 - 4), *(_DWORD *)(*(void *)(v17 + 80 * v16 + 72) + v34), *(_DWORD *)(*(void *)(v17 + 80 * v16 + 72) + v34 + 4));
      v34 += 16;
      if (v20 == v33) {
        goto LABEL_24;
      }
    }
    uint64_t v70 = 0;
    memset(v91, 0, sizeof(v91));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v84 = 136315906;
    *(void *)&v84[4] = "operator[]";
    __int16 v85 = 1024;
    int v86 = 797;
    __int16 v87 = 2048;
    unint64_t v88 = v33;
    __int16 v89 = 2048;
    unint64_t v90 = v35;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "topologies.size() > 0", "createGeomMeshFromMDLSubmesh", 655, v54);
    _os_crash();
    __break(1u);
  }
LABEL_24:
  int v36 = (re *)re::GeomMesh::operator=((uint64_t)v59, &v72[1]);
  re::GeomMesh::setName(v36, v72[0]);
  re::GeomMesh::freeName((re *)v72);
  re::GeomMesh::freeName((re *)v72);
  re::internal::GeomAttributeManager::~GeomAttributeManager((re::internal::GeomAttributeManager *)((char *)v75 + 8));
  if ((void)v73 && *(void *)&v75[0]) {
    (*(void (**)(void, void))(*(void *)v73 + 40))(v73, *(void *)&v75[0]);
  }
  uint64_t v37 = *MEMORY[0x263F135C8];
  {
    *(void *)&v91[0] = re::GeomMesh::modifyVertexPositions(v59);
    *((void *)&v91[0] + 1) = v38;
  }
  uint64_t v40 = v17 + 80 * v16;
  uint64_t v41 = *MEMORY[0x263F135B8];
  uint64_t v42 = *MEMORY[0x263F135D0];
  uint64_t v61 = *MEMORY[0x263F13590];
  uint64_t v60 = *MEMORY[0x263F135D8];
  uint64_t v56 = v40;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  uint64_t v43 = [v55 attributes];
  uint64_t v44 = [v43 countByEnumeratingWithState:&v62 objects:v71 count:16];
  if (v44)
  {
    uint64_t v45 = v44;
    uint64_t v46 = *(void *)v63;
    while (2)
    {
      for (uint64_t i = 0; i != v45; ++i)
      {
        if (*(void *)v63 != v46) {
          objc_enumerationMutation(v43);
        }
        uint64_t v48 = *(void **)(*((void *)&v62 + 1) + 8 * i);
        uint64_t v49 = objc_msgSend(v48, "name", v52, v53);
        if (([v49 isEqualToString:v37] & 1) == 0
          && ([v49 isEqualToString:v41] & 1) == 0
          && ([v49 isEqualToString:v42] & 1) == 0
          && ([v49 isEqualToString:v61] & 1) == 0
          && ([v49 isEqualToString:v60] & 1) == 0)
        {
          id v50 = v49;
          if (!*(unsigned char *)[v50 UTF8String])
          {

            goto LABEL_46;
          }
          if ((unint64_t)([v48 format] - 786437) >= 0xFFFFFFFFFFFFFFFDLL)
          {
            id v51 = v50;
          }
        }
      }
      uint64_t v45 = [v43 countByEnumeratingWithState:&v62 objects:v71 count:16];
      if (v45) {
        continue;
      }
      break;
    }
  }
LABEL_46:
}

void re::internal::anonymous namespace'::extractMDLAttributeTopologies(void *a1, uint64_t a2)
{
  uint64_t v192 = *MEMORY[0x263EF8340];
  id v4 = a1;
  re::DynamicArray<re::RigBasicConstraint>::clear(a2);
  if (!v4) {
    goto LABEL_211;
  }
  uint64_t v5 = [v4 indexBuffer];
  uint64_t v6 = [v5 map];

  if (!v6) {
    goto LABEL_211;
  }
  unint64_t v7 = [v4 indexBuffer];
  uint64_t v8 = [v7 map];
  uint64_t v9 = [v8 bytes];

  if (!v9) {
    goto LABEL_211;
  }
  v166 = (void *)a2;
  uint64_t v10 = [v4 geometryType];
  uint64_t v11 = [v4 indexBuffer];
  unint64_t v12 = [v11 length];
  unint64_t v13 = [v4 indexBuffer];
  uint64_t v14 = [(id)v13 map];
  uint64_t v15 = [v14 bytes];
  uint64_t v16 = [v4 indexType];
  uint64_t v18 = v16;
  v173[1] = v15;
  v173[2] = v16;
  if (v16 != 8)
  {
    if (v16 == 32)
    {
      v12 >>= 2;
    }
    else
    {
      if (v16 != 16) {
        goto LABEL_237;
      }
      v12 >>= 1;
    }
  }
  unint64_t v19 = (unint64_t)v181;
  v173[0] = v12;

  if (v10 != 2)
  {
    if (v10 == 5)
    {
      id v156 = v4;
      id v45 = v4;
      uint64_t v46 = [v45 topology];
      unint64_t v47 = [v46 faceTopology];
      uint64_t v159 = [v47 length];
      uint64_t v154 = v47;
      uint64_t v48 = [v47 map];
      uint64_t v165 = [v48 bytes];

      uint64_t v49 = [v45 faceIndexing];
      unsigned int v157 = [v46 faceCount];
      v153 = v49;
      uint64_t v50 = [v49 count];
      char v155 = v46;
      unsigned int v51 = 0;
      if (v50)
      {
        for (uint64_t i = 0; i != v50; ++i)
        {
          uint64_t v53 = [v45 faceIndexing];
          __int16 v54 = [v53 objectAtIndexedSubscript:i];
          unsigned int v55 = [v54 intValue];

          if (v55 > v51)
          {
            uint64_t v56 = [v45 faceIndexing];
            unint64_t v57 = [v56 objectAtIndexedSubscript:i];
            unsigned int v51 = [v57 intValue];
          }
        }
      }
      unint64_t v58 = v51 + 1;
      unsigned int v59 = [v45 indexCount];
      uint64_t v60 = v166;
      if (v51 != -1)
      {
        unsigned int v161 = 0;
        unsigned int v162 = 0;
        uint64_t v151 = v51;
        unint64_t v19 = 0;
        unsigned int v152 = v59 / v58;
        id v164 = v45;
        uint64_t v61 = v159;
        unint64_t v172 = v58;
        while (1)
        {
          unint64_t v2 = v60[2];
          if (v2 <= v19) {
            goto LABEL_233;
          }
          unint64_t v2 = v60[4];
          memset(v180, 0, 36);
          *(void *)&v180[36] = 0x7FFFFFFFLL;
          long long v158 = (void *)(v2 + 80 * v19 + 40);
          re::DynamicArray<re::GeomCell4>::resize(v158, v157);
          if (v157) {
            break;
          }
LABEL_137:
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v180);
          BOOL v106 = v19++ == v151;
          uint64_t v60 = v166;
          if (v106)
          {
            if (v162)
            {
              v107 = *re::pipelineLogObjects(v105);
              if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 67109890;
                *(_WORD *)&buf[8] = 2080;
                *(_DWORD *)&buf[4] = v162 / v58;
                if (v162 / v58 == 1) {
                  uint64_t v108 = "";
                }
                else {
                  uint64_t v108 = "s";
                }
                *(void *)&buf[10] = v108;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v161;
                *(_WORD *)&buf[24] = 1024;
                *(_DWORD *)&buf[26] = v157;
                _os_log_debug_impl(&dword_233120000, v107, OS_LOG_TYPE_DEBUG, "Mesh contains %d polygon%s with edge count greater than 4 (max edge count %d) out of total face count %d.  The nGons have been triangulated.", buf, 0x1Eu);
              }
            }
            goto LABEL_210;
          }
        }
        unint64_t v63 = 0;
        unint64_t v64 = v2 + 80 * v19;
        unint64_t v13 = 0;
        uint64_t v170 = (void *)(v64 + 72);
        char v171 = (unint64_t *)(v64 + 56);
        unint64_t v167 = v19;
        while (1)
        {
          if (v63 == v61) {
            goto LABEL_224;
          }
          unint64_t v2 = *(unsigned __int8 *)(v165 + v63);
          if (v2 <= 2) {
            goto LABEL_207;
          }
          unsigned int v178 = 0;
          unint64_t v65 = (v19 + v13 * v58);
          if (v12 <= v65) {
            goto LABEL_225;
          }
          switch(v18)
          {
            case 32:
              unsigned int v66 = *(_DWORD *)(v15 + 4 * v65);
              break;
            case 16:
              unsigned int v66 = *(unsigned __int16 *)(v15 + 2 * v65);
              break;
            case 8:
              unsigned int v66 = *(unsigned __int8 *)(v15 + v65);
              break;
            default:
              goto LABEL_236;
          }
          unsigned int v177 = 0;
          unsigned int v178 = v66;
          unint64_t v67 = (v58 + v58 * v13 + v19);
          if (v12 <= v67) {
            goto LABEL_226;
          }
          if (v18 == 32)
          {
            unsigned int v68 = *(_DWORD *)(v15 + 4 * v67);
          }
          else if (v18 == 16)
          {
            unsigned int v68 = *(unsigned __int16 *)(v15 + 2 * v67);
          }
          else
          {
            unsigned int v68 = *(unsigned __int8 *)(v15 + v67);
          }
          int v176 = 0;
          unsigned int v177 = v68;
          int v69 = v13 + 2;
          unint64_t v70 = (v19 + (v13 + 2) * v58);
          if (v12 <= v70) {
            goto LABEL_227;
          }
          unint64_t v168 = v63;
          if (v18 == 32) {
            int v71 = *(_DWORD *)(v15 + 4 * v70);
          }
          else {
            int v71 = v18 == 16 ? *(unsigned __int16 *)(v15 + 2 * v70) : *(unsigned __int8 *)(v15 + v70);
          }
          int v176 = v71;
          unint64_t v19 = re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, &v178);
          v72 = (int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, &v177);
          long long v73 = (int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, (unsigned int *)&v176);
          if (!v19) {
            break;
          }
          if (!v72) {
            break;
          }
          long long v74 = v73;
          if (!v73) {
            break;
          }
          if (v2 == 4)
          {
            unsigned int v175 = 0;
            unint64_t v80 = (v167 + (v13 + 3) * v172);
            if (v12 <= v80) {
              goto LABEL_230;
            }
            id v45 = v164;
            if (v18 == 32)
            {
              unsigned int v81 = *(_DWORD *)(v15 + 4 * v80);
            }
            else if (v18 == 16)
            {
              unsigned int v81 = *(unsigned __int16 *)(v15 + 2 * v80);
            }
            else
            {
              unsigned int v81 = *(unsigned __int8 *)(v15 + v80);
            }
            unsigned int v175 = v81;
            uint64_t v98 = (int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, &v175);
            if (!v98)
            {
LABEL_207:
              re::DynamicArray<re::RigBasicConstraint>::clear((uint64_t)v166);
              goto LABEL_209;
            }
            int v99 = v2;
            unint64_t v2 = *v171;
            unint64_t v75 = v168;
            if (*v171 <= v168) {
              goto LABEL_232;
            }
            v100 = (_DWORD *)(*v170 + 16 * v168);
            int v101 = *v72;
            int v102 = *v74;
            int v103 = *v98;
            _DWORD *v100 = *(_DWORD *)v19;
            v100[1] = v101;
            v100[2] = v102;
            v100[3] = v103;
            int v76 = v99;
          }
          else
          {
            unint64_t v75 = v168;
            if (v2 == 3)
            {
              int v76 = 3;
              unint64_t v2 = *v171;
              if (*v171 <= v168) {
                goto LABEL_229;
              }
              uint64_t v77 = (_DWORD *)(*v170 + 16 * v168);
              int v78 = *v72;
              int v79 = *v73;
              *uint64_t v77 = *(_DWORD *)v19;
              v77[1] = v78;
              v77[2] = v79;
              v77[3] = -1;
              id v45 = v164;
            }
            else
            {
              int v163 = v13;
              unint64_t v13 = *v171;
              if (*v171 <= v168) {
                goto LABEL_231;
              }
              uint64_t v82 = (_DWORD *)(*v170 + 16 * v168);
              int v83 = *v72;
              int v84 = *v73;
              *uint64_t v82 = *(_DWORD *)v19;
              v82[1] = v83;
              v82[2] = v84;
              v82[3] = -1;
              unsigned int v160 = v2;
              unint64_t v85 = (v2 + v13 - 3);
              re::DynamicArray<re::GeomCell4>::resize(v158, v85);
              if (v85 <= v13)
              {
LABEL_122:
                int v76 = v160;
                if (v161 <= v160) {
                  unsigned int v97 = v160;
                }
                else {
                  unsigned int v97 = v161;
                }
                LODWORD(v13) = v163;
                unsigned int v161 = v97;
                ++v162;
                id v45 = v164;
                uint64_t v61 = v159;
                unint64_t v75 = v168;
              }
              else
              {
                unint64_t v2 = 0;
                unint64_t v13 = v13;
                uint64_t v86 = 16 * v13;
                int v169 = v172 * v69;
                int v87 = v167;
                while (1)
                {
                  unsigned int v175 = 0;
                  unint64_t v88 = (v169 + v87);
                  if (v12 <= v88) {
                    goto LABEL_221;
                  }
                  if (v18 == 32)
                  {
                    unsigned int v89 = *(_DWORD *)(v15 + 4 * v88);
                  }
                  else if (v18 == 16)
                  {
                    unsigned int v89 = *(unsigned __int16 *)(v15 + 2 * v88);
                  }
                  else
                  {
                    unsigned int v89 = *(unsigned __int8 *)(v15 + v88);
                  }
                  int v174 = 0;
                  unsigned int v175 = v89;
                  unint64_t v90 = (v172 * (v163 + 3) + v87);
                  if (v12 <= v90) {
                    goto LABEL_222;
                  }
                  if (v18 == 32) {
                    int v91 = *(_DWORD *)(v15 + 4 * v90);
                  }
                  else {
                    int v91 = v18 == 16 ? *(unsigned __int16 *)(v15 + 2 * v90) : *(unsigned __int8 *)(v15 + v90);
                  }
                  int v174 = v91;
                  uint64_t v92 = (int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, &v175);
                  v93 = (int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v180, (unsigned int *)&v174);
                  if (!v92 || !v93) {
                    break;
                  }
                  unint64_t v2 = *v171;
                  if (*v171 <= v13) {
                    goto LABEL_223;
                  }
                  uint64_t v94 = (_DWORD *)(*v170 + v86);
                  int v95 = *v92;
                  int v96 = *v93;
                  *uint64_t v94 = *(_DWORD *)v19;
                  v94[1] = v95;
                  ++v13;
                  v94[2] = v96;
                  v94[3] = -1;
                  unint64_t v2 = v13 >= v85;
                  v86 += 16;
                  v87 += v172;
                  if (v85 == v13) {
                    goto LABEL_122;
                  }
                }
                re::DynamicArray<re::RigBasicConstraint>::clear((uint64_t)v166);
                unsigned int v104 = v161;
                if (v161 <= v160) {
                  unsigned int v104 = v160;
                }
                id v45 = v164;
                if ((v2 & 1) == 0) {
                  goto LABEL_209;
                }
                unsigned int v161 = v104;
                LODWORD(v13) = v163;
                v162 += v2 & 1;
                uint64_t v61 = v159;
                unint64_t v75 = v168;
                int v76 = v160;
              }
            }
          }
          unint64_t v13 = (v13 + v76);
          unint64_t v63 = v75 + 1;
          unint64_t v58 = v172;
          unint64_t v19 = v167;
          if (v63 == v157) {
            goto LABEL_137;
          }
        }
        re::DynamicArray<re::RigBasicConstraint>::clear((uint64_t)v166);
        id v45 = v164;
LABEL_209:
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v180);
      }
LABEL_210:

      id v4 = v156;
LABEL_211:

      return;
    }
    if (v10 != 4) {
      goto LABEL_238;
    }
  }
  if (!v166[2])
  {
LABEL_228:
    *(void *)int v181 = 0;
    *(_OWORD *)(v19 + 96) = 0u;
    *(_OWORD *)(v19 + 112) = 0u;
    *(_OWORD *)(v19 + 64) = 0u;
    *(_OWORD *)(v19 + 80) = 0u;
    *(_OWORD *)(v19 + 48) = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v180 = 136315906;
    *(void *)&v180[4] = "operator[]";
    *(_WORD *)&v180[12] = 1024;
    *(_DWORD *)&v180[14] = 789;
    *(_WORD *)&v180[18] = 2048;
    *(void *)&v180[20] = 0;
    *(_WORD *)&v180[28] = 2048;
    *(void *)&v180[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_229:
    uint64_t v179 = 0;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v189 = 0u;
    memset(buf, 0, sizeof(buf));
    unint64_t v138 = v75;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v181 = 136315906;
    *(void *)&v181[4] = "operator[]";
    __int16 v182 = 1024;
    int v183 = 789;
    __int16 v184 = 2048;
    unint64_t v185 = v138;
    __int16 v186 = 2048;
    unint64_t v187 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_230:
    re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
    _os_crash();
    __break(1u);
LABEL_231:
    uint64_t v179 = 0;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v189 = 0u;
    memset(buf, 0, sizeof(buf));
    unint64_t v139 = v75;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v181 = 136315906;
    *(void *)&v181[4] = "operator[]";
    __int16 v182 = 1024;
    int v183 = 789;
    __int16 v184 = 2048;
    unint64_t v185 = v139;
    __int16 v186 = 2048;
    unint64_t v187 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_232:
    uint64_t v179 = 0;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v189 = 0u;
    memset(buf, 0, sizeof(buf));
    unint64_t v140 = v75;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v181 = 136315906;
    *(void *)&v181[4] = "operator[]";
    __int16 v182 = 1024;
    int v183 = 789;
    __int16 v184 = 2048;
    unint64_t v185 = v140;
    __int16 v186 = 2048;
    unint64_t v187 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_233:
    *(void *)int v181 = 0;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v189 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v180 = 136315906;
    *(void *)&v180[4] = "operator[]";
    *(_WORD *)&v180[12] = 1024;
    *(_DWORD *)&v180[14] = 789;
    *(_WORD *)&v180[18] = 2048;
    *(void *)&v180[20] = v19;
    *(_WORD *)&v180[28] = 2048;
    *(void *)&v180[30] = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v2 = v166[4];
  memset(v180, 0, 36);
  *(void *)&v180[36] = 0x7FFFFFFFLL;
  unint64_t v21 = [v4 indexCount];
  unsigned int v22 = (void *)(v2 + 40);
  if (v10 != 2)
  {
    re::DynamicArray<re::GeomCell4>::resize(v22, (v21 >> 2));
    if ((v21 & 0x3FFFFFFFCLL) == 0) {
      goto LABEL_206;
    }
    unint64_t v13 = 0;
    unsigned int v110 = 0;
    long long v111 = *(_OWORD *)v180;
    while (1)
    {
      if (v12 <= v110) {
        goto LABEL_216;
      }
      switch(v18)
      {
        case 32:
          unint64_t v112 = *(unsigned int *)(v15 + 4 * v110);
          if (!(void)v111) {
            goto LABEL_159;
          }
          break;
        case 16:
          unint64_t v112 = *(unsigned __int16 *)(v15 + 2 * v110);
          if (!(void)v111) {
            goto LABEL_159;
          }
          break;
        case 8:
          unint64_t v112 = *(unsigned __int8 *)(v15 + v110);
          if (!(void)v111)
          {
LABEL_159:
            uint64_t v115 = *(void *)&v180[16];
LABEL_160:
            LODWORD(v114) = 0x7FFFFFFF;
            goto LABEL_161;
          }
          break;
        default:
          goto LABEL_235;
      }
      unint64_t v113 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v112 ^ (v112 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v112 ^ (v112 >> 30))) >> 27));
      uint64_t v114 = *(unsigned int *)(*((void *)&v111 + 1) + 4 * ((v113 ^ (v113 >> 31)) % *(unsigned int *)&v180[24]));
      uint64_t v115 = *(void *)&v180[16];
      if (v114 == 0x7FFFFFFF) {
        goto LABEL_160;
      }
      while (*(_DWORD *)(*(void *)&v180[16] + 24 * v114 + 12) != v112)
      {
        uint64_t v114 = *(_DWORD *)(*(void *)&v180[16] + 24 * v114 + 8) & 0x7FFFFFFF;
        if (v114 == 0x7FFFFFFF) {
          goto LABEL_160;
        }
      }
LABEL_161:
      unint64_t v116 = v110 | 1;
      if (v12 <= v116) {
        goto LABEL_217;
      }
      int v117 = *(_DWORD *)(v115 + 24 * v114 + 16);
      if (v18 == 32)
      {
        unint64_t v118 = *(unsigned int *)(v15 + 4 * v116);
        if (!(void)v111) {
          goto LABEL_170;
        }
      }
      else if (v18 == 16)
      {
        unint64_t v118 = *(unsigned __int16 *)(v15 + 2 * v116);
        if (!(void)v111) {
          goto LABEL_170;
        }
      }
      else
      {
        unint64_t v118 = *(unsigned __int8 *)(v15 + v116);
        if (!(void)v111) {
          goto LABEL_170;
        }
      }
      unint64_t v119 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v118 ^ (v118 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v118 ^ (v118 >> 30))) >> 27));
      uint64_t v120 = *(unsigned int *)(*((void *)&v111 + 1) + 4 * ((v119 ^ (v119 >> 31)) % *(unsigned int *)&v180[24]));
      if (v120 == 0x7FFFFFFF)
      {
LABEL_170:
        LODWORD(v120) = 0x7FFFFFFF;
        goto LABEL_171;
      }
      uint64_t v132 = *(unsigned int *)(v115 + 24 * v120 + 12);
      for (uint64_t j = v120; v132 != v118; LODWORD(v120) = j)
      {
        uint64_t j = *(_DWORD *)(v115 + 24 * j + 8) & 0x7FFFFFFF;
        LODWORD(v120) = 0x7FFFFFFF;
        if (j == 0x7FFFFFFF) {
          break;
        }
        uint64_t v132 = *(unsigned int *)(v115 + 24 * j + 12);
      }
LABEL_171:
      unint64_t v121 = v110 | 2;
      if (v12 <= v121) {
        goto LABEL_218;
      }
      int v122 = *(_DWORD *)(v115 + 24 * v120 + 16);
      if (v18 == 32)
      {
        unint64_t v123 = *(unsigned int *)(v15 + 4 * v121);
        if (!(void)v111) {
          goto LABEL_180;
        }
      }
      else if (v18 == 16)
      {
        unint64_t v123 = *(unsigned __int16 *)(v15 + 2 * v121);
        if (!(void)v111) {
          goto LABEL_180;
        }
      }
      else
      {
        unint64_t v123 = *(unsigned __int8 *)(v15 + v121);
        if (!(void)v111) {
          goto LABEL_180;
        }
      }
      unint64_t v124 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v123 ^ (v123 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v123 ^ (v123 >> 30))) >> 27));
      uint64_t v125 = *(unsigned int *)(*((void *)&v111 + 1) + 4 * ((v124 ^ (v124 >> 31)) % *(unsigned int *)&v180[24]));
      if (v125 == 0x7FFFFFFF)
      {
LABEL_180:
        uint64_t v125 = 0x7FFFFFFFLL;
        goto LABEL_181;
      }
      uint64_t v134 = *(unsigned int *)(v115 + 24 * v125 + 12);
      for (k = v125; v134 != v123; uint64_t v125 = k)
      {
        uint64_t k = *(_DWORD *)(v115 + 24 * k + 8) & 0x7FFFFFFF;
        uint64_t v125 = 0x7FFFFFFFLL;
        if (k == 0x7FFFFFFF) {
          break;
        }
        uint64_t v134 = *(unsigned int *)(v115 + 24 * k + 12);
      }
LABEL_181:
      unint64_t v126 = v110 | 3;
      if (v12 <= v126) {
        goto LABEL_219;
      }
      int v127 = *(_DWORD *)(v115 + 24 * v125 + 16);
      if (v18 == 32)
      {
        unint64_t v128 = *(unsigned int *)(v15 + 4 * v126);
        if (!(void)v111) {
          goto LABEL_190;
        }
      }
      else if (v18 == 16)
      {
        unint64_t v128 = *(unsigned __int16 *)(v15 + 2 * v126);
        if (!(void)v111) {
          goto LABEL_190;
        }
      }
      else
      {
        unint64_t v128 = *(unsigned __int8 *)(v15 + v126);
        if (!(void)v111) {
          goto LABEL_190;
        }
      }
      unint64_t v129 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v128 ^ (v128 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v128 ^ (v128 >> 30))) >> 27));
      uint64_t v130 = *(unsigned int *)(*((void *)&v111 + 1) + 4 * ((v129 ^ (v129 >> 31)) % *(unsigned int *)&v180[24]));
      if (v130 != 0x7FFFFFFF)
      {
        uint64_t v136 = *(unsigned int *)(v115 + 24 * v130 + 12);
        for (uint64_t m = v130; v136 != v128; LODWORD(v130) = m)
        {
          uint64_t m = *(_DWORD *)(v115 + 24 * m + 8) & 0x7FFFFFFF;
          LODWORD(v130) = 0x7FFFFFFF;
          if (m == 0x7FFFFFFF) {
            break;
          }
          uint64_t v136 = *(unsigned int *)(v115 + 24 * m + 12);
        }
        goto LABEL_191;
      }
LABEL_190:
      LODWORD(v130) = 0x7FFFFFFF;
LABEL_191:
      uint64_t v14 = *(void **)(v2 + 56);
      if ((unint64_t)v14 <= v13) {
        goto LABEL_220;
      }
      int v131 = *(_DWORD *)(v115 + 24 * v130 + 16);
      int v109 = (_DWORD *)(*(void *)(v2 + 72) + 16 * v13);
      *int v109 = v117;
      v109[1] = v122;
      v109[2] = v127;
      v109[3] = v131;
      ++v13;
      v110 += 4;
      if (v13 == (v21 >> 2)) {
        goto LABEL_206;
      }
    }
  }
  re::DynamicArray<re::GeomCell4>::resize(v22, (v21 / 3));
  if (!(v21 / 3))
  {
LABEL_206:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v180);
    goto LABEL_211;
  }
  unint64_t v13 = 0;
  unsigned int v24 = 0;
  long long v25 = *(_OWORD *)v180;
  while (1)
  {
    if (v12 <= v24)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)v23, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_213:
      re::internal::assertLog((re::internal *)4, v30, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_214:
      re::internal::assertLog((re::internal *)4, v34, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_215:
      uint64_t v179 = 0;
      long long v190 = 0u;
      long long v191 = 0u;
      long long v189 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int v181 = 136315906;
      *(void *)&v181[4] = "operator[]";
      __int16 v182 = 1024;
      int v183 = 789;
      __int16 v184 = 2048;
      unint64_t v185 = v13;
      __int16 v186 = 2048;
      unint64_t v187 = (unint64_t)v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_216:
      re::internal::assertLog((re::internal *)4, (uint64_t)v109, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_217:
      re::internal::assertLog((re::internal *)4, (uint64_t)v109, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_218:
      re::internal::assertLog((re::internal *)4, v121, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_219:
      re::internal::assertLog((re::internal *)4, v125, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_220:
      uint64_t v179 = 0;
      long long v190 = 0u;
      long long v191 = 0u;
      long long v189 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int v181 = 136315906;
      *(void *)&v181[4] = "operator[]";
      __int16 v182 = 1024;
      int v183 = 789;
      __int16 v184 = 2048;
      unint64_t v185 = v13;
      __int16 v186 = 2048;
      unint64_t v187 = (unint64_t)v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_221:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_222:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_223:
      uint64_t v179 = 0;
      long long v190 = 0u;
      long long v191 = 0u;
      long long v189 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int v181 = 136315906;
      *(void *)&v181[4] = "operator[]";
      __int16 v182 = 1024;
      int v183 = 789;
      __int16 v184 = 2048;
      unint64_t v185 = v13;
      __int16 v186 = 2048;
      unint64_t v187 = v2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_224:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_225:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_226:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
LABEL_227:
      re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
      _os_crash();
      __break(1u);
      goto LABEL_228;
    }
    if (v18 == 32)
    {
      unint64_t v26 = *(unsigned int *)(v15 + 4 * v24);
      if (!(void)v25) {
        goto LABEL_28;
      }
      goto LABEL_23;
    }
    if (v18 != 16) {
      break;
    }
    unint64_t v26 = *(unsigned __int16 *)(v15 + 2 * v24);
    if (!(void)v25)
    {
LABEL_28:
      uint64_t v29 = *(void *)&v180[16];
LABEL_29:
      LODWORD(v28) = 0x7FFFFFFF;
      goto LABEL_30;
    }
LABEL_23:
    unint64_t v27 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v26 ^ (v26 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v26 ^ (v26 >> 30))) >> 27));
    uint64_t v28 = *(unsigned int *)(*((void *)&v25 + 1) + 4 * ((v27 ^ (v27 >> 31)) % *(unsigned int *)&v180[24]));
    uint64_t v29 = *(void *)&v180[16];
    if (v28 == 0x7FFFFFFF) {
      goto LABEL_29;
    }
    while (*(_DWORD *)(*(void *)&v180[16] + 24 * v28 + 12) != v26)
    {
      uint64_t v28 = *(_DWORD *)(*(void *)&v180[16] + 24 * v28 + 8) & 0x7FFFFFFF;
      if (v28 == 0x7FFFFFFF) {
        goto LABEL_29;
      }
    }
LABEL_30:
    unint64_t v30 = v24 + 1;
    if (v12 <= v30) {
      goto LABEL_213;
    }
    int v31 = *(_DWORD *)(v29 + 24 * v28 + 16);
    if (v18 == 32)
    {
      unint64_t v32 = *(unsigned int *)(v15 + 4 * v30);
      if (!(void)v25) {
        goto LABEL_39;
      }
    }
    else if (v18 == 16)
    {
      unint64_t v32 = *(unsigned __int16 *)(v15 + 2 * v30);
      if (!(void)v25) {
        goto LABEL_39;
      }
    }
    else
    {
      unint64_t v32 = *(unsigned __int8 *)(v15 + v30);
      if (!(void)v25) {
        goto LABEL_39;
      }
    }
    unint64_t v33 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) >> 27));
    uint64_t v34 = *(unsigned int *)(*((void *)&v25 + 1) + 4 * ((v33 ^ (v33 >> 31)) % *(unsigned int *)&v180[24]));
    if (v34 == 0x7FFFFFFF)
    {
LABEL_39:
      uint64_t v34 = 0x7FFFFFFFLL;
      goto LABEL_40;
    }
    uint64_t v41 = *(unsigned int *)(v29 + 24 * v34 + 12);
    for (n = v34; v41 != v32; uint64_t v34 = n)
    {
      uint64_t n = *(_DWORD *)(v29 + 24 * n + 8) & 0x7FFFFFFF;
      uint64_t v34 = 0x7FFFFFFFLL;
      if (n == 0x7FFFFFFF) {
        break;
      }
      uint64_t v41 = *(unsigned int *)(v29 + 24 * n + 12);
    }
LABEL_40:
    unint64_t v35 = v24 + 2;
    if (v12 <= v35) {
      goto LABEL_214;
    }
    int v36 = *(_DWORD *)(v29 + 24 * v34 + 16);
    if (v18 == 32)
    {
      unint64_t v37 = *(unsigned int *)(v15 + 4 * v35);
      if (!(void)v25) {
        goto LABEL_49;
      }
    }
    else if (v18 == 16)
    {
      unint64_t v37 = *(unsigned __int16 *)(v15 + 2 * v35);
      if (!(void)v25) {
        goto LABEL_49;
      }
    }
    else
    {
      unint64_t v37 = *(unsigned __int8 *)(v15 + v35);
      if (!(void)v25) {
        goto LABEL_49;
      }
    }
    unint64_t v38 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) >> 27));
    uint64_t v39 = *(unsigned int *)(*((void *)&v25 + 1) + 4 * ((v38 ^ (v38 >> 31)) % *(unsigned int *)&v180[24]));
    if (v39 != 0x7FFFFFFF)
    {
      uint64_t v43 = *(unsigned int *)(v29 + 24 * v39 + 12);
      for (iuint64_t i = v39; v43 != v37; LODWORD(v39) = ii)
      {
        iuint64_t i = *(_DWORD *)(v29 + 24 * ii + 8) & 0x7FFFFFFF;
        LODWORD(v39) = 0x7FFFFFFF;
        if (ii == 0x7FFFFFFF) {
          break;
        }
        uint64_t v43 = *(unsigned int *)(v29 + 24 * ii + 12);
      }
      goto LABEL_50;
    }
LABEL_49:
    LODWORD(v39) = 0x7FFFFFFF;
LABEL_50:
    uint64_t v14 = *(void **)(v2 + 56);
    if ((unint64_t)v14 <= v13) {
      goto LABEL_215;
    }
    int v40 = *(_DWORD *)(v29 + 24 * v39 + 16);
    unint64_t v23 = (_DWORD *)(*(void *)(v2 + 72) + 16 * v13);
    *unint64_t v23 = v31;
    v23[1] = v36;
    _OWORD v23[2] = v40;
    v23[3] = -1;
    ++v13;
    v24 += 3;
    if (v13 == (v21 / 3)) {
      goto LABEL_206;
    }
  }
  if (v18 == 8)
  {
    unint64_t v26 = *(unsigned __int8 *)(v15 + v24);
    if (!(void)v25) {
      goto LABEL_28;
    }
    goto LABEL_23;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)v23, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v141, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v142, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
LABEL_235:
  re::internal::assertLog((re::internal *)4, (uint64_t)v109, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v143, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v144, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v145, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v146, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v147, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
LABEL_236:
  re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v148, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v149, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
LABEL_237:
  re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "MDLIndexBuffer", 65);
  _os_crash();
  __break(1u);
LABEL_238:
  re::internal::assertLog((re::internal *)4, v20, "assertion failure: '%s' (%s:line %i) Unsupported Geometry type", "!\"Unreachable code\"", "extractMDLAttributeTopologies", 475);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v150, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
  _os_crash();
  __break(1u);
}

uint64_t re::internal::anonymous namespace'::modelGetVertexAttributeBuffer(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = [v7 vertexDescriptor];
  uint64_t v10 = [v9 attributeNamed:v8];

  if (v10)
  {
    *(_DWORD *)(a4 + 32) = [v10 bufferIndex];
    uint64_t v11 = [v7 vertexAttributeDataForAttributeNamed:v8];
    if (v11)
    {
      if ([v10 format] == a3)
      {
        unint64_t v12 = [v10 offset];
        uint64_t v13 = [v10 bufferIndex];
        uint64_t v14 = [v11 stride];
        if ((v12 & 3) != 0)
        {
          NSLog(&cfstr_Modelconverter_1.isa);
        }
        else
        {
          unint64_t v17 = v14;
          if ((v14 & 3) == 0)
          {
            uint64_t v18 = [v7 vertexBuffers];
            unint64_t v19 = [v18 objectAtIndexedSubscript:v13];

            *(void *)(a4 + 8) = [v19 length];
            uint64_t v20 = [v19 map];
            *(void *)a4 = [v20 bytes];

            *(void *)(a4 + 16) = v12 >> 2;
            *(void *)(a4 + 24) = v17 >> 2;

            uint64_t v15 = 1;
            goto LABEL_9;
          }
          NSLog(&cfstr_Modelconverter_2.isa);
        }
      }
      else
      {
        NSLog(&cfstr_Modelconverter_0.isa);
      }
    }
    uint64_t v15 = 0;
LABEL_9:

    goto LABEL_10;
  }
  uint64_t v15 = 0;
LABEL_10:

  return v15;
}

void *re::internal::anonymous namespace'::copyVertex3FValues(void *result, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v4 = *(unsigned int *)(a3 + 8);
  if (v4)
  {
    unint64_t v5 = 0;
    unint64_t v6 = *result + (result[1] & 0xFFFFFFFFFFFFFFFCLL) - 12;
    do
    {
      if (*(void *)(a2 + 16) <= v5)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_10:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      unint64_t v7 = *result + 4 * result[2] + 4 * result[3] * *(unsigned int *)(*(void *)(a2 + 32) + 4 * v5);
      if (v7 <= v6)
      {
        if (v5 >= *(unsigned int *)(a3 + 8)) {
          goto LABEL_10;
        }
        a4.n128_u64[0] = *(void *)v7;
        a4.n128_u32[2] = *(_DWORD *)(v7 + 8);
        *(__n128 *)(*(void *)a3 + 16 * v5) = a4;
      }
      ++v5;
    }
    while (v4 != v5);
  }
  return result;
}

void re::internal::anonymous namespace'::addAttributeIfItExistsToGeomMesh(void *a1, void *a2, void *a3, char *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  id v13 = a1;
  id v14 = a2;
  id v15 = a3;
  uint64_t v16 = [v13 vertexDescriptor];
  unint64_t v17 = [v16 attributeNamed:v15];

  uint64_t v18 = [v17 format];
  if (v18 > 786434)
  {
    if (v18 == 786436)
    {
      int v20 = 0;
      uint64_t v21 = 8;
      int v59 = 1;
    }
    else
    {
      if (v18 != 786435) {
        goto LABEL_62;
      }
      int v59 = 0;
      uint64_t v21 = 7;
      int v20 = 1;
    }
LABEL_9:
    {
      int v57 = v20;
      id v56 = v14;
      unsigned int v22 = [v14 faceIndexing];
      unsigned int v55 = v22;
      if (v22)
      {
        unint64_t v23 = [v22 objectAtIndexedSubscript:v64];
        unsigned int v24 = [v23 unsignedIntValue];

        unint64_t v25 = v24;
      }
      else
      {
        unint64_t v25 = 0;
      }
      unint64_t v26 = *(void *)(a6 + 16);
      if (v26 <= v25) {
        goto LABEL_59;
      }
      uint64_t v27 = *(void *)(a6 + 32);
      unint64_t v58 = v25;
      unint64_t v26 = v27 + 80 * v25;
      if (v26 == a5
        || (uint64_t v28 = *(void *)(v26 + 16), v28 == *(void *)(a5 + 16))
        && !memcmp(*(const void **)(v26 + 32), *(const void **)(a5 + 32), 4 * v28)
        && re::DynamicArray<re::GeomCell4>::operator==(v27 + 80 * v58 + 40, a5 + 40))
      {
        uint64_t v29 = (uint64_t)re::GeomMesh::addAttribute(a7, a4, 1, v21);
      }
      else
      {
        *(void *)&v68[2] = 0;
        memset(v66, 0, sizeof(v66));
        re::DynamicArray<float>::resize((uint64_t)v66, *(unsigned int *)(a7 + 40));
        uint64_t v30 = *(unsigned int *)(a7 + 40);
        if (*(_DWORD *)(a7 + 40))
        {
          uint64_t v31 = 0;
          uint64_t v32 = *(void *)&v66[16];
          uint64_t v33 = *(void *)&v68[2];
          while (v32 != v31)
          {
            *(_DWORD *)(v33 + 4 * v31) = v31;
            if (v30 == ++v31) {
              goto LABEL_23;
            }
          }
          uint64_t v65 = 0;
          long long v77 = 0u;
          long long v78 = 0u;
          long long v75 = 0u;
          long long v76 = 0u;
          long long v74 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v69 = 136315906;
          *(void *)&v69[4] = "operator[]";
          *(_WORD *)&v69[12] = 1024;
          *(_DWORD *)&v69[14] = 789;
          __int16 v70 = 2048;
          uint64_t v71 = v32;
          __int16 v72 = 2048;
          uint64_t v73 = v32;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_57;
        }
LABEL_23:
        uint64_t v29 = re::GeomMesh::addFaceVaryingAttribute(a7, a4, v21, *(_DWORD *)(v26 + 16), (uint64_t *)(v27 + 80 * v58 + 40), (uint64_t *)v66);
        if (*(void *)v66 && *(void *)&v68[2]) {
          (*(void (**)(void))(**(void **)v66 + 40))();
        }
      }
      if (v59)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29))
        {
          uint64_t v34 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v29, 0);
          int v35 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
          unint64_t v36 = *(void *)(a6 + 16);
          if (v36 > v58)
          {
            if (v35)
            {
              unint64_t v26 = 0;
              unint64_t v37 = v60 + (v61 & 0xFFFFFFFFFFFFFFFCLL) - 16;
              uint64_t v38 = *(void *)(a6 + 32) + 80 * v58;
              uint64_t v39 = v63;
              uint64_t v40 = v60 + 4 * v62;
              while (1)
              {
                a6 = *(void *)(v38 + 16);
                if (a6 <= v26) {
                  break;
                }
                uint64_t v41 = (_OWORD *)(v40 + 4 * v39 * *(unsigned int *)(*(void *)(v38 + 32) + 4 * v26));
                if ((unint64_t)v41 <= v37) {
                  *(_OWORD *)(v34 + 16 * v26) = *v41;
                }
                if (v35 == ++v26) {
                  goto LABEL_54;
                }
              }
LABEL_57:
              *(void *)int v69 = 0;
              long long v77 = 0u;
              long long v78 = 0u;
              long long v75 = 0u;
              long long v76 = 0u;
              long long v74 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unsigned int v66 = 136315906;
              *(void *)&v66[4] = "operator[]";
              *(_WORD *)&v66[12] = 1024;
              *(_DWORD *)&v66[14] = 797;
              *(_WORD *)&v66[18] = 2048;
              *(void *)&v66[20] = v26;
              __int16 v67 = 2048;
              *(void *)unsigned int v68 = a6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_58:
              *(void *)int v69 = 0;
              long long v77 = 0u;
              long long v78 = 0u;
              long long v75 = 0u;
              long long v76 = 0u;
              long long v74 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unsigned int v66 = 136315906;
              *(void *)&v66[4] = "operator[]";
              *(_WORD *)&v66[12] = 1024;
              *(_DWORD *)&v66[14] = 797;
              *(_WORD *)&v66[18] = 2048;
              *(void *)&v66[20] = v26;
              __int16 v67 = 2048;
              *(void *)unsigned int v68 = a6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_59:
              *(void *)int v69 = 0;
              long long v77 = 0u;
              long long v78 = 0u;
              long long v75 = 0u;
              long long v76 = 0u;
              long long v74 = 0u;
              unint64_t v53 = v25;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unsigned int v66 = 136315906;
              *(void *)&v66[4] = "operator[]";
              *(_WORD *)&v66[12] = 1024;
              *(_DWORD *)&v66[14] = 789;
              *(_WORD *)&v66[18] = 2048;
              *(void *)&v66[20] = v53;
              __int16 v67 = 2048;
              *(void *)unsigned int v68 = v26;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_60;
            }
            goto LABEL_54;
          }
        }
        else
        {
          unint64_t v36 = *(void *)(a6 + 16);
          if (v36 > v58)
          {
LABEL_54:

            id v14 = v56;
            goto LABEL_55;
          }
        }
        *(void *)int v69 = 0;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v74 = 0u;
        id v13 = (id)&_os_log_internal;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unsigned int v66 = 136315906;
        *(void *)&v66[4] = "operator[]";
        *(_WORD *)&v66[12] = 1024;
        *(_DWORD *)&v66[14] = 789;
        *(_WORD *)&v66[18] = 2048;
        *(void *)&v66[20] = v58;
        __int16 v67 = 2048;
        *(void *)unsigned int v68 = v36;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      else
      {
        if (!v57)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29))
          {
            uint64_t v45 = re::internal::GeomTypedAttribute<double>::operator[](v29, 0);
            int v46 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
            unint64_t v26 = *(void *)(a6 + 16);
            if (v26 <= v58) {
              goto LABEL_61;
            }
            if (v46)
            {
              unint64_t v26 = 0;
              unint64_t v47 = v60 + (v61 & 0xFFFFFFFFFFFFFFFCLL) - 8;
              uint64_t v48 = *(void *)(a6 + 32) + 80 * v58;
              uint64_t v49 = v63;
              uint64_t v50 = v60 + 4 * v62;
              while (1)
              {
                a6 = *(void *)(v48 + 16);
                if (a6 <= v26) {
                  goto LABEL_58;
                }
                unsigned int v51 = (void *)(v50 + 4 * v49 * *(unsigned int *)(*(void *)(v48 + 32) + 4 * v26));
                if ((unint64_t)v51 <= v47) {
                  *(void *)(v45 + 8 * v26) = *v51;
                }
                if (v46 == ++v26) {
                  goto LABEL_54;
                }
              }
            }
          }
          else
          {
            unint64_t v26 = *(void *)(a6 + 16);
            if (v26 <= v58) {
              goto LABEL_61;
            }
          }
          goto LABEL_54;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29))
        {
          uint64_t v43 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v29, 0);
          uint64_t v44 = (*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29);
LABEL_51:
          *(void *)int v69 = v43;
          *(void *)&v69[8] = v44;
          unint64_t v26 = *(void *)(a6 + 16);
          unint64_t v52 = v58;
          if (v26 <= v58)
          {
LABEL_60:
            uint64_t v65 = 0;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v75 = 0u;
            long long v76 = 0u;
            long long v74 = 0u;
            unint64_t v54 = v52;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int v66 = 136315906;
            *(void *)&v66[4] = "operator[]";
            *(_WORD *)&v66[12] = 1024;
            *(_DWORD *)&v66[14] = 789;
            *(_WORD *)&v66[18] = 2048;
            *(void *)&v66[20] = v54;
            __int16 v67 = 2048;
            *(void *)unsigned int v68 = v26;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_61:
            *(void *)int v69 = 0;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v75 = 0u;
            long long v76 = 0u;
            long long v74 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int v66 = 136315906;
            *(void *)&v66[4] = "operator[]";
            *(_WORD *)&v66[12] = 1024;
            *(_DWORD *)&v66[14] = 789;
            *(_WORD *)&v66[18] = 2048;
            *(void *)&v66[20] = v58;
            __int16 v67 = 2048;
            *(void *)unsigned int v68 = v26;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          goto LABEL_54;
        }
      }
      uint64_t v44 = 0;
      uint64_t v43 = 0;
      goto LABEL_51;
    }
LABEL_55:

    return;
  }
  if (!v18) {
    goto LABEL_55;
  }
  if (v18 == 786434)
  {
    int v59 = 0;
    int v20 = 0;
    uint64_t v21 = 6;
    goto LABEL_9;
  }
LABEL_62:
  re::internal::assertLog((re::internal *)4, v19, v18, "assertion failure: '%s' (%s:line %i) unsupported MDLVertexFormat", "!\"Unreachable code\"", "addAttributeIfItExistsToGeomMesh", 580);
  _os_crash();
  __break(1u);
}

uint64_t *re::DynamicArray<re::internal::anonymous namespace'::MDLAttrTopologyMap>::~DynamicArray(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (v3)
    {
      uint64_t v4 = a1[2];
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 80;
          v5 -= 80;
        }
        while (v5);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[4];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

void re::internal::attachBlendShapeDataIfItExistsToGeomMesh(re::internal *this, const MDLMesh *a2, re::GeomMesh *a3)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v4 = this;
  uint64_t v5 = [(re::internal *)v4 submeshes];
  if (v5)
  {
    unint64_t v6 = (void *)v5;
    unint64_t v7 = [(re::internal *)v4 submeshes];
    uint64_t v8 = [v7 count];

    if (v8 == 1)
    {
      uint64_t v9 = [(re::internal *)v4 componentConformingToProtocol:&unk_26E75F6C8];
      if (v9)
      {
        uint64_t v10 = [(re::internal *)v4 submeshes];
        uint64_t v11 = [v10 objectAtIndexedSubscript:0];

        uint64_t v45 = 0;
        v42[1] = 0;
        unint64_t v43 = 0;
        v42[0] = 0;
        int v44 = 0;
        unint64_t v36 = v43;
        if (v43)
        {
          unint64_t v12 = [(re::internal *)v4 vertexDescriptor];
          id v13 = [v12 attributeNamed:@"position"];
          uint64_t v14 = [v13 bufferIndex];
          id v15 = [v11 faceIndexing];

          int v35 = v12;
          if (v15)
          {
            uint64_t v16 = [v11 faceIndexing];
            unint64_t v17 = [v16 objectAtIndexedSubscript:v14];
            unsigned int v18 = [v17 unsignedIntValue];

            unint64_t v19 = v18;
          }
          else
          {
            unint64_t v19 = 0;
          }
          int v20 = [v9 targetShapes];
          uint64_t v21 = [v20 count];

          if (v21)
          {
            unint64_t v22 = 0;
            do
            {
              unint64_t v23 = [v9 targetShapes];
              unsigned int v24 = [v23 objectAtIndexedSubscript:v22];

              {
                id v25 = [v24 name];
                uint64_t v26 = [v25 UTF8String];

                uint64_t v27 = "";
                if (v26) {
                  uint64_t v27 = (const char *)v26;
                }
                re::DynamicString::format((re::DynamicString *)"%s|blendTargetPosDeltas", (re::DynamicString *)&v38, v27);
                if (v39) {
                  uint64_t v28 = *(char **)&v40[7];
                }
                else {
                  uint64_t v28 = v40;
                }
                uint64_t v29 = re::GeomMesh::addAttribute((uint64_t)a2, v28, 1, 7);
                if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v29 + 16))(v29))
                {
                  uint64_t v31 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v29, 0);
                  uint64_t v32 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)v29 + 16))(v29);
                }
                else
                {
                  uint64_t v32 = 0;
                  uint64_t v31 = 0;
                }
                v37[0] = v31;
                v37[1] = v32;
                if (v36 <= v19)
                {
                  uint64_t v46 = 0;
                  long long v58 = 0u;
                  long long v59 = 0u;
                  long long v56 = 0u;
                  long long v57 = 0u;
                  long long v55 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v47 = 136315906;
                  uint64_t v48 = "operator[]";
                  __int16 v49 = 1024;
                  int v50 = 789;
                  __int16 v51 = 2048;
                  unint64_t v52 = v19;
                  __int16 v53 = 2048;
                  unint64_t v54 = v36;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
                if (v38 && (v39 & 1) != 0) {
                  (*(void (**)(void))(*(void *)v38 + 40))();
                }
              }

              ++v22;
              uint64_t v33 = [v9 targetShapes];
              unint64_t v34 = [v33 count];
            }
            while (v34 > v22);
          }
        }
      }
    }
  }
}

void re::internal::attachNewBlendShapeDataIfItExistsToGeomMesh(re::internal *this, MDLMesh *a2, const MDLObject *a3, uint64_t a4, re::GeomMesh *a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  unint64_t v7 = this;
  uint64_t v8 = a2;
  uint64_t v9 = [(re::internal *)v7 submeshes];
  unint64_t v43 = a3;
  uint64_t v10 = [v9 objectAtIndexedSubscript:a3];

  int v44 = v8;
  uint64_t v11 = [(MDLMesh *)v8 children];
  uint64_t v12 = [v11 count];

  memset(v45, 0, sizeof(v45));
  int v46 = 0;
  uint64_t v50 = 0;
  long long v47 = 0u;
  long long v48 = 0u;
  int v49 = 0;
  id v13 = v7;
  id v14 = v10;
  uint64_t v53 = 0;
  *(void *)&long long v52 = 0;
  long long v51 = 0uLL;
  DWORD2(v52) = 0;
  unint64_t v15 = v52;
  if ((void)v52)
  {
    uint64_t v16 = [(re::internal *)v13 vertexDescriptor];
    unint64_t v17 = [v16 attributeNamed:@"position"];
    uint64_t v18 = [v17 bufferIndex];
    unint64_t v19 = [v14 faceIndexing];

    if (v19)
    {
      id v20 = v14;
      uint64_t v21 = [v14 faceIndexing];
      unint64_t v22 = [v21 objectAtIndexedSubscript:v18];
      unsigned int v23 = [v22 unsignedIntValue];

      unsigned int v24 = v23;
      if (v15 <= v23)
      {
        uint64_t v54 = 0;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v56 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v55 = 136315906;
        *(void *)&v55[4] = "operator[]";
        *(_WORD *)&v55[12] = 1024;
        *(_DWORD *)&v55[14] = 789;
        *(_WORD *)&v55[18] = 2048;
        *(void *)&v55[20] = v23;
        *(_WORD *)&v55[28] = 2048;
        *(void *)&v55[30] = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      id v14 = v20;
    }
    else
    {
      unsigned int v24 = 0;
    }
    uint64_t v25 = v53 + 80 * v24;
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)v45, v25);
    re::DynamicArray<re::GeomCell4>::operator=((uint64_t)&v47 + 8, v25 + 40);
  }
  uint64_t v40 = v14;

  uint64_t v41 = v13;
  if (v12)
  {
    uint64_t v26 = 0;
    uint64_t v27 = (void *)*MEMORY[0x263F135C8];
    do
    {
      uint64_t v28 = [(MDLMesh *)v44 children];
      uint64_t v29 = [v28 objectAtIndexedSubscript:v26];

      __n128 v30 = [v29 submeshes];
      uint64_t v31 = [v30 objectAtIndexedSubscript:v43];

      *(void *)&long long v58 = 0;
      *(void *)&long long v57 = 0;
      long long v56 = 0uLL;
      DWORD2(v57) = 0;
      if ((void)v57)
      {
        uint64_t v32 = [v29 vertexDescriptor];
        uint64_t v33 = [v32 attributeNamed:@"offsets"];
        [v33 bufferIndex];
        unint64_t v34 = [v31 faceIndexing];

        if (v34)
        {
          int v35 = [v31 faceIndexing];
          unint64_t v36 = [v35 objectAtIndexedSubscript:0];
          [v36 unsignedIntValue];
        }
        id v37 = [v29 name];
        uint64_t v38 = (_anonymous_namespace_ *)[v37 UTF8String];
        re::DynamicString::operator+((re::DynamicString *)v55, "|blendTargetPosDeltas", (re::DynamicString *)&v51);
        if (BYTE8(v51)) {
          char v39 = (char *)v52;
        }
        else {
          char v39 = (char *)&v51 + 9;
        }
        if ((void)v51)
        {
          if (BYTE8(v51)) {
            (*(void (**)(void))(*(void *)v51 + 40))();
          }
          long long v51 = 0u;
          long long v52 = 0u;
        }
        if (*(void *)v55)
        {
          if (v55[8]) {
            (*(void (**)(void))(**(void **)v55 + 40))();
          }
          memset(v55, 0, 32);
        }
      }

      ++v26;
    }
    while (v12 != v26);
  }
  if (*((void *)&v47 + 1))
  {
    if (v50) {
      (*(void (**)(void))(**((void **)&v47 + 1) + 40))();
    }
    uint64_t v50 = 0;
    long long v48 = 0uLL;
    *((void *)&v47 + 1) = 0;
    ++v49;
  }
  if (v45[0] && (void)v47) {
    (*(void (**)(void))(*(void *)v45[0] + 40))();
  }
}

void re::internal::attachSkinningDataToMesh(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = &v60;
  uint64_t v65 = *MEMORY[0x263EF8340];
  id v10 = a1;
  unint64_t v11 = a2;
  uint64_t v12 = re::GeomMesh::addAttribute(a6, "skeletonPath", 0, 1);
  *(_WORD *)re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v12, 0) = 0;
  id v13 = re::GeomMesh::addAttribute(a6, "skinnedAnimationGeometryBindTransform", 4, 8);
  (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v13 + 24))(v13, 4);
  if (!(*(unsigned int (**)(re::GeomAttribute *))(*(void *)v13 + 16))(v13)
    || (id v14 = (_OWORD *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v13, 0),
        (unsigned int v15 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v13 + 16))(v13)) == 0))
  {
LABEL_65:
    *(void *)uint64_t v53 = 0;
    v9[3] = 0u;
    v9[4] = 0u;
    v9[2] = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v50 = 136315906;
    *(void *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 609;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = 0;
    __int16 v51 = 2048;
    *(void *)long long v52 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  _OWORD *v14 = *(_OWORD *)a5;
  if (v15 == 1) {
    goto LABEL_61;
  }
  v14[1] = *(_OWORD *)(a5 + 16);
  if (v15 <= 2)
  {
LABEL_62:
    *(void *)uint64_t v53 = 0;
    v9[3] = 0u;
    v9[4] = 0u;
    v9[2] = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v9 = (long long *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v50 = 136315906;
    *(void *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 609;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = 2;
    __int16 v51 = 2048;
    *(void *)long long v52 = 2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_63;
  }
  void v14[2] = *(_OWORD *)(a5 + 32);
  if (v15 == 3)
  {
LABEL_63:
    *(void *)uint64_t v53 = 0;
    v9[3] = 0u;
    v9[4] = 0u;
    v9[2] = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v9 = (long long *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v50 = 136315906;
    *(void *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 609;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = 3;
    __int16 v51 = 2048;
    *(void *)long long v52 = 3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_64;
  }
  v14[3] = *(_OWORD *)(a5 + 48);
  uint64_t v16 = *(unsigned int *)(a6 + 16);
  *(void *)&v52[2] = 0;
  memset(v50, 0, sizeof(v50));
  if (!*(void *)&v50[16])
  {
LABEL_64:
    re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) ", "topologies.size() > 0", "attachSkinningDataToMesh", 971);
    _os_crash();
    __break(1u);
    goto LABEL_65;
  }
  long long v48 = (void *)v11;
  int v49 = v10;
  uint64_t v18 = re::GeomMesh::addAttribute(a6, "skinnedAnimationWeights", 4, 4);
  unint64_t v19 = re::GeomMesh::addAttribute(a6, "skinnedAnimationJointIndices", 4, 2);
  id v20 = re::GeomMesh::addAttribute(a6, "skinnedAnimationInfluenceEndIndices", 4, 2);
  (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v20 + 24))(v20, v16);
  uint64_t v21 = *(void *)&v52[2];
  if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v20 + 16))(v20))
  {
    unint64_t v22 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v20, 0);
    unint64_t v23 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)v20 + 16))(v20);
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v22 = 0;
  }
  unsigned int v24 = v19;
  if (v16)
  {
    uint64_t v25 = 0;
    LODWORD(v26) = 0;
    unint64_t v27 = *(void *)(v21 + 16);
    while (v27 != v25)
    {
      unint64_t v11 = *(unsigned int *)(*(void *)(v21 + 32) + 4 * v25);
      if (v11)
      {
        id v14 = *(_OWORD **)(a5 + 160);
        if ((unint64_t)v14 <= v11) {
          goto LABEL_57;
        }
        int v28 = *(_DWORD *)(*(void *)(a5 + 168) + 4 * v11)
            - *(_DWORD *)(*(void *)(a5 + 168) + 4 * (v11 - 1));
      }
      else
      {
        if (!*(void *)(a5 + 160)) {
          goto LABEL_60;
        }
        int v28 = **(_DWORD **)(a5 + 168);
      }
      if (v23 == v25) {
        goto LABEL_56;
      }
      uint64_t v26 = (v28 + v26);
      *(_DWORD *)(v22 + 4 * v25++) = v26;
      if (v16 == v25) {
        goto LABEL_22;
      }
    }
    goto LABEL_55;
  }
  uint64_t v26 = 0;
LABEL_22:
  uint64_t v29 = (uint64_t)v24;
  (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v24 + 24))(v24, v26);
  (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v18 + 24))(v18, v26);
  if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v18 + 16))(v18))
  {
    unint64_t v22 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v18, 0);
    unint64_t v11 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v18 + 16))(v18);
  }
  else
  {
    unint64_t v11 = 0;
    unint64_t v22 = 0;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29))
  {
    uint64_t v30 = re::internal::GeomTypedAttribute<float>::operator[](v29, 0);
    uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
    uint64_t v32 = v30;
    id v14 = (_OWORD *)v31;
  }
  else
  {
    id v14 = 0;
    uint64_t v32 = 0;
  }
  unint64_t v33 = v22;
  if (v16)
  {
    unsigned int v34 = v11;
    uint64_t v35 = 0;
    unsigned int v36 = 0;
    unint64_t v23 = *(void *)(v21 + 16);
    while (1)
    {
      if (v35 == v23) {
        goto LABEL_58;
      }
      unint64_t v11 = *(unsigned int *)(*(void *)(v21 + 32) + 4 * v35);
      unint64_t v22 = *(void *)(a5 + 160);
      if (v22 <= v11) {
        goto LABEL_59;
      }
      uint64_t v37 = *(void *)(a5 + 168);
      int v38 = v11 ? *(_DWORD *)(v37 + 4 * (v11 - 1)) : 0;
      int v39 = *(_DWORD *)(v37 + 4 * v11);
      int v40 = v39 - v38;
      if (v39 != v38) {
        break;
      }
LABEL_49:
      if (++v35 == v16) {
        goto LABEL_50;
      }
    }
    uint64_t v41 = 0;
    unint64_t v42 = *(void *)(a5 + 112);
    uint64_t v43 = v36;
    if (v36 <= v34) {
      unint64_t v22 = v34;
    }
    else {
      unint64_t v22 = v36;
    }
    uint64_t v44 = v32 + 4 * v36;
    if (v36 <= v14) {
      unint64_t v45 = v14;
    }
    else {
      unint64_t v45 = v36;
    }
    unint64_t v46 = v33 + 4 * v36;
    while (1)
    {
      unint64_t v11 = (v38 + v41);
      if (v42 <= v11) {
        break;
      }
      if (!(v43 - v22 + v41)) {
        goto LABEL_52;
      }
      *(_DWORD *)(v46 + 4 * v41) = *(_DWORD *)(*(void *)(a5 + 120) + 4 * v11);
      uint64_t v18 = *(re::GeomAttribute **)(a5 + 136);
      if ((unint64_t)v18 <= v11) {
        goto LABEL_53;
      }
      if (!(v43 - v45 + v41)) {
        goto LABEL_54;
      }
      *(_DWORD *)(v44 + 4 * v41++) = *(_DWORD *)(*(void *)(a5 + 144) + 4 * v11);
      if (v40 == v41)
      {
        unsigned int v36 = v43 + v41;
        goto LABEL_49;
      }
    }
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 476;
    __int16 v56 = 2048;
    unint64_t v57 = v11;
    __int16 v58 = 2048;
    unint64_t v59 = v42;
    _os_log_send_and_compose_impl();
    unsigned int v34 = _os_crash_msg();
    __break(1u);
LABEL_52:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    unsigned int v47 = v34;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 609;
    __int16 v56 = 2048;
    unint64_t v57 = v22;
    __int16 v58 = 2048;
    unint64_t v59 = v47;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 476;
    __int16 v56 = 2048;
    unint64_t v57 = v11;
    __int16 v58 = 2048;
    unint64_t v59 = (unint64_t)v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    unint64_t v27 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 609;
    __int16 v56 = 2048;
    unint64_t v57 = v45;
    __int16 v58 = 2048;
    unint64_t v59 = v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 789;
    __int16 v56 = 2048;
    unint64_t v57 = v27;
    __int16 v58 = 2048;
    unint64_t v59 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 609;
    __int16 v56 = 2048;
    unint64_t v57 = v23;
    __int16 v58 = 2048;
    unint64_t v59 = v23;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 476;
    __int16 v56 = 2048;
    unint64_t v57 = v11;
    __int16 v58 = 2048;
    unint64_t v59 = (unint64_t)v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 789;
    __int16 v56 = 2048;
    unint64_t v57 = v23;
    __int16 v58 = 2048;
    unint64_t v59 = v23;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 476;
    __int16 v56 = 2048;
    unint64_t v57 = v11;
    __int16 v58 = 2048;
    unint64_t v59 = v22;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_60:
    long long v63 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v9 = (long long *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v53 = 136315906;
    *(void *)&v53[4] = "operator[]";
    __int16 v54 = 1024;
    int v55 = 476;
    __int16 v56 = 2048;
    unint64_t v57 = 0;
    __int16 v58 = 2048;
    unint64_t v59 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_61:
    *(void *)uint64_t v53 = 0;
    v9[3] = 0u;
    v9[4] = 0u;
    v9[2] = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v9 = (long long *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v50 = 136315906;
    *(void *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 609;
    *(_WORD *)&v50[18] = 2048;
    *(void *)&v50[20] = 1;
    __int16 v51 = 2048;
    *(void *)long long v52 = 1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_50:
}

void re::internal::attachOpenSubdivDataToMesh(re::internal *this, MDLMesh *a2, MDLSubmesh *a3, re::GeomMesh *a4)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  unint64_t v6 = this;
  unint64_t v7 = a2;
  if ([(re::internal *)v6 subdivisionScheme] == 1)
  {
    uint64_t v64 = 0;
    v61[1] = 0;
    unint64_t v62 = 0;
    v61[0] = 0;
    int v63 = 0;
    unint64_t v8 = v62;
    if (v62)
    {
      uint64_t v9 = [(re::internal *)v6 vertexDescriptor];
      id v10 = [v9 attributeNamed:@"position"];
      unint64_t v11 = [v10 bufferIndex];
      if (v8 <= v11) {
        goto LABEL_57;
      }
      uint64_t v12 = v64;
      uint64_t v13 = [(id)v7 topology];
      id v14 = re::GeomMesh::addAttribute((uint64_t)a3, "osdSubdivisionScheme", 0, 1);
      if (v14) {
        *(_WORD *)re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v14, 0) = 1;
      }
      if (v13)
      {
        unint64_t v15 = [(id)v13 edgeCreaseCount];
        uint64_t v16 = [(id)v13 vertexCreaseCount];
        *(void *)&v68[2] = 0;
        memset(v66, 0, sizeof(v66));
        unint64_t v59 = v15;
        if (v16 | v15)
        {
          re::DynamicArray<unsigned int>::resize(v66, [(re::internal *)v6 vertexCount], &re::kInvalidMeshIndex);
          uint64_t isa_low = LODWORD(a3[2].super.isa);
          if (isa_low)
          {
            uint64_t v18 = 0;
            uint64_t v19 = v12 + 80 * v11;
            unint64_t v11 = *(void *)(v19 + 16);
            unint64_t v8 = *(void *)&v66[16];
            uint64_t v20 = *(void *)&v68[2];
            while (v11 != v18)
            {
              unint64_t v15 = *(unsigned int *)(*(void *)(v19 + 32) + 4 * v18);
              if (v8 <= v15) {
                goto LABEL_48;
              }
              *(_DWORD *)(v20 + 4 * v15) = v18++;
              if (isa_low == v18) {
                goto LABEL_13;
              }
            }
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 797;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v11;
            __int16 v74 = 2048;
            unint64_t v75 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_48:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 789;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v15;
            __int16 v74 = 2048;
            unint64_t v75 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_49:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 789;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v15;
            __int16 v74 = 2048;
            unint64_t v75 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_50:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 609;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v7;
            __int16 v74 = 2048;
            unint64_t v75 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_51:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            uint64_t v32 = (re::internal *)&_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 789;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v15;
            __int16 v74 = 2048;
            unint64_t v75 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_52:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            unint64_t v15 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 609;
            __int16 v72 = 2048;
            uint64_t v73 = v32;
            __int16 v74 = 2048;
            unint64_t v75 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_53:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 609;
            __int16 v72 = 2048;
            uint64_t v73 = v6;
            __int16 v74 = 2048;
            unint64_t v75 = (unint64_t)v6;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_54:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 789;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v15;
            __int16 v74 = 2048;
            unint64_t v75 = (unint64_t)v6;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_55:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 609;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v13;
            __int16 v74 = 2048;
            unint64_t v75 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_56:
            uint64_t v65 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v69 = 136315906;
            *(void *)&v69[4] = "operator[]";
            __int16 v70 = 1024;
            int v71 = 609;
            __int16 v72 = 2048;
            uint64_t v73 = (re::internal *)v8;
            __int16 v74 = 2048;
            unint64_t v75 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_57:
            *(void *)int v69 = 0;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v76 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int v66 = 136315906;
            *(void *)&v66[4] = "operator[]";
            *(_WORD *)&v66[12] = 1024;
            *(_DWORD *)&v66[14] = 789;
            *(_WORD *)&v66[18] = 2048;
            *(void *)&v66[20] = v11;
            __int16 v67 = 2048;
            *(void *)unsigned int v68 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_13:
          unint64_t v57 = v10;
          __int16 v58 = v9;
          uint64_t v56 = v13;
          if (v59)
          {
            uint64_t v52 = v16;
            uint64_t v21 = [(id)v13 edgeCreases];
            unint64_t v22 = [(id)v13 edgeCreaseIndices];
            uint64_t v50 = v21;
            unint64_t v23 = [v21 map];
            uint64_t v24 = [v23 bytes];

            int v49 = v22;
            uint64_t v25 = [v22 map];
            uint64_t v26 = a3;
            uint64_t v27 = [v25 bytes];

            id v10 = re::GeomMesh::addAttribute((uint64_t)v26, "osdEdgeCreaseIndices", 4, 3);
            __int16 v51 = v26;
            int v28 = re::GeomMesh::addAttribute((uint64_t)v26, "osdEdgeCreaseWeights", 4, 4);
            (*(void (**)(void *, void))(*(void *)v10 + 24))(v10, (2 * v59));
            (*(void (**)(re::GeomAttribute *, unint64_t))(*(void *)v28 + 24))(v28, v59);
            if ((*(unsigned int (**)(void *))(*(void *)v10 + 16))(v10))
            {
              unint64_t v11 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v10, 0);
              LODWORD(v10) = (*(uint64_t (**)(void *))(*(void *)v10 + 16))(v10);
            }
            else
            {
              LODWORD(v10) = 0;
              unint64_t v11 = 0;
            }
            __int16 v54 = v6;
            uint64_t v53 = (MDLMesh *)v7;
            if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v28 + 16))(v28))
            {
              uint64_t v13 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v28, 0);
              unint64_t v6 = (re::internal *)(*(unsigned int (**)(re::GeomAttribute *))(*(void *)v28 + 16))(v28);
            }
            else
            {
              unint64_t v6 = 0;
              uint64_t v13 = 0;
            }
            uint64_t v29 = 0;
            unint64_t v8 = *(void *)&v66[16];
            uint64_t v30 = *(void *)&v68[2];
            unsigned int v31 = 1;
            do
            {
              unint64_t v7 = v31 - 1;
              unint64_t v15 = *(unsigned int *)(v27 + 4 * v7);
              if (v8 <= v15) {
                goto LABEL_49;
              }
              if (v10 <= v7) {
                goto LABEL_50;
              }
              *(_DWORD *)(v11 + 4 * v7) = *(_DWORD *)(v30 + 4 * v15);
              unint64_t v15 = *(unsigned int *)(v27 + 4 * v31);
              if (v8 <= v15) {
                goto LABEL_51;
              }
              uint64_t v32 = (re::internal *)v31;
              if (v10 <= v31) {
                goto LABEL_52;
              }
              *(_DWORD *)(v11 + 4 * v31) = *(_DWORD *)(v30 + 4 * v15);
              if (v6 == v29) {
                goto LABEL_53;
              }
              v31 += 2;
              *(_DWORD *)(v13 + 4 * (void)v29) = *(_DWORD *)(v24 + 4 * (void)v29);
              uint64_t v29 = (re::internal *)((char *)v29 + 1);
            }
            while ((re::internal *)v59 != v29);

            unint64_t v7 = (unint64_t)v53;
            unint64_t v6 = v54;
            id v10 = v57;
            uint64_t v9 = v58;
            uint64_t v13 = v56;
            a3 = v51;
            uint64_t v16 = v52;
          }
          if (v16)
          {
            unint64_t v33 = [(id)v13 vertexCreases];
            unsigned int v34 = [(id)v13 vertexCreaseIndices];
            long long v60 = v33;
            uint64_t v35 = [v33 map];
            uint64_t v36 = [v35 bytes];

            int v55 = v34;
            uint64_t v37 = [v34 map];
            int v38 = a3;
            uint64_t v39 = [v37 bytes];

            int v40 = re::GeomMesh::addAttribute((uint64_t)v38, "osdVertexCreaseIndices", 4, 3);
            uint64_t v41 = re::GeomMesh::addAttribute((uint64_t)v38, "osdVertexCreaseWeights", 4, 4);
            (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v40 + 24))(v40, v16);
            unsigned int v42 = v16;
            (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v41 + 24))(v41, v16);
            if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v40 + 16))(v40))
            {
              unint64_t v11 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v40, 0);
              uint64_t v13 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)v40 + 16))(v40);
            }
            else
            {
              uint64_t v13 = 0;
              unint64_t v11 = 0;
            }
            uint64_t v43 = (MDLMesh *)v7;
            uint64_t v44 = v6;
            if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v41 + 16))(v41))
            {
              uint64_t v45 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v41, 0);
              unint64_t v8 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)v41 + 16))(v41);
            }
            else
            {
              unint64_t v8 = 0;
              uint64_t v45 = 0;
            }
            uint64_t v46 = 0;
            unint64_t v6 = *(re::internal **)&v66[16];
            uint64_t v47 = *(void *)&v68[2];
            uint64_t v48 = v42;
            do
            {
              unint64_t v15 = *(unsigned int *)(v39 + 4 * v46);
              if ((unint64_t)v6 <= v15) {
                goto LABEL_54;
              }
              if (v13 == v46) {
                goto LABEL_55;
              }
              *(_DWORD *)(v11 + 4 * v46) = *(_DWORD *)(v47 + 4 * v15);
              if (v8 == v46) {
                goto LABEL_56;
              }
              *(_DWORD *)(v45 + 4 * v46) = *(_DWORD *)(v36 + 4 * v46);
              ++v46;
            }
            while (v48 != v46);

            unint64_t v6 = v44;
            unint64_t v7 = (unint64_t)v43;
            id v10 = v57;
            uint64_t v9 = v58;
            uint64_t v13 = v56;
          }
          if (*(void *)v66 && *(void *)&v68[2]) {
            (*(void (**)(void))(**(void **)v66 + 40))();
          }
        }
      }
    }
  }
}

void *re::DynamicArray<re::internal::anonymous namespace'::MDLAttrTopologyMap>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 80 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[4] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (void *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 80;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 80 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 72) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        v6 += 80;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

unint64_t *re::internal::anonymous namespace'::buildMappingsForMDLSubmeshToGeomVertexHelper(unint64_t *result, uint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (a4)
  {
    unint64_t v7 = a3;
    unint64_t v8 = a2;
    unint64_t v9 = result;
    unsigned int v10 = 0;
    unint64_t v12 = result[1];
    unint64_t v11 = result[2];
    unint64_t v13 = a4;
    unsigned int v14 = -1;
    unsigned int v15 = a3;
    uint64_t v16 = a4;
    do
    {
      if (*result <= v15)
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
        _os_crash();
        __break(1u);
LABEL_50:
        re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) ", "index < m_max_index", "operator[]", 79);
        _os_crash();
        __break(1u);
LABEL_51:
        uint64_t v45 = 0;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v46 = 136315906;
        uint64_t v47 = "operator[]";
        __int16 v48 = 1024;
        int v49 = 789;
        __int16 v50 = 2048;
        unint64_t v51 = v7;
        __int16 v52 = 2048;
        uint64_t v53 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      switch(v11)
      {
        case 0x20uLL:
          unsigned int v17 = *(_DWORD *)(v12 + 4 * v15);
          break;
        case 0x10uLL:
          unsigned int v17 = *(unsigned __int16 *)(v12 + 2 * v15);
          break;
        case 8uLL:
          unsigned int v17 = *(unsigned __int8 *)(v12 + v15);
          break;
        default:
          goto LABEL_54;
      }
      if (v17 < v14) {
        unsigned int v14 = v17;
      }
      if (v17 > v10) {
        unsigned int v10 = v17;
      }
      v15 += a2;
      --v16;
    }
    while (v16);
    uint64_t v44 = 0;
    unint64_t v18 = v10 - v14 + 1;
    v41[1] = 0;
    unsigned int v42 = 0;
    v41[0] = 0;
    int v43 = 0;
    LOBYTE(v54) = 0;
    re::DynamicArray<BOOL>::resize(v41, v18, &v54);
    unsigned int v20 = 0;
    unint64_t v22 = v9[1];
    unint64_t v21 = v9[2];
    unint64_t v23 = *v9;
    unint64_t v9 = v42;
    uint64_t v24 = v44;
    do
    {
      if (v23 <= v7) {
        goto LABEL_50;
      }
      int v25 = v7;
      switch(v21)
      {
        case 0x20uLL:
          int v26 = *(_DWORD *)(v22 + 4 * v7);
          break;
        case 0x10uLL:
          int v26 = *(unsigned __int16 *)(v22 + 2 * v7);
          break;
        case 8uLL:
          int v26 = *(unsigned __int8 *)(v22 + v7);
          break;
        default:
          goto LABEL_55;
      }
      unint64_t v7 = v26 - v14;
      if ((unint64_t)v9 <= v7) {
        goto LABEL_51;
      }
      if (!*(unsigned char *)(v24 + v7))
      {
        *(unsigned char *)(v24 + v7) = 1;
        ++v20;
      }
      unint64_t v7 = (v25 + v8);
      --v13;
    }
    while (v13);
    re::DynamicArray<float>::resize(a6, v20);
    if (v18)
    {
      unsigned int v27 = 0;
      unint64_t v8 = 0;
      while (1)
      {
        unint64_t v9 = v42;
        if ((unint64_t)v42 <= v8) {
          break;
        }
        if (*(unsigned char *)(v44 + v8))
        {
          unint64_t v28 = v14 + v8;
          unint64_t v29 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v28 ^ (v28 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v28 ^ (v28 >> 30))) >> 27));
          unint64_t v30 = v29 ^ (v29 >> 31);
          unint64_t v31 = *(void *)a5;
          if (!*(void *)a5
            || (unint64_t v31 = v30 % *(unsigned int *)(a5 + 24),
                uint64_t v32 = *(unsigned int *)(*(void *)(a5 + 8) + 4 * v31),
                v32 == 0x7FFFFFFF))
          {
LABEL_36:
            uint64_t v34 = *(unsigned int *)(a5 + 36);
            if (v34 == 0x7FFFFFFF)
            {
              uint64_t v34 = *(unsigned int *)(a5 + 32);
              int v35 = v34;
              if (v34 == *(_DWORD *)(a5 + 24))
              {
                re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a5, 2 * *(_DWORD *)(a5 + 28));
                unint64_t v31 = v30 % *(unsigned int *)(a5 + 24);
                int v35 = *(_DWORD *)(a5 + 32);
              }
              *(_DWORD *)(a5 + 32) = v35 + 1;
              uint64_t v36 = *(void *)(a5 + 16);
              int v37 = *(_DWORD *)(v36 + 24 * v34 + 8);
            }
            else
            {
              uint64_t v36 = *(void *)(a5 + 16);
              int v37 = *(_DWORD *)(v36 + 24 * v34 + 8);
              *(_DWORD *)(a5 + 36) = v37 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v36 + 24 * v34 + 8) = v37 | 0x80000000;
            uint64_t v38 = *(void *)(a5 + 8);
            *(_DWORD *)(*(void *)(a5 + 16) + 24 * v34 + 8) = *(_DWORD *)(*(void *)(a5 + 16) + 24 * v34 + 8) & 0x80000000 | *(_DWORD *)(v38 + 4 * v31);
            *(void *)(*(void *)(a5 + 16) + 24 * v34) = v30;
            *(_DWORD *)(*(void *)(a5 + 16) + 24 * v34 + 12) = v28;
            *(_DWORD *)(*(void *)(a5 + 16) + 24 * v34 + 16) = v27;
            *(_DWORD *)(v38 + 4 * v31) = v34;
            ++*(_DWORD *)(a5 + 28);
            ++*(_DWORD *)(a5 + 40);
          }
          else
          {
            uint64_t v33 = *(void *)(a5 + 16);
            while (*(_DWORD *)(v33 + 24 * v32 + 12) != v28)
            {
              LODWORD(v32) = *(_DWORD *)(v33 + 24 * v32 + 8) & 0x7FFFFFFF;
              if (v32 == 0x7FFFFFFF) {
                goto LABEL_36;
              }
            }
          }
          unint64_t v13 = v27;
          unint64_t v39 = *(void *)(a6 + 16);
          if (v39 <= v27) {
            goto LABEL_53;
          }
          *(_DWORD *)(*(void *)(a6 + 32) + 4 * v27++) = v28;
        }
        if (++v8 == v18) {
          goto LABEL_45;
        }
      }
LABEL_52:
      uint64_t v45 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      unint64_t v39 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v46 = 136315906;
      uint64_t v47 = "operator[]";
      __int16 v48 = 1024;
      int v49 = 789;
      __int16 v50 = 2048;
      unint64_t v51 = v8;
      __int16 v52 = 2048;
      uint64_t v53 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      uint64_t v45 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v46 = 136315906;
      uint64_t v47 = "operator[]";
      __int16 v48 = 1024;
      int v49 = 789;
      __int16 v50 = 2048;
      unint64_t v51 = v13;
      __int16 v52 = 2048;
      uint64_t v53 = (unint64_t *)v39;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
      _os_crash();
      __break(1u);
LABEL_55:
      re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) Unsupported or invalid MDLIndexBitDepth detected.", "!\"Unreachable code\"", "operator[]", 93);
      _os_crash();
      __break(1u);
    }
LABEL_45:
    uint64_t result = (unint64_t *)v41[0];
    if (v41[0])
    {
      if (v44) {
        return (unint64_t *)(*(uint64_t (**)(void))(*(void *)v41[0] + 40))();
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::anonymous namespace'::MDLAttrTopologyMap>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 != a2)
  {
    unint64_t v4 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v4)
      {
        ++*((_DWORD *)v4 + 6);
        return result;
      }
      if (a2)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
        if (!result)
        {
          re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 80 * a2, *(void *)(*v4 + 8));
          uint64_t result = (void *)_os_crash();
          __break(1u);
          return result;
        }
        uint64_t v6 = result;
        if (!v4[1]) {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v6 = 0;
        if (!v2)
        {
LABEL_15:
          v4[4] = v6;
          v4[1] = a2;
          return result;
        }
      }
      uint64_t v7 = v4[4];
      uint64_t v8 = v4[2];
      if (v8)
      {
        unint64_t v9 = 0;
        uint64_t v10 = v7 + 80 * v8;
        do
        {
          uint64_t v11 = v7 + v9;
          unint64_t v12 = &v6[v9 / 8];
          v12[4] = 0;
          v12[1] = 0;
          v12[2] = 0;
          void *v12 = 0;
          *((_DWORD *)v12 + 6) = 0;
          uint64_t v13 = *(void *)(v7 + v9 + 8);
          void *v12 = *(void *)(v7 + v9);
          v12[1] = v13;
          *(void *)uint64_t v11 = 0;
          *(void *)(v11 + 8) = 0;
          uint64_t v14 = v6[v9 / 8 + 2];
          v12[2] = *(void *)(v7 + v9 + 16);
          *(void *)(v11 + 16) = v14;
          uint64_t v15 = v6[v9 / 8 + 4];
          v12[4] = *(void *)(v7 + v9 + 32);
          *(void *)(v11 + 32) = v15;
          *(_DWORD *)(v11 + 24) = *(_DWORD *)(v7 + v9 + 24) + 1;
          *((_DWORD *)v12 + 6) = LODWORD(v6[v9 / 8 + 3]) + 1;
          v12[9] = 0;
          v12[6] = 0;
          v12[7] = 0;
          v12[5] = 0;
          *((_DWORD *)v12 + 16) = 0;
          uint64_t v16 = (void *)(v7 + v9 + 40);
          uint64_t v17 = *(void *)(v7 + v9 + 48);
          v12[5] = *v16;
          *uint64_t v16 = 0;
          v12[6] = v17;
          *(void *)(v11 + 48) = 0;
          uint64_t v18 = v6[v9 / 8 + 7];
          v12[7] = *(void *)(v7 + v9 + 56);
          *(void *)(v11 + 56) = v18;
          uint64_t v19 = v6[v9 / 8 + 9];
          v12[9] = *(void *)(v7 + v9 + 72);
          *(void *)(v11 + 72) = v19;
          *(_DWORD *)(v11 + 64) = *(_DWORD *)(v7 + v9 + 64) + 1;
          *((_DWORD *)v12 + 16) = LODWORD(v6[v9 / 8 + 8]) + 1;
          re::DynamicArray<unsigned long>::deinit((uint64_t)v16);
          re::DynamicArray<unsigned long>::deinit(v7 + v9);
          v9 += 80;
        }
        while (v11 + 80 != v10);
        uint64_t v7 = v4[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 40))(*v4, v7);
      goto LABEL_15;
    }
  }
  return result;
}

void re::makeGeomMeshFromModelDescriptor(re *this@<X0>, unint64_t a2@<X8>)
{
  unint64_t v6 = (unint64_t)this;
  uint64_t v611 = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v544 = v8;
  if (v8) {
    id v9 = (id)(v8 + 8);
  }
  re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)&v544, &v558);
  if ((void)v544) {

  }
  if (*(void *)(v6 + 24) != v560)
  {
    long long v24 = v544;
    uint64_t v25 = v545;
    uint64_t v26 = v546;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v24;
    *(void *)(a2 + 40) = v25;
    *(void *)(a2 + 48) = v26;
    goto LABEL_998;
  }
  unint64_t v11 = (unint64_t)&v544;
  re::GeomMesh::GeomMesh((re::GeomMesh *)&v544, 0);
  long long v548 = xmmword_2343AC120;
  int v549 = -1;
  char v550 = 0;
  LODWORD(v551) = 0;
  long long v556 = 0u;
  memset(v557, 0, sizeof(v557));
  unint64_t v13 = *(void *)(v6 + 16);
  uint64_t v12 = *(void *)(v6 + 24);
  uint64_t v14 = *(char **)(v6 + 40);
  v573[0] = v14;
  if (v14) {
    uint64_t v15 = v14 + 8;
  }
  re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v605);
  if (v573[0]) {

  }
  unint64_t v18 = v560;
  if (v560 != v12) {
    goto LABEL_1197;
  }
  if (v560)
  {
    LODWORD(v4) = 0;
    int v19 = 0;
    LODWORD(v5) = 0;
    unsigned int v20 = v558;
    unint64_t v21 = v560;
    while (1)
    {
      unsigned int v22 = *v20;
      if (*v20 < 5)
      {
        if (v22 <= 2)
        {
          unint64_t v29 = "Model contains degenerate face (face < 2 vertices).";
          goto LABEL_34;
        }
        int v23 = 1;
      }
      else
      {
        int v23 = v22 - 2;
      }
      unsigned int v20 = (unsigned int *)((char *)v20 + v559);
      unint64_t v4 = (v23 + v4);
      if (v22 <= v5) {
        unint64_t v5 = v5;
      }
      else {
        unint64_t v5 = v22;
      }
      v19 += v22;
      if (!--v21) {
        goto LABEL_24;
      }
    }
  }
  unint64_t v5 = 0;
  int v19 = 0;
  unint64_t v4 = 0;
LABEL_24:
  if (*(void *)&v605[1] != v19)
  {
    unint64_t v29 = "Model contains a corrupt index list.";
    goto LABEL_34;
  }
  uint64_t v27 = re::GeomModelDescriptor::attributeByName((re::GeomModelDescriptor *)v6, (const re::DynamicString *)v573);
  unint64_t v28 = (_anonymous_namespace_ *)v573[0];
  if (v573[0] && ((uint64_t)v573[1] & 1) != 0) {
    unint64_t v28 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v573[0] + 40))();
  }
  unint64_t v3 = *(void *)(v27 + 40);
  if (v3)
  {
    if (*(void *)(v27 + 48))
    {
      unint64_t v29 = "Positions cannot be indexed.";
      goto LABEL_34;
    }
    v434 = (void *)(v3 + 8);
    id v435 = (id)(v3 + 8);
    if (*(unsigned char *)(v3 + 32) && (*(unsigned __int8 *)(v3 + 33) | 2) == 0xB)
    {
      id v436 = v434;
      uint64_t v529 = *(void *)(v3 + 48);
      uint64_t v526 = *(void *)(v3 + 24) + *(void *)(v3 + 56);
      id v437 = v434;

      v524 = 0;
      uint64_t v530 = 0;
      uint64_t v536 = 0;
    }
    else
    {
      re::internal::DataPayload::computeConvertedValues<re::PackedFloat3>(v3, (uint64_t)v573);
      if (LOBYTE(v573[0]))
      {
        uint64_t v536 = (uint64_t)v573[1];
        v573[1] = 0;
        v446 = (char *)*((void *)&v574 + 1);
        uint64_t v529 = 12;
        uint64_t v530 = v574;
        long long v574 = 0uLL;
      }
      else
      {
        v446 = 0;
        uint64_t v529 = 0;
        uint64_t v530 = 0;
        uint64_t v536 = 0;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v573);
      unint64_t v3 = 0;
      v524 = v446;
      uint64_t v526 = (uint64_t)v446;
    }

    unint64_t v11 = (unint64_t)&v573[1];
    bzero(v573, 0x2D0uLL);
    v525 = &v573[1];
    re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)&v573[1]);
    re::internal::GeomAttributeManager::addAttribute((re::internal::GeomAttributeManager *)((char *)&v576 + 8), "vertexPosition", 1, 7);
    if (LODWORD(v573[1]) > v13 && v575 && (v575 - 1) > (unint64_t)v575)
    {
      while (1)
        ;
    }
    v532 = (re::internal::GeomAttributeManager *)((char *)&v576 + 8);
    unint64_t v534 = v3;
    v540 = (uint64_t *)v12;
    LODWORD(v573[1]) = v13;
    unsigned int v578 = v13;
    if (v579)
    {
      v461 = v580;
      uint64_t v12 = 8 * v579;
      do
      {
        uint64_t v462 = *v461++;
        (*(void (**)(uint64_t, void))(*(void *)v462 + 72))(v462, v578);
        v12 -= 8;
      }
      while (v12);
    }
    if (v4 < v575)
    {
      unint64_t v3 = v585;
      if (v585)
      {
        unsigned int v463 = 0;
        uint64_t v12 = (uint64_t)v584;
        do
        {
          v464 = (re::internal *)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)v584, v463);
          re::internal::accessFaceVaryingAttributeSubmesh(v464, v465);
          ++v463;
        }
        while (v3 != v463);
      }
    }
    unint64_t v30 = v4;
    v466 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomCell4>::resize(&v574, v4);
    unsigned int v581 = v4;
    if (v582)
    {
      uint64_t v12 = v583;
      unint64_t v3 = 8 * v582;
      do
      {
        uint64_t v467 = *(void *)v12;
        v12 += 8;
        v466 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, void))(*(void *)v467 + 72))(v467, v581);
        v3 -= 8;
      }
      while (v3);
    }
    *((void *)&v557[0] + 1) = 0;
    *(_OWORD *)((char *)&v557[1] + 8) = 0uLL;
    uint64_t v468 = *(void *)&v557[0];
    *(void *)&v557[1] = *(void *)&v557[0];
    if (*(void *)&v557[0] >= 0x10uLL)
    {
      unint64_t v469 = 0;
      *(void *)&long long v470 = -1;
      *((void *)&v470 + 1) = -1;
      do
      {
        *(_OWORD *)(v556 + 16 * v469++) = v470;
        uint64_t v468 = *(void *)&v557[0];
      }
      while (v469 < *(void *)&v557[0] >> 4);
    }
    if (v468)
    {
      unint64_t v11 = 96 * v468;
      uint64_t v12 = *((void *)&v556 + 1) + 32;
      do
      {
        unint64_t v3 = v12 - 24;
        re::DynamicArray<unsigned long>::deinit(v12 + 24);
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)v12);
        v466 = (_anonymous_namespace_ *)re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v12 - 24));
        v12 += 96;
        v11 -= 96;
      }
      while (v11);
    }
    if (v5 <= 4)
    {
      unint64_t v11 = (unint64_t)&v544;
      if (!v540)
      {
LABEL_1132:
        int v501 = 0;
        *(void *)&v601[0] = 0xFFFFFFFF00000000;
        DWORD2(v601[0]) = -1;
        BYTE12(v601[0]) = 0;
        if ((v4 - 1) <= 0xFFFFFFFD)
        {
          DWORD2(v601[0]) = v4 - 1;
          int v501 = v4;
          *(void *)&v601[0] = v4;
        }
        LODWORD(v601[1]) = v501;
        re::GeomIndexMap::operator=((uint64_t)&v548 + 8, (uint64_t)v601);
        if (!BYTE12(v601[0])) {
          goto LABEL_1167;
        }
        if (BYTE12(v601[0]) == 2) {
          goto LABEL_1162;
        }
        if (BYTE12(v601[0]) != 1) {
          goto LABEL_1274;
        }
        uint64_t v503 = *(void *)&v601[1];
        if (!*(void *)&v601[1] || !*(void *)&v602[0]) {
          goto LABEL_1167;
        }
        goto LABEL_1166;
      }
      unint64_t v30 = 0;
      LODWORD(v12) = 0;
      while (1)
      {
        unsigned int v495 = *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * v12);
        if (v495 >= v13) {
          break;
        }
        unsigned int v496 = *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v12 + 1));
        if (v496 >= v13) {
          break;
        }
        unint64_t v3 = *(unsigned int *)((char *)v558 + v559 * v30);
        unsigned int v497 = *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v12 + 2));
        if (v3 != 4 || v497 >= v13)
        {
          if (v3 == 4 || v497 >= v13) {
            break;
          }
          if (v3 == 3) {
            v466 = (_anonymous_namespace_ *)re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v30, v495, v496, v497);
          }
        }
        else
        {
          unsigned int v500 = *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v12 + 3));
          if (v500 >= v13) {
            break;
          }
          v466 = (_anonymous_namespace_ *)re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v30, v495, v496, v497, v500);
        }
        uint64_t v12 = (v3 + v12);
        if (v18 == ++v30) {
          goto LABEL_1132;
        }
      }
      unint64_t v13 = 0;
      uint64_t v12 = *((void *)&v601[1] + 1);
      unint64_t v30 = *(void *)&v601[1];
      unint64_t v4 = *((void *)&v601[0] + 1);
      unint64_t v3 = *(void *)&v601[0];
      goto LABEL_1180;
    }
    unint64_t v571 = 0;
    v570 = 0;
    unint64_t v572 = 0;
    unint64_t v567 = 0;
    uint64_t v566 = 0;
    uint64_t v568 = 0;
    *(void *)&v609[32] = 0;
    memset(v609, 0, 28);
    uint64_t v12 = v5;
    v472 = (_anonymous_namespace_ *)re::DynamicArray<unsigned int>::resize(v609, v4, &re::kInvalidMeshIndex);
    uint64_t v473 = 0;
    unint64_t v3 = v571;
    unint64_t v474 = v572;
    while (v3 != v473)
    {
      *(_DWORD *)(v474 + 4 * v473) = v473;
      if (v5 == ++v473)
      {
        unsigned int v565 = 0;
        if (!v540) {
          goto LABEL_1142;
        }
        LODWORD(v12) = 0;
        unint64_t v18 = 0;
        unint64_t v4 = (unint64_t)v540;
        while (1)
        {
          unint64_t v3 = v12;
          unint64_t v475 = *(unsigned int *)((char *)v558 + v559 * v12);
          if (v475)
          {
            uint64_t v476 = *(unsigned int *)((char *)v558 + v559 * v12);
            unsigned int v477 = v18;
            do
            {
              if (*(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * v477) >= v13)
              {
                uint64_t v12 = *((void *)&v601[1] + 1);
                unint64_t v30 = *(void *)&v601[1];
                char v504 = 1;
                unint64_t v4 = *((void *)&v601[0] + 1);
                unint64_t v3 = *(void *)&v601[0];
LABEL_1143:
                if (*(void *)v609 && *(void *)&v609[32]) {
                  (*(void (**)(void))(**(void **)v609 + 40))(*(void *)v609);
                }
                if (v566 && v567) {
                  (*(void (**)(void))(*(void *)v566 + 40))();
                }
                if (v570 && v571) {
                  (*(void (**)(void))(*(void *)v570 + 40))();
                }
                if (v504)
                {
                  unint64_t v13 = 0;
                  goto LABEL_1179;
                }
                goto LABEL_1167;
              }
              ++v477;
              --v476;
            }
            while (v476);
          }
          unint64_t v11 = *(void *)&v609[16];
          if (*(void *)&v609[16] <= (unint64_t)v12) {
            goto LABEL_1241;
          }
          *(_DWORD *)(*(void *)&v609[32] + 4 * v12) = v12;
          unint64_t v523 = v475;
          if (v475 == 4) {
            break;
          }
          if (v475 == 3)
          {
            v472 = (_anonymous_namespace_ *)re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v12, *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * v18), *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * (v18 + 1)), *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * (v18 + 2)));
LABEL_1071:
            unint64_t v30 = (unint64_t)v540;
            goto LABEL_1072;
          }
          unint64_t v3 = (v475 - 2);
          v603 = 0;
          memset(v601, 0, sizeof(v601));
          memset(v602, 0, 28);
          v543 = (re::internal::GeomAttributeManager *)v3;
          unsigned int v518 = v4;
          if (v523)
          {
            uint64_t v479 = 0;
            long long v480 = v605[0];
            unint64_t v3 = *((void *)&v601[0] + 1);
            uint64_t v481 = *(void *)&v601[1];
            do
            {
              if (v3 == v479) {
                goto LABEL_1214;
              }
              *(_DWORD *)(v481 + 4 * v479) = *(_DWORD *)(v480 + *((void *)&v480 + 1) * (v18 + v479));
              ++v479;
            }
            while (v523 != v479);
            if (v523 > 0xFF)
            {
              unint64_t v486 = a2;
              re::DynamicArray<unsigned int>::resize(v602, (3 * v543), &re::kInvalidMeshIndex);
              unsigned int v487 = 0;
              int v488 = 2;
              unint64_t v11 = *(void *)&v602[1];
              v489 = v603;
              while (1)
              {
                unint64_t v3 = v487;
                if (v11 <= v487) {
                  break;
                }
                v489[v487] = 0;
                a2 = v487 + 1;
                if (v11 <= a2) {
                  goto LABEL_1238;
                }
                v489[a2] = v488 - 1;
                a2 = v487 + 2;
                if (v11 <= a2) {
                  goto LABEL_1240;
                }
                v489[a2] = v488;
                v487 += 3;
                ++v488;
                if ((int)v3 + 3 >= (3 * v543)) {
                  goto LABEL_1090;
                }
              }
            }
            else
            {
              unint64_t v11 = 0;
              uint64_t v482 = 4;
              while (1)
              {
                unint64_t v3 = v567;
                if (v567 <= v11) {
                  break;
                }
                v483 = (_DWORD *)(v526
                                + v529
                                * *(unsigned int *)(*(void *)&v605[0]
                                                  + *((void *)&v605[0] + 1) * (v18 + v11)));
                int v485 = v483[1];
                int v484 = v483[2];
                *(_DWORD *)(v568 + v482 - 4) = *v483;
                unint64_t v3 = v567;
                if (v567 <= v11) {
                  goto LABEL_1237;
                }
                *(_DWORD *)(v568 + v482) = v485;
                unint64_t v3 = v567;
                if (v567 <= v11) {
                  goto LABEL_1239;
                }
                *(_DWORD *)(v568 + v482 + 4) = v484;
                ++v11;
                v482 += 16;
                if (v523 == v11) {
                  goto LABEL_1084;
                }
              }
LABEL_1235:
              uint64_t v569 = 0;
              long long v608 = 0u;
              memset(v607, 0, sizeof(v607));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v598 = 136315906;
              *(void *)&v598[4] = "operator[]";
              *(_WORD *)&v598[12] = 1024;
              *(_DWORD *)&v598[14] = 468;
              *(_WORD *)&v598[18] = 2048;
              *(void *)&v598[20] = v11;
              __int16 v599 = 2048;
              uint64_t v600 = v3;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = v3;
            __int16 v599 = 2048;
            uint64_t v600 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1237:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 468;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = v11;
            __int16 v599 = 2048;
            uint64_t v600 = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1238:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = a2;
            __int16 v599 = 2048;
            uint64_t v600 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1239:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 468;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = v11;
            __int16 v599 = 2048;
            uint64_t v600 = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1240:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = a2;
            __int16 v599 = 2048;
            uint64_t v600 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1241:
            *(void *)v598 = 0;
            memset(v602, 0, sizeof(v602));
            memset(v601, 0, sizeof(v601));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 789;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v3;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1242:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 468;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = 0;
            __int16 v599 = 2048;
            uint64_t v600 = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1243:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = 0;
            __int16 v599 = 2048;
            uint64_t v600 = 0;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1244:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = 1;
            __int16 v599 = 2048;
            uint64_t v600 = 1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1245:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 789;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = 2;
            __int16 v599 = 2048;
            uint64_t v600 = 2;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_1084:
          unint64_t v486 = a2;
          *(void *)&v607[0] = v568;
          *((void *)&v607[0] + 1) = v523;
          *(void *)v598 = v572;
          *(void *)&v598[8] = v523;
          re::triangulatePolygon((uint64_t)v607, (uint64_t)v598, (uint64_t)v602);
LABEL_1090:
          if (!*(void *)&v601[2]) {
            goto LABEL_1242;
          }
          **((_DWORD **)&v601[2] + 1) = v12;
          if (!*(void *)&v602[1]) {
            goto LABEL_1243;
          }
          a2 = v486;
          unint64_t v4 = v518;
          if (*(void *)&v602[1] == 1) {
            goto LABEL_1244;
          }
          unint64_t v30 = (unint64_t)v540;
          if (*(void *)&v602[1] <= 2uLL) {
            goto LABEL_1245;
          }
          re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v12, *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (*v603 + v18)), *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v603[1] + v18)), *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v603[2] + v18)));
          if (v543 < 2) {
            goto LABEL_1103;
          }
          int v539 = v12;
          unint64_t v528 = a2;
          unint64_t v3 = v518;
          a2 = 5;
          unint64_t v490 = 1;
          do
          {
            unint64_t v11 = *(void *)&v601[2];
            if (*(void *)&v601[2] <= v490) {
              goto LABEL_1219;
            }
            unsigned int v491 = v518 + v490 - 1;
            *(_DWORD *)(*((void *)&v601[2] + 1) + 4 * v490) = v491;
            unint64_t v11 = v491;
            unint64_t v4 = *(void *)&v609[16];
            if (*(void *)&v609[16] <= (unint64_t)v491)
            {
LABEL_1220:
              uint64_t v569 = 0;
              long long v608 = 0u;
              memset(v607, 0, sizeof(v607));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v598 = 136315906;
              *(void *)&v598[4] = "operator[]";
              *(_WORD *)&v598[12] = 1024;
              *(_DWORD *)&v598[14] = 789;
              *(_WORD *)&v598[18] = 2048;
              *(void *)&v598[20] = v11;
              __int16 v599 = 2048;
              uint64_t v600 = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1221:
              uint64_t v569 = 0;
              long long v608 = 0u;
              memset(v607, 0, sizeof(v607));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v598 = 136315906;
              *(void *)&v598[4] = "operator[]";
              *(_WORD *)&v598[12] = 1024;
              *(_DWORD *)&v598[14] = 789;
              *(_WORD *)&v598[18] = 2048;
              *(void *)&v598[20] = v18;
              __int16 v599 = 2048;
              uint64_t v600 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1222:
              uint64_t v569 = 0;
              long long v608 = 0u;
              memset(v607, 0, sizeof(v607));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v598 = 136315906;
              *(void *)&v598[4] = "operator[]";
              *(_WORD *)&v598[12] = 1024;
              *(_DWORD *)&v598[14] = 789;
              *(_WORD *)&v598[18] = 2048;
              *(void *)&v598[20] = v6;
              __int16 v599 = 2048;
              uint64_t v600 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1223:
              uint64_t v569 = 0;
              long long v608 = 0u;
              memset(v607, 0, sizeof(v607));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v598 = 136315906;
              *(void *)&v598[4] = "operator[]";
              *(_WORD *)&v598[12] = 1024;
              *(_DWORD *)&v598[14] = 789;
              *(_WORD *)&v598[18] = 2048;
              *(void *)&v598[20] = v4;
              __int16 v599 = 2048;
              uint64_t v600 = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1224:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1225:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1226:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1227:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v6;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1228:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v13;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1229:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v11;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v13;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1230:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v6;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1231:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v13;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1232:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v13;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1233:
              *(void *)v609 = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v605[0]) = 136315906;
              *(void *)((char *)v605 + 4) = "operator[]";
              WORD6(v605[0]) = 1024;
              *(_DWORD *)((char *)v605 + 14) = 609;
              WORD1(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 4) = v6;
              WORD6(v605[1]) = 2048;
              *(void *)((char *)&v605[1] + 14) = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_1234:
              *(void *)&v605[0] = 0;
              long long v577 = 0u;
              long long v576 = 0u;
              long long v575 = 0u;
              long long v574 = 0u;
              *(_OWORD *)v573 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(v607[0]) = 136315906;
              *(void *)((char *)v607 + 4) = "operator[]";
              WORD6(v607[0]) = 1024;
              *(_DWORD *)((char *)v607 + 14) = 609;
              WORD1(v607[1]) = 2048;
              *(void *)((char *)&v607[1] + 4) = v6;
              WORD6(v607[1]) = 2048;
              *(void *)((char *)&v607[1] + 14) = v11;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_1235;
            }
            unint64_t v492 = v18;
            unint64_t v18 = (a2 - 2);
            *(_DWORD *)(*(void *)&v609[32] + 4 * v491) = v539;
            unint64_t v11 = *(void *)&v602[1];
            if (*(void *)&v602[1] <= (unint64_t)v18) {
              goto LABEL_1221;
            }
            unint64_t v493 = v13;
            unint64_t v13 = v6;
            unint64_t v6 = (a2 - 1);
            if (*(void *)&v602[1] <= v6) {
              goto LABEL_1222;
            }
            unint64_t v4 = a2;
            if (*(void *)&v602[1] <= (unint64_t)a2) {
              goto LABEL_1223;
            }
            int v494 = v603[v18];
            unint64_t v18 = v492;
            re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v491, *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v494 + v492)), *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1) * (v603[v6] + v492)), *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1)* (v603[a2] + v492)));
            ++v490;
            a2 = (a2 + 3);
            unint64_t v6 = v13;
            unint64_t v13 = v493;
          }
          while (v543 != (re::internal::GeomAttributeManager *)v490);
          unint64_t v4 = v518 + v490 - 1;
          a2 = v528;
          unint64_t v30 = (unint64_t)v540;
          LODWORD(v12) = v539;
LABEL_1103:
          re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::addNew((_anonymous_namespace_ *)&v556, &v565, (uint64_t)v601);
          if (*(void *)&v602[0])
          {
            if (v603) {
              (*(void (**)(void))(**(void **)&v602[0] + 40))();
            }
            v603 = 0;
            memset(v602, 0, 24);
            ++DWORD2(v602[1]);
          }
          if (*((void *)&v601[1] + 1))
          {
            if (*(void *)&v601[2])
            {
              (*(void (**)(void))(**((void **)&v601[1] + 1) + 40))();
              v601[2] = 0uLL;
            }
            *((void *)&v601[1] + 1) = 0;
          }
          v472 = *(_anonymous_namespace_ **)&v601[0];
          if (*(void *)&v601[0] && *((void *)&v601[0] + 1)) {
            v472 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v601[0] + 40))();
          }
LABEL_1072:
          unint64_t v18 = (v523 + v18);
          uint64_t v12 = (v12 + 1);
          unsigned int v565 = v12;
          if (v12 >= v30)
          {
LABEL_1142:
            re::GeomIndexMap::GeomIndexMap((uint64_t)v601, (uint64_t)v609);
            re::GeomIndexMap::operator=((uint64_t)&v548 + 8, (uint64_t)v601);
            re::GeomIndexMap::~GeomIndexMap((re::GeomIndexMap *)v601, v505);
            char v504 = 0;
            goto LABEL_1143;
          }
        }
        v472 = (_anonymous_namespace_ *)re::GeomMeshBuilder::setFaceVertices((uint64_t)v573, v12, *(_DWORD *)(*(void *)&v605[0] + *((void *)&v605[0] + 1)* v18), *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * (v18 + 1)), *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * (v18 + 2)), *(_DWORD *)(*(void *)&v605[0]+ *((void *)&v605[0] + 1) * (v18 + 3)));
        goto LABEL_1071;
      }
    }
    goto LABEL_1196;
  }
  unint64_t v29 = "No positions specified for model.";
LABEL_34:
  unint64_t v13 = 0;
  uint64_t v12 = *((void *)&v574 + 1);
  unint64_t v30 = v574;
  unint64_t v3 = (unint64_t)v573[0];
  unint64_t v4 = (unint64_t)v573[1];
  while (2)
  {
    unint64_t v31 = *(_anonymous_namespace_ **)&v605[2];
    if (*(void *)&v605[2])
    {
      if (*((void *)&v605[2] + 1))
      {
        unint64_t v31 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(**(void **)&v605[2] + 40))(*(void *)&v605[2], *(void *)&v605[3]);
        *((void *)&v605[2] + 1) = 0;
        *(void *)&v605[3] = 0;
        unint64_t v11 = (unint64_t)&v544;
      }
      *(void *)&v605[2] = 0;
    }
    if (*((void *)&v605[1] + 1)) {

    }
    v540 = &v551;
    if (!v13)
    {
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(void *)(a2 + 40) = v30;
      *(void *)(a2 + 48) = v12;
      *(void *)(a2 + 24) = v3;
      *(void *)(a2 + 32) = v4;
      goto LABEL_983;
    }
    uint64_t v32 = *(void *)(v6 + 40);
    if (v32) {
      uint64_t v529 = *(void *)(v32 + 40);
    }
    else {
      uint64_t v529 = 0;
    }
    unint64_t v5 = *(void *)(v6 + 112);
    unint64_t v527 = a2;
    if (!v5) {
      goto LABEL_893;
    }
    unint64_t v4 = 0;
    v524 = (char *)&v601[2] + 8;
    unint64_t v538 = *(void *)(v6 + 112);
LABEL_48:
    unint64_t v33 = *(void *)(v6 + 112);
    if (v33 <= v4)
    {
      *(void *)&v607[0] = 0;
      long long v577 = 0u;
      long long v576 = 0u;
      long long v575 = 0u;
      long long v574 = 0u;
      *(_OWORD *)v573 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v601[0]) = 136315906;
      *(void *)((char *)v601 + 4) = "operator[]";
      WORD6(v601[0]) = 1024;
      *(_DWORD *)((char *)v601 + 14) = 797;
      WORD1(v601[1]) = 2048;
      *(void *)((char *)&v601[1] + 4) = v4;
      WORD6(v601[1]) = 2048;
      *(void *)((char *)&v601[1] + 14) = v33;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_1189;
    }
    uint64_t v12 = *(void *)(v6 + 128);
    unint64_t v13 = v12 + 56 * v4;
    BOOL v34 = re::DynamicString::operator!=(v13, (uint64_t)v598);
    if (!v34) {
      goto LABEL_103;
    }
    unint64_t v35 = v12 + 56 * v4;
    uint64_t v38 = *(void *)(v35 + 40);
    int v37 = (char **)(v35 + 40);
    uint64_t v36 = v38;
    if (!v38)
    {
      int v40 = "Null attribute.";
LABEL_99:
      uint64_t v72 = v574;
      uint64_t v73 = v573[0];
      unint64_t v3 = (unint64_t)v573[1];
      goto LABEL_100;
    }
    switch(*(unsigned char *)(v12 + 56 * v4 + 32))
    {
      case 0:
        uint64_t v39 = *(void *)(v12 + 56 * v4 + 48);
        if (!v39) {
          uint64_t v39 = v36;
        }
        if (*(void *)(v39 + 40) != 1) {
          goto LABEL_98;
        }
        goto LABEL_62;
      case 1:
        unint64_t v41 = v545;
        goto LABEL_59;
      case 2:
        unint64_t v41 = v560;
LABEL_59:
        uint64_t v42 = *(void *)(v12 + 56 * v4 + 48);
        if (!v42) {
          uint64_t v42 = v36;
        }
        if (*(void *)(v42 + 40) == v41) {
          goto LABEL_62;
        }
        goto LABEL_98;
      case 3:
        uint64_t v71 = *(void *)(v12 + 56 * v4 + 48);
        if (!v71) {
          uint64_t v71 = v36;
        }
        if (*(void *)(v71 + 40) != v529)
        {
LABEL_98:
          int v40 = "Incorrect number of attribute values specified.";
          goto LABEL_99;
        }
        int v43 = 1;
LABEL_63:
        unint64_t v44 = *(char *)(v36 + 33);
        if (v44 >= 0xC)
        {
          int v40 = "Unexpected attribute type.";
          goto LABEL_99;
        }
        uint64_t v536 = byte_23440AD14[v44];
        if (!v43)
        {
          if (*(void *)(v13 + 8)) {
            __int16 v74 = *(char **)(v13 + 16);
          }
          else {
            __int16 v74 = (char *)(v13 + 9);
          }
          unint64_t v75 = re::GeomMesh::addAttribute((uint64_t)&v544, v74, *(unsigned __int8 *)(v12 + 56 * v4 + 32), byte_23440AD14[v44]);
          long long v76 = (unsigned __int8 *)v75;
          if (!v75) {
            goto LABEL_192;
          }
LABEL_109:
          switch((int)v536)
          {
            case 0:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                long long v77 = *(char **)(v12 + 56 * v4 + 48);
                if (v77 || (long long v77 = *v37) != 0) {
                  uint64_t v78 = *((void *)v77 + 5);
                }
                else {
                  uint64_t v78 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v78);
              }
              long long v79 = *v37;
              v573[0] = v79;
              if (v79) {
                long long v80 = v79 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<short>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v164 = *(void *)(v12 + 56 * v4 + 48);
              BOOL v165 = v13 == 3 || v164 == 0;
              if (!v165)
              {
                unint64_t v175 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v176 = (id)(v164 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v178 = v601[1];
                unsigned int v179 = v607[1];
                unint64_t v180 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v182 = *((void *)&v607[0] + 1);
                  int v181 = *(unsigned int **)&v607[0];
                  unint64_t v6 = a2;
                  long long v183 = v601[0];
                  do
                  {
                    uint64_t v184 = *v181;
                    if (v184 < v178)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1224;
                      }
                      *(_WORD *)(v3 + 2 * v11) = *(_WORD *)(v183 + *((void *)&v183 + 1) * v184);
                    }
                    int v181 = (unsigned int *)((char *)v181 + v182);
                    ++v11;
                  }
                  while (v180 != v11);
                }
                unint64_t v6 = v175;
                unint64_t v5 = v538;
                if (v13 == 2 && a2 > v179)
                {
                  while (2)
                  {
                    LODWORD(v573[0]) = v180;
                    if (v550 == 2)
                    {
                      uint64_t v186 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                      if (v186 != -1)
                      {
                        unsigned int v185 = *(_DWORD *)(v552 + 8 * v186 + 4);
                        goto LABEL_333;
                      }
                    }
                    else
                    {
                      if (v550 != 1)
                      {
                        if (v550) {
                          goto LABEL_1253;
                        }
                        if (v180 >= v551) {
                          unsigned int v185 = -1;
                        }
                        else {
                          unsigned int v185 = v180;
                        }
LABEL_333:
                        uint64_t v187 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v185);
                        if (v187 < v178) {
                          *(_WORD *)(v3 + 2 * v180) = *(_WORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v187);
                        }
                        if (a2 == ++v180) {
                          goto LABEL_802;
                        }
                        continue;
                      }
                      if ((unint64_t)v553 > v180)
                      {
                        unsigned int v185 = *(_DWORD *)(v554 + 4 * v180);
                        goto LABEL_333;
                      }
                    }
                    break;
                  }
                  unsigned int v185 = -1;
                  goto LABEL_333;
                }
LABEL_802:
                if (*(void *)&v607[2])
                {
                  if (*((void *)&v607[2] + 1))
                  {
                    (*(void (**)(void, void))(**(void **)&v607[2] + 40))(*(void *)&v607[2], *(void *)&v607[3]);
                    *((void *)&v607[2] + 1) = 0;
                    *(void *)&v607[3] = 0;
                  }
                  *(void *)&v607[2] = 0;
                }
                if (*((void *)&v607[1] + 1)) {

                }
LABEL_808:
                uint64_t v355 = *(void *)&v601[2];
                a2 = v18;
                if (*(void *)&v601[2])
                {
LABEL_809:
                  if (*((void *)&v601[2] + 1))
                  {
                    (*(void (**)(uint64_t, void))(*(void *)v355 + 40))(v355, *(void *)&v602[0]);
                    *((void *)&v601[2] + 1) = 0;
                    *(void *)&v602[0] = 0;
                  }
                  *(void *)&v601[2] = 0;
                }
LABEL_812:
                unint64_t v373 = *((void *)&v601[1] + 1);
                if (!*((void *)&v601[1] + 1)) {
                  goto LABEL_103;
                }
LABEL_813:

                goto LABEL_103;
              }
              unsigned int v166 = v601[1];
              unint64_t v167 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v169 = *((void *)&v601[0] + 1);
                unint64_t v168 = *(_WORD **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v170 = a2;
                uint64_t v171 = LODWORD(v601[1]);
                unint64_t v172 = (_WORD *)v3;
                while (v170)
                {
                  *v172++ = *v168;
                  unint64_t v168 = (_WORD *)((char *)v168 + v169);
                  --v170;
                  if (!--v171) {
                    goto LABEL_297;
                  }
                }
                goto LABEL_1203;
              }
LABEL_297:
              if (v13 != 2 || a2 <= v166) {
                goto LABEL_808;
              }
              while (2)
              {
                LODWORD(v573[0]) = v167;
                if (v550 == 2)
                {
                  uint64_t v174 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v174 != -1)
                  {
                    unsigned int v173 = *(_DWORD *)(v552 + 8 * v174 + 4);
                    goto LABEL_310;
                  }
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1252;
                    }
                    if (v167 >= v551) {
                      unsigned int v173 = -1;
                    }
                    else {
                      unsigned int v173 = v167;
                    }
LABEL_310:
                    *(_WORD *)(v3 + 2 * v167++) = *(_WORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v173);
                    if (a2 == v167) {
                      goto LABEL_808;
                    }
                    continue;
                  }
                  if ((unint64_t)v553 > v167)
                  {
                    unsigned int v173 = *(_DWORD *)(v554 + 4 * v167);
                    goto LABEL_310;
                  }
                }
                break;
              }
              unsigned int v173 = -1;
              goto LABEL_310;
            case 1:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                uint64_t v120 = *(char **)(v12 + 56 * v4 + 48);
                if (v120 || (uint64_t v120 = *v37) != 0) {
                  uint64_t v121 = *((void *)v120 + 5);
                }
                else {
                  uint64_t v121 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v121);
              }
              int v122 = *v37;
              v573[0] = v122;
              if (v122) {
                unint64_t v123 = v122 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<unsigned short>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v188 = *(void *)(v12 + 56 * v4 + 48);
              if (v13 != 3 && v188 != 0)
              {
                unint64_t v199 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v200 = (id)(v188 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v202 = v601[1];
                unsigned int v203 = v607[1];
                unint64_t v204 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v206 = *((void *)&v607[0] + 1);
                  __int16 v205 = *(unsigned int **)&v607[0];
                  unint64_t v6 = a2;
                  long long v207 = v601[0];
                  do
                  {
                    uint64_t v208 = *v205;
                    if (v208 < v202)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1225;
                      }
                      *(_WORD *)(v3 + 2 * v11) = *(_WORD *)(v207 + *((void *)&v207 + 1) * v208);
                    }
                    __int16 v205 = (unsigned int *)((char *)v205 + v206);
                    ++v11;
                  }
                  while (v204 != v11);
                }
                unint64_t v6 = v199;
                unint64_t v5 = v538;
                if (v13 != 2 || a2 <= v203) {
                  goto LABEL_802;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v204;
                  if (v550 == 2)
                  {
                    uint64_t v210 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v210 == -1) {
                      goto LABEL_382;
                    }
                    unsigned int v209 = *(_DWORD *)(v552 + 8 * v210 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1255;
                      }
                      if (v204 >= v551) {
                        unsigned int v209 = -1;
                      }
                      else {
                        unsigned int v209 = v204;
                      }
                      goto LABEL_383;
                    }
                    if ((unint64_t)v553 <= v204)
                    {
LABEL_382:
                      unsigned int v209 = -1;
                      goto LABEL_383;
                    }
                    unsigned int v209 = *(_DWORD *)(v554 + 4 * v204);
                  }
LABEL_383:
                  uint64_t v211 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v209);
                  if (v211 < v202) {
                    *(_WORD *)(v3 + 2 * v204) = *(_WORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v211);
                  }
                  if (a2 == ++v204) {
                    goto LABEL_802;
                  }
                }
              }
              unsigned int v190 = v601[1];
              unint64_t v191 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v193 = *((void *)&v601[0] + 1);
                uint64_t v192 = *(_WORD **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v194 = a2;
                uint64_t v195 = LODWORD(v601[1]);
                uint64_t v196 = (_WORD *)v3;
                while (v194)
                {
                  *v196++ = *v192;
                  uint64_t v192 = (_WORD *)((char *)v192 + v193);
                  --v194;
                  if (!--v195) {
                    goto LABEL_347;
                  }
                }
                goto LABEL_1204;
              }
LABEL_347:
              if (v13 != 2 || a2 <= v190) {
                goto LABEL_808;
              }
              while (1)
              {
                LODWORD(v573[0]) = v191;
                if (v550 == 2)
                {
                  uint64_t v198 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v198 == -1) {
                    goto LABEL_359;
                  }
                  unsigned int v197 = *(_DWORD *)(v552 + 8 * v198 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1254;
                    }
                    if (v191 >= v551) {
                      unsigned int v197 = -1;
                    }
                    else {
                      unsigned int v197 = v191;
                    }
                    goto LABEL_360;
                  }
                  if ((unint64_t)v553 <= v191)
                  {
LABEL_359:
                    unsigned int v197 = -1;
                    goto LABEL_360;
                  }
                  unsigned int v197 = *(_DWORD *)(v554 + 4 * v191);
                }
LABEL_360:
                *(_WORD *)(v3 + 2 * v191++) = *(_WORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v197);
                if (a2 == v191) {
                  goto LABEL_808;
                }
              }
            case 2:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                uint64_t v125 = *(char **)(v12 + 56 * v4 + 48);
                if (v125 || (uint64_t v125 = *v37) != 0) {
                  uint64_t v126 = *((void *)v125 + 5);
                }
                else {
                  uint64_t v126 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v126);
              }
              int v127 = *v37;
              v573[0] = v127;
              if (v127) {
                unint64_t v128 = v127 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<int>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v212 = *(void *)(v12 + 56 * v4 + 48);
              if (v13 != 3 && v212 != 0)
              {
                unint64_t v223 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v224 = (id)(v212 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v226 = v601[1];
                unsigned int v227 = v607[1];
                unint64_t v228 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v230 = *((void *)&v607[0] + 1);
                  uint64_t v229 = *(unsigned int **)&v607[0];
                  unint64_t v6 = a2;
                  long long v231 = v601[0];
                  do
                  {
                    uint64_t v232 = *v229;
                    if (v232 < v226)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1226;
                      }
                      *(_DWORD *)(v3 + 4 * v11) = *(_DWORD *)(v231 + *((void *)&v231 + 1) * v232);
                    }
                    uint64_t v229 = (unsigned int *)((char *)v229 + v230);
                    ++v11;
                  }
                  while (v228 != v11);
                }
                unint64_t v6 = v223;
                unint64_t v5 = v538;
                if (v13 != 2 || a2 <= v227) {
                  goto LABEL_802;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v228;
                  if (v550 == 2)
                  {
                    uint64_t v234 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v234 == -1) {
                      goto LABEL_432;
                    }
                    unsigned int v233 = *(_DWORD *)(v552 + 8 * v234 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1257;
                      }
                      if (v228 >= v551) {
                        unsigned int v233 = -1;
                      }
                      else {
                        unsigned int v233 = v228;
                      }
                      goto LABEL_433;
                    }
                    if ((unint64_t)v553 <= v228)
                    {
LABEL_432:
                      unsigned int v233 = -1;
                      goto LABEL_433;
                    }
                    unsigned int v233 = *(_DWORD *)(v554 + 4 * v228);
                  }
LABEL_433:
                  uint64_t v235 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v233);
                  if (v235 < v226) {
                    *(_DWORD *)(v3 + 4 * v228) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v235);
                  }
                  if (a2 == ++v228) {
                    goto LABEL_802;
                  }
                }
              }
              unsigned int v214 = v601[1];
              unint64_t v215 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v217 = *((void *)&v601[0] + 1);
                long long v216 = *(_DWORD **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v218 = a2;
                uint64_t v219 = LODWORD(v601[1]);
                unsigned int v220 = (_DWORD *)v3;
                while (v218)
                {
                  *v220++ = *v216;
                  long long v216 = (_DWORD *)((char *)v216 + v217);
                  --v218;
                  if (!--v219) {
                    goto LABEL_397;
                  }
                }
                goto LABEL_1205;
              }
LABEL_397:
              if (v13 != 2 || a2 <= v214) {
                goto LABEL_808;
              }
              while (1)
              {
                LODWORD(v573[0]) = v215;
                if (v550 == 2)
                {
                  uint64_t v222 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v222 == -1) {
                    goto LABEL_409;
                  }
                  unsigned int v221 = *(_DWORD *)(v552 + 8 * v222 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1256;
                    }
                    if (v215 >= v551) {
                      unsigned int v221 = -1;
                    }
                    else {
                      unsigned int v221 = v215;
                    }
                    goto LABEL_410;
                  }
                  if ((unint64_t)v553 <= v215)
                  {
LABEL_409:
                    unsigned int v221 = -1;
                    goto LABEL_410;
                  }
                  unsigned int v221 = *(_DWORD *)(v554 + 4 * v215);
                }
LABEL_410:
                *(_DWORD *)(v3 + 4 * v215++) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v221);
                if (a2 == v215) {
                  goto LABEL_808;
                }
              }
            case 3:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                uint64_t v130 = *(char **)(v12 + 56 * v4 + 48);
                if (v130 || (uint64_t v130 = *v37) != 0) {
                  uint64_t v131 = *((void *)v130 + 5);
                }
                else {
                  uint64_t v131 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v131);
              }
              uint64_t v132 = *v37;
              v573[0] = v132;
              if (v132) {
                v133 = v132 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v236 = *(void *)(v12 + 56 * v4 + 48);
              if (v13 != 3 && v236 != 0)
              {
                unint64_t v247 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v248 = (id)(v236 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v250 = v601[1];
                unsigned int v251 = v607[1];
                unint64_t v252 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v254 = *((void *)&v607[0] + 1);
                  v253 = *(unsigned int **)&v607[0];
                  unint64_t v6 = a2;
                  long long v255 = v601[0];
                  do
                  {
                    uint64_t v256 = *v253;
                    if (v256 < v250)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1227;
                      }
                      *(_DWORD *)(v3 + 4 * v11) = *(_DWORD *)(v255 + *((void *)&v255 + 1) * v256);
                    }
                    v253 = (unsigned int *)((char *)v253 + v254);
                    ++v11;
                  }
                  while (v252 != v11);
                }
                unint64_t v6 = v247;
                unint64_t v5 = v538;
                if (v13 != 2 || a2 <= v251) {
                  goto LABEL_802;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v252;
                  if (v550 == 2)
                  {
                    uint64_t v258 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v258 == -1) {
                      goto LABEL_482;
                    }
                    unsigned int v257 = *(_DWORD *)(v552 + 8 * v258 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1259;
                      }
                      if (v252 >= v551) {
                        unsigned int v257 = -1;
                      }
                      else {
                        unsigned int v257 = v252;
                      }
                      goto LABEL_483;
                    }
                    if ((unint64_t)v553 <= v252)
                    {
LABEL_482:
                      unsigned int v257 = -1;
                      goto LABEL_483;
                    }
                    unsigned int v257 = *(_DWORD *)(v554 + 4 * v252);
                  }
LABEL_483:
                  uint64_t v259 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v257);
                  if (v259 < v250) {
                    *(_DWORD *)(v3 + 4 * v252) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v259);
                  }
                  if (a2 == ++v252) {
                    goto LABEL_802;
                  }
                }
              }
              unsigned int v238 = v601[1];
              unint64_t v239 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v241 = *((void *)&v601[0] + 1);
                v240 = *(_DWORD **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v242 = a2;
                uint64_t v243 = LODWORD(v601[1]);
                v244 = (_DWORD *)v3;
                while (v242)
                {
                  *v244++ = *v240;
                  v240 = (_DWORD *)((char *)v240 + v241);
                  --v242;
                  if (!--v243) {
                    goto LABEL_447;
                  }
                }
                goto LABEL_1206;
              }
LABEL_447:
              if (v13 != 2 || a2 <= v238) {
                goto LABEL_808;
              }
              while (1)
              {
                LODWORD(v573[0]) = v239;
                if (v550 == 2)
                {
                  uint64_t v246 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v246 == -1) {
                    goto LABEL_459;
                  }
                  unsigned int v245 = *(_DWORD *)(v552 + 8 * v246 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1258;
                    }
                    if (v239 >= v551) {
                      unsigned int v245 = -1;
                    }
                    else {
                      unsigned int v245 = v239;
                    }
                    goto LABEL_460;
                  }
                  if ((unint64_t)v553 <= v239)
                  {
LABEL_459:
                    unsigned int v245 = -1;
                    goto LABEL_460;
                  }
                  unsigned int v245 = *(_DWORD *)(v554 + 4 * v239);
                }
LABEL_460:
                *(_DWORD *)(v3 + 4 * v239++) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v245);
                if (a2 == v239) {
                  goto LABEL_808;
                }
              }
            case 4:
              unint64_t v18 = v6;
              unint64_t v6 = v76[16];
              if (v6 == 4)
              {
                int v135 = *(char **)(v12 + 56 * v4 + 48);
                if (v135 || (int v135 = *v37) != 0) {
                  uint64_t v136 = *((void *)v135 + 5);
                }
                else {
                  uint64_t v136 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v136);
              }
              re::GeomModelDescriptor::AttributeData::makeConvertedValues<float>(v13, (uint64_t)v601);
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              unint64_t v5 = v538;
              uint64_t v260 = *(void *)(v12 + 56 * v4 + 48);
              if (v6 != 3 && v260 != 0)
              {
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v271 = (id)(v260 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v273 = v601[1];
                unsigned int v274 = v607[1];
                unint64_t v275 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v277 = *((void *)&v607[0] + 1);
                  v276 = *(unsigned int **)&v607[0];
                  unint64_t v13 = a2;
                  long long v278 = v601[0];
                  do
                  {
                    uint64_t v279 = *v276;
                    if (v279 < v273)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1228;
                      }
                      *(_DWORD *)(v3 + 4 * v11) = *(_DWORD *)(v278 + *((void *)&v278 + 1) * v279);
                    }
                    v276 = (unsigned int *)((char *)v276 + v277);
                    ++v11;
                  }
                  while (v275 != v11);
                }
                BOOL v165 = v6 == 2;
                unint64_t v6 = v18;
                if (v165 && a2 > v274)
                {
                  while (1)
                  {
                    LODWORD(v573[0]) = v275;
                    if (v550 == 2)
                    {
                      uint64_t v281 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                      if (v281 == -1) {
                        goto LABEL_534;
                      }
                      unsigned int v280 = *(_DWORD *)(v552 + 8 * v281 + 4);
                    }
                    else
                    {
                      if (v550 != 1)
                      {
                        if (v550) {
                          goto LABEL_1261;
                        }
                        if (v275 >= v551) {
                          unsigned int v280 = -1;
                        }
                        else {
                          unsigned int v280 = v275;
                        }
                        goto LABEL_535;
                      }
                      if ((unint64_t)v553 <= v275)
                      {
LABEL_534:
                        unsigned int v280 = -1;
                        goto LABEL_535;
                      }
                      unsigned int v280 = *(_DWORD *)(v554 + 4 * v275);
                    }
LABEL_535:
                    uint64_t v282 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v280);
                    if (v282 < v273) {
                      *(_DWORD *)(v3 + 4 * v275) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v282);
                    }
                    if (a2 == ++v275) {
                      goto LABEL_745;
                    }
                  }
                }
                goto LABEL_745;
              }
              unsigned int v262 = v601[1];
              unint64_t v263 = LODWORD(v601[1]);
              if (LODWORD(v601[1]))
              {
                uint64_t v265 = *((void *)&v601[0] + 1);
                v264 = *(_DWORD **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v266 = a2;
                uint64_t v267 = LODWORD(v601[1]);
                v268 = (_DWORD *)v3;
                while (v266)
                {
                  *v268++ = *v264;
                  v264 = (_DWORD *)((char *)v264 + v265);
                  --v266;
                  if (!--v267) {
                    goto LABEL_497;
                  }
                }
                goto LABEL_1207;
              }
LABEL_497:
              BOOL v165 = v6 == 2;
              unint64_t v6 = v18;
              if (!v165 || a2 <= v262) {
                goto LABEL_751;
              }
              while (1)
              {
                LODWORD(v573[0]) = v263;
                if (v550 == 2)
                {
                  uint64_t v270 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v270 == -1) {
                    goto LABEL_510;
                  }
                  unsigned int v269 = *(_DWORD *)(v552 + 8 * v270 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1260;
                    }
                    if (v263 >= v551) {
                      unsigned int v269 = -1;
                    }
                    else {
                      unsigned int v269 = v263;
                    }
                    goto LABEL_511;
                  }
                  if ((unint64_t)v553 <= v263)
                  {
LABEL_510:
                    unsigned int v269 = -1;
                    goto LABEL_511;
                  }
                  unsigned int v269 = *(_DWORD *)(v554 + 4 * v263);
                }
LABEL_511:
                *(_DWORD *)(v3 + 4 * v263++) = *(_DWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v269);
                if (a2 == v263) {
                  goto LABEL_751;
                }
              }
            case 5:
              unint64_t v18 = v6;
              unint64_t v6 = v76[16];
              if (v6 == 4)
              {
                unint64_t v138 = *(char **)(v12 + 56 * v4 + 48);
                if (v138 || (unint64_t v138 = *v37) != 0) {
                  uint64_t v139 = *((void *)v138 + 5);
                }
                else {
                  uint64_t v139 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v139);
              }
              re::GeomModelDescriptor::AttributeData::makeConvertedValues<double>(v13, (uint64_t)v601);
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              unint64_t v5 = v538;
              uint64_t v283 = *(void *)(v12 + 56 * v4 + 48);
              if (v6 != 3 && v283 != 0)
              {
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v294 = (id)(v283 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v296 = v601[1];
                unsigned int v297 = v607[1];
                unint64_t v298 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v11 = 0;
                  uint64_t v300 = *((void *)&v607[0] + 1);
                  v299 = *(unsigned int **)&v607[0];
                  unint64_t v13 = a2;
                  long long v301 = v601[0];
                  do
                  {
                    uint64_t v302 = *v299;
                    if (v302 < v296)
                    {
                      if (v11 >= a2) {
                        goto LABEL_1229;
                      }
                      *(void *)(v3 + 8 * v11) = *(void *)(v301 + *((void *)&v301 + 1) * v302);
                    }
                    v299 = (unsigned int *)((char *)v299 + v300);
                    ++v11;
                  }
                  while (v298 != v11);
                }
                BOOL v165 = v6 == 2;
                unint64_t v6 = v18;
                if (v165 && a2 > v297)
                {
                  do
                  {
                    LODWORD(v573[0]) = v298;
                    if (v550 == 2)
                    {
                      uint64_t v304 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                      if (v304 == -1) {
                        goto LABEL_586;
                      }
                      unsigned int v303 = *(_DWORD *)(v552 + 8 * v304 + 4);
                    }
                    else
                    {
                      if (v550 != 1)
                      {
                        if (v550) {
                          goto LABEL_1263;
                        }
                        if (v298 >= v551) {
                          unsigned int v303 = -1;
                        }
                        else {
                          unsigned int v303 = v298;
                        }
                        goto LABEL_587;
                      }
                      if ((unint64_t)v553 <= v298)
                      {
LABEL_586:
                        unsigned int v303 = -1;
                        goto LABEL_587;
                      }
                      unsigned int v303 = *(_DWORD *)(v554 + 4 * v298);
                    }
LABEL_587:
                    uint64_t v305 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v303);
                    if (v305 < v296) {
                      *(void *)(v3 + 8 * v298) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v305);
                    }
                    ++v298;
                  }
                  while (a2 != v298);
                }
LABEL_745:
                if (*(void *)&v607[2])
                {
                  if (*((void *)&v607[2] + 1))
                  {
                    (*(void (**)(void, void))(**(void **)&v607[2] + 40))(*(void *)&v607[2], *(void *)&v607[3]);
                    *((void *)&v607[2] + 1) = 0;
                    *(void *)&v607[3] = 0;
                  }
                  *(void *)&v607[2] = 0;
                }
                if (*((void *)&v607[1] + 1)) {

                }
                goto LABEL_751;
              }
              unsigned int v285 = v601[1];
              unint64_t v286 = LODWORD(v601[1]);
              if (LODWORD(v601[1]))
              {
                uint64_t v288 = *((void *)&v601[0] + 1);
                v287 = *(void **)&v601[0];
                uint64_t v12 = a2;
                uint64_t v289 = a2;
                uint64_t v290 = LODWORD(v601[1]);
                v291 = (void *)v3;
                while (v289)
                {
                  *v291++ = *v287;
                  v287 = (void *)((char *)v287 + v288);
                  --v289;
                  if (!--v290) {
                    goto LABEL_549;
                  }
                }
                goto LABEL_1208;
              }
LABEL_549:
              BOOL v165 = v6 == 2;
              unint64_t v6 = v18;
              if (!v165 || a2 <= v285) {
                goto LABEL_751;
              }
              while (1)
              {
                LODWORD(v573[0]) = v286;
                if (v550 == 2)
                {
                  uint64_t v293 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v293 == -1) {
                    goto LABEL_562;
                  }
                  unsigned int v292 = *(_DWORD *)(v552 + 8 * v293 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1262;
                    }
                    if (v286 >= v551) {
                      unsigned int v292 = -1;
                    }
                    else {
                      unsigned int v292 = v286;
                    }
                    goto LABEL_563;
                  }
                  if ((unint64_t)v553 <= v286)
                  {
LABEL_562:
                    unsigned int v292 = -1;
                    goto LABEL_563;
                  }
                  unsigned int v292 = *(_DWORD *)(v554 + 4 * v286);
                }
LABEL_563:
                *(void *)(v3 + 8 * v286++) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v292);
                if (a2 == v286) {
                  goto LABEL_751;
                }
              }
            case 6:
              unint64_t v18 = v6;
              unint64_t v6 = v76[16];
              if (v6 == 4)
              {
                v153 = *(char **)(v12 + 56 * v4 + 48);
                if (v153 || (v153 = *v37) != 0) {
                  uint64_t v154 = *((void *)v153 + 5);
                }
                else {
                  uint64_t v154 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v154);
              }
              _ZNK2re19GeomModelDescriptor13AttributeData19makeConvertedValuesIDv2_fEENS0_15ConvertedValuesIT_EEv(v13, (uint64_t)v601);
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              unint64_t v5 = v538;
              uint64_t v323 = *(void *)(v12 + 56 * v4 + 48);
              if (v6 != 3 && v323 != 0)
              {
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v330 = (id)(v323 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v332 = v601[1];
                unsigned int v333 = v607[1];
                unint64_t v334 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v13 = 0;
                  unint64_t v11 = a2;
                  do
                  {
                    uint64_t v335 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v13);
                    if (v335 < v332)
                    {
                      if (v13 >= a2) {
                        goto LABEL_1231;
                      }
                      *(void *)(v3 + 8 * v13) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v335);
                    }
                    ++v13;
                  }
                  while (v334 != v13);
                }
                BOOL v165 = v6 == 2;
                unint64_t v6 = v18;
                if (!v165 || a2 <= v333) {
                  goto LABEL_745;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v334;
                  if (v550 == 2)
                  {
                    uint64_t v337 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v337 == -1) {
                      goto LABEL_689;
                    }
                    unsigned int v336 = *(_DWORD *)(v552 + 8 * v337 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1267;
                      }
                      if (v334 >= v551) {
                        unsigned int v336 = -1;
                      }
                      else {
                        unsigned int v336 = v334;
                      }
                      goto LABEL_690;
                    }
                    if ((unint64_t)v553 <= v334)
                    {
LABEL_689:
                      unsigned int v336 = -1;
                      goto LABEL_690;
                    }
                    unsigned int v336 = *(_DWORD *)(v554 + 4 * v334);
                  }
LABEL_690:
                  uint64_t v338 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v336);
                  if (v338 < v332) {
                    *(void *)(v3 + 8 * v334) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v338);
                  }
                  if (a2 == ++v334) {
                    goto LABEL_745;
                  }
                }
              }
              unsigned int v325 = v601[1];
              unint64_t v326 = LODWORD(v601[1]);
              if (LODWORD(v601[1]))
              {
                uint64_t v327 = 0;
                uint64_t v12 = a2;
                while (a2 != v327)
                {
                  *(void *)(v3 + 8 * v327) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v327);
                  if (v326 == ++v327) {
                    goto LABEL_652;
                  }
                }
                goto LABEL_1210;
              }
LABEL_652:
              BOOL v165 = v6 == 2;
              unint64_t v6 = v18;
              if (!v165 || a2 <= v325) {
                goto LABEL_751;
              }
              while (1)
              {
                LODWORD(v573[0]) = v326;
                if (v550 == 2)
                {
                  uint64_t v329 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v329 == -1) {
                    goto LABEL_665;
                  }
                  unsigned int v328 = *(_DWORD *)(v552 + 8 * v329 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1266;
                    }
                    if (v326 >= v551) {
                      unsigned int v328 = -1;
                    }
                    else {
                      unsigned int v328 = v326;
                    }
                    goto LABEL_666;
                  }
                  if ((unint64_t)v553 <= v326)
                  {
LABEL_665:
                    unsigned int v328 = -1;
                    goto LABEL_666;
                  }
                  unsigned int v328 = *(_DWORD *)(v554 + 4 * v326);
                }
LABEL_666:
                *(void *)(v3 + 8 * v326++) = *(void *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v328);
                if (a2 == v326) {
                  goto LABEL_751;
                }
              }
            case 7:
              int v542 = v76[16];
              if (v542 == 4)
              {
                uint64_t v141 = *(char **)(v12 + 56 * v4 + 48);
                if (v141 || (uint64_t v141 = *v37) != 0) {
                  uint64_t v142 = *((void *)v141 + 5);
                }
                else {
                  uint64_t v142 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v142);
              }
              unint64_t v11 = v12;
              unint64_t v143 = (unint64_t)*v37;
              if (*v37)
              {
                uint64_t v144 = (void *)(v143 + 8);
                id v145 = (id)(v143 + 8);
                if (*(unsigned char *)(v143 + 32) && (*(unsigned __int8 *)(v143 + 33) | 2) == 0xB)
                {
                  id v146 = v144;
                  unint64_t v18 = *(void *)(v143 + 48);
                  unint64_t v13 = *(void *)(v143 + 24) + *(void *)(v143 + 56);
                  unint64_t v537 = v143;
                  LODWORD(v143) = *(_DWORD *)(v143 + 40);
                  id v147 = v144;

                  unint64_t v531 = 0;
                  v533 = 0;
                  v535 = 0;
                }
                else
                {
                  _ZNK2re8internal11DataPayload22computeConvertedValuesIDv3_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv(v143, (uint64_t)v573);
                  if (LOBYTE(v573[0]))
                  {
                    v535 = v573[1];
                    unint64_t v143 = v574;
                    v573[1] = 0;
                    unint64_t v13 = *((void *)&v574 + 1);
                    unint64_t v18 = 16;
                    long long v574 = 0uLL;
                  }
                  else
                  {
                    unint64_t v13 = 0;
                    unint64_t v143 = 0;
                    v535 = 0;
                    unint64_t v18 = 0;
                  }
                  re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v573);
                  unint64_t v537 = 0;
                  unint64_t v531 = v13;
                  v533 = (re::internal::GeomAttributeManager *)v143;
                }
              }
              else
              {
                unint64_t v13 = 0;
                unint64_t v18 = 0;
                unint64_t v537 = 0;
                v533 = 0;
                v535 = 0;
                unint64_t v531 = 0;
              }
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v376 = *(void *)(v12 + 56 * v4 + 48);
              if (v542 != 3 && v376 != 0)
              {
                unint64_t v385 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v386 = (id)(v376 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v601);
                if (v573[0]) {

                }
                unsigned int v389 = v601[1];
                unint64_t v390 = LODWORD(v601[1]);
                if (LODWORD(v601[1]))
                {
                  unint64_t v6 = 0;
                  unint64_t v11 = a2;
                  do
                  {
                    uint64_t v391 = *(unsigned int *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v6);
                    if (v391 < v143)
                    {
                      if (v6 >= a2) {
                        goto LABEL_1234;
                      }
                      unint64_t v392 = v13 + v18 * v391;
                      *(void *)&long long v388 = *(void *)v392;
                      DWORD2(v388) = *(_DWORD *)(v392 + 8);
                      *(_OWORD *)(v3 + 16 * v6) = v388;
                    }
                    ++v6;
                  }
                  while (v390 != v6);
                }
                unint64_t v6 = v385;
                unint64_t v5 = v538;
                if (v542 == 2 && a2 > v389)
                {
                  do
                  {
                    LODWORD(v573[0]) = v390;
                    if (v550 == 2)
                    {
                      uint64_t v394 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                      if (v394 == -1) {
                        goto LABEL_867;
                      }
                      unsigned int v393 = *(_DWORD *)(v552 + 8 * v394 + 4);
                    }
                    else
                    {
                      if (v550 != 1)
                      {
                        if (v550) {
                          goto LABEL_1273;
                        }
                        if (v390 >= v551) {
                          unsigned int v393 = -1;
                        }
                        else {
                          unsigned int v393 = v390;
                        }
                        goto LABEL_868;
                      }
                      if ((unint64_t)v553 <= v390)
                      {
LABEL_867:
                        unsigned int v393 = -1;
                        goto LABEL_868;
                      }
                      unsigned int v393 = *(_DWORD *)(v554 + 4 * v390);
                    }
LABEL_868:
                    uint64_t v395 = *(unsigned int *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v393);
                    if (v395 < v143)
                    {
                      unint64_t v396 = v13 + v18 * v395;
                      *(void *)&long long v388 = *(void *)v396;
                      DWORD2(v388) = *(_DWORD *)(v396 + 8);
                      *(_OWORD *)(v3 + 16 * v390) = v388;
                    }
                    ++v390;
                  }
                  while (a2 != v390);
                }
                if (*(void *)&v601[2])
                {
                  if (*((void *)&v601[2] + 1))
                  {
                    (*(void (**)(void, void))(**(void **)&v601[2] + 40))(*(void *)&v601[2], *(void *)&v602[0]);
                    *((void *)&v601[2] + 1) = 0;
                    *(void *)&v602[0] = 0;
                  }
                  *(void *)&v601[2] = 0;
                }
                if (*((void *)&v601[1] + 1)) {

                }
LABEL_877:
                if (v535 && v533) {
                  (*(void (**)(char *, unint64_t))(*(void *)v535 + 40))(v535, v531);
                }
                a2 = v527;
                unint64_t v373 = v537;
                if (!v537) {
                  goto LABEL_103;
                }
                goto LABEL_813;
              }
              unint64_t v5 = v538;
              if (v143)
              {
                uint64_t v12 = a2;
                uint64_t v378 = v143;
                v379 = (_DWORD *)(v13 + 8);
                uint64_t v380 = a2;
                v381 = (_OWORD *)v3;
                while (v380)
                {
                  *(void *)&long long v375 = *((void *)v379 - 1);
                  DWORD2(v375) = *v379;
                  v379 = (_DWORD *)((char *)v379 + v18);
                  *v381++ = v375;
                  --v380;
                  if (!--v378) {
                    goto LABEL_831;
                  }
                }
                goto LABEL_1213;
              }
LABEL_831:
              if (v542 != 2 || a2 <= v143) {
                goto LABEL_877;
              }
              unint64_t v143 = v143;
              while (1)
              {
                LODWORD(v573[0]) = v143;
                if (v550 == 2)
                {
                  uint64_t v383 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v383 == -1) {
                    goto LABEL_844;
                  }
                  unsigned int v382 = *(_DWORD *)(v552 + 8 * v383 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1272;
                    }
                    if (v143 >= v551) {
                      unsigned int v382 = -1;
                    }
                    else {
                      unsigned int v382 = v143;
                    }
                    goto LABEL_845;
                  }
                  if ((unint64_t)v553 <= v143)
                  {
LABEL_844:
                    unsigned int v382 = -1;
                    goto LABEL_845;
                  }
                  unsigned int v382 = *(_DWORD *)(v554 + 4 * v143);
                }
LABEL_845:
                unint64_t v384 = v13 + v18 * v382;
                *(void *)&long long v375 = *(void *)v384;
                DWORD2(v375) = *(_DWORD *)(v384 + 8);
                *(_OWORD *)(v3 + 16 * v143++) = v375;
                if (a2 == v143) {
                  goto LABEL_877;
                }
              }
            case 8:
              unint64_t v18 = v6;
              unint64_t v6 = v76[16];
              if (v6 == 4)
              {
                id v156 = *(char **)(v12 + 56 * v4 + 48);
                if (v156 || (id v156 = *v37) != 0) {
                  uint64_t v157 = *((void *)v156 + 5);
                }
                else {
                  uint64_t v157 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v157);
              }
              _ZNK2re19GeomModelDescriptor13AttributeData19makeConvertedValuesIDv4_fEENS0_15ConvertedValuesIT_EEv(v13, (uint64_t)v601);
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              unint64_t v5 = v538;
              uint64_t v339 = *(void *)(v12 + 56 * v4 + 48);
              if (v6 != 3 && v339 != 0)
              {
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v346 = (id)(v339 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v348 = v601[1];
                unsigned int v349 = v607[1];
                unint64_t v350 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v13 = 0;
                  unint64_t v11 = a2;
                  do
                  {
                    uint64_t v351 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v13);
                    if (v351 < v348)
                    {
                      if (v13 >= a2) {
                        goto LABEL_1232;
                      }
                      *(_OWORD *)(v3 + 16 * v13) = *(_OWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v351);
                    }
                    ++v13;
                  }
                  while (v350 != v13);
                }
                BOOL v165 = v6 == 2;
                unint64_t v6 = v18;
                if (!v165 || a2 <= v349) {
                  goto LABEL_745;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v350;
                  if (v550 == 2)
                  {
                    uint64_t v353 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v353 == -1) {
                      goto LABEL_741;
                    }
                    unsigned int v352 = *(_DWORD *)(v552 + 8 * v353 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1269;
                      }
                      if (v350 >= v551) {
                        unsigned int v352 = -1;
                      }
                      else {
                        unsigned int v352 = v350;
                      }
                      goto LABEL_742;
                    }
                    if ((unint64_t)v553 <= v350)
                    {
LABEL_741:
                      unsigned int v352 = -1;
                      goto LABEL_742;
                    }
                    unsigned int v352 = *(_DWORD *)(v554 + 4 * v350);
                  }
LABEL_742:
                  uint64_t v354 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v352);
                  if (v354 < v348) {
                    *(_OWORD *)(v3 + 16 * v350) = *(_OWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v354);
                  }
                  if (a2 == ++v350) {
                    goto LABEL_745;
                  }
                }
              }
              unsigned int v341 = v601[1];
              unint64_t v342 = LODWORD(v601[1]);
              if (LODWORD(v601[1]))
              {
                uint64_t v343 = 0;
                uint64_t v12 = a2;
                while (a2 != v343)
                {
                  *(_OWORD *)(v3 + 16 * v343) = *(_OWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v343);
                  if (v342 == ++v343) {
                    goto LABEL_704;
                  }
                }
                goto LABEL_1211;
              }
LABEL_704:
              BOOL v165 = v6 == 2;
              unint64_t v6 = v18;
              if (!v165 || a2 <= v341)
              {
LABEL_751:
                uint64_t v355 = *(void *)&v601[2];
                a2 = v527;
                if (*(void *)&v601[2]) {
                  goto LABEL_809;
                }
                goto LABEL_812;
              }
              while (1)
              {
                LODWORD(v573[0]) = v342;
                if (v550 == 2)
                {
                  uint64_t v345 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v345 == -1) {
                    goto LABEL_717;
                  }
                  unsigned int v344 = *(_DWORD *)(v552 + 8 * v345 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1268;
                    }
                    if (v342 >= v551) {
                      unsigned int v344 = -1;
                    }
                    else {
                      unsigned int v344 = v342;
                    }
                    goto LABEL_718;
                  }
                  if ((unint64_t)v553 <= v342)
                  {
LABEL_717:
                    unsigned int v344 = -1;
                    goto LABEL_718;
                  }
                  unsigned int v344 = *(_DWORD *)(v554 + 4 * v342);
                }
LABEL_718:
                *(_OWORD *)(v3 + 16 * v342++) = *(_OWORD *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v344);
                if (a2 == v342) {
                  goto LABEL_751;
                }
              }
            case 9:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                uint64_t v148 = *(char **)(v12 + 56 * v4 + 48);
                if (v148 || (uint64_t v148 = *v37) != 0) {
                  uint64_t v149 = *((void *)v148 + 5);
                }
                else {
                  uint64_t v149 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v149);
              }
              uint64_t v150 = *v37;
              v573[0] = v150;
              if (v150) {
                uint64_t v151 = v150 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<unsigned char>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v306 = *(void *)(v12 + 56 * v4 + 48);
              if (v13 != 3 && v306 != 0)
              {
                unint64_t v313 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v314 = (id)(v306 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v316 = v601[1];
                unsigned int v317 = v607[1];
                unint64_t v318 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v6 = 0;
                  unint64_t v11 = a2;
                  do
                  {
                    uint64_t v319 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v6);
                    if (v319 < v316)
                    {
                      if (v6 >= a2) {
                        goto LABEL_1230;
                      }
                      *(unsigned char *)(v3 + v6) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v319);
                    }
                    ++v6;
                  }
                  while (v318 != v6);
                }
                unint64_t v6 = v313;
                unint64_t v5 = v538;
                if (v13 != 2 || a2 <= v317) {
                  goto LABEL_802;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v318;
                  if (v550 == 2)
                  {
                    uint64_t v321 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v321 == -1) {
                      goto LABEL_637;
                    }
                    unsigned int v320 = *(_DWORD *)(v552 + 8 * v321 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1265;
                      }
                      if (v318 >= v551) {
                        unsigned int v320 = -1;
                      }
                      else {
                        unsigned int v320 = v318;
                      }
                      goto LABEL_638;
                    }
                    if ((unint64_t)v553 <= v318)
                    {
LABEL_637:
                      unsigned int v320 = -1;
                      goto LABEL_638;
                    }
                    unsigned int v320 = *(_DWORD *)(v554 + 4 * v318);
                  }
LABEL_638:
                  uint64_t v322 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v320);
                  if (v322 < v316) {
                    *(unsigned char *)(v3 + v318) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v322);
                  }
                  if (a2 == ++v318) {
                    goto LABEL_802;
                  }
                }
              }
              unsigned int v308 = v601[1];
              unint64_t v309 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v310 = 0;
                uint64_t v12 = a2;
                while (a2 != v310)
                {
                  *(unsigned char *)(v3 + v310) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v310);
                  if (v309 == ++v310) {
                    goto LABEL_602;
                  }
                }
                goto LABEL_1209;
              }
LABEL_602:
              if (v13 != 2 || a2 <= v308) {
                goto LABEL_808;
              }
              while (1)
              {
                LODWORD(v573[0]) = v309;
                if (v550 == 2)
                {
                  uint64_t v312 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                  if (v312 == -1) {
                    goto LABEL_614;
                  }
                  unsigned int v311 = *(_DWORD *)(v552 + 8 * v312 + 4);
                }
                else
                {
                  if (v550 != 1)
                  {
                    if (v550) {
                      goto LABEL_1264;
                    }
                    if (v309 >= v551) {
                      unsigned int v311 = -1;
                    }
                    else {
                      unsigned int v311 = v309;
                    }
                    goto LABEL_615;
                  }
                  if ((unint64_t)v553 <= v309)
                  {
LABEL_614:
                    unsigned int v311 = -1;
                    goto LABEL_615;
                  }
                  unsigned int v311 = *(_DWORD *)(v554 + 4 * v309);
                }
LABEL_615:
                *(unsigned char *)(v3 + v309++) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v311);
                if (a2 == v309) {
                  goto LABEL_808;
                }
              }
            case 10:
              unint64_t v13 = v76[16];
              if (v13 == 4)
              {
                uint64_t v159 = *(char **)(v12 + 56 * v4 + 48);
                if (v159 || (uint64_t v159 = *v37) != 0) {
                  uint64_t v160 = *((void *)v159 + 5);
                }
                else {
                  uint64_t v160 = 0;
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v76 + 24))(v76, v160);
              }
              unsigned int v161 = *v37;
              v573[0] = v161;
              if (v161) {
                unsigned int v162 = v161 + 8;
              }
              re::GeomModelDescriptor::makeConvertedValues<signed char>((_anonymous_namespace_ **)v573, v601);
              if (v573[0]) {

              }
              unint64_t v18 = a2;
              if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76))
              {
                unint64_t v3 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v76, 0);
                a2 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v76 + 16))(v76);
              }
              else
              {
                a2 = 0;
                unint64_t v3 = 0;
              }
              uint64_t v356 = *(void *)(v12 + 56 * v4 + 48);
              if (v13 != 3 && v356 != 0)
              {
                unint64_t v363 = v6;
                v573[0] = *(char **)(v12 + 56 * v4 + 48);
                id v364 = (id)(v356 + 8);
                re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v607);
                if (v573[0]) {

                }
                unsigned int v366 = v601[1];
                unsigned int v367 = v607[1];
                unint64_t v368 = LODWORD(v607[1]);
                if (LODWORD(v607[1]))
                {
                  unint64_t v6 = 0;
                  unint64_t v11 = a2;
                  do
                  {
                    uint64_t v369 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v6);
                    if (v369 < v366)
                    {
                      if (v6 >= a2) {
                        goto LABEL_1233;
                      }
                      *(unsigned char *)(v3 + v6) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v369);
                    }
                    ++v6;
                  }
                  while (v368 != v6);
                }
                unint64_t v6 = v363;
                unint64_t v5 = v538;
                if (v13 != 2 || a2 <= v367) {
                  goto LABEL_802;
                }
                while (1)
                {
                  LODWORD(v573[0]) = v368;
                  if (v550 == 2)
                  {
                    uint64_t v371 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
                    if (v371 == -1) {
                      goto LABEL_798;
                    }
                    unsigned int v370 = *(_DWORD *)(v552 + 8 * v371 + 4);
                  }
                  else
                  {
                    if (v550 != 1)
                    {
                      if (v550) {
                        goto LABEL_1271;
                      }
                      if (v368 >= v551) {
                        unsigned int v370 = -1;
                      }
                      else {
                        unsigned int v370 = v368;
                      }
                      goto LABEL_799;
                    }
                    if ((unint64_t)v553 <= v368)
                    {
LABEL_798:
                      unsigned int v370 = -1;
                      goto LABEL_799;
                    }
                    unsigned int v370 = *(_DWORD *)(v554 + 4 * v368);
                  }
LABEL_799:
                  uint64_t v372 = *(unsigned int *)(*(void *)&v607[0] + *((void *)&v607[0] + 1) * v370);
                  if (v372 < v366) {
                    *(unsigned char *)(v3 + v368) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v372);
                  }
                  if (a2 == ++v368) {
                    goto LABEL_802;
                  }
                }
              }
              unsigned int v358 = v601[1];
              unint64_t v359 = LODWORD(v601[1]);
              unint64_t v5 = v538;
              if (LODWORD(v601[1]))
              {
                uint64_t v360 = 0;
                uint64_t v12 = a2;
                while (a2 != v360)
                {
                  *(unsigned char *)(v3 + v360) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v360);
                  if (v359 == ++v360) {
                    goto LABEL_763;
                  }
                }
                goto LABEL_1212;
              }
LABEL_763:
              if (v13 != 2 || a2 <= v358) {
                goto LABEL_808;
              }
              break;
            default:
              unint64_t v119 = "Unexpected attribute type.";
              goto LABEL_193;
          }
          while (1)
          {
            LODWORD(v573[0]) = v359;
            if (v550 == 2)
            {
              uint64_t v362 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v551, (unsigned int *)v573);
              if (v362 == -1) {
                goto LABEL_775;
              }
              unsigned int v361 = *(_DWORD *)(v552 + 8 * v362 + 4);
            }
            else
            {
              if (v550 != 1)
              {
                if (v550) {
                  goto LABEL_1270;
                }
                if (v359 >= v551) {
                  unsigned int v361 = -1;
                }
                else {
                  unsigned int v361 = v359;
                }
                goto LABEL_776;
              }
              if ((unint64_t)v553 <= v359)
              {
LABEL_775:
                unsigned int v361 = -1;
                goto LABEL_776;
              }
              unsigned int v361 = *(_DWORD *)(v554 + 4 * v359);
            }
LABEL_776:
            *(unsigned char *)(v3 + v359++) = *(unsigned char *)(*(void *)&v601[0] + *((void *)&v601[0] + 1) * v361);
            if (a2 == v359) {
              goto LABEL_808;
            }
          }
        }
        v525 = v37;
        unint64_t v11 = *(void *)(v36 + 40);
        int v45 = v560;
        v541 = (re::internal::GeomAttributeManager *)v560;
        *(void *)&v605[2] = 0;
        memset(v605, 0, 28);
        uint64_t v46 = (uint64_t)re::DynamicArray<re::GeomCell4>::resize(v605, v547);
        uint64_t v526 = v12;
        uint64_t v47 = *(void *)(v12 + 56 * v4 + 48);
        if (!*((void *)&v557[0] + 1))
        {
          if (!v47)
          {
            if (!v45) {
              goto LABEL_178;
            }
            unint64_t v108 = v11;
            unint64_t v11 = 0;
            unsigned int v109 = 0;
            unsigned int v110 = v558;
            uint64_t v111 = v559;
            unint64_t v3 = *(void *)&v605[1];
            uint64_t v112 = *(void *)&v605[2];
            while (1)
            {
              unsigned int v113 = *v110;
              if (*v110 == 3)
              {
                if (v3 <= v11) {
                  goto LABEL_1201;
                }
                int v114 = -1;
              }
              else
              {
                if (v3 <= v11) {
                  goto LABEL_1202;
                }
                int v114 = v109 + 3;
              }
              unsigned int v110 = (unsigned int *)((char *)v110 + v111);
              *(_DWORD *)uint64_t v112 = v109;
              *(int32x2_t *)(v112 + 4) = vadd_s32(vdup_n_s32(v109), (int32x2_t)0x200000001);
              *(_DWORD *)(v112 + 12) = v114;
              v109 += v113;
              ++v11;
              v112 += 16;
              if (v541 == (re::internal::GeomAttributeManager *)v11)
              {
                if (v108 >= v109) {
                  goto LABEL_178;
                }
                goto LABEL_177;
              }
            }
          }
          v573[0] = *(char **)(v12 + 56 * v4 + 48);
          id v82 = (id)(v47 + 8);
          re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v601);
          if (v573[0]) {

          }
          uint64_t v83 = *(void *)&v601[1];
          if (*(void *)&v601[1])
          {
            int v84 = *(unsigned int **)&v601[0];
            while (v11 > *v84)
            {
              int v84 = (unsigned int *)((char *)v84 + *((void *)&v601[0] + 1));
              if (!--v83) {
                goto LABEL_128;
              }
            }
LABEL_162:
            LOBYTE(v607[0]) = 0;
            *((void *)&v607[0] + 1) = 100;
            *(void *)&v607[1] = re::AssetErrorCategory(void)::instance;
            *(_OWORD *)((char *)&v607[1] + 8) = *(_OWORD *)v573;
            *(_OWORD *)((char *)&v607[2] + 8) = v574;
            int v37 = v525;
            if (*(void *)&v601[2])
            {
              if (*((void *)&v601[2] + 1))
              {
                (*(void (**)(void, void))(**(void **)&v601[2] + 40))(*(void *)&v601[2], *(void *)&v602[0]);
                *((void *)&v601[2] + 1) = 0;
                *(void *)&v602[0] = 0;
              }
              *(void *)&v601[2] = 0;
            }
            if (*((void *)&v601[1] + 1)) {

            }
            goto LABEL_180;
          }
LABEL_128:
          if (v45)
          {
            unint64_t v11 = 0;
            unsigned int v85 = 0;
            uint64_t v86 = v558;
            uint64_t v87 = v559;
            unint64_t v3 = *(void *)&v605[1];
            unint64_t v88 = *(_DWORD **)&v605[2];
            long long v89 = v601[0];
            do
            {
              unsigned int v90 = *v86;
              if (*v86 == 3)
              {
                if (v3 <= v11) {
                  goto LABEL_1199;
                }
                int v91 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * (v85 + 1));
                int v92 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * (v85 + 2));
                *unint64_t v88 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * v85);
                int v93 = -1;
              }
              else
              {
                if (v3 <= v11) {
                  goto LABEL_1200;
                }
                int v91 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * (v85 + 1));
                int v92 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * (v85 + 2));
                int v93 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * (v85 + 3));
                *unint64_t v88 = *(_DWORD *)(v89 + *((void *)&v89 + 1) * v85);
              }
              uint64_t v86 = (unsigned int *)((char *)v86 + v87);
              v88[1] = v91;
              v88[2] = v92;
              v88[3] = v93;
              v85 += v90;
              ++v11;
              v88 += 4;
            }
            while (v541 != (re::internal::GeomAttributeManager *)v11);
          }
          uint64_t v70 = *(void *)&v601[2];
          if (!*(void *)&v601[2])
          {
LABEL_140:
            if (*((void *)&v601[1] + 1)) {

            }
LABEL_178:
            uint64_t v115 = *(void *)&v605[2];
            *(void *)&v605[2] = 0;
            ++DWORD2(v605[1]);
            LOBYTE(v607[0]) = 1;
            *((void *)&v607[0] + 1) = *(void *)&v605[0];
            long long v116 = *(_OWORD *)((char *)v605 + 8);
            memset(v605, 0, 24);
            v607[1] = v116;
            *((void *)&v607[2] + 1) = v115;
            LODWORD(v607[2]) = 1;
            goto LABEL_179;
          }
LABEL_137:
          if (*((void *)&v601[2] + 1))
          {
            (*(void (**)(uint64_t, void))(*(void *)v70 + 40))(v70, *(void *)&v602[0]);
            *((void *)&v601[2] + 1) = 0;
            *(void *)&v602[0] = 0;
          }
          *(void *)&v601[2] = 0;
          goto LABEL_140;
        }
        if (v47)
        {
          v573[0] = *(char **)(v12 + 56 * v4 + 48);
          id v48 = (id)(v47 + 8);
          re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v573, v601);
          if (v573[0]) {

          }
          uint64_t v50 = *(void *)&v601[1];
          if (*(void *)&v601[1])
          {
            unint64_t v51 = *(unsigned int **)&v601[0];
            while (v11 > *v51)
            {
              unint64_t v51 = (unsigned int *)((char *)v51 + *((void *)&v601[0] + 1));
              if (!--v50) {
                goto LABEL_73;
              }
            }
            goto LABEL_162;
          }
LABEL_73:
          unint64_t v515 = v6;
          if (v45)
          {
            unint64_t v3 = 0;
            unint64_t v6 = 0;
            uint64_t v530 = v559;
            v532 = (re::internal::GeomAttributeManager *)v558;
            unint64_t v534 = *((void *)&v556 + 1);
            unint64_t v5 = *(void *)&v605[1];
            uint64_t v519 = *(void *)&v601[0];
            uint64_t v521 = *(void *)&v605[2];
            uint64_t v517 = *((void *)&v601[0] + 1);
            do
            {
              a2 = *(unsigned int *)((char *)v532 + v530 * v3);
              uint64_t v52 = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v556, v3);
              if (v52 == -1)
              {
                if (a2 == 3)
                {
                  if (v5 <= v3) {
                    goto LABEL_1215;
                  }
                  int v65 = *(_DWORD *)(v519 + v517 * (v6 + 1));
                  int v66 = *(_DWORD *)(v519 + v517 * (v6 + 2));
                  *(_DWORD *)(v521 + 16 * v3) = *(_DWORD *)(v519 + v517 * v6);
                  uint64_t v67 = v521;
                  int v68 = -1;
                }
                else
                {
                  if (v5 <= v3) {
                    goto LABEL_1216;
                  }
                  int v65 = *(_DWORD *)(v519 + v517 * (v6 + 1));
                  int v66 = *(_DWORD *)(v519 + v517 * (v6 + 2));
                  int v68 = *(_DWORD *)(v519 + v517 * (v6 + 3));
                  *(_DWORD *)(v521 + 16 * v3) = *(_DWORD *)(v519 + v517 * v6);
                  uint64_t v67 = v521;
                }
                int v69 = (_DWORD *)(v67 + 16 * v3);
                v69[1] = v65;
                v69[2] = v66;
                v69[3] = v68;
              }
              else
              {
                uint64_t v53 = *(void *)(v534 + 96 * v52 + 40);
                if (v53)
                {
                  unint64_t v18 = 0;
                  long long v54 = (void *)(v534 + 96 * v52);
                  long long v55 = (unsigned int *)v54[6];
                  uint64_t v56 = *(void *)&v605[2];
                  long long v57 = v54 + 9;
                  long long v58 = v54 + 11;
                  long long v59 = v601[0];
                  while (1)
                  {
                    unsigned int v61 = *v55++;
                    uint64_t v60 = v61;
                    if (v5 <= v61) {
                      break;
                    }
                    unint64_t v11 = *v57;
                    if (*v57 <= v18) {
                      goto LABEL_1155;
                    }
                    uint64_t v12 = v18 + 1;
                    if (v11 <= v18 + 1) {
                      goto LABEL_1156;
                    }
                    uint64_t v12 = v18 + 2;
                    if (v11 <= v18 + 2) {
                      goto LABEL_1157;
                    }
                    uint64_t v62 = *v58 + 4 * v18;
                    int v63 = *(_DWORD *)(v59 + *((void *)&v59 + 1) * (*(_DWORD *)(v62 + 4) + v6));
                    LODWORD(v62) = *(_DWORD *)(v59 + *((void *)&v59 + 1) * (*(_DWORD *)(v62 + 8) + v6));
                    uint64_t v64 = (_DWORD *)(v56 + 16 * v60);
                    *uint64_t v64 = *(_DWORD *)(v59 + *((void *)&v59 + 1) * (*(_DWORD *)(*v58 + 4 * v18) + v6));
                    v64[1] = v63;
                    v64[2] = v62;
                    v64[3] = -1;
                    v18 += 3;
                    if (!--v53) {
                      goto LABEL_90;
                    }
                  }
                  v570 = 0;
                  long long v577 = 0u;
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  uint64_t v12 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v609 = 136315906;
                  *(void *)&v609[4] = "operator[]";
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = 789;
                  *(_WORD *)&v609[18] = 2048;
                  *(void *)&v609[20] = v60;
                  *(_WORD *)&v609[28] = 2048;
                  *(void *)&v609[30] = v5;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_1155:
                  v570 = 0;
                  long long v577 = 0u;
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v609 = 136315906;
                  *(void *)&v609[4] = "operator[]";
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = 797;
                  *(_WORD *)&v609[18] = 2048;
                  *(void *)&v609[20] = v18;
                  *(_WORD *)&v609[28] = 2048;
                  *(void *)&v609[30] = v11;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_1156:
                  v570 = 0;
                  long long v577 = 0u;
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v609 = 136315906;
                  *(void *)&v609[4] = "operator[]";
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = 797;
                  *(_WORD *)&v609[18] = 2048;
                  *(void *)&v609[20] = v12;
                  *(_WORD *)&v609[28] = 2048;
                  *(void *)&v609[30] = v11;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_1157:
                  v570 = 0;
                  long long v577 = 0u;
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  uint64_t v102 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v609 = 136315906;
                  *(void *)&v609[4] = "operator[]";
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = 797;
                  *(_WORD *)&v609[18] = 2048;
                  *(void *)&v609[20] = v12;
                  *(_WORD *)&v609[28] = 2048;
                  *(void *)&v609[30] = v11;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_1158:
                  *(void *)v609 = 0;
                  long long v577 = 0u;
                  long long v576 = 0u;
                  long long v575 = 0u;
                  long long v574 = 0u;
                  *(_OWORD *)v573 = 0u;
                  uint64_t v12 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  LODWORD(v601[0]) = 136315906;
                  *(void *)((char *)v601 + 4) = "operator[]";
                  WORD6(v601[0]) = 1024;
                  *(_DWORD *)((char *)v601 + 14) = 789;
                  WORD1(v601[1]) = 2048;
                  *(void *)((char *)&v601[1] + 4) = v102;
                  WORD6(v601[1]) = 2048;
                  *(void *)((char *)&v601[1] + 14) = v6;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_1159;
                }
              }
LABEL_90:
              unint64_t v6 = (a2 + v6);
              ++v3;
            }
            while ((re::internal::GeomAttributeManager *)v3 != v541);
          }
          uint64_t v70 = *(void *)&v601[2];
          a2 = v527;
          unint64_t v6 = v515;
          unint64_t v5 = v538;
          if (!*(void *)&v601[2]) {
            goto LABEL_140;
          }
          goto LABEL_137;
        }
        if (!v45) {
          goto LABEL_178;
        }
        unint64_t v520 = v11;
        unint64_t v516 = v6;
        unint64_t v3 = 0;
        unint64_t v11 = 0;
        uint64_t v530 = v559;
        v532 = (re::internal::GeomAttributeManager *)v558;
        unint64_t v534 = *((void *)&v556 + 1);
        unint64_t v6 = *(void *)&v605[1];
        uint64_t v522 = *(void *)&v605[2];
LABEL_144:
        a2 = *(unsigned int *)((char *)v532 + v530 * v3);
        uint64_t v46 = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v556, v3);
        if (v46 != -1)
        {
          uint64_t v94 = *(void *)(v534 + 96 * v46 + 40);
          if (!v94) {
            goto LABEL_159;
          }
          unint64_t v5 = 0;
          int v95 = (void *)(v534 + 96 * v46);
          int v96 = (unsigned int *)v95[6];
          uint64_t v97 = *(void *)&v605[2];
          uint64_t v98 = v95 + 9;
          int v99 = v95 + 11;
          int32x2_t v100 = vdup_n_s32(v11);
          uint64_t v101 = 4;
          while (1)
          {
            unsigned int v103 = *v96++;
            uint64_t v102 = v103;
            if (v6 <= v103) {
              goto LABEL_1158;
            }
            unint64_t v18 = *v98;
            if (*v98 <= v5) {
              break;
            }
            uint64_t v12 = v5 + 1;
            if (v18 <= v5 + 1) {
              goto LABEL_1160;
            }
            uint64_t v12 = v5 + 2;
            if (v18 <= v5 + 2) {
              goto LABEL_1161;
            }
            uint64_t v104 = v97 + 16 * v102;
            int32x2_t v105 = *(int32x2_t *)(*v99 + v101);
            *(_DWORD *)uint64_t v104 = *(_DWORD *)(*v99 + 4 * v5) + v11;
            *(int32x2_t *)(v104 + 4) = vadd_s32(v105, v100);
            *(_DWORD *)(v104 + 12) = -1;
            v5 += 3;
            v101 += 12;
            if (!--v94) {
              goto LABEL_159;
            }
          }
LABEL_1159:
          *(void *)v609 = 0;
          long long v577 = 0u;
          long long v576 = 0u;
          long long v575 = 0u;
          long long v574 = 0u;
          *(_OWORD *)v573 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v601[0]) = 136315906;
          *(void *)((char *)v601 + 4) = "operator[]";
          WORD6(v601[0]) = 1024;
          *(_DWORD *)((char *)v601 + 14) = 797;
          WORD1(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 4) = v5;
          WORD6(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 14) = v18;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_1160:
          *(void *)v609 = 0;
          long long v577 = 0u;
          long long v576 = 0u;
          long long v575 = 0u;
          long long v574 = 0u;
          *(_OWORD *)v573 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v601[0]) = 136315906;
          *(void *)((char *)v601 + 4) = "operator[]";
          WORD6(v601[0]) = 1024;
          *(_DWORD *)((char *)v601 + 14) = 797;
          WORD1(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 4) = v12;
          WORD6(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 14) = v18;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_1161:
          *(void *)v609 = 0;
          long long v577 = 0u;
          long long v576 = 0u;
          long long v575 = 0u;
          long long v574 = 0u;
          *(_OWORD *)v573 = 0u;
          unint64_t v30 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v601[0]) = 136315906;
          *(void *)((char *)v601 + 4) = "operator[]";
          WORD6(v601[0]) = 1024;
          *(_DWORD *)((char *)v601 + 14) = 797;
          WORD1(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 4) = v12;
          WORD6(v601[1]) = 2048;
          *(void *)((char *)&v601[1] + 14) = v18;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_1162:
          uint64_t v503 = *((void *)&v602[1] + 1);
          if (*((void *)&v602[1] + 1))
          {
            if (*((void *)&v601[1] + 1)) {
              *((void *)&v601[1] + 1) = 0;
            }
            if (*(void *)&v601[1]) {
LABEL_1166:
            }
              (*(void (**)(uint64_t))(*(void *)v503 + 40))(v503);
          }
LABEL_1167:
          re::GeomMesh::operator=((uint64_t)&v544, v525);
          re::GeomMesh::setName((re *)&v544, v573[0]);
          re::GeomMesh::freeName((re *)v573);
          v506 = (_OWORD *)re::GeomMesh::modifyVertexPositions((re::GeomMesh *)&v544);
          if (v13)
          {
            uint64_t v509 = v13;
            unint64_t v11 = v507;
            v510 = (_DWORD *)(v526 + 8);
            uint64_t v511 = v507;
            while (v511)
            {
              *(void *)&long long v508 = *((void *)v510 - 1);
              DWORD2(v508) = *v510;
              v510 = (_DWORD *)((char *)v510 + v529);
              *v506++ = v508;
              --v511;
              if (!--v509) {
                goto LABEL_1171;
              }
            }
LABEL_1198:
            *(void *)v609 = 0;
            memset(v602, 0, sizeof(v602));
            memset(v601, 0, sizeof(v601));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v11;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1199:
            v570 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v11;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1200:
            v570 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v11;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1201:
            *(void *)v609 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v601[0]) = 136315906;
            *(void *)((char *)v601 + 4) = "operator[]";
            WORD6(v601[0]) = 1024;
            *(_DWORD *)((char *)v601 + 14) = 789;
            WORD1(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 4) = v11;
            WORD6(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 14) = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1202:
            *(void *)v609 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v601[0]) = 136315906;
            *(void *)((char *)v601 + 4) = "operator[]";
            WORD6(v601[0]) = 1024;
            *(_DWORD *)((char *)v601 + 14) = 789;
            WORD1(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 4) = v11;
            WORD6(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 14) = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1203:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1204:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1205:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1206:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1207:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1208:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1209:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1210:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1211:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1212:
            *(void *)&v605[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 609;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v12;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1213:
            *(void *)&v607[0] = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v601[0]) = 136315906;
            *(void *)((char *)v601 + 4) = "operator[]";
            WORD6(v601[0]) = 1024;
            *(_DWORD *)((char *)v601 + 14) = 609;
            WORD1(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 4) = v12;
            WORD6(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1214:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 468;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = v3;
            __int16 v599 = 2048;
            uint64_t v600 = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1215:
            v570 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v3;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v5;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1216:
            v570 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v3;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v5;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1217:
            *(void *)v609 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v601[0]) = 136315906;
            *(void *)((char *)v601 + 4) = "operator[]";
            WORD6(v601[0]) = 1024;
            *(_DWORD *)((char *)v601 + 14) = 789;
            WORD1(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 4) = v3;
            WORD6(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 14) = v6;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1218:
            *(void *)v609 = 0;
            long long v577 = 0u;
            long long v576 = 0u;
            long long v575 = 0u;
            long long v574 = 0u;
            *(_OWORD *)v573 = 0u;
            unint64_t v490 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v601[0]) = 136315906;
            *(void *)((char *)v601 + 4) = "operator[]";
            WORD6(v601[0]) = 1024;
            *(_DWORD *)((char *)v601 + 14) = 789;
            WORD1(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 4) = v3;
            WORD6(v601[1]) = 2048;
            *(void *)((char *)&v601[1] + 14) = v6;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1219:
            uint64_t v569 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v598 = 136315906;
            *(void *)&v598[4] = "operator[]";
            *(_WORD *)&v598[12] = 1024;
            *(_DWORD *)&v598[14] = 468;
            *(_WORD *)&v598[18] = 2048;
            *(void *)&v598[20] = v490;
            __int16 v599 = 2048;
            uint64_t v600 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_1220;
          }
LABEL_1171:
          *(void *)&long long v548 = __PAIR64__(v5, v540);
          unint64_t v512 = *(void *)(v6 + 192);
          unint64_t v513 = v512 >> 1;
          if ((v512 & 1) == 0) {
            unint64_t v513 = v512 >> 1;
          }
          if (v513)
          {
            if (v512) {
              v514 = *(const char **)(v6 + 200);
            }
            else {
              v514 = (const char *)(v6 + 193);
            }
            re::GeomMesh::setName((re *)&v544, v514);
          }
          unint64_t v13 = 1;
LABEL_1179:
          unint64_t v11 = (unint64_t)&v544;
LABEL_1180:
          re::GeomMesh::freeName((re *)v573);
          re::internal::GeomAttributeManager::~GeomAttributeManager(v532);
          if ((void)v574 && (void)v576) {
            (*(void (**)(void, void))(*(void *)v574 + 40))(v574, v576);
          }
          if (v536 && v530) {
            (*(void (**)(uint64_t, char *))(*(void *)v536 + 40))(v536, v524);
          }
          if (v534) {

          }
          continue;
        }
        if (a2 == 3)
        {
          if (v6 <= v3) {
            goto LABEL_1217;
          }
          int v106 = -1;
        }
        else
        {
          if (v6 <= v3) {
            goto LABEL_1218;
          }
          int v106 = v11 + 3;
        }
        uint64_t v107 = v522 + 16 * v3;
        *(_DWORD *)uint64_t v107 = v11;
        *(int32x2_t *)(v107 + 4) = vadd_s32(vdup_n_s32(v11), (int32x2_t)0x200000001);
        *(_DWORD *)(v107 + 12) = v106;
LABEL_159:
        unint64_t v11 = (a2 + v11);
        ++v3;
        unint64_t v5 = v538;
        if ((re::internal::GeomAttributeManager *)v3 != v541) {
          goto LABEL_144;
        }
        a2 = v527;
        unint64_t v6 = v516;
        if (v520 >= v11) {
          goto LABEL_178;
        }
LABEL_177:
        LOBYTE(v607[0]) = 0;
        *((void *)&v607[0] + 1) = 100;
        *(void *)&v607[1] = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)((char *)&v607[1] + 8) = *(_OWORD *)v573;
        *(_OWORD *)((char *)&v607[2] + 8) = v574;
LABEL_179:
        int v37 = v525;
        uint64_t v12 = v526;
LABEL_180:
        if (*(void *)&v605[0] && *(void *)&v605[2]) {
          (*(void (**)(void, void))(**(void **)&v605[0] + 40))(*(void *)&v605[0], *(void *)&v605[2]);
        }
        if (!LOBYTE(v607[0]))
        {
          uint64_t v73 = (char *)*((void *)&v607[1] + 1);
          unint64_t v3 = *(void *)&v607[2];
          memset((char *)&v607[1] + 8, 0, 32);
          uint64_t v72 = *((void *)&v607[2] + 1);
          re::Result<re::DynamicArray<re::GeomCell4>,re::DetailedError>::~Result(v607);
          goto LABEL_100;
        }
        if (*(unsigned char *)(v13 + 8)) {
          int v117 = *(const char **)(v13 + 16);
        }
        else {
          int v117 = (const char *)(v13 + 9);
        }
        if (*v37) {
          int v118 = *((_DWORD *)*v37 + 10);
        }
        else {
          int v118 = 0;
        }
        long long v76 = (unsigned __int8 *)re::GeomMesh::addFaceVaryingAttribute((uint64_t)&v544, v117, v536, v118, (uint64_t *)v607 + 1);
        unint64_t v75 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::GeomCell4>,re::DetailedError>::~Result(v607);
        if (v76) {
          goto LABEL_109;
        }
LABEL_192:
        unint64_t v119 = "Error adding attribute.";
LABEL_193:
        uint64_t v72 = v574;
        uint64_t v73 = v573[0];
        unint64_t v3 = (unint64_t)v573[1];
        unint64_t v5 = v538;
LABEL_100:
        if (v73 && (v3 & 1) != 0) {
          (*(void (**)(char *, uint64_t))(*(void *)v73 + 40))(v73, v72);
        }
LABEL_103:
        if (++v4 != v5) {
          goto LABEL_48;
        }
LABEL_893:
        if (*(unsigned char *)v6 == 1)
        {
          v397 = re::GeomMesh::addAttribute((uint64_t)&v544, "osdSubdivisionScheme", 0, 1);
          if (v397) {
            *(_WORD *)re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v397, 0) = 1;
          }
        }
        if (*(unsigned char *)(v6 + 1) != 1) {
          goto LABEL_966;
        }
        re::GeomMeshBuilder::GeomMeshBuilder((re *)v573, (uint64_t)&v544);
        uint64_t v398 = v575;
        if ((void)v575)
        {
          uint64_t v399 = 0;
          uint64_t v400 = v576;
          v401 = (_DWORD *)v576;
          do
          {
            int v402 = v401[3];
            if (v402 == -1)
            {
              int v404 = *v401;
              int v405 = -1;
              v403 = v401;
            }
            else
            {
              v403 = (_DWORD *)(v400 + 16 * v399 + 4);
              int v405 = *v401;
              int v404 = v401[1];
              _DWORD *v401 = v402;
            }
            _DWORD *v403 = v401[2];
            v401[2] = v404;
            v401[3] = v405;
            ++v399;
            v401 += 4;
            --v398;
          }
          while (v398);
        }
        unsigned int v406 = v585;
        if (v585)
        {
          for (unsigned int i = 0; i != v406; ++i)
          {
            v408 = (char **)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)v584, i);
            uint64_t v410 = re::internal::accessFaceVaryingAttributeSubmesh((re::internal *)v408, v409);
            *(_DWORD *)v609 = *(_DWORD *)v410;
            re::DynamicArray<re::GeomCell4>::DynamicArray((uint64_t)&v609[8], (uint64_t *)(v410 + 8));
            if (!*(void *)&v609[16]) {
              re::DynamicArray<re::BlendNode>::setCapacity(&v609[8], 1uLL);
            }
            *(void *)&v607[0] = *(void *)(v410 + 128);
            DWORD2(v607[0]) = *(_DWORD *)(v410 + 136);
            BYTE12(v607[0]) = *(unsigned char *)(v410 + 140);
            if (BYTE12(v607[0]) == 2)
            {
              re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v607[1], (uint64_t *)(v410 + 144));
            }
            else if (BYTE12(v607[0]) == 1)
            {
              re::DynamicArray<float>::DynamicArray((uint64_t)&v607[1], (uint64_t *)(v410 + 144));
            }
            else
            {
              if (BYTE12(v607[0]))
              {
                re::internal::assertLog((re::internal *)4, v411, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
                _os_crash();
                __break(1u);
LABEL_1247:
                re::internal::assertLog((re::internal *)4, v411, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
                _os_crash();
                __break(1u);
LABEL_1248:
                re::internal::assertLog((re::internal *)4, v422, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
                _os_crash();
                __break(1u);
LABEL_1249:
                re::internal::assertLog((re::internal *)4, v422, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
                _os_crash();
                __break(1u);
                goto LABEL_1250;
              }
              LODWORD(v607[1]) = *(_DWORD *)(v410 + 144);
            }
            *(void *)&v605[0] = *(void *)(v410 + 48);
            DWORD2(v605[0]) = *(_DWORD *)(v410 + 56);
            BYTE12(v605[0]) = *(unsigned char *)(v410 + 60);
            if (BYTE12(v605[0]) == 2)
            {
              re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v605[1], (uint64_t *)(v410 + 64));
            }
            else if (BYTE12(v605[0]) == 1)
            {
              re::DynamicArray<float>::DynamicArray((uint64_t)&v605[1], (uint64_t *)(v410 + 64));
            }
            else
            {
              if (BYTE12(v605[0])) {
                goto LABEL_1247;
              }
              LODWORD(v605[1]) = *(_DWORD *)(v410 + 64);
            }
            uint64_t v412 = *(void *)&v609[24];
            if (*(void *)&v609[24])
            {
              uint64_t v413 = 0;
              v414 = v610;
              v415 = v610;
              uint64_t v416 = *(void *)&v609[24];
              do
              {
                int v417 = v415[3];
                if (v417 == -1)
                {
                  int v419 = *v415;
                  int v420 = -1;
                  v418 = v415;
                }
                else
                {
                  v418 = &v414[4 * v413 + 1];
                  int v420 = *v415;
                  int v419 = v415[1];
                  _DWORD *v415 = v417;
                }
                _DWORD *v418 = v415[2];
                v415[2] = v419;
                v415[3] = v420;
                ++v413;
                v415 += 4;
                --v416;
              }
              while (v416);
            }
            LODWORD(v601[0]) = *(_DWORD *)v609;
            *((void *)&v601[0] + 1) = *(void *)&v609[8];
            *(void *)&v601[1] = *(void *)&v609[16];
            *((void *)&v601[1] + 1) = v412;
            *((void *)&v601[2] + 1) = v610;
            v610 = 0;
            LODWORD(v601[2]) = 1;
            *(_DWORD *)v609 = 0;
            memset(&v609[8], 0, 24);
            *(_DWORD *)&v609[32] += 2;
            re::GeomIndexMap::GeomIndexMap((uint64_t)v602, (uint64_t)v607);
            re::GeomIndexMap::GeomIndexMap((uint64_t)&v604, (uint64_t)v605);
            re::internal::GeomAttributeManager::updateFaceVaryingAttributeSubmesh((void *)&v576 + 1, v408[1], (uint64_t)v601);
            re::internal::GeomAttributeFaceVaryingSubmesh::~GeomAttributeFaceVaryingSubmesh((re::internal::GeomAttributeFaceVaryingSubmesh *)v601, v421);
            if (BYTE12(v605[0]))
            {
              if (BYTE12(v605[0]) == 2)
              {
                uint64_t v423 = v606;
                if (v606)
                {
                  if (*((void *)&v605[1] + 1)) {
                    *((void *)&v605[1] + 1) = 0;
                  }
                  uint64_t v422 = *(void *)&v605[1];
                  if (*(void *)&v605[1]) {
                    goto LABEL_935;
                  }
                }
              }
              else
              {
                if (BYTE12(v605[0]) != 1) {
                  goto LABEL_1248;
                }
                uint64_t v423 = *(void *)&v605[1];
                if (*(void *)&v605[1])
                {
                  uint64_t v422 = *(void *)&v605[3];
                  if (*(void *)&v605[3]) {
LABEL_935:
                  }
                    (*(void (**)(uint64_t))(*(void *)v423 + 40))(v423);
                }
              }
            }
            if (BYTE12(v607[0]))
            {
              if (BYTE12(v607[0]) == 2)
              {
                if (!*((void *)&v608 + 1)) {
                  goto LABEL_948;
                }
                if (*((void *)&v607[1] + 1)) {
                  *((void *)&v607[1] + 1) = 0;
                }
                if (!*(void *)&v607[1]) {
                  goto LABEL_948;
                }
                (*(void (**)(void, void))(**((void **)&v608 + 1) + 40))(*((void *)&v608 + 1), *(void *)&v607[1]);
                v424 = &v607[1];
              }
              else
              {
                if (BYTE12(v607[0]) != 1) {
                  goto LABEL_1249;
                }
                if (!*(void *)&v607[1]) {
                  goto LABEL_948;
                }
                v424 = &v607[3];
                if (*(void *)&v607[3])
                {
                  (*(void (**)(void, void))(**(void **)&v607[1] + 40))(*(void *)&v607[1], *(void *)&v607[3]);
                  v424 = &v607[3];
                }
              }
              *(void *)v424 = 0;
            }
LABEL_948:
            if (*(void *)&v609[8] && v610) {
              (*(void (**)(void, _DWORD *))(**(void **)&v609[8] + 40))(*(void *)&v609[8], v610);
            }
          }
        }
        re::GeomMesh::operator=((uint64_t)&v544, &v573[1]);
        re::GeomMesh::setName((re *)&v544, v573[0]);
        re::GeomMesh::freeName((re *)v573);
        long long v425 = 0uLL;
        memset(v605, 0, sizeof(v605));
        v570 = &v556;
        unint64_t v571 = 0;
        uint64_t v426 = *(void *)&v557[0];
        if (*(void *)&v557[0] < 0x10uLL)
        {
          uint64_t v427 = 0;
          uint64_t v428 = 0;
          long long v429 = 0uLL;
          long long v430 = 0uLL;
          goto LABEL_963;
        }
        uint64_t v431 = 0;
        uint64_t v432 = *(void *)&v557[0] >> 4;
        while (1)
        {
          unsigned __int16 v433 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v556 + v431)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
          unint64_t v571 = (unsigned __int16)~v433;
          if (v433 != 0xFFFF) {
            break;
          }
          v431 += 16;
          if (!--v432) {
            goto LABEL_962;
          }
        }
        unint64_t v4 = __clz(__rbit64((unsigned __int16)~v433)) + v431;
        unint64_t v572 = v4;
        if (v4 == -1)
        {
LABEL_962:
          uint64_t v427 = 0;
          uint64_t v428 = 0;
          long long v429 = 0uLL;
          long long v430 = 0uLL;
          long long v425 = 0uLL;
          goto LABEL_963;
        }
        unint64_t v3 = (unint64_t)&v601[1] + 8;
        a2 = (unint64_t)v602;
        unint64_t v11 = 96;
        while (2)
        {
          unint64_t v6 = *((void *)v570 + 1);
          unint64_t v447 = v6 + 96 * v4;
          LODWORD(v569) = *(_DWORD *)v447;
          v603 = 0;
          memset(v601, 0, sizeof(v601));
          memset(v602, 0, 28);
          v448 = re::FixedArray<unsigned int>::operator=((uint64_t *)&v601[1] + 1, v447 + 32);
          unint64_t v449 = *(void *)(v447 + 16);
          unint64_t v18 = v449 - 1;
          if (v449)
          {
            uint64_t v450 = 0;
            unint64_t v5 = *(void *)(v447 + 16);
            uint64_t v451 = *((void *)&v601[0] + 1);
            uint64_t v452 = *(void *)&v601[1];
            unint64_t v13 = v18;
            while (v5 > v13)
            {
              if (v451 == v450) {
                goto LABEL_1190;
              }
              *(_DWORD *)(v452 + 4 * v450++) = *(_DWORD *)(*(void *)(v447 + 24) + 4 * v13--);
              if (v13 == -1) {
                goto LABEL_1013;
              }
            }
LABEL_1189:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            uint64_t v451 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 476;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v13;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v5;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1190:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            uint64_t v12 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 468;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v451;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v451;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1191:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 797;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v13;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v5;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1192:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v12;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1193:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 797;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v6;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v5;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1194:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v6;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1195:
            uint64_t v566 = 0;
            long long v608 = 0u;
            memset(v607, 0, sizeof(v607));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v609 = 136315906;
            *(void *)&v609[4] = "operator[]";
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = 789;
            *(_WORD *)&v609[18] = 2048;
            *(void *)&v609[20] = v6 + 1;
            *(_WORD *)&v609[28] = 2048;
            *(void *)&v609[30] = v4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1196:
            *(void *)v598 = 0;
            memset(v602, 0, sizeof(v602));
            memset(v601, 0, sizeof(v601));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v607[0]) = 136315906;
            *(void *)((char *)v607 + 4) = "operator[]";
            WORD6(v607[0]) = 1024;
            *(_DWORD *)((char *)v607 + 14) = 468;
            WORD1(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 4) = v3;
            WORD6(v607[1]) = 2048;
            *(void *)((char *)&v607[1] + 14) = v3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_1197:
            re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) ", "vertexCountPerPolygon.size() == originalPolygonCount", "buildPositionsOnlyMeshHelper", 64);
            _os_crash();
            __break(1u);
            goto LABEL_1198;
          }
LABEL_1013:
          unint64_t v453 = v6 + 96 * v4;
          unint64_t v455 = *(void *)(v453 + 72);
          uint64_t v12 = v453 + 72;
          unint64_t v454 = v455;
          re::DynamicArray<float>::operator=((uint64_t)v602, (uint64_t *)(v12 - 16));
          if (v455)
          {
            unint64_t v5 = *(void *)v12;
            v456 = (uint64_t *)(v6 + 96 * v4 + 88);
            unint64_t v4 = *(void *)&v602[1];
            v457 = v603;
            uint64_t v458 = 2;
            unint64_t v6 = 1;
            do
            {
              unint64_t v13 = v6 + 1;
              if (v5 <= v6 + 1) {
                goto LABEL_1191;
              }
              uint64_t v12 = v6 - 1;
              if (v4 <= v6 - 1) {
                goto LABEL_1192;
              }
              uint64_t v459 = *v456;
              v457[v458 - 2] = v18 - *(_DWORD *)(*v456 + v458 * 4);
              if (v5 <= v6) {
                goto LABEL_1193;
              }
              if (v4 <= v6) {
                goto LABEL_1194;
              }
              v457[v458 - 1] = v18 - *(_DWORD *)(v459 + 4 * v6);
              if (v4 <= v13) {
                goto LABEL_1195;
              }
              v457[v458] = v18 - *(_DWORD *)(v459 + v458 * 4 - 8);
              unint64_t v460 = v6 + 2;
              v6 += 3;
              v458 += 3;
            }
            while (v460 < v454);
          }
          re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::addNew((_anonymous_namespace_ *)v605, (unsigned int *)&v569, (uint64_t)v601);
          if (*(void *)&v602[0])
          {
            if (v603) {
              (*(void (**)(void, _DWORD *))(**(void **)&v602[0] + 40))(*(void *)&v602[0], v603);
            }
            v603 = 0;
            memset(v602, 0, 24);
            ++DWORD2(v602[1]);
          }
          if (*((void *)&v601[1] + 1))
          {
            if (*(void *)&v601[2])
            {
              (*(void (**)(void, void))(**((void **)&v601[1] + 1) + 40))(*((void *)&v601[1] + 1), *((void *)&v601[2] + 1));
              v601[2] = 0uLL;
            }
            *((void *)&v601[1] + 1) = 0;
          }
          if (*(void *)&v601[0] && *((void *)&v601[0] + 1)) {
            (*(void (**)(void, void))(**(void **)&v601[0] + 40))(*(void *)&v601[0], *(void *)&v601[1]);
          }
          re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(&v570);
          unint64_t v4 = v572;
          if (v572 != -1) {
            continue;
          }
          break;
        }
        uint64_t v426 = *(void *)&v557[0];
        uint64_t v428 = *((void *)&v605[3] + 1);
        uint64_t v427 = *(void *)&v605[3];
        long long v425 = v605[0];
        long long v429 = v605[1];
        long long v430 = v605[2];
LABEL_963:
        a2 = v527;
        uint64_t v438 = *((void *)&v557[2] + 1);
        *((void *)&v557[2] + 1) = v428;
        v605[0] = v556;
        *((void *)&v605[3] + 1) = v438;
        *(void *)&v605[1] = v426;
        long long v439 = *(_OWORD *)((char *)&v557[1] + 8);
        long long v440 = *(_OWORD *)((char *)v557 + 8);
        *(void *)&v557[2] = v427;
        *(_OWORD *)((char *)&v605[2] + 8) = v439;
        long long v556 = v425;
        v557[0] = v429;
        v557[1] = v430;
        *(_OWORD *)((char *)&v605[1] + 8) = v440;
        re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit((uint64_t)v605);
        re::GeomMesh::freeName((re *)v573);
        re::internal::GeomAttributeManager::~GeomAttributeManager((re::internal::GeomAttributeManager *)((char *)&v576 + 8));
        if ((void)v574 && (void)v576) {
          (*(void (**)(void, void))(*(void *)v574 + 40))(v574, v576);
        }
LABEL_966:
        re::GeomMesh::GeomMesh((uint64_t)v573, (uint64_t)&v544);
        uint64_t v586 = v548;
        re::GeomIndexMap::GeomIndexMap((uint64_t)v587, (uint64_t)&v548 + 8);
        long long v597 = v557[2];
        long long v594 = v556;
        long long v595 = v557[0];
        long long v556 = 0u;
        memset(v557, 0, sizeof(v557));
        long long v596 = v557[1];
        *(unsigned char *)a2 = 1;
        re::GeomMesh::GeomMesh(a2 + 8, (uint64_t)v573);
        *(void *)(a2 + 744) = v586;
        re::GeomIndexMap::GeomIndexMap(a2 + 752, (uint64_t)v587);
        *(_OWORD *)(a2 + 880) = v597;
        long long v597 = 0u;
        long long v441 = v595;
        *(_OWORD *)(a2 + 832) = v594;
        *(_OWORD *)(a2 + 848) = v441;
        long long v594 = 0u;
        long long v595 = 0u;
        *(_OWORD *)(a2 + 864) = v596;
        long long v596 = 0u;
        v443.n128_f64[0] = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit((uint64_t)&v594);
        switch(v588)
        {
          case 2:
            if (*((void *)&v593 + 1))
            {
              if (v590) {
                uint64_t v590 = 0;
              }
              if (v589)
              {
                (*(void (**)(__n128))(**((void **)&v593 + 1) + 40))(v443);
                uint64_t v589 = 0;
              }
              long long v592 = 0u;
              long long v593 = 0u;
              long long v591 = 0u;
            }
            break;
          case 1:
            if (v589)
            {
              if ((void)v592) {
                (*(void (**)(double))(*(void *)v589 + 40))(v443.n128_f64[0]);
              }
              *(void *)&long long v592 = 0;
              uint64_t v590 = 0;
              *(void *)&long long v591 = 0;
              uint64_t v589 = 0;
              ++DWORD2(v591);
            }
            break;
          case 0:
            LODWORD(v589) = 0;
            break;
          default:
LABEL_1251:
            re::internal::assertLog((re::internal *)4, v442, v443.n128_f64[0], "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
            _os_crash();
            __break(1u);
LABEL_1252:
            re::internal::assertLog((re::internal *)4, v81, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1253:
            re::internal::assertLog((re::internal *)4, v177, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1254:
            re::internal::assertLog((re::internal *)4, v124, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1255:
            re::internal::assertLog((re::internal *)4, v201, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1256:
            re::internal::assertLog((re::internal *)4, v129, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1257:
            re::internal::assertLog((re::internal *)4, v225, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1258:
            re::internal::assertLog((re::internal *)4, v134, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1259:
            re::internal::assertLog((re::internal *)4, v249, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1260:
            re::internal::assertLog((re::internal *)4, v137, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1261:
            re::internal::assertLog((re::internal *)4, v272, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1262:
            re::internal::assertLog((re::internal *)4, v140, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1263:
            re::internal::assertLog((re::internal *)4, v295, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1264:
            re::internal::assertLog((re::internal *)4, v152, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1265:
            re::internal::assertLog((re::internal *)4, v315, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1266:
            re::internal::assertLog((re::internal *)4, v155, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1267:
            re::internal::assertLog((re::internal *)4, v331, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1268:
            re::internal::assertLog((re::internal *)4, v158, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1269:
            re::internal::assertLog((re::internal *)4, v347, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1270:
            re::internal::assertLog((re::internal *)4, v163, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1271:
            re::internal::assertLog((re::internal *)4, v365, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1272:
            re::internal::assertLog((re::internal *)4, v374, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1273:
            re::internal::assertLog((re::internal *)4, v387, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
            _os_crash();
            __break(1u);
LABEL_1274:
            re::internal::assertLog((re::internal *)4, v502, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
            _os_crash();
            __break(1u);
            JUMPOUT(0x233D561C0);
        }
        re::GeomMesh::~GeomMesh((re::GeomMesh *)v573);
        if (*(void *)v598 && (v598[8] & 1) != 0) {
          (*(void (**)(void, void))(**(void **)v598 + 40))(*(void *)v598, *(void *)&v598[16]);
        }
LABEL_983:
        v445.n128_f64[0] = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit((uint64_t)&v556);
        switch(v550)
        {
          case 2:
            if (*((void *)&v555 + 1))
            {
              if (v552) {
                uint64_t v552 = 0;
              }
              if (v551)
              {
                (*(void (**)(__n128))(**((void **)&v555 + 1) + 40))(v445);
                uint64_t v551 = 0;
              }
              long long v554 = 0u;
              long long v555 = 0u;
              long long v553 = 0u;
            }
            break;
          case 1:
            if (v551)
            {
              if ((void)v554) {
                (*(void (**)(double))(*(void *)v551 + 40))(v445.n128_f64[0]);
              }
              *(void *)&long long v554 = 0;
              uint64_t v552 = 0;
              *(void *)&long long v553 = 0;
              uint64_t v551 = 0;
              ++DWORD2(v553);
            }
            break;
          case 0:
            LODWORD(v551) = 0;
            break;
          default:
LABEL_1250:
            re::internal::assertLog((re::internal *)4, v444, v445.n128_f64[0], "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
            _os_crash();
            __break(1u);
            goto LABEL_1251;
        }
        re::GeomMesh::~GeomMesh((re::GeomMesh *)&v544);
LABEL_998:
        if (v562)
        {
          if (v563)
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v562 + 40))(v562, v564);
            uint64_t v563 = 0;
            uint64_t v564 = 0;
          }
          uint64_t v562 = 0;
        }
        if (v561) {

        }
        return;
      default:
LABEL_62:
        int v43 = 0;
        goto LABEL_63;
    }
  }
}

uint64_t re::makeGeomModelFromModelDescriptor@<X0>(re *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v169 = *MEMORY[0x263EF8340];
  re::makeGeomMeshFromModelDescriptor(this, (unint64_t)v73);
  if (!v73[0])
  {
    v133[0] = v74;
    re::DynamicString::DynamicString((re::DynamicString *)&v133[1], (const re::DynamicString *)&v75);
    *(unsigned char *)a2 = 0;
    *(_OWORD *)(a2 + 8) = v133[0];
    *(void *)(a2 + 24) = *(void *)&v133[1];
    *(void *)(a2 + 48) = *((void *)&v133[2] + 1);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)&v133[1] + 8);
    return re::Result<re::GeomMeshWithNGons,re::DetailedError>::~Result((uint64_t)v73);
  }
  unint64_t v5 = (unint64_t)&v106;
  uint64_t v6 = *((void *)this + 1);
  if (!v6)
  {
    re::GeomModel::GeomModel((re::GeomModel *)v133);
    if (!*((void *)&v133[2] + 1)) {
      re::DynamicArray<re::GeomMesh>::setCapacity(&v133[2], 1uLL);
    }
    re::DynamicArray<re::GeomMesh>::add((uint64_t)&v133[2], (uint64_t)&v74);
    if (!v136) {
      re::DynamicArray<int>::setCapacity((void *)&v135 + 1, 1uLL);
    }
    LODWORD(v149) = *((_DWORD *)this + 1);
    re::DynamicArray<int>::add((void *)&v135 + 1, &v149);
    uint64_t v16 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v149, (uint64_t)this + 136);
    unint64_t v17 = v146;
    if (v146 >= v145)
    {
      unint64_t v18 = v146 + 1;
      if (v145 < v146 + 1)
      {
        if (v144)
        {
          unint64_t v19 = 8;
          if (v145) {
            unint64_t v19 = 2 * v145;
          }
          if (v19 <= v18) {
            unint64_t v20 = v146 + 1;
          }
          else {
            unint64_t v20 = v19;
          }
          re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(&v144, v20);
        }
        else
        {
          re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(&v144, v18);
          ++v147;
        }
      }
      unint64_t v17 = v146;
    }
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v148 + 48 * v17, (uint64_t)&v149);
    ++v146;
    ++v147;
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v149);
    uint64_t v95 = 0;
    uint64_t v92 = 0;
    long long v93 = 0uLL;
    LODWORD(v94) = 0;
    uint64_t v89 = 0;
    unint64_t v86 = 0;
    long long v87 = 0uLL;
    LODWORD(v88) = 0;
    re::DynamicArray<re::GeomIndexMap>::resize((uint64_t)&v92, 1uLL);
    re::DynamicArray<re::GeomIndexMap>::resize((uint64_t)&v86, 1uLL);
    unsigned int v64 = 0;
    unsigned int v65 = *((_DWORD *)this + 4);
    *(void *)&v122[0] = 0xFFFFFFFF00000000;
    DWORD2(v122[0]) = -1;
    BYTE12(v122[0]) = 0;
    if (v65 - 1 <= 0xFFFFFFFD)
    {
      DWORD2(v122[0]) = v65 - 1;
      unsigned int v64 = v65;
      *(void *)&v122[0] = v65;
    }
    LODWORD(v122[1]) = v64;
    if (!*((void *)&v93 + 1)) {
      goto LABEL_213;
    }
    re::GeomIndexMap::operator=(v95, (uint64_t)v122);
    if (!BYTE12(v122[0])) {
      goto LABEL_176;
    }
    if (BYTE12(v122[0]) == 2)
    {
      uint64_t v67 = *((void *)&v124 + 1);
      if (!*((void *)&v124 + 1)) {
        goto LABEL_176;
      }
      if (*((void *)&v122[1] + 1)) {
        *((void *)&v122[1] + 1) = 0;
      }
      if (!*(void *)&v122[1]) {
        goto LABEL_176;
      }
    }
    else
    {
      if (BYTE12(v122[0]) != 1) {
        goto LABEL_217;
      }
      uint64_t v67 = *(void *)&v122[1];
      if (!*(void *)&v122[1] || !(void)v123) {
        goto LABEL_176;
      }
    }
    (*(void (**)(uint64_t))(*(void *)v67 + 40))(v67);
LABEL_176:
    if (!*((void *)&v87 + 1)) {
      goto LABEL_214;
    }
    re::GeomIndexMap::operator=(v89, (uint64_t)&v77);
    LOBYTE(v149) = 1;
    *((void *)&v149 + 1) = v92;
    v150[0] = v93;
    uint64_t v92 = 0;
    long long v93 = 0uLL;
    *((void *)&v150[1] + 1) = v95;
    uint64_t v95 = 0;
    LODWORD(v94) = v94 + 1;
    LODWORD(v150[1]) = 1;
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(v140, (unsigned __int8 *)&v149);
    if ((_BYTE)v149) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v149 + 8);
    }
    LOBYTE(v149) = 1;
    *((void *)&v149 + 1) = v86;
    v150[0] = v87;
    unint64_t v86 = 0;
    long long v87 = 0uLL;
    *((void *)&v150[1] + 1) = v89;
    uint64_t v89 = 0;
    LODWORD(v88) = v88 + 1;
    LODWORD(v150[1]) = 1;
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(v142, (unsigned __int8 *)&v149);
    if ((_BYTE)v149) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v149 + 8);
    }
    re::DynamicString::operator=((re::DynamicString *)v133, (re *)((char *)this + 184));
    re::types::Ok<re::GeomModel>::Ok((uint64_t)&v149, (uint64_t)v133);
    re::Result<re::GeomModel,re::DetailedError>::Result(a2, (uint64_t)&v149);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v161);
    if (v159[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v160);
    }
    if (v157[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v158);
    }
    if (*((void *)&v152 + 1))
    {
      if (v156) {
        (*(void (**)(void))(**((void **)&v152 + 1) + 40))();
      }
      uint64_t v156 = 0;
      uint64_t v153 = 0;
      unint64_t v154 = 0;
      *((void *)&v152 + 1) = 0;
      ++v155;
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v150[1]);
    if (void)v149 && (BYTE8(v149)) {
      (*(void (**)(void))(*(void *)v149 + 40))();
    }
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v86);
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v92);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)&v144);
    if (v142[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v143);
    }
    if (v140[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v141);
    }
    if (*((void *)&v135 + 1))
    {
      if (v139) {
        (*(void (**)(void))(**((void **)&v135 + 1) + 40))();
      }
      uint64_t v139 = 0;
      uint64_t v136 = 0;
      uint64_t v137 = 0;
      *((void *)&v135 + 1) = 0;
      ++v138;
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v133[2]);
    if (*(void *)&v133[0] && (BYTE8(v133[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v133[0] + 40))();
    }
    return re::Result<re::GeomMeshWithNGons,re::DetailedError>::~Result((uint64_t)v73);
  }
  *(void *)&v133[0] = *((void *)this + 1);
  id v7 = (id)(v6 + 8);
  re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v133, &v115);
  if (*(void *)&v133[0]) {

  }
  if (*((void *)this + 3) != v76)
  {
    long long v21 = v133[0];
    long long v22 = v133[1];
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v21;
    *(_OWORD *)(a2 + 40) = v22;
LABEL_154:
    if (v119)
    {
      if (v120)
      {
        (*(void (**)(void))(*(void *)v119 + 40))();
        uint64_t v120 = 0;
        uint64_t v121 = 0;
      }
      uint64_t v119 = 0;
    }
    if (v118) {

    }
    return re::Result<re::GeomMeshWithNGons,re::DetailedError>::~Result((uint64_t)v73);
  }
  uint64_t v70 = a2;
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v72, (uint64_t)this + 136);
  uint64_t v9 = (uint64_t)re::GeomModel::GeomModel((re::GeomModel *)&v149);
  unsigned int v112 = 0;
  long long v111 = 0u;
  long long v110 = 0u;
  uint64_t v113 = 0x7FFFFFFFLL;
  uint64_t v10 = v76;
  if (v76)
  {
    uint64_t v11 = 0;
    do
    {
      LODWORD(v122[0]) = *(_DWORD *)(v115 + v116 * v11);
      uint64_t v12 = (void *)re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)&v110, v122[0]);
      uint64_t v9 = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v81, v11);
      if (v9 == -1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = *(void *)(v82 + 96 * v9 + 40);
      }
      *(void *)&v133[0] = v13;
      if (v12) {
        *v12 += v13;
      }
      else {
        re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add((uint64_t)&v110, v122, v133);
      }
      ++v11;
    }
    while (v10 != v11);
    signed int v14 = HIDWORD(v111);
    unsigned int v15 = v112;
  }
  else
  {
    unsigned int v15 = 0;
    signed int v14 = 0;
  }
  unsigned int v108 = 0;
  long long v107 = 0u;
  long long v106 = 0u;
  uint64_t v109 = 0x7FFFFFFFLL;
  unsigned int v71 = v14;
  uint64_t v23 = 0;
  if (v15)
  {
    long long v24 = (int *)(v111 + 8);
    while (1)
    {
      int v25 = *v24;
      v24 += 6;
      if (v25 < 0) {
        break;
      }
      if (v15 == ++v23)
      {
        LODWORD(v23) = v15;
        break;
      }
    }
  }
  if (v15 != v23)
  {
    uint64_t v26 = v23;
    uint64_t v27 = v111;
    do
    {
      uint64_t v28 = v27 + 24 * v26;
      LODWORD(v122[0]) = *(_DWORD *)(v28 + 12);
      unint64_t v29 = *(void *)(v28 + 16);
      *(void *)&v133[2] = 0;
      memset(v133, 0, 28);
      if (v29) {
        re::DynamicArray<int>::setCapacity(v133, v29);
      }
      re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew((uint64_t)&v106, v122, (uint64_t)v133);
      if (*(void *)&v133[0] && *(void *)&v133[2]) {
        (*(void (**)(void))(**(void **)&v133[0] + 40))();
      }
      if (v15 <= (int)v23 + 1) {
        unsigned int v30 = v23 + 1;
      }
      else {
        unsigned int v30 = v15;
      }
      while (1)
      {
        uint64_t v26 = (v23 + 1);
        if (v30 - 1 == v23) {
          break;
        }
        LODWORD(v23) = v23 + 1;
        unsigned int v31 = v26;
        if ((*(_DWORD *)(v27 + 24 * v26 + 8) & 0x80000000) != 0) {
          goto LABEL_51;
        }
      }
      unsigned int v31 = v30;
LABEL_51:
      LODWORD(v23) = v31;
    }
    while (v15 != v31);
  }
  int v69 = this;
  if (v10)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      unint64_t v33 = (void *)re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)&v106, *(_DWORD *)(v115 + v116 * i));
      uint64_t v34 = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(&v81, i);
      if (v34 == -1)
      {
        LODWORD(v133[0]) = i;
        re::DynamicArray<int>::add(v33, v133);
      }
      else
      {
        uint64_t v35 = v82 + 96 * v34;
        uint64_t v38 = *(void *)(v35 + 40);
        uint64_t v36 = (unint64_t *)(v35 + 40);
        uint64_t v37 = v38;
        if (v38)
        {
          uint64_t v39 = 0;
          unint64_t v40 = 0;
          unint64_t v41 = (void *)(v82 + 96 * v34 + 48);
          while (1)
          {
            unint64_t v5 = *v36;
            if (*v36 <= v40) {
              break;
            }
            re::DynamicArray<int>::add(v33, (_DWORD *)(*v41 + v39));
            ++v40;
            v39 += 4;
            if (v37 == v40) {
              goto LABEL_61;
            }
          }
          uint64_t v92 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          unint64_t v50 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 476;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v40;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_205:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_206:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_207:
          uint64_t v114 = 0;
          long long v124 = 0u;
          long long v123 = 0u;
          memset(v122, 0, sizeof(v122));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unsigned int v162 = 136315906;
          *(void *)&v162[4] = "operator[]";
          __int16 v163 = 1024;
          int v164 = 789;
          __int16 v165 = 2048;
          unint64_t v166 = v5;
          __int16 v167 = 2048;
          unint64_t v168 = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_208:
          uint64_t v84 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unsigned int v162 = 136315906;
          *(void *)&v162[4] = "operator[]";
          __int16 v163 = 1024;
          int v164 = 789;
          __int16 v165 = 2048;
          unint64_t v166 = v5;
          __int16 v167 = 2048;
          unint64_t v168 = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_209:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_210:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_211:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_212:
          *(void *)unsigned int v162 = 0;
          long long v135 = 0u;
          long long v134 = 0u;
          memset(v133, 0, sizeof(v133));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)((char *)v122 + 4) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)((char *)v122 + 14) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 4) = v5;
          WORD6(v122[1]) = 2048;
          *(void *)((char *)&v122[1] + 14) = v50;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_213:
          *(void *)&long long v110 = 0;
          long long v152 = 0u;
          long long v151 = 0u;
          memset(v150, 0, sizeof(v150));
          long long v149 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v115) = 136315906;
          *(void *)(v5 + 116) = "operator[]";
          WORD2(v116) = 1024;
          *(_DWORD *)(v5 + 126) = 789;
          __int16 v117 = 2048;
          *(void *)(v5 + 132) = 0;
          WORD2(v118) = 2048;
          *(void *)(v5 + 142) = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_214:
          uint64_t v115 = 0;
          long long v152 = 0u;
          long long v151 = 0u;
          memset(v150, 0, sizeof(v150));
          long long v149 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v122[0]) = 136315906;
          *(void *)(v5 + 180) = "operator[]";
          WORD6(v122[0]) = 1024;
          *(_DWORD *)(v5 + 190) = 789;
          WORD1(v122[1]) = 2048;
          *(void *)(v5 + 196) = 0;
          WORD6(v122[1]) = 2048;
          *(void *)(v5 + 206) = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_61:
      ;
    }
  }
  re::DynamicArray<re::GeomMesh>::resize((uint64_t)&v150[1], v71);
  LODWORD(v133[0]) = 0;
  re::DynamicArray<unsigned int>::resize((void *)&v152 + 1, v71, v133);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::resize((uint64_t)v161, v71, (uint64_t)v72);
  uint64_t v105 = 0;
  uint64_t v102 = 0;
  long long v103 = 0uLL;
  int v104 = 0;
  uint64_t v101 = 0;
  uint64_t v98 = 0;
  long long v99 = 0uLL;
  int v100 = 0;
  re::DynamicArray<re::GeomIndexMap>::resize((uint64_t)&v102, v71);
  re::DynamicArray<re::GeomIndexMap>::resize((uint64_t)&v98, v71);
  uint64_t v92 = v77;
  LODWORD(v93) = v78;
  BYTE4(v93) = v79;
  if (v79 == 2)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v93 + 8, v80);
  }
  else if (v79 == 1)
  {
    re::DynamicArray<float>::DynamicArray((uint64_t)&v93 + 8, v80);
  }
  else
  {
    if (v79) {
      goto LABEL_218;
    }
    DWORD2(v93) = v80[0];
  }
  unsigned int v43 = v108;
  uint64_t v44 = 0;
  if (v108)
  {
    int v45 = (int *)(v107 + 8);
    while (1)
    {
      int v46 = *v45;
      v45 += 14;
      if (v46 < 0) {
        break;
      }
      if (v108 == ++v44)
      {
        LODWORD(v44) = v108;
        break;
      }
    }
  }
  if (v108 == v44)
  {
LABEL_113:
    LOBYTE(v133[0]) = 1;
    *((void *)&v133[0] + 1) = v102;
    v133[1] = v103;
    uint64_t v102 = 0;
    long long v103 = 0uLL;
    *((void *)&v133[2] + 1) = v105;
    uint64_t v105 = 0;
    ++v104;
    LODWORD(v133[2]) = 1;
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(v157, (unsigned __int8 *)v133);
    if (LOBYTE(v133[0])) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v133 + 8);
    }
    LOBYTE(v133[0]) = 1;
    *((void *)&v133[0] + 1) = v98;
    v133[1] = v99;
    uint64_t v98 = 0;
    long long v99 = 0uLL;
    *((void *)&v133[2] + 1) = v101;
    uint64_t v101 = 0;
    ++v100;
    LODWORD(v133[2]) = 1;
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(v159, (unsigned __int8 *)v133);
    if (LOBYTE(v133[0])) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v133 + 8);
    }
    re::types::Ok<re::GeomModel>::Ok((uint64_t)v122, (uint64_t)&v149);
    re::Result<re::GeomModel,re::DetailedError>::Result((uint64_t)v133, (uint64_t)v122);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)&v132);
    if (v130[40]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v131);
    }
    if (v129) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v130);
    }
    if (*((void *)&v124 + 1))
    {
      if (v128) {
        (*(void (**)(void))(**((void **)&v124 + 1) + 40))();
      }
      uint64_t v128 = 0;
      uint64_t v125 = 0;
      uint64_t v126 = 0;
      *((void *)&v124 + 1) = 0;
      ++v127;
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v122[2]);
    if (*(void *)&v122[0] && (BYTE8(v122[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v122[0] + 40))();
    }
    if (!BYTE4(v93)) {
      goto LABEL_139;
    }
    if (BYTE4(v93) == 2)
    {
      uint64_t v63 = v97;
      if (!v97) {
        goto LABEL_139;
      }
      if (v94) {
        uint64_t v94 = 0;
      }
      if (!*((void *)&v93 + 1)) {
        goto LABEL_139;
      }
    }
    else
    {
      if (BYTE4(v93) != 1) {
        goto LABEL_219;
      }
      uint64_t v63 = *((void *)&v93 + 1);
      if (!*((void *)&v93 + 1) || !v96) {
        goto LABEL_139;
      }
    }
    (*(void (**)(uint64_t))(*(void *)v63 + 40))(v63);
LABEL_139:
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v98);
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v102);
    re::HashTable<int,re::DynamicArray<re::RenderGraphProviderBase const*>,re::Hash<int>,re::EqualTo<int>,true,false>::deinit((uint64_t *)&v106);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v110);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v161);
    if (v159[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v160);
    }
    if (v157[0]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v158);
    }
    if (*((void *)&v152 + 1))
    {
      if (v156) {
        (*(void (**)(void))(**((void **)&v152 + 1) + 40))();
      }
      uint64_t v156 = 0;
      uint64_t v153 = 0;
      unint64_t v154 = 0;
      *((void *)&v152 + 1) = 0;
      ++v155;
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v150[1]);
    if (void)v149 && (BYTE8(v149)) {
      (*(void (**)(void))(*(void *)v149 + 40))();
    }
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v72);
    if (LOBYTE(v133[0]))
    {
      re::DynamicString::operator=((re::DynamicString *)((char *)v133 + 8), (re *)((char *)v69 + 184));
      re::Result<re::GeomModel,re::DetailedError>::Result(v70, (unsigned __int8 *)v133);
    }
    else
    {
      long long v149 = *(_OWORD *)((char *)v133 + 8);
      re::DynamicString::DynamicString((re::DynamicString *)v150, (const re::DynamicString *)((char *)&v133[1] + 8));
      *(unsigned char *)uint64_t v70 = 0;
      *(_OWORD *)(v70 + 8) = v149;
      *(void *)(v70 + 24) = *(void *)&v150[0];
      *(void *)(v70 + 48) = *((void *)&v150[1] + 1);
      *(_OWORD *)(v70 + 32) = *(_OWORD *)((char *)v150 + 8);
    }
    re::Result<re::GeomModel,re::DetailedError>::~Result(v133);
    goto LABEL_154;
  }
  unsigned int v47 = 0;
  uint64_t v48 = v44;
  uint64_t v49 = v107;
  while (1)
  {
    unint64_t v86 = 0xFFFFFFFF00000000;
    LODWORD(v87) = -1;
    BYTE4(v87) = 0;
    DWORD2(v87) = 0;
    unint64_t v5 = v47;
    unint64_t v50 = v154;
    if (v154 <= v47) {
      goto LABEL_205;
    }
    uint64_t v51 = v49 + 56 * v48;
    *(_DWORD *)(v156 + 4 * v47) = *(_DWORD *)(v51 + 12);
    uint64_t v85 = 0;
    uint64_t v84 = 0;
    uint64_t v52 = *(void *)(v51 + 48);
    uint64_t v53 = *(void *)(v51 + 32);
    uint64_t v84 = v52;
    uint64_t v85 = v53;
    v83[1] = 0;
    v83[0] = 0;
    unint64_t v50 = *((void *)&v103 + 1);
    if (*((void *)&v103 + 1) <= v5) {
      goto LABEL_206;
    }
    re::makeMeshFromFaces((unint64_t)&v74, &v84, v83, v105 + 80 * v5, (uint64_t)&v86, (unint64_t)v133);
    unint64_t v50 = v151;
    if ((unint64_t)v151 <= v5) {
      goto LABEL_207;
    }
    re::GeomMesh::operator=((re::GeomMesh *)(v152 + 736 * v5), (re::GeomMesh *)v133);
    re::GeomMesh::~GeomMesh((re::GeomMesh *)v133);
    re::remapIndexMap((unsigned int *)&v86, (const re::GeomIndexMap *)&v92, (uint64_t)v122);
    unint64_t v50 = *((void *)&v99 + 1);
    if (*((void *)&v99 + 1) <= v5) {
      goto LABEL_208;
    }
    re::GeomIndexMap::operator=(v101 + 80 * v5, (uint64_t)v122);
    if (!BYTE12(v122[0])) {
      goto LABEL_90;
    }
    if (BYTE12(v122[0]) != 2) {
      break;
    }
    uint64_t v56 = *((void *)&v124 + 1);
    if (*((void *)&v124 + 1))
    {
      if (*((void *)&v122[1] + 1)) {
        *((void *)&v122[1] + 1) = 0;
      }
      if (*(void *)&v122[1]) {
LABEL_89:
      }
        (*(void (**)(uint64_t))(*(void *)v56 + 40))(v56);
    }
LABEL_90:
    unint64_t v50 = v151;
    if ((unint64_t)v151 <= v5) {
      goto LABEL_209;
    }
    unint64_t v50 = *((void *)&v103 + 1);
    if (*((void *)&v103 + 1) <= v5) {
      goto LABEL_210;
    }
    re::remapSkinningAttributes((re *)(v152 + 736 * v5), (re::GeomMesh *)&v74, (const re::GeomMesh *)(v105 + 80 * v5), v55);
    unint64_t v50 = v151;
    if ((unint64_t)v151 <= v5) {
      goto LABEL_211;
    }
    unint64_t v50 = *((void *)&v103 + 1);
    if (*((void *)&v103 + 1) <= v5) {
      goto LABEL_212;
    }
    re::remapSubdivisionSurfaceAttributes((re *)(v152 + 736 * v5), (re::GeomMesh *)&v74, v105 + 80 * v5, v57);
    if (BYTE4(v87))
    {
      if (BYTE4(v87) != 2)
      {
        if (BYTE4(v87) != 1) {
          goto LABEL_216;
        }
        uint64_t v59 = *((void *)&v87 + 1);
        if (!*((void *)&v87 + 1) || !v90) {
          goto LABEL_105;
        }
LABEL_104:
        (*(void (**)(uint64_t))(*(void *)v59 + 40))(v59);
        goto LABEL_105;
      }
      uint64_t v59 = v91;
      if (v91)
      {
        if (v88) {
          uint64_t v88 = 0;
        }
        if (*((void *)&v87 + 1)) {
          goto LABEL_104;
        }
      }
    }
LABEL_105:
    if (v43 <= (int)v44 + 1) {
      unsigned int v60 = v44 + 1;
    }
    else {
      unsigned int v60 = v43;
    }
    while (1)
    {
      uint64_t v48 = (v44 + 1);
      if (v60 - 1 == v44) {
        break;
      }
      LODWORD(v44) = v44 + 1;
      unsigned int v61 = v48;
      if ((*(_DWORD *)(v49 + 56 * v48 + 8) & 0x80000000) != 0) {
        goto LABEL_112;
      }
    }
    unsigned int v61 = v60;
LABEL_112:
    unsigned int v47 = v5 + 1;
    LODWORD(v44) = v61;
    if (v43 == v61) {
      goto LABEL_113;
    }
  }
  if (BYTE12(v122[0]) == 1)
  {
    uint64_t v56 = *(void *)&v122[1];
    if (*(void *)&v122[1] && (void)v123) {
      goto LABEL_89;
    }
    goto LABEL_90;
  }
  re::internal::assertLog((re::internal *)4, v54, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_216:
  re::internal::assertLog((re::internal *)4, v58, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_217:
  re::internal::assertLog((re::internal *)4, v66, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_218:
  re::internal::assertLog((re::internal *)4, v42, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
  _os_crash();
  __break(1u);
LABEL_219:
  re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::DynamicArray<re::GeomIndexMap>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 > a2)
    {
      uint64_t v8 = 80 * a2;
      unint64_t v9 = a2;
      while (1)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        int v11 = *(unsigned __int8 *)(v10 + v8 + 12);
        if (v11 == 2)
        {
          re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(v10 + v8 + 16);
        }
        else if (v11 == 1)
        {
          re::DynamicArray<unsigned long>::deinit(v10 + v8 + 16);
        }
        else
        {
          if (*(unsigned char *)(v10 + v8 + 12))
          {
            re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
            _os_crash();
            __break(1u);
            return;
          }
          *(_DWORD *)(v10 + v8 + 16) = 0;
        }
        ++v9;
        v8 += 80;
        if (v9 >= *(void *)(a1 + 16)) {
          goto LABEL_17;
        }
      }
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::GeomIndexMap>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 80 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0xFFFFFFFF00000000;
        *(_DWORD *)(v7 + 8) = -1;
        *(unsigned char *)(v7 + 12) = 0;
        *(_DWORD *)(v7 + 16) = 0;
        v6 += 80;
        --v5;
      }
      while (v5);
    }
LABEL_17:
    *(void *)(a1 + 16) = a2;
    ++*(_DWORD *)(a1 + 24);
  }
}

void re::GeomIndexMap::~GeomIndexMap(re::GeomIndexMap *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 12);
  if (v2 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 16);
  }
  else if (v2 == 1)
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + 16);
  }
  else if (*((unsigned char *)this + 12))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
    _os_crash();
    __break(1u);
  }
  else
  {
    *((_DWORD *)this + 4) = 0;
  }
}

void re::GeomModelDescriptor::makeConvertedValues<unsigned int>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((0x30u >> v4) & 1) == 0 || v4 > 5) && v4 != 5 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<unsigned int>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 4;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      uint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      int v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<unsigned int>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 2:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_11:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,signed char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(char *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(__int16 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_WORD *)(a2[2] + v12) = *(_WORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(_DWORD *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(unsigned __int8 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(unsigned __int16 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_WORD *)(a2[2] + v12) = *(_WORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,float>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(float *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,double>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(double *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(void *)(a2[2] + v12) = *(void *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

uint64_t re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1) {
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::GeomModelDescriptor::attributeByName(re::GeomModelDescriptor *this, const re::DynamicString *a2)
{
  unint64_t v3 = (void *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 48, (uint64_t)a2);
  if (v3)
  {
    if (*((void *)this + 14) <= *v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *((void *)this + 16) + 56 * *v3;
  }
  else
  {
    return re::GeomModelDescriptor::emptyAttribute(0);
  }
}

_DWORD *re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::addNew(_anonymous_namespace_ *a1, unsigned int *a2, uint64_t a3)
{
  __n128 result = (_DWORD *)re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(a1, *a2);
  if (result == (_DWORD *)-1)
  {
    return re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(a1, a2, a3);
  }
  return result;
}

__n128 re::internal::DataPayload::computeConvertedValues<re::PackedFloat3>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if ((*(unsigned __int8 *)(a1 + 33) | 2) == 0xB)
  {
    uint64_t v4 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
    unint64_t v5 = *(void *)(a1 + 40);
    unint64_t v6 = *(void *)(a1 + 48) * v5;
    __n128 v19 = 0uLL;
    uint64_t v20 = 0;
    if (*(unsigned char *)(a1 + 32))
    {
      if (v6)
      {
        unint64_t v7 = 0;
        unint64_t v8 = v19.n128_u64[1];
        unint64_t v9 = (_DWORD *)(v20 + 8);
        uint64_t v10 = -1;
        while (v8 != ++v10)
        {
          int v11 = *(_DWORD *)(v4 + v7 + 8);
          *((void *)v9 - 1) = *(void *)(v4 + v7);
          *unint64_t v9 = v11;
          v9 += 3;
          v7 += *(void *)(a1 + 48);
          if (v7 >= v6) {
            goto LABEL_13;
          }
        }
        uint64_t v21 = 0;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        __n128 v30 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v22 = 136315906;
        uint64_t v23 = "operator[]";
        __int16 v24 = 1024;
        int v25 = 468;
        __int16 v26 = 2048;
        unint64_t v27 = v8;
        __int16 v28 = 2048;
        unint64_t v29 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_16;
      }
    }
    else if (v6)
    {
      unint64_t v14 = 0;
      unint64_t v8 = v19.n128_u64[1];
      uint64_t v15 = (_DWORD *)(v20 + 8);
      uint64_t v16 = -1;
      while (v8 != ++v16)
      {
        int v17 = *(_DWORD *)(v4 + v14 + 8);
        *((void *)v15 - 1) = *(void *)(v4 + v14);
        *uint64_t v15 = v17;
        v15 += 3;
        v14 += *(void *)(a1 + 48);
        if (v14 >= v6) {
          goto LABEL_13;
        }
      }
LABEL_16:
      uint64_t v21 = 0;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      __n128 v30 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v22 = 136315906;
      uint64_t v23 = "operator[]";
      __int16 v24 = 1024;
      int v25 = 468;
      __int16 v26 = 2048;
      unint64_t v27 = v8;
      __int16 v28 = 2048;
      unint64_t v29 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_13:
    __n128 result = v19;
    uint64_t v18 = v20;
    *(unsigned char *)a2 = 1;
    *(__n128 *)(a2 + 8) = result;
    *(void *)(a2 + 24) = v18;
  }
  else
  {
    __n128 result = v30;
    long long v13 = v31;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = result;
    *(_OWORD *)(a2 + 40) = v13;
  }
  return result;
}

uint64_t re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find(void *a1, unsigned int a2)
{
  if (!a1[7]) {
    return -1;
  }
  unint64_t v2 = a1[2];
  if (v2 < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v3 = v2 >> 4;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  unint64_t v5 = (0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31);
  unint64_t v6 = v5 % v3;
  int8x16_t v7 = vdupq_n_s8(v5 & 0x7F);
  v8.i64[0] = -1;
  v8.i64[1] = -1;
  unint64_t v9 = v5 % v3;
  while (1)
  {
    int8x16_t v10 = *(int8x16_t *)(*a1 + 16 * v9);
    unint64_t v11 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v10), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v12 = __clz(__rbit64(v11));
    if (v12 <= 0x3F) {
      break;
    }
LABEL_10:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v10, v8), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (v9 + 1 == v3) {
      unint64_t v9 = 0;
    }
    else {
      ++v9;
    }
    uint64_t v14 = -1;
    if (v9 == v6) {
      return v14;
    }
  }
  uint64_t v13 = 16 * v9;
  while (1)
  {
    uint64_t v14 = v12 + v13;
    if (*(_DWORD *)(a1[1] + 96 * (v12 + v13)) == a2) {
      return v14;
    }
    if (v12 <= 0x3E)
    {
      unint64_t v12 = __clz(__rbit64((-2 << v12) & v11));
      if (v12 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

_DWORD *re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(_anonymous_namespace_ *a1, unsigned int *a2, uint64_t a3)
{
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize((uint64_t *)a1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v9 = (0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) ^ ((0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) >> 31);
  unint64_t v10 = v7 >> 4;
  unint64_t v11 = v9 % (v7 >> 4);
  uint64_t v12 = *(void *)a1;
  unint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
  if (v13 >= 0x40)
  {
    do
    {
      if (v11 + 1 == v10) {
        unint64_t v11 = 0;
      }
      else {
        ++v11;
      }
      unint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    }
    while (v13 > 0x3F);
  }
  uint64_t v14 = v12 + 16 * v11;
  int v15 = *(unsigned __int8 *)(v14 + v13);
  *(unsigned char *)(v14 + v13) = v9 & 0x7F;
  unint64_t v16 = v13 + 16 * v11;
  int v17 = *a2;
  uint64_t v18 = *(void *)(a3 + 8);
  uint64_t v27 = *(void *)a3;
  uint64_t v28 = v18;
  long long v29 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v30 = *(void *)(a3 + 32);
  *(void *)(a3 + 32) = 0;
  long long v19 = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(a3 + 40) = 0u;
  long long v20 = *(_OWORD *)(a3 + 56);
  long long v31 = v19;
  long long v32 = v20;
  *(_OWORD *)(a3 + 56) = 0u;
  uint64_t v34 = *(void *)(a3 + 80);
  *(void *)(a3 + 80) = 0;
  ++*(_DWORD *)(a3 + 72);
  int v33 = 1;
  uint64_t v21 = *((void *)a1 + 1) + 96 * v16;
  *(_DWORD *)uint64_t v21 = v17;
  re::FixedArray<float>::operator=((uint64_t *)(v21 + 8), &v27);
  re::FixedArray<float>::operator=((uint64_t *)(v21 + 32), (uint64_t *)&v29 + 1);
  re::DynamicArray<re::RigComponentConstraint>::operator=(v21 + 56, (uint64_t)&v31 + 8);
  if (*((void *)&v31 + 1))
  {
    if (v34) {
      (*(void (**)(void))(**((void **)&v31 + 1) + 40))();
    }
    uint64_t v34 = 0;
    long long v32 = 0uLL;
    *((void *)&v31 + 1) = 0;
    ++v33;
  }
  if (*((void *)&v29 + 1))
  {
    if (v30)
    {
      (*(void (**)(void))(**((void **)&v29 + 1) + 40))();
      uint64_t v30 = 0;
      *(void *)&long long v31 = 0;
    }
    *((void *)&v29 + 1) = 0;
  }
  if (v27 && v28) {
    (*(void (**)(void))(*(void *)v27 + 40))();
  }
  uint64_t v22 = *((void *)a1 + 4);
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v22 - (v15 == 255);
  uint64_t v23 = (unsigned int *)(*((void *)a1 + 1) + 96 * v16);
  unsigned int v25 = *v23;
  __n128 result = v23 + 2;
  unint64_t v26 = 0xBF58476D1CE4E5B9 * (v25 ^ ((unint64_t)v25 >> 30));
  *((void *)a1 + 5) ^= ((0x94D049BB133111EBLL * (v26 ^ (v26 >> 27))) >> 31) ^ (0x94D049BB133111EBLL
                                                                               * (v26 ^ (v26 >> 27)));
  return result;
}

double re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize(uint64_t *a1)
{
  unint64_t v3 = a1[2];
  uint64_t v2 = a1[3];
  unint64_t v4 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  unint64_t v5 = ((3 * v3) >> 1) & 0x1FFFFFFFFFFFFFFLL;
  if (v4 > (192 * v3) >> 7) {
    unint64_t v5 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  }
  unint64_t v6 = (v5 << 7) / 0x97;
  uint64_t v7 = a1[7];
  long long v26 = 0u;
  *(_OWORD *)uint64_t v27 = 0u;
  if (v4 <= v3) {
    uint64_t v8 = v2 + 1;
  }
  else {
    uint64_t v8 = v6;
  }
  memset(&v27[16], 0, 32);
  re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init(&v26, v7, v8);
  v24[0] = a1;
  unint64_t v10 = a1[2];
  if (v10 >= 0x10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = *a1;
    unint64_t v13 = v10 >> 4;
    __n128 v14 = (__n128)xmmword_2343680E0;
    v9.n128_u64[0] = 0x3830282018100800;
    while (1)
    {
      unsigned __int16 v15 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v24[1] = (unsigned __int16)~v15;
      if (v15 != 0xFFFF) {
        break;
      }
      v11 += 16;
      if (!--v13) {
        goto LABEL_14;
      }
    }
    uint64_t v16 = __clz(__rbit64((unsigned __int16)~v15)) + v11;
    uint64_t v25 = v16;
    if (v16 != -1)
    {
      do
      {
        re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(&v26, *(void *)(v24[0] + 8) + 96 * v16, *(void *)(v24[0] + 8) + 96 * v16 + 8, v14, v9);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v24);
        uint64_t v16 = v25;
      }
      while (v25 != -1);
      unint64_t v10 = a1[2];
    }
  }
LABEL_14:
  uint64_t v17 = *(void *)&v27[40];
  *(void *)&v27[40] = a1[7];
  long long v18 = v26;
  long long v19 = *(_OWORD *)v27;
  long long v26 = *(_OWORD *)a1;
  *(void *)uint64_t v27 = v10;
  long long v20 = *(_OWORD *)&v27[16];
  long long v21 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v27[32];
  a1[7] = v17;
  *(_OWORD *)&v27[24] = v21;
  long long v22 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v18;
  *((_OWORD *)a1 + 1) = v19;
  *((_OWORD *)a1 + 2) = v20;
  *(_OWORD *)&v27[8] = v22;
  return re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit((uint64_t)&v26);
}

void *re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v6 = v5 >> 4;
    __n128 result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 97 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *unint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v7 = 0;
      *(void *)&long long v8 = -1;
      *((void *)&v8 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v7++) = v8;
      while (v6 != v7);
      __n128 result = (void *)*v3;
    }
    v3[1] = &result[2 * v6];
    if (v3[2])
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      do
      {
        uint64_t v11 = v3[1] + v9;
        *(_DWORD *)uint64_t v11 = 0;
        *(_OWORD *)(v11 + 8) = 0uLL;
        *(_OWORD *)(v11 + 24) = 0uLL;
        *(_OWORD *)(v11 + 40) = 0uLL;
        *(_OWORD *)(v11 + 56) = 0uLL;
        *(_OWORD *)(v11 + 72) = 0uLL;
        *(void *)(v11 + 88) = 0;
        ++v10;
        unint64_t v12 = v3[2];
        v9 += 96;
      }
      while (v10 < v12);
    }
    else
    {
      unint64_t v12 = 0;
    }
  }
  else
  {
    unint64_t v12 = 0;
    *__n128 result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v12;
  return result;
}

unsigned char *re::Result<re::DynamicArray<re::GeomCell4>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void re::GeomModelDescriptor::makeConvertedValues<signed char>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((3u >> v4) & 1) == 0 || v4 > 5) && v4 != 0 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<signed char>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 1;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      unint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      uint64_t v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<signed char>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,signed char>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 2:
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,short>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,int>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,float>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,double>((uint64_t)a1, &v8);
LABEL_9:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<signed char,signed char>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 48) * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v6)
    {
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      while (a2[1] > v7)
      {
        *(unsigned char *)(a2[2] + v7) = *(unsigned char *)(v5 + v8);
        v8 += *(void *)(a1 + 48);
        ++v7;
        if (v8 >= v6) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (a2[1] > v9)
    {
      *(unsigned char *)(a2[2] + v9) = *(unsigned char *)(v5 + v10);
      v10 += *(void *)(a1 + 48);
      ++v9;
      if (v10 >= v6) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<signed char,short>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 48) * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v6)
    {
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      while (a2[1] > v7)
      {
        *(unsigned char *)(a2[2] + v7) = *(unsigned char *)(v5 + v8);
        v8 += *(void *)(a1 + 48);
        ++v7;
        if (v8 >= v6) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (a2[1] > v9)
    {
      *(_WORD *)(a2[2] + v9) = *(_WORD *)(v5 + v10);
      v10 += *(void *)(a1 + 48);
      ++v9;
      if (v10 >= v6) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<signed char,int>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 48) * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v6)
    {
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      while (a2[1] > v7)
      {
        *(unsigned char *)(a2[2] + v7) = *(_DWORD *)(v5 + v8);
        v8 += *(void *)(a1 + 48);
        ++v7;
        if (v8 >= v6) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (a2[1] > v9)
    {
      *(_DWORD *)(a2[2] + v9) = *(_DWORD *)(v5 + v10);
      v10 += *(void *)(a1 + 48);
      ++v9;
      if (v10 >= v6) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<signed char,float>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 48) * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v6)
    {
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      while (a2[1] > v7)
      {
        *(unsigned char *)(a2[2] + v7) = (int)*(float *)(v5 + v8);
        v8 += *(void *)(a1 + 48);
        ++v7;
        if (v8 >= v6) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (a2[1] > v9)
    {
      *(_DWORD *)(a2[2] + v9) = *(_DWORD *)(v5 + v10);
      v10 += *(void *)(a1 + 48);
      ++v9;
      if (v10 >= v6) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<signed char,double>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 48) * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v6)
    {
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      while (a2[1] > v7)
      {
        *(unsigned char *)(a2[2] + v7) = (int)*(double *)(v5 + v8);
        v8 += *(void *)(a1 + 48);
        ++v7;
        if (v8 >= v6) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (a2[1] > v9)
    {
      *(void *)(a2[2] + v9) = *(void *)(v5 + v10);
      v10 += *(void *)(a1 + 48);
      ++v9;
      if (v10 >= v6) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::GeomModelDescriptor::makeConvertedValues<unsigned char>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((3u >> v4) & 1) == 0 || v4 > 5) && v4 != 1 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<unsigned char>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 1;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      unint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      uint64_t v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<unsigned char>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,signed char>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 2:
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,short>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,int>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,float>((uint64_t)a1, &v8);
      goto LABEL_9;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<signed char,double>((uint64_t)a1, &v8);
LABEL_9:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::GeomModelDescriptor::makeConvertedValues<short>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((0xCu >> v4) & 1) == 0 || v4 > 5) && v4 != 2 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<short>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 2;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      uint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      uint64_t v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<short>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<short,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<short,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 2:
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<short,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<short,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<short,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<short,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_10:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,signed char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = *(char *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 2;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = *(_WORD *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_WORD *)(a2[2] + 2 * v12) = *(_WORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = *(_DWORD *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_DWORD *)(a2[2] + v12) = *(_DWORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 2;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,unsigned char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = *(unsigned __int8 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 2;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,float>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = (int)*(float *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_DWORD *)(a2[2] + v12) = *(_DWORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 2;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<short,double>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_WORD *)(v10 + 2 * v8) = (int)*(double *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(void *)(a2[2] + v12) = *(void *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 2;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::GeomModelDescriptor::makeConvertedValues<unsigned short>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((0xCu >> v4) & 1) == 0 || v4 > 5) && v4 != 3 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<unsigned short>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 2;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      uint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      uint64_t v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<unsigned short>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<short,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<short,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 2:
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<short,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<short,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<short,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_10;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<short,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_10:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::GeomModelDescriptor::makeConvertedValues<int>(_anonymous_namespace_ **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (*a1)
  {
    unsigned int v4 = *((unsigned __int8 *)v3 + 33);
    if ((((0x30u >> v4) & 1) == 0 || v4 > 5) && v4 != 4 || *((unsigned char *)v3 + 32) == 0)
    {
      re::internal::DataPayload::computePoDConversionHelper<int>(*a1, (uint64_t)v12);
      if (v12[0])
      {
        uint64_t v8 = v14;
        a2[4] = v13;
        a2[5] = v8;
        uint64_t v9 = v15;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v13 = 0;
        a2[6] = v9;
        *a2 = v9;
        a2[1] = 4;
        a2[2] = v8;
        a2[3] = 0;
      }
      else
      {
        a2[6] = 0;
        *((_OWORD *)a2 + 1) = 0u;
        *((_OWORD *)a2 + 2) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v12);
    }
    else
    {
      uint64_t v10 = (char *)v3 + 8;
      *a2 = *((void *)v3 + 3) + *((void *)v3 + 7);
      *(int8x16_t *)(a2 + 1) = vextq_s8(*(int8x16_t *)((char *)v3 + 40), *(int8x16_t *)((char *)v3 + 40), 8uLL);
      a2[3] = v3;
      uint64_t v11 = (char *)v3 + 8;
      a2[5] = 0;
      a2[6] = 0;
      a2[4] = 0;
    }
  }
  else
  {
    a2[6] = 0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<int>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 2:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,unsigned short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 4:
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<unsigned int,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<int,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_11;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<int,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_11:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      unint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<int,float>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = (int)*(float *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<int,double>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = (int)*(double *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(void *)(a2[2] + v12) = *(void *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::GeomModelDescriptor::AttributeData::makeConvertedValues<float>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    unint64_t v4 = (void *)(v3 + 8);
    id v5 = (id)(v3 + 8);
    if (*(unsigned char *)(v3 + 32)) {
      BOOL v6 = *(unsigned char *)(v3 + 33) == 6;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      id v9 = v4;
      *(void *)a2 = *(void *)(v3 + 24) + *(void *)(v3 + 56);
      *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)(v3 + 40), *(int8x16_t *)(v3 + 40), 8uLL);
      *(void *)(a2 + 24) = v3;
      id v10 = v4;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
    }
    else
    {
      re::internal::DataPayload::computePoDConversionHelper<float>((_anonymous_namespace_ *)v3, (uint64_t)v11);
      if (v11[0])
      {
        uint64_t v7 = v13;
        *(void *)(a2 + 32) = v12;
        *(void *)(a2 + 40) = v7;
        uint64_t v8 = v14;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        *(void *)(a2 + 48) = v8;
        *(void *)a2 = v8;
        *(void *)(a2 + 8) = 4;
        *(void *)(a2 + 16) = v7;
        *(void *)(a2 + 24) = 0;
      }
      else
      {
        *(void *)(a2 + 48) = 0;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v11);
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<float>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<float,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 2:
      re::internal::DataPayload::computeConvertedValuesInternal<float,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 4:
      re::internal::DataPayload::computeConvertedValuesInternal<float,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<float,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<float,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_12:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      uint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      uint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,signed char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(float *)(v10 + 4 * v8) = (float)*(char *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(float *)(v10 + 4 * v8) = (float)*(__int16 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_WORD *)(a2[2] + v12) = *(_WORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 4;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(float *)(v10 + 4 * v8) = (float)*(int *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v8 = v6 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v8)
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v12 = a2[1];
      uint64_t v11 = a2[2];
      while (v12 != v9)
      {
        LOBYTE(v5) = *(unsigned char *)(v7 + v10);
        float v5 = (float)LODWORD(v5);
        *(float *)(v11 + 4 * v9) = v5;
        v10 += v6;
        ++v9;
        if (v10 >= v8) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(unsigned char *)(a2[2] + v13) = *(unsigned char *)(v7 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 4;
      if (v15 >= v8) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v8 = v6 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v8)
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v12 = a2[1];
      uint64_t v11 = a2[2];
      while (v12 != v9)
      {
        LOWORD(v5) = *(_WORD *)(v7 + v10);
        float v5 = (float)LODWORD(v5);
        *(float *)(v11 + 4 * v9) = v5;
        v10 += v6;
        ++v9;
        if (v10 >= v8) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(_WORD *)(a2[2] + v13) = *(_WORD *)(v7 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 4;
      if (v15 >= v8) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,unsigned int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(float *)(v10 + 4 * v8) = (float)*(unsigned int *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,float>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(_DWORD *)(v10 + 4 * v8) = *(_DWORD *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(_DWORD *)(a2[2] + 4 * v12) = *(_DWORD *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<float,double>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        float v12 = *(double *)(v6 + v9);
        *(float *)(v10 + 4 * v8) = v12;
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(void *)(a2[2] + v13) = *(void *)(v6 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 4;
      if (v15 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::GeomModelDescriptor::AttributeData::makeConvertedValues<double>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    unint64_t v4 = (void *)(v3 + 8);
    id v5 = (id)(v3 + 8);
    if (*(unsigned char *)(v3 + 32)) {
      BOOL v6 = *(unsigned char *)(v3 + 33) == 7;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      id v9 = v4;
      *(void *)a2 = *(void *)(v3 + 24) + *(void *)(v3 + 56);
      *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)(v3 + 40), *(int8x16_t *)(v3 + 40), 8uLL);
      *(void *)(a2 + 24) = v3;
      id v10 = v4;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
    }
    else
    {
      re::internal::DataPayload::computePoDConversionHelper<double>((_anonymous_namespace_ *)v3, (uint64_t)v11);
      if (v11[0])
      {
        uint64_t v7 = v13;
        *(void *)(a2 + 32) = v12;
        *(void *)(a2 + 40) = v7;
        uint64_t v8 = v14;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        *(void *)(a2 + 48) = v8;
        *(void *)a2 = v8;
        *(void *)(a2 + 8) = 8;
        *(void *)(a2 + 16) = v7;
        *(void *)(a2 + 24) = 0;
      }
      else
      {
        *(void *)(a2 + 48) = 0;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v11);
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 re::internal::DataPayload::computePoDConversionHelper<double>@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  switch(*((unsigned char *)a1 + 33))
  {
    case 0:
      re::internal::DataPayload::computeConvertedValuesInternal<double,signed char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 1:
      re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned char>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 2:
      re::internal::DataPayload::computeConvertedValuesInternal<double,short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 3:
      re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned short>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 4:
      re::internal::DataPayload::computeConvertedValuesInternal<double,int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 5:
      re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned int>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 6:
      re::internal::DataPayload::computeConvertedValuesInternal<double,float>((uint64_t)a1, (uint64_t *)&v8);
      goto LABEL_12;
    case 7:
      re::internal::DataPayload::computeConvertedValuesInternal<double,double>((uint64_t)a1, (uint64_t *)&v8);
LABEL_12:
      __n128 result = v8;
      uint64_t v7 = v9;
      *(unsigned char *)a2 = 1;
      *(__n128 *)(a2 + 8) = result;
      *(void *)(a2 + 24) = v7;
      return result;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      uint64_t v3 = "Could not convert values to specified output type.";
      goto LABEL_3;
    default:
      uint64_t v3 = "Unrecognized/Unsupported type.";
LABEL_3:
      __n128 result = v8;
      uint64_t v5 = v9;
      uint64_t v6 = v10;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(__n128 *)(a2 + 24) = result;
      *(void *)(a2 + 40) = v5;
      *(void *)(a2 + 48) = v6;
      return result;
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,signed char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(double *)(v10 + 8 * v8) = (double)*(char *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(unsigned char *)(a2[2] + v12) = *(unsigned char *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 8;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(double *)(v10 + 8 * v8) = (double)*(__int16 *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_WORD *)(a2[2] + v12) = *(_WORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 8;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(double *)(v10 + 8 * v8) = (double)*(int *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_DWORD *)(a2[2] + v12) = *(_DWORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 8;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned char>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v8 = v6 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v8)
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v12 = a2[1];
      uint64_t v11 = a2[2];
      while (v12 != v9)
      {
        LOBYTE(v5) = *(unsigned char *)(v7 + v10);
        double v5 = (double)*(unint64_t *)&v5;
        *(double *)(v11 + 8 * v9) = v5;
        v10 += v6;
        ++v9;
        if (v10 >= v8) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(unsigned char *)(a2[2] + v13) = *(unsigned char *)(v7 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 8;
      if (v15 >= v8) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned short>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v8 = v6 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v8)
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v12 = a2[1];
      uint64_t v11 = a2[2];
      while (v12 != v9)
      {
        LOWORD(v5) = *(_WORD *)(v7 + v10);
        double v5 = (double)*(unint64_t *)&v5;
        *(double *)(v11 + 8 * v9) = v5;
        v10 += v6;
        ++v9;
        if (v10 >= v8) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(_WORD *)(a2[2] + v13) = *(_WORD *)(v7 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 8;
      if (v15 >= v8) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,unsigned int>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v8 = v6 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v8)
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v12 = a2[1];
      uint64_t v11 = a2[2];
      while (v12 != v9)
      {
        LODWORD(v5) = *(_DWORD *)(v7 + v10);
        double v5 = (double)*(unint64_t *)&v5;
        *(double *)(v11 + 8 * v9) = v5;
        v10 += v6;
        ++v9;
        if (v10 >= v8) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    while (a2[1] > v14)
    {
      *(_DWORD *)(a2[2] + v13) = *(_DWORD *)(v7 + v15);
      v15 += *(void *)(a1 + 48);
      ++v14;
      v13 += 8;
      if (v15 >= v8) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,float>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(double *)(v10 + 8 * v8) = *(float *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    while (a2[1] > v13)
    {
      *(_DWORD *)(a2[2] + v12) = *(_DWORD *)(v6 + v14);
      v14 += *(void *)(a1 + 48);
      ++v13;
      v12 += 8;
      if (v14 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::internal::DataPayload::computeConvertedValuesInternal<double,double>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
  unint64_t v7 = v5 * *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      uint64_t v11 = a2[1];
      uint64_t v10 = a2[2];
      while (v11 != v8)
      {
        *(void *)(v10 + 8 * v8) = *(void *)(v6 + v9);
        v9 += v5;
        ++v8;
        if (v9 >= v7) {
          return;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    while (a2[1] > v12)
    {
      *(void *)(a2[2] + 8 * v12) = *(void *)(v6 + v13);
      v13 += *(void *)(a1 + 48);
      ++v12;
      if (v13 >= v7) {
        return;
      }
    }
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void _ZNK2re19GeomModelDescriptor13AttributeData19makeConvertedValuesIDv2_fEENS0_15ConvertedValuesIT_EEv(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    unint64_t v4 = (void *)(v3 + 8);
    id v5 = (id)(v3 + 8);
    if (*(unsigned char *)(v3 + 32)) {
      BOOL v6 = *(unsigned char *)(v3 + 33) == 8;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      id v9 = v4;
      *(void *)a2 = *(void *)(v3 + 24) + *(void *)(v3 + 56);
      *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)(v3 + 40), *(int8x16_t *)(v3 + 40), 8uLL);
      *(void *)(a2 + 24) = v3;
      id v10 = v4;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
    }
    else
    {
      _ZNK2re8internal11DataPayload22computeConvertedValuesIDv2_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv(v3, (uint64_t)v11);
      if (v11[0])
      {
        uint64_t v7 = v13;
        *(void *)(a2 + 32) = v12;
        *(void *)(a2 + 40) = v7;
        uint64_t v8 = v14;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        *(void *)(a2 + 48) = v8;
        *(void *)a2 = v8;
        *(void *)(a2 + 8) = 8;
        *(void *)(a2 + 16) = v7;
        *(void *)(a2 + 24) = 0;
      }
      else
      {
        *(void *)(a2 + 48) = 0;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v11);
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 _ZNK2re8internal11DataPayload22computeConvertedValuesIDv2_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 33) == 8)
  {
    uint64_t v4 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
    unint64_t v5 = *(void *)(a1 + 40);
    unint64_t v6 = *(void *)(a1 + 48) * v5;
    __n128 v14 = 0uLL;
    uint64_t v15 = 0;
    if (*(unsigned char *)(a1 + 32))
    {
      if (v6)
      {
        unint64_t v7 = 0;
        unint64_t v8 = 0;
        while (1)
        {
          unint64_t v9 = v14.n128_u64[1];
          if (v14.n128_u64[1] <= v8) {
            break;
          }
          *(void *)(v15 + 8 * v8) = *(void *)(v4 + v7);
          v7 += *(void *)(a1 + 48);
          ++v8;
          if (v7 >= v6) {
            goto LABEL_13;
          }
        }
        uint64_t v16 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        __n128 v25 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v17 = 136315906;
        long long v18 = "operator[]";
        __int16 v19 = 1024;
        int v20 = 468;
        __int16 v21 = 2048;
        unint64_t v22 = v8;
        __int16 v23 = 2048;
        unint64_t v24 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_16;
      }
    }
    else if (v6)
    {
      unint64_t v8 = 0;
      unint64_t v12 = 0;
      while (1)
      {
        unint64_t v9 = v14.n128_u64[1];
        if (v14.n128_u64[1] <= v8) {
          break;
        }
        *(void *)(v15 + 8 * v8) = *(void *)(v4 + v12);
        v12 += *(void *)(a1 + 48);
        ++v8;
        if (v12 >= v6) {
          goto LABEL_13;
        }
      }
LABEL_16:
      uint64_t v16 = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      __n128 v25 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v17 = 136315906;
      long long v18 = "operator[]";
      __int16 v19 = 1024;
      int v20 = 468;
      __int16 v21 = 2048;
      unint64_t v22 = v8;
      __int16 v23 = 2048;
      unint64_t v24 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_13:
    __n128 result = v14;
    uint64_t v13 = v15;
    *(unsigned char *)a2 = 1;
    *(__n128 *)(a2 + 8) = result;
    *(void *)(a2 + 24) = v13;
  }
  else
  {
    __n128 result = v25;
    long long v11 = v26;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = result;
    *(_OWORD *)(a2 + 40) = v11;
  }
  return result;
}

__n128 _ZNK2re8internal11DataPayload22computeConvertedValuesIDv3_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if ((*(unsigned __int8 *)(a1 + 33) | 2) == 0xB)
  {
    uint64_t v4 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
    unint64_t v5 = *(void *)(a1 + 40);
    unint64_t v6 = *(void *)(a1 + 48) * v5;
    __n128 v15 = 0uLL;
    uint64_t v16 = 0;
    if (*(unsigned char *)(a1 + 32))
    {
      if (v6)
      {
        unint64_t v8 = 0;
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v10 = v15.n128_u64[1];
          if (v15.n128_u64[1] <= v9) {
            break;
          }
          *(void *)&long long v7 = *(void *)(v4 + v8);
          DWORD2(v7) = *(_DWORD *)(v4 + v8 + 8);
          *(_OWORD *)(v16 + 16 * v9) = v7;
          v8 += *(void *)(a1 + 48);
          ++v9;
          if (v8 >= v6) {
            goto LABEL_13;
          }
        }
        uint64_t v17 = 0;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        __n128 v26 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v18 = 136315906;
        __int16 v19 = "operator[]";
        __int16 v20 = 1024;
        int v21 = 468;
        __int16 v22 = 2048;
        unint64_t v23 = v9;
        __int16 v24 = 2048;
        unint64_t v25 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_16;
      }
    }
    else if (v6)
    {
      unint64_t v9 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        unint64_t v10 = v15.n128_u64[1];
        if (v15.n128_u64[1] <= v9) {
          break;
        }
        *(void *)&long long v7 = *(void *)(v4 + v13);
        DWORD2(v7) = *(_DWORD *)(v4 + v13 + 8);
        *(_OWORD *)(v16 + 16 * v9) = v7;
        v13 += *(void *)(a1 + 48);
        ++v9;
        if (v13 >= v6) {
          goto LABEL_13;
        }
      }
LABEL_16:
      uint64_t v17 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      __n128 v26 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v18 = 136315906;
      __int16 v19 = "operator[]";
      __int16 v20 = 1024;
      int v21 = 468;
      __int16 v22 = 2048;
      unint64_t v23 = v9;
      __int16 v24 = 2048;
      unint64_t v25 = v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_13:
    __n128 result = v15;
    uint64_t v14 = v16;
    *(unsigned char *)a2 = 1;
    *(__n128 *)(a2 + 8) = result;
    *(void *)(a2 + 24) = v14;
  }
  else
  {
    __n128 result = v26;
    long long v12 = v27;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = result;
    *(_OWORD *)(a2 + 40) = v12;
  }
  return result;
}

void _ZNK2re19GeomModelDescriptor13AttributeData19makeConvertedValuesIDv4_fEENS0_15ConvertedValuesIT_EEv(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = (void *)(v3 + 8);
    id v5 = (id)(v3 + 8);
    if (*(unsigned char *)(v3 + 32)) {
      BOOL v6 = *(unsigned char *)(v3 + 33) == 10;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      id v9 = v4;
      *(void *)a2 = *(void *)(v3 + 24) + *(void *)(v3 + 56);
      *(int8x16_t *)(a2 + 8) = vextq_s8(*(int8x16_t *)(v3 + 40), *(int8x16_t *)(v3 + 40), 8uLL);
      *(void *)(a2 + 24) = v3;
      id v10 = v4;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
    }
    else
    {
      _ZNK2re8internal11DataPayload22computeConvertedValuesIDv4_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv(v3, (uint64_t)v11);
      if (v11[0])
      {
        uint64_t v7 = v13;
        *(void *)(a2 + 32) = v12;
        *(void *)(a2 + 40) = v7;
        uint64_t v8 = v14;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        *(void *)(a2 + 48) = v8;
        *(void *)a2 = v8;
        *(void *)(a2 + 8) = 16;
        *(void *)(a2 + 16) = v7;
        *(void *)(a2 + 24) = 0;
      }
      else
      {
        *(void *)(a2 + 48) = 0;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
      }
      re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v11);
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
}

__n128 _ZNK2re8internal11DataPayload22computeConvertedValuesIDv4_fEENS_6ResultINS_10FixedArrayIT_EENS_13DetailedErrorEEEv@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 33) == 10)
  {
    uint64_t v4 = *(void *)(a1 + 24) + *(void *)(a1 + 56);
    unint64_t v5 = *(void *)(a1 + 40);
    unint64_t v6 = *(void *)(a1 + 48) * v5;
    __n128 v14 = 0uLL;
    uint64_t v15 = 0;
    if (*(unsigned char *)(a1 + 32))
    {
      if (v6)
      {
        unint64_t v7 = 0;
        unint64_t v8 = 0;
        while (1)
        {
          unint64_t v9 = v14.n128_u64[1];
          if (v14.n128_u64[1] <= v8) {
            break;
          }
          *(_OWORD *)(v15 + 16 * v8) = *(_OWORD *)(v4 + v7);
          v7 += *(void *)(a1 + 48);
          ++v8;
          if (v7 >= v6) {
            goto LABEL_13;
          }
        }
        uint64_t v16 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        __n128 v25 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v17 = 136315906;
        int v18 = "operator[]";
        __int16 v19 = 1024;
        int v20 = 468;
        __int16 v21 = 2048;
        unint64_t v22 = v8;
        __int16 v23 = 2048;
        unint64_t v24 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_16;
      }
    }
    else if (v6)
    {
      unint64_t v8 = 0;
      unint64_t v12 = 0;
      while (1)
      {
        unint64_t v9 = v14.n128_u64[1];
        if (v14.n128_u64[1] <= v8) {
          break;
        }
        *(_OWORD *)(v15 + 16 * v8) = *(_OWORD *)(v4 + v12);
        v12 += *(void *)(a1 + 48);
        ++v8;
        if (v12 >= v6) {
          goto LABEL_13;
        }
      }
LABEL_16:
      uint64_t v16 = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      __n128 v25 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v17 = 136315906;
      int v18 = "operator[]";
      __int16 v19 = 1024;
      int v20 = 468;
      __int16 v21 = 2048;
      unint64_t v22 = v8;
      __int16 v23 = 2048;
      unint64_t v24 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_13:
    __n128 result = v14;
    uint64_t v13 = v15;
    *(unsigned char *)a2 = 1;
    *(__n128 *)(a2 + 8) = result;
    *(void *)(a2 + 24) = v13;
  }
  else
  {
    __n128 result = v25;
    long long v11 = v26;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = result;
    *(_OWORD *)(a2 + 40) = v11;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v5 + 24 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v5 + 24 * v3 + 12) == a2) {
        return v5 + 24 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

void re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add(uint64_t a1, _DWORD *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  unint64_t v9 = *(void *)a1;
  if (*(void *)a1)
  {
    unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(_DWORD *)(v16 + 24 * v10 + 12) == v6) {
        return;
      }
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v16 + 24 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v16 + 24 * v10 + 12) == v6) {
          return;
        }
      }
    }
  }
  uint64_t v11 = *(unsigned int *)(a1 + 36);
  if (v11 == 0x7FFFFFFF)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    int v12 = v11;
    if (v11 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(a1 + 24);
      int v12 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  uint64_t v15 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(v15 + 4 * v9);
  *(void *)(*(void *)(a1 + 16) + 24 * v11) = v8;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 12) = *a2;
  *(void *)(*(void *)(a1 + 16) + 24 * v11 + 16) = *a3;
  *(_DWORD *)(v15 + 4 * v9) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

uint64_t re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(uint64_t result, _DWORD *a2, uint64_t a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(_DWORD *)(v11 + 56 * v10 + 12) == v6) {
        return result;
      }
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v11 + 56 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v11 + 56 * v10 + 12) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  __n128 result = re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v5 + 56 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 56 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v5 + 56 * v3 + 12) == a2) {
        return v5 + 56 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 56 * v3 + 16;
}

void re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::resize(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= a2)
  {
    if (v5 <= a2) {
      return;
    }
    uint64_t v9 = 48 * a2;
    unint64_t v10 = a2;
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(*(void *)(a1 + 32) + v9));
      ++v10;
      v9 += 48;
    }
    while (v10 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity((void *)a1, a2);
      unint64_t v5 = *(void *)(a1 + 16);
    }
    unint64_t v7 = a2 - v5;
    if (a2 > v5)
    {
      uint64_t v8 = 48 * v5;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(*(void *)(a1 + 32) + v8, a3);
        v8 += 48;
        --v7;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)unint64_t v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<unsigned int,unsigned long,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 12) = *((_DWORD *)v13 - 1);
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v29, 0, 36);
          *(void *)&v29[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v29, v13, v12);
          long long v15 = *(_OWORD *)v29;
          *(_OWORD *)long long v29 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v29[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v29[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v29[24];
          *(_OWORD *)&v29[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v29[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned int,re::DynamicArray<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21 - 4, v21);
              }
              v21 += 56;
              --v20;
            }
            while (v20);
          }
          re::HashTable<int,re::DynamicArray<re::RenderGraphProviderBase const*>,re::Hash<int>,re::EqualTo<int>,true,false>::deinit((uint64_t *)v29);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 56 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 56 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v9) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 12) = *a4;
  uint64_t v25 = *(void *)(a1 + 16) + 56 * v9;
  *(void *)(v25 + 48) = 0;
  *(_DWORD *)(v25 + 40) = 0;
  *(void *)(v25 + 24) = 0;
  *(void *)(v25 + 32) = 0;
  *(void *)(v25 + 16) = 0;
  *(void *)(v25 + 16) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(v25 + 24) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  uint64_t v26 = *(void *)(v25 + 32);
  *(void *)(v25 + 32) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v26;
  uint64_t v27 = *(void *)(v25 + 48);
  *(void *)(v25 + 48) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v27;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v25 + 40);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::Result<re::GeomModel,re::DetailedError>::Result(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  *(unsigned char *)a1 = v4;
  long long v5 = (_OWORD *)(a1 + 8);
  if (v4)
  {
    *long long v5 = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(void *)(a1 + 32) = *((void *)a2 + 4);
    uint64_t v6 = *((void *)a2 + 2);
    *(void *)(a1 + 8) = *((void *)a2 + 1);
    *((void *)a2 + 1) = 0;
    uint64_t v7 = *((void *)a2 + 3);
    *((void *)a2 + 4) = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v8 = *(void *)(a1 + 24);
    *(void *)(a1 + 16) = v6;
    *(void *)(a1 + 24) = v7;
    *((void *)a2 + 2) = v9;
    *((void *)a2 + 3) = v8;
    *(void *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 40) = 0;
    uint64_t v10 = *((void *)a2 + 6);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(void *)(a1 + 48) = v10;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    uint64_t v11 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = *((void *)a2 + 7);
    *((void *)a2 + 7) = v11;
    uint64_t v12 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *((void *)a2 + 9) = v12;
    ++*((_DWORD *)a2 + 16);
    ++*(_DWORD *)(a1 + 64);
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    uint64_t v13 = *((void *)a2 + 11);
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    *(void *)(a1 + 88) = v13;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    uint64_t v14 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = *((void *)a2 + 12);
    *((void *)a2 + 12) = v14;
    uint64_t v15 = *(void *)(a1 + 112);
    *(void *)(a1 + 112) = *((void *)a2 + 14);
    *((void *)a2 + 14) = v15;
    ++*((_DWORD *)a2 + 26);
    ++*(_DWORD *)(a1 + 104);
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 120, a2 + 120);
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 168, a2 + 168);
    *(void *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 240) = 0;
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 216) = 0;
    uint64_t v16 = *((void *)a2 + 28);
    *(void *)(a1 + 216) = *((void *)a2 + 27);
    *(void *)(a1 + 224) = v16;
    *((void *)a2 + 27) = 0;
    *((void *)a2 + 28) = 0;
    uint64_t v17 = *(void *)(a1 + 232);
    *(void *)(a1 + 232) = *((void *)a2 + 29);
    *((void *)a2 + 29) = v17;
    uint64_t v18 = *(void *)(a1 + 248);
    *(void *)(a1 + 248) = *((void *)a2 + 31);
    *((void *)a2 + 31) = v18;
    ++*((_DWORD *)a2 + 60);
    ++*(_DWORD *)(a1 + 240);
  }
  else
  {
    *long long v5 = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    *(void *)(a1 + 48) = *((void *)a2 + 6);
    uint64_t v19 = *((void *)a2 + 4);
    *(void *)(a1 + 24) = *((void *)a2 + 3);
    *((void *)a2 + 3) = 0;
    uint64_t v20 = *((void *)a2 + 5);
    *((void *)a2 + 6) = 0;
    uint64_t v22 = *(void *)(a1 + 32);
    uint64_t v21 = *(void *)(a1 + 40);
    *(void *)(a1 + 32) = v19;
    *(void *)(a1 + 40) = v20;
    *((void *)a2 + 4) = v22;
    *((void *)a2 + 5) = v21;
  }
  return a1;
}

BOOL re::hasTransformAnimation(re *this, const MDLObject *a2)
{
  if (!this) {
    return 0;
  }
  unint64_t v2 = [(re *)this transform];
  uint64_t v3 = v2;
  if (v2)
  {
    int v4 = [v2 keyTimes];
    BOOL v5 = (unint64_t)[v4 count] > 1;
  }
  else
  {
    BOOL v5 = 0;
  }

  return v5;
}

void re::importSRTSampledAnimation(re *this@<X0>, MDLObject *a2@<X1>, float a3@<S0>, uint64_t a4@<X8>)
{
  uint64_t v8 = this;
  if (!re::hasTransformAnimation(v8, v9))
  {
    id v12 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v55, [v12 UTF8String]);
    long long v20 = v55;
    uint64_t v21 = v56;
    uint64_t v22 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v23 = 2000;
LABEL_9:
    *(void *)(a4 + 8) = v23;
    *(void *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v20;
    *(void *)(a4 + 40) = v21;
    *(void *)(a4 + 48) = v22;
    goto LABEL_10;
  }
  if (a3 <= 0.0 || (float v10 = fabsf(a3), v10 < (float)((float)(v10 + 1.0) * 0.00001)))
  {
    id v12 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"Sample Rate = %f. Processing node \"%s\"", (re::DynamicString *)&v55, a3, [v12 UTF8String]);
    long long v20 = v55;
    uint64_t v21 = v56;
    uint64_t v22 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v23 = 2001;
    goto LABEL_9;
  }
  uint64_t v11 = [(re *)v8 transform];
  id v12 = v11;
  if (!v11)
  {
    id v15 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v55, [v15 UTF8String]);
    long long v16 = v55;
    uint64_t v17 = v56;
    uint64_t v18 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v19 = 2002;
    goto LABEL_14;
  }
  uint64_t v13 = [v11 keyTimes];
  unint64_t v14 = [v13 count];

  if (v14 <= 1)
  {
    id v15 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v55, [v15 UTF8String]);
    long long v16 = v55;
    uint64_t v17 = v56;
    uint64_t v18 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v19 = 2003;
LABEL_14:
    *(void *)(a4 + 8) = v19;
    *(void *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v16;
    *(void *)(a4 + 40) = v17;
    *(void *)(a4 + 48) = v18;

    goto LABEL_10;
  }
  [v12 minimumTime];
  double v25 = v24;
  [v12 maximumTime];
  if (v25 > v26)
  {
    [v12 minimumTime];
    uint64_t v28 = v27;
    [v12 maximumTime];
    uint64_t v30 = v29;
    id v15 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"MinTime = %lf, MaxTime = %lf, Processing node \"%s\"", (re::DynamicString *)&v55, v28, v30, [v15 UTF8String]);
    long long v16 = v55;
    uint64_t v17 = v56;
    uint64_t v18 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v19 = 2004;
    goto LABEL_14;
  }
  [v12 minimumTime];
  float v32 = v31;
  int v33 = (_anonymous_namespace_ *)[v12 maximumTime];
  float v35 = v34;
  uint64_t v61 = 0;
  v58[1] = 0;
  unint64_t v59 = 0;
  int v60 = 0;
  int v36 = vcvtps_s32_f32(v32 / a3);
  int v37 = vcvtms_s32_f32(v35 / a3);
  unint64_t v38 = v37 - v36 + 3;
  re::DynamicArray<re::Matrix3x3<float>>::setCapacity(v58, v38);
  ++v60;
  float v39 = (float)(int)ceilf(v32 / a3) * a3;
  *(float *)&double v40 = vabds_f32(v32, v39);
  BOOL v41 = v39 >= v32 || v39 == v32;
  if (v41 || *(float *)&v40 <= 0.00001)
  {
    float v42 = (float)v37 * a3;
    BOOL v43 = v42 <= v35 || v42 == v35;
    if (v43 || vabds_f32(v42, v35) <= 0.00001)
    {
      if (v39 != v32 && *(float *)&v40 >= (float)((float)((float)(fabsf(v32) + fabsf(v39)) + 1.0) * 0.00001))
      {
        re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)v58, (uint64_t)&v55);
      }
      double v44 = 0.0;
      if (v37 >= v36)
      {
        int v45 = v37 + 1;
        do
        {
          double v44 = (float)((float)v36 * a3);
          re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)v58, (uint64_t)&v55);
          ++v36;
        }
        while (v45 != v36);
      }
      double v46 = v35;
      if (v44 != v35 && vabdd_f64(v46, v44) >= (fabs(v46) + fabs(v44) + 1.0) * 1.0e-12)
      {
        *(void *)&double v46 = re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)v58, (uint64_t)&v55).n128_u64[0];
      }
      unint64_t v47 = v59;
      if (v59 <= v38)
      {
        re::DynamicArray<re::AssetHandle>::operator=((uint64_t)&a2[11], (uint64_t)v58);
        *(float *)&a2[10].super.isa = v32;
        *((float *)&a2[10].super.isa + 1) = v35;
        *((float *)&a2[9].super.isa + 1) = a3;
        *(unsigned char *)a4 = 1;
        goto LABEL_42;
      }
      id v48 = [(re *)v8 name];
      re::DynamicString::format((re::DynamicString *)"Frame count = %ld. Max sample count = %ld, Processing node \"%s\"", (re::DynamicString *)&v55, v47, v38, [v48 UTF8String]);
      long long v49 = v55;
      uint64_t v50 = v56;
      uint64_t v51 = v57;
      *(unsigned char *)a4 = 0;
      uint64_t v52 = 2008;
    }
    else
    {
      double v54 = v42;
      id v48 = [(re *)v8 name];
      re::DynamicString::format((re::DynamicString *)"End time = %f. Calculated end time = %f, Processing node \"%s\"", (re::DynamicString *)&v55, v35, *(void *)&v54, [v48 UTF8String]);
      long long v49 = v55;
      uint64_t v50 = v56;
      uint64_t v51 = v57;
      *(unsigned char *)a4 = 0;
      uint64_t v52 = 2006;
    }
  }
  else
  {
    double v53 = v39;
    id v48 = [(re *)v8 name];
    re::DynamicString::format((re::DynamicString *)"Start time = %f. Calculated start time = %f, Processing node \"%s\"", (re::DynamicString *)&v55, v32, *(void *)&v53, [v48 UTF8String]);
    long long v49 = v55;
    uint64_t v50 = v56;
    uint64_t v51 = v57;
    *(unsigned char *)a4 = 0;
    uint64_t v52 = 2005;
  }
  *(void *)(a4 + 8) = v52;
  *(void *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v49;
  *(void *)(a4 + 40) = v50;
  *(void *)(a4 + 48) = v51;

LABEL_42:
  if (v58[0] && v61) {
    (*(void (**)(void))(*(void *)v58[0] + 40))();
  }
LABEL_10:
}

uint64_t anonymous namespace'::sampleTransform(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  [v5 localTransformAtTime:a3];
  long long v13 = v7;
  long long v14 = v6;
  long long v11 = v9;
  long long v12 = v8;

  v15[0] = v14;
  v15[1] = v13;
  v15[2] = v12;
  v15[3] = v11;
  *(void *)a1 = 0x3F8000003F800000;
  *(void *)(a1 + 8) = 1065353216;
  *(void *)(a1 + 24) = 0x3F80000000000000;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  return re::decomposeScaleRotationTranslation<float>((uint64_t)v15, (int32x4_t *)a1, (void *)(a1 + 16), (_OWORD *)(a1 + 32));
}

void re::importSRTSampledAnimationFromUSKNode(void *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a1;
  long long v6 = [MEMORY[0x263F83F10] transformKeyTimesWithNode:v5];
  long long v7 = v6;
  if (!v6)
  {
    id v8 = [v5 path];
    id v9 = [v8 stringValue];
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v33, [v9 UTF8String]);
    long long v10 = v33;
    uint64_t v12 = *((void *)&v34 + 1);
    uint64_t v11 = v34;
    *(unsigned char *)a3 = 0;
    uint64_t v13 = 2000;
    goto LABEL_10;
  }
  if ((unint64_t)[v6 arraySize] <= 1)
  {
    id v8 = [v5 path];
    id v9 = [v8 stringValue];
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v33, [v9 UTF8String]);
    long long v10 = v33;
    uint64_t v12 = *((void *)&v34 + 1);
    uint64_t v11 = v34;
    *(unsigned char *)a3 = 0;
    uint64_t v13 = 2003;
LABEL_10:
    *(void *)(a3 + 8) = v13;
    *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v10;
    *(void *)(a3 + 40) = v11;
    *(void *)(a3 + 48) = v12;
    goto LABEL_11;
  }
  float v14 = a2[19];
  if (v14 <= 0.0 || (float v15 = fabsf(v14), v15 < (float)((float)(v15 + 1.0) * 0.00001)))
  {
    double v23 = v14;
    id v8 = [v5 path];
    id v9 = [v8 stringValue];
    re::DynamicString::format((re::DynamicString *)"Sample Rate = %f. Processing node \"%s\"", (re::DynamicString *)&v33, *(void *)&v23, [v9 UTF8String]);
    long long v10 = v33;
    uint64_t v12 = *((void *)&v34 + 1);
    uint64_t v11 = v34;
    *(unsigned char *)a3 = 0;
    uint64_t v13 = 2001;
    goto LABEL_10;
  }
  id v8 = [v7 dataNoCopy];
  long long v16 = (double *)[v8 bytes];
  uint64_t v17 = (_anonymous_namespace_ *)[v7 arraySize];
  float v18 = *v16;
  float v19 = v16[(void)v17 - 1];
  if (v18 > v19)
  {
    id v9 = [v5 name];
    id v20 = [v9 stringValue];
    re::DynamicString::format((re::DynamicString *)"MinTime = %lf, MaxTime = %lf, Processing node \"%s\"", (re::DynamicString *)&v33, v18, v19, [v20 UTF8String]);
    long long v21 = v33;
    long long v22 = v34;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 2004;
    *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v21;
    *(_OWORD *)(a3 + 40) = v22;

LABEL_11:
    goto LABEL_12;
  }
  uint64_t v39 = 0;
  v37[1] = 0;
  void v37[2] = 0;
  int v38 = 0;
  re::DynamicArray<re::Matrix3x3<float>>::setCapacity(v37, (unint64_t)(float)((float)(v19 - v18) + 1.0));
  ++v38;
  if ((float)(int)v18 <= v19)
  {
    int v24 = (int)v18;
    do
    {
      [MEMORY[0x263F83F10] localTransformWithNode:v5 time:(double)v24];
      long long v33 = v25;
      long long v34 = v26;
      long long v35 = v27;
      long long v36 = v28;
      v30.i64[0] = 0x3F8000003F800000;
      v30.i64[1] = 1065353216;
      v31[0] = 0;
      v31[1] = 0x3F80000000000000;
      long long v32 = 0uLL;
      re::decomposeScaleRotationTranslation<float>((uint64_t)&v33, &v30, v31, &v32);
      re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)v37, (uint64_t)&v30);
      ++v24;
    }
    while ((float)v24 <= v19);
  }
  re::DynamicArray<re::AssetHandle>::operator=((uint64_t)(a2 + 22), (uint64_t)v37);
  float v29 = a2[19];
  a2[20] = v29 * v18;
  a2[21] = v29 * v19;
  *(unsigned char *)a3 = 1;
  if (v37[0] && v39) {
    (*(void (**)(void))(*(void *)v37[0] + 40))();
  }
LABEL_12:
}

id re::findMaterialPropertyString(re *this, MDLMaterial *a2, MDLMaterialSemantic a3)
{
  int v4 = this;
  long long v6 = re::findMaterialPropertyType(v4, a2, MDLMaterialSemanticSubsurface, v5);
  uint64_t v7 = [v6 stringValue];
  id v9 = (void *)v7;
  if (v6)
  {
    if (v7) {
      goto LABEL_3;
    }
LABEL_7:
    long long v10 = 0;
    goto LABEL_8;
  }
  long long v6 = re::findMaterialPropertyType(v4, a2, MDLMaterialSemanticMetallic, v8);
  uint64_t v11 = [v6 URLValue];
  uint64_t v12 = [v11 absoluteString];

  id v9 = (void *)v12;
  if (!v12) {
    goto LABEL_7;
  }
LABEL_3:
  if ([v9 length]) {
    long long v10 = v6;
  }
  else {
    long long v10 = 0;
  }
LABEL_8:
  id v13 = v10;

  return v13;
}

void re::gatherMaterialConstants(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  MDLMaterialPropertyType v5 = re::findMaterialPropertyType(v3, 0, MDLMaterialSemanticAnisotropic, v4);
  if (v5)
  {
  }
  else
  {
    id v9 = re::findMaterialPropertyType(v3, (MDLMaterial *)0xF, MDLMaterialSemanticSpecularTint, v6);

    if (!v9) {
      goto LABEL_10;
    }
  }
  __asm { FMOV            V0.4S, #1.0 }
  __n128 MaterialPropertyFloat3 = re::getMaterialPropertyFloat3(v3, 0, _Q0, v7, v8);
  float MaterialPropertyFloat = re::getMaterialPropertyFloat(v3, (MDLMaterial *)0xF, v15, 1.0, v16);
  float v19 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v105, "[%f, %f, %f, %f]", MaterialPropertyFloat3.n128_f32[0], MaterialPropertyFloat3.n128_f32[1], MaterialPropertyFloat3.n128_f32[2], MaterialPropertyFloat);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v106, (const re::DynamicString *)&v105);
  if (v106 && (v107 & 1) != 0) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v106 + 40))(v106, v108);
  }
  if (*(void *)v105.__x_ && (v105.__x_[2] & 1) != 0) {
    (*(void (**)(void))(**(void **)v105.__x_ + 40))();
  }
LABEL_10:
  id v20 = [(re *)v3 name];
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v21 = [v20 hash];
  v105.__x_[0] = v21;
  for (uint64_t i = 1; i != 624; ++i)
  {
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v21 = i + 1812433253 * (v21 ^ (v21 >> 30));
    v105.__x_[i] = v21;
  }
  v105.__i_ = 0;

  double v24 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v105)
                      * 2.3283e-10)
              + 0.0);
  double v25 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v105)
                      * 2.3283e-10)
              + 0.0);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v26 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v105);
  long long v27 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v106, "[%f, %f, %f]", v24, v25, (float)((float)((float)v26 * 2.3283e-10) + 0.0));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v103, (const re::DynamicString *)&v106);
  if (v103 && (v104 & 1) != 0) {
    (*(void (**)(void))(*(void *)v103 + 40))();
  }
  float v29 = re::findMaterialPropertyType(v3, (MDLMaterial *)0xD, MDLMaterialSemanticAnisotropic, v28);

  if (v29)
  {
    __n128 v98 = re::getMaterialPropertyFloat3(v3, (MDLMaterial *)0xD, (__n128)0, v30, v31);
    long long v33 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "[%f, %f, %f]", v98.n128_f32[0], v98.n128_f32[1], v98.n128_f32[2]);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
    long long v34 = v101;
    if (v101 && (v102 & 1) != 0) {
      long long v34 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v101 + 40))();
    }
    long long v35 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v101, "%f", 1.0);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v99, (const re::DynamicString *)&v101);
    long long v36 = v99;
    if (v99 && (v100 & 1) != 0) {
      long long v36 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v99 + 40))();
    }
    unint64_t v37 = re::Hash<re::DynamicString>::operator()((uint64_t)&v109, (uint64_t)&v99);
    unint64_t v38 = v37;
    if (*(void *)a1)
    {
      unint64_t v39 = v37 % *(unsigned int *)(a1 + 24);
      uint64_t v40 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v39);
      if (v40 != 0x7FFFFFFF)
      {
        uint64_t v41 = *(void *)(a1 + 16);
        while (!re::DynamicString::operator==(v41 + 80 * v40 + 16, (uint64_t)&v99))
        {
          uint64_t v40 = *(_DWORD *)(v41 + 80 * v40 + 8) & 0x7FFFFFFF;
          if (v40 == 0x7FFFFFFF) {
            goto LABEL_29;
          }
        }
        goto LABEL_35;
      }
    }
    else
    {
      LODWORD(v39) = 0;
    }
LABEL_29:
    uint64_t v42 = *(unsigned int *)(a1 + 36);
    if (v42 == 0x7FFFFFFF)
    {
      uint64_t v42 = *(unsigned int *)(a1 + 32);
      int v43 = v42;
      if (v42 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v39) = v38 % *(unsigned int *)(a1 + 24);
        int v43 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v43 + 1;
      uint64_t v44 = *(void *)(a1 + 16);
      int v45 = *(_DWORD *)(v44 + 80 * v42 + 8);
    }
    else
    {
      uint64_t v44 = *(void *)(a1 + 16);
      int v45 = *(_DWORD *)(v44 + 80 * v42 + 8);
      *(_DWORD *)(a1 + 36) = v45 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v44 + 80 * v42 + 8) = v45 | 0x80000000;
    *(_DWORD *)(*(void *)(a1 + 16) + 80 * v42 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v42 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v39);
    *(void *)(*(void *)(a1 + 16) + 80 * v42) = v38;
    double v46 = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 80 * v42 + 16), (const re::DynamicString *)&v99);
    unint64_t v47 = (re::DynamicString *)(*(void *)(a1 + 16) + 80 * v42 + 48);
    *(_DWORD *)(*(void *)(a1 + 8) + 4 * v39) = v42;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
LABEL_35:
    if (v99 && (v100 & 1) != 0) {
      (*(void (**)(void))(*(void *)v99 + 40))();
    }
    if (v101 && (v102 & 1) != 0) {
      (*(void (**)(void))(*(void *)v101 + 40))();
    }
    if (v103 && (v104 & 1) != 0) {
      (*(void (**)(void))(*(void *)v103 + 40))();
    }
  }
  id v48 = re::findMaterialPropertyString(v3, (MDLMaterial *)2, v30);
  if (v48)
  {
  }
  else
  {
    uint64_t v52 = re::findMaterialPropertyType(v3, (MDLMaterial *)2, MDLMaterialSemanticSpecular, v49);

    if (!v52)
    {
      float v53 = 0.0;
      goto LABEL_48;
    }
  }
  float v53 = 1.0;
LABEL_48:
  float v54 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)2, v50, v53, v51);
  uint64_t v56 = re::findMaterialPropertyType(v3, (MDLMaterial *)2, MDLMaterialSemanticSpecularTint, v55);

  if (v56 || v54 != 0.0)
  {
    unint64_t v59 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "%f", v54);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
    if (v101 && (v102 & 1) != 0) {
      (*(void (**)(void))(*(void *)v101 + 40))();
    }
    if (v103 && (v104 & 1) != 0) {
      (*(void (**)(void))(*(void *)v103 + 40))();
    }
  }
  int v60 = re::findMaterialPropertyType(v3, (MDLMaterial *)6, MDLMaterialSemanticSpecularTint, v58);

  if (v60)
  {
    float v63 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)6, v61, 1.0, v62);
    unsigned int v65 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "%f", v63);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
    if (v101 && (v102 & 1) != 0) {
      (*(void (**)(void))(*(void *)v101 + 40))();
    }
    if (v103 && (v104 & 1) != 0) {
      (*(void (**)(void))(*(void *)v103 + 40))();
    }
  }
  uint64_t v66 = re::findMaterialPropertyType(v3, (MDLMaterial *)0xB, MDLMaterialSemanticSpecularTint, v62);

  if (v66)
  {
    float v69 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)0xB, v67, 0.0, v68);
    unsigned int v71 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "%f", v69);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
    if (v101 && (v102 & 1) != 0) {
      (*(void (**)(void))(*(void *)v101 + 40))();
    }
    if (v103 && (v104 & 1) != 0) {
      (*(void (**)(void))(*(void *)v103 + 40))();
    }
  }
  uint64_t v72 = re::findMaterialPropertyString(v3, (MDLMaterial *)0x8000, v67);
  if (v72)
  {
  }
  else
  {
    unsigned int v76 = re::findMaterialPropertyType(v3, (MDLMaterial *)0x8000, MDLMaterialSemanticSpecular, v73);

    if (!v76)
    {
      float v77 = 0.01;
      goto LABEL_74;
    }
  }
  float v77 = 1.0;
LABEL_74:
  float v78 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)0x8000, v74, v77, v75);
  long long v80 = re::findMaterialPropertyType(v3, (MDLMaterial *)0x8000, MDLMaterialSemanticSpecularTint, v79);

  if (v80 || v78 != 0.01)
  {
    uint64_t v83 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "%f", v78);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
    if (v101 && (v102 & 1) != 0) {
      (*(void (**)(void))(*(void *)v101 + 40))();
    }
    if (v103 && (v104 & 1) != 0) {
      (*(void (**)(void))(*(void *)v103 + 40))();
    }
  }
  uint64_t v84 = re::findMaterialPropertyType(v3, (MDLMaterial *)0x10, MDLMaterialSemanticSpecularTint, v82);

  if (v84) {
    float v87 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)0x10, v85, 1.0, v86);
  }
  else {
    float v87 = 1.0;
  }
  uint64_t v88 = re::findMaterialPropertyType(v3, (MDLMaterial *)0x11, MDLMaterialSemanticSpecularTint, v86);

  float v92 = 1.5;
  if (v88) {
    float v92 = re::getMaterialPropertyFloat(v3, (MDLMaterial *)0x11, v90, 1.5, v91);
  }
  if (v87 <= 2.4) {
    float v93 = v87;
  }
  else {
    float v93 = 2.4;
  }
  if (v93 < 1.0) {
    float v93 = 1.0;
  }
  if (v92 > 2.4) {
    float v92 = 2.4;
  }
  if (v92 < 1.0) {
    float v92 = 1.0;
  }
  float v94 = (float)((float)((float)(v93 - v92) / (float)(v93 + v92)) * (float)((float)(v93 - v92) / (float)(v93 + v92)))
      / 0.08;
  if (v94 <= 1.0) {
    float v95 = v94;
  }
  else {
    float v95 = 1.0;
  }
  uint64_t v96 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v103, "%f", v95);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v101, (const re::DynamicString *)&v103);
  if (v101 && (v102 & 1) != 0) {
    (*(void (**)(void))(*(void *)v101 + 40))();
  }
  if (v103 && (v104 & 1) != 0) {
    (*(void (**)(void))(*(void *)v103 + 40))();
  }
  if (v106 && (v107 & 1) != 0) {
    (*(void (**)(void))(*(void *)v106 + 40))();
  }
}

__n128 re::getMaterialPropertyFloat3(re *a1, MDLMaterial *a2, __n128 a3, uint64_t a4, MDLMaterialPropertyType a5)
{
  MDLMaterialPropertyType v5 = re::findMaterialPropertyType(a1, a2, MDLMaterialSemanticAnisotropic, a5);
  MDLMaterialPropertyType v6 = v5;
  if (v5 && ![v5 isDefaultValue])
  {
    [v6 float3Value];
    a3 = v7;
  }

  return a3;
}

float re::getMaterialPropertyFloat(re *this, MDLMaterial *a2, MDLMaterialSemantic a3, float a4, MDLMaterialPropertyType a5)
{
  MDLMaterialPropertyType v6 = re::findMaterialPropertyType(this, a2, MDLMaterialSemanticSpecularTint, a5);
  __n128 v7 = v6;
  if (v6 && ([v6 isDefaultValue] & 1) == 0)
  {
    [v7 floatValue];
    a4 = v8;
  }

  return a4;
}

uint64_t re::isMaterialTransparent(re *this, MDLMaterial *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  unint64_t v2 = -[re propertiesWithSemantic:](this, "propertiesWithSemantic:", 15, 0);
  uint64_t v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v11;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v11 != v5) {
        objc_enumerationMutation(v2);
      }
      uint64_t v7 = *(void *)(*((void *)&v10 + 1) + 8 * v6);
      if ([(id)v7 type] == 3 || objc_msgSend((id)v7, "type") == 1)
      {
        uint64_t v7 = 1;
        goto LABEL_16;
      }
      if ([(id)v7 type] == 5) {
        break;
      }
      if (v4 == ++v6)
      {
        uint64_t v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
        uint64_t v7 = 0;
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_16;
      }
    }
    if (!v7) {
      goto LABEL_16;
    }
    if (([(id)v7 isDefaultValue] & 1) == 0)
    {
      [(id)v7 floatValue];
      uint64_t v7 = v9 < 0.99;
      goto LABEL_16;
    }
  }
  uint64_t v7 = 0;
LABEL_16:

  return v7;
}

id re::findMaterialPropertyType(re *this, MDLMaterial *a2, MDLMaterialSemantic a3, MDLMaterialPropertyType a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v5 = -[re propertiesWithSemantic:](this, "propertiesWithSemantic:", a2, a4, 0);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v14;
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        long long v10 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        if ([v10 type] == a3)
        {
          id v11 = v10;
          goto LABEL_11;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  id v11 = 0;
LABEL_11:

  return v11;
}

id re::createMDLMeshFromGeomMesh(re *this, const re::GeomMesh *a2, const char *a3)
{
  uint64_t v6 = (unsigned int *)v116;
  uint64_t v132 = *MEMORY[0x263EF8340];
  id v94 = objc_alloc_init(MEMORY[0x263F13630]);
  uint64_t v7 = (void *)[objc_alloc(MEMORY[0x263F13618]) initWithBufferAllocator:v94];
  uint64_t v8 = (unsigned int *)((char *)this + 16);
  [v7 setVertexCount:*((unsigned int *)this + 4)];
  id v98 = v7;
  float v9 = [v98 allocator];
  long long v10 = (void *)[v9 newBuffer:12 * *((unsigned int *)this + 4) type:1];

  id v11 = this;
  long long v12 = (uint64_t *)re::GeomMesh::accessVertexPositions(this);
  unint64_t v14 = v13;
  uint64_t v96 = v10;
  uint64_t v15 = [v10 map];
  uint64_t v16 = [(id)v15 bytes];
  uint64_t v106 = (uint64_t)v8;
  uint64_t v17 = *v8;
  if (v17)
  {
    unint64_t v18 = v14;
    float v19 = (_DWORD *)(v16 + 8);
    uint64_t v20 = v14;
    while (v20)
    {
      uint64_t v21 = v12[1];
      uint64_t v22 = *v12;
      v12 += 2;
      *((void *)v19 - 1) = v22;
      _DWORD *v19 = v21;
      v19 += 3;
      --v20;
      if (!--v17) {
        goto LABEL_5;
      }
    }
    goto LABEL_100;
  }
LABEL_5:

  id v23 = objc_alloc(MEMORY[0x263F13698]);
  uint64_t v24 = [v23 initWithName:*MEMORY[0x263F135C8] format:786435 offset:0 bufferIndex:0];
  id v25 = objc_alloc_init(MEMORY[0x263F136A8]);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v26 = [v25 layouts];
  MDLMaterialSemantic v90 = (void *)[objc_alloc(MEMORY[0x263F136A0]) initWithStride:12];
  MDLMaterialPropertyType v91 = v26;
  [v26 replaceObjectAtIndex:0 withObject:v90];
  float v93 = (void *)v24;
  [v25 addOrReplaceAttribute:v24];
  float v92 = v25;
  [v98 setVertexDescriptor:v25];
  uint64_t v119 = v10;
  long long v27 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v119 count:1];
  [v98 setVertexBuffers:v27];

  unsigned int v112 = 0;
  unint64_t v109 = 0;
  unint64_t v110 = 0;
  uint64_t v108 = 0;
  MDLMaterialPropertyType v28 = v11;
  int v111 = 0;
  float v29 = (unsigned char *)re::internal::GeomAttributeManager::attributeByName((re *)((char *)v11 + 64), (const char *)a2);
  if (v29
    && (uint64_t v30 = (uint64_t)v29, v29[16] == 2)
    && (*(unsigned int (**)(unsigned char *))(*(void *)v29 + 16))(v29) == *((_DWORD *)v11 + 10))
  {
    MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v30 + 16))(v30);
    if (!v31) {
      goto LABEL_64;
    }
    uint64_t v32 = re::internal::GeomTypedAttribute<int>::operator[](v30, 0);
    MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v30 + 16))(v30);
    LODWORD(v3) = v31;
LABEL_65:
    unsigned int v107 = 0;
    if (*((_DWORD *)v28 + 10))
    {
      unint64_t v39 = 0;
      LODWORD(v15) = 0;
      while (!v39)
      {
        unint64_t v74 = 0;
        unint64_t v14 = 0;
LABEL_77:
        LODWORD(__src) = v15;
        *((void *)v6 + 4) = 0;
        memset(v116, 0, sizeof(v116));
        re::DynamicArray<int>::setCapacity(v116, 1uLL);
        ++*(_DWORD *)&v116[24];
        re::DynamicArray<float>::copy(v116, 0, (char *)&__src, 1);
        uint64_t v15 = v107;
        if (v3 <= v107) {
          goto LABEL_101;
        }
        *(_DWORD *)uint64_t v114 = *(_DWORD *)(v32 + 4 * v107);
        re::DynamicArray<float>::DynamicArray((uint64_t)&v114[8], (uint64_t *)v116);
        uint64_t v15 = v74 + 1;
        if (v74 + 1 <= v14) {
          goto LABEL_102;
        }
        unint64_t v75 = v74;
        if (v74 >= v109)
        {
          re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::growCapacity(&v108, v74 + 1);
          unint64_t v75 = v110;
        }
        unsigned int v76 = v112;
        float v77 = &v112[12 * v75];
        if (v75 <= v14)
        {
          *float v77 = *(_DWORD *)v114;
          uint64_t v83 = &v76[12 * v75];
          *((void *)v83 + 5) = 0;
          *((void *)v83 + 2) = 0;
          *((void *)v83 + 3) = 0;
          *((void *)v83 + 1) = 0;
          v83[8] = 0;
          *((void *)v83 + 1) = *(void *)&v114[8];
          *(void *)&v114[8] = 0;
          *((void *)v83 + 2) = *(void *)&v114[16];
          *(void *)&v114[16] = 0;
          uint64_t v84 = *((void *)v83 + 3);
          *((void *)v83 + 3) = *(void *)&v114[24];
          *(void *)&v114[24] = v84;
          uint64_t v85 = *((void *)v83 + 5);
          *((void *)v83 + 5) = v115;
          uint64_t v115 = v85;
          ++*(_DWORD *)&v114[32];
          ++v83[8];
        }
        else
        {
          float v78 = &v112[12 * v75];
          *float v77 = *(v78 - 12);
          *((void *)v78 + 2) = 0;
          *((void *)v78 + 3) = 0;
          *((void *)v78 + 1) = *((void *)v78 - 5);
          long long v79 = *((_OWORD *)v78 - 2);
          *((void *)v78 - 4) = 0;
          *((void *)v78 - 3) = 0;
          *((void *)v78 - 5) = 0;
          *((_OWORD *)v78 + 1) = v79;
          *((void *)v78 + 5) = *((void *)v78 - 1);
          *((void *)v78 - 1) = 0;
          ++*(v78 - 4);
          v78[8] = 1;
          if (v77 - 12 != &v76[12 * v14])
          {
            long long v80 = &v76[12 * v75 - 24];
            uint64_t v81 = 48 * v14 - 48 * v75 + 48;
            do
            {
              v80[12] = *v80;
              re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v80 + 14), (uint64_t)(v80 + 2));
              v80 -= 12;
              v81 += 48;
            }
            while (v81);
            unsigned int v76 = v112;
            MDLMaterialPropertyType v28 = v11;
          }
          MDLMaterialPropertyType v82 = &v76[12 * v14];
          *MDLMaterialPropertyType v82 = *(_DWORD *)v114;
          re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v82 + 2), (uint64_t)&v114[8]);
          unint64_t v75 = v110;
        }
        unint64_t v39 = v75 + 1;
        unint64_t v110 = v39;
        ++v111;
        if (*(void *)&v114[8] && v115)
        {
          unint64_t v86 = v39;
          (*(void (**)(void, uint64_t))(**(void **)&v114[8] + 40))(*(void *)&v114[8], v115);
          unint64_t v39 = v86;
        }
        MDLMaterialPropertyType v31 = *(_anonymous_namespace_ **)v116;
        if (*(void *)v116)
        {
          uint64_t v87 = *((void *)v6 + 4);
          if (v87)
          {
            unint64_t v73 = v39;
            MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t))(**(void **)v116 + 40))(*(void *)v116, v87);
LABEL_94:
            unint64_t v39 = v73;
          }
        }
        LODWORD(v15) = v107 + 1;
        unsigned int v107 = v15;
        if (v15 >= *((_DWORD *)v28 + 10)) {
          goto LABEL_21;
        }
      }
      if (v3 <= v15) {
        goto LABEL_103;
      }
      unint64_t v14 = 0;
      int v71 = *(_DWORD *)(v32 + 4 * v15);
      MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)(v112 + 2);
      while (1)
      {
        int v72 = *((_DWORD *)v31 - 2);
        if (v72 == v71) {
          break;
        }
        if (v72 > v71)
        {
          unint64_t v74 = v39;
          goto LABEL_77;
        }
        ++v14;
        MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)((char *)v31 + 48);
        if (v39 == v14)
        {
          unint64_t v74 = v39;
          unint64_t v14 = v39;
          goto LABEL_77;
        }
      }
      unint64_t v73 = v39;
      MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)re::DynamicArray<int>::add(v31, &v107);
      goto LABEL_94;
    }
    unint64_t v39 = 0;
  }
  else
  {
    *(void *)&v114[32] = 0;
    memset(v114, 0, 28);
    LODWORD(__src) = 1;
    re::DynamicArray<float>::DynamicArray((uint64_t)&__src + 8, (uint64_t *)v114);
    re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::growCapacity(&v108, 1uLL);
    long long v33 = v112;
    int v34 = v111;
    unint64_t v35 = v110;
    long long v36 = &v112[12 * v110];
    *long long v36 = __src;
    *((void *)v36 + 5) = 0;
    v36[8] = 0;
    *((void *)v36 + 2) = 0;
    *((void *)v36 + 3) = 0;
    *((void *)v36 + 1) = 0;
    *((void *)v36 + 1) = *((void *)&__src + 1);
    *((void *)&__src + 1) = 0;
    *((void *)v36 + 2) = v128;
    *(void *)&long long v128 = 0;
    uint64_t v37 = *((void *)v36 + 3);
    *((void *)v36 + 3) = *((void *)&v128 + 1);
    *((void *)&v128 + 1) = v37;
    uint64_t v38 = *((void *)v36 + 5);
    *((void *)v36 + 5) = *((void *)&v129 + 1);
    *((void *)&v129 + 1) = v38;
    LODWORD(v129) = v129 + 1;
    ++v36[8];
    unint64_t v39 = v35 + 1;
    unint64_t v110 = v35 + 1;
    int v111 = v34 + 1;
    if (*((void *)&__src + 1))
    {
      if (v38)
      {
        unint64_t v40 = v35 + 1;
        (*(void (**)(void))(**((void **)&__src + 1) + 40))();
        unint64_t v39 = v40;
      }
      *((void *)&v129 + 1) = 0;
      long long v128 = 0uLL;
      *((void *)&__src + 1) = 0;
      LODWORD(v129) = v129 + 1;
    }
    if (*(void *)v114 && *(void *)&v114[32])
    {
      unint64_t v41 = v39;
      (*(void (**)(void))(**(void **)v114 + 40))();
      unint64_t v39 = v41;
    }
    *(_DWORD *)uint64_t v120 = 0;
    if (*((_DWORD *)v11 + 10))
    {
      if (!v39) {
        goto LABEL_104;
      }
      do
      {
        re::DynamicArray<int>::add((void *)v33 + 1, v120);
        ++*(_DWORD *)v120;
      }
      while (*(_DWORD *)v120 < *((_DWORD *)v11 + 10));
      unint64_t v39 = v110;
    }
  }
LABEL_21:
  unint64_t v95 = v39;
  if (v39)
  {
    unint64_t v18 = (unint64_t)v112;
    uint64_t v97 = &v112[12 * v39];
    while (1)
    {
      id v42 = v98;
      unint64_t v14 = (unint64_t)v42;
      unint64_t v43 = *(void *)(v18 + 24);
      if (v43) {
        break;
      }
      uint64_t v3 = 0;
LABEL_32:
      MDLMaterialPropertyType v49 = objc_msgSend(v42, "allocator", v88, v89);
      MDLMaterialSemantic v50 = (void *)[v49 newBuffer:4 * v3 type:2];

      uint64_t v103 = (void *)v14;
      MDLMaterialPropertyType v51 = [(id)v14 allocator];
      unint64_t v101 = v43;
      uint64_t v52 = (void *)[v51 newBuffer:v43 type:2];

      long long v99 = v50;
      char v102 = [v50 map];
      uint64_t v53 = [v102 bytes];
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> v105 = v52;
      char v100 = [v52 map];
      uint64_t v54 = [v100 bytes];
      unint64_t v104 = v18;
      uint64_t v55 = *(void *)(v18 + 24);
      if (v55)
      {
        uint64_t v56 = v54;
        unint64_t v14 = 0;
        unsigned int v57 = 0;
        unint64_t v18 = *(void *)(v18 + 40);
        uint64_t v6 = (unsigned int *)(v18 + 4 * v55);
        while (1)
        {
          unint64_t v43 = *(unsigned int *)v18;
          *(void *)&v114[32] = 0;
          memset(v114, 0, 28);
          unsigned int v58 = re::internal::GeomBaseTopology::faceVertices(v106, v43, (uint64_t)v114);
          unint64_t v59 = v28;
          MDLMaterialPropertyType v28 = (re *)*((void *)v28 + 5);
          if ((unint64_t)v28 <= v43) {
            goto LABEL_99;
          }
          char v60 = *(_DWORD *)(*((void *)v59 + 7) + 16 * v43 + 12) == -1 ? 3 : 4;
          *(unsigned char *)(v56 + v57) = v60;
          MDLMaterialPropertyType v28 = v59;
          if (v58) {
            break;
          }
LABEL_43:
          if (*(void *)v114 && *(void *)&v114[32]) {
            (*(void (**)(void))(**(void **)v114 + 40))();
          }
          ++v57;
          v18 += 4;
          if ((unsigned int *)v18 == v6) {
            goto LABEL_47;
          }
        }
        MDLMaterialSemantic v61 = 0;
        id v11 = *(re **)&v114[16];
        uint64_t v62 = *(void *)&v114[32];
        while (v11 != v61)
        {
          *(_DWORD *)(v53 + 4 * (v14 + v61)) = *(_DWORD *)(v62 + 4 * (void)v61);
          MDLMaterialSemantic v61 = (re *)((char *)v61 + 1);
          if ((re *)v58 == v61)
          {
            unint64_t v14 = (v14 + v61);
            goto LABEL_43;
          }
        }
        *(void *)uint64_t v120 = 0;
        long long v130 = 0u;
        long long v131 = 0u;
        long long v128 = 0u;
        long long v129 = 0u;
        long long __src = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v116 = 136315906;
        *(void *)&v116[4] = "operator[]";
        *(_WORD *)&v116[12] = 1024;
        *(_DWORD *)&v116[14] = 789;
        *(_WORD *)&v116[18] = 2048;
        *(void *)&v116[20] = v11;
        __int16 v117 = 2048;
        uint64_t v118 = v11;
        LODWORD(v89) = 38;
        uint64_t v88 = v116;
        _os_log_send_and_compose_impl();
        MDLMaterialPropertyType v31 = (_anonymous_namespace_ *)_os_crash_msg();
        __break(1u);
LABEL_64:
        LODWORD(v3) = 0;
        uint64_t v32 = 0;
        goto LABEL_65;
      }
LABEL_47:
      id v63 = objc_alloc_init(MEMORY[0x263F13670]);
      [v63 setFaceCount:v101];
      [v63 setFaceTopology:v105];
      if (*(void *)v28)
      {
        objc_msgSend(NSString, "stringWithUTF8String:");
        unsigned int v64 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        unsigned int v64 = &stru_26E738380;
      }
      unsigned int v65 = (void *)[objc_alloc(MEMORY[0x263F13668]) initWithName:v64 indexBuffer:v99 indexCount:v3 indexType:32 geometryType:5 material:0 topology:v63];
      if (v65)
      {
        uint64_t v66 = [v103 submeshes];
        [v66 addObject:v65];
        [v103 setSubmeshes:v66];
      }
      unint64_t v18 = v104 + 48;
      if ((unsigned int *)(v104 + 48) == v97) {
        goto LABEL_53;
      }
    }
    uint64_t v3 = 0;
    uint64_t v44 = *(unsigned int **)(v18 + 40);
    unint64_t v45 = *((void *)v28 + 5);
    uint64_t v46 = 4 * v43;
    while (1)
    {
      unint64_t v47 = *v44;
      if (v45 <= v47) {
        break;
      }
      if (*(_DWORD *)(*((void *)v28 + 7) + 16 * v47 + 12) == -1) {
        uint64_t v48 = 3;
      }
      else {
        uint64_t v48 = 4;
      }
      v3 += v48;
      ++v44;
      v46 -= 4;
      if (!v46) {
        goto LABEL_32;
      }
    }
    *(void *)uint64_t v116 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v114 = 136315906;
    *(void *)&v114[4] = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)&v114[14] = 797;
    *(_WORD *)&v114[18] = 2048;
    *(void *)&v114[20] = v47;
    *(_WORD *)&v114[28] = 2048;
    *(void *)&v114[30] = v45;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_99:
    uint64_t v15 = (uint64_t)v116;
    *(void *)uint64_t v120 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v116 = 136315906;
    *(void *)&v116[4] = "operator[]";
    *(_WORD *)&v116[12] = 1024;
    *(_DWORD *)&v116[14] = 797;
    *(_WORD *)&v116[18] = 2048;
    *(void *)&v116[20] = v43;
    __int16 v117 = 2048;
    uint64_t v118 = v28;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_100:
    uint64_t v108 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v114 = 136315906;
    *(void *)&v114[4] = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)&v114[14] = 601;
    *(_WORD *)&v114[18] = 2048;
    *(void *)&v114[20] = v18;
    *(_WORD *)&v114[28] = 2048;
    *(void *)&v114[30] = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_101:
    uint64_t v113 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v120 = 136315906;
    *(void *)&v120[4] = "operator[]";
    __int16 v121 = 1024;
    int v122 = 601;
    __int16 v123 = 2048;
    unint64_t v124 = v15;
    __int16 v125 = 2048;
    uint64_t v126 = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_102:
    uint64_t v113 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v120 = 136315906;
    *(void *)&v120[4] = "insert";
    __int16 v121 = 1024;
    int v122 = 887;
    __int16 v123 = 2048;
    unint64_t v124 = v14;
    __int16 v125 = 2048;
    uint64_t v126 = v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_103:
    *(void *)uint64_t v116 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v114 = 136315906;
    *(void *)&v114[4] = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)&v114[14] = 601;
    *(_WORD *)&v114[18] = 2048;
    *(void *)&v114[20] = v15;
    *(_WORD *)&v114[28] = 2048;
    *(void *)&v114[30] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_104:
    *(void *)uint64_t v116 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long __src = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v114 = 136315906;
    *(void *)&v114[4] = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)&v114[14] = 789;
    *(_WORD *)&v114[18] = 2048;
    *(void *)&v114[20] = 0;
    *(_WORD *)&v114[28] = 2048;
    *(void *)&v114[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_53:
  uint64_t v67 = v108;
  if (v108 && v112)
  {
    if (v95)
    {
      uint64_t v68 = 48 * v95;
      uint64_t v69 = (uint64_t)(v112 + 2);
      do
      {
        re::DynamicArray<unsigned long>::deinit(v69);
        v69 += 48;
        v68 -= 48;
      }
      while (v68);
      uint64_t v67 = v108;
    }
    (*(void (**)(uint64_t))(*(void *)v67 + 40))(v67);
  }

  return v98;
}

void *re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::KeyValuePair<int,re::DynamicArray<unsigned int>>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 48 * v9;
        id v11 = v7;
        do
        {
          *(_DWORD *)id v11 = *(_DWORD *)v8;
          v11[5] = 0;
          v11[2] = 0;
          v11[3] = 0;
          v11[1] = 0;
          *((_DWORD *)v11 + 8) = 0;
          uint64_t v12 = *(void *)(v8 + 8);
          uint64_t v13 = *(void *)(v8 + 16);
          uint64_t v14 = v8 + 8;
          v11[1] = v12;
          v11[2] = v13;
          *(void *)uint64_t v14 = 0;
          *(void *)(v14 + 8) = 0;
          uint64_t v15 = v11[3];
          v11[3] = *(void *)(v14 + 16);
          *(void *)(v14 + 16) = v15;
          uint64_t v16 = v11[5];
          v11[5] = *(void *)(v14 + 32);
          *(void *)(v14 + 32) = v16;
          ++*(_DWORD *)(v14 + 24);
          ++*((_DWORD *)v11 + 8);
          re::DynamicArray<unsigned long>::deinit(v14);
          uint64_t v8 = v14 + 40;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::createCGImagePtrFromCGImageSource(id *a1@<X0>, CGImageSource *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  v103[3] = *MEMORY[0x263EF8340];
  unint64_t v85 = 0;
  unint64_t v86 = 0;
  uint64_t v8 = *MEMORY[0x263F0F600];
  v103[0] = MEMORY[0x263EFFA80];
  uint64_t v9 = *MEMORY[0x263F0F5F8];
  v102[0] = v8;
  v102[1] = v9;
  uint64_t v10 = [NSNumber numberWithBool:*(unsigned __int8 *)(a3 + 44)];
  v102[2] = @"kCGImageSourceCreateUnpremultipliedPNG";
  v103[1] = v10;
  v103[2] = MEMORY[0x263EFFA88];
  CFDictionaryRef v11 = [NSDictionary dictionaryWithObjects:v103 forKeys:v102 count:3];

  ImageAtIndex = CGImageSourceCreateImageAtIndex(a2, 0, v11);
  if (ImageAtIndex || (ImageAtIndex = CGImageSourceCreateImageAtIndex(a2, 0, 0)) != 0)
  {
    CFDictionaryRef v13 = CGImageSourceCopyPropertiesAtIndex(a2, 0, 0);
    CFDictionaryRef v14 = v13;
    if (!v13)
    {
      uint64_t v32 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_233120000, v32, OS_LOG_TYPE_ERROR, "Failed to retrieve image properties from a CGImageSource during texture creation", buf, 2u);
      }
      *(void *)(a4 + 48) = 0;
      *(_OWORD *)(a4 + 16) = 0u;
      *(_OWORD *)(a4 + 32) = 0u;
      *(_OWORD *)a4 = 0u;
      *(void *)(a4 + 56) = CGColorSpaceGetNumberOfComponents(0);
      *(_DWORD *)(a4 + 64) = CGColorSpaceGetModel(0);
      *(_DWORD *)(a4 + 72) = 0;
      goto LABEL_50;
    }
    int v71 = (CGImagePtr *)a4;
    CFDictionaryRef v15 = v11;
    uint64_t v16 = [(__CFDictionary *)v13 objectForKeyedSubscript:*MEMORY[0x263F0F4F8]];
    CFDictionaryRef v76 = v14;
    uint64_t v17 = [(__CFDictionary *)v14 objectForKeyedSubscript:*MEMORY[0x263F0F4F0]];
    unint64_t v74 = v16;
    unint64_t v18 = [v16 unsignedIntegerValue];
    unint64_t v73 = v17;
    unint64_t v19 = [v17 unsignedIntegerValue];
    unsigned int v20 = *(_DWORD *)(a3 + 16);
    if (v20 <= 1) {
      unsigned int v20 = 1;
    }
    if (*(_DWORD *)(a3 + 8) == 1) {
      LODWORD(v21) = v20;
    }
    else {
      LODWORD(v21) = 1;
    }
    unint64_t v22 = (int)v21;
    unint64_t v75 = (re *)a1;
    unint64_t v23 = re::internal::downsampleFactorToFitDeviceLimits(a1, 2, v18, v19, 0);
    if (v23 <= (int)v21) {
      unint64_t v21 = (int)v21;
    }
    else {
      unint64_t v21 = v23;
    }
    unint64_t v72 = v21;
    if (v21 < 2)
    {
      CFDictionaryRef v11 = v15;
    }
    else
    {
      unint64_t v25 = v23;
      uint64_t v26 = [(__CFDictionary *)v15 mutableCopy];
      unint64_t v27 = v21;
      MDLMaterialPropertyType v28 = (void *)v26;
      float v29 = [NSNumber numberWithInt:v27];
      [v28 setObject:v29 forKey:*MEMORY[0x263F0F628]];

      if (v25 > v22 && (MDLMaterialPropertyType v31 = *re::pipelineLogObjects(v30), os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)))
      {
        *(_DWORD *)buf = 134218752;
        *(void *)&buf[4] = v18;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&buf[24] = v86;
        *(_WORD *)&uint8_t buf[32] = 2048;
        *(void *)&buf[34] = v85;
        _os_log_impl(&dword_233120000, v31, OS_LOG_TYPE_DEFAULT, "Downsampling imported image to match device limits, from %zux%zu image to %zux%zu", buf, 0x2Au);
        CFDictionaryRef v11 = (const __CFDictionary *)v28;
      }
      else
      {
        CFDictionaryRef v11 = (const __CFDictionary *)v28;
      }
    }
    if ((*(_DWORD *)(a3 + 56) - 3) <= 1 && !*(void *)(a3 + 64))
    {
      ColorSpace = CGImageGetColorSpace(ImageAtIndex);
      CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
      if (Model <= kCGColorSpaceModelRGB)
      {
        CGColorSpaceModel v36 = Model;
        if (!re::internal::colorSpaceIsExtendedOrHDR(ColorSpace, v35))
        {
          uint64_t v37 = [(__CFDictionary *)v76 objectForKeyedSubscript:*MEMORY[0x263F0F500]];
          if (v37)
          {
          }
          else
          {
            id v63 = [(__CFDictionary *)v76 objectForKeyedSubscript:*MEMORY[0x263F0F490]];
            uint64_t v70 = v63;
            if (v36) {
              unint64_t v64 = 4;
            }
            else {
              unint64_t v64 = 1;
            }
            unsigned int v65 = (void *)re::computeWorkingColorSpaceName(v75, v64, [v63 BOOLValue] ^ 1, objc_msgSend(v63, "BOOLValue"));
            long long v66 = *(_OWORD *)(a3 + 16);
            *(_OWORD *)buf = *(_OWORD *)a3;
            *(_OWORD *)&buf[16] = v66;
            *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)(a3 + 32);
            *(_OWORD *)&buf[44] = *(_OWORD *)(a3 + 44);
            id v67 = *(id *)(a3 + 64);
            long long v101 = *(_OWORD *)(a3 + 72);
            id v68 = v65;
            id v100 = v68;

            uint64_t v69 = CGImageRetain(ImageAtIndex);
            CGImageRefWithColorSpace = re::createCGImageRefWithColorSpace(v75, v69, (id *)buf, 0);

            if (CGImageRefWithColorSpace)
            {
LABEL_28:
              CGImageRelease(ImageAtIndex);
              CGImagePtr::CGImagePtr((CGImagePtr *)buf, CGImageRefWithColorSpace);
              unint64_t v41 = *(void *)&buf[8];
              unint64_t v42 = *(void *)&buf[16];
              if (v72 < 2)
              {
                unint64_t v85 = *(void *)&buf[16];
                unint64_t v86 = *(void *)&buf[8];
                unint64_t v43 = *(void *)&buf[16];
                unint64_t v44 = *(void *)&buf[8];
              }
              else
              {
                unint64_t v43 = v85;
                unint64_t v44 = v86;
              }
              if ((v44 > 0x1000 || v43 > 0x1000)
                && (Type = CGImageSourceGetType(a2), unint64_t v40 = (re *)CFEqual(Type, @"public.jpeg"), v40))
              {
                uint64_t v46 = *re::pipelineLogObjects(v40);
                unint64_t v40 = (re *)os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG);
                if (v40)
                {
                  *(_DWORD *)uint64_t v87 = 134218240;
                  unint64_t v88 = v44;
                  __int16 v89 = 2048;
                  unint64_t v90 = v43;
                  _os_log_debug_impl(&dword_233120000, v46, OS_LOG_TYPE_DEBUG, "Loading JPEG > 4K on iOS (%zux%zu): forced load to memory workaround", v87, 0x16u);
                }
              }
              else if (v72 < 2 || v41 <= v44 && v42 <= v43)
              {
                goto LABEL_48;
              }
              unint64_t v47 = *re::pipelineLogObjects(v40);
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)uint64_t v87 = 134219264;
                unint64_t v88 = v18;
                __int16 v89 = 2048;
                unint64_t v90 = v19;
                __int16 v91 = 2048;
                unint64_t v92 = v44;
                __int16 v93 = 2048;
                unint64_t v94 = v43;
                __int16 v95 = 2048;
                unint64_t v96 = v41;
                __int16 v97 = 2048;
                unint64_t v98 = v42;
                _os_log_debug_impl(&dword_233120000, v47, OS_LOG_TYPE_DEBUG, "Performing requested downsampling of %zux%zu image to %zux%zu (since Image I/O only downsampled to %zux%zu)", v87, 0x3Eu);
              }
              uint64_t v48 = CGImageCreateByScaling();
              if (v48)
              {
                MDLMaterialPropertyType v49 = (CGImage *)v48;
                CGImagePtr::CGImagePtr((CGImagePtr *)&image, 0);
                CGImageRef v50 = image;
                uint64_t v51 = *(void *)&buf[40];
                CGImageRef image = *(CGImageRef *)buf;
                long long v52 = v78;
                long long v78 = *(_OWORD *)&buf[8];
                *(_OWORD *)&buf[8] = v52;
                long long v53 = v79;
                long long v79 = *(_OWORD *)&buf[24];
                *(_OWORD *)&buf[24] = v53;
                CGColorSpaceRef v54 = v81;
                *(void *)buf = v50;
                *(void *)&buf[40] = v80;
                uint64_t v55 = v82;
                int v56 = v83;
                LODWORD(v50) = v100;
                LODWORD(v100) = -1;
                unsigned int v57 = *(CGColorSpace **)&buf[48];
                uint64_t v58 = *(void *)&buf[56];
                *(void *)&buf[48] = 0;
                *(void *)&buf[56] = 0;
                uint64_t v80 = v51;
                CGColorSpaceRef v81 = v57;
                uint64_t v82 = v58;
                int v83 = (int)v50;
                CGColorSpaceRelease(0);
                unint64_t v59 = *(CGColorSpace **)&buf[48];
                *(void *)&buf[48] = v54;
                *(void *)&buf[56] = v55;
                LODWORD(v100) = v56;
                CGColorSpaceRelease(v59);
                CGColorSpaceRelease(0);
                int v60 = v84;
                int v84 = v101;
                LODWORD(v101) = v60;
                CGImageRelease(image);
                CGImageRef image = 0;
                CGColorSpaceRelease(v81);
                CGColorSpaceRef v81 = 0;
                CGImagePtr::CGImagePtr(v71, v49);
LABEL_49:
                CGImageRelease(*(CGImageRef *)buf);
                *(void *)buf = 0;
                CGColorSpaceRelease(*(CGColorSpaceRef *)&buf[48]);

                CFDictionaryRef v14 = v76;
LABEL_50:

                goto LABEL_51;
              }
              uint64_t v62 = *re::pipelineLogObjects(0);
              if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)uint64_t v87 = 134218240;
                unint64_t v88 = v44;
                __int16 v89 = 2048;
                unint64_t v90 = v43;
                _os_log_error_impl(&dword_233120000, v62, OS_LOG_TYPE_ERROR, "Failed to scale source image to %zux%zu during texture creation, ignoring downsampling", v87, 0x16u);
              }
LABEL_48:
              CGImagePtr::CGImagePtr((uint64_t)v71, (uint64_t *)buf);
              goto LABEL_49;
            }
          }
        }
      }
    }
    uint64_t v38 = CGImageRetain(ImageAtIndex);
    CGImageRefWithColorSpace = re::createCGImageRefWithColorSpace(v75, v38, (id *)a3, 0);
    goto LABEL_28;
  }
  MDLMaterialSemantic v61 = *re::pipelineLogObjects(0);
  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_233120000, v61, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGImageSource during texture creation", buf, 2u);
  }
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(void *)(a4 + 56) = CGColorSpaceGetNumberOfComponents(0);
  *(_DWORD *)(a4 + 64) = CGColorSpaceGetModel(0);
  *(_DWORD *)(a4 + 72) = 0;
LABEL_51:
}

unint64_t re::anonymous namespace'::getCGDownsampledImageSize(unint64_t this, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] != 1)
  {
    unint64_t v7 = (a3 - 1) | ((a3 - 1) >> 1) | (((a3 - 1) | ((a3 - 1) >> 1)) >> 2);
    unint64_t v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
    a3 = (v8 | (v8 >> 16) | ((v8 | (v8 >> 16)) >> 32)) + 1;
  }
  unint64_t v9 = this / a3;
  if (this / a3 <= 1) {
    unint64_t v9 = 1;
  }
  *a4 = v9;
  unint64_t v10 = a2 / a3;
  if (a2 / a3 <= 1) {
    unint64_t v10 = 1;
  }
  *a5 = v10;
  return this;
}

BOOL re::internal::colorSpaceIsExtendedOrHDR(re::internal *this, CGColorSpace *a2)
{
  if (CGColorSpaceUsesExtendedRange(this) || CGColorSpaceIsPQBased(this)) {
    return 1;
  }
  return CGColorSpaceIsHLGBased(this);
}

uint64_t re::computeWorkingColorSpaceName(unsigned char *a1, unint64_t a2, int a3, int a4)
{
  if (a1[16])
  {
    if (a1[19]) {
      unsigned __int8 v4 = a1[20];
    }
    else {
      unsigned __int8 v4 = 0;
    }
    return re::ColorHelpers::getCGColorSpaceNameForGamut(a2, a3, a4, v4);
  }
  else
  {
    uint64_t v6 = MEMORY[0x263F002D8];
    if (a2 <= 2) {
      uint64_t v6 = MEMORY[0x263F00250];
    }
    return *(void *)v6;
  }
}

const re::ImportGraphicsContext *re::createCGImageRefWithColorSpace(re *this, const re::ImportGraphicsContext *a2, id *a3, const re::TextureFromImageOptions *a4)
{
  int v4 = (int)a4;
  uint64_t v46 = *MEMORY[0x263EF8340];
  CFStringRef v8 = (const __CFString *)a3[8];
  if (!v8)
  {
LABEL_10:
    CFDictionaryRef v11 = 0;
    goto LABEL_11;
  }
  CFStringRef v9 = v8;
  CGColorSpaceRef v10 = CGColorSpaceCreateWithName(v8);
  if (!v10)
  {
    CFDictionaryRef v15 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = v15;
      *(_DWORD *)buf = 136315138;
      CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
      _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_DEFAULT, "Invalid colorSpaceNameOverride: %s", buf, 0xCu);
    }
    goto LABEL_10;
  }
  CFDictionaryRef v11 = v10;
  if (*((unsigned char *)this + 16))
  {
    if ((*((_DWORD *)a3 + 14) - 3) <= 1)
    {
      ColorSpace = CGImageGetColorSpace(a2);
      if ((CGColorSpaceEqualToColorSpace() & 1) == 0)
      {
        CGImageRef CopyWithColorSpace = CGImageCreateCopyWithColorSpace(a2, v11);
        if (CopyWithColorSpace)
        {
          CFDictionaryRef v14 = CopyWithColorSpace;
          CGImageRelease(a2);
          a2 = v14;
        }
        else
        {
          CFStringRef Name = CGColorSpaceGetName(ColorSpace);
          long long v33 = CFStringGetCStringPtr(Name, 0x8000100u);
          int v34 = (re *)CFStringGetCStringPtr(v9, 0x8000100u);
          unint64_t v35 = *re::pipelineLogObjects(v34);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            CStringPtr = v33;
            __int16 v40 = 2080;
            size_t v41 = (size_t)v34;
            _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_DEFAULT, "Failed to create CGImage from Source ColorSpace: %s to Override ColorSpace: %s", buf, 0x16u);
          }
        }
      }
    }
  }
LABEL_11:
  CGColorSpaceRelease(v11);
  if (v4)
  {
    size_t Width = CGImageGetWidth(a2);
    size_t Height = CGImageGetHeight(a2);
    size_t v36 = 0;
    size_t v37 = 0;
    int v19 = *((_DWORD *)a3 + 2) == 1 ? *((_DWORD *)a3 + 4) : 1;
    unint64_t v20 = v19;
    unint64_t v21 = re::internal::downsampleFactorToFitDeviceLimits((id *)this, 2, 0, 0, 0);
    unint64_t v23 = v21 <= v19 ? v19 : v21;
    if (v23 >= 2)
    {
      unint64_t v24 = v21;
      unint64_t v26 = v36;
      unint64_t v27 = v37;
      if (Width > v37 || Height > v36)
      {
        MDLMaterialPropertyType v28 = *re::pipelineLogObjects(CGDownsampledImageSize);
        if (v24 <= v20)
        {
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134218752;
            CStringPtr = (const char *)Width;
            __int16 v40 = 2048;
            size_t v41 = Height;
            __int16 v42 = 2048;
            unint64_t v43 = v27;
            __int16 v44 = 2048;
            unint64_t v45 = v26;
            _os_log_debug_impl(&dword_233120000, v28, OS_LOG_TYPE_DEBUG, "Performing requested downsampling of %zux%zu image to %zux%zu", buf, 0x2Au);
          }
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218752;
          CStringPtr = (const char *)Width;
          __int16 v40 = 2048;
          size_t v41 = Height;
          __int16 v42 = 2048;
          unint64_t v43 = v27;
          __int16 v44 = 2048;
          unint64_t v45 = v26;
          _os_log_impl(&dword_233120000, v28, OS_LOG_TYPE_DEFAULT, "Downsampling imported image to match device limits, from %zux%zu image to %zux%zu", buf, 0x2Au);
        }
        uint64_t v29 = CGImageCreateByScaling();
        if (!v29)
        {
          uint64_t v30 = *re::pipelineLogObjects(0);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134218240;
            CStringPtr = (const char *)v27;
            __int16 v40 = 2048;
            size_t v41 = v26;
            _os_log_error_impl(&dword_233120000, v30, OS_LOG_TYPE_ERROR, "Failed to scale source image to %zux%zu during texture creation, ignoring downsampling", buf, 0x16u);
          }
        }
        CGImageRelease(a2);
        return (const re::ImportGraphicsContext *)v29;
      }
    }
  }
  return a2;
}

uint64_t re::createTextureFromCGImagePtr(uint64_t a1, uint64_t a2, id *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v14 = a5;
  if (*(_DWORD *)(a5 + 28))
  {
    uint64_t v20 = a1;
    re::logTextureCompressionInfo((re *)"createTextureFromCGImagePtr", *a3, (int *)(a5 + 28));
    uint64_t v14 = a5;
    a1 = v20;
  }
}

void re::createTextureFromCGImagePtrs(uint64_t a1, uint64_t a2, uint64_t a3, id *a4, uint64_t a5, uint64_t a6)
{
  if (*(_DWORD *)(a6 + 28)) {
    re::logTextureCompressionInfo((re *)"createTextureFromCGImagePtrs", *a4, (int *)(a6 + 28));
  }
  JUMPOUT(0x233D64B28);
}

CGColorSpaceRef re::getDestinationColorSpace@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X1>, id *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  objc_msgSend(*a3, sel_pixelFormat);
  MTLPixelFormatGetInfoForDevice();
  objc_msgSend(*a3, sel_pixelFormat, 0);
  MTLPixelFormatGetInfoForDevice();
  if (*(void *)(a1 + 24) > 8uLL || re::internal::colorSpaceIsExtendedOrHDR(*(re::internal **)(a1 + 48), v10)) {
    int isHDR = 1;
  }
  else {
    int isHDR = re::isHDR((int)objc_msgSend(*a3, sel_pixelFormat, 0, 0, 0, 0));
  }
  if ((*(_DWORD *)(a4 + 56) - 3) > 1)
  {
    CFDictionaryRef v15 = *(CGColorSpace **)(a1 + 48);
    CGColorSpaceModel Model = CGColorSpaceGetModel(v15);
    CGColorSpaceModel v18 = Model;
    if (Model == kCGColorSpaceModelIndexed)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(*(CGColorSpaceRef *)(a1 + 48));
      CGColorSpaceModel v19 = CGColorSpaceGetModel(BaseColorSpace);
      CFRetain(BaseColorSpace);
      CFDictionaryRef v15 = BaseColorSpace;
    }
    else
    {
      BaseColorSpace = 0;
      CGColorSpaceModel v19 = Model;
    }
    if (v19)
    {
      ColorSpaceTransferFunctiouint64_t n = re::getColorSpaceTransferFunction(v15, v17);
      unint64_t v21 = (CFStringRef *)MEMORY[0x263F00220];
      if ((ColorSpaceTransferFunction & 1) == 0) {
        unint64_t v21 = (CFStringRef *)MEMORY[0x263F00208];
      }
      unint64_t v22 = (CFStringRef *)MEMORY[0x263F002B8];
      if ((ColorSpaceTransferFunction & 1) == 0) {
        unint64_t v22 = (CFStringRef *)MEMORY[0x263F00250];
      }
      if (!isHDR) {
        unint64_t v21 = v22;
      }
      BaseColorSpace = CGColorSpaceCreateWithName(*v21);
      goto LABEL_24;
    }
    if (v18 != kCGColorSpaceModelIndexed) {
      goto LABEL_23;
    }
  }
  else
  {
    CFStringRef v12 = (const __CFString *)re::computeWorkingColorSpaceName(a2, 0, 0, isHDR);
    CFDictionaryRef v13 = CGColorSpaceCreateWithName(v12);
    BaseColorSpace = v13;
    if (a2[16])
    {
      if ((CGColorSpaceEqualToColorSpace() & 1) == 0) {
        goto LABEL_24;
      }
LABEL_23:
      CGColorSpaceRelease(BaseColorSpace);
      CGColorSpaceRef result = CGColorSpaceRetain(*(CGColorSpaceRef *)(a1 + 48));
      uint64_t v25 = *(void *)(a1 + 56);
      *(void *)a5 = result;
      *(void *)(a5 + 8) = v25;
      *(_DWORD *)(a5 + 16) = *(_DWORD *)(a1 + 64);
      return result;
    }
    CGColorSpaceModel v23 = CGColorSpaceGetModel(v13);
    if (CGColorSpaceGetModel(*(CGColorSpaceRef *)(a1 + 48)) == v23) {
      goto LABEL_23;
    }
  }
LABEL_24:
  *(void *)a5 = BaseColorSpace;
  *(void *)(a5 + 8) = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  CGColorSpaceRef result = (CGColorSpaceRef)(int)CGColorSpaceGetModel(BaseColorSpace);
  *(_DWORD *)(a5 + 16) = result;
  return result;
}

const __CFString *re::getColorSpaceTransferFunction(re *this, CGColorSpace *a2)
{
  BaseColorSpace = this;
  if (CGColorSpaceGetModel(this) == kCGColorSpaceModelIndexed) {
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
  }
  CFStringRef result = CGColorSpaceGetName(BaseColorSpace);
  if (result)
  {
    CFStringRef v5 = result;
    if (re::colorSpaceNameHasSRGBTransfer(result, v4)) {
      return (const __CFString *)2;
    }
    else {
      return (const __CFString *)re::colorSpaceNameHasLinearTransfer(v5, v6);
    }
  }
  return result;
}

void re::createTextureDescriptorForCGImagePtr(uint64_t a1@<X0>, id *a2@<X1>, id *a3@<X2>, re::internal *a4@<X3>, int a5@<W4>, unint64_t *a6@<X5>, void *a7@<X6>, unsigned int *a8@<X7>, id *a9@<X8>)
{
  unint64_t v16 = *(void *)(a1 + 8);
  unint64_t v17 = *(void *)(a1 + 16);
  unint64_t v59 = v16;
  unint64_t v58 = v17;
  if (a5)
  {
    if (*((_DWORD *)a4 + 2) == 1)
    {
      unint64_t v18 = *((int *)a4 + 4);
      if (v18 >= 2) {
    }
      }
  }
  objc_msgSend(*a3, sel_pixelFormat);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(*(CGImageRef *)a1);
  int DestinationTransferFunctionFromOptions = re::internal::getDestinationTransferFunctionFromOptions(a4, *(const re::TextureFromImageOptions **)(a1 + 48), (CGColorSpace *)(BitsPerComponent > 8));
  if (DestinationTransferFunctionFromOptions) {
    BOOL v21 = DestinationTransferFunctionFromOptions == 2;
  }
  else {
    BOOL v21 = (*((_DWORD *)a4 + 14) - 3) < 2;
  }
  long long v53 = a8;
  if (*a2) {
    int v54 = [*a2 supportsTextureSwizzle];
  }
  else {
    int v54 = 1;
  }
  unint64_t v22 = *(CGColorSpace **)(a1 + 48);
  BaseColorSpace = CGColorSpaceGetBaseColorSpace(v22);
  if (!BaseColorSpace) {
    BaseColorSpace = v22;
  }
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  int v26 = *((_DWORD *)a4 + 1);
  if (v26 == 1)
  {
    int v55 = 0;
    uint64_t v27 = 1;
  }
  else
  {
    uint64_t v27 = NumberOfComponents;
    if (v26 == 2)
    {
      int v28 = v54;
      if (NumberOfComponents != 1) {
        int v28 = 1;
      }
      if (!v28) {
        uint64_t v27 = 3;
      }
      int v55 = (NumberOfComponents != 1) ^ v28;
    }
    else
    {
      if (v26 == 3)
      {
        re::internal::assertLog((re::internal *)4, v25, "assertion failure: '%s' (%s:line %i) Semantics should have been applied at this point", "!\"Unreachable code\"", "createTextureDescriptorForCGImagePtr", 3523);
        _os_crash();
        __break(1u);
        return;
      }
      int v55 = 0;
    }
  }
  if (*(_DWORD *)a4 != 1)
  {
    int v56 = a3;
    if (*(_DWORD *)a4)
    {
      int v35 = 0;
    }
    else
    {
      int v29 = *((_DWORD *)a4 + 14);
      if (CGImageGetBitsPerComponent(*(CGImageRef *)a1) > 8
        || ((BOOL IsExtendedOrHDR = re::internal::colorSpaceIsExtendedOrHDR(*(re::internal **)(a1 + 48), v30), !v21)
          ? (int v32 = 10)
          : (int v32 = 71),
            !v21 ? (int v33 = 70) : (int v33 = 71),
            IsExtendedOrHDR))
      {
        int v32 = 25;
        int v33 = 115;
      }
      CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(*(CGImageRef *)a1);
      int v35 = 1;
      if (AlphaInfo - 1 < 4) {
        goto LABEL_35;
      }
      if (AlphaInfo != kCGImageAlphaOnly)
      {
        LOBYTE(v35) = 0;
LABEL_35:
        if (((v29 != 2) & v35) != 0) {
          int v35 = v33;
        }
        else {
          int v35 = v32;
        }
        if (v27 != 1) {
          int v35 = v33;
        }
      }
    }
LABEL_55:
    unint64_t v39 = a2;
    uint64_t v40 = v35;
    size_t v41 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:v35 width:v59 height:v58 mipmapped:*((_DWORD *)a4 + 5) != 2];
    uint64_t v42 = [v41 width];
    uint64_t v43 = [v41 height];
    uint64_t v44 = [v41 depth];
    uint64_t v45 = v44;
    if (a6)
    {
      *a6 = v42;
      a6[1] = v43;
      a6[2] = v44;
    }
    if (a7) {
      *a7 = [v41 mipmapLevelCount];
    }
    id v46 = objc_msgSend(*v56, sel_copy);
    *a9 = v46;
    objc_msgSend(v46, sel_setTextureType_, 2);
    objc_msgSend(v46, sel_setWidth_, v42);
    objc_msgSend(v46, sel_setHeight_, v43);
    objc_msgSend(v46, sel_setDepth_, v45);
    objc_msgSend(v46, sel_setArrayLength_, objc_msgSend(v41, "arrayLength"));
    objc_msgSend(v46, sel_setPixelFormat_, v40);
    objc_msgSend(v46, sel_setMipmapLevelCount_, objc_msgSend(v41, "mipmapLevelCount"));
    objc_msgSend(v46, sel_setSampleCount_, objc_msgSend(v41, "sampleCount"));
    if (*((_DWORD *)a4 + 19)) {
      objc_msgSend(v46, sel_setHeight_);
    }
    if (*((_DWORD *)a4 + 18)) {
      objc_msgSend(v46, sel_setWidth_);
    }
    if (*((_DWORD *)a4 + 20)) {
      objc_msgSend(v46, sel_setDepth_);
    }
    if (*((_DWORD *)a4 + 21)) {
      objc_msgSend(v46, sel_setMipmapLevelCount_);
    }
    if (((objc_msgSend(*v56, sel_swizzle) == 84148994) & ~v55) == 0)
    {
      unsigned int v47 = objc_msgSend(v46, sel_swizzle);
      if (v55)
      {
        int v48 = v47;
        if (HIBYTE(v47) - 2 >= 3u) {
          unsigned int v49 = v47 & 0xFF000000;
        }
        else {
          unsigned int v49 = 0x2000000;
        }
        if (BYTE2(v47) - 2 >= 3) {
          int v50 = v47 & 0xFF0000;
        }
        else {
          int v50 = 0x20000;
        }
        if (BYTE1(v47) - 2 >= 3) {
          int v51 = v47 & 0xFF00;
        }
        else {
          int v51 = 512;
        }
        if (v47 - 2 < 3) {
          int v48 = 2;
        }
        unsigned int v47 = v50 | v48 | v49 | v51;
      }
      if (v53) {
        unsigned int *v53 = v47;
      }
      if (v54) {
        uint64_t v52 = v47;
      }
      else {
        uint64_t v52 = 84148994;
      }
      objc_msgSend(v46, sel_setSwizzle_, v52);
    }
    objc_msgSend(v46, sel_pixelFormat);
    if (re::internal::textureMightNeedPixelFormatViewUsage()) {
      objc_msgSend(v46, sel_setUsage_, (unint64_t)objc_msgSend(v46, sel_usage) | 0x10);
    }
    re::internal::applyCompressionOptionsToTextureDescriptor(v39, a4, 1, 0, a9);

    return;
  }
  size_t v36 = (re *)objc_msgSend(*a3, sel_pixelFormat);
  if (v36)
  {
    int v35 = (int)v36;
    int v37 = *((_DWORD *)a4 + 14);
    int v56 = a3;
    if (v37 == 3)
    {
      if (v36 != 10) {
        goto LABEL_55;
      }
    }
    else if (v36 != 10 || v37 != 4)
    {
      goto LABEL_55;
    }
    uint64_t v63 = 0;
    long long v61 = 0u;
    long long v62 = 0u;
    *(_OWORD *)buf = 0u;
    MTLPixelFormatGetInfoForDevice();
    if (buf[8]) {
      int v35 = 11;
    }
    else {
      int v35 = 25;
    }
    goto LABEL_55;
  }
  uint64_t v38 = *re::pipelineLogObjects(v36);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_233120000, v38, OS_LOG_TYPE_ERROR, "Invalid pixel format in texture descriptor", buf, 2u);
  }
  *a9 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
}

void re::createTextureDescriptorForCGImageSource(CGImageSource *a1@<X0>, id *a2@<X1>, id *a3@<X2>, unsigned __int8 *a4@<X3>, unint64_t *a5@<X4>, void *a6@<X5>, int a7@<W6>, id *a8@<X8>)
{
  v24[3] = *MEMORY[0x263EF8340];
  uint64_t v16 = *MEMORY[0x263F0F600];
  v24[0] = MEMORY[0x263EFFA80];
  uint64_t v17 = *MEMORY[0x263F0F5F8];
  v23[0] = v16;
  v23[1] = v17;
  unint64_t v18 = [NSNumber numberWithBool:a4[44]];
  _OWORD v23[2] = @"kCGImageSourceCreateUnpremultipliedPNG";
  v24[1] = v18;
  void v24[2] = MEMORY[0x263EFFA88];
  CFDictionaryRef v19 = [NSDictionary dictionaryWithObjects:v24 forKeys:v23 count:3];

  ImageAtIndex = CGImageSourceCreateImageAtIndex(a1, 0, v19);
  if (ImageAtIndex || (ImageAtIndex = CGImageSourceCreateImageAtIndex(a1, 0, 0)) != 0)
  {
    CGImagePtr::CGImagePtr((CGImagePtr *)image, ImageAtIndex);
    re::createTextureDescriptorForCGImagePtr((uint64_t)image, a2, a3, (re::internal *)a4, a7, a5, a6, 0, a8);
    CGImageRelease(image[0]);
    image[0] = 0;
    CGColorSpaceRelease(image[6]);
  }
  else
  {
    BOOL v21 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(image[0]) = 0;
      _os_log_error_impl(&dword_233120000, v21, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGImageSource", (uint8_t *)image, 2u);
    }
    *a8 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  }
}

void re::copyTextureBytesToASTCCompression(id *a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, re::ASTCCompressor *a8@<X7>, uint64_t a9@<X8>, uint64_t a10)
{
  v29[4] = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 88))
  {
    uint64_t v18 = a2;
    uint64_t v19 = a5;
    uint64_t v20 = a6;
    uint64_t v21 = a7;
    uint64_t v16 = &unk_26E715A30;
    uint64_t v17 = &unk_26E715A80;
    unint64_t v22 = 0;
    id v23 = 0;
    id v24 = 0;
    int v25 = 0;
    long long v26 = 0u;
    memset(v27, 0, 48);
    std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::__value_func[abi:nn180100]((uint64_t)v28, a10);
    re::copyTextureBytesToASTCCompression(a9, &v16, a3, a4, a8, (uint64_t)v28);
    std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::~__value_func[abi:nn180100](v28);
    uint64_t v16 = &unk_26E715A30;
    uint64_t v17 = &unk_26E715A80;
    if (v22)
    {
      if ((void)v26) {
        (*(void (**)(void))(*(void *)v22 + 40))();
      }
    }
  }
  else
  {
    uint64_t v18 = a2;
    uint64_t v19 = a5;
    uint64_t v20 = a6;
    uint64_t v21 = a7;
    uint64_t v16 = &unk_26E715950;
    uint64_t v17 = &unk_26E7159A0;
    id v15 = *a1;
    unint64_t v22 = &unk_26E7158F8;
    id v23 = v15;
    id v24 = 0;

    *(void *)uint64_t v27 = a1;
    memset(&v27[8], 0, 64);
    std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::__value_func[abi:nn180100]((uint64_t)v29, a10);
    re::copyTextureBytesToASTCCompression(a9, &v16, a3, a4, a8, (uint64_t)v29);
    std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::~__value_func[abi:nn180100](v29);
    uint64_t v16 = &unk_26E715950;
    uint64_t v17 = &unk_26E7159A0;
    if (*(void *)&v27[40])
    {

      *(void *)&v27[40] = 0;
    }
    unint64_t v22 = &unk_26E7158F8;
    if (v24)
    {

      id v24 = 0;
    }
  }
}

uint64_t re::copyTextureBytesToASTCCompression(uint64_t a1, void *a2, long long *a3, int a4, re::ASTCCompressor *a5, uint64_t a6)
{
  uint64_t v6 = a2[2];
  if (*(_DWORD *)(v6 + 88) >= 2u) {
    goto LABEL_24;
  }
  id v13 = objc_msgSend(*(id *)(v6 + 8), sel_pixelFormat);
  int v14 = re::MTLToASTCPixelFormat((int)v13);
  if (!v14)
  {
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Unsupported metal format for ASTC compression: %d", (re::DynamicString *)&v42, v13);
    long long v24 = v42;
    long long v25 = v43;
    *(unsigned char *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v24;
    *(_OWORD *)(a1 + 24) = v25;
    return result;
  }
  int v15 = v14;
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v42 = 0u;
  MTLPixelFormatGetInfoForDevice();
  uint64_t v16 = a2[2];
  if (*(_DWORD *)(v16 + 88) >= 2u
    || (unint64_t v17 = (unint64_t)objc_msgSend(*(id *)(v16 + 8), sel_width), v18 = a2[2], *(_DWORD *)(v18 + 88) >= 2u))
  {
LABEL_24:
    std::__throw_bad_variant_access[abi:nn180100]();
    goto LABEL_25;
  }
  if (v17 >> a2[3] <= 1) {
    uint64_t v19 = 1;
  }
  else {
    uint64_t v19 = v17 >> a2[3];
  }
  unint64_t v20 = (unint64_t)objc_msgSend(*(id *)(v18 + 8), sel_height) >> a2[3];
  if (v20 <= 1) {
    unint64_t v20 = 1;
  }
  v38[0] = v19;
  v38[1] = v20;
  v38[2] = 1;
  v37[0] = 0;
  v37[1] = v19 * DWORD2(v43);
  void v37[2] = 0;
  (*(void (**)(uint64_t *__return_ptr, void *, void *, void *))(*a2 + 16))(&v39, a2, v38, v37);
  if (!(_BYTE)v39)
  {
    uint64_t result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v40);
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = v31;
    *(void *)(a1 + 32) = v33;
    *(_OWORD *)(a1 + 16) = v32;
    goto LABEL_16;
  }
  long long v34 = *a3;
  int v35 = v15;
  int v36 = a4;
  uint64_t v21 = (const vImage_Buffer *)(*(uint64_t (**)(void *))(*a2 + 24))(a2);
  if (!(_BYTE)v31)
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v28, (const re::DynamicString *)&v32);
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = v28;
    *(void *)(a1 + 32) = v30;
    *(_OWORD *)(a1 + 16) = v29;
    uint64_t result = v32;
    if (void)v32 && (BYTE8(v32)) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v32 + 40))();
    }
    goto LABEL_16;
  }
  uint64_t v22 = *(void *)(a6 + 24);
  if (!v22)
  {
LABEL_25:
    long long v26 = (re *)std::__throw_bad_function_call[abi:nn180100]();
    return re::colorSpaceNameHasSRGBTransfer(v26, v27);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)v22 + 48))(v22, a2 + 1);
LABEL_16:
  if (!(_BYTE)v39)
  {
    uint64_t result = v40;
    if (v40)
    {
      if (v41) {
        return (*(uint64_t (**)(void))(*(void *)v40 + 40))();
      }
    }
  }
  return result;
}

BOOL re::colorSpaceNameHasSRGBTransfer(const __CFString *this, const __CFString *a2)
{
  return CFEqual(this, (CFStringRef)*MEMORY[0x263F001E8])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00200])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F002D8])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00238])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00248])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00250])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00208])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00278])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00280])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00210]);
}

BOOL re::colorSpaceNameHasLinearTransfer(const __CFString *this, const __CFString *a2)
{
  return CFEqual(this, (CFStringRef)*MEMORY[0x263F00268])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F001D0])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F002C0])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00228])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F002B0])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00218])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F002C8])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00230])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F002B8])
      || CFEqual(this, (CFStringRef)*MEMORY[0x263F00220]);
}

uint64_t re::getLinearColorSpaceNameFromSRGB(const __CFString *this, const __CFString *a2)
{
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F001E8]))
  {
    uint64_t v4 = MEMORY[0x263F002B0];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00200]))
  {
    uint64_t v4 = MEMORY[0x263F00218];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F002D8]))
  {
    uint64_t v4 = MEMORY[0x263F002C8];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00238]))
  {
    uint64_t v4 = MEMORY[0x263F00230];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00248])
    || CFEqual(this, (CFStringRef)*MEMORY[0x263F00250]))
  {
    uint64_t v4 = MEMORY[0x263F002B8];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00208]))
  {
    uint64_t v4 = MEMORY[0x263F00220];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00278])
    || CFEqual(this, (CFStringRef)*MEMORY[0x263F00280]))
  {
    uint64_t v4 = MEMORY[0x263F002C0];
    return *(void *)v4;
  }
  if (CFStringCompare(this, (CFStringRef)*MEMORY[0x263F00210], 0)) {
    return 0;
  }
  else {
    return *MEMORY[0x263F00228];
  }
}

uint64_t re::getSRGBColorSpaceNameFromLinear(const __CFString *this, const __CFString *a2)
{
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F002B0]))
  {
    uint64_t v4 = MEMORY[0x263F001E8];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00218]))
  {
    uint64_t v4 = MEMORY[0x263F00200];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F002C8]))
  {
    uint64_t v4 = MEMORY[0x263F002D8];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00230]))
  {
    uint64_t v4 = MEMORY[0x263F00238];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F002B8]))
  {
    uint64_t v4 = MEMORY[0x263F00250];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F00220]))
  {
    uint64_t v4 = MEMORY[0x263F00208];
    return *(void *)v4;
  }
  if (CFEqual(this, (CFStringRef)*MEMORY[0x263F002C0]))
  {
    uint64_t v4 = MEMORY[0x263F00278];
    return *(void *)v4;
  }
  if (CFStringCompare(this, (CFStringRef)*MEMORY[0x263F00228], 0)) {
    return 0;
  }
  else {
    return *MEMORY[0x263F00210];
  }
}

void re::decompressCPUTexture(re *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)this + 22) >= 2u) {
    goto LABEL_79;
  }
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v37 = 0u;
  objc_msgSend(*((id *)this + 1), sel_pixelFormat);
  MTLPixelFormatGetInfoForDevice();
  if (*((_DWORD *)this + 22) >= 2u) {
    goto LABEL_79;
  }
  CFStringRef v5 = (re *)objc_msgSend(*((id *)this + 1), sel_pixelFormat);
  at_block_format_t v6 = at_block_format_bc1;
  switch((int)v5)
  {
    case 0:
    case 1:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 40:
    case 41:
    case 42:
    case 43:
    case 53:
    case 54:
    case 55:
    case 60:
    case 62:
    case 63:
    case 64:
    case 65:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 80:
    case 81:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 103:
    case 104:
    case 105:
    case 110:
    case 112:
    case 113:
    case 114:
    case 115:
    case 123:
    case 124:
    case 125:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 170:
    case 172:
    case 174:
    case 176:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 240:
    case 241:
    case 250:
    case 252:
    case 253:
    case 255:
    case 260:
    case 261:
    case 262:
LABEL_6:
      unint64_t v7 = *re::pipelineLogObjects(v5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = v37;
        _os_log_error_impl(&dword_233120000, v7, OS_LOG_TYPE_ERROR, "Failed to decompress unsupported format %{public}s", buf, 0xCu);
      }
      *(unsigned char *)a2 &= 0x80u;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 88) = 0;
      *(void *)(a2 + 96) = 0;
      return;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 21:
    case 26:
    case 27:
    case 28:
    case 29:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 56:
    case 57:
    case 58:
    case 59:
    case 61:
    case 66:
    case 67:
    case 68:
    case 69:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 106:
    case 107:
    case 108:
    case 109:
    case 111:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 136:
    case 137:
    case 138:
    case 139:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 168:
    case 169:
    case 171:
    case 173:
    case 175:
    case 177:
    case 184:
    case 185:
    case 191:
    case 201:
    case 202:
    case 203:
    case 209:
    case 219:
    case 220:
    case 221:
    case 227:
    case 237:
    case 238:
    case 239:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 251:
    case 254:
    case 256:
    case 257:
    case 258:
    case 259:
      goto LABEL_40;
    case 132:
    case 133:
      at_block_format_t v6 = at_block_format_bc2;
      goto LABEL_40;
    case 134:
    case 135:
      at_block_format_t v6 = at_block_format_bc3;
      goto LABEL_40;
    case 140:
    case 141:
    case 142:
    case 143:
      at_block_format_t v6 = at_block_format_bc5;
      goto LABEL_40;
    case 150:
    case 151:
    case 152:
    case 153:
      at_block_format_t v6 = at_block_format_bc6;
      goto LABEL_40;
    case 186:
    case 204:
      at_block_format_t v6 = at_block_format_astc_4x4_ldr;
      goto LABEL_40;
    case 187:
    case 205:
      at_block_format_t v6 = at_block_format_astc_5x4_ldr;
      goto LABEL_40;
    case 188:
    case 206:
      at_block_format_t v6 = at_block_format_astc_5x5_ldr;
      goto LABEL_40;
    case 189:
    case 207:
      at_block_format_t v6 = at_block_format_astc_6x5_ldr;
      goto LABEL_40;
    case 190:
    case 208:
      at_block_format_t v6 = at_block_format_astc_6x6_ldr;
      goto LABEL_40;
    case 192:
    case 210:
      at_block_format_t v6 = at_block_format_astc_8x5_ldr;
      goto LABEL_40;
    case 193:
    case 211:
      at_block_format_t v6 = at_block_format_astc_8x6_ldr;
      goto LABEL_40;
    case 194:
    case 212:
      at_block_format_t v6 = at_block_format_astc_8x8_ldr;
      goto LABEL_40;
    case 195:
    case 213:
      at_block_format_t v6 = at_block_format_astc_10x5_ldr;
      goto LABEL_40;
    case 196:
    case 214:
      at_block_format_t v6 = at_block_format_astc_10x6_ldr;
      goto LABEL_40;
    case 197:
    case 215:
      at_block_format_t v6 = at_block_format_astc_10x8_ldr;
      goto LABEL_40;
    case 198:
    case 216:
      at_block_format_t v6 = at_block_format_astc_10x10_ldr;
      goto LABEL_40;
    case 199:
    case 217:
      at_block_format_t v6 = at_block_format_astc_12x10_ldr;
      goto LABEL_40;
    case 200:
    case 218:
      at_block_format_t v6 = at_block_format_astc_12x12_ldr;
      goto LABEL_40;
    case 222:
      at_block_format_t v6 = at_block_format_astc_4x4_hdr;
      goto LABEL_40;
    case 223:
      at_block_format_t v6 = at_block_format_astc_5x4_hdr;
      goto LABEL_40;
    case 224:
      at_block_format_t v6 = at_block_format_astc_5x5_hdr;
      goto LABEL_40;
    case 225:
      at_block_format_t v6 = at_block_format_astc_6x5_hdr;
      goto LABEL_40;
    case 226:
      at_block_format_t v6 = at_block_format_astc_6x6_hdr;
      goto LABEL_40;
    case 228:
      at_block_format_t v6 = at_block_format_astc_8x5_hdr;
      goto LABEL_40;
    case 229:
      at_block_format_t v6 = at_block_format_astc_8x6_hdr;
      goto LABEL_40;
    case 230:
      at_block_format_t v6 = at_block_format_astc_8x8_hdr;
      goto LABEL_40;
    case 231:
      at_block_format_t v6 = at_block_format_astc_10x5_hdr;
      goto LABEL_40;
    case 232:
      at_block_format_t v6 = at_block_format_astc_10x6_hdr;
      goto LABEL_40;
    case 233:
      at_block_format_t v6 = at_block_format_astc_10x8_hdr;
      goto LABEL_40;
    case 234:
      at_block_format_t v6 = at_block_format_astc_10x10_hdr;
      goto LABEL_40;
    case 235:
      at_block_format_t v6 = at_block_format_astc_12x10_hdr;
      goto LABEL_40;
    case 236:
      at_block_format_t v6 = at_block_format_astc_12x12_hdr;
LABEL_40:
      uint64_t v29 = a2;
      if (*((_DWORD *)this + 22) != 1) {
        goto LABEL_79;
      }
      uint64_t v36 = 0;
      v33[1] = 0;
      unint64_t v34 = 0;
      v33[0] = 0;
      int v35 = 0;
      id v8 = re::TextureData::mipmapLevelCount(this);
      re::DynamicArray<re::DynamicArray<re::Matrix4x4<float>>>::resize(v33, (unint64_t)v8);
      if (*((_DWORD *)this + 22) >= 2u) {
        goto LABEL_79;
      }
      int isHDR = re::isHDR((int)objc_msgSend(*((id *)this + 1), sel_pixelFormat));
      uint64_t v10 = 70;
      if ((WORD4(v37) & 0x800) != 0) {
        uint64_t v10 = 71;
      }
      BOOL v11 = isHDR == 0;
      if (isHDR) {
        at_texel_format_t v12 = at_texel_format_rgba16_float;
      }
      else {
        at_texel_format_t v12 = at_texel_format_rgba8_unorm;
      }
      if (!v11) {
        uint64_t v10 = 115;
      }
      uint64_t v31 = v10;
      encoder = at_encoder_create(v12, at_alpha_not_premultiplied, v6, at_alpha_not_premultiplied, 0);
      unsigned int FaceOrArrayLength = re::internal::getFaceOrArrayLength((id *)this, v13);
      if (!v8) {
        goto LABEL_71;
      }
      unint64_t v15 = 0;
      uint64_t v16 = &selRef_stepFunction_0;
      unint64_t v17 = &selRef_taskToken;
      uint64_t v30 = FaceOrArrayLength;
      break;
    default:
      switch((int)v5)
      {
        case 500:
        case 501:
        case 502:
        case 503:
        case 504:
        case 505:
        case 506:
        case 507:
        case 508:
        case 509:
        case 510:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 528:
        case 529:
        case 530:
        case 540:
        case 541:
        case 542:
        case 543:
        case 544:
        case 545:
        case 546:
        case 547:
        case 548:
        case 550:
        case 551:
        case 552:
        case 553:
        case 554:
        case 555:
        case 562:
        case 563:
        case 564:
        case 565:
        case 566:
        case 567:
        case 568:
        case 569:
        case 607:
        case 608:
        case 609:
        case 610:
        case 611:
        case 612:
        case 613:
        case 628:
        case 629:
          goto LABEL_6;
        default:
          goto LABEL_40;
      }
  }
  while (1)
  {
    uint64_t v48 = 0;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    *(_OWORD *)buf = 0u;
    long long v43 = 0u;
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    objc_msgSend(*((id *)this + 1), sel_pixelFormat);
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    [*((id *)this + 1) v16[26]];
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    [*((id *)this + 1) v17[268]];
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    objc_msgSend(*((id *)this + 1), sel_depth);
    MTLGetTextureLevelInfoForDeviceWithOptions();
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    [*((id *)this + 1) v16[26]];
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    uint64_t v18 = v17;
    [*((id *)this + 1) v17[268]];
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    id v19 = v8;
    objc_msgSend(*((id *)this + 1), sel_depth);
    MTLGetTextureLevelInfoForDeviceWithOptions();
    if (*((_DWORD *)this + 22) >= 2u) {
      goto LABEL_79;
    }
    if (objc_msgSend(*((id *)this + 1), sel_textureType) == 7) {
      uint64_t v20 = v43;
    }
    else {
      uint64_t v20 = v30;
    }
    unint64_t v21 = *((void *)this + 4);
    if (v21 <= v15)
    {
      *(void *)char v41 = 0;
      long long v53 = 0u;
      long long v54 = 0u;
      memset(dest, 0, sizeof(dest));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)src = 136315906;
      *(void *)&src[4] = "operator[]";
      *(_WORD *)&src[12] = 1024;
      *(_DWORD *)&src[14] = 797;
      *(_WORD *)&src[18] = 2048;
      *(void *)&src[20] = v15;
      __int16 v50 = 2048;
      unint64_t v51 = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_78:
      *(void *)char v41 = 0;
      long long v53 = 0u;
      long long v54 = 0u;
      memset(dest, 0, sizeof(dest));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)src = 136315906;
      *(void *)&src[4] = "operator[]";
      *(_WORD *)&src[12] = 1024;
      *(_DWORD *)&src[14] = 789;
      *(_WORD *)&src[18] = 2048;
      *(void *)&src[20] = v15;
      __int16 v50 = 2048;
      unint64_t v51 = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_79:
      std::__throw_bad_variant_access[abi:nn180100]();
    }
    uint64_t v22 = *((void *)this + 6);
    if (*(void *)(v22 + 40 * v15 + 16))
    {
      unint64_t v21 = v34;
      if (v34 <= v15) {
        goto LABEL_78;
      }
      uint64_t v23 = v36;
      re::DynamicArray<BOOL>::resize(v36 + 40 * v15, 0);
      if (v20) {
        break;
      }
    }
LABEL_69:
    ++v15;
    id v8 = v19;
    BOOL v11 = v15 == (void)v19;
    uint64_t v16 = &selRef_stepFunction_0;
    unint64_t v17 = v18;
    if (v11)
    {
LABEL_71:
      id v26 = objc_msgSend(*((id *)this + 1), sel_copy);
      objc_msgSend(v26, sel_setPixelFormat_, v31);
      re::CPUTexture::CPUTexture((uint64_t)buf, v26, (uint64_t)v33);
      *(unsigned char *)re::TextureData::TextureData(v29, (uint64_t)buf, (__CFString *)*((id *)this + 12)) = *(unsigned char *)this | 4;
      re::CPUTexture::~CPUTexture((id *)buf);
      if (v26) {

      }
      goto LABEL_76;
    }
  }
  uint64_t v24 = 0;
  while (1)
  {
    memset(dest, 0, 40);
    *(void *)dest = *(void *)(v23 + 40 * v15 + 32);
    *(int32x2_t *)&dest[8] = vmovn_s64(*(int64x2_t *)buf);
    *(_DWORD *)&dest[16] = 1;
    *(void *)&dest[24] = 0;
    *(void *)&src[8] = 0;
    *(void *)&src[16] = 0;
    *(void *)src = 0;
    *(void *)src = *(void *)(v22 + 40 * v15 + 32) + *((void *)&v47 + 1) * v24;
    *(void *)&src[8] = v47;
    long long v25 = (re *)at_encoder_decompress_texels(encoder, (const at_block_buffer_t *)src, (const at_texel_region_t *)dest, at_flags_default);
    if (v25) {
      break;
    }
    if (v20 == ++v24) {
      goto LABEL_69;
    }
  }
  CFStringRef v27 = v25;
  uint64_t v28 = *re::pipelineLogObjects(v25);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)char v41 = 134217984;
    *(void *)&v41[4] = v27;
    _os_log_error_impl(&dword_233120000, v28, OS_LOG_TYPE_ERROR, "Encoder failed (error: %ld) during texture creation", v41, 0xCu);
  }
  *(unsigned char *)v29 &= 0x80u;
  *(void *)(v29 + 8) = 0;
  *(_DWORD *)(v29 + 88) = 0;
  *(void *)(v29 + 96) = 0;
LABEL_76:

  re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v33);
}

void re::convertCPUTextureColorSpace(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = (char *)a2;
  uint64_t v108 = *MEMORY[0x263EF8340];
  CFStringRef v6 = (const __CFString *)*(id *)(a2 + 96);
  if (!v6) {
    goto LABEL_52;
  }
  CFStringRef v7 = v6;
  unsigned __int8 v83 = 0;
  if ((re::ColorHelpers::getColorGamutFromCGColorSpaceName(v6, (char *)&v83) & 1) == 0 || v83 == a1) {
    goto LABEL_52;
  }
  if (*((_DWORD *)v3 + 22) >= 2u) {
    goto LABEL_60;
  }
  CFStringRef CGColorSpaceNameForPixelFormat = (const __CFString *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat((int)objc_msgSend(*((id *)v3 + 1), sel_pixelFormat), a1);
  CGColorSpaceRef v9 = CGColorSpaceCreateWithName(CGColorSpaceNameForPixelFormat);
  if (!v9)
  {
LABEL_52:
    *(unsigned char *)a3 &= 0x80u;
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    return;
  }
  __int16 v50 = (__CFString *)CGColorSpaceNameForPixelFormat;
  uint64_t v82 = 0;
  long long v81 = 0u;
  long long v80 = 0u;
  long long v79 = 0u;
  if (*((_DWORD *)v3 + 22) >= 2u) {
    goto LABEL_60;
  }
  uint64_t v10 = v9;
  objc_msgSend(*((id *)v3 + 1), sel_pixelFormat);
  MTLPixelFormatGetInfoForDevice();
  char v75 = 0;
  v76[0] = 0;
  unsigned int v77 = 0;
  double v78 = 0.0;
  if ((BYTE9(v79) & 4) == 0)
  {
LABEL_15:
    if (*((_DWORD *)v3 + 22) == 1)
    {
      id v13 = CGColorSpaceCreateWithName(v7);
      if (v81 == 4) {
        char v14 = 3;
      }
      else {
        char v14 = 0;
      }
      int v15 = objc_msgSend(*((id *)v3 + 1), sel_pixelFormat);
      *(void *)&long long v85 = v13;
      *((void *)&v85 + 1) = CGColorSpaceGetNumberOfComponents(v13);
      LODWORD(v86) = CGColorSpaceGetModel(v13);
      unsigned int v49 = v13;
      CGColorSpaceRelease(v13);
      *(void *)&v67.bitsPerComponent = v71;
      *(_OWORD *)&v67.bitmapInfo = v72;
      *(void *)&v67.renderingIntent = v73;
      CGColorSpaceRef space = CGColorSpaceRetain(v74);
      size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v10);
      CGColorSpaceModel Model = CGColorSpaceGetModel(v10);
      uint64_t v18 = space;
      CGColorSpaceRef space = v10;
      size_t v69 = NumberOfComponents;
      CGColorSpaceModel v70 = Model;
      CGColorSpaceRelease(v18);
      v67.colorSpace = v10;
      unint64_t v19 = *((void *)v3 + 4);
      long long v53 = (id *)(v3 + 8);
      unsigned int FaceOrArrayLength = re::internal::getFaceOrArrayLength((id *)v3 + 1);
      uint64_t v66 = 0;
      v63[1] = 0;
      unint64_t v64 = 0;
      v63[0] = 0;
      int v65 = 0;
      unint64_t v21 = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<re::Matrix4x4<float>>>::resize(v63, v19);
      char v22 = *v3;
      char v62 = *v3;
      unint64_t v52 = v19;
      if (v19)
      {
        unint64_t v24 = 0;
        unint64_t v54 = FaceOrArrayLength;
        unint64_t v51 = v3;
        do
        {
          unint64_t v25 = *((void *)v3 + 4);
          if (v25 <= v24) {
            goto LABEL_58;
          }
          uint64_t v26 = *((void *)v3 + 6);
          unint64_t v27 = (unint64_t)objc_msgSend(*((id *)v3 + 1), sel_width) >> v24;
          if (v27 <= 1) {
            unint64_t v27 = 1;
          }
          unint64_t v59 = v27;
          unint64_t v28 = (unint64_t)objc_msgSend(*((id *)v3 + 1), sel_height) >> v24;
          if (v28 <= 1) {
            unint64_t v28 = 1;
          }
          unint64_t v61 = v28;
          unint64_t v60 = v54;
          if (objc_msgSend(*((id *)v3 + 1), sel_textureType) == 7)
          {
            unint64_t v29 = (unint64_t)objc_msgSend(*v53, sel_depth) >> v24;
            if (v29 <= 1) {
              unint64_t v29 = 1;
            }
            unint64_t v60 = v29;
          }
          unint64_t v25 = v64;
          if (v64 <= v24) {
            goto LABEL_59;
          }
          unint64_t v30 = v24;
          unint64_t v31 = *(void *)(v26 + 40 * v24 + 16);
          size_t v32 = (*((void *)&v80 + 1) * v59 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          __uint64_t n = v32 * v61;
          unint64_t v58 = v30;
          re::DynamicArray<BOOL>::resize(v66 + 40 * v30, v32 * v61 * v60);
          if (v60)
          {
            unint64_t v25 = 0;
            unint64_t v56 = v31 / v60;
            unsigned int v57 = (uint64_t *)(v26 + 40 * v58 + 32);
            while (1)
            {
              unint64_t v33 = v64;
              unint64_t v24 = v58;
              if (v64 <= v58) {
                break;
              }
              uint64_t v34 = *v57;
              uint64_t v35 = *(void *)(v66 + 40 * v58 + 32);
              LOBYTE(v100) = 0;
              *(void *)&long long v85 = v34 + v25 * v56;
              *((void *)&v85 + 1) = v61;
              *(void *)&long long v86 = v59;
              *((void *)&v86 + 1) = v32;
              long long v87 = v71;
              long long v88 = v72;
              long long v89 = v73;
              uint64_t v90 = 0;
              double v91 = (double)v59;
              double v92 = (double)v61;
              long long v93 = 0u;
              long long v94 = 0u;
              long long v95 = 0u;
              id v96 = 0;
              uint64_t v36 = CGColorSpaceRetain(*((CGColorSpaceRef *)&v71 + 1));
              CGColorSpaceRef v97 = v36;
              size_t v98 = CGColorSpaceGetNumberOfComponents(v36);
              CGColorSpaceModel v99 = CGColorSpaceGetModel(v36);
              if (v37)
              {
                long long v38 = (char *)(v35 + v25 * __n);
                long long v39 = (char *)v85;
                if (*((void *)&v86 + 1) == v32)
                {
                  memcpy(v38, (const void *)v85, __n);
                }
                else
                {
                  unint64_t v40 = v61;
                  do
                  {
                    memcpy(v38, v39, v32);
                    v39 += *((void *)&v86 + 1);
                    v38 += v32;
                    --v40;
                  }
                  while (v40);
                }
              }
              else
              {
                *(unsigned char *)a3 &= 0x80u;
                *(void *)(a3 + 8) = 0;
                *(_DWORD *)(a3 + 88) = 0;
                *(void *)(a3 + 96) = 0;
              }
              CGColorSpaceRelease(v97);
              CGColorSpaceRef v97 = 0;
              if (v96)
              {

                id v96 = 0;
              }
              char v41 = (void *)*((void *)&v95 + 1);
              *((void *)&v95 + 1) = 0;
              if (v41) {
                free(v41);
              }

              if ((void)v93) {
                CGImageBlockSetRelease();
              }
              if ((v37 & 1) == 0) {
                goto LABEL_51;
              }
              if (++v25 == v60) {
                goto LABEL_48;
              }
            }
            uint64_t v84 = 0;
            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            long long v85 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v100 = 136315906;
            long long v101 = "operator[]";
            __int16 v102 = 1024;
            int v103 = 789;
            __int16 v104 = 2048;
            unint64_t v105 = v58;
            __int16 v106 = 2048;
            unint64_t v107 = v33;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_58:
            uint64_t v84 = 0;
            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            long long v85 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v100 = 136315906;
            long long v101 = "operator[]";
            __int16 v102 = 1024;
            int v103 = 797;
            __int16 v104 = 2048;
            unint64_t v105 = v24;
            __int16 v106 = 2048;
            unint64_t v107 = v25;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_59:
            uint64_t v84 = 0;
            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            long long v85 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v100 = 136315906;
            long long v101 = "operator[]";
            __int16 v102 = 1024;
            int v103 = 789;
            __int16 v104 = 2048;
            unint64_t v105 = v24;
            __int16 v106 = 2048;
            unint64_t v107 = v25;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_48:
          unint64_t v24 = v58 + 1;
          uint64_t v3 = v51;
        }
        while (v58 + 1 != v52);
        char v22 = v62;
      }
      re::CPUTexture::CPUTexture((uint64_t)&v85, *v53, (uint64_t)v63);
      re::TextureData::TextureData(a3, (uint64_t)&v85, v50);
      *(unsigned char *)a3 = v22 | 0x10;
      CGColorSpaceRelease(v10);
      CGColorSpaceRelease(v49);
      re::CPUTexture::~CPUTexture((id *)&v85);
LABEL_51:
      re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v63);
      CGColorSpaceRelease(space);
      CGColorSpaceRelease(v74);
      goto LABEL_55;
    }
LABEL_60:
    uint64_t v42 = std::__throw_bad_variant_access[abi:nn180100]();
    return;
  }
  re::decompressCPUTexture((re *)v3, (uint64_t)&v85);
  char v75 = v85;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v76, (uint64_t)&v85 + 8);
  double v11 = v92;
  double v92 = 0.0;
  double v12 = v78;
  double v78 = v11;

  if (LODWORD(v91) != -1) {
    ((void (*)(long long *, char *))*(&off_26E715930 + LODWORD(v91)))(&v71, (char *)&v85 + 8);
  }
  if (!v77) {
    goto LABEL_13;
  }
  if (v77 != 1) {
    goto LABEL_60;
  }
  if (v76[3])
  {
LABEL_13:
    if (v76[0])
    {
      objc_msgSend(v76[0], sel_pixelFormat);
      MTLPixelFormatGetInfoForDevice();
      long long v79 = v85;
      long long v80 = v86;
      long long v81 = v87;
      uint64_t v82 = v88;
      uint64_t v3 = &v75;
      goto LABEL_15;
    }
  }
  CGColorSpaceRelease(v10);
  *(unsigned char *)a3 &= 0x80u;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 88) = 0;
  *(void *)(a3 + 96) = 0;
LABEL_55:

  if (v77 != -1) {
    ((void (*)(long long *, id *))*(&off_26E715930 + v77))(&v85, v76);
  }
}

void re::anonymous namespace'::cgFormatForTextureDestination(uint64_t a1, int a2, uint64_t *a3, char a4, int a5, uint64_t a6, int a7)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  unsigned int v10 = 8 * *((_DWORD *)a3 + 6);
  unsigned int v11 = *((unsigned __int8 *)a3 + 32);
  unsigned int v12 = v10 / v11;
  uint64_t v13 = a4 & 0x1F;
  if (a7 == 2)
  {
    uint64_t v16 = v13 - 1;
    if (v16 < 6)
    {
      int v14 = dword_23440AEF4[v16];
      int v15 = dword_23440AF0C[(int)v16];
      goto LABEL_11;
    }
  }
  else
  {
    if (a7 == 1)
    {
      int v15 = 1;
      int v14 = 2;
      goto LABEL_11;
    }
    if (a7)
    {
      int v14 = 0;
      int v15 = 0;
      goto LABEL_11;
    }
    if (v13 < 7)
    {
      int v14 = dword_23440AEBC[a4 & 0x1F];
      int v15 = dword_23440AED8[a4 & 0x1F];
      goto LABEL_11;
    }
  }
  int v15 = 3;
  int v14 = 4;
LABEL_11:
  if (v12 <= 7)
  {
    BOOL v17 = v10 == 16;
    goto LABEL_16;
  }
  if (v12 != 8)
  {
    BOOL v17 = v12 == 16;
LABEL_16:
    if (v17) {
      int v18 = 4096;
    }
    else {
      int v18 = 0x2000;
    }
    goto LABEL_19;
  }
  int v18 = 0;
LABEL_19:
  int v19 = 0;
  switch(a2)
  {
    case 0:
    case 92:
    case 93:
    case 94:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 140:
    case 141:
    case 142:
    case 143:
    case 150:
    case 151:
    case 152:
    case 153:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 170:
    case 172:
    case 174:
    case 176:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 240:
    case 241:
    case 250:
    case 252:
    case 253:
    case 255:
    case 260:
    case 261:
    case 262:
LABEL_22:
      uint64_t v20 = *re::pipelineLogObjects((re *)a1);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = *a3;
        int v29 = 136446210;
        uint64_t v30 = v22;
        _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "No CG image format corresponds to pixel format %{public}s", (uint8_t *)&v29, 0xCu);
      }
      *(_OWORD *)(a1 + 16) = unk_23440AD40;
      *(void *)(a1 + 40) = 0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 32) = 0;
      int v21 = -1;
      goto LABEL_43;
    case 1:
      int v19 = 7;
      goto LABEL_34;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 21:
    case 26:
    case 27:
    case 28:
    case 29:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 56:
    case 57:
    case 58:
    case 59:
    case 61:
    case 66:
    case 67:
    case 68:
    case 69:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 106:
    case 107:
    case 108:
    case 109:
    case 111:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 126:
    case 127:
    case 128:
    case 129:
    case 136:
    case 137:
    case 138:
    case 139:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 168:
    case 169:
    case 171:
    case 173:
    case 175:
    case 177:
    case 184:
    case 185:
    case 191:
    case 201:
    case 202:
    case 203:
    case 209:
    case 219:
    case 220:
    case 221:
    case 227:
    case 237:
    case 238:
    case 239:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 251:
    case 254:
    case 256:
    case 257:
    case 258:
    case 259:
      goto LABEL_34;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 22:
    case 23:
    case 24:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 53:
    case 54:
    case 60:
    case 62:
    case 63:
    case 64:
    case 103:
    case 104:
      int v19 = v18;
      goto LABEL_34;
    case 25:
    case 55:
    case 65:
    case 105:
      int v19 = v18 | 0x100;
      goto LABEL_34;
    case 40:
      int v19 = 4096;
      goto LABEL_34;
    case 41:
    case 42:
      int v19 = 4099;
      goto LABEL_34;
    case 43:
      int v19 = v14 | 0x1000;
      goto LABEL_34;
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 90:
    case 91:
    case 110:
    case 112:
    case 113:
    case 114:
    case 123:
    case 124:
      int v19 = v18 | v15;
      goto LABEL_34;
    case 80:
    case 81:
LABEL_27:
      int v19 = v14 | 0x2000;
      goto LABEL_34;
    case 115:
    case 125:
      int v19 = v15 | v18 | 0x100;
LABEL_34:
      uint64_t v23 = *(CGColorSpace **)a6;
      BOOL v25 = (v19 & 0x1F) == 0 && *(void *)(a6 + 8) == 1 && v11 == 2;
      unsigned int v26 = v19 & 0xFFFFFFE0 | 3;
      if (!v25) {
        unsigned int v26 = v19;
      }
      *(_DWORD *)a1 = v12;
      *(_DWORD *)(a1 + 4) = v10;
      *(void *)(a1 + 8) = v23;
      *(_DWORD *)(a1 + 16) = v26;
      *(_DWORD *)(a1 + 20) = 0;
      *(void *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 32) = a5;
      *(_DWORD *)(a1 + 36) = 0;
      CGColorSpaceRef v27 = CGColorSpaceRetain(v23);
      uint64_t v28 = *(void *)(a6 + 8);
      *(void *)(a1 + 40) = v27;
      *(void *)(a1 + 48) = v28;
      int v21 = *(_DWORD *)(a6 + 16);
LABEL_43:
      *(_DWORD *)(a1 + 56) = v21;
      return;
    default:
      switch(a2)
      {
        case 500:
        case 501:
        case 502:
        case 503:
        case 504:
        case 505:
        case 506:
        case 507:
        case 508:
        case 509:
        case 510:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 528:
        case 529:
        case 530:
        case 540:
        case 541:
        case 542:
        case 543:
        case 544:
        case 545:
        case 546:
        case 547:
        case 548:
        case 550:
        case 551:
        case 562:
        case 563:
        case 564:
        case 565:
        case 566:
        case 567:
        case 568:
        case 569:
        case 607:
        case 608:
        case 609:
        case 610:
        case 611:
        case 612:
        case 613:
        case 628:
        case 629:
          goto LABEL_22;
        case 552:
        case 553:
          goto LABEL_27;
        case 554:
        case 555:
          int v19 = 0x2000;
          goto LABEL_34;
        default:
          goto LABEL_34;
      }
  }
}

void re::anonymous namespace'::logFormatConversionInfo(re::_anonymous_namespace_ *this, const vImage_CGImageFormat *a2, const vImage_CGImageFormat *a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  CFStringRef v5 = (re *)MEMORY[0x237DBE8D0](this, a2, a3);
  if (!v5)
  {
    CFStringRef v6 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *((void *)this + 1);
      int v9 = *(_DWORD *)this;
      int v8 = *((_DWORD *)this + 1);
      int v10 = *((_DWORD *)this + 4);
      CGColorSpaceRef colorSpace = a2->colorSpace;
      uint32_t bitsPerComponent = a2->bitsPerComponent;
      uint32_t bitsPerPixel = a2->bitsPerPixel;
      CGBitmapInfo bitmapInfo = a2->bitmapInfo;
      int v15 = 138414082;
      uint64_t v16 = v7;
      __int16 v17 = 1024;
      int v18 = v8;
      __int16 v19 = 1024;
      int v20 = v9;
      __int16 v21 = 1024;
      int v22 = v10;
      __int16 v23 = 2112;
      CGColorSpaceRef v24 = colorSpace;
      __int16 v25 = 1024;
      uint32_t v26 = bitsPerPixel;
      __int16 v27 = 1024;
      uint32_t v28 = bitsPerComponent;
      __int16 v29 = 1024;
      CGBitmapInfo v30 = bitmapInfo;
      _os_log_debug_impl(&dword_233120000, v6, OS_LOG_TYPE_DEBUG, "Format conversion required on texture import:\nSource format: %@, %u bpp, %u bpc, 0x%08x info\nDestination format: %@, %u bpp, %u bpc, 0x%08x info", (uint8_t *)&v15, 0x3Au);
    }
  }
}

uint64_t re::anonymous namespace'::vImageBufferStorage::vImageBufferStorage(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v5;
  long long v6 = *a3;
  long long v7 = a3[1];
  *(void *)(a1 + 64) = *((void *)a3 + 4);
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)(a1 + 48) = v7;
  int8x16_t v8 = (int8x16_t)vcvtq_f64_u64(*(uint64x2_t *)(a2 + 8));
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(int8x16_t *)(a1 + 88) = vextq_s8(v8, v8, 8uLL);
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  int v9 = CGColorSpaceRetain(*((CGColorSpaceRef *)a3 + 1));
  *(void *)(a1 + 160) = v9;
  *(void *)(a1 + 168) = CGColorSpaceGetNumberOfComponents(v9);
  *(_DWORD *)(a1 + 176) = CGColorSpaceGetModel(v9);
  int v10 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = *(void *)a2;
  if (v10) {
    free(v10);
  }
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return a1;
}

uint64_t re::anonymous namespace'::convertBufferToFormat(uint64_t a1, vImage_CGImageFormat *a2, uint64_t a3, unsigned char *a4, unsigned char *a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  int v10 = (const vImage_CGImageFormat *)(a1 + 32);
  *a4 = 0;
  if (MEMORY[0x237DBE8D0](a1 + 32)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 36) != a2->bitsPerPixel
    || *(_DWORD *)(a1 + 48) != a2->bitmapInfo
    || v10->bitsPerComponent != a2->bitsPerComponent)
  {
    *a5 |= 0x40u;
  }
  vImage_Error error = 0;
  unsigned int v12 = vImageConverter_CreateWithCGImageFormat(v10, a2, 0, 0, &error);
  if (!v12)
  {
    __int16 v17 = CGColorConversionInfoCreate(*(CGColorSpaceRef *)(a1 + 40), a2->colorSpace);
    if (!v17
      || (int v18 = v17,
          unsigned int v12 = vImageConverter_CreateWithCGColorConversionInfo(v17, v10, a2, 0, 0, &error),
          CFRelease(v18),
          !v12))
    {
      __int16 v19 = *re::pipelineLogObjects(v17);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = error;
        _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, "Failed to create an image converter during texture creation (vImage error: %zd)", buf, 0xCu);
      }
      return 0;
    }
  }
  if (vImageConverter_GetNumberOfSourceBuffers(v12) != 1)
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) ", "vImageConverter_GetNumberOfSourceBuffers(converter) == 1", "convertBufferToFormat", 2765);
    _os_crash();
    __break(1u);
LABEL_38:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) ", "vImageConverter_GetNumberOfDestinationBuffers(converter) == 1", "convertBufferToFormat", 2766);
    _os_crash();
    __break(1u);
  }
  if (vImageConverter_GetNumberOfDestinationBuffers(v12) != 1) {
    goto LABEL_38;
  }
  memset(&dests, 0, sizeof(dests));
  int v15 = (re *)MEMORY[0x237DBE8C0](&dests, *(void *)(a1 + 8), *(void *)(a1 + 16), a2->bitsPerPixel, 0);
  vImage_Error error = (vImage_Error)v15;
  if (v15)
  {
    uint64_t v16 = *re::pipelineLogObjects(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = error;
      _os_log_error_impl(&dword_233120000, v16, OS_LOG_TYPE_ERROR, "Failed to allocate an image buffer during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    goto LABEL_28;
  }
  vImage_Error v20 = vImageConvert_AnyToAny(v12, (const vImage_Buffer *)a1, &dests, 0, 0x90u);
  vImage_Error v21 = v20;
  if (v20 < 0)
  {
    uint32_t v26 = *re::pipelineLogObjects((re *)v20);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_error_impl(&dword_233120000, v26, OS_LOG_TYPE_ERROR, "Failed to prepare image converter during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    goto LABEL_27;
  }
  if (v20)
  {
    int v22 = *re::pipelineLogObjects((re *)v20);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_debug_impl(&dword_233120000, v22, OS_LOG_TYPE_DEBUG, "Format conversion requires %zd bytes of temp buffer", buf, 0xCu);
    }
  }
  __int16 v23 = (void *)(*(uint64_t (**)(uint64_t, vImage_Error, void))(*(void *)a3 + 32))(a3, v21, *MEMORY[0x263EF8AF8]);
  CGColorSpaceRef v24 = (re *)vImageConvert_AnyToAny(v12, (const vImage_Buffer *)a1, &dests, v23, 0x10u);
  vImage_Error error = (vImage_Error)v24;
  if (v24)
  {
    __int16 v25 = *re::pipelineLogObjects(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = error;
      _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, "Failed to convert image during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    (*(void (**)(uint64_t, void *))(*(void *)a3 + 40))(a3, v23);
LABEL_27:
    free(dests.data);
LABEL_28:
    vImageConverter_Release(v12);
    return 0;
  }
  (*(void (**)(uint64_t, void *))(*(void *)a3 + 40))(a3, v23);
  vImageConverter_Release(v12);
  CGColorSpaceRelease(space);
  CGColorSpaceRef space = 0;
  if (v34)
  {

    id v34 = 0;
  }
  __int16 v27 = v33;
  unint64_t v33 = 0;
  if (v27) {
    free(v27);
  }

  if (v31) {
    CGImageBlockSetRelease();
  }
  uint64_t result = 1;
  *a4 = 1;
  return result;
}

uint64_t re::internal::createCompressedCPUTextureData@<X0>(id *a1@<X0>, int a2@<W1>, int a3@<W2>, id *a4@<X3>, unsigned int *a5@<X4>, id *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v49 = 0;
  v46[1] = 0;
  uint64_t v47 = 0;
  v46[0] = 0;
  int v48 = 0;
  char v43 = 0;
  memset(v44, 0, sizeof(v44));
  uint64_t v42[2] = 0;
  v42[0] = 0;
  v42[1] = 8;
  dispatch_get_global_queue(21, 0);
  id v45 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v36 = a5;
  long long v39 = *(_OWORD *)a5;
  int v40 = a2;
  int v41 = a3;
  uint64_t v13 = (id *)objc_msgSend(*a4, sel_mipmapLevelCount);
  unsigned int FaceOrArrayLength = re::internal::getFaceOrArrayLength(a4);
  re::DynamicArray<re::DynamicArray<re::Matrix4x4<float>>>::resize(v46, (unint64_t)v13);
  if (v13 <= a6)
  {
LABEL_21:
    re::CPUTexture::CPUTexture((uint64_t)&v53, *a4, (uint64_t)v46);
    v51[0] = (id)v53;
    re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray((uint64_t)&v51[1], (uint64_t *)&v53 + 1);
    re::DynamicString::DynamicString((re::DynamicString *)v52, (const re::DynamicString *)&v56);
    *(unsigned char *)a7 = 1;
    *(void *)(a7 + 8) = v51[0];
    re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray(a7 + 16, (uint64_t *)&v51[1]);
    re::DynamicString::DynamicString((re::DynamicString *)(a7 + 56), (const re::DynamicString *)v52);
    re::CPUTexture::~CPUTexture(v51);
    re::CPUTexture::~CPUTexture((id *)&v53);
  }
  else
  {
    unint64_t v33 = a1;
    unint64_t v34 = FaceOrArrayLength;
LABEL_3:
    int v15 = (id *)a1[2];
    if (v15 <= a6) {
      goto LABEL_33;
    }
    uint64_t v16 = a1[4];
    unint64_t v17 = v34;
    if (objc_msgSend(*a4, sel_textureType) == (id)7)
    {
      unint64_t v18 = (unint64_t)objc_msgSend(*a4, sel_depth);
      if (v18 >> (char)a6 <= 1) {
        unint64_t v17 = 1;
      }
      else {
        unint64_t v17 = v18 >> (char)a6;
      }
    }
    unint64_t v19 = v16[5 * (void)a6 + 2] / v17;
    vImagePixelCount v20 = (unint64_t)objc_msgSend(*a4, sel_width) >> (char)a6;
    if (v20 <= 1) {
      vImagePixelCount v20 = 1;
    }
    v38.width = v20;
    unint64_t v21 = (unint64_t)objc_msgSend(*a4, sel_height);
    if (v21 >> (char)a6 <= 1) {
      vImagePixelCount v22 = 1;
    }
    else {
      vImagePixelCount v22 = v21 >> (char)a6;
    }
    v38.height = v22;
    v38.rowBytes = v19 / v22;
    a1 = v47;
    if (v47 <= a6) {
      goto LABEL_34;
    }
    unint64_t v25 = v17 * ((v22 + v24 - 1) / v24) * ((v23 + v38.width - 1) / v23);
    if (*(void *)(v49 + 40 * (void)a6 + 8) < 16 * v25) {
      re::DynamicArray<BOOL>::setCapacity((void *)(v49 + 40 * (void)a6), 16 * v25);
    }
    a1 = 0;
    uint32_t v26 = &v16[5 * (void)a6 + 4];
    while (1)
    {
      v38.data = (void *)(*v26 + (void)a1 * v19);
      __int16 v27 = v47;
      if (v47 <= a6)
      {
        uint64_t v50 = 0;
        int v15 = v51;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v53 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 789;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        v38.data = 0;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v53 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 797;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        v37[0] = 0;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v53 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 789;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = a1;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v37[0] = &unk_26E715AC8;
      v37[1] = v49 + 40 * (void)a6;
      void v37[2] = 0;
      if (!(_BYTE)v53) {
        break;
      }
      a1 = (id *)((char *)a1 + 1);
      if (!--v17)
      {
        a6 = (id *)((char *)a6 + 1);
        a1 = v33;
        if (a6 == v13) {
          goto LABEL_21;
        }
        goto LABEL_3;
      }
    }
    if (v54) {
      uint32_t v28 = (char *)*((void *)&v54 + 1);
    }
    else {
      uint32_t v28 = (char *)&v54 + 1;
    }
    re::DynamicString::format((re::DynamicString *)"Failed to compress image buffer during texture creation: %s", (re::DynamicString *)v51, v28);
    long long v29 = *(_OWORD *)v51;
    id v30 = v51[2];
    id v31 = v51[3];
    *(unsigned char *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v29;
    *(void *)(a7 + 24) = v30;
    *(void *)(a7 + 32) = v31;
    if (!(_BYTE)v53 && *((void *)&v53 + 1) && (v54 & 1) != 0) {
      (*(void (**)(void))(**((void **)&v53 + 1) + 40))();
    }
  }
  if (*(void *)&v44[4])
  {
    astcenc_context_free(*(uint64_t *)&v44[4]);
    *(void *)&v44[4] = 0;
  }

  return re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v46);
}

void re::anonymous namespace'::compressTextureWithImageBuffer(uint64_t a1, uint64_t a2, const vImage_Buffer *a3, uint64_t a4, re::ASTCCompressor *a5)
{
  char v37 = 0;
  memset(v38, 0, sizeof(v38));
  v36[2] = 0;
  v36[0] = 0;
  v36[1] = 8;
  dispatch_get_global_queue(21, 0);
  id v39 = (id)objc_claimAutoreleasedReturnValue();
  if (a5) {
    int v10 = a5;
  }
  else {
    int v10 = (re::ASTCCompressor *)v36;
  }
  re::ASTCCompressor::initializeContext((uint64_t)v10, a4, *(_DWORD *)(a4 + 16), *(_DWORD *)(a4 + 20), (uint64_t)v32);
  if (!v32[0])
  {
    if (v34) {
      unint64_t v18 = *(unsigned char **)&v35[7];
    }
    else {
      unint64_t v18 = v35;
    }
    re::DynamicString::format((re::DynamicString *)"Encoder failed during texture creation: %s", (re::DynamicString *)&v29, v18);
    goto LABEL_16;
  }
  vImagePixelCount height = a3->height;
  vImagePixelCount width = a3->width;
  if (a5) {
    uint64_t v13 = a5;
  }
  else {
    uint64_t v13 = (re::ASTCCompressor *)v36;
  }
  uint64_t v16 = (_anonymous_namespace_ *)(**(uint64_t (***)(uint64_t, unint64_t))a2)(a2, (height + v15 - 1) / v15 * 16 * ((width + v14 - 1) / v14));
  if ((v16 & 1) == 0)
  {
LABEL_16:
    long long v19 = v29;
    uint64_t v20 = v30;
    unint64_t v21 = v31;
    *(unsigned char *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v19;
    *(void *)(a1 + 24) = v20;
    *(void *)(a1 + 32) = v21;
    goto LABEL_17;
  }
  unint64_t v17 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  re::ASTCCompressor::compress(v10, a3, v17, (uint64_t)&v29);
  if ((_BYTE)v29)
  {
    *(unsigned char *)a1 = 1;
  }
  else
  {
    if (v30) {
      vImagePixelCount v22 = v31;
    }
    else {
      vImagePixelCount v22 = (char *)&v30 + 1;
    }
    re::DynamicString::format((re::DynamicString *)"Encoder failed during texture creation: %s", (re::DynamicString *)&v26, v22);
    long long v23 = v26;
    uint64_t v24 = v27;
    uint64_t v25 = v28;
    *(unsigned char *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v23;
    *(void *)(a1 + 24) = v24;
    *(void *)(a1 + 32) = v25;
    if (!(_BYTE)v29 && *((void *)&v29 + 1) && (v30 & 1) != 0) {
      (*(void (**)(void))(**((void **)&v29 + 1) + 40))();
    }
  }
LABEL_17:
  if (!v32[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  if (*(void *)&v38[4])
  {
    astcenc_context_free(*(uint64_t *)&v38[4]);
    *(void *)&v38[4] = 0;
  }
}

uint64_t re::anonymous namespace'::createBufferWithImageUsingVImage(uint64_t a1, uint64_t *a2, vImage_CGImageFormat *a3, uint64_t a4, unsigned char *a5, unsigned char *a6)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  if (*a2)
  {
    *a5 = 0;
  }
  else
  {
    unsigned int v12 = *re::pipelineLogObjects((re *)a1);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (v13)
    {
      *(_WORD *)vImage_CGImageFormat v67 = 0;
      _os_log_error_impl(&dword_233120000, v12, OS_LOG_TYPE_ERROR, "Failed to create buffer from image due to invalid image", v67, 2u);
    }
    uint64_t v14 = *a2;
    *a5 = 0;
    if (!v14)
    {
      unint64_t v15 = *re::pipelineLogObjects((re *)v13);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_233120000, v15, OS_LOG_TYPE_ERROR, "Failed to create buffer from image due to invalid image", buf, 2u);
      }
    }
  }
  uint64_t v16 = (void *)MEMORY[0x237DBDCF0]();
  if (CGImageGetImageProvider())
  {
    uint64_t v77 = *MEMORY[0x263F00358];
    uint64_t v78 = MEMORY[0x263EFFA88];
    uint64_t v66 = [NSDictionary dictionaryWithObjects:&v78 forKeys:&v77 count:1];
    uint64_t v17 = CGImageProviderCopyImageBlockSetWithOptions();
    if (v17 || (uint64_t v17 = CGImageProviderCopyImageBlockSetWithOptions()) != 0)
    {
      Count = (re *)CGImageBlockSetGetCount();
      if (Count == (re *)1)
      {
        unint64_t v64 = a3;
        uint64_t v65 = a4;
        int BitmapInfo = CGImageProviderGetBitmapInfo();
        ComponentCFStringRef Type = CGImageBlockSetGetComponentType();
        uint64_t ColorSpace = CGImageBlockSetGetColorSpace();
        uint64_t PixelSize = CGImageBlockSetGetPixelSize();
        *(_OWORD *)vImage_CGImageFormat v67 = 0u;
        long long v68 = 0u;
        if (ComponentType >= 7)
        {
          re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) ", "0 <= componentType && componentType < countOf(kImageProviderComponentTypes)", "imageProviderComponentType", 956);
          _os_crash();
          __break(1u);
        }
        uint64_t v24 = PixelSize;
        if (ComponentType && ComponentType != 3)
        {
          DWORD1(v69) = 8 * PixelSize;
          *((void *)&v69 + 1) = ColorSpace;
          *(_DWORD *)CGColorSpaceModel v70 = BitmapInfo;
          *(void *)&v70[12] = 0;
          *(void *)&v70[4] = 0;
        }
        else
        {
          uint64_t v25 = *re::pipelineLogObjects((re *)PixelSize);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = ComponentType;
            _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, "Unsupported CGImageComponentType %d during texture creation", buf, 8u);
          }
          *(_OWORD *)CGColorSpaceModel v70 = unk_23440AD40;
          *(void *)&v70[16] = 0;
        }
        memset(&v70[24], 0, 32);
        *(void *)&long long v71 = v17;
        DWORD2(v71) = ComponentType;
        *(void *)&long long v72 = ColorSpace;
        *((void *)&v72 + 1) = v24;
        long long v73 = 0u;
        *(_OWORD *)CGColorSpaceRef v74 = 0u;
        size_t space_8 = 0;
        LODWORD(v76) = -1;
        CGImageBlockSetGetImageBlock();
        CGImageBlockSetGetSize();
        double v41 = v40;
        double v43 = v42;
        uint64_t Data = CGImageBlockGetData();
        uint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
        *(void *)vImage_CGImageFormat v67 = Data;
        *(void *)&v67[8] = (unint64_t)v43;
        *(void *)&long long v68 = (unint64_t)v41;
        *((void *)&v68 + 1) = BytesPerRow;
        CGImageBlockGetRect();
        *(void *)&v70[24] = v46;
        *(void *)&v70[32] = v47;
        *(void *)&v70[40] = v48;
        *(void *)&v70[48] = v49;
        CGImagePtr::CGImagePtr((CGImagePtr *)buf, 0);
        CGImagePtr::swap(v50, (CGImagePtr *)a2);
        CGImageRelease(*(CGImageRef *)buf);
        *(void *)buf = 0;
        CGColorSpaceRelease(v80);
        CGColorSpaceRef v80 = 0;
        a3 = v64;
        a4 = v65;
        goto LABEL_33;
      }
      vImage_Buffer v38 = *re::pipelineLogObjects(Count);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_233120000, v38, OS_LOG_TYPE_ERROR, "Failed to create a single image block from a CGImageProvider during texture creation", buf, 2u);
      }
      CGImageBlockSetRelease();
      *(_OWORD *)vImage_CGImageFormat v67 = 0u;
      long long v68 = 0u;
      *(_OWORD *)CGColorSpaceModel v70 = unk_23440AD40;
      memset(&v70[16], 0, 40);
      size_t space_8 = 0;
      uint64_t v76 = 0;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      *(_OWORD *)CGColorSpaceRef v74 = 0u;
    }
    else
    {
      unint64_t v51 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_233120000, v51, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGImageProvider during texture creation", buf, 2u);
      }
      *(_OWORD *)vImage_CGImageFormat v67 = 0u;
      long long v68 = 0u;
      *(_OWORD *)CGColorSpaceModel v70 = unk_23440AD40;
      memset(&v70[16], 0, 40);
      size_t space_8 = 0;
      uint64_t v76 = 0;
      *(_OWORD *)CGColorSpaceRef v74 = 0u;
      long long v73 = 0u;
      long long v72 = 0u;
      long long v71 = 0u;
    }
    LODWORD(v76) = -1;
LABEL_33:

    goto LABEL_38;
  }
  DataProvider = CGImageGetDataProvider((CGImageRef)*a2);
  if (DataProvider)
  {
    uint64_t v27 = v16;
    CFDataRef v28 = CGDataProviderCopyData(DataProvider);
    CFDataRef v29 = v28;
    if (v28)
    {
      CFDataRef v30 = v28;
      uint64_t v31 = [(__CFData *)v30 bytes];
      unint64_t v33 = a2[1];
      unint64_t v32 = a2[2];
      *(void *)vImage_CGImageFormat v67 = v31;
      *(void *)&v67[8] = v32;
      uint64_t v35 = a2[5];
      char v34 = (CGColorSpace *)a2[6];
      *(void *)&long long v68 = v33;
      *((void *)&v68 + 1) = v35;
      *(int32x2_t *)&long long v69 = vmovn_s64(*(int64x2_t *)(a2 + 3));
      *((void *)&v69 + 1) = v34;
      *(_DWORD *)CGColorSpaceModel v70 = *((_DWORD *)a2 + 18);
      *(_OWORD *)&v70[4] = 0uLL;
      *(void *)&v70[24] = 0;
      *(void *)&v70[32] = 0;
      *(double *)&v70[40] = (double)v33;
      *(double *)&v70[48] = (double)v32;
      long long v72 = 0u;
      long long v71 = 0u;
      v74[0] = 0;
      long long v73 = (unint64_t)v30;
      uint64_t v36 = CGColorSpaceRetain(v34);
      v74[1] = v36;
      size_t space_8 = CGColorSpaceGetNumberOfComponents(v36);
      LODWORD(v76) = CGColorSpaceGetModel(v36);
      CGImagePtr::CGImagePtr((CGImagePtr *)buf, 0);
      CGImagePtr::swap(v37, (CGImagePtr *)a2);
      CGImageRelease(*(CGImageRef *)buf);
      *(void *)buf = 0;
      CGColorSpaceRelease(v80);
      CGColorSpaceRef v80 = 0;
    }
    else
    {
      unint64_t v52 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_233120000, v52, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGDataProvider during texture creation", buf, 2u);
      }
      *(_OWORD *)vImage_CGImageFormat v67 = 0u;
      long long v68 = 0u;
      *(_OWORD *)CGColorSpaceModel v70 = unk_23440AD40;
      memset(&v70[16], 0, 40);
      size_t space_8 = 0;
      *(_OWORD *)CGColorSpaceRef v74 = 0u;
      long long v73 = 0u;
      long long v72 = 0u;
      long long v71 = 0u;
      uint64_t v76 = 0xFFFFFFFFLL;
    }

    uint64_t v16 = v27;
  }
  else
  {
    id v39 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_233120000, v39, OS_LOG_TYPE_ERROR, "Failed to create a texture because it is not backed by an image or data provider", buf, 2u);
    }
    *(_OWORD *)vImage_CGImageFormat v67 = 0u;
    long long v68 = 0u;
    *(_OWORD *)CGColorSpaceModel v70 = unk_23440AD40;
    memset(&v70[16], 0, 40);
    size_t space_8 = 0;
    *(_OWORD *)CGColorSpaceRef v74 = 0u;
    long long v73 = 0u;
    long long v72 = 0u;
    long long v71 = 0u;
    uint64_t v76 = 0xFFFFFFFFLL;
  }
LABEL_38:
  if (*(_DWORD *)&v70[4])
  {
    long long v54 = *re::pipelineLogObjects(v53);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_233120000, v54, OS_LOG_TYPE_ERROR, "Failed to create buffer from image during texture creation", buf, 2u);
    }
  }
  {
    long long v55 = *(_OWORD *)&v70[32];
    *(_OWORD *)(a1 + 64) = *(_OWORD *)&v70[16];
    *(_OWORD *)(a1 + 80) = v55;
    long long v56 = v68;
    *(_OWORD *)a1 = *(_OWORD *)v67;
    *(_OWORD *)(a1 + 16) = v56;
    long long v57 = *(_OWORD *)v70;
    *(_OWORD *)(a1 + 32) = v69;
    *(_OWORD *)(a1 + 48) = v57;
    uint64_t v58 = v71;
    *(void *)(a1 + 96) = *(void *)&v70[48];
    *(void *)(a1 + 104) = v58;
    *(_DWORD *)(a1 + 112) = DWORD2(v71);
    uint64_t v59 = *((void *)&v72 + 1);
    *(void *)(a1 + 120) = v72;
    *(void *)(a1 + 128) = v59;
    *(void *)&long long v71 = 0;
    *(void *)&long long v72 = 0;
    long long v60 = v73;
    long long v73 = 0u;
    *(_OWORD *)(a1 + 136) = v60;
    *(_OWORD *)(a1 + 152) = *(_OWORD *)v74;
    size_t v61 = space_8;
    size_t space_8 = 0;
    *(void *)(a1 + 168) = v61;
    LODWORD(v61) = v76;
    LODWORD(v76) = -1;
    *(_DWORD *)(a1 + 176) = v61;
    *(_OWORD *)CGColorSpaceRef v74 = 0u;
    goto LABEL_44;
  }
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 48) = unk_23440AD40;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 176) = -1;
LABEL_44:
  CGColorSpaceRelease((CGColorSpaceRef)v74[1]);
  v74[1] = 0;
  if (v74[0])
  {

    v74[0] = 0;
  }
  char v62 = (void *)*((void *)&v73 + 1);
  *((void *)&v73 + 1) = 0;
  if (v62) {
    free(v62);
  }

  uint64_t result = v71;
  if ((void)v71) {
    return CGImageBlockSetRelease();
  }
  return result;
}

void re::anonymous namespace'::compressTextureWithImageBuffer(uint64_t a1, void *a2, const vImage_Buffer *a3, uint64_t a4, re::ASTCCompressor *a5)
{
  long long v19 = &unk_26E7158F8;
  id v20 = a2;
  id v21 = 0;

  if (v16[0])
  {
    id v9 = v21;
    uint64_t v10 = v22;
    uint64_t v11 = v25;
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = v10;
    *(void *)(a1 + 32) = 0;
    *(void *)&long long v12 = v23;
    *((void *)&v12 + 1) = v24;
    *(_OWORD *)(a1 + 40) = v12;
    *(void *)(a1 + 56) = v11;
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)&v17);
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 32) = v15;
    *(_OWORD *)(a1 + 16) = v14;
    if (v17 && (v18 & 1) != 0) {
      (*(void (**)(void))(*(void *)v17 + 40))();
    }
  }
  long long v19 = &unk_26E7158F8;
  if (v21)
  {

    id v21 = 0;
  }
}

void re::anonymous namespace'::scaleImageBufferUsingVImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, vImage_Error a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  memset(&v21, 0, sizeof(v21));
  uint64_t v10 = (re *)MEMORY[0x237DBE8C0](&v21, a4, a3, *(unsigned int *)(a2 + 36), 0);
  if (v10)
  {
    uint64_t v11 = v10;
    long long v12 = *re::pipelineLogObjects(v10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      vImagePixelCount width = (vImagePixelCount)v11;
      _os_log_error_impl(&dword_233120000, v12, OS_LOG_TYPE_ERROR, "Failed to allocate an image buffer during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 48) = unk_23440AD40;
    *(_OWORD *)(a1 + 64) = 0u;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    goto LABEL_16;
  }
  vImagePixelCount v14 = v13;
  if (v13 < 0)
  {
    id v20 = *re::pipelineLogObjects((re *)v13);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      vImagePixelCount width = v14;
      _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "Failed to get temp buffer size for image scaling during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    goto LABEL_15;
  }
  if (v13)
  {
    uint64_t v15 = *re::pipelineLogObjects((re *)v13);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218496;
      vImagePixelCount width = v21.width;
      __int16 v24 = 2048;
      vImagePixelCount height = v21.height;
      __int16 v26 = 2048;
      vImagePixelCount v27 = v14;
      _os_log_debug_impl(&dword_233120000, v15, OS_LOG_TYPE_DEBUG, "Image scaling to %lux%lu requires %zd bytes of temp buffer", buf, 0x20u);
    }
  }
  uint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, vImagePixelCount, void))(*(void *)a6 + 32))(a6, v14, *MEMORY[0x263EF8AF8]);
  if (v17)
  {
    char v18 = v17;
    long long v19 = *re::pipelineLogObjects(v17);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      vImagePixelCount width = (vImagePixelCount)v18;
      _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, "Failed to scale image during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    (*(void (**)(uint64_t, void *))(*(void *)a6 + 40))(a6, v16);
LABEL_15:
    free(v21.data);
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 48) = unk_23440AD40;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
LABEL_16:
    *(_DWORD *)(a1 + 176) = -1;
    return;
  }
  (*(void (**)(uint64_t, void *))(*(void *)a6 + 40))(a6, v16);
}

re::DynamicString *re::Result<re::anonymous namespace'::TextureInMetalBuffer,re::DynamicString>::~Result(re::DynamicString *this)
{
  uint64_t v2 = (id *)((char *)this + 8);
  if (*(unsigned char *)this)
  {
    if (*v2)
    {

      *uint64_t v2 = 0;
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)((char *)this + 8));
  }
  return this;
}

void re::anonymous namespace'::replaceTextureSliceWithBuffer(id *a1, uint64_t a2, uint64_t a3, uint64_t a4, id *a5)
{
  uint64_t v10 = (void *)MEMORY[0x237DBDCF0]();
  if (objc_msgSend(*a1, sel_textureType) == (id)7)
  {
    long long v19 = *(_OWORD *)(a4 + 32);
    uint64_t v20 = 1;
    id v12 = *a1;
    vImage_Error v13 = (uint64_t *)(a4 + 8);
    v18[0] = 0;
    v18[1] = 0;
    v18[2] = a3;
    vImagePixelCount v14 = &v19;
    uint64_t v15 = (long long *)v18;
    uint64_t v16 = (void **)a4;
    uint64_t v17 = 0;
  }
  else
  {
    id v12 = *a1;
    vImage_Error v13 = (uint64_t *)(a4 + 8);
    vImagePixelCount v14 = (long long *)(a4 + 32);
    long long v19 = 0uLL;
    uint64_t v20 = 0;
    uint64_t v15 = &v19;
    uint64_t v16 = (void **)a4;
    uint64_t v17 = a3;
  }
  re::mtl::BlitCommandEncoder::copyFromBufferToTexture(v11, v16, v13, v14, (uint64_t)v12, v17, a2, v15);
}

void re::anonymous namespace'::TextureUploadQueue::commit(re::_anonymous_namespace_::TextureUploadQueue *this)
{
  if (*(void *)this)
  {
    v1 = this;
    uint64_t v2 = (void *)MEMORY[0x237DBDCF0]();
    uint64_t v3 = (void *)*((void *)v1 + 2);
    v1 = (re::_anonymous_namespace_::TextureUploadQueue *)((char *)v1 + 16);
    [v3 endEncoding];
    [*((id *)v1 - 1) commit];
    re::ObjCObject::operator=((void **)v1, 0);
  }
}

void re::anonymous namespace'::TextureUploadQueue::waitUntilCompleted(re::_anonymous_namespace_::TextureUploadQueue *this, id *a2)
{
  if (*a2)
  {
    uint64_t v3 = a2;
    uint64_t v4 = (void *)MEMORY[0x237DBDCF0]();
    id v5 = v3[1];
    ++v3;
    [v5 waitUntilCompleted];
    re::internal::getCommandBufferError(v3, (uint64_t)this);
    re::ObjCObject::operator=(v3, 0);
  }
  else
  {
    *(unsigned char *)this = 1;
  }
}

id *re::anonymous namespace'::TextureUploadQueue::blitCommandEncoder(id *this)
{
  uint64_t v2 = this + 1;
  if (!this[1])
  {
    re::mtl::CommandQueue::makeCommandBuffer(this, &v9);
    if (v2 != &v9)
    {
      id v3 = v9;
      id v9 = 0;
      id v4 = *v2;
      *uint64_t v2 = v3;
    }
    re::mtl::CommandBuffer::makeBlitCommandEncoder(v2, &v9);
    id v5 = this + 2;
    if (this + 2 != &v9)
    {
      id v6 = v9;
      id v9 = 0;
      long long v7 = *v5;
      *id v5 = v6;
    }
  }
  return this + 2;
}

BOOL re::anonymous namespace'::adjustBufferLinePaddingAndKTXConformance(re *a1)
{
  unint64_t v1 = *((void *)a1 + 3);
  unint64_t v2 = *((void *)a1 + 2) * *((unsigned int *)a1 + 9) + 7;
  if (v2 >> 3 == v1) {
    return 1;
  }
  if (v2 >> 3 < v1)
  {
    if ((v2 & 0x18) == 0 || v2 >= 0x20) {
      size_t v5 = v2 >> 3;
    }
    else {
      size_t v5 = 4;
    }
    if (*((void *)a1 + 1) >= 2uLL)
    {
      id v6 = *(char **)a1;
      long long v7 = (char *)(*(void *)a1 + v1);
      unint64_t v8 = 1;
      do
      {
        v6 += v5;
        memmove(v6, v7, v5);
        ++v8;
        v7 += v1;
      }
      while (v8 < *((void *)a1 + 1));
    }
    *((void *)a1 + 3) = v5;
    return 1;
  }
  uint64_t v10 = *re::pipelineLogObjects(a1);
  BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v11[0] = 0;
    _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "Failed to adjust buffer to alignment requirements", (uint8_t *)v11, 2u);
    return 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicArray<unsigned char>>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t result = re::DynamicArray<BOOL>::DynamicArray(*(void *)(a1 + 32) + 40 * v5, a2);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::anonymous namespace'::generateMipmapLevelOnCPU(uint64_t *a1, uint64_t a2, uint64_t a3, id *a4, uint64_t a5, char a6)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)objc_msgSend(*a4, sel_width);
  if (v12 >> a6 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v12 >> a6;
  }
  unint64_t v14 = (unint64_t)objc_msgSend(*a4, sel_height);
  if (v14 >> a6 <= 1) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v14 >> a6;
  }
  if (*a1) {
    uint64_t v16 = *a1;
  }
  else {
    uint64_t v16 = a2;
  }
  operator new();
}

__n128 re::DynamicArray<re::anonymous namespace'::TextureInMetalBuffer>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)a1)
    {
      uint64_t v11 = 2 * v4;
      BOOL v12 = v4 == 0;
      unint64_t v13 = 8;
      if (!v12) {
        unint64_t v13 = v11;
      }
      if (v13 <= v6) {
        unint64_t v14 = v6;
      }
      else {
        unint64_t v14 = v13;
      }
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)a1, v14);
    }
    else
    {
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)a1, v6);
      ++*(_DWORD *)(a1 + 24);
    }
  }
  uint64_t v8 = *(void *)(a1 + 32) + 56 * *(void *)(a1 + 16);
  *(void *)uint64_t v8 = *(void *)a2;
  *(void *)a2 = 0;
  __n128 result = *(__n128 *)(a2 + 8);
  long long v10 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v8 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v8 + 24) = v10;
  *(__n128 *)(v8 + 8) = result;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::anonymous namespace'::createMetalBuffer(re::_anonymous_namespace_ *this, const vImage_Buffer *a2, uint64_t a3, id *a4)
{
  size_t rowBytes = a2->rowBytes;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  unint64_t v9 = (void *)MEMORY[0x237DBDCF0]();
  id v11 = objc_msgSend(*a4, sel_newBufferWithBytes_length_options_, a2->data, a3, 0);
  *(void *)&long long v12 = 0;
  *((void *)&v12 + 1) = rowBytes;
  *(void *)unint64_t v13 = 0;
  *(int8x16_t *)&v13[8] = vextq_s8(*(int8x16_t *)&a2->height, *(int8x16_t *)&a2->height, 8uLL);
  *(void *)&v13[24] = 1;
  NS::SharedPtr<MTL::Texture>::operator=((void **)this, &v11);
  *(_OWORD *)((char *)this + 8) = v12;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)v13;
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)&v13[16];
  if (v11) {

  }
  if (!*(void *)this)
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Failed to create staging buffer for texture upload", "stagingBuffer.buffer.isValid()", "createMetalBuffer", 3119);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::anonymous namespace'::vImageBufferStorage::operator=(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v4;
  long long v6 = a2[3];
  long long v7 = a2[4];
  long long v8 = a2[5];
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 48) = v6;
  if (*(void *)(a1 + 104))
  {
    CGImageBlockSetRelease();
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 120) = 0;
  }
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  uint64_t v9 = *((void *)a2 + 16);
  *(void *)(a1 + 120) = *((void *)a2 + 15);
  *(void *)(a1 + 128) = v9;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 15) = 0;
  uint64_t v10 = *((void *)a2 + 17);
  *((void *)a2 + 17) = 0;
  id v11 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = v10;

  uint64_t v12 = *((void *)a2 + 18);
  *((void *)a2 + 18) = 0;
  unint64_t v13 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = v12;
  if (v13) {
    free(v13);
  }
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + 152), (void **)a2 + 19);
  uint64_t v14 = *((void *)a2 + 20);
  uint64_t v15 = *((void *)a2 + 21);
  int v16 = *((_DWORD *)a2 + 44);
  *((_DWORD *)a2 + 44) = -1;
  *((void *)a2 + 20) = 0;
  *((void *)a2 + 21) = 0;
  uint64_t v17 = *(CGColorSpace **)(a1 + 160);
  *(void *)(a1 + 160) = v14;
  *(void *)(a1 + 168) = v15;
  *(_DWORD *)(a1 + 176) = v16;
  CGColorSpaceRelease(v17);
  return a1;
}

void re::anonymous namespace'::replaceTextureSliceWithBuffer(id *a1, uint64_t a2, uint64_t a3, const vImage_Buffer *a4, id *a5)
{
  if (objc_msgSend(*a1, sel_storageMode) == (id)2)
  {
    vImagePixelCount height = a4->height;
    if (height) {
      uint64_t v11 = a4->rowBytes * (height - 1) + ((a4->width * HIDWORD(a4[1].data) + 7) >> 3);
    }
    else {
      uint64_t v11 = 0;
    }
    id v20 = objc_msgSend(*a1, sel_device);
    id v21 = v20;

    if (v22[0]) {
  }
    }
  else
  {
    uint64_t rowBytes = a4->rowBytes;
    id v13 = objc_msgSend(*a1, sel_textureType);
    vImagePixelCount v14 = a4->height;
    vImagePixelCount width = a4->width;
    id v16 = *a1;
    uint64_t data = (uint64_t)a4->data;
    v22[0] = 0;
    v22[1] = 0;
    if (v13 == (id)7)
    {
      uint64_t v23 = a3;
      vImagePixelCount v24 = width;
      vImagePixelCount v25 = v14;
      uint64_t v26 = 1;
      uint64_t v18 = a2;
      uint64_t v19 = 0;
    }
    else
    {
      uint64_t v23 = 0;
      vImagePixelCount v24 = width;
      vImagePixelCount v25 = v14;
      uint64_t v26 = 1;
      uint64_t v18 = a2;
      uint64_t v19 = a3;
    }
    objc_msgSend(v16, sel_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_, v22, v18, v19, data, rowBytes, 0);
  }
}

BOOL re::anonymous namespace'::DeviceOutputAllocator::outputAllocate(id *this, uint64_t a2, void *a3, at_size_t a4)
{
  uint32_t z = a4.z;
  long long v5 = *(void **)&a4.x;
  id v13 = objc_msgSend(this[1], sel_newBufferWithLength_options_, a2, 0);
  NS::SharedPtr<MTL::Texture>::operator=(this + 2, &v13);
  long long v8 = (re *)v13;
  if (v13) {

  }
  id v9 = this[2];
  if (v9)
  {
    objc_msgSend(this[2], sel_setLabel_, @"compressTextureWithImageBuffer staging buffer");
    this[3] = a3;
    this[4] = v5;
    *((_DWORD *)this + 10) = z;
  }
  else
  {
    uint64_t v10 = *re::pipelineLogObjects(v8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "Failed to create Metal staging buffer for texture compression", v12, 2u);
    }
  }
  return v9 != 0;
}

id re::anonymous namespace'::DeviceOutputAllocator::outputBuffer(id *this)
{
  return objc_msgSend(this[2], sel_contents);
}

vImage_Error re::anonymous namespace'::doVImageScale(vImage_Error result, vImage_Buffer *src, const vImage_Buffer *a3, void *tempBuffer, uint64_t flags)
{
  switch((int)result)
  {
    case 0:
      re::internal::assertLog((re::internal *)4, (uint64_t)src, a3, tempBuffer, flags, "assertion failure: '%s' (%s:line %i) Invalid vImageScale_* variant", "!\"Unreachable code\"", "doVImageScale", 3059, v5, v6);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D6E584);
    case 1:
      __n128 result = vImageScale_Planar8(src, a3, tempBuffer, flags);
      break;
    case 2:
      __n128 result = vImageScale_Planar16S(src, a3, tempBuffer, flags);
      break;
    case 3:
      __n128 result = vImageScale_Planar16U(src, a3, tempBuffer, flags);
      break;
    case 4:
      __n128 result = vImageScale_PlanarF(src, a3, tempBuffer, flags);
      break;
    case 5:
      __n128 result = vImageScale_ARGB8888(src, a3, tempBuffer, flags);
      break;
    case 6:
      __n128 result = vImageScale_ARGB16U(src, a3, tempBuffer, flags);
      break;
    case 7:
      __n128 result = vImageScale_ARGB16S(src, a3, tempBuffer, flags);
      break;
    case 8:
      __n128 result = vImageScale_ARGBFFFF(src, a3, tempBuffer, flags);
      break;
    case 9:
      __n128 result = vImageScale_Planar16F(src, a3, tempBuffer, flags);
      break;
    case 10:
      __n128 result = vImageScale_ARGB16F(src, a3, tempBuffer, flags);
      break;
    case 11:
      __n128 result = vImageScale_CbCr8(src, a3, tempBuffer, flags);
      break;
    case 12:
      __n128 result = vImageScale_CbCr16U(src, a3, tempBuffer, flags);
      break;
    case 13:
      __n128 result = vImageScale_XRGB2101010W(src, a3, tempBuffer, flags);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *std::unique_ptr<re::anonymous namespace'::vImageBufferStorage>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 160));
    *(void *)(v2 + 160) = 0;
    id v3 = *(void **)(v2 + 152);
    if (v3)
    {

      *(void *)(v2 + 152) = 0;
    }
    long long v4 = *(void **)(v2 + 144);
    *(void *)(v2 + 144) = 0;
    if (v4) {
      free(v4);
    }

    if (*(void *)(v2 + 104))
    {
      CGImageBlockSetRelease();
      *(void *)(v2 + 104) = 0;
      *(void *)(v2 + 120) = 0;
    }
    JUMPOUT(0x237DBCBD0);
  }
  return result;
}

BOOL re::anonymous namespace'::MetalCompression::outputAllocate(id *this, uint64_t a2, void *a3, at_size_t a4)
{
}

id re::anonymous namespace'::MetalCompression::outputBuffer(id *this)
{
  return objc_msgSend(this[8], sel_contents);
}

void re::anonymous namespace'::MetalCompression::updateSource(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  long long v5 = *(_OWORD *)a3;
  *(void *)(a1 + 160) = a3[2];
  *(_OWORD *)(a1 + 144) = v5;
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 88)) {
    goto LABEL_22;
  }
  v43[0] = objc_msgSend(objc_msgSend(*(id *)(v6 + 8), sel_device), sel_newBufferWithLength_options_, (void)a2[1] * a3[1], 0);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + 136), v43);
  uint64_t v10 = (_anonymous_namespace_ *)v43[0];
  if (v43[0]) {

  }
  if (!*(void *)(a1 + 136))
  {
    long long v18 = *(_OWORD *)v43;
    uint64_t v19 = v44;
    id v20 = v45;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(void *)(a4 + 24) = v19;
    *(void *)(a4 + 32) = v20;
    return;
  }
  id v11 = objc_msgSend(*(id *)(v6 + 8), sel_device);
  if (objc_msgSend(*(id *)(v6 + 8), sel_storageMode) != (id)2)
  {
    uint64_t v21 = *(void *)(a1 + 40);
    uint64_t v23 = *a2;
    uint64_t v22 = a2[1];
    vImagePixelCount v24 = *(void **)(v6 + 8);
    id v25 = objc_msgSend(*(id *)(a1 + 136), sel_contents);
    uint64_t v26 = a3[1];
    uint64_t v27 = a3[2];
    uint64_t v28 = *(void *)(a1 + 24);
    uint64_t v29 = *(void *)(a1 + 32);
    v43[0] = 0;
    v43[1] = 0;
    uint64_t v44 = v21;
    id v45 = v23;
    uint64_t v46 = v22;
    uint64_t v47 = 1;
    objc_msgSend(v24, sel_getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_, v25, v26, v27, v43, v28, v29);
    id v17 = objc_msgSend(*(id *)(a1 + 136), (SEL)&selRef_setThreadgroupMemoryLength_);
    goto LABEL_11;
  }
  uint64_t v12 = *(void *)(a1 + 96);
  v43[0] = (id)0x4D6518ECB093D0F6;
  v43[1] = "CompressedTextureUploadQueue";
  re::ImportGraphicsContext::getOrCreateCommandQueue(v12, (uint64_t)v43, (const char *)1, &v42);
  re::mtl::CommandQueue::makeCommandBuffer(&v42, &v41);
  re::mtl::CommandBuffer::makeBlitCommandEncoder(&v41, &v40);
  uint64_t v13 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v13 + 88))
  {
LABEL_22:
    uint64_t v36 = (re::_anonymous_namespace_::MetalCompression *)std::__throw_bad_variant_access[abi:nn180100]();
    return;
  }
  uint64_t v14 = *(void *)(v13 + 8);
  uint64_t v16 = *(void *)(a1 + 24);
  uint64_t v15 = *(void *)(a1 + 32);
  v43[0] = 0;
  v43[1] = 0;
  uint64_t v44 = *(void *)(a1 + 40);
  re::mtl::BlitCommandEncoder::copyFromTextureToBuffer(&v40, v14, v15, v16, (long long *)v43, (long long *)a2, (void *)(a1 + 136), a3);
  [v40 endEncoding];
  [v41 commit];
  [v41 waitUntilCompleted];
  re::internal::getCommandBufferError(&v41, (uint64_t)v43);
  if (!LOBYTE(v43[0]))
  {
    id v31 = objc_msgSend(objc_msgSend(*(id *)(v6 + 8), sel_label), sel_UTF8String);
    if (v44) {
      unint64_t v32 = v45;
    }
    else {
      unint64_t v32 = (char *)&v44 + 1;
    }
    long long v33 = v37;
    uint64_t v34 = v38;
    uint64_t v35 = v39;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    if (!LOBYTE(v43[0]) && v43[1] && (v44 & 1) != 0) {
      (*(void (**)(void))(*(void *)v43[1] + 40))();
    }

    goto LABEL_12;
  }

  id v17 = objc_msgSend(*(id *)(a1 + 136), (SEL)&selRef_setThreadgroupMemoryLength_);
LABEL_11:
  uint64_t v30 = *(void *)(a1 + 152);
  *(void *)(a1 + 104) = v17;
  *(int8x16_t *)(a1 + 112) = vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 8uLL);
  *(void *)(a1 + 128) = v30;
  *(unsigned char *)a4 = 1;
LABEL_12:
}

uint64_t re::anonymous namespace'::MetalCompression::source(re::_anonymous_namespace_::MetalCompression *this)
{
  return (uint64_t)this + 104;
}

uint64_t re::anonymous namespace'::BaseCompressionSource::contents(re::_anonymous_namespace_::BaseCompressionSource *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 8))();
}

void re::anonymous namespace'::MetalCompression::backingMetalBuffer(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  id v8 = *(id *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 72);
  uint64_t v10 = *(unsigned int *)(a1 + 88);
  *a2 = 0;
  a2[1] = v9;
  a2[2] = 0;
  uint64_t v11 = *(void *)(a1 + 80);
  *(void *)&long long v12 = v11;
  *((void *)&v12 + 1) = HIDWORD(v11);
  *(_OWORD *)a3 = v12;
  *(void *)(a3 + 16) = v10;
  *a4 = v8;
  if (v8)
  {
  }
}

BOOL re::anonymous namespace'::MetalCompression::isValid(id *this)
{
  id v1 = this[8];
  id v2 = v1;
  if (v1) {

  }
  return v2 != 0;
}

id re::anonymous namespace'::MetalCompression::length(id *this)
{
  id v1 = this[8];
  id v2 = objc_msgSend(v1, sel_length);
  if (v1) {

  }
  return v2;
}

BOOL non-virtual thunk to're::anonymous namespace'::MetalCompression::isValid(uint64_t a1)
{
}

id non-virtual thunk to're::anonymous namespace'::MetalCompression::length(uint64_t a1)
{
}

uint64_t non-virtual thunk to're::anonymous namespace'::BaseCompressionSource::contents(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 8) + 8))();
}

void non-virtual thunk to're::anonymous namespace'::MetalCompression::backingMetalBuffer(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
}

void re::anonymous namespace'::BaseCompressionSource::backingMetalBuffer(void *a1@<X8>)
{
  *a1 = 0;
}

void non-virtual thunk to're::anonymous namespace'::BaseCompressionSource::backingMetalBuffer(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t re::anonymous namespace'::CPUCompression::outputAllocate(re::_anonymous_namespace_::CPUCompression *this, unint64_t a2, unint64_t a3, at_size_t a4)
{
  return 1;
}

uint64_t re::anonymous namespace'::CPUCompression::outputBuffer(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((void *)this + 10);
}

int8x16_t re::anonymous namespace'::CPUCompression::updateSource@<Q0>(uint64_t a1@<X0>, int8x16_t *a2@<X1>, long long *a3@<X2>, unsigned char *a4@<X8>)
{
  long long v5 = *a3;
  *(void *)(a1 + 136) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 120) = v5;
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 88) != 1) {
LABEL_5:
  }
    std::__throw_bad_variant_access[abi:nn180100]();
  unint64_t v8 = *(void *)(a1 + 24);
  if (*(void *)(v6 + 32) <= v8)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_5;
  }
  uint64_t v10 = *(void *)(*(void *)(v6 + 48) + 40 * v8 + 32)
      + a2->i64[1] * *((void *)a3 + 1) * (*(void *)(a1 + 32) + *(void *)(a1 + 40));
  objc_msgSend(*(id *)(v6 + 8), sel_textureType);
  uint64_t v11 = *(void *)(a1 + 128);
  *(void *)(a1 + 88) = v10;
  int8x16_t result = vextq_s8(*a2, *a2, 8uLL);
  *(int8x16_t *)(a1 + 96) = result;
  *(void *)(a1 + 112) = v11;
  *a4 = 1;
  return result;
}

uint64_t re::anonymous namespace'::CPUCompression::source(re::_anonymous_namespace_::CPUCompression *this)
{
  return (uint64_t)this + 88;
}

BOOL re::anonymous namespace'::CPUCompression::isValid(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((void *)this + 8) != 0;
}

uint64_t re::anonymous namespace'::CPUCompression::length(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((void *)this + 8);
}

BOOL non-virtual thunk to're::anonymous namespace'::CPUCompression::isValid(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0;
}

uint64_t non-virtual thunk to're::anonymous namespace'::CPUCompression::length(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t re::CPUTexture::CPUTexture(uint64_t a1, id a2, uint64_t a3)
{
  long long v5 = (_anonymous_namespace_ *)a2;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(void *)(a3 + 8);
  *(void *)(a1 + 8) = *(void *)a3;
  *(void *)(a1 + 16) = v6;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = v7;
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a3 + 32);
  *(void *)(a3 + 32) = v8;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a1 + 32);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  re::DynamicString::setCapacity((void *)(a1 + 48), 0);
  return a1;
}

BOOL re::anonymous namespace'::BasicAppendingOutputAllocator::outputAllocate(re::_anonymous_namespace_::BasicAppendingOutputAllocator *this, uint64_t a2, unint64_t a3, at_size_t a4)
{
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = v6 + a2;
  re::DynamicArray<BOOL>::resize(v5, v6 + a2);
  uint64_t v8 = *((void *)this + 1);
  *((void *)this + 2) = *(void *)(v8 + 32) + v6;
  return *(void *)(v8 + 16) == v7;
}

uint64_t re::anonymous namespace'::BasicAppendingOutputAllocator::outputBuffer(re::_anonymous_namespace_::BasicAppendingOutputAllocator *this)
{
  return *((void *)this + 2);
}

uint64_t std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void re::addPropertyToGeomModelDescriptor(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X3>, const char *a5@<X4>, char a6@<W5>, uint64_t a7@<X8>)
{
  id v12 = a1;
  id v67 = a2;
  id v13 = a3;
  uint64_t v14 = [v12 type];
  uint64_t v15 = (void *)*MEMORY[0x263F83F48];

  uint64_t v65 = a4;
  if (v14 == v15)
  {
    char v31 = 8;
LABEL_9:
    char v63 = v31;
    uint64_t v32 = 8;
    goto LABEL_15;
  }
  uint64_t v16 = [v12 type];
  id v17 = (void *)*MEMORY[0x263F83F58];

  if (v16 == v17)
  {
    char v63 = 11;
    uint64_t v32 = 12;
    goto LABEL_15;
  }
  long long v18 = [v12 type];
  uint64_t v19 = (void *)*MEMORY[0x263F83F60];

  if (v18 == v19)
  {
    char v63 = 10;
    uint64_t v32 = 16;
    goto LABEL_15;
  }
  id v20 = [v12 type];
  uint64_t v21 = (void *)*MEMORY[0x263F83F70];

  if (v20 == v21)
  {
    char v63 = 6;
    uint64_t v32 = 4;
    goto LABEL_15;
  }
  uint64_t v22 = [v12 type];
  uint64_t v23 = (void *)*MEMORY[0x263F83F38];

  if (v22 == v23)
  {
    char v31 = 7;
    goto LABEL_9;
  }
  vImagePixelCount v24 = [v12 type];
  id v25 = (void *)*MEMORY[0x263F83F80];

  if (v24 == v25)
  {
    uint64_t v32 = 4;
    char v63 = 4;
LABEL_15:
    long long v33 = [v12 metadataWithKey:@"elementSize"];
    uint64_t v34 = v33;
    if (v33) {
      BOOL v35 = [v33 intValue] != 1;
    }
    else {
      BOOL v35 = 0;
    }
    int v36 = 4;
    if ((a6 & 1) == 0 && !v35)
    {
      id v37 = v13;
      uint64_t v38 = [v12 metadataWithKey:@"interpolation"];
      uint64_t v39 = v38;
      if (v38)
      {
        uint64_t v40 = [v38 stringValue];

        id v37 = (id)v40;
      }
      if (([v37 isEqualToString:@"vertex"] & 1) != 0
        || ([v37 isEqualToString:@"varying"] & 1) != 0)
      {
        int v36 = 1;
      }
      else if ([v37 isEqualToString:@"faceVarying"])
      {
        int v36 = 3;
      }
      else if ([v37 isEqualToString:@"constant"])
      {
        int v36 = 0;
      }
      else if ([v37 isEqualToString:@"uniform"])
      {
        int v36 = 2;
      }
      else
      {
        int v36 = 4;
      }
    }
    id v41 = [v12 data];
    id v42 = [v41 dataNoCopy];
    double v43 = (void *)[v42 copy];

    if (!v41 || !v43)
    {
      uint64_t v47 = "No values specified for attribute.";
      goto LABEL_31;
    }
    unint64_t v45 = [v43 length];
    uint64_t v46 = (_anonymous_namespace_ *)[v41 arraySize];
    if (v45 < (uint64_t)v46 * v32)
    {
      uint64_t v47 = "Skipping attribute because the value buffer is malformed.";
LABEL_31:
      long long v48 = v75;
      uint64_t v49 = v76;
      uint64_t v50 = v77;
      *(unsigned char *)a7 = 0;
      *(void *)(a7 + 8) = 100;
      *(void *)(a7 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a7 + 24) = v48;
      *(void *)(a7 + 40) = v49;
      *(void *)(a7 + 48) = v50;
      uint64_t v30 = v67;
LABEL_51:

      goto LABEL_52;
    }
    *(void *)&long long v75 = v43;
    BYTE8(v75) = v63;
    uint64_t v76 = [v41 arraySize];
    uint64_t v77 = 0;
    uint64_t v78 = v32;
    uint64_t v30 = v67;
    unint64_t v51 = [v67 data];
    unint64_t v52 = [v51 dataNoCopy];
    unint64_t v64 = (void *)[v52 copy];

    CGColorSpaceModel v70 = 0;
    char v71 = -1;
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    uint64_t v72 = 0;
    if (v67 && v51)
    {
      unint64_t v54 = [v64 length];
      long long v55 = (_anonymous_namespace_ *)[v51 arraySize];
      if (v54 < 4 * (uint64_t)v55)
      {
        long long v56 = v68;
        long long v57 = v69;
        *(unsigned char *)a7 = 0;
        *(void *)(a7 + 8) = 100;
        *(void *)(a7 + 16) = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)(a7 + 24) = v56;
        *(_OWORD *)(a7 + 40) = v57;
        uint64_t v58 = v64;
LABEL_50:

        goto LABEL_51;
      }
      uint64_t v72 = [v51 arraySize];
      uint64_t v74 = 4;
      char v71 = 5;
      long long v53 = re::ObjCObject::operator=(&v70, v64);
    }
    uint64_t v59 = a5;
    if (!a5)
    {
      char v62 = [v12 name];
      id v61 = [v62 stringValue];
      long long v53 = (void **)[v61 UTF8String];
      uint64_t v59 = (const char *)v53;
    }
    if (v51) {
      long long v60 = &v70;
    }
    else {
      long long v60 = 0;
    }
    re::GeomModelDescriptor::setAttribute(v65, (uint64_t)&v68, v36, (uint64_t)&v75, (uint64_t)v60, a7);
    uint64_t v58 = v64;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        (*(void (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if (!a5)
    {
    }
    goto LABEL_50;
  }
  long long v27 = v75;
  uint64_t v28 = v76;
  uint64_t v29 = v77;
  *(unsigned char *)a7 = 0;
  *(void *)(a7 + 8) = 100;
  *(void *)(a7 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a7 + 24) = v27;
  *(void *)(a7 + 40) = v28;
  *(void *)(a7 + 48) = v29;
  uint64_t v30 = v67;
LABEL_52:
}

void re::addPropertyToGeomModelDescriptorHelper(uint64_t a1, void *a2, void *a3, void *a4, void *a5, const char *a6, char a7)
{
  id v13 = a4;
  id v14 = a3;
  id v15 = a2;
  uint64_t v16 = [v14 name];
  id v17 = [v16 stringValue];
  id v19 = [v17 stringByAppendingString:@":indices"];

  long long v18 = [v15 property:v19];

  re::addPropertyToGeomModelDescriptor(v14, v18, v13, a5, a6, a7, a1);
}

id re::primaryUVSetForMesh(void *a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v1 = a1;
  id v2 = [v1 property:@"primvars:st"];
  uint64_t v3 = v2;
  long long v4 = (void **)MEMORY[0x263F83F48];
  if (v2
    && ([v2 type], uint64_t v5 = objc_claimAutoreleasedReturnValue(), v6 = *v4, v5, v5 == v6))
  {
    id v15 = v3;
  }
  else
  {
    id v20 = v1;
    [v1 properties];
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    id v7 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v8 = [v7 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      id v10 = 0;
      uint64_t v11 = *(void *)v22;
      id v12 = (void *)*MEMORY[0x263F84058];
      id v13 = *v4;
      while (2)
      {
        for (uint64_t i = 0; i != v9; ++i)
        {
          if (*(void *)v22 != v11) {
            objc_enumerationMutation(v7);
          }
          id v15 = [v7 objectForKey:*(void *)(*((void *)&v21 + 1) + 8 * i)];
          uint64_t v16 = [v15 role];

          if (v16 == v12)
          {

            goto LABEL_17;
          }
          id v17 = [v15 type];

          if (v17 == v13)
          {
            id v18 = v15;

            id v10 = v18;
          }
        }
        uint64_t v9 = [v7 countByEnumeratingWithState:&v21 objects:v25 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
    else
    {
      id v10 = 0;
    }

    id v10 = v10;
    id v15 = v10;
LABEL_17:

    id v1 = v20;
  }

  return v15;
}

void re::addSkeletonBindingsAsAttributesToModelDescriptor(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v135 = *MEMORY[0x263EF8340];
  id v7 = a2;
  uint64_t v8 = [v7 inheritedProperty:@"primvars:skel:jointWeights"];
  uint64_t v9 = [v7 inheritedProperty:@"primvars:skel:jointIndices"];
  if (v8)
  {
    id v10 = [v8 data];
    uint64_t v11 = v10;
    if (v10 && v9)
    {
      id v12 = [v9 data];

      if (v12)
      {
        id v13 = [v8 metadataWithKey:@"elementSize"];
        unint64_t v14 = (unint64_t)v13;
        if (v13) {
          int v15 = [v13 intValue];
        }
        else {
          int v15 = 1;
        }
        int v81 = v15;
        uint64_t v83 = v15;
        unint64_t v16 = a1[2] * v15;
        id v17 = [v8 data];
        id v18 = [v17 dataNoCopy];
        if ([v18 length] < 4 * v16)
        {

LABEL_128:
          goto LABEL_129;
        }
        uint64_t v76 = a3;
        unint64_t v77 = a4;
        long long v79 = a1;
        unint64_t v80 = v14;
        id v19 = [v9 data];
        id v20 = [v19 dataNoCopy];
        unint64_t v21 = [v20 length];

        if (v21 < 4 * v16) {
          goto LABEL_128;
        }
        long long v22 = [v9 metadataWithKey:@"elementSize"];
        long long v23 = v22;
        int v24 = v22 ? [v22 intValue] : 1;

        if (v24 != v81) {
          goto LABEL_128;
        }
        id v25 = [v8 metadataWithKey:@"interpolation"];
        uint64_t v26 = [v25 stringValue];
        char v27 = [v26 isEqualToString:@"constant"];

        uint64_t v28 = [v9 metadataWithKey:@"interpolation"];
        uint64_t v29 = [v28 stringValue];
        char v30 = [v29 isEqualToString:@"constant"];

        if ((v27 & 1) == 0)
        {
          char v31 = [v8 data];
          uint64_t v32 = [v31 arraySize];

          if (v32 != v16) {
            goto LABEL_128;
          }
        }
        if ((v30 & 1) == 0)
        {
          long long v33 = [v9 data];
          uint64_t v34 = [v33 arraySize];

          if (v34 != v16) {
            goto LABEL_128;
          }
        }
        if (v27)
        {
          char v74 = v30;
          uint64_t v72 = [v8 data];
          id v71 = [v72 dataNoCopy];
          BOOL v35 = (_anonymous_namespace_ *)[v71 bytes];
          uint64_t v119 = 0;
          uint64_t v118 = 0;
          uint64_t v120 = 0;
          if (v16)
          {
            uint64_t v37 = 0;
            unint64_t v38 = 0;
            size_t v39 = 4 * v83;
            do
            {
              uint64_t v40 = v119;
              if ((unint64_t)v119 <= v38) {
                goto LABEL_131;
              }
              int v36 = (_anonymous_namespace_ *)memcpy((void *)(v120 + v37), v35, v39);
              v38 += v83;
              v37 += v39;
            }
            while (v38 < v16);
          }
          uint64_t v100 = v120;
          unint64_t v101 = (unint64_t)v119;
          *(void *)uint64_t v132 = 0;
          *(void *)&v132[8] = 0;
          uint64_t v40 = v79;
          re::GeomModelDescriptor::setAttribute<float,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v115);
          unint64_t v38 = v77;
          if (!v115[0] && (void)v116)
          {
            if (BYTE8(v116)) {
              (*(void (**)(void))(*(void *)v116 + 40))();
            }
            long long v116 = 0u;
            long long v117 = 0u;
          }
          char v30 = v74;
          if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
          }
          if (v118 && v119) {
            (*(void (**)(void))(*(void *)v118 + 40))();
          }
        }
        else
        {
          uint64_t v40 = v79;
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v121, v7, v8, @"constant", v79, "skinnedAnimationWeights", 1);
          unint64_t v38 = v77;
          if (!v121[0] && (void)v122)
          {
            if (BYTE8(v122)) {
              (*(void (**)(void))(*(void *)v122 + 40))();
            }
            long long v122 = 0u;
            long long v123 = 0u;
          }
        }
        if (v30)
        {
          long long v75 = [v9 data];
          id v73 = [v75 dataNoCopy];
          id v41 = (_anonymous_namespace_ *)[v73 bytes];
          uint64_t v119 = 0;
          uint64_t v118 = 0;
          uint64_t v120 = 0;
          if (v16)
          {
            uint64_t v43 = 0;
            unint64_t v38 = 0;
            size_t v44 = 4 * v83;
            while (1)
            {
              uint64_t v40 = v119;
              if ((unint64_t)v119 <= v38) {
                break;
              }
              id v42 = (_anonymous_namespace_ *)memcpy((void *)(v120 + v43), v41, v44);
              v38 += v83;
              v43 += v44;
              if (v38 >= v16) {
                goto LABEL_47;
              }
            }
LABEL_132:
            uint64_t v100 = 0;
            float64x2_t v127 = 0u;
            float64x2_t v128 = 0u;
            float64x2_t v125 = 0u;
            float64x2_t v126 = 0u;
            float64x2_t v124 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v132 = 136315906;
            *(void *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(void *)&v132[20] = v38;
            __int16 v133 = 2048;
            long long v134 = v40;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_133:
            uint64_t v95 = 0;
            float64x2_t v127 = 0u;
            float64x2_t v128 = 0u;
            float64x2_t v125 = 0u;
            float64x2_t v126 = 0u;
            float64x2_t v124 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v132 = 136315906;
            *(void *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(void *)&v132[20] = v14;
            __int16 v133 = 2048;
            long long v134 = (void *)v38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_134:
            uint64_t v95 = 0;
            float64x2_t v127 = 0u;
            float64x2_t v128 = 0u;
            float64x2_t v125 = 0u;
            float64x2_t v126 = 0u;
            float64x2_t v124 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v132 = 136315906;
            *(void *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(void *)&v132[20] = v14;
            __int16 v133 = 2048;
            long long v134 = (void *)v38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_47:
          uint64_t v100 = v120;
          unint64_t v101 = (unint64_t)v119;
          *(void *)uint64_t v132 = 0;
          *(void *)&v132[8] = 0;
          uint64_t v40 = v79;
          re::GeomModelDescriptor::setAttribute<int,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v109);
          if (!v109[0] && (void)v110)
          {
            if (BYTE8(v110)) {
              (*(void (**)(void))(*(void *)v110 + 40))();
            }
            long long v110 = 0u;
            long long v111 = 0u;
          }
          unint64_t v38 = v77;
          if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
          }
          if (v118 && v119) {
            (*(void (**)(void))(*(void *)v118 + 40))();
          }
        }
        else
        {
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v112, v7, v9, @"constant", v40, "skinnedAnimationJointIndices", 1);
          if (!v112[0])
          {
            unint64_t v45 = (_anonymous_namespace_ *)v113;
            if ((void)v113)
            {
              if (BYTE8(v113)) {
                unint64_t v45 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v113 + 40))();
              }
              long long v113 = 0u;
              long long v114 = 0u;
            }
          }
        }
        unint64_t v46 = v40[2];
        uint64_t v119 = 0;
        uint64_t v118 = 0;
        uint64_t v120 = 0;
        if (!v46)
        {
LABEL_68:
          uint64_t v100 = v120;
          unint64_t v101 = (unint64_t)v119;
          *(void *)uint64_t v132 = 0;
          *(void *)&v132[8] = 0;
          re::GeomModelDescriptor::setAttribute<int,unsigned int>(v40, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v106);
          if (!v106[0] && (void)v107)
          {
            if (BYTE8(v107)) {
              (*(void (**)(void))(*(void *)v107 + 40))();
            }
            long long v107 = 0u;
            long long v108 = 0u;
          }
          if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
          }
          if (v118 && v119) {
            (*(void (**)(void))(*(void *)v118 + 40))();
          }
          unint64_t v52 = [v7 inheritedProperty:@"primvars:skel:geomBindTransform"];
          uint64_t v119 = 0;
          uint64_t v118 = 0;
          uint64_t v120 = 0;
          if (v52
            && ([(_anonymous_namespace_ *)v52 data],
                long long v53 = objc_claimAutoreleasedReturnValue(),
                v53,
                v53))
          {
            float64x2_t v130 = 0u;
            float64x2_t v131 = 0u;
            float64x2_t v128 = 0u;
            float64x2_t v129 = 0u;
            float64x2_t v126 = 0u;
            float64x2_t v127 = 0u;
            float64x2_t v124 = 0u;
            float64x2_t v125 = 0u;
            [(_anonymous_namespace_ *)v52 double4x4Value];
            float32x4_t v84 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v124), v125);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 0) = v84;
            float32x4_t v85 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v126), v127);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 1uLL) = v85;
            float32x4_t v86 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v128), v129);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 2uLL) = v86;
            float32x4_t v87 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v130), v131);
          }
          else
          {
            unint64_t v54 = (float32x4_t *)MEMORY[0x263EF89A8];
            long long v88 = *MEMORY[0x263EF89A8];
            *(_OWORD *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 0) = v88;
            float32x4_t v89 = v54[1];
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 1uLL) = v89;
            float32x4_t v90 = v54[2];
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 2uLL) = v90;
            float32x4_t v87 = v54[3];
          }
          long long v55 = (_anonymous_namespace_ *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 3uLL);
          *(float32x4_t *)long long v55 = v87;
          uint64_t v100 = v120;
          unint64_t v101 = (unint64_t)v119;
          *(void *)uint64_t v132 = 0;
          *(void *)&v132[8] = 0;
          _ZN2re19GeomModelDescriptor12setAttributeIDv4_fjEENS_6ResultINS_4UnitENS_13DetailedErrorEEERKNS_13DynamicStringENS_17GeomAttributeRateERKNS_5SliceIT_EERKNSB_IT0_EE(v40, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v103);
          if (!v103[0] && (void)v104)
          {
            if (BYTE8(v104)) {
              (*(void (**)(void))(*(void *)v104 + 40))();
            }
            long long v104 = 0u;
            long long v105 = 0u;
          }
          if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
          }
          long long v56 = [v7 property:@"skel:joints"];
          long long v57 = v56;
          if (v56)
          {
            uint64_t v58 = [v56 data];

            if (v58)
            {
              uint64_t v82 = v52;
              uint64_t v78 = v57;
              uint64_t v59 = [v57 stringArray];
              long long v60 = (_anonymous_namespace_ *)[v59 count];
              uint64_t v100 = 0;
              unint64_t v101 = 0;
              uint64_t v102 = 0;
              unint64_t v61 = v60;
              double v91 = (void *)v61;
              if (v61)
              {
                unint64_t v14 = 0;
                uint64_t v63 = v38 + 112;
                do
                {
                  id v64 = [v59 objectAtIndexedSubscript:v14];
                  uint64_t v65 = (const char *)[v64 UTF8String];
                  uint64_t v66 = [v59 objectAtIndexedSubscript:v14];
                  id v67 = (_anonymous_namespace_ *)[v66 length];
                  v124.f64[0] = 0.0;
                  *(void *)&v124.f64[1] = "";
                  long long v68 = (_DWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v63, &v124);
                  re::StringID::destroyString((re::StringID *)&v124);

                  unint64_t v38 = v101;
                  if (v68)
                  {
                    if (v101 <= v14) {
                      goto LABEL_133;
                    }
                    *(_DWORD *)(v102 + 4 * v14) = *v68;
                  }
                  else
                  {
                    if (v101 <= v14) {
                      goto LABEL_134;
                    }
                    *(_DWORD *)(v102 + 4 * v14) = v14;
                  }
                  ++v14;
                }
                while (v91 != (void *)v14);
              }
              uint64_t v95 = v102;
              unint64_t v96 = v101;
              *(void *)uint64_t v132 = 0;
              *(void *)&v132[8] = 0;
              uint64_t v40 = v79;
              re::GeomModelDescriptor::setAttribute<int,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v95, (re *)v132, (uint64_t)v97);
              if (!v97[0] && (void)v98)
              {
                if (BYTE8(v98)) {
                  (*(void (**)(void))(*(void *)v98 + 40))();
                }
                long long v98 = 0u;
                long long v99 = 0u;
              }
              if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
                (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
              }
              unint64_t v14 = v80;
              if (v100 && v101) {
                (*(void (**)(void))(*(void *)v100 + 40))();
              }

              unint64_t v52 = v82;
              long long v57 = v78;
            }
          }
          memset(v132, 0, 24);
          uint64_t v69 = (*(void *)(v76 + 8) >> 1) + 1;
          CGColorSpaceModel v70 = (_anonymous_namespace_ *)memcpy(*(void **)&v132[16], *(const void **)v76, *(void *)(v76 + 8));
          *(unsigned char *)(*(void *)&v132[16] + *(void *)(v76 + 8)) = 0;
          uint64_t v95 = *(void *)&v132[16];
          unint64_t v96 = *(void *)&v132[8];
          uint64_t v100 = 0;
          unint64_t v101 = 0;
          re::GeomModelDescriptor::setAttribute<unsigned short,unsigned int>(v40, (uint64_t)&v124, 4, (re *)&v95, (re *)&v100, (uint64_t)v92);
          if (!v92[0] && (void)v93)
          {
            if (BYTE8(v93)) {
              (*(void (**)(void))(*(void *)v93 + 40))();
            }
            long long v93 = 0u;
            long long v94 = 0u;
          }
          if (*(void *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v124.f64[0] + 40))();
          }
          if (*(void *)v132 && *(void *)&v132[8]) {
            (*(void (**)(void))(**(void **)v132 + 40))();
          }

          if (v118 && v119) {
            (*(void (**)(void))(*(void *)v118 + 40))();
          }

          goto LABEL_128;
        }
        uint64_t v48 = 0;
        unint64_t v49 = (unint64_t)v119;
        uint64_t v50 = v120;
        int v51 = v81;
        while (v49 != v48)
        {
          *(_DWORD *)(v50 + 4 * v48) = v51;
          v51 += v81;
          if (v46 == ++v48) {
            goto LABEL_68;
          }
        }
        uint64_t v100 = 0;
        float64x2_t v127 = 0u;
        float64x2_t v128 = 0u;
        float64x2_t v125 = 0u;
        float64x2_t v126 = 0u;
        float64x2_t v124 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v132 = 136315906;
        *(void *)&v132[4] = "operator[]";
        *(_WORD *)&v132[12] = 1024;
        *(_DWORD *)&v132[14] = 468;
        *(_WORD *)&v132[18] = 2048;
        *(void *)&v132[20] = v49;
        __int16 v133 = 2048;
        long long v134 = (void *)v49;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_131:
        uint64_t v100 = 0;
        float64x2_t v127 = 0u;
        float64x2_t v128 = 0u;
        float64x2_t v125 = 0u;
        float64x2_t v126 = 0u;
        float64x2_t v124 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v132 = 136315906;
        *(void *)&v132[4] = "operator[]";
        *(_WORD *)&v132[12] = 1024;
        *(_DWORD *)&v132[14] = 468;
        *(_WORD *)&v132[18] = 2048;
        *(void *)&v132[20] = v38;
        __int16 v133 = 2048;
        long long v134 = v40;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_132;
      }
    }
    else
    {
    }
  }
LABEL_129:
}

uint64_t _ZN2re10FixedArrayIDv4_fEixEm(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 16 * a3;
}

void re::attachNewBlendShapeDataIfItExistsToModelDescriptor(void *a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = v2;
  if (!v2) {
    goto LABEL_15;
  }
  long long v4 = [v2 name];

  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = [v3 name];
  uint64_t v6 = [v5 stringValue];

  id v7 = v6;
  uint64_t v8 = (_anonymous_namespace_ *)[v7 UTF8String];
  re::DynamicString::rfind((uint64_t)v9, "_blendShape", v36);
  if (v40 && (v41 & 1) != 0) {
    (*(void (**)(id, uint64_t))(*(void *)v40 + 40))(v40, v42);
  }
  int v10 = LOBYTE(v36[0]);

  if (!v10)
  {
LABEL_15:
    id v18 = 0;
LABEL_16:

    goto LABEL_17;
  }
  uint64_t v11 = [v3 childIterator];
  uint64_t v12 = [v11 nextObject];
  if (v12)
  {
    id v13 = (void *)v12;
    while (1)
    {
      unint64_t v14 = [v13 name];
      id v15 = [v14 stringValue];
      unint64_t v16 = (_anonymous_namespace_ *)[v15 UTF8String];

      re::DynamicString::rfind((uint64_t)&v40, "_blendTargets", v36);
      if (LOBYTE(v36[0])) {
        break;
      }
      if (v40 && (v41 & 1) != 0) {
        (*(void (**)(id, uint64_t))(*(void *)v40 + 40))(v40, v42);
      }
      uint64_t v17 = [v11 nextObject];

      id v13 = (void *)v17;
      if (!v17) {
        goto LABEL_14;
      }
    }
    id v18 = v13;
    if (v40 && (v41 & 1) != 0) {
      (*(void (**)(id, uint64_t))(*(void *)v40 + 40))(v40, v42);
    }
  }
  else
  {
LABEL_14:
    id v18 = 0;
  }

  if (v18)
  {
    uint64_t v3 = [v18 childIterator];
    uint64_t v19 = [v3 nextObject];
    if (v19)
    {
      id v20 = (void *)v19;
      id v33 = v18;
      unint64_t v21 = (void *)*MEMORY[0x263F83F58];
      do
      {
        long long v22 = objc_msgSend(v20, "property:", @"offsets", v33);
        long long v23 = v22;
        if (v22)
        {
          int v24 = [v22 data];
          id v25 = [v23 type];

          if (v25 == v21)
          {
            uint64_t v26 = [v24 dataNoCopy];
            char v27 = (void *)[v26 copy];

            id v28 = v27;
            id v40 = v28;
            char v41 = 11;
            uint64_t v42 = [v24 arraySize];
            long long v43 = xmmword_23437DC60;
            uint64_t v29 = [v20 name];
            id v30 = [v29 stringValue];
            char v31 = (_anonymous_namespace_ *)[v30 UTF8String];
            re::DynamicString::operator+((re::DynamicString *)v35, "|blendTargetPosDeltas", (re::DynamicString *)v36);
            re::GeomModelDescriptor::setAttribute(a1, (uint64_t)v36, 1, (uint64_t)&v40, 0, (uint64_t)v37);
            if (!v37[0] && (void)v38)
            {
              if (BYTE8(v38)) {
                (*(void (**)(void))(*(void *)v38 + 40))();
              }
              long long v38 = 0u;
              long long v39 = 0u;
            }
            if (*(void *)&v36[0])
            {
              if (BYTE8(v36[0])) {
                (*(void (**)(void))(**(void **)&v36[0] + 40))();
              }
              memset(v36, 0, sizeof(v36));
            }
            if (*(void *)&v35[0])
            {
              if (BYTE8(v35[0])) {
                (*(void (**)(void))(**(void **)&v35[0] + 40))();
              }
              memset(v35, 0, sizeof(v35));
            }
          }
        }

        uint64_t v32 = [v3 nextObject];

        id v20 = (void *)v32;
      }
      while (v32);
      id v18 = v33;
    }
    goto LABEL_16;
  }
LABEL_17:
}

void re::attachOpenSubdivDataToModelDescriptor(unsigned char *a1, void *a2)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  id v3 = a2;
  *a1 = 1;
  long long v4 = [v3 property:@"creaseIndices"];
  uint64_t v5 = [v3 property:@"creaseLengths"];
  uint64_t v6 = [v3 property:@"creaseSharpnesses"];
  id v7 = v6;
  if (v4)
  {
    if (v5)
    {
      if (v6)
      {
        if ([v6 arraySize])
        {
          uint64_t v8 = [v7 arraySize];
          if (v8 == [v5 arraySize])
          {
            uint64_t v9 = [v4 data];
            int v10 = [v9 dataNoCopy];

            uint64_t v11 = [v5 data];
            uint64_t v12 = [v11 dataNoCopy];

            id v13 = [v7 data];
            id v59 = [v13 dataNoCopy];

            id v58 = v12;
            uint64_t v14 = [v58 bytes];
            unsigned int v15 = [v7 arraySize];
            uint64_t v16 = v15;
            if (v15)
            {
              LODWORD(v17) = 0;
              unsigned int v18 = 0;
              uint64_t v19 = (unsigned int *)v14;
              uint64_t v20 = v15;
              while (1)
              {
                unsigned int v22 = *v19++;
                unsigned int v21 = v22;
                if (v22 < 2) {
                  break;
                }
                uint64_t v17 = v21 + v17;
                unsigned int v18 = v18 + v21 - 1;
                if (!--v20) {
                  goto LABEL_12;
                }
              }
            }
            else
            {
              unsigned int v18 = 0;
              uint64_t v17 = 0;
LABEL_12:
              if ([v4 arraySize] == v17)
              {
                long long v55 = v10;
                long long v56 = a1;
                uint64_t v57 = v14;
                uint64_t v23 = [v10 bytes];
                unint64_t v24 = [v59 bytes];
                id v64 = 0;
                unint64_t v65 = 0;
                uint64_t v66 = 0;
                uint64_t v78 = 0;
                unint64_t v79 = 0;
                uint64_t v80 = 0;
                if (v16)
                {
                  unint64_t v27 = v24;
                  uint64_t v28 = 0;
                  unsigned int v29 = 0;
                  unsigned int v30 = 0;
                  unsigned int v31 = 0;
                  unint64_t v32 = v65;
                  do
                  {
                    int v33 = *(_DWORD *)(v57 + 4 * v28) - 1;
                    if (*(_DWORD *)(v57 + 4 * v28) != 1)
                    {
                      int v34 = *(_DWORD *)(v27 + 4 * v28);
                      uint64_t v35 = v66;
                      unsigned int v36 = v33 + v30;
                      unint64_t v38 = v79;
                      uint64_t v37 = v80;
                      do
                      {
                        uint64_t v39 = v29;
                        if (v32 <= v29)
                        {
                          uint64_t v73 = 0;
                          long long v84 = 0u;
                          long long v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          long long v82 = 0u;
                          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                          *(_DWORD *)int v81 = 136315906;
                          *(void *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(void *)&v81[20] = v39;
                          *(_WORD *)&v81[28] = 2048;
                          *(void *)&v81[30] = v32;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
LABEL_69:
                          uint64_t v73 = 0;
                          long long v84 = 0u;
                          long long v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          long long v82 = 0u;
                          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                          *(_DWORD *)int v81 = 136315906;
                          *(void *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(void *)&v81[20] = v24;
                          *(_WORD *)&v81[28] = 2048;
                          *(void *)&v81[30] = v32;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
LABEL_70:
                          uint64_t v73 = 0;
                          long long v84 = 0u;
                          long long v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          long long v82 = 0u;
                          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                          *(_DWORD *)int v81 = 136315906;
                          *(void *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(void *)&v81[20] = v24;
                          *(_WORD *)&v81[28] = 2048;
                          *(void *)&v81[30] = v38;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
                        }
                        *(_DWORD *)(v35 + 4 * v29) = *(_DWORD *)(v23 + 4 * v31);
                        unint64_t v24 = v29 + 1;
                        if (v32 <= v24) {
                          goto LABEL_69;
                        }
                        *(_DWORD *)(v35 + 4 * v24) = *(_DWORD *)(v23 + 4 * ++v31);
                        unint64_t v24 = v30;
                        if (v38 <= v30) {
                          goto LABEL_70;
                        }
                        *(_DWORD *)(v37 + 4 * v30++) = v34;
                        v29 += 2;
                        --v33;
                      }
                      while (v33);
                      unsigned int v30 = v36;
                    }
                    ++v31;
                    ++v28;
                  }
                  while (v28 != v16);
                }
                uint64_t v73 = v66;
                unint64_t v74 = v65;
                *(void *)int v81 = 0;
                *(void *)&v81[8] = 0;
                a1 = v56;
                re::GeomModelDescriptor::setAttribute<unsigned int,unsigned int>(v56, (uint64_t)&v82, 4, (re *)&v73, (re *)v81, (uint64_t)v75);
                int v10 = v55;
                if (!v75[0] && (void)v76)
                {
                  if (BYTE8(v76)) {
                    (*(void (**)(void))(*(void *)v76 + 40))();
                  }
                  long long v76 = 0u;
                  long long v77 = 0u;
                }
                id v40 = (_anonymous_namespace_ *)v82;
                if (void)v82 && (BYTE8(v82)) {
                  id v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v82 + 40))();
                }
                uint64_t v73 = v80;
                unint64_t v74 = v79;
                *(void *)int v81 = 0;
                *(void *)&v81[8] = 0;
                re::GeomModelDescriptor::setAttribute<float,unsigned int>(v56, (uint64_t)&v82, 4, (re *)&v73, (re *)v81, (uint64_t)v70);
                if (!v70[0] && (void)v71)
                {
                  if (BYTE8(v71)) {
                    (*(void (**)(void))(*(void *)v71 + 40))();
                  }
                  long long v71 = 0u;
                  long long v72 = 0u;
                }
                if (void)v82 && (BYTE8(v82)) {
                  (*(void (**)(void))(*(void *)v82 + 40))();
                }
                if (v78 && v79) {
                  (*(void (**)(void))(*(void *)v78 + 40))();
                }
                if (v64 && v65) {
                  (*(void (**)(void))(*(void *)v64 + 40))();
                }
              }
            }
          }
        }
      }
    }
  }
  char v41 = [v3 property:@"cornerIndices"];
  uint64_t v42 = [v3 property:@"cornerSharpness"];
  long long v43 = v42;
  if (v41)
  {
    if (v42)
    {
      if ([v42 arraySize])
      {
        uint64_t v44 = [v43 arraySize];
        if (v44 == [v41 arraySize])
        {
          id v60 = v4;
          unint64_t v45 = [v41 data];
          unint64_t v46 = [v45 dataNoCopy];
          uint64_t v47 = a1;
          uint64_t v48 = (void *)[v46 copy];

          unint64_t v49 = [v43 data];
          uint64_t v50 = [v49 dataNoCopy];
          int v51 = (void *)[v50 copy];

          id v52 = v48;
          *(void *)&long long v82 = v52;
          BYTE8(v82) = 5;
          v83[0] = [v41 arraySize];
          *(_OWORD *)&v83[1] = xmmword_23437DC70;
          id v53 = v51;
          *(void *)int v81 = v53;
          v81[8] = 6;
          *(void *)&v81[16] = [v43 arraySize];
          *(_OWORD *)&v81[24] = xmmword_23437DC70;
          re::GeomModelDescriptor::setAttribute(v47, (uint64_t)&v64, 4, (uint64_t)&v82, 0, (uint64_t)v67);
          if (!v67[0] && (void)v68)
          {
            if (BYTE8(v68)) {
              (*(void (**)(void))(*(void *)v68 + 40))();
            }
            long long v68 = 0u;
            long long v69 = 0u;
          }
          unint64_t v54 = v64;
          if (v64 && (v65 & 1) != 0) {
            unint64_t v54 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v64 + 40))();
          }
          re::GeomModelDescriptor::setAttribute(v47, (uint64_t)&v64, 4, (uint64_t)v81, 0, (uint64_t)v61);
          long long v4 = v60;
          if (!v61[0] && (void)v62)
          {
            if (BYTE8(v62)) {
              (*(void (**)(void))(*(void *)v62 + 40))();
            }
            long long v62 = 0u;
            long long v63 = 0u;
          }
          if (v64 && (v65 & 1) != 0) {
            (*(void (**)(void))(*(void *)v64 + 40))();
          }
        }
      }
    }
  }
}

void re::makeGeomModelDescriptorFromUSKNode(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X6>, unint64_t a8@<X7>, uint64_t a9@<X8>)
{
  LODWORD(v207) = a4;
  uint64_t v301 = *MEMORY[0x263EF8340];
  id v12 = a1;
  id v13 = [v12 property:@"orientation"];
  uint64_t v14 = [v13 stringValue];
  int v15 = [v14 isEqualToString:@"leftHanded"];

  uint64_t v16 = [v12 property:@"faceVertexIndices"];
  uint64_t v17 = [v12 property:@"faceVertexCounts"];
  unsigned int v18 = [v12 property:@"points"];
  uint64_t v19 = [v12 property:@"doubleSided"];
  uint64_t v20 = v19;
  if (!v16)
  {
    unsigned int v21 = "Skiping mesh due to missing face vertex indices property.";
LABEL_9:
    long long v22 = *(_OWORD *)v258;
    uint64_t v23 = *(void *)&v258[16];
    uint64_t v24 = *(void *)&v258[24];
    *(unsigned char *)a9 = 0;
    *(void *)(a9 + 8) = 100;
    *(void *)(a9 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a9 + 24) = v22;
    *(void *)(a9 + 40) = v23;
    *(void *)(a9 + 48) = v24;
    goto LABEL_37;
  }
  if (!v17)
  {
    unsigned int v21 = "Skiping mesh due to missing face vertex counts property.";
    goto LABEL_9;
  }
  if (!v18)
  {
    unsigned int v21 = "Skiping mesh due to missing points property";
    goto LABEL_9;
  }
  long long v189 = v13;
  unint64_t v191 = v19;
  uint64_t v183 = a9;
  int v181 = a6;
  int v182 = a5;
  if (v19) {
    char v204 = [(_anonymous_namespace_ *)v19 BOOLValue];
  }
  else {
    char v204 = 0;
  }
  id v25 = [v16 data];
  uint64_t v26 = [v17 data];
  unint64_t v27 = [v18 data];
  unsigned int v200 = [v27 arraySize];
  unsigned int v212 = [v26 arraySize];
  uint64_t v194 = v25;
  uint64_t v28 = [v25 dataNoCopy];
  uint64_t v29 = [v28 copy];

  unsigned int v185 = v26;
  unsigned int v30 = [v26 dataNoCopy];
  uint64_t v31 = [v30 copy];

  uint64_t v184 = v27;
  unint64_t v32 = [v27 dataNoCopy];
  int v33 = (_anonymous_namespace_ *)[v32 copy];

  uint64_t v195 = (void *)v29;
  if (!v29)
  {
    int v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x263EFF8F8]);
    uint64_t v195 = v34;
  }
  uint64_t v186 = v18;
  uint64_t v187 = v17;
  uint64_t v188 = v16;
  uint64_t v35 = (void *)v31;
  if (!v31)
  {
    int v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x263EFF8F8]);
    uint64_t v35 = v34;
  }
  if (!v33)
  {
    int v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x263EFF8F8]);
    int v33 = v34;
  }
  uint64_t v193 = v33;
  *(_WORD *)uint64_t v258 = 0;
  v258[2] = 0;
  memset(&v258[4], 0, 80);
  uint64_t v259 = 0x7FFFFFFFLL;
  v261 = 0;
  v260[0] = 0;
  v260[1] = 0;
  int v262 = 0;
  memset(v263, 0, sizeof(v263));
  uint64_t v264 = 0x7FFFFFFFLL;
  *((void *)&v265 + 1) = 0;
  long long v266 = 0uLL;
  re::DynamicString::setCapacity(&v265, 0);
  uint64_t v192 = v12;
  unsigned int v36 = [v12 name];
  id v37 = [v36 stringValue];
  unint64_t v38 = (_anonymous_namespace_ *)[v37 UTF8String];

  re::DynamicString::operator=((re::DynamicString *)&v265, (re::DynamicString *)&v256);
  v258[2] = v204;
  uint64_t v39 = (_anonymous_namespace_ *)[v35 length];
  unsigned int v190 = v35;
  if ((unint64_t)v39 >= 4 * (unint64_t)v212)
  {
    unint64_t v41 = [v195 length];
    uint64_t v42 = (_anonymous_namespace_ *)[v194 arraySize];
    if (v41 < 4 * (uint64_t)v42)
    {
      long long v40 = v284[0];
      goto LABEL_21;
    }
    unint64_t v46 = [(_anonymous_namespace_ *)v33 length];
    id v12 = v192;
    if (v46 < 12 * (unint64_t)v200)
    {
      long long v47 = v284[0];
      long long v48 = v284[1];
      *(unsigned char *)uint64_t v183 = 0;
      *(void *)(v183 + 8) = 100;
      *(void *)(v183 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(v183 + 24) = v47;
      *(_OWORD *)(v183 + 40) = v48;
      goto LABEL_22;
    }
    id v252 = v35;
    char v253 = 5;
    obunint64_t j = v212;
    uint64_t v254 = v212;
    long long v255 = xmmword_23437DC70;
    id v248 = v195;
    char v249 = 5;
    uint64_t v250 = [v194 arraySize];
    long long v251 = xmmword_23437DC70;
    v244 = v33;
    char v245 = 11;
    uint64_t v246 = v200;
    long long v247 = xmmword_23437DC60;
    if (v15) {
      v258[1] = 1;
    }
    re::GeomModelDescriptor::setSurfaceTopology((_anonymous_namespace_ *)v258, v200, (uint64_t)&v252, (uint64_t)&v248, (uint64_t)v241);
    int v50 = v181;
    int v51 = v182;
    if (!v241[0])
    {
      unint64_t v49 = (_anonymous_namespace_ *)v242;
      if ((void)v242)
      {
        if (BYTE8(v242)) {
          unint64_t v49 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v242 + 40))();
        }
        long long v242 = 0u;
        long long v243 = 0u;
      }
    }
    re::GeomModelDescriptor::setAttribute(v258, (uint64_t)v284, 1, (uint64_t)&v244, 0, (uint64_t)v238);
    if (!v238[0] && (void)v239)
    {
      if (BYTE8(v239)) {
        (*(void (**)(void))(*(void *)v239 + 40))();
      }
      long long v239 = 0u;
      long long v240 = 0u;
    }
    if (*(void *)&v284[0] && (BYTE8(v284[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v284[0] + 40))();
    }
    if (*(unsigned char *)(a2 + 8)) {
      id v52 = *(unsigned char **)(a2 + 16);
    }
    else {
      id v52 = (unsigned char *)(a2 + 9);
    }
    if (*v52)
    {
      objc_msgSend(NSString, "stringWithUTF8String:");
      id v53 = (id)objc_claimAutoreleasedReturnValue();
      id v54 = [v192 property:v53];
    }
    else
    {
      re::primaryUVSetForMesh(v192);
      id v53 = (id)objc_claimAutoreleasedReturnValue();
      id v54 = v53;
    }

    long long v55 = [v192 property:@"normals"];
    unint64_t v180 = v54;
    if (v54)
    {
      long long v56 = v55;
      re::addPropertyToGeomModelDescriptorHelper((uint64_t)v284, v192, v54, @"constant", v258, "vertexUV", 0);
      if (!LOBYTE(v284[0])) {
        goto LABEL_77;
      }
      id v58 = [v54 name];
      id v59 = [v58 stringValue];
      id v60 = (_anonymous_namespace_ *)[v59 UTF8String];
      int v33 = (_anonymous_namespace_ *)v236;
      __n128 v61 = re::GeomModelDescriptor::addAttributeAlias((re::GeomModelDescriptor *)v258, (const re::DynamicString *)&v275, (const re::DynamicString *)v293, (uint64_t)v236);
      if (!v236[0] && v237[0])
      {
        int v33 = (_anonymous_namespace_ *)v237;
        if (v237[1]) {
          (*(void (**)(__n128))(*(void *)v237[0] + 40))(v61);
        }
        __n128 v61 = 0uLL;
        memset(v237, 0, sizeof(v237));
      }
      if (*(void *)v293)
      {
        if (v293[8]) {
          (*(void (**)(__n128))(**(void **)v293 + 40))(v61);
        }
        memset(v293, 0, 32);
      }

      if (void)v275 && (BYTE8(v275)) {
        (*(void (**)(void))(*(void *)v275 + 40))();
      }
      if (!LOBYTE(v284[0]))
      {
LABEL_77:
        if (*((void *)&v284[1] + 1) && (v284[2] & 1) != 0) {
          (*(void (**)(void))(**((void **)&v284[1] + 1) + 40))();
        }
      }
      long long v55 = v56;
    }
    long long v62 = v55;
    long long v63 = [v55 data];

    if (!v63)
    {
      uint64_t v64 = [v192 property:@"primvars:normals"];

      long long v62 = (void *)v64;
    }
    unsigned int v179 = v62;
    if (v62)
    {
      re::addPropertyToGeomModelDescriptorHelper((uint64_t)v284, v192, v62, @"vertex", v258, "vertexNormal", 0);
      if (!LOBYTE(v284[0])) {
        goto LABEL_98;
      }
      uint64_t v66 = [v62 name];
      id v67 = [v66 stringValue];
      long long v68 = (_anonymous_namespace_ *)[v67 UTF8String];
      int v33 = (_anonymous_namespace_ *)v234;
      __n128 v69 = re::GeomModelDescriptor::addAttributeAlias((re::GeomModelDescriptor *)v258, (const re::DynamicString *)&v275, (const re::DynamicString *)v293, (uint64_t)v234);
      if (!v234[0] && v235[0])
      {
        int v33 = (_anonymous_namespace_ *)v235;
        if (v235[1]) {
          (*(void (**)(__n128))(*(void *)v235[0] + 40))(v69);
        }
        __n128 v69 = 0uLL;
        memset(v235, 0, sizeof(v235));
      }
      if (*(void *)v293)
      {
        if (v293[8]) {
          (*(void (**)(__n128))(**(void **)v293 + 40))(v69);
        }
        memset(v293, 0, 32);
      }

      if (void)v275 && (BYTE8(v275)) {
        (*(void (**)(void))(*(void *)v275 + 40))();
      }
      if (!LOBYTE(v284[0]))
      {
LABEL_98:
        if (*((void *)&v284[1] + 1) && (v284[2] & 1) != 0) {
          (*(void (**)(void))(**((void **)&v284[1] + 1) + 40))();
        }
      }
    }
    id v70 = v192;
    unint64_t v71 = [v70 property:@"primvars:displayColor"];
    long long v72 = [v70 property:@"primvars:displayOpacity"];
    uint64_t v73 = v72;
    uint64_t v198 = v70;
    if (!v71)
    {
      BOOL v77 = 0;
      goto LABEL_112;
    }
    unint64_t v74 = [(id)v71 type];
    long long v75 = (void *)*MEMORY[0x263F83F60];

    if (v74 != v75)
    {
      long long v76 = [(id)v71 type];
      id v70 = v198;
      if (v76 == (void *)*MEMORY[0x263F83F58])
      {
        re::addPropertyToGeomModelDescriptorHelper((uint64_t)v284, v198, (void *)v71, @"constant", v258, 0, 0);
        BOOL v77 = LOBYTE(v284[0]) != 0;
        if (!LOBYTE(v284[0]) && *((void *)&v284[1] + 1) && (v284[2] & 1) != 0) {
          (*(void (**)(void))(**((void **)&v284[1] + 1) + 40))();
        }
      }
      else
      {
        BOOL v77 = 0;
      }

LABEL_112:
      if (v73)
      {
        uint64_t v78 = [(_anonymous_namespace_ *)v73 type];
        if (v78 == (void *)*MEMORY[0x263F83F70])
        {
          unint64_t v79 = v73;
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v284, v70, v73, @"constant", v258, 0, 0);
          LODWORD(v73) = LOBYTE(v284[0]) != 0;
          if (!LOBYTE(v284[0]) && *((void *)&v284[1] + 1) && (v284[2] & 1) != 0) {
            (*(void (**)(void))(**((void **)&v284[1] + 1) + 40))();
          }
        }
        else
        {
          unint64_t v79 = v73;
          LODWORD(v73) = 0;
        }
        LODWORD(v80) = v181;
      }
      else
      {
        LODWORD(v80) = v181;
        unint64_t v79 = 0;
      }
      unint64_t v270 = 0;
      uint64_t v269 = 0;
      id v271 = 0;
      if (v77)
      {
        int v81 = [(id)v71 name];
        id v82 = [v81 stringValue];
        uint64_t v83 = (_anonymous_namespace_ *)[v82 UTF8String];

        long long v84 = (_anonymous_namespace_ *)re::GeomModelDescriptor::attributeByName((re::GeomModelDescriptor *)v258, (const re::DynamicString *)&v275);
        int v33 = v84;
        uint64_t v85 = *((void *)v84 + 5);
        unint64_t v209 = v71;
        BOOL v205 = v77;
        if (v85)
        {
          uint64_t v86 = (void *)(v85 + 8);
          id v87 = (id)(v85 + 8);
          if (*(unsigned char *)(v85 + 32) && (*(unsigned __int8 *)(v85 + 33) | 2) == 0xB)
          {
            id v88 = v86;
            uint64_t v89 = *(void *)(v85 + 48);
            uint64_t v90 = *(void *)(v85 + 24) + *(void *)(v85 + 56);
            unint64_t v91 = *(void *)(v85 + 40);
            id v92 = v86;

            uint64_t v93 = 0;
            unint64_t v201 = 0;
            uint64_t v177 = 0;
          }
          else
          {
            re::internal::DataPayload::computeConvertedValues<re::PackedFloat3>(v85, (uint64_t)v284);
            if (LOBYTE(v284[0]))
            {
              uint64_t v93 = *((void *)&v284[0] + 1);
              unint64_t v91 = *(void *)&v284[1];
              memset((char *)v284 + 8, 0, 24);
              uint64_t v90 = *((void *)&v284[1] + 1);
              uint64_t v89 = 12;
            }
            else
            {
              uint64_t v89 = 0;
              unint64_t v91 = 0;
              uint64_t v93 = 0;
              uint64_t v90 = 0;
            }
            re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v284);
            uint64_t v85 = 0;
            unint64_t v201 = v91;
            uint64_t v177 = v90;
          }
        }
        else
        {
          uint64_t v90 = 0;
          uint64_t v177 = 0;
          unint64_t v201 = 0;
          uint64_t v93 = 0;
          unint64_t v91 = 0;
          uint64_t v89 = 0;
        }
        unint64_t v95 = *((void *)v33 + 6);
        if (v95)
        {
          *(void *)uint64_t v293 = *((void *)v33 + 6);
          id v96 = (id)(v95 + 8);
          re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v293, v284);
          if (*(void *)v293) {

          }
          unint64_t v95 = *(void *)&v284[1];
        }
        else
        {
          memset(v284, 0, 56);
        }
        if (*((void *)v33 + 6)) {
          unint64_t v97 = v95;
        }
        else {
          unint64_t v97 = v91;
        }
        *(void *)uint64_t v293 = 0x3F8000003F800000;
        *(void *)&v293[8] = 0x3F8000003F800000;
        unint64_t v98 = v270;
        if (v270)
        {
          unint64_t v99 = 0;
          uint64_t v100 = v271;
          do
          {
            unint64_t v101 = v99;
            if (*((void *)v33 + 6)) {
              unint64_t v101 = *(unsigned int *)(*(void *)&v284[0] + *((void *)&v284[0] + 1) * v99);
            }
            if (v101 < v91)
            {
              uint64_t v102 = v90 + v101 * v89;
              *(void *)&long long v103 = *(void *)v102;
              DWORD2(v103) = *(_DWORD *)(v102 + 8);
              HIDWORD(v103) = 1.0;
              *(_OWORD *)&v100[4 * v99] = v103;
            }
            ++v99;
          }
          while (v98 != v99);
        }
        int v94 = *((unsigned __int8 *)v33 + 32);
        id v12 = v192;
        LODWORD(v80) = v181;
        unint64_t v71 = v209;
        if (*(void *)&v284[2])
        {
          if (*((void *)&v284[2] + 1))
          {
            (*(void (**)(void))(**(void **)&v284[2] + 40))();
            *((void *)&v284[2] + 1) = 0;
            *(void *)&v284[3] = 0;
          }
          *(void *)&v284[2] = 0;
        }
        if (*((void *)&v284[1] + 1)) {

        }
        if (v93 && v201) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v93 + 40))(v93, v177);
        }
        if (v85) {

        }
        long long v72 = (_anonymous_namespace_ *)v275;
        BOOL v77 = v205;
        if (void)v275 && (BYTE8(v275)) {
          long long v72 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v275 + 40))();
        }
        id v70 = v198;
      }
      else
      {
        int v94 = 1;
      }
      if (v73)
      {
        uint64_t v73 = v79;
        long long v104 = [(_anonymous_namespace_ *)v79 name];
        id v105 = [v104 stringValue];
        int v33 = (_anonymous_namespace_ *)[v105 UTF8String];

        uint64_t v106 = re::GeomModelDescriptor::attributeByName((re::GeomModelDescriptor *)v258, (const re::DynamicString *)v293);
        if (!v77) {
          int v94 = *(unsigned __int8 *)(v106 + 32);
        }
        if (*(unsigned __int8 *)(v106 + 32) == v94)
        {
          uint64_t v107 = v106;
          re::GeomModelDescriptor::AttributeData::makeConvertedValues<float>(v106, (uint64_t)v284);
          uint64_t v109 = *(void *)(v107 + 48);
          if (v109)
          {
            *(void *)unsigned int v296 = *(void *)(v107 + 48);
            id v110 = (id)(v109 + 8);
            re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v296, &v275);
            if (*(void *)v296) {
          }
            }
          else
          {
            uint64_t v278 = 0;
            long long v276 = 0u;
            long long v277 = 0u;
            long long v275 = 0u;
          }
          if (!v269)
          {
            if (*(void *)(v107 + 48)) {
              long long v111 = (unint64_t *)&v276;
            }
            else {
              long long v111 = (unint64_t *)&v284[1];
            }
            unint64_t v112 = *v111;
            *(void *)unsigned int v296 = 0x3F8000003F800000;
            *(void *)&v296[8] = 0x3F8000003F800000;
          }
          unint64_t v113 = v270;
          if (v270)
          {
            unint64_t v114 = 0;
            uint64_t v115 = v271 + 3;
            while (1)
            {
              unint64_t v116 = v114;
              if (!*(void *)(v107 + 48)) {
                goto LABEL_185;
              }
              if (v114 < (unint64_t)v276) {
                break;
              }
LABEL_187:
              ++v114;
              v115 += 4;
              if (v113 == v114) {
                goto LABEL_188;
              }
            }
            unint64_t v116 = *(unsigned int *)(v275 + *((void *)&v275 + 1) * v114);
LABEL_185:
            if (v116 < *(void *)&v284[1]) {
              _DWORD *v115 = *(_DWORD *)(*(void *)&v284[0] + *((void *)&v284[0] + 1) * v116);
            }
            goto LABEL_187;
          }
LABEL_188:
          if ((void)v277)
          {
            if (*((void *)&v277 + 1))
            {
              (*(void (**)(void))(*(void *)v277 + 40))();
              *((void *)&v277 + 1) = 0;
              uint64_t v278 = 0;
            }
            *(void *)&long long v277 = 0;
          }
          if (*((void *)&v276 + 1)) {

          }
          if (*(void *)&v284[2])
          {
            if (*((void *)&v284[2] + 1))
            {
              (*(void (**)(void))(**(void **)&v284[2] + 40))();
              *((void *)&v284[2] + 1) = 0;
              *(void *)&v284[3] = 0;
            }
            *(void *)&v284[2] = 0;
          }
          if (*((void *)&v284[1] + 1)) {
        }
          }
        long long v72 = *(_anonymous_namespace_ **)v293;
        id v70 = v198;
        if (*(void *)v293 && (v293[8] & 1) != 0) {
          long long v72 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v293 + 40))();
        }
      }
      else
      {
        uint64_t v73 = v79;
      }
      if (!v269) {
        goto LABEL_246;
      }
      uint64_t i = v271;
      unint64_t j = v270;
      uint64_t v273 = 0;
      uint64_t v272 = 0;
      uint64_t v119 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v263[8], (uint64_t)&v267);
      if (v119) {
        uint64_t v120 = (const re::DynamicString *)v119;
      }
      else {
        uint64_t v120 = (const re::DynamicString *)&v267;
      }
      re::DynamicString::DynamicString((re::DynamicString *)&v279, v120);
      __n128 v122 = re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v279, v94, 10, (uint64_t)&v275);
      if (!(_BYTE)v275)
      {
        LOBYTE(v136) = 0;
        float64x2_t v131 = (unsigned char *)*((void *)&v276 + 1);
        LOBYTE(j) = v277;
        *((void *)&v276 + 1) = 0;
        uint64_t i = (const void *)*((void *)&v277 + 1);
        uint64_t v278 = 0;
        long long v277 = 0uLL;
        goto LABEL_230;
      }
      if (!j)
      {
        LOBYTE(v136) = 0;
        uint64_t i = *(const void **)&v284[1];
        float64x2_t v131 = *(unsigned char **)&v284[0];
        LOBYTE(j) = BYTE8(v284[0]);
        goto LABEL_230;
      }
      v293[32] = 4;
      uint64_t v294 = 0;
      uint64_t v295 = 0;
      float64x2_t v124 = re::DynamicString::operator=(v123, (re::DynamicString *)&v279);
      v293[32] = v94;
      float64x2_t v125 = re::globalAllocators(v124);
      if (j >> 60 || 16 * j >= 0xFFFFFFFFFFFFFFF0)
      {
        re::internal::assertLog((re::internal *)6, v126, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 16, j);
        _os_crash();
        __break(1u);
      }
      else
      {
        uint64_t v127 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v125[2] + 32))(v125[2], (16 * j + 16) | 0xF, 0);
        float64x2_t v128 = (void *)((v127 + 31) & 0xFFFFFFFFFFFFFFF0);
        *(v128 - 2) = j;
        *(v128 - 1) = v127;
        bzero(v128, 16 * j);
        *(void *)&v284[0] = v128;
        memcpy(v128, i, 16 * j);
        *(void *)unsigned int v296 = j;
        uint64_t v283 = 16;
        int v282 = 0;
        char v281 = 1;
        re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)v284, re::ConvertToGeomModelValueType<re::Vector4<float>>::kValueType, (uint64_t *)v296, &v283, &v282, &v281, (uint64_t *)v284, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<re::Vector4<float>>, &v274);
        uint64_t v129 = v294;
        uint64_t v294 = v274;
        uint64_t v274 = v129;
        if (v129) {

        }
        if (v273)
        {
          re::GeomModelDescriptor::makeSlicePayload<unsigned int>((re *)&v272, (uint64_t *)v284);
          uint64_t v130 = v295;
          uint64_t v295 = *(void *)&v284[0];
          *(void *)&v284[0] = v130;
          if (v130) {
        }
          }
        float64x2_t v131 = &v258[48];
        uint64_t v132 = (const void **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v258[48], (uint64_t)&v279);
        if (!v132)
        {
          *(void *)&v284[0] = v261;
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)&v258[48], (re::DynamicString *)&v279, v284);
          v122.n128_f64[0] = re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)v260, (uint64_t)v293);
          uint64_t v135 = v295;
          goto LABEL_222;
        }
        uint64_t i = *v132;
        int v33 = v261;
        if (v261 > *v132)
        {
          __int16 v133 = re::DynamicString::operator=((re::DynamicString *)(*(void *)v263 + 56 * i), (re::DynamicString *)v293);
          *((unsigned char *)v133 + 32) = v293[32];
          uint64_t v134 = *((void *)v133 + 5);
          *((void *)v133 + 5) = v294;
          uint64_t v294 = v134;
          uint64_t v135 = *((void *)v133 + 6);
          *((void *)v133 + 6) = v295;
          uint64_t v295 = v135;
LABEL_222:
          if (v135)
          {

            uint64_t v295 = 0;
          }
          if (v294)
          {

            uint64_t v294 = 0;
          }
          if (*(void *)v293 && (v293[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)v293 + 40))();
          }
          LOBYTE(v136) = 1;
LABEL_230:
          if (!(_BYTE)v275) {
            goto LABEL_356;
          }
          goto LABEL_231;
        }
      }
      uint64_t v283 = 0;
      long long v285 = 0u;
      memset(v284, 0, sizeof(v284));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unsigned int v296 = 136315906;
      *(void *)&v296[4] = "operator[]";
      *(_WORD *)&v296[12] = 1024;
      *(_DWORD *)&v296[14] = 789;
      __int16 v297 = 2048;
      unint64_t v298 = i;
      __int16 v299 = 2048;
      uint64_t v300 = v33;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    id v70 = v198;
    re::addPropertyToGeomModelDescriptorHelper((uint64_t)v284, v198, (void *)v71, @"constant", v258, "vertexColor", 0);
    if (!LOBYTE(v284[0]) && *((void *)&v284[1] + 1))
    {
      if (v284[2]) {
        (*(void (**)(void))(**((void **)&v284[1] + 1) + 40))();
      }
      memset((char *)&v284[1] + 8, 0, 32);
    }
LABEL_247:

    if (v207) {
      int isCatmullClarkSurface = re::isCatmullClarkSurface(v70);
    }
    else {
      int isCatmullClarkSurface = 0;
    }
    int v138 = objc_msgSend(MEMORY[0x263F83F10], "meshGroupsWithNode:", v70, v175, v176);
    unsigned int v178 = v138;
    if ([v138 count])
    {
      *(void *)&long long v277 = 0;
      *(void *)&long long v276 = 0;
      long long v275 = 0uLL;
      DWORD2(v276) = 0;
      LODWORD(v284[0]) = 0;
      re::DynamicArray<unsigned int>::resize(&v275, obj, v284);
      long long v230 = 0u;
      long long v231 = 0u;
      long long v232 = 0u;
      long long v233 = 0u;
      obunint64_t j = v138;
      uint64_t v210 = [(id)obj countByEnumeratingWithState:&v230 objects:v292 count:16];
      if (v210)
      {
        uint64_t v206 = *(void *)v231;
        long long v207 = (re::DynamicString *)((char *)v284 + 8);
        while (2)
        {
          for (uint64_t i = 0; i != (const void *)v210; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v231 != v206) {
              objc_enumerationMutation((id)obj);
            }
            uint64_t v139 = *(void **)(*((void *)&v230 + 1) + 8 * i);
            uint64_t v140 = [v139 inheritedMaterialBinding];
            uint64_t v80 = v140;
            if (!v140) {
              goto LABEL_267;
            }
            uint64_t v141 = [v140 path];
            id v142 = [v141 stringValue];
            uint64_t v143 = (_anonymous_namespace_ *)[v142 UTF8String];
            LOBYTE(v284[0]) = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)((char *)v284 + 8), (const re::DynamicString *)v293);
            uint64_t v144 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(a3, (char *)v284);
            if (*((void *)&v284[0] + 1))
            {
              if (v284[1]) {
                (*(void (**)(void))(**((void **)&v284[0] + 1) + 40))();
              }
              memset((char *)v284 + 8, 0, 32);
            }
            if (*(void *)v293)
            {
              if (v293[8]) {
                (*(void (**)(void))(**(void **)v293 + 40))();
              }
              memset(v293, 0, 32);
            }

            if (v144) {
              uint64_t v73 = (_anonymous_namespace_ *)*(unsigned int *)(v144 + 8);
            }
            else {
LABEL_267:
            }
              uint64_t v73 = 0;
            unint64_t v145 = [v139 property:@"indices"];
            id v12 = [v145 data];
            uint64_t v136 = [v12 dataNoCopy];
            unint64_t v146 = [v136 length];
            if (v146 >= 4 * [v12 arraySize])
            {
              uint64_t v147 = [v136 bytes];
              if ([v12 arraySize])
              {
                for (unint64_t j = 0; [v12 arraySize] > j; ++j)
                {
                  unint64_t v71 = *(int *)(v147 + 4 * j);
                  if (v71 < v212)
                  {
                    uint64_t v148 = v276;
                    if ((unint64_t)v276 <= v71)
                    {
                      *(void *)unsigned int v296 = 0;
                      long long v285 = 0u;
                      memset(v284, 0, sizeof(v284));
                      float64x2_t v131 = (unsigned char *)&_os_log_internal;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)uint64_t v293 = 136315906;
                      *(void *)&v293[4] = "operator[]";
                      *(_WORD *)&v293[12] = 1024;
                      *(_DWORD *)&v293[14] = 789;
                      *(_WORD *)&v293[18] = 2048;
                      *(void *)&v293[20] = v71;
                      *(_WORD *)&v293[28] = 2048;
                      *(void *)&v293[30] = v148;
                      LODWORD(v176) = 38;
                      unint64_t v175 = v293;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_356:
                      if (*((void *)&v276 + 1) && (v277 & 1) != 0) {
                        (*(void (**)(__n128))(**((void **)&v276 + 1) + 40))(v122);
                      }
LABEL_231:
                      if (v279 && (v280 & 1) != 0) {
                        (*(void (**)(__n128))(*(void *)v279 + 40))(v122);
                      }
                      if (v131) {
                        char v137 = (char)v136;
                      }
                      else {
                        char v137 = 1;
                      }
                      if (v137 & 1) == 0 && (j) {
                        (*(void (**)(unsigned char *, const void *, __n128))(*(void *)v131 + 40))(v131, i, v122);
                      }
                      if (v267 && (v268 & 1) != 0) {
                        (*(void (**)(__n128))(*(void *)v267 + 40))(v122);
                      }
                      id v70 = v198;
                      if (v269 && v270) {
                        (*(void (**)(__n128))(*(void *)v269 + 40))(v122);
                      }
LABEL_246:
                      int v50 = (int)v80;
                      int v51 = v182;
                      goto LABEL_247;
                    }
                    *(_DWORD *)(v277 + 4 * v71) = v73;
                  }
                }
              }
            }
          }
          uint64_t v210 = [(id)obj countByEnumeratingWithState:&v230 objects:v292 count:16];
          if (v210) {
            continue;
          }
          break;
        }
      }

      __n128 v149 = re::GeomModelDescriptor::setMaterialAssignmentsPerFace((_anonymous_namespace_ *)v258, v277, v276, (uint64_t)v227);
      id v12 = v192;
      int v50 = v181;
      int v51 = v182;
      if (!v227[0] && (void)v228)
      {
        if (BYTE8(v228)) {
          (*(void (**)(__n128))(*(void *)v228 + 40))(v149);
        }
        __n128 v149 = 0uLL;
        long long v228 = 0u;
        long long v229 = 0u;
      }
      if ((void)v275 && (void)v277) {
        (*(void (**)(__n128))(*(void *)v275 + 40))(v149);
      }
    }
    else
    {
      uint64_t v150 = [v70 inheritedMaterialBinding];
      long long v151 = v150;
      if (v150)
      {
        long long v152 = [v150 path];
        id v153 = [v152 stringValue];
        unint64_t v154 = (_anonymous_namespace_ *)[v153 UTF8String];
        LOBYTE(v284[0]) = isCatmullClarkSurface;
        re::DynamicString::DynamicString((re::DynamicString *)((char *)v284 + 8), (const re::DynamicString *)&v275);
        uint64_t v155 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(a3, (char *)v284);
        if (*((void *)&v284[0] + 1))
        {
          if (v284[1]) {
            (*(void (**)(void))(**((void **)&v284[0] + 1) + 40))();
          }
          memset((char *)v284 + 8, 0, 32);
        }
        if ((void)v275)
        {
          if (BYTE8(v275)) {
            (*(void (**)(void))(*(void *)v275 + 40))();
          }
          long long v275 = 0u;
          long long v276 = 0u;
        }

        if (v155) {
          *(_DWORD *)&v258[4] = *(_DWORD *)(v155 + 8);
        }
      }
    }
    if (a8) {
      re::addSkeletonBindingsAsAttributesToModelDescriptor(v258, v198, a7, a8);
    }
    if (isCatmullClarkSurface) {
      re::attachOpenSubdivDataToModelDescriptor(v258, v198);
    }
    if (v51) {
      re::attachNewBlendShapeDataIfItExistsToModelDescriptor(v258, v198);
    }
    uint64_t v156 = objc_msgSend(v198, "properties", v149.n128_f64[0]);
    uint64_t v157 = v156;
    if (v50)
    {
      long long v225 = 0u;
      long long v226 = 0u;
      long long v223 = 0u;
      long long v224 = 0u;
      id v158 = v156;
      uint64_t v159 = [v158 countByEnumeratingWithState:&v223 objects:v291 count:16];
      if (!v159)
      {
LABEL_344:

        re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)v284, (uint64_t)v258);
        *(unsigned char *)uint64_t v183 = 1;
        re::GeomModelDescriptor::GeomModelDescriptor(v183 + 8, (uint64_t)v284);
        uint64_t v17 = v187;
        uint64_t v16 = v188;
        uint64_t v44 = v185;
        unsigned int v18 = v186;
        unint64_t v45 = v184;
        if ((void)v288)
        {
          if (BYTE8(v288)) {
            (*(void (**)(void))(*(void *)v288 + 40))();
          }
          long long v288 = 0u;
          long long v289 = 0u;
        }
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v287);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)&v286);
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v284[3]);
        if (*((void *)&v284[2] + 1))
        {

          *((void *)&v284[2] + 1) = 0;
        }
        id v13 = v189;
        if (*(void *)&v284[2])
        {

          *(void *)&v284[2] = 0;
        }
        if (*((void *)&v284[0] + 1)) {

        }
        goto LABEL_23;
      }
      uint64_t v160 = v159;
      uint64_t v211 = v157;
      uint64_t v161 = *(void *)v224;
      do
      {
        for (uint64_t k = 0; k != v160; ++k)
        {
          if (*(void *)v224 != v161) {
            objc_enumerationMutation(v158);
          }
          __int16 v163 = *(void **)(*((void *)&v223 + 1) + 8 * k);
          if (([v163 isEqualToString:@"orientation"] & 1) == 0
            && ([v163 isEqualToString:@"faceVertexIndices"] & 1) == 0
            && ([v163 isEqualToString:@"faceVertexCounts"] & 1) == 0
            && ([v163 isEqualToString:@"normals"] & 1) == 0
            && ([v163 isEqualToString:@"primvars:normals"] & 1) == 0
            && ([v163 isEqualToString:@"primvars:displayColor"] & 1) == 0
            && ([v163 isEqualToString:@"primvars:skel:jointWeights"] & 1) == 0
            && ([v163 isEqualToString:@"primvars:skel:jointIndices"] & 1) == 0
            && ([v163 isEqualToString:@"primvars:skel:geomBindTransform"] & 1) == 0
            && ([v163 isEqualToString:@"skel:joints"] & 1) == 0)
          {
            int v164 = [v158 objectForKey:v163];
            re::addPropertyToGeomModelDescriptorHelper((uint64_t)v220, v198, v164, @"constant", v258, 0, 0);
            if (!v220[0] && (void)v221)
            {
              if (BYTE8(v221)) {
                (*(void (**)(void))(*(void *)v221 + 40))();
              }
              long long v221 = 0u;
              long long v222 = 0u;
            }
          }
        }
        uint64_t v160 = [v158 countByEnumeratingWithState:&v223 objects:v291 count:16];
      }
      while (v160);
    }
    else
    {
      __int16 v165 = [v180 name];
      id v158 = [v165 stringValue];

      long long v218 = 0u;
      long long v219 = 0u;
      long long v216 = 0u;
      long long v217 = 0u;
      uint64_t v211 = v157;
      id v166 = v157;
      uint64_t v167 = [v166 countByEnumeratingWithState:&v216 objects:v290 count:16];
      if (v167)
      {
        uint64_t v168 = v167;
        uint64_t v169 = *(void *)v217;
        uint64_t v170 = (void *)*MEMORY[0x263F84058];
        do
        {
          for (uint64_t m = 0; m != v168; ++m)
          {
            if (*(void *)v217 != v169) {
              objc_enumerationMutation(v166);
            }
            unint64_t v172 = *(void **)(*((void *)&v216 + 1) + 8 * m);
            unsigned int v173 = [v166 objectForKey:v172];
            uint64_t v174 = [v173 role];

            if (v174 == v170 && ([v172 isEqualToString:v158] & 1) == 0)
            {
              re::addPropertyToGeomModelDescriptorHelper((uint64_t)v213, v198, v173, @"constant", v258, 0, 0);
              if (!v213[0])
              {
                if ((void)v214)
                {
                  if (BYTE8(v214)) {
                    (*(void (**)(void))(*(void *)v214 + 40))();
                  }
                  long long v214 = 0u;
                  long long v215 = 0u;
                }
              }
            }
          }
          uint64_t v168 = [v166 countByEnumeratingWithState:&v216 objects:v290 count:16];
        }
        while (v168);
      }
    }
    id v12 = v192;
    uint64_t v157 = v211;
    goto LABEL_344;
  }
  long long v40 = v284[0];
LABEL_21:
  long long v43 = v284[1];
  *(unsigned char *)uint64_t v183 = 0;
  *(void *)(v183 + 8) = 100;
  *(void *)(v183 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(v183 + 24) = v40;
  *(_OWORD *)(v183 + 40) = v43;
  id v12 = v192;
LABEL_22:
  uint64_t v16 = v188;
  id v13 = v189;
  uint64_t v17 = v187;
  unint64_t v45 = v184;
  uint64_t v44 = v185;
LABEL_23:
  if (v256 && (v257 & 1) != 0) {
    (*(void (**)(void))(*(void *)v256 + 40))();
  }
  if ((void)v265)
  {
    if (BYTE8(v265)) {
      (*(void (**)(void))(*(void *)v265 + 40))();
    }
    long long v265 = 0u;
    long long v266 = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v263[8]);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)v260);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v258[48]);
  if (*(void *)&v258[40])
  {

    *(void *)&v258[40] = 0;
  }
  uint64_t v20 = v191;
  if (*(void *)&v258[32])
  {

    *(void *)&v258[32] = 0;
  }
  if (*(void *)&v258[8]) {

  }
LABEL_37:
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(uint64_t a1, char *a2)
{
  unint64_t v4 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v11, a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  int v8 = *a2;
  uint64_t v6 = (uint64_t)(a2 + 8);
  int v7 = v8;
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(unsigned __int8 *)(v9 + 72 * v5 + 16) != v7 || !re::DynamicString::operator==(v9 + 72 * v5 + 24, v6))
  {
    uint64_t v5 = *(_DWORD *)(v9 + 72 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v9 + 72 * v5 + 56;
}

uint64_t re::GeomModelDescriptor::setAttribute<float,unsigned int>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    id v13 = (const re::DynamicString *)v12;
  }
  else {
    id v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 6, (uint64_t)v31);
  if (v31[0])
  {
    if (*((void *)a4 + 1))
    {
      char v28 = 4;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      char v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<float>(a4, (uint64_t *)&v47);
      uint64_t v15 = v29;
      uint64_t v29 = v47;
      *(void *)&long long v47 = v15;
      if (v15) {

      }
      if (*((void *)a5 + 1))
      {
        *(unsigned char *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        uint64_t v16 = v30;
        uint64_t v30 = v47;
        *(void *)&long long v47 = v16;
        if (v16) {
      }
        }
      uint64_t v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        unint64_t v18 = *v17;
        unint64_t v19 = a1[14];
        if (v19 <= *v17)
        {
          uint64_t v38 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v39 = 136315906;
          long long v40 = "operator[]";
          __int16 v41 = 1024;
          int v42 = 789;
          __int16 v43 = 2048;
          unint64_t v44 = v18;
          __int16 v45 = 2048;
          unint64_t v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((unsigned char *)v20 + 32) = v28;
        uint64_t v21 = *((void *)v20 + 5);
        *((void *)v20 + 5) = v29;
        uint64_t v29 = v21;
        uint64_t v22 = *((void *)v20 + 6);
        *((void *)v20 + 6) = v30;
        uint64_t v30 = v22;
      }
      else
      {
        *(void *)&long long v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        uint64_t v22 = v30;
      }
      *(unsigned char *)a6 = 1;
      if (v22)
      {

        uint64_t v30 = 0;
      }
      if (v29)
      {

        uint64_t v29 = 0;
      }
      if (v26 && (v27 & 1) != 0) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    else
    {
      long long v23 = v47;
      long long v24 = v48;
      *(unsigned char *)a6 = 0;
      *(void *)(a6 + 8) = 100;
      *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(void *)(a6 + 24) = v33;
    *(void *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    long long v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  uint64_t result = v36;
  if (v36)
  {
    if (v37) {
      return (*(uint64_t (**)(void))(*(void *)v36 + 40))();
    }
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<float>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  unint64_t v6 = *((void *)a1 + 1);
  if (!v6)
  {
    size_t v9 = 0;
    int v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 62) && 4 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v4[2] + 32))(v4[2], (4 * v6 + 16) | 3, 0);
    int v8 = (void *)((v7 + 19) & 0xFFFFFFFFFFFFFFFCLL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 4 * v6);
    size_t v9 = 4 * *((void *)a1 + 1);
LABEL_6:
    uint64_t v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    uint64_t v10 = *((void *)a1 + 1);
    uint64_t v14 = 4;
    uint64_t v15 = v10;
    int v13 = 0;
    char v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<float>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<float>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 4, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<float>(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<int,unsigned int>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    int v13 = (const re::DynamicString *)v12;
  }
  else {
    int v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 4, (uint64_t)v31);
  if (v31[0])
  {
    if (*((void *)a4 + 1))
    {
      char v28 = 4;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      char v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<int>(a4, (uint64_t *)&v47);
      uint64_t v15 = v29;
      uint64_t v29 = v47;
      *(void *)&long long v47 = v15;
      if (v15) {

      }
      if (*((void *)a5 + 1))
      {
        *(unsigned char *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        uint64_t v16 = v30;
        uint64_t v30 = v47;
        *(void *)&long long v47 = v16;
        if (v16) {
      }
        }
      uint64_t v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        unint64_t v18 = *v17;
        unint64_t v19 = a1[14];
        if (v19 <= *v17)
        {
          uint64_t v38 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v39 = 136315906;
          long long v40 = "operator[]";
          __int16 v41 = 1024;
          int v42 = 789;
          __int16 v43 = 2048;
          unint64_t v44 = v18;
          __int16 v45 = 2048;
          unint64_t v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((unsigned char *)v20 + 32) = v28;
        uint64_t v21 = *((void *)v20 + 5);
        *((void *)v20 + 5) = v29;
        uint64_t v29 = v21;
        uint64_t v22 = *((void *)v20 + 6);
        *((void *)v20 + 6) = v30;
        uint64_t v30 = v22;
      }
      else
      {
        *(void *)&long long v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        uint64_t v22 = v30;
      }
      *(unsigned char *)a6 = 1;
      if (v22)
      {

        uint64_t v30 = 0;
      }
      if (v29)
      {

        uint64_t v29 = 0;
      }
      if (v26 && (v27 & 1) != 0) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    else
    {
      long long v23 = v47;
      long long v24 = v48;
      *(unsigned char *)a6 = 0;
      *(void *)(a6 + 8) = 100;
      *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(void *)(a6 + 24) = v33;
    *(void *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    long long v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  uint64_t result = v36;
  if (v36)
  {
    if (v37) {
      return (*(uint64_t (**)(void))(*(void *)v36 + 40))();
    }
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<int>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  unint64_t v6 = *((void *)a1 + 1);
  if (!v6)
  {
    size_t v9 = 0;
    int v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 62) && 4 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v4[2] + 32))(v4[2], (4 * v6 + 16) | 3, 0);
    int v8 = (void *)((v7 + 19) & 0xFFFFFFFFFFFFFFFCLL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 4 * v6);
    size_t v9 = 4 * *((void *)a1 + 1);
LABEL_6:
    uint64_t v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    uint64_t v10 = *((void *)a1 + 1);
    uint64_t v14 = 4;
    uint64_t v15 = v10;
    int v13 = 0;
    char v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<int>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<int>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 4, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<int>(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t _ZN2re19GeomModelDescriptor12setAttributeIDv4_fjEENS_6ResultINS_4UnitENS_13DetailedErrorEEERKNS_13DynamicStringENS_17GeomAttributeRateERKNS_5SliceIT_EERKNSB_IT0_EE@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    int v13 = (const re::DynamicString *)v12;
  }
  else {
    int v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 10, (uint64_t)v31);
  if (v31[0])
  {
    if (*((void *)a4 + 1))
    {
      char v28 = 4;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      char v28 = a3;
      _ZN2re19GeomModelDescriptor16makeSlicePayloadIDv4_fEENS_9SharedPtrINS_8internal11DataPayloadEEERKNS_5SliceIT_EE(a4, (uint64_t *)&v47);
      uint64_t v15 = v29;
      uint64_t v29 = v47;
      *(void *)&long long v47 = v15;
      if (v15) {

      }
      if (*((void *)a5 + 1))
      {
        *(unsigned char *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        uint64_t v16 = v30;
        uint64_t v30 = v47;
        *(void *)&long long v47 = v16;
        if (v16) {
      }
        }
      uint64_t v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        unint64_t v18 = *v17;
        unint64_t v19 = a1[14];
        if (v19 <= *v17)
        {
          uint64_t v38 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v39 = 136315906;
          long long v40 = "operator[]";
          __int16 v41 = 1024;
          int v42 = 789;
          __int16 v43 = 2048;
          unint64_t v44 = v18;
          __int16 v45 = 2048;
          unint64_t v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((unsigned char *)v20 + 32) = v28;
        uint64_t v21 = *((void *)v20 + 5);
        *((void *)v20 + 5) = v29;
        uint64_t v29 = v21;
        uint64_t v22 = *((void *)v20 + 6);
        *((void *)v20 + 6) = v30;
        uint64_t v30 = v22;
      }
      else
      {
        *(void *)&long long v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        uint64_t v22 = v30;
      }
      *(unsigned char *)a6 = 1;
      if (v22)
      {

        uint64_t v30 = 0;
      }
      if (v29)
      {

        uint64_t v29 = 0;
      }
      if (v26 && (v27 & 1) != 0) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    else
    {
      long long v23 = v47;
      long long v24 = v48;
      *(unsigned char *)a6 = 0;
      *(void *)(a6 + 8) = 100;
      *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(void *)(a6 + 24) = v33;
    *(void *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    long long v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  uint64_t result = v36;
  if (v36)
  {
    if (v37) {
      return (*(uint64_t (**)(void))(*(void *)v36 + 40))();
    }
  }
  return result;
}

uint64_t _ZN2re19GeomModelDescriptor16makeSlicePayloadIDv4_fEENS_9SharedPtrINS_8internal11DataPayloadEEERKNS_5SliceIT_EE@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  unint64_t v6 = *((void *)a1 + 1);
  if (!v6)
  {
    size_t v9 = 0;
    int v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 60) && 16 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v4[2] + 32))(v4[2], (16 * v6 + 16) | 0xF, 0);
    int v8 = (void *)((v7 + 31) & 0xFFFFFFFFFFFFFFF0);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 16 * v6);
    size_t v9 = 16 * *((void *)a1 + 1);
LABEL_6:
    uint64_t v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    uint64_t v10 = *((void *)a1 + 1);
    uint64_t v14 = 16;
    uint64_t v15 = v10;
    int v13 = 0;
    char v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, _ZN2re27ConvertToGeomModelValueTypeIDv4_fE10kValueTypeE, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)_ZN2re19GeomModelDescriptor20freeReNewedArrayDataIDv4_fEEvPKv, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 16, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *_ZN2re19GeomModelDescriptor20freeReNewedArrayDataIDv4_fEEvPKv(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<unsigned short,unsigned int>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    int v13 = (const re::DynamicString *)v12;
  }
  else {
    int v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 3, (uint64_t)v31);
  if (v31[0])
  {
    if (*((void *)a4 + 1))
    {
      char v28 = 4;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      char v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<unsigned short>(a4, (uint64_t *)&v47);
      uint64_t v15 = v29;
      uint64_t v29 = v47;
      *(void *)&long long v47 = v15;
      if (v15) {

      }
      if (*((void *)a5 + 1))
      {
        *(unsigned char *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        uint64_t v16 = v30;
        uint64_t v30 = v47;
        *(void *)&long long v47 = v16;
        if (v16) {
      }
        }
      uint64_t v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        unint64_t v18 = *v17;
        unint64_t v19 = a1[14];
        if (v19 <= *v17)
        {
          uint64_t v38 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v39 = 136315906;
          long long v40 = "operator[]";
          __int16 v41 = 1024;
          int v42 = 789;
          __int16 v43 = 2048;
          unint64_t v44 = v18;
          __int16 v45 = 2048;
          unint64_t v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((unsigned char *)v20 + 32) = v28;
        uint64_t v21 = *((void *)v20 + 5);
        *((void *)v20 + 5) = v29;
        uint64_t v29 = v21;
        uint64_t v22 = *((void *)v20 + 6);
        *((void *)v20 + 6) = v30;
        uint64_t v30 = v22;
      }
      else
      {
        *(void *)&long long v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        uint64_t v22 = v30;
      }
      *(unsigned char *)a6 = 1;
      if (v22)
      {

        uint64_t v30 = 0;
      }
      if (v29)
      {

        uint64_t v29 = 0;
      }
      if (v26 && (v27 & 1) != 0) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    else
    {
      long long v23 = v47;
      long long v24 = v48;
      *(unsigned char *)a6 = 0;
      *(void *)(a6 + 8) = 100;
      *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(void *)(a6 + 24) = v33;
    *(void *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    long long v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  uint64_t result = v36;
  if (v36)
  {
    if (v37) {
      return (*(uint64_t (**)(void))(*(void *)v36 + 40))();
    }
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<unsigned short>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  uint64_t v6 = *((void *)a1 + 1);
  if (!v6)
  {
    size_t v9 = 0;
    int v8 = 0;
    goto LABEL_6;
  }
  if ((v6 & 0x8000000000000000) == 0 && (unint64_t)(2 * v6) < 0xFFFFFFFFFFFFFFF0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v4[2] + 32))(v4[2], (2 * v6 + 16) | 1, 0);
    int v8 = (void *)((v7 + 17) & 0xFFFFFFFFFFFFFFFELL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 2 * v6);
    size_t v9 = 2 * *((void *)a1 + 1);
LABEL_6:
    uint64_t v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    uint64_t v10 = *((void *)a1 + 1);
    uint64_t v14 = 2;
    uint64_t v15 = v10;
    int v13 = 0;
    char v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<unsigned short>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<unsigned short>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 2, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<unsigned short>(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<unsigned int,unsigned int>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12) {
    int v13 = (const re::DynamicString *)v12;
  }
  else {
    int v13 = (const re::DynamicString *)a2;
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 5, (uint64_t)v31);
  if (v31[0])
  {
    if (*((void *)a4 + 1))
    {
      char v28 = 4;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      char v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a4, (uint64_t *)&v47);
      uint64_t v15 = v29;
      uint64_t v29 = v47;
      *(void *)&long long v47 = v15;
      if (v15) {

      }
      if (*((void *)a5 + 1))
      {
        *(unsigned char *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        uint64_t v16 = v30;
        uint64_t v30 = v47;
        *(void *)&long long v47 = v16;
        if (v16) {
      }
        }
      uint64_t v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        unint64_t v18 = *v17;
        unint64_t v19 = a1[14];
        if (v19 <= *v17)
        {
          uint64_t v38 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v39 = 136315906;
          long long v40 = "operator[]";
          __int16 v41 = 1024;
          int v42 = 789;
          __int16 v43 = 2048;
          unint64_t v44 = v18;
          __int16 v45 = 2048;
          unint64_t v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((unsigned char *)v20 + 32) = v28;
        uint64_t v21 = *((void *)v20 + 5);
        *((void *)v20 + 5) = v29;
        uint64_t v29 = v21;
        uint64_t v22 = *((void *)v20 + 6);
        *((void *)v20 + 6) = v30;
        uint64_t v30 = v22;
      }
      else
      {
        *(void *)&long long v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        uint64_t v22 = v30;
      }
      *(unsigned char *)a6 = 1;
      if (v22)
      {

        uint64_t v30 = 0;
      }
      if (v29)
      {

        uint64_t v29 = 0;
      }
      if (v26 && (v27 & 1) != 0) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    else
    {
      long long v23 = v47;
      long long v24 = v48;
      *(unsigned char *)a6 = 0;
      *(void *)(a6 + 8) = 100;
      *(void *)(a6 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(void *)(a6 + 24) = v33;
    *(void *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    long long v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }
  uint64_t result = v36;
  if (v36)
  {
    if (v37) {
      return (*(uint64_t (**)(void))(*(void *)v36 + 40))();
    }
  }
  return result;
}

void *re::FixedArray<re::Vector4<float>>::init<re::Vector4<float>>(void *result, uint64_t a2, unint64_t a3, _OWORD *a4)
{
  *uint64_t result = a2;
  result[1] = a3;
  if (!a3) {
    return result;
  }
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v6 = result;
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * a3, 16);
  v6[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  unint64_t v8 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_OWORD *)uint64_t result = *a4;
      result += 2;
      --v8;
    }
    while (v8);
  }
  *(_OWORD *)uint64_t result = *a4;
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<re::Vector4<float>>(re *a1)
{
  uint64_t result = re::globalAllocators(a1);
  if (a1)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result[2] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

void CGImagePtr::CGImagePtr(CGImagePtr *this, CGImageRef image)
{
  *(void *)this = image;
  *((void *)this + 1) = CGImageGetWidth(image);
  *((void *)this + 2) = CGImageGetHeight(image);
  *((void *)this + 3) = CGImageGetBitsPerComponent(image);
  *((void *)this + 4) = CGImageGetBitsPerPixel(image);
  size_t BytesPerRow = CGImageGetBytesPerRow(image);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = BytesPerRow;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 18) = CGImageGetBitmapInfo(image);
  uint64_t ColorSpace = CGImageGetColorSpace(image);
  if (ColorSpace)
  {
    uint64_t v6 = CGColorSpaceRetain(ColorSpace);
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v6);
    CGColorSpaceModel Model = CGColorSpaceGetModel(v6);
    size_t v9 = (CGColorSpace *)*((void *)this + 6);
    *((void *)this + 6) = v6;
    *((void *)this + 7) = NumberOfComponents;
    *((_DWORD *)this + 16) = Model;
    CGColorSpaceRelease(v9);
  }
}

uint64_t CGImagePtr::CGImagePtr(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = -1;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = v5;
  uint64_t v6 = a2[2];
  a2[2] = 0;
  *(void *)(a1 + 16) = v6;
  uint64_t v7 = a2[3];
  a2[3] = 0;
  *(void *)(a1 + 24) = v7;
  uint64_t v8 = a2[5];
  uint64_t v9 = a2[6];
  a2[5] = 0;
  *(void *)(a1 + 40) = v8;
  uint64_t v10 = a2[4];
  a2[4] = 0;
  *(void *)(a1 + 32) = v10;
  uint64_t v11 = a2[7];
  int v12 = *((_DWORD *)a2 + 16);
  a2[6] = 0;
  a2[7] = 0;
  *((_DWORD *)a2 + 16) = -1;
  CGColorSpaceRelease(0);
  int v13 = *(CGColorSpace **)(a1 + 48);
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + 56) = v11;
  *(_DWORD *)(a1 + 64) = v12;
  CGColorSpaceRelease(v13);
  CGColorSpaceRelease(0);
  int v14 = *((_DWORD *)a2 + 18);
  *((_DWORD *)a2 + 18) = 0;
  *(_DWORD *)(a1 + 72) = v14;
  return a1;
}

void CGImagePtr::swap(CGImagePtr *this, CGImagePtr *a2)
{
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((void *)this + 1) = v6;
  *(void *)a2 = v4;
  *((void *)a2 + 1) = v5;
  uint64_t v7 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v7;
  uint64_t v8 = *((void *)this + 3);
  *((void *)this + 3) = *((void *)a2 + 3);
  *((void *)a2 + 3) = v8;
  uint64_t v9 = *((void *)this + 4);
  *((void *)this + 4) = *((void *)a2 + 4);
  *((void *)a2 + 4) = v9;
  uint64_t v10 = *((void *)this + 5);
  uint64_t v11 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  uint64_t v12 = *((void *)a2 + 6);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)a2 + 5) = v10;
  uint64_t v13 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  int v14 = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = -1;
  uint64_t v15 = *((void *)a2 + 7);
  LODWORD(v6) = *((_DWORD *)a2 + 16);
  *((_DWORD *)a2 + 16) = -1;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  uint64_t v16 = (CGColorSpace *)*((void *)this + 6);
  *((void *)this + 6) = v12;
  *((void *)this + 7) = v15;
  *((_DWORD *)this + 16) = v6;
  CGColorSpaceRelease(v16);
  uint64_t v17 = (CGColorSpace *)*((void *)a2 + 6);
  *((void *)a2 + 6) = v11;
  *((void *)a2 + 7) = v13;
  *((_DWORD *)a2 + 16) = v14;
  CGColorSpaceRelease(v17);
  CGColorSpaceRelease(0);
  int v18 = *((_DWORD *)this + 18);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  *((_DWORD *)a2 + 18) = v18;
}

const void *re::CGColorSpaceNameFromOCIOString(re *this, const __CFString *a2)
{
  id v2 = this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF984C0, memory_order_acquire) & 1) == 0)
  {
    int v5 = __cxa_guard_acquire(&qword_26AF984C0);
    id v2 = this;
    if (v5)
    {
      if (qword_26AF984E0 != -1) {
        dispatch_once(&qword_26AF984E0, &__block_literal_global_37);
      }
      _MergedGlobals_419 = qword_26AF984D8;
      __cxa_guard_release(&qword_26AF984C0);
      id v2 = this;
    }
  }
  CFDictionaryRef v3 = (const __CFDictionary *)_MergedGlobals_419;
  return CFDictionaryGetValue(v3, v2);
}

const void *re::OCIOStringArrayFromCGColorSpaceName(re *this, const __CFString *a2)
{
  id v2 = this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF984D0, memory_order_acquire) & 1) == 0)
  {
    int v5 = __cxa_guard_acquire(&qword_26AF984D0);
    id v2 = this;
    if (v5)
    {
      if (qword_26AF984F0 != -1) {
        dispatch_once(&qword_26AF984F0, &__block_literal_global_160);
      }
      qword_26AF984C8 = qword_26AF984E8;
      __cxa_guard_release(&qword_26AF984D0);
      id v2 = this;
    }
  }
  CFDictionaryRef v3 = (const __CFDictionary *)qword_26AF984C8;
  return CFDictionaryGetValue(v3, v2);
}

void ___ZN2reL30OCIOToCGColorSpaceMappingTableEv_block_invoke()
{
  v18[45] = *MEMORY[0x263EF8340];
  v0 = [MEMORY[0x263EFF9A0] dictionary];
  uint64_t v1 = *MEMORY[0x263F002D8];
  v17[0] = @"Input - Texture - sRGB - sRGB";
  v17[1] = @"Utility - sRGB - Texture";
  v18[0] = v1;
  v18[1] = v1;
  v17[2] = @"sRGB";
  v17[3] = @"srgb_texture";
  v18[2] = v1;
  void v18[3] = v1;
  v17[4] = @"sRGB - Texture";
  v17[5] = @"Input - Generic - sRGB - Texture";
  v18[4] = v1;
  v18[5] = v1;
  v17[6] = @"srgb_tx";
  v17[7] = @"Input - Texture - Linear - sRGB";
  uint64_t v2 = *MEMORY[0x263F002C8];
  v18[6] = v1;
  v18[7] = v2;
  v17[8] = @"Utility - Linear - sRGB";
  v17[9] = @"Utility - Linear - Rec.709";
  v18[8] = v2;
  v18[9] = v2;
  v17[10] = @"lin_srgb";
  v17[11] = @"scene-linear Rec 709/sRGB";
  v18[10] = v2;
  v18[11] = v2;
  v17[12] = @"lin_rec709";
  v17[13] = @"Linear Rec.709 (sRGB)";
  v18[12] = v2;
  v18[13] = v2;
  v17[14] = @"lin_rec709_srgb";
  v17[15] = @"Linear - sRGB";
  v18[14] = v2;
  v18[15] = v2;
  uint64_t v3 = *MEMORY[0x263F00218];
  v17[16] = @"Utility - Linear - P3-D65";
  v17[17] = @"Linear P3-D65";
  v18[16] = v3;
  v18[17] = v3;
  v17[18] = @"lin_displayp3";
  v17[19] = @"Linear - Display P3";
  v18[18] = v3;
  v18[19] = v3;
  uint64_t v4 = *MEMORY[0x263F001E8];
  v17[20] = @"Input - Texture - sRGB - Display P3";
  v17[21] = @"Input - Generic - Display P3 - Texture";
  v18[20] = v4;
  v18[21] = v4;
  v17[22] = @"sRGB - Display P3 - Texture";
  v17[23] = @"Role - texture_paint";
  v18[22] = v4;
  v18[23] = v4;
  v17[24] = @"role_texture_paint";
  v17[25] = @"Role - matte_paint";
  v18[24] = v4;
  v18[25] = v4;
  v17[26] = @"role_matte_paint";
  v17[27] = @"Role - color_picking";
  v18[26] = v4;
  v18[27] = v4;
  v17[28] = @"role_color_picking";
  v17[29] = @"srgb_displayp3";
  v18[28] = v4;
  v18[29] = v4;
  v17[30] = @"srgb_p3d65";
  v17[31] = @"Display P3";
  v18[30] = v4;
  v18[31] = v4;
  v17[32] = @"sRGB - Display P3";
  v17[33] = @"sRGB Encoded P3-D65 - Texture";
  v18[32] = v4;
  v18[33] = v4;
  v17[34] = @"srgb_encoded_p3d65_tx";
  v17[35] = @"Utility - sRGB - P3-D65 - Texture";
  v18[34] = v4;
  v18[35] = v4;
  uint64_t v5 = *MEMORY[0x263F001F8];
  v17[36] = @"Input - Texture - PQ - Display P3";
  v17[37] = @"Utility - Rec.2020 - Camera";
  uint64_t v6 = *MEMORY[0x263F00278];
  v18[36] = v5;
  v18[37] = v6;
  v17[38] = @"srgb_rec2020";
  v17[39] = @"Utility - Linear - Rec.2020";
  uint64_t v7 = *MEMORY[0x263F00228];
  v18[38] = v6;
  v18[39] = v7;
  v17[40] = @"Linear Rec.2020";
  v17[41] = @"acescg";
  uint64_t v8 = *MEMORY[0x263F001D0];
  v18[40] = v7;
  v18[41] = v8;
  v17[42] = @"ACES - ACEScg";
  v17[43] = @"ACEScg";
  v18[42] = v8;
  v18[43] = v8;
  v17[44] = @"lin_ap1";
  v18[44] = v8;
  uint64_t v9 = [NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:45];
  [v0 addEntriesFromDictionary:v9];
  uint64_t v10 = *MEMORY[0x263F002A8];
  v15[0] = @"Input - Texture - PQ - sRGB";
  v15[1] = @"Input - Texture - Linear - Display P3";
  uint64_t v11 = *MEMORY[0x263F002B0];
  v16[0] = v10;
  v16[1] = v11;
  v15[2] = @"lin_p3d65";
  v15[3] = @"Input - Texture - sRGB - Rec.2020";
  uint64_t v12 = *MEMORY[0x263F00280];
  v16[2] = v11;
  v16[3] = v12;
  _OWORD v15[4] = @"Input - Generic - Rec.2020 - Texture";
  v15[5] = @"sRGB - Rec.2020 - Texture";
  v16[4] = v12;
  v16[5] = v12;
  uint64_t v13 = *MEMORY[0x263F002C0];
  v15[6] = @"Input - Texture - Linear - Rec.2020";
  v15[7] = @"lin_rec2020";
  v16[6] = v13;
  v16[7] = v13;
  int v14 = [NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:8];
  [v0 addEntriesFromDictionary:v14];

  qword_26AF984D8 = (uint64_t)v0;
  CFRetain(v0);
}

void ___ZN2reL30CGColorSpaceToOCIOMappingTableEv_block_invoke()
{
  cf = [MEMORY[0x263EFF9A0] dictionary];
  if (qword_26AF984E0 != -1) {
    dispatch_once(&qword_26AF984E0, &__block_literal_global_37);
  }
  id v0 = (id)qword_26AF984D8;
  uint64_t v1 = [v0 keyEnumerator];
  uint64_t v2 = [v1 nextObject];
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    do
    {
      uint64_t v4 = [v0 objectForKeyedSubscript:v3];
      id v5 = v3;
      uint64_t v6 = [cf objectForKey:v4];

      if (v6)
      {
        uint64_t v7 = [cf objectForKeyedSubscript:v4];
      }
      else
      {
        uint64_t v7 = [MEMORY[0x263EFF980] array];
        [cf setObject:v7 forKeyedSubscript:v4];
      }
      [v7 addObject:v5];

      uint64_t v3 = [v1 nextObject];
    }
    while (v3);
  }
  qword_26AF984E8 = (uint64_t)cf;
  CFRetain(cf);
}

void re::internal::HIDKeyboardFactory::addDeviceMatchingDictionaries(re::internal::HIDKeyboardFactory *this, __CFArray *a2)
{
  DeviceMatchingDictionary = re::internal::createDeviceMatchingDictionary((re::internal *)1, 6);
  CFArrayAppendValue(a2, DeviceMatchingDictionary);
  CFRelease(DeviceMatchingDictionary);
}

uint64_t re::internal::HIDKeyboardFactory::tryCreate@<X0>(IOHIDDeviceRef device@<X1>, void *a2@<X8>)
{
  if (IOHIDDeviceConformsTo(device, 1u, 6u)) {
    operator new();
  }
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

void re::internal::HIDKeyboard::flush(re::internal::HIDKeyboard *this)
{
  *((unsigned char *)this + 4re::InputManager::notify(8, 0, 0, 0) = 0;
}

void re::internal::HIDKeyboardFactory::~HIDKeyboardFactory(re::internal::HIDKeyboardFactory *this)
{
}

void re::internal::HIDKeyboard::~HIDKeyboard(CFStringRef *this)
{
  re::internal::HIDDevice::~HIDDevice(this);
  JUMPOUT(0x237DBCBD0);
}

CFIndex HIDKeyboard_FnHandler(uint64_t a1, int a2, IOHIDValueRef value)
{
  CFIndex result = IOHIDValueGetIntegerValue(value);
  *(unsigned char *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = result != 0;
  return result;
}

void HIDKeyboard_KeyHandler(re::internal::HIDDevice *a1, int a2, IOHIDValueRef value, __IOHIDElement *a4)
{
  BOOL v5 = IOHIDValueGetIntegerValue(value) != 0;
  re::InputManager::notify(7, a2, v5, 0);
}

void *re::allocInfo_InputService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_420, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_420))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98500, "InputService");
    __cxa_guard_release(&_MergedGlobals_420);
  }
  return &unk_26AF98500;
}

void re::initInfo_InputService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x3611AC2775B3C756;
  v5[1] = "InputService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_InputService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_InputService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"InputService", (uint64_t (*)(re::internal *))re::allocInfo_InputService, (re::IntrospectionBase *(*)(void))re::initInfo_InputService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::InputService>, this);
}

uint64_t re::internal::HIDDevice::HIDDevice(uint64_t a1, re::internal *this, const __CFString *a3, int a4)
{
  CFStringRef v5 = a3;
  *(void *)a1 = &unk_26E715BD8;
  *(void *)(a1 + 8) = this;
  *(void *)(a1 + 16) = re::internal::getDevicePropertyString(this, @"Manufacturer", a3);
  DevicePropertyString = re::internal::getDevicePropertyString(this, @"Product", v8);
  *(void *)(a1 + 24) = DevicePropertyString;
  *(void *)(a1 + 32) = 0;
  CStringPtr = CFStringGetCStringPtr((CFStringRef)DevicePropertyString, 0x8000100u);
  uint64_t v11 = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 16), 0x8000100u);
  printf("Found \"%s\" by \"%s\"\n", CStringPtr, v11);
  int DevicePropertyInt = re::internal::getDevicePropertyInt(this, @"VendorID", v12);
  for (int i = re::internal::getDevicePropertyInt(this, @"ProductID", v14); a4; --a4)
  {
    if (LODWORD(v5->isa) == -1 && HIDWORD(v5->isa) == -1
      || LODWORD(v5->isa) == DevicePropertyInt && HIDWORD(v5->isa) == i)
    {
      *(void *)(a1 + 32) = v5;
    }
    CFStringRef v5 = (const __CFString *)((char *)v5 + 24);
  }
  return a1;
}

void re::internal::HIDDevice::~HIDDevice(CFStringRef *this)
{
  *this = (CFStringRef)&unk_26E715BD8;
  CStringPtr = CFStringGetCStringPtr(this[3], 0x8000100u);
  uint64_t v3 = CFStringGetCStringPtr(this[2], 0x8000100u);
  printf("Lost \"%s\" by \"%s\"\n", CStringPtr, v3);
}

{
  uint64_t vars8;

  re::internal::HIDDevice::~HIDDevice(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::HIDDevice::handleInput(re::internal::HIDDevice *this, IOHIDValueRef value)
{
  Element = IOHIDValueGetElement(value);
  uint64_t result = IOHIDElementGetType(Element);
  uint64_t v6 = *((void *)this + 4);
  uint64_t v7 = *(_DWORD **)(v6 + 8);
  uint64_t v8 = (result - *v7);
  if (v8 < *(_DWORD *)(v6 + 16))
  {
    uint64_t v9 = &v7[4 * v8];
    uint64_t v11 = *((void *)v9 + 1);
    uint64_t v10 = v9 + 2;
    if (v11)
    {
      uint64_t result = IOHIDElementGetUsage(Element);
      CFStringRef v12 = (_DWORD *)*v10;
      uint64_t v13 = (result - *(_DWORD *)*v10);
      if (v13 < v7[4 * v8 + 1])
      {
        CFStringRef v14 = *(uint64_t (**)(re::internal::HIDDevice *, uint64_t, IOHIDValueRef, __IOHIDElement *))&v12[4 * v13 + 2];
        if (v14)
        {
          uint64_t v15 = v12[4 * v13 + 1];
          return v14(this, v15, value, Element);
        }
      }
    }
  }
  return result;
}

uint64_t re::initInputManagement(re *this)
{
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  if (!inputState(void)::state)
  {
    uint64_t v2 = re::globalAllocators(v1);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 48, 8);
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
    inputState(void)::state = v3;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
  if (re::internal::HIDManager::getShared(void)::sharedInstancePredicate != -1) {
    dispatch_once(&re::internal::HIDManager::getShared(void)::sharedInstancePredicate, &__block_literal_global_38);
  }
  uint64_t v4 = re::internal::HIDManager::getShared(void)::sharedInstance;
  return re::internal::HIDManager::start(v4);
}

void inputState(void)
{
  {
    InputEventState::InputEventState((InputEventState *)&inputState(void)::state);
  }
}

void re::deinitInputManagement(re *this)
{
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  uint64_t v2 = (uint64_t *)inputState(void)::state;
  if (inputState(void)::state)
  {
    uint64_t v3 = re::globalAllocators(v1)[2];
    double v4 = re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v2);
    (*(void (**)(uint64_t, uint64_t *, double))(*(void *)v3 + 40))(v3, v2, v4);
    inputState(void)::state = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
    if (re::internal::HIDManager::getShared(void)::sharedInstancePredicate != -1) {
      dispatch_once(&re::internal::HIDManager::getShared(void)::sharedInstancePredicate, &__block_literal_global_38);
    }
    CFStringRef v5 = (re::internal::HIDManager *)re::internal::HIDManager::getShared(void)::sharedInstance;
    re::internal::HIDManager::stop(v5);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
  }
}

void re::InputManager::notify(int a1, int a2, int a3, int a4)
{
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  uint64_t v8 = inputState(void)::state;
  uint64_t v9 = *(unsigned int *)(inputState(void)::state + 32);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (int *)(*(void *)(inputState(void)::state + 16) + 8);
    while (1)
    {
      int v12 = *v11;
      v11 += 8;
      if (v12 < 0) {
        break;
      }
      if (v9 == ++v10)
      {
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(inputState(void)::state + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  if (v9 != v10)
  {
    uint64_t v13 = v10;
    uint64_t v14 = MEMORY[0x263EF8330];
    do
    {
      uint64_t v15 = *(void *)(v8 + 16);
      v20[0] = v14;
      uint64_t v16 = v15 + 32 * v13;
      v20[1] = 3221225472;
      v20[2] = ___ZN2re12InputManager6notifyE16REInputEventTypeiii_block_invoke;
      v20[3] = &__block_descriptor_64_e5_v8__0l;
      uint64_t v17 = *(NSObject **)(v16 + 24);
      v16 += 24;
      v20[4] = v16 - 8;
      v20[5] = v16;
      int v21 = a1;
      int v22 = a2;
      int v23 = a3;
      int v24 = a4;
      dispatch_async(v17, v20);
      if (*(_DWORD *)(v8 + 32) <= (v10 + 1)) {
        int v18 = v10 + 1;
      }
      else {
        int v18 = *(_DWORD *)(v8 + 32);
      }
      int v19 = v10;
      while (1)
      {
        uint64_t v13 = (v19 + 1);
        if (v18 - 1 == v19) {
          break;
        }
        ++v19;
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v13;
        if ((*(_DWORD *)(*(void *)(v8 + 16) + 32 * v13 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v18;
LABEL_17:
      ;
    }
    while (*(_DWORD *)(inputState(void)::state + 32) != v10);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
}

void ___ZN2re12InputManager6notifyE16REInputEventTypeiii_block_invoke(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 32);
  unint64_t v2 = *(unsigned int *)(a1 + 52);
  int32x2_t v3 = *(int32x2_t *)(a1 + 56);
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
      if (v3.i32[0]) {
        goto LABEL_16;
      }
      goto LABEL_7;
    case 1:
      switch(v2)
      {
        case 4:
          *(_DWORD *)(v1 + 120) += v3.i32[0];
          break;
        case 2:
          *(_DWORD *)(v1 + 116) += v3.i32[0];
          break;
        case 1:
          *(_DWORD *)(v1 + 112) += v3.i32[0];
          break;
      }
      return;
    case 2:
      *(void *)(v1 + 112) = 0;
      *(void *)(v1 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
      *(_DWORD *)(v1 + 136) = 0;
      *(void *)(v1 + 128) = 0;
      return;
    case 3:
      *(void *)(v1 + 112) = 0;
      goto LABEL_15;
    case 4:
      *(void *)(v1 + 112) = 0;
      *(int32x2_t *)(v1 + 124) = v3;
LABEL_7:
      int v4 = *(_DWORD *)(v1 + 136) & ~v2;
      goto LABEL_17;
    case 5:
      *(int32x2_t *)(v1 + 112) = vadd_s32(vsub_s32(v3, *(int32x2_t *)(v1 + 124)), *(int32x2_t *)(v1 + 112));
LABEL_15:
      *(int32x2_t *)(v1 + 124) = v3;
LABEL_16:
      int v4 = *(_DWORD *)(v1 + 136) | v2;
LABEL_17:
      *(_DWORD *)(v1 + 136) = v4;
      break;
    case 6:
      *(_DWORD *)(v1 + 12re::InputManager::notify(8, 0, 0, 0) = v2;
      *(_DWORD *)(v1 + 132) += v2;
      break;
    case 7:
      if (v2 >= 0xE8) {
        abort();
      }
      uint64_t v6 = v1 + 16;
      unint64_t v7 = v2 >> 6;
      uint64_t v8 = 1 << v2;
      if (v3.i32[0]) {
        uint64_t v9 = *(void *)(v6 + 8 * v7) | v8;
      }
      else {
        uint64_t v9 = *(void *)(v6 + 8 * v7) & ~v8;
      }
      *(void *)(v6 + 8 * v7) = v9;
      break;
    case 8:
      uint64_t v11 = v1 + 16;
      int v12 = 0;
      std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v11, 0xE8uLL);
      break;
    case 9:
      *(_DWORD *)(v1 + 20re::InputManager::notify(8, 0, 0, 0) = 0;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(_DWORD *)(v1 + 196) = 0;
      *(_WORD *)(v1 + 212) = 1;
      break;
    case 0xA:
      __int32 v10 = v3.i32[0] - *(_DWORD *)(v1 + 208);
      *(_DWORD *)(v1 + 196) = v2 - *(_DWORD *)(v1 + 204);
      *(_DWORD *)(v1 + 20re::InputManager::notify(8, 0, 0, 0) = v10;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(_WORD *)(v1 + 212) = 0;
      break;
    case 0xB:
      __int32 v5 = v3.i32[0] - *(_DWORD *)(v1 + 208);
      *(_DWORD *)(v1 + 196) = v2 - *(_DWORD *)(v1 + 204);
      *(_DWORD *)(v1 + 20re::InputManager::notify(8, 0, 0, 0) = v5;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(unsigned char *)(v1 + 213) = 1;
      break;
    default:
      return;
  }
}

void re::InputManager::subscribe(uint64_t a1, id *a2)
{
  uint64_t v4 = a1;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addOrReplace<re::dispatch::Queue&>(inputState(void)::state, &v4, a2);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
  uint64_t v5 = v4 + 16;
  int v6 = 0;
  std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v5, 0xE8uLL);
  uint64_t v3 = v4;
  *(void *)(v4 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 112) = 0;
  *(_DWORD *)(v3 + 136) = 0;
  *(void *)(v3 + 204) = 0;
  *(void *)(v3 + 196) = 0;
  *(_WORD *)(v3 + 212) = 0;
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addOrReplace<re::dispatch::Queue&>(uint64_t a1, uint64_t *a2, id *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v15 = re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addEmplace<re::dispatch::Queue&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 16) + 32 * v15;
    return v14 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    int v12 = *(_DWORD *)(v11 + 32 * v10 + 8);
    uint64_t v10 = v12 & 0x7FFFFFFF;
    if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }

  uint64_t v13 = *(void *)(a1 + 16) + 32 * v10;
  *(void *)(v13 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v14 = *(void *)(a1 + 16) + 32 * v10;
  return v14 + 24;
}

void re::InputManager::unsubscribe(re::InputManager *this, re::InputManager *a2)
{
  unint64_t v2 = this;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::remove(inputState(void)::state, (uint64_t *)&v2);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = v9 + 32 * v7;
  if (*(void *)(v10 + 16) != v3)
  {
    while (1)
    {
      unsigned int v11 = v7;
      int v12 = *(_DWORD *)(v9 + 32 * v7 + 8);
      uint64_t v7 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v13 = v9 + 32 * v7;
      if (*(void *)(v13 + 16) == v3)
      {
        *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = v14 + 32 * v7;
  int v18 = *(_DWORD *)(v15 + 8);
  uint64_t v17 = (int *)(v15 + 8);
  int v16 = v18;
  if (v18 < 0)
  {
    *uint64_t v17 = v16 & 0x7FFFFFFF;

    uint64_t v14 = *(void *)(a1 + 16);
    int v16 = *(_DWORD *)(v14 + 32 * v7 + 8);
  }
  int v19 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v14 + 32 * v7 + 8) = *(_DWORD *)(a1 + 36) | v16 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v19 + 1;
  return 1;
}

BOOL re::InputManager::isSubscribed(re::InputManager *this, re::InputManager *a2)
{
  unint64_t v4 = this;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_2687A0C28);
  BOOL v2 = re::HashTable<re::ecs2::Entity const*,unsigned long long,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::containsKey(inputState(void)::state, (uint64_t *)&v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_2687A0C28);
  return v2;
}

uint64_t re::InputManager::isDown(uint64_t a1, unsigned int a2)
{
  return (*(void *)(a1 + (((unint64_t)a2 >> 3) & 0x18) + 48) >> a2) & 1;
}

BOOL re::InputManager::isUp(uint64_t a1, unsigned int a2)
{
  return ((*(void *)(a1 + (((unint64_t)a2 >> 3) & 0x18) + 48) >> a2) & 1) == 0;
}

BOOL re::InputManager::wentDown(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = a1 + 8 * ((unint64_t)a2 >> 6);
  return (*(void *)(v2 + 80) & (1 << a2)) == 0 && (*(void *)(v2 + 48) & (1 << a2)) != 0;
}

BOOL re::InputManager::wentUp(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = a1 + 8 * ((unint64_t)a2 >> 6);
  return (*(void *)(v2 + 80) & (1 << a2)) != 0 && (*(void *)(v2 + 48) & (1 << a2)) == 0;
}

BOOL re::InputManager::isDown(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 164) & a2) != 0;
}

BOOL re::InputManager::isUp(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 164) & a2) == 0;
}

BOOL re::InputManager::wentDown(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 192) & a2) == 0 && (*(_DWORD *)(a1 + 164) & a2) != 0;
}

BOOL re::InputManager::wentUp(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 192) & a2) != 0 && (*(_DWORD *)(a1 + 164) & a2) == 0;
}

uint64_t re::InputManager::isTouching(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 232);
}

BOOL re::InputManager::wentTouching(re::InputManager *this)
{
  return !*((unsigned char *)this + 252) && *((unsigned char *)this + 232) != 0;
}

uint64_t re::InputManager::isTouchMoving(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 233);
}

BOOL re::InputManager::wentTouchMoving(re::InputManager *this)
{
  return !*((unsigned char *)this + 253) && *((unsigned char *)this + 233) != 0;
}

uint64_t re::InputManager::isKeyboardHandled(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t re::InputManager::setKeyboardHandled(uint64_t this)
{
  *(unsigned char *)(this + 8) = 1;
  return this;
}

uint64_t re::InputManager::isMouseOrTouchHandled(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 9);
}

uint64_t re::InputManager::setMouseOrTouchHandled(uint64_t this)
{
  *(unsigned char *)(this + 9) = 1;
  return this;
}

__n128 re::InputManager::keyboardState@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[3];
  __n128 v3 = this[4];
  *a2 = result;
  a2[1] = v3;
  return result;
}

__n128 re::InputManager::mouseState@<Q0>(re::InputManager *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = *(_OWORD *)((char *)this + 140);
  __n128 result = *(__n128 *)((char *)this + 152);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

__n128 re::InputManager::getTouchState@<Q0>(re::InputManager *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 216);
  *a2 = result;
  a2[1].n128_u32[0] = *((_DWORD *)this + 58);
  return result;
}

void InputEventState::InputEventState(InputEventState *this)
{
  *((_DWORD *)this + 2) = 0;
  uint64_t v2 = re::globalAllocators(this);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 48, 8);
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  *(void *)this = v3;
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addEmplace<re::dispatch::Queue&>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, id *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 32 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v10 + 16) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 32 * v10;
  *(void *)(v14 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v25, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v25;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)id v25 = v5;
      *(void *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&unsigned char v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (uint64_t *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 3);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 32 * v18) = v15;
            *(void *)(*(void *)(a1 + 16) + 32 * v18 + 16) = *(v14 - 1);
            uint64_t v22 = *(void *)(a1 + 16) + 32 * v18;
            uint64_t v23 = *v14;
            uint64_t *v14 = 0;
            *(void *)(v22 + 24) = v23;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

void ___ZN2re8internal10HIDManager9getSharedEv_block_invoke()
{
}

void anonymous namespace'::deviceFactories(_anonymous_namespace_ *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_421, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_421))
  {
    qword_26AF98580 = 0;
    qword_26AF98588 = 0;
    qword_26AF98590 = 0;
    __cxa_guard_release(&_MergedGlobals_421);
  }
}

void re::internal::HIDManager::stop(re::internal::HIDManager *this)
{
  int v2 = *((_DWORD *)this + 1);
  if (!v2)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s: Unbalanced HIDManager.stop() call.\n", "void re::internal::HIDManager::stop()");
    int v2 = *((_DWORD *)this + 1);
  }
  int v3 = v2 - 1;
  *((_DWORD *)this + 1) = v3;
  if (!v3)
  {
    IOHIDManagerClose(*((IOHIDManagerRef *)this + 1), 0);
    uint64_t v4 = (__IOHIDManager *)*((void *)this + 1);
    Current = CFRunLoopGetCurrent();
    IOHIDManagerUnscheduleFromRunLoop(v4, Current, (CFStringRef)*MEMORY[0x263EFFE88]);
    IOHIDManagerRegisterDeviceMatchingCallback(*((IOHIDManagerRef *)this + 1), (IOHIDDeviceCallback)re::internal::HIDManager::nullCallback, 0);
    uint64_t v6 = (__IOHIDManager *)*((void *)this + 1);
    IOHIDManagerRegisterDeviceRemovalCallback(v6, (IOHIDDeviceCallback)re::internal::HIDManager::nullCallback, 0);
  }
}

uint64_t re::internal::HIDManager::start(uint64_t this)
{
  unsigned int v1 = *(_DWORD *)(this + 4) + 1;
  *(_DWORD *)(this + 4) = v1;
  if (v1 <= 1)
  {
    int v2 = (IOHIDManagerRef *)this;
    if (qword_26AF98588 == qword_26AF98580)
    {
      return fprintf((FILE *)*MEMORY[0x263EF8348], "%s: No HID device factories registered.\n");
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
      if (Mutable)
      {
        CFArrayRef v4 = Mutable;
        uint64_t v6 = (uint64_t *)qword_26AF98580;
        uint64_t v5 = qword_26AF98588;
        while (v6 != (uint64_t *)v5)
        {
          uint64_t v7 = *v6++;
          (*(void (**)(uint64_t, const __CFArray *))(*(void *)v7 + 16))(v7, v4);
        }
        IOHIDManagerSetDeviceMatchingMultiple(v2[1], v4);
        CFRelease(v4);
        IOHIDManagerRegisterDeviceMatchingCallback(v2[1], (IOHIDDeviceCallback)re::internal::HIDManager::deviceMatchingCallback, v2);
        IOHIDManagerRegisterDeviceRemovalCallback(v2[1], (IOHIDDeviceCallback)re::internal::HIDManager::deviceRemovalCallback, v2);
        unsigned int v8 = v2[1];
        Current = CFRunLoopGetCurrent();
        IOHIDManagerScheduleWithRunLoop(v8, Current, (CFStringRef)*MEMORY[0x263EFFE88]);
        this = IOHIDManagerOpen(v2[1], 0);
        if (this)
        {
          this = fprintf((FILE *)*MEMORY[0x263EF8348], "%s: IOHIDManagerOpen() failed.\n", "void re::internal::HIDManager::start()");
          *(unsigned char *)int v2 = 0;
        }
      }
      else
      {
        return fprintf((FILE *)*MEMORY[0x263EF8348], "%s: CFArrayCreateMutable() failed.\n");
      }
    }
  }
  return this;
}

void re::internal::HIDManager::deviceMatchingCallback(re::internal::HIDManager *this, void *a2, int a3, __IOHIDDevice *a4, __IOHIDDevice *a5)
{
  uint64_t v7 = qword_26AF98580;
  uint64_t v8 = qword_26AF98588;
  while (v7 != v8)
  {
    (*(void (**)(void **__return_ptr))(**(void **)v7 + 24))(&context);
    if (context)
    {
      IOHIDDeviceRegisterInputValueCallback(a4, (IOHIDValueCallback)re::internal::HIDManager::inputValueCallback, context);
      unint64_t v10 = (void *)*((void *)this + 3);
      unint64_t v9 = *((void *)this + 4);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v13 = (void *)*((void *)this + 2);
        uint64_t v14 = v10 - v13;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = (char *)operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        int v19 = &v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        int v21 = context;
        context = 0;
        *(void *)int v19 = v21;
        int v12 = v19 + 8;
        if (v10 == v13)
        {
          *((void *)this + 2) = v19;
          *((void *)this + 3) = v12;
          *((void *)this + 4) = v20;
        }
        else
        {
          do
          {
            uint64_t v22 = *--v10;
            void *v10 = 0;
            *((void *)v19 - 1) = v22;
            v19 -= 8;
          }
          while (v10 != v13);
          unint64_t v10 = (void *)*((void *)this + 2);
          uint64_t v23 = (void *)*((void *)this + 3);
          *((void *)this + 2) = v19;
          *((void *)this + 3) = v12;
          *((void *)this + 4) = v20;
          while (v23 != v10)
          {
            uint64_t v25 = *--v23;
            uint64_t v24 = v25;
            *uint64_t v23 = 0;
            if (v25) {
              (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
            }
          }
        }
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        unint64_t v11 = context;
        context = 0;
        void *v10 = v11;
        int v12 = v10 + 1;
      }
      *((void *)this + 3) = v12;
      uint64_t v26 = context;
      context = 0;
      if (v26) {
        (*(void (**)(void *))(*(void *)v26 + 8))(v26);
      }
      return;
    }
    v7 += 8;
  }
}

void re::internal::HIDManager::deviceRemovalCallback(re::internal::HIDManager *this, void *a2, int a3, IOHIDDeviceRef device, __IOHIDDevice *a5)
{
  IOHIDDeviceRegisterInputValueCallback(device, 0, 0);
  uint64_t v7 = (void *)*((void *)this + 2);
  uint64_t v8 = (void *)*((void *)this + 3);
  if (v7 != v8)
  {
    uint64_t v9 = 0;
    while (*(IOHIDDeviceRef *)(v7[v9] + 8) != device)
    {
      if (&v7[++v9] == v8) {
        return;
      }
    }
    unint64_t v10 = &v7[v9];
    unint64_t v11 = &v7[v9 + 1];
    if (v11 != v8)
    {
      do
      {
        uint64_t v12 = *(v11 - 1);
        *(v11 - 1) = *v11;
        void *v11 = 0;
        if (v12) {
          (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        }
        ++v11;
      }
      while (v11 != v8);
      uint64_t v8 = (void *)*((void *)this + 3);
      unint64_t v10 = v11 - 1;
    }
    while (v8 != v10)
    {
      uint64_t v14 = *--v8;
      uint64_t v13 = v14;
      void *v8 = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
    }
    *((void *)this + 3) = v10;
  }
}

uint64_t re::internal::HIDManager::inputValueCallback(re::internal::HIDManager *this, void *a2, int a3, IOHIDValueRef value, __IOHIDValue *a5)
{
  return re::internal::HIDDevice::handleInput(this, value);
}

__CFDictionary *re::internal::createDeviceMatchingDictionary(re::internal *this, int a2)
{
  int v9 = a2;
  int valuePtr = (int)this;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s: CFDictionaryCreateMutable failed.\n", "CFMutableDictionaryRef re::internal::createDeviceMatchingDictionary(UInt32, UInt32)");
    return Mutable;
  }
  CFNumberRef v4 = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  if (!v4)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s: CFNumberCreate(usage page) failed.\n");
    return 0;
  }
  CFNumberRef v5 = v4;
  CFDictionarySetValue(Mutable, @"PrimaryUsagePage", v4);
  CFRelease(v5);
  CFNumberRef v6 = CFNumberCreate(v2, kCFNumberIntType, &v9);
  if (!v6)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s: CFNumberCreate(usage) failed.\n");
    return 0;
  }
  CFNumberRef v7 = v6;
  CFDictionarySetValue(Mutable, @"PrimaryUsage", v6);
  CFRelease(v7);
  return Mutable;
}

uint64_t re::internal::getDevicePropertyInt(re::internal *this, const __CFString *a2, const __CFString *a3)
{
  if (!this) {
    return 0xFFFFFFFFLL;
  }
  CFNumberRef Property = (const __CFNumber *)IOHIDDeviceGetProperty(this, a2);
  if (!Property) {
    return 0xFFFFFFFFLL;
  }
  CFNumberRef v4 = Property;
  CFTypeID v5 = CFGetTypeID(Property);
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0xFFFFFFFFLL;
  if (v5 == TypeID)
  {
    unsigned int valuePtr = -1;
    if (CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr)) {
      return valuePtr;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

__IOHIDDevice *re::internal::getDevicePropertyString(__IOHIDDevice *this, const __CFString *a2, const __CFString *a3)
{
  if (this)
  {
    this = (__IOHIDDevice *)IOHIDDeviceGetProperty(this, a2);
    if (this)
    {
      int v3 = this;
      CFTypeID v4 = CFGetTypeID(this);
      if (v4 == CFStringGetTypeID()) {
        return v3;
      }
      else {
        return 0;
      }
    }
  }
  return this;
}

re::TypeBuilder *re::TypeBuilder::TypeBuilder(re::TypeBuilder *this, re::Allocator *a2)
{
  *(unsigned char *)this = 0;
  re::StringID::invalid((re::TypeBuilder *)((char *)this + 8));
  *((_DWORD *)this + 6) = -1;
  *((unsigned char *)this + 28) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *(_OWORD *)((char *)this + 44re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *((_DWORD *)this + 118) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 28re::InputManager::notify(8, 0, 0, 0) = 0u;
  *((_DWORD *)this + 74) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 2re::InputManager::notify(8, 0, 0, 0) = 0u;
  *((_DWORD *)this + 84) = 0;
  *((_DWORD *)this + 94) = 0;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 36re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(void *)((char *)this + 476) = 0x7FFFFFFFLL;
  *((void *)this + 24) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity((void *)this + 24, 0);
  ++*((_DWORD *)this + 54);
  *((void *)this + 29) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity((void *)this + 29, 0);
  ++*((_DWORD *)this + 64);
  *((void *)this + 34) = a2;
  re::DynamicArray<float *>::setCapacity((void *)this + 34, 0);
  ++*((_DWORD *)this + 74);
  *((void *)this + 39) = a2;
  re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity((void *)this + 39, 0);
  ++*((_DWORD *)this + 84);
  *((void *)this + 44) = a2;
  re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)this + 44, 0);
  ++*((_DWORD *)this + 94);
  re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init((uint64_t)this + 440, (uint64_t)a2, 3);
  return this;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  CFTypeID v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    CFNumberRef v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      CFTypeID v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_19, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::TypeBuilder::~TypeBuilder(re::TypeBuilder *this, uint64_t a2)
{
  if (*((unsigned char *)this + 392)) {
    re::StringID::destroyString((re::TypeBuilder *)((char *)this + 408));
  }
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192);
  re::StringID::destroyString((re::TypeBuilder *)((char *)this + 8));
}

void re::TypeBuilder::reset(re::TypeBuilder *this, uint64_t a2)
{
  switch(*(unsigned char *)this)
  {
    case 0:
      return;
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 9:
      goto LABEL_2;
    case 2:
      re::DynamicArray<re::EnumConstant>::clear((uint64_t)this + 192);
      re::DynamicArray<re::EnumConstant>::clear((uint64_t)this + 232);
      goto LABEL_2;
    case 7:
      *((void *)this + 36) = 0;
      ++*((_DWORD *)this + 74);
      goto LABEL_2;
    case 8:
      re::StringID::destroyString((re::TypeBuilder *)((char *)this + 136));
      re::DynamicArray<re::GeomDeformer::Attribute>::clear((uint64_t)this + 312);
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::clear((uint64_t)this + 352);
      LOBYTE(v9[0]) = 0;
      re::Optional<re::internal::ObjectMemberInfo>::operator=((uint64_t)this + 392, (unsigned __int8 *)v9);
      if (LOBYTE(v9[0])) {
        re::StringID::destroyString((re::StringID *)&v10);
      }
LABEL_2:
      *(unsigned char *)this = 0;
      re::StringID::invalid((re::StringID *)&v7);
      uint64_t v3 = v7;
      unint64_t v4 = v8;
      uint64_t v7 = 0;
      uint64_t v8 = "";
      uint64_t v5 = *((void *)this + 1);
      uint64_t v6 = *((void *)this + 2);
      *((void *)this + 1) = v3;
      *((void *)this + 2) = v4;
      v9[0] = v3 & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
      v9[1] = v6;
      re::StringID::destroyString((re::StringID *)v9);
      re::StringID::destroyString((re::StringID *)&v7);
      *((_DWORD *)this + 6) = -1;
      if (*((unsigned char *)this + 28)) {
        *((unsigned char *)this + 28) = 0;
      }
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::clear((uint64_t)this + 440);
      return;
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown type category.", "!\"Unreachable code\"", "reset", 77);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D78788);
  }
}

void re::DynamicArray<re::EnumConstant>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 24 * v2;
    unint64_t v4 = (re::StringID *)(*(void *)(a1 + 32) + 8);
    do
    {
      re::StringID::destroyString(v4);
      unint64_t v4 = (re::StringID *)((char *)v4 + 24);
      v3 -= 24;
    }
    while (v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::Optional<re::internal::ObjectMemberInfo>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (*(unsigned char *)a1) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v3 == 0;
  }
  if (!v4)
  {
    if (*(unsigned char *)a1) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      re::StringID::destroyString((re::StringID *)(a1 + 16));
      *(unsigned char *)a1 = 0;
    }
    else
    {
      if (*(unsigned char *)a1) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v3 == 0;
      }
      if (v7)
      {
        *(void *)(a1 + 8) = *((void *)a2 + 1);
        uint64_t v8 = *((void *)a2 + 2);
        uint64_t v9 = *((void *)a2 + 3);
        *((void *)a2 + 2) = 0;
        *((void *)a2 + 3) = "";
        uint64_t v10 = *(void *)(a1 + 16);
        uint64_t v11 = *(void *)(a1 + 24);
        *(void *)(a1 + 16) = v8;
        *(void *)(a1 + 24) = v9;
        v15[0] = v8 & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
        v15[1] = v11;
        re::StringID::destroyString((re::StringID *)v15);
      }
      else
      {
        *(unsigned char *)a1 = 1;
        *(void *)(a1 + 8) = *((void *)a2 + 1);
        uint64_t v12 = *((void *)a2 + 2);
        *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
        *(void *)(a1 + 16) = *((void *)a2 + 2) & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
        *(void *)(a1 + 24) = *((void *)a2 + 3);
        *((void *)a2 + 2) = 0;
        *((void *)a2 + 3) = "";
      }
      uint64_t v13 = *((void *)a2 + 4);
      *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = *((_DWORD *)a2 + 10);
      *(void *)(a1 + 32) = v13;
    }
  }
  return a1;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_202, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 56 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 56;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

void re::TypeBuilder::commitTo(re::TypeBuilder *this@<X0>, re::TypeRegistry *a2@<X1>, void *a3@<X8>)
{
  if (*(unsigned char *)this)
  {
    re::TypeRegistry::declareType((uint64_t)a2, *(unsigned __int8 *)this, (StringID *)((char *)this + 8), *((_DWORD *)this + 6), 0, a3);
    if (*a3)
    {
      long long v5 = *(_OWORD *)a3;
      re::TypeBuilder::commitTo((unsigned __int8 *)this, (uint64_t *)&v5);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "commitTo", 102);
    _os_crash();
    __break(1u);
  }
}

void re::TypeBuilder::commitTo(unsigned __int8 *a1, uint64_t *a2)
{
  uint64_t v320 = *MEMORY[0x263EF8340];
  if (!*a1)
  {
LABEL_354:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling commitTo().", "isBuilding()", "commitTo", 118);
    _os_crash();
    __break(1u);
    goto LABEL_355;
  }
  unint64_t v4 = (unint64_t)a2;
  if (!*a2)
  {
LABEL_355:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "commitTo", 119);
    _os_crash();
    __break(1u);
    goto LABEL_356;
  }
  uint64_t v2 = a1;
  unint64_t v3 = *((unsigned int *)a1 + 6);
  uint64_t v299 = *a2;
  uint64_t v9 = re::DataArray<re::TextureAtlasTile>::tryGet(*a2 + 96, a2[1]);
  if (v9) {
    int v11 = *(_DWORD *)(v9 + 16);
  }
  else {
    int v11 = -1;
  }
  if (v3 != v11)
  {
LABEL_356:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type version mismatch.", "m_version == registry->typeVersion(typeID)", "commitTo", 124);
    _os_crash();
    __break(1u);
LABEL_357:
    unint64_t v16 = v299;
    re::TypeRegistry::typeName(v299, *(void *)(v3 + 152 * v5));
    unsigned int v292 = re::TypeRegistry::typeName(v299, *(void *)(v3 + 152 * v5));
    re::internal::assertLog((re::internal *)6, v293, "assertion failure: '%s' (%s:line %i) Duplicate custom class IDs in inheritance tree. Classes \"%s\" and \"%s\".", "objectType.customClassID.value() != m_objectTypeInfo.customClassID.value()", "commitTo", 377, v292[1], *((void *)v2 + 2));
    _os_crash();
    __break(1u);
    goto LABEL_358;
  }
  unint64_t v3 = v299;
  uint64_t v12 = v299 + 32;
  uint64_t v13 = (_anonymous_namespace_ *)re::DataArray<re::internal::TypeInfoIndex>::get(v299 + 32, *(void *)(v4 + 8));
  unsigned int v15 = *v2;
  if (v15 > 9) {
    goto LABEL_377;
  }
  unint64_t v16 = (unint64_t)v13;
  if (((1 << v15) & 0x2FA) == 0)
  {
    if (v15 == 2)
    {
      uint64_t v40 = *((void *)v2 + 26);
      if (v40)
      {
        unint64_t v6 = 24 * v40;
        __int16 v41 = (StringID *)(*((void *)v2 + 28) + 8);
        unint64_t v7 = (unint64_t)"";
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v41, (re::StringID *)&v302);
          uint64_t v42 = v302;
          __int16 v43 = (char *)v303;
          uint64_t v302 = 0;
          unsigned int v303 = "";
          var1 = v41->var1;
          unint64_t v45 = v42 & 0xFFFFFFFFFFFFFFFELL | *(void *)&v41->var0 & 1;
          v41->var1 = v43;
          *(void *)buf = v45;
          *(void *)&uint8_t buf[8] = var1;
          *(void *)&v41->var0 = v42;
          __int16 v41 = (StringID *)((char *)v41 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v6 -= 24;
        }
        while (v6);
      }
      uint64_t v46 = *((void *)v2 + 31);
      if (v46)
      {
        unint64_t v6 = 24 * v46;
        long long v47 = (StringID *)(*((void *)v2 + 33) + 8);
        unint64_t v7 = (unint64_t)"";
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v47, (re::StringID *)&v302);
          uint64_t v48 = v302;
          long long v49 = (char *)v303;
          uint64_t v302 = 0;
          unsigned int v303 = "";
          long long v50 = v47->var1;
          unint64_t v51 = v48 & 0xFFFFFFFFFFFFFFFELL | *(void *)&v47->var0 & 1;
          v47->var1 = v49;
          *(void *)buf = v51;
          *(void *)&uint8_t buf[8] = v50;
          *(void *)&v47->var0 = v48;
          long long v47 = (StringID *)((char *)v47 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v6 -= 24;
        }
        while (v6);
      }
      goto LABEL_9;
    }
    if (v15 == 8)
    {
      re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, (const StringID *)(v2 + 136), (re::StringID *)&v302);
      uint64_t v24 = v302;
      uint64_t v25 = v303;
      unint64_t v6 = (unint64_t)"";
      uint64_t v302 = 0;
      unsigned int v303 = "";
      uint64_t v26 = *((void *)v2 + 17);
      uint64_t v27 = *((void *)v2 + 18);
      *((void *)v2 + 17) = v24;
      *((void *)v2 + 18) = v25;
      *(void *)buf = v24 & 0xFFFFFFFFFFFFFFFELL | v26 & 1;
      *(void *)&uint8_t buf[8] = v27;
      re::StringID::destroyString((re::StringID *)buf);
      re::StringID::destroyString((re::StringID *)&v302);
      uint64_t v28 = *((void *)v2 + 41);
      if (v28)
      {
        unint64_t v7 = 40 * v28;
        uint64_t v29 = (StringID *)(*((void *)v2 + 43) + 8);
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v29, (re::StringID *)&v302);
          uint64_t v30 = v302;
          uint64_t v31 = (char *)v303;
          uint64_t v302 = 0;
          unsigned int v303 = "";
          long long v32 = v29->var1;
          unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFFELL | *(void *)&v29->var0 & 1;
          v29->var1 = v31;
          *(void *)buf = v33;
          *(void *)&uint8_t buf[8] = v32;
          *(void *)&v29->var0 = v30;
          uint64_t v29 = (StringID *)((char *)v29 + 40);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v7 -= 40;
        }
        while (v7);
      }
      uint64_t v34 = *((void *)v2 + 46);
      if (v34)
      {
        uint64_t v35 = (StringID *)*((void *)v2 + 48);
        unint64_t v7 = (unint64_t)v35 + 24 * v34;
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v35, (re::StringID *)&v302);
          uint64_t v36 = v302;
          char v37 = (char *)v303;
          uint64_t v302 = 0;
          unsigned int v303 = "";
          uint64_t v38 = v35->var1;
          unint64_t v39 = v36 & 0xFFFFFFFFFFFFFFFELL | *(void *)&v35->var0 & 1;
          v35->var1 = v37;
          *(void *)buf = v39;
          *(void *)&uint8_t buf[8] = v38;
          *(void *)&v35->var0 = v36;
          uint64_t v35 = (StringID *)((char *)v35 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
        }
        while (v35 != (StringID *)v7);
      }
      goto LABEL_9;
    }
LABEL_377:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Unexpected type category.", "!\"Unreachable code\"", "internStrings", 1103);
    _os_crash();
    __break(1u);
    JUMPOUT(0x233D7AF98);
  }
LABEL_9:
  if (*((void *)v2 + 6)) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = *((void *)v2 + 7) == 0;
  }
  *((void *)v2 + 4) = *(void *)(v4 + 8);
  unint64_t v17 = v2 + 32;
  switch(*v2)
  {
    case 1u:
      *((_DWORD *)v2 + 20) |= v5 | 2;
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 264) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v18 = *(void *)(v299 + 256);
      unint64_t v19 = *(void *)(v299 + 264);
      if (v19 >= v18)
      {
        unint64_t v20 = v19 + 1;
        if (v18 < v19 + 1)
        {
          if (*(void *)(v299 + 248))
          {
            uint64_t v21 = 2 * v18;
            BOOL v100 = v18 == 0;
            unint64_t v22 = 8;
            if (!v100) {
              unint64_t v22 = v21;
            }
            if (v22 <= v20) {
              unint64_t v23 = v20;
            }
            else {
              unint64_t v23 = v22;
            }
            re::DynamicArray<re::PipelineStateCacheKey>::setCapacity((void *)(v299 + 248), v23);
          }
          else
          {
            re::DynamicArray<re::PipelineStateCacheKey>::setCapacity((void *)(v299 + 248), v20);
            ++*(_DWORD *)(v299 + 272);
          }
        }
        unint64_t v19 = *(void *)(v299 + 264);
      }
      uint64_t v202 = *(void *)(v299 + 280) + 72 * v19;
      *(_OWORD *)uint64_t v202 = *v17;
      long long v203 = *((_OWORD *)v2 + 3);
      long long v204 = *((_OWORD *)v2 + 4);
      long long v205 = *((_OWORD *)v2 + 5);
      *(void *)(v202 + 64) = *((void *)v2 + 12);
      *(_OWORD *)(v202 + 32) = v204;
      *(_OWORD *)(v202 + 48) = v205;
      *(_OWORD *)(v202 + 16) = v203;
      ++*(void *)(v299 + 264);
      ++*(_DWORD *)(v299 + 272);
      goto LABEL_321;
    case 2u:
      if (!*((void *)v2 + 26))
      {
        uint64_t v52 = *re::foundationIntrospectionLogObjects(v13);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v53 = *((void *)v2 + 2);
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v53;
          _os_log_impl(&dword_233120000, v52, OS_LOG_TYPE_DEFAULT, "Creating enum type \"%s\" without values.", buf, 0xCu);
        }
      }
      uint64_t v54 = *((void *)v2 + 31);
      if (!v54) {
        goto LABEL_49;
      }
      long long v55 = (void *)*((void *)v2 + 33);
      uint64_t v56 = *((void *)v2 + 26);
      if (!v56) {
        goto LABEL_360;
      }
      uint64_t v57 = &v55[3 * v54];
      uint64_t v58 = 24 * v56;
      do
      {
        uint64_t v59 = v58;
        id v60 = (void *)*((void *)v2 + 28);
        while (*v55 != *v60)
        {
          v60 += 3;
          v59 -= 24;
          if (!v59) {
            goto LABEL_360;
          }
        }
        v55 += 3;
      }
      while (v55 != v57);
LABEL_49:
      __n128 v61 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((void *)v299, *((void *)v2 + 13), buf);
      *((_DWORD *)v2 + 20) |= v5 | 2;
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 304) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      long long v62 = (unint64_t *)(v299 + 328);
      uint64_t v63 = *((void *)v2 + 26);
      *((_DWORD *)v2 + 28) = *(void *)(v299 + 344);
      *((_DWORD *)v2 + 29) = v63;
      *((_DWORD *)v2 + 3re::InputManager::notify(8, 0, 0, 0) = *((void *)v2 + 31);
      unint64_t v64 = *(void *)(v299 + 296);
      unint64_t v65 = *(void *)(v299 + 304);
      if (v65 >= v64)
      {
        unint64_t v66 = v65 + 1;
        if (v64 < v65 + 1)
        {
          if (*(void *)(v299 + 288))
          {
            uint64_t v67 = 2 * v64;
            BOOL v100 = v64 == 0;
            unint64_t v68 = 8;
            if (!v100) {
              unint64_t v68 = v67;
            }
            if (v68 <= v66) {
              unint64_t v69 = v66;
            }
            else {
              unint64_t v69 = v68;
            }
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 288), v69);
          }
          else
          {
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 288), v66);
            ++*(_DWORD *)(v299 + 312);
          }
        }
        unint64_t v65 = *(void *)(v299 + 304);
      }
      v237 = (_OWORD *)(*(void *)(v299 + 320) + 96 * v65);
      long long v238 = *((_OWORD *)v2 + 3);
      _OWORD *v237 = *v17;
      v237[1] = v238;
      long long v239 = *((_OWORD *)v2 + 4);
      long long v240 = *((_OWORD *)v2 + 5);
      long long v241 = *((_OWORD *)v2 + 7);
      void v237[4] = *((_OWORD *)v2 + 6);
      v237[5] = v241;
      v237[2] = v239;
      v237[3] = v240;
      ++*(void *)(v299 + 304);
      ++*(_DWORD *)(v299 + 312);
      unint64_t v242 = *(void *)(v299 + 344);
      uint64_t v243 = *((void *)v2 + 26);
      uint64_t v244 = *((void *)v2 + 31);
      unint64_t v245 = v243 + v242 + v244;
      BOOL v246 = v242 > v245;
      if (v242 >= v245)
      {
        unint64_t v3 = v299;
        if (!v246) {
          goto LABEL_277;
        }
        uint64_t v248 = v299;
        uint64_t v252 = 24 * v245 + 8;
        unint64_t v253 = v245;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(void *)(v299 + 360) + v252));
          ++v253;
          v252 += 24;
        }
        while (v253 < *(void *)(v299 + 344));
      }
      else
      {
        unint64_t v247 = *(void *)(v299 + 344);
        if (*(void *)(v299 + 336) < v245)
        {
          re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v62, v243 + v242 + v244);
          unint64_t v247 = *(void *)(v299 + 344);
        }
        uint64_t v248 = v299;
        if (v247 < v245)
        {
          unint64_t v249 = v243 + v242 + v244 - v247;
          uint64_t v250 = 24 * v247;
          do
          {
            long long v251 = (void *)(*(void *)(v299 + 360) + v250);
            *long long v251 = 0;
            re::StringID::invalid((re::StringID *)(v251 + 1));
            v250 += 24;
            --v249;
          }
          while (v249);
        }
      }
      *(void *)(v248 + 344) = v245;
      ++*(_DWORD *)(v248 + 352);
      uint64_t v243 = *((void *)v2 + 26);
      unint64_t v3 = v248;
LABEL_277:
      re::DynamicArray<re::EnumConstant>::copy(v62, *((unsigned int *)v2 + 28), *((unint64_t **)v2 + 28), v243);
      re::DynamicArray<re::EnumConstant>::copy(v62, *((void *)v2 + 26) + *((unsigned int *)v2 + 28), *((unint64_t **)v2 + 33), *((void *)v2 + 31));
      goto LABEL_321;
    case 3u:
      id v70 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((void *)v299, *((void *)v2 + 13), buf);
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 384) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v71 = *(void *)(v299 + 376);
      unint64_t v72 = *(void *)(v299 + 384);
      if (v72 >= v71)
      {
        unint64_t v73 = v72 + 1;
        if (v71 < v72 + 1)
        {
          if (*(void *)(v299 + 368))
          {
            uint64_t v74 = 2 * v71;
            BOOL v100 = v71 == 0;
            unint64_t v75 = 8;
            if (!v100) {
              unint64_t v75 = v74;
            }
            if (v75 <= v73) {
              unint64_t v76 = v73;
            }
            else {
              unint64_t v76 = v75;
            }
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 368), v76);
          }
          else
          {
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 368), v73);
            ++*(_DWORD *)(v299 + 392);
          }
        }
        unint64_t v72 = *(void *)(v299 + 384);
      }
      uint64_t v206 = (_OWORD *)(*(void *)(v299 + 400) + 96 * v72);
      long long v207 = *((_OWORD *)v2 + 3);
      *uint64_t v206 = *v17;
      v206[1] = v207;
      long long v208 = *((_OWORD *)v2 + 4);
      long long v209 = *((_OWORD *)v2 + 5);
      long long v210 = *((_OWORD *)v2 + 7);
      void v206[4] = *((_OWORD *)v2 + 6);
      v206[5] = v210;
      v206[2] = v208;
      v206[3] = v209;
      ++*(void *)(v299 + 384);
      ++*(_DWORD *)(v299 + 392);
      goto LABEL_321;
    case 4u:
      char v77 = v5 ^ 1;
      if ((*((_DWORD *)v2 + 29) & 0xFFFFFF) != 0) {
        char v77 = 1;
      }
      if (v77)
      {
        if ((*((_DWORD *)v2 + 29) & 0xFFFFFF) != 0)
        {
LABEL_126:
          *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 424) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
          unint64_t v109 = *(void *)(v299 + 416);
          unint64_t v110 = *(void *)(v299 + 424);
          if (v110 >= v109)
          {
            unint64_t v111 = v110 + 1;
            if (v109 < v110 + 1)
            {
              if (*(void *)(v299 + 408))
              {
                uint64_t v112 = 2 * v109;
                BOOL v100 = v109 == 0;
                unint64_t v113 = 8;
                if (!v100) {
                  unint64_t v113 = v112;
                }
                if (v113 <= v111) {
                  unint64_t v114 = v111;
                }
                else {
                  unint64_t v114 = v113;
                }
                re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 408), v114);
              }
              else
              {
                re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 408), v111);
                ++*(_DWORD *)(v299 + 432);
              }
            }
            unint64_t v110 = *(void *)(v299 + 424);
          }
          long long v232 = (_OWORD *)(*(void *)(v299 + 440) + 96 * v110);
          long long v233 = *((_OWORD *)v2 + 3);
          *long long v232 = *v17;
          v232[1] = v233;
          long long v234 = *((_OWORD *)v2 + 4);
          long long v235 = *((_OWORD *)v2 + 5);
          long long v236 = *((_OWORD *)v2 + 7);
          v232[4] = *((_OWORD *)v2 + 6);
          v232[5] = v236;
          v232[2] = v234;
          v232[3] = v235;
          ++*(void *)(v299 + 424);
          ++*(_DWORD *)(v299 + 432);
          goto LABEL_321;
        }
LABEL_124:
        uint64_t v13 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((void *)v299, *((void *)v2 + 13), buf);
        if ((*(unsigned char *)(*((void *)&v316 + 1) + 48) & 3) != 0) {
          *((_DWORD *)v2 + 20) |= 2u;
        }
        goto LABEL_126;
      }
      re::TypeRegistry::typeInfo((void *)v299, *((void *)v2 + 13), buf);
      if (buf[0])
      {
        if (*(_DWORD *)(*((void *)&v316 + 1) + 48)) {
          *((_DWORD *)v2 + 20) |= 1u;
        }
        goto LABEL_124;
      }
      goto LABEL_375;
    case 5u:
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 464) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v79 = *(void *)(v299 + 456);
      unint64_t v80 = *(void *)(v299 + 464);
      if (v80 >= v79)
      {
        unint64_t v81 = v80 + 1;
        if (v79 < v80 + 1)
        {
          if (*(void *)(v299 + 448))
          {
            uint64_t v82 = 2 * v79;
            BOOL v100 = v79 == 0;
            unint64_t v83 = 8;
            if (!v100) {
              unint64_t v83 = v82;
            }
            if (v83 <= v81) {
              unint64_t v84 = v81;
            }
            else {
              unint64_t v84 = v83;
            }
            re::DynamicArray<re::internal::ListTypeInfo>::setCapacity((void *)(v299 + 448), v84);
          }
          else
          {
            re::DynamicArray<re::internal::ListTypeInfo>::setCapacity((void *)(v299 + 448), v81);
            ++*(_DWORD *)(v299 + 472);
          }
        }
        unint64_t v80 = *(void *)(v299 + 464);
      }
      uint64_t v211 = (_OWORD *)(*(void *)(v299 + 480) + (v80 << 7));
      long long v212 = *v17;
      long long v213 = *((_OWORD *)v2 + 3);
      long long v214 = *((_OWORD *)v2 + 5);
      v211[2] = *((_OWORD *)v2 + 4);
      v211[3] = v214;
      *uint64_t v211 = v212;
      v211[1] = v213;
      long long v215 = *((_OWORD *)v2 + 6);
      long long v216 = *((_OWORD *)v2 + 7);
      long long v217 = *((_OWORD *)v2 + 9);
      v211[6] = *((_OWORD *)v2 + 8);
      v211[7] = v217;
      v211[4] = v215;
      v211[5] = v216;
      ++*(void *)(v299 + 464);
      ++*(_DWORD *)(v299 + 472);
      goto LABEL_321;
    case 6u:
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 504) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v85 = *(void *)(v299 + 496);
      unint64_t v86 = *(void *)(v299 + 504);
      if (v86 >= v85)
      {
        unint64_t v87 = v86 + 1;
        if (v85 < v86 + 1)
        {
          if (*(void *)(v299 + 488))
          {
            uint64_t v88 = 2 * v85;
            BOOL v100 = v85 == 0;
            unint64_t v89 = 8;
            if (!v100) {
              unint64_t v89 = v88;
            }
            if (v89 <= v87) {
              unint64_t v90 = v87;
            }
            else {
              unint64_t v90 = v89;
            }
            re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity((void *)(v299 + 488), v90);
          }
          else
          {
            re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity((void *)(v299 + 488), v87);
            ++*(_DWORD *)(v299 + 512);
          }
        }
        unint64_t v86 = *(void *)(v299 + 504);
      }
      long long v218 = (_OWORD *)(*(void *)(v299 + 520) + 160 * v86);
      long long v219 = *((_OWORD *)v2 + 3);
      *long long v218 = *v17;
      v218[1] = v219;
      long long v220 = *((_OWORD *)v2 + 4);
      long long v221 = *((_OWORD *)v2 + 5);
      long long v222 = *((_OWORD *)v2 + 7);
      v218[4] = *((_OWORD *)v2 + 6);
      v218[5] = v222;
      v218[2] = v220;
      v218[3] = v221;
      long long v223 = *((_OWORD *)v2 + 8);
      long long v224 = *((_OWORD *)v2 + 9);
      long long v225 = *((_OWORD *)v2 + 11);
      v218[8] = *((_OWORD *)v2 + 10);
      v218[9] = v225;
      v218[6] = v223;
      v218[7] = v224;
      ++*(void *)(v299 + 504);
      ++*(_DWORD *)(v299 + 512);
      goto LABEL_321;
    case 7u:
      unint64_t v91 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((void *)v299, *((void *)v2 + 13), &v302);
      if (!(_BYTE)v302) {
        goto LABEL_361;
      }
      if (v304 != 2) {
        goto LABEL_362;
      }
      if (*((void *)v2 + 6)) {
        goto LABEL_363;
      }
      if (*((void *)v2 + 7)) {
        goto LABEL_364;
      }
      uint64_t v92 = *((void *)v2 + 36);
      *((_DWORD *)v2 + 29) = *(void *)(v299 + 584);
      *((_DWORD *)v2 + 3re::InputManager::notify(8, 0, 0, 0) = v92;
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 544) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v93 = *(void *)(v299 + 544);
      unint64_t v94 = *(void *)(v299 + 536);
      if (v93 >= v94)
      {
        unint64_t v95 = v93 + 1;
        if (v94 < v93 + 1)
        {
          if (*(void *)(v299 + 528))
          {
            uint64_t v96 = 2 * v94;
            BOOL v100 = v94 == 0;
            unint64_t v97 = 8;
            if (!v100) {
              unint64_t v97 = v96;
            }
            if (v97 <= v95) {
              unint64_t v98 = v95;
            }
            else {
              unint64_t v98 = v97;
            }
            unint64_t v91 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 528), v98);
          }
          else
          {
            unint64_t v91 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((void *)(v299 + 528), v95);
            ++*(_DWORD *)(v299 + 552);
          }
        }
        unint64_t v93 = *(void *)(v299 + 544);
      }
      uint64_t v254 = (_OWORD *)(*(void *)(v299 + 560) + 96 * v93);
      long long v255 = *((_OWORD *)v2 + 3);
      *uint64_t v254 = *v17;
      v254[1] = v255;
      long long v256 = *((_OWORD *)v2 + 4);
      long long v257 = *((_OWORD *)v2 + 5);
      long long v258 = *((_OWORD *)v2 + 7);
      v254[4] = *((_OWORD *)v2 + 6);
      v254[5] = v258;
      v254[2] = v256;
      v254[3] = v257;
      ++*(void *)(v299 + 544);
      ++*(_DWORD *)(v299 + 552);
      unint64_t v259 = *(void *)(v299 + 584);
      unint64_t v6 = *((void *)v2 + 36);
      unint64_t v260 = v6 + v259;
      if (v259 >= v6 + v259)
      {
        if (v259 <= v6 + v259) {
          goto LABEL_288;
        }
      }
      else
      {
        if (*(void *)(v299 + 576) < v260)
        {
          unint64_t v91 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((void *)(v299 + 568), v6 + v259);
          unint64_t v259 = *(void *)(v299 + 584);
        }
        if (v259 < v260)
        {
          unint64_t v91 = (_anonymous_namespace_ *)(*(void *)(v299 + 600) + 8 * v259);
          uint64_t v261 = 8 * v260 - 8 * v259;
          if (v261 >= 1) {
            memset_pattern16(v91, &unk_23440AFF0, 8 * (((unint64_t)v261 >> 3) - ((unint64_t)v261 > 7)) + 8);
          }
        }
      }
      *(void *)(v299 + 584) = v260;
      ++*(_DWORD *)(v299 + 592);
      unint64_t v6 = *((void *)v2 + 36);
      unint64_t v259 = v260;
LABEL_288:
      if (!v6) {
        goto LABEL_321;
      }
      unint64_t v5 = *((unsigned int *)v2 + 29);
      unint64_t v16 = v259 + 1;
      if (v259 + 1 <= v5) {
        goto LABEL_366;
      }
      unint64_t v16 = v5 + v6;
      if (__CFADD__(v5, v6)) {
        goto LABEL_367;
      }
      int v262 = (char *)*((void *)v2 + 38);
      if (v259 >= v16)
      {
        memmove((void *)(*(void *)(v299 + 600) + 8 * v5), *((const void **)v2 + 38), 8 * v6);
      }
      else
      {
        unint64_t v263 = *(void *)(v299 + 576);
        if (v263 < v16)
        {
          if (*(void *)(v299 + 568))
          {
            uint64_t v264 = 2 * v263;
            BOOL v100 = v263 == 0;
            unint64_t v265 = 8;
            if (!v100) {
              unint64_t v265 = v264;
            }
            if (v265 <= v16) {
              unint64_t v266 = v5 + v6;
            }
            else {
              unint64_t v266 = v265;
            }
            re::DynamicArray<float *>::setCapacity((void *)(v299 + 568), v266);
          }
          else
          {
            re::DynamicArray<float *>::setCapacity((void *)(v299 + 568), v5 + v6);
            ++*(_DWORD *)(v299 + 592);
          }
        }
        uint64_t v267 = *(void *)(v299 + 600);
        unint64_t v268 = *(void *)(v299 + 584) - v5;
        uint64_t v269 = &v262[8 * v268];
        if (v268)
        {
          memmove((void *)(v267 + 8 * v5), v262, 8 * v268);
          unint64_t v5 = *(void *)(v299 + 584);
          uint64_t v267 = *(void *)(v299 + 600);
        }
        memcpy((void *)(v267 + 8 * v5), v269, &v262[8 * v6] - v269);
        *(void *)(v299 + 584) = v16;
      }
      ++*(_DWORD *)(v299 + 592);
      goto LABEL_321;
    case 8u:
      LOBYTE(v302) = 0;
      int v8 = v2 + 104;
      int v99 = *((_DWORD *)v2 + 27) & 0xFFFFFF;
      if (v99)
      {
        re::TypeRegistry::typeInfo((void *)v299, *(void *)v8, buf);
        re::Optional<re::TypeInfo>::operator=(&v302, buf);
        if (!(_BYTE)v302) {
          goto LABEL_365;
        }
      }
      if (*((void *)v2 + 22)) {
        BOOL v100 = 0;
      }
      else {
        BOOL v100 = (v2[392] | v2[152]) == 0;
      }
      int v101 = v100;
      if (v99) {
        int v102 = *(unsigned char *)(v305 + 48) & 1;
      }
      else {
        int v102 = 1;
      }
      if ((v5 & v102 & v101) != 1) {
        goto LABEL_143;
      }
      uint64_t v115 = *((void *)v2 + 41);
      if (!v115) {
        goto LABEL_142;
      }
      unint64_t v4 = *((void *)v2 + 43);
      uint64_t v116 = 40 * v115;
      do
      {
        re::TypeRegistry::typeInfo((void *)v299, *(void *)v4, buf);
        if (!buf[0]) {
          goto LABEL_359;
        }
        if ((*(_DWORD *)(*((void *)&v316 + 1) + 48) & 1) == 0) {
          goto LABEL_143;
        }
        v4 += 40;
        v116 -= 40;
      }
      while (v116);
LABEL_142:
      *((_DWORD *)v2 + 20) |= 1u;
LABEL_143:
      if ((_BYTE)v302 && (*(unsigned char *)(v305 + 48) & 2) == 0 || v2[28] && !v2[29]) {
        goto LABEL_153;
      }
      uint64_t v117 = *((void *)v2 + 41);
      if (v117)
      {
        unint64_t v4 = *((void *)v2 + 43);
        uint64_t v118 = 40 * v117;
        while (1)
        {
          re::TypeRegistry::typeInfo((void *)v299, *(void *)v4, buf);
          if (!buf[0]) {
            break;
          }
          if ((*(_DWORD *)(*((void *)&v316 + 1) + 48) & 2) == 0) {
            goto LABEL_153;
          }
          v4 += 40;
          v118 -= 40;
          if (!v118) {
            goto LABEL_152;
          }
        }
LABEL_358:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid member type.", "memberType", "commitTo", 347);
        _os_crash();
        __break(1u);
LABEL_359:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid member type.", "memberType", "commitTo", 318);
        _os_crash();
        __break(1u);
LABEL_360:
        re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) New value of renamed enum constant (old name = \"%s\") is missing.", "found", "commitTo", 168, v55[2]);
        _os_crash();
        __break(1u);
LABEL_361:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Union tag type must be registered before the union type.", "tagType", "commitTo", 264);
        _os_crash();
        __break(1u);
LABEL_362:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Union tag type must be an enum type.", "tagType.value().isEnum()", "commitTo", 265);
        _os_crash();
        __break(1u);
LABEL_363:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Tagged unions don't support custom constructors.", "!sharedTypeInfo().constructor", "commitTo", 266);
        _os_crash();
        __break(1u);
LABEL_364:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Tagged unions don't support custom destructors.", "!sharedTypeInfo().destructor", "commitTo", 267);
        _os_crash();
        __break(1u);
LABEL_365:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid super class type.", "superClass", "commitTo", 305);
        _os_crash();
        __break(1u);
LABEL_366:
        uint64_t v300 = 0;
        long long v318 = 0u;
        long long v319 = 0u;
        long long v316 = 0u;
        long long v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v307 = 136315906;
        unsigned int v308 = "copy";
        __int16 v309 = 1024;
        int v310 = 643;
        __int16 v311 = 2048;
        unint64_t v312 = v5;
        __int16 v313 = 2048;
        unint64_t v314 = v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_367:
        re::internal::assertLog((re::internal *)7, v14, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v259, v5, v6);
        _os_crash();
        __break(1u);
        goto LABEL_368;
      }
LABEL_152:
      *((_DWORD *)v2 + 20) |= 2u;
LABEL_153:
      unint64_t v3 = v299;
      if (v2[152])
      {
        if ((_BYTE)v302)
        {
          re::TypeInfo::rootClass((re::TypeInfo *)&v303, (uint64_t)&v300);
          uint64_t v119 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(void *)v301);
          uint64_t v120 = *(unsigned int *)(v301 + 80);
          if (v120)
          {
            unsigned int v121 = *v119 & 0xFFFFFF;
            unint64_t v4 = *(void *)(v299 + 624);
            do
            {
              unint64_t v5 = v121;
              if (v4 <= v121) {
                goto LABEL_352;
              }
              unint64_t v3 = *(void *)(v3 + 640);
              if (*(unsigned char *)(v3 + 152 * v121 + 120) && *(void *)(v3 + 152 * v121 + 128) == *((void *)v2 + 20)) {
                goto LABEL_357;
              }
              ++v121;
              --v120;
              unint64_t v3 = v299;
            }
            while (v120);
          }
        }
      }
      if (v2[392])
      {
        *((_DWORD *)v2 + 42) = *(void *)(v3 + 664);
        re::DynamicArray<re::internal::ObjectMemberInfo>::add((_anonymous_namespace_ *)(v3 + 648), (uint64_t)(v2 + 400));
      }
      unsigned int v122 = *(_DWORD *)(v3 + 664);
      unint64_t v7 = *((void *)v2 + 41);
      *((_DWORD *)v2 + 29) = v122;
      *((_DWORD *)v2 + 3re::InputManager::notify(8, 0, 0, 0) = v7;
      if ((v2[80] & 0x10) == 0 && v7)
      {
        int v123 = 0;
        float64x2_t v124 = (unsigned int *)(*((void *)v2 + 43) + 32);
        uint64_t v125 = 40 * v7;
        while (1)
        {
          uint64_t v126 = *v124;
          if ((int)v126 <= v123) {
            break;
          }
          v124 += 10;
          int v123 = v126;
          v125 -= 40;
          if (!v125) {
            goto LABEL_168;
          }
        }
LABEL_351:
        re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Object member \"%s\" has invalid numeric tag %d. Tags need to be unique and greater than 1. Object members need to be sorted by tag.", "member.serializationTag > tag", "commitTo", 397, *((void *)v124 - 2), v126);
        _os_crash();
        __break(1u);
LABEL_352:
        uint64_t v306 = 0;
        long long v318 = 0u;
        long long v319 = 0u;
        long long v316 = 0u;
        long long v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v307 = 136315906;
        unsigned int v308 = "operator[]";
        __int16 v309 = 1024;
        int v310 = 789;
        __int16 v311 = 2048;
        unint64_t v312 = v5;
        __int16 v313 = 2048;
        unint64_t v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_353:
        uint64_t v300 = 0;
        long long v318 = 0u;
        long long v319 = 0u;
        long long v316 = 0u;
        long long v317 = 0u;
        *(_OWORD *)buf = 0u;
        uint64_t v2 = (unsigned __int8 *)&_os_log_internal;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v307 = 136315906;
        unsigned int v308 = "operator[]";
        __int16 v309 = 1024;
        int v310 = 789;
        __int16 v311 = 2048;
        unint64_t v312 = v16;
        __int16 v313 = 2048;
        unint64_t v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_354;
      }
LABEL_168:
      unint64_t v4 = v3 + 648;
      unint64_t v5 = *(void *)(v3 + 664);
      unint64_t v127 = v5 + v7;
      unint64_t v298 = v2 + 104;
      if (v5 >= v5 + v7)
      {
        if (v5 <= v5 + v7) {
          goto LABEL_179;
        }
        uint64_t v294 = (_anonymous_namespace_ *)(v3 + 648);
        unint64_t v129 = v3;
        uint64_t v133 = 40 * v127 + 8;
        unint64_t v134 = v5 + v7;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(void *)(v129 + 680) + v133));
          ++v134;
          v133 += 40;
        }
        while (v134 < *(void *)(v129 + 664));
      }
      else
      {
        unint64_t v128 = *(void *)(v3 + 664);
        if (*(void *)(v3 + 656) < v127)
        {
          re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity((void *)(v3 + 648), v5 + v7);
          unint64_t v128 = *(void *)(v3 + 664);
        }
        uint64_t v294 = (_anonymous_namespace_ *)(v3 + 648);
        unint64_t v129 = v3;
        if (v128 < v127)
        {
          unint64_t v130 = v5 + v7 - v128;
          uint64_t v131 = 40 * v128;
          do
          {
            uint64_t v132 = *(void *)(v129 + 680) + v131;
            *(void *)uint64_t v132 = 0xFFFFFFFFLL;
            re::StringID::invalid((re::StringID *)(v132 + 8));
            *(_DWORD *)(v132 + 24) = 0;
            *(unsigned char *)(v132 + 28) = 1;
            v131 += 40;
            *(_DWORD *)(v132 + 32) = 0;
            --v130;
          }
          while (v130);
        }
      }
      *(void *)(v129 + 664) = v127;
      ++*(_DWORD *)(v129 + 672);
      unsigned int v122 = *((_DWORD *)v2 + 29);
      unint64_t v7 = *((void *)v2 + 41);
      unint64_t v5 = v127;
      unint64_t v3 = v129;
      unint64_t v4 = (unint64_t)v294;
LABEL_179:
      if (v7)
      {
        int v8 = (unsigned __int8 *)v122;
        unint64_t v6 = v5 + 1;
        if (v5 + 1 <= v122)
        {
LABEL_368:
          uint64_t v300 = 0;
          long long v318 = 0u;
          long long v319 = 0u;
          long long v316 = 0u;
          long long v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v307 = 136315906;
          unsigned int v308 = "copy";
          __int16 v309 = 1024;
          int v310 = 643;
          __int16 v311 = 2048;
          unint64_t v312 = (unint64_t)v8;
          __int16 v313 = 2048;
          unint64_t v314 = v6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_369;
        }
        unint64_t v135 = v122 + v7;
        if (__CFADD__(v122, v7))
        {
LABEL_369:
          re::internal::assertLog((re::internal *)7, v135, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v5, v8, v7);
          _os_crash();
          __break(1u);
          goto LABEL_370;
        }
        uint64_t v136 = (unint64_t *)*((void *)v2 + 43);
        if (v5 >= v135)
        {
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(*((unint64_t **)v2 + 43), &v136[5 * v7], *(void *)(v3 + 680) + 40 * v122);
        }
        else
        {
          uint64_t v295 = (_anonymous_namespace_ *)(v122 + v7);
          re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity((void *)v4, v135);
          unint64_t v137 = v3;
          uint64_t v138 = *(void *)(v3 + 664);
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(v136, &v136[5 * (v138 - (void)v8)], *(void *)(v137 + 680) + 40 * v8);
          if (v138 - (void)v8 != v7)
          {
            uint64_t v139 = (uint64_t)v136 + 40 * v138 - 40 * v8 + 8;
            uint64_t v140 = (re::StringID *)(*(void *)(v299 + 680) + 40 * *(void *)(v299 + 664) + 8);
            do
            {
              *((void *)v140 - 1) = *(void *)(v139 - 8);
              uint64_t v141 = re::StringID::StringID(v140, (const StringID *)v139);
              uint64_t v142 = *(void *)(v139 + 16);
              *((_DWORD *)v141 + 6) = *(_DWORD *)(v139 + 24);
              *((void *)v141 + 2) = v142;
              uint64_t v143 = (unint64_t *)(v139 + 32);
              v139 += 40;
              uint64_t v140 = (re::StringID *)((char *)v141 + 40);
            }
            while (v143 != &v136[5 * v7]);
          }
          unint64_t v3 = v299;
          *(void *)(v299 + 664) = v295;
        }
        ++*(_DWORD *)(v3 + 672);
      }
      unint64_t v4 = v3 + 688;
      unsigned int v144 = *(_DWORD *)(v3 + 704);
      int v8 = (unsigned __int8 *)*((void *)v2 + 46);
      *((_DWORD *)v2 + 31) = v144;
      *((_DWORD *)v2 + 32) = v8;
      unint64_t v145 = v3;
      unint64_t v146 = *(void *)(v3 + 704);
      unint64_t v5 = (unint64_t)&v8[v146];
      unsigned int v296 = (_anonymous_namespace_ *)v4;
      if (v146 < (unint64_t)&v8[v146])
      {
        unint64_t v147 = v146;
        if (*(void *)(v145 + 696) < v5)
        {
          re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)v4, (unint64_t)&v8[v146]);
          unint64_t v147 = *(void *)(v299 + 704);
        }
        unint64_t v4 = v299;
        if (v147 < v5)
        {
          uint64_t v148 = &v8[v146 - v147];
          uint64_t v149 = 24 * v147;
          do
          {
            uint64_t v150 = (re::StringID *)(*(void *)(v299 + 720) + v149);
            re::StringID::invalid(v150);
            *((_DWORD *)v150 + 4) = 0;
            v149 += 24;
            --v148;
          }
          while (v148);
        }
LABEL_199:
        *(void *)(v4 + 704) = v5;
        ++*(_DWORD *)(v4 + 712);
        unsigned int v144 = *((_DWORD *)v2 + 31);
        int v8 = (unsigned __int8 *)*((void *)v2 + 46);
        unint64_t v3 = v4;
        if (!v8) {
          goto LABEL_211;
        }
        goto LABEL_202;
      }
      if (v146 > (unint64_t)&v8[v146])
      {
        uint64_t v151 = 24 * v5;
        unint64_t v152 = v5;
        unint64_t v4 = v299;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(void *)(v299 + 720) + v151));
          ++v152;
          v151 += 24;
        }
        while (v152 < *(void *)(v299 + 704));
        goto LABEL_199;
      }
      unint64_t v5 = v146;
      unint64_t v3 = v299;
      if (!v8) {
        goto LABEL_211;
      }
LABEL_202:
      unint64_t v6 = v144;
      unint64_t v7 = v5 + 1;
      if (v5 + 1 <= v144)
      {
LABEL_370:
        uint64_t v300 = 0;
        long long v318 = 0u;
        long long v319 = 0u;
        long long v316 = 0u;
        long long v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v307 = 136315906;
        unsigned int v308 = "copy";
        __int16 v309 = 1024;
        int v310 = 643;
        __int16 v311 = 2048;
        unint64_t v312 = v6;
        __int16 v313 = 2048;
        unint64_t v314 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_371;
      }
      unint64_t v153 = (unint64_t)&v8[v144];
      if (__CFADD__(v144, v8))
      {
LABEL_371:
        re::internal::assertLog((re::internal *)7, v153, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v5, v6, v8);
        _os_crash();
        __break(1u);
        goto LABEL_372;
      }
      unint64_t v154 = (unint64_t *)*((void *)v2 + 48);
      if (v5 >= v153)
      {
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(*((unint64_t **)v2 + 48), &v154[3 * (void)v8], *(void *)(v3 + 720) + 24 * v144);
      }
      else
      {
        uint64_t v155 = v296;
        __int16 v297 = (_anonymous_namespace_ *)&v8[v144];
        re::DynamicArray<re::AttributeArgument>::growCapacity(v155, v153);
        unint64_t v156 = v3;
        uint64_t v157 = *(void *)(v3 + 704);
        unint64_t v5 = v157 - v6;
        id v158 = &v154[3 * (v157 - v6)];
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(v154, v158, *(void *)(v156 + 720) + 24 * v6);
        if ((unsigned __int8 *)(v157 - v6) != v8)
        {
          uint64_t v159 = (re::StringID *)(*(void *)(v299 + 720) + 24 * *(void *)(v299 + 704));
          uint64_t v160 = 24 * (void)v8 + 24 * v6 - 24 * v157;
          do
          {
            uint64_t v161 = re::StringID::StringID(v159, (const StringID *)v158);
            *((_DWORD *)v161 + 4) = *((_DWORD *)v158 + 4);
            v158 += 3;
            uint64_t v159 = (re::StringID *)((char *)v161 + 24);
            v160 -= 24;
          }
          while (v160);
        }
        unint64_t v3 = v299;
        *(void *)(v299 + 704) = v297;
      }
      ++*(_DWORD *)(v3 + 712);
LABEL_211:
      if ((*((_DWORD *)v2 + 27) & 0xFFFFFF) != 0)
      {
        int v8 = v2 + 104;
        unint64_t v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *v298) & 0xFFFFFFLL;
        unint64_t v4 = *(void *)(v3 + 624);
        if (v4 <= v6)
        {
LABEL_372:
          uint64_t v300 = 0;
          long long v318 = 0u;
          long long v319 = 0u;
          long long v316 = 0u;
          long long v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v307 = 136315906;
          unsigned int v308 = "operator[]";
          __int16 v309 = 1024;
          int v310 = 789;
          __int16 v311 = 2048;
          unint64_t v312 = v6;
          __int16 v313 = 2048;
          unint64_t v314 = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_373;
        }
        unint64_t v5 = (*(_DWORD *)(*(void *)(v3 + 640) + 152 * v6 + 80) + v6);
        *(_DWORD *)unint64_t v16 = (*(_DWORD *)(*(void *)(v3 + 640) + 152 * v6 + 80) + v6) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
        unint64_t v7 = *(void *)(v3 + 624);
        unint64_t v16 = v7 + 1;
        if (v7 + 1 <= v5)
        {
LABEL_373:
          uint64_t v300 = 0;
          long long v318 = 0u;
          long long v319 = 0u;
          long long v316 = 0u;
          long long v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v307 = 136315906;
          unsigned int v308 = "insert";
          __int16 v309 = 1024;
          int v310 = 855;
          __int16 v311 = 2048;
          unint64_t v312 = v5;
          __int16 v313 = 2048;
          unint64_t v314 = v16;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_374:
          uint64_t v300 = 0;
          long long v318 = 0u;
          long long v319 = 0u;
          long long v316 = 0u;
          long long v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v307 = 136315906;
          unsigned int v308 = "operator[]";
          __int16 v309 = 1024;
          int v310 = 789;
          __int16 v311 = 2048;
          unint64_t v312 = v6;
          __int16 v313 = 2048;
          unint64_t v314 = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_375:
          re::internal::assertLog((re::internal *)4, v78, "assertion failure: '%s' (%s:line %i) Element type must be registered before the array type.", "elementType", "commitTo", 222);
          _os_crash();
          __break(1u);
        }
        if (v7 >= *(void *)(v3 + 616))
        {
          re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity((void *)(v3 + 608), v7 + 1);
          unint64_t v7 = *(void *)(v3 + 624);
        }
        uint64_t v162 = *(void *)(v3 + 640);
        uint64_t v163 = v162 + 152 * v7;
        if (v7 <= v5)
        {
          *(_OWORD *)uint64_t v163 = *v17;
          long long v195 = *((_OWORD *)v2 + 3);
          long long v196 = *((_OWORD *)v2 + 4);
          long long v197 = *((_OWORD *)v2 + 5);
          *(void *)(v163 + 64) = *((void *)v2 + 12);
          *(_OWORD *)(v163 + 32) = v196;
          *(_OWORD *)(v163 + 48) = v197;
          *(_OWORD *)(v163 + 16) = v195;
          uint64_t v198 = v162 + 152 * v7;
          long long v199 = *(_OWORD *)v298;
          *(_OWORD *)(v198 + 84) = *(_OWORD *)(v2 + 116);
          *(_OWORD *)(v198 + 72) = v199;
          re::StringID::StringID((re::StringID *)(v198 + 104), (const StringID *)(v2 + 136));
          int v200 = v2[152];
          *(unsigned char *)(v198 + 12re::InputManager::notify(8, 0, 0, 0) = v200;
          if (v200) {
            *(void *)(v162 + 152 * v7 + 128) = *((void *)v2 + 20);
          }
          unint64_t v201 = (_OWORD *)(v162 + 152 * v7 + 136);
          unint64_t v3 = v299;
        }
        else
        {
          uint64_t v164 = v162 + 152 * v7;
          long long v165 = *(_OWORD *)(v164 - 136);
          unint64_t v166 = v7 - 1;
          long long v167 = *(_OWORD *)(v164 - 104);
          *(_OWORD *)(v163 + 32) = *(_OWORD *)(v164 - 120);
          *(_OWORD *)(v163 + 48) = v167;
          *(void *)(v163 + 64) = *(void *)(v164 - 88);
          *(_OWORD *)uint64_t v163 = *(_OWORD *)(v164 - 152);
          *(_OWORD *)(v163 + 16) = v165;
          *(_OWORD *)(v164 + 72) = *(_OWORD *)(v164 - 80);
          *(_OWORD *)(v164 + 84) = *(_OWORD *)(v164 - 68);
          uint64_t v168 = *(void *)(v164 - 40);
          *(void *)(v164 + 104) = *(void *)(v164 - 48);
          *(void *)(v164 + 112) = v168;
          *(void *)(v164 - 48) = 0;
          *(void *)(v164 - 4re::InputManager::notify(8, 0, 0, 0) = "";
          int v169 = *(unsigned __int8 *)(v164 - 32);
          *(unsigned char *)(v164 + 12re::InputManager::notify(8, 0, 0, 0) = v169;
          if (v169) {
            *(void *)(v162 + 152 * v7 + 128) = *(void *)(v162 + 152 * v166 + 128);
          }
          *(_OWORD *)(v162 + 152 * v7 + 136) = *(_OWORD *)(v162 + 152 * v166 + 136);
          uint64_t v170 = *(void *)(v3 + 640);
          uint64_t v171 = *(void *)(v3 + 624);
          if (v170 + 152 * v171 - 152 != v170 + 152 * v5)
          {
            unint64_t v7 = 152 * v171;
            uint64_t v172 = 152 * v5 + 152;
            do
            {
              uint64_t v173 = v170 + v7;
              *(_OWORD *)(v173 - 104) = *(_OWORD *)(v170 + v7 - 256);
              long long v174 = *(_OWORD *)(v170 + v7 - 304);
              *(_OWORD *)(v173 - 136) = *(_OWORD *)(v170 + v7 - 288);
              *(_OWORD *)(v173 - 12re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(v170 + v7 - 272);
              *(_DWORD *)(v173 - 88) = *(_DWORD *)(v170 + v7 - 240);
              uint64_t v175 = *(void *)(v170 + v7 - 200);
              uint64_t v176 = *(void *)(v170 + v7 - 192);
              uint64_t v177 = *(void *)(v170 + v7 - 40);
              unint64_t v178 = v175 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v170 + v7 - 48) & 1;
              *(_OWORD *)(v173 - 152) = v174;
              *(_OWORD *)(v173 - 8re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(v170 + v7 - 232);
              *(_OWORD *)(v173 - 68) = *(_OWORD *)(v170 + v7 - 220);
              *(void *)(v173 - 20re::InputManager::notify(8, 0, 0, 0) = 0;
              *(void *)(v173 - re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = "";
              *(void *)(v173 - 4re::InputManager::notify(8, 0, 0, 0) = v176;
              *(void *)buf = v178;
              *(void *)&uint8_t buf[8] = v177;
              *(void *)(v173 - 48) = v175;
              re::StringID::destroyString((re::StringID *)buf);
              if (*(unsigned char *)(v170 + v7 - 32) || *(unsigned char *)(v170 + v7 - 184))
              {
                if (!*(unsigned char *)(v170 + v7 - 32) || *(unsigned char *)(v170 + v7 - 184))
                {
                  if (!*(unsigned char *)(v170 + v7 - 32) && *(unsigned char *)(v170 + v7 - 184)) {
                    *(unsigned char *)(v173 - 32) = 1;
                  }
                  *(void *)(v170 + v7 - 24) = *(void *)(v170 + v7 - 176);
                }
                else
                {
                  *(unsigned char *)(v173 - 32) = 0;
                }
              }
              *(_OWORD *)(v170 + v7 - 16) = *(_OWORD *)(v170 + v7 - 168);
              v170 -= 152;
              v172 += 152;
            }
            while (v7 != v172);
            uint64_t v170 = *(void *)(v3 + 640);
            int v8 = v2 + 104;
          }
          uint64_t v179 = v170 + 152 * v5;
          *(_OWORD *)uint64_t v179 = *v17;
          long long v180 = *((_OWORD *)v2 + 3);
          long long v181 = *((_OWORD *)v2 + 4);
          long long v182 = *((_OWORD *)v2 + 5);
          *(_DWORD *)(v179 + 64) = *((_DWORD *)v2 + 24);
          *(_OWORD *)(v179 + 32) = v181;
          *(_OWORD *)(v179 + 48) = v182;
          *(_OWORD *)(v179 + 16) = v180;
          long long v183 = *(_OWORD *)v8;
          *(_OWORD *)(v179 + 84) = *(_OWORD *)(v8 + 12);
          *(_OWORD *)(v179 + 72) = v183;
          re::StringID::operator=((unint64_t *)(v179 + 104), (uint64_t *)v2 + 17);
          int v186 = *(unsigned __int8 *)(v179 + 120);
          unsigned int v185 = (unsigned char *)(v179 + 120);
          int v184 = v186;
          if (v186 || v2[152])
          {
            if (!v184 || v2[152])
            {
              if (v184 || !v2[152])
              {
                *(void *)(v170 + 152 * v5 + 128) = *((void *)v2 + 20);
              }
              else
              {
                *unsigned int v185 = 1;
                *(void *)(v170 + 152 * v5 + 128) = *((void *)v2 + 20);
              }
            }
            else
            {
              *unsigned int v185 = 0;
            }
          }
          unint64_t v201 = (_OWORD *)(v170 + 152 * v5 + 136);
        }
        *unint64_t v201 = *(_OWORD *)(v2 + 168);
        unint64_t v4 = *(void *)(v3 + 624) + 1;
        *(void *)(v3 + 624) = v4;
        ++*(_DWORD *)(v3 + 632);
        unint64_t v16 = (v5 + 1);
        if (v16 < v4)
        {
          unint64_t v7 = v6;
          unint64_t v5 = v4;
          unint64_t v6 = 152 * v16;
          do
          {
            unint64_t v4 = *(void *)(v3 + 624);
            if (v4 <= v16) {
              goto LABEL_353;
            }
            uint64_t v270 = re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(void *)(*(void *)(v3 + 640) + v6));
            *(_DWORD *)uint64_t v270 = v16++ & 0xFFFFFF | (*(unsigned __int8 *)(v270 + 3) << 24);
            v6 += 152;
          }
          while (v16 < v5);
          unint64_t v4 = *(void *)(v3 + 624);
          unint64_t v6 = v7;
        }
        if (v4 <= v6) {
          goto LABEL_374;
        }
        uint64_t v271 = *(void *)(v3 + 640);
        uint64_t v272 = v271 + 152 * v6;
        int v273 = *(_DWORD *)(v272 + 76);
        ++*(_DWORD *)(v272 + 80);
        if ((v273 & 0xFFFFFF) == 0) {
          goto LABEL_321;
        }
        unint64_t v5 = 152;
        uint64_t v274 = v271 + 152 * v6;
        while (1)
        {
          unint64_t v16 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(void *)(v274 + 72)) & 0xFFFFFFLL;
          unint64_t v4 = *(void *)(v3 + 624);
          if (v4 <= v16) {
            break;
          }
          uint64_t v274 = *(void *)(v3 + 640) + 152 * v16;
          int v275 = *(_DWORD *)(v274 + 76);
          ++*(_DWORD *)(v274 + 80);
          if ((v275 & 0xFFFFFF) == 0) {
            goto LABEL_321;
          }
        }
        uint64_t v300 = 0;
        long long v318 = 0u;
        long long v319 = 0u;
        long long v316 = 0u;
        long long v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v307 = 136315906;
        unsigned int v308 = "operator[]";
        __int16 v309 = 1024;
        int v310 = 789;
        __int16 v311 = 2048;
        unint64_t v312 = v16;
        __int16 v313 = 2048;
        unint64_t v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_351;
      }
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v3 + 624) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v187 = *(void *)(v3 + 624);
      if (v187 >= *(void *)(v3 + 616))
      {
        re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity((void *)(v3 + 608), v187 + 1);
        unint64_t v187 = *(void *)(v3 + 624);
      }
      uint64_t v188 = *(void *)(v3 + 640);
      uint64_t v189 = v188 + 152 * v187;
      *(_OWORD *)uint64_t v189 = *v17;
      long long v190 = *((_OWORD *)v2 + 3);
      long long v191 = *((_OWORD *)v2 + 4);
      long long v192 = *((_OWORD *)v2 + 5);
      *(void *)(v189 + 64) = *((void *)v2 + 12);
      *(_OWORD *)(v189 + 32) = v191;
      *(_OWORD *)(v189 + 48) = v192;
      *(_OWORD *)(v189 + 16) = v190;
      long long v193 = *(_OWORD *)v298;
      *(_OWORD *)(v189 + 84) = *(_OWORD *)(v2 + 116);
      *(_OWORD *)(v189 + 72) = v193;
      re::StringID::StringID((re::StringID *)(v189 + 104), (const StringID *)(v2 + 136));
      int v194 = v2[152];
      *(unsigned char *)(v189 + 12re::InputManager::notify(8, 0, 0, 0) = v194;
      if (v194) {
        *(void *)(v188 + 152 * v187 + 128) = *((void *)v2 + 20);
      }
      *(_OWORD *)(v188 + 152 * v187 + 136) = *(_OWORD *)(v2 + 168);
      unint64_t v3 = v299;
      ++*(void *)(v299 + 624);
      ++*(_DWORD *)(v299 + 632);
LABEL_321:
      if (v2[28]) {
        *((_DWORD *)v2 + 2re::InputManager::notify(8, 0, 0, 0) = *((_DWORD *)v2 + 20) & 0xFFFFFFFD | (2 * v2[29]);
      }
      uint64_t v276 = *((unsigned int *)v2 + 118);
      if (v276)
      {
        uint64_t v277 = 0;
        uint64_t v278 = (int *)(*((void *)v2 + 57) + 8);
        while (1)
        {
          int v279 = *v278;
          v278 += 14;
          if (v279 < 0) {
            break;
          }
          if (v276 == ++v277)
          {
            LODWORD(v277) = *((_DWORD *)v2 + 118);
            break;
          }
        }
      }
      else
      {
        LODWORD(v277) = 0;
      }
      if (v276 != v277)
      {
        uint64_t v280 = v277;
        char v281 = (void *)(v3 + 768);
        do
        {
          uint64_t v282 = *((void *)v2 + 57) + 56 * v280;
          uint64_t v283 = *(void *)(v282 + 32);
          *(_OWORD *)buf = *(_OWORD *)(v282 + 16);
          *(void *)&uint8_t buf[8] = *((void *)v2 + 4);
          *(void *)&long long v316 = v283;
          unint64_t v284 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v302, (uint64_t)buf);
          unint64_t v285 = v284;
          if (*v281)
          {
            unint64_t v286 = v284 % *(unsigned int *)(v3 + 792);
            unint64_t v287 = v3;
            uint64_t v288 = *(unsigned int *)(*(void *)(v3 + 776) + 4 * v286);
            if (v288 != 0x7FFFFFFF)
            {
              uint64_t v289 = *(void *)(v287 + 784);
              while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v289 + 56 * v288 + 16), (uint64_t *)buf))
              {
                uint64_t v289 = *(void *)(v299 + 784);
                uint64_t v288 = *(_DWORD *)(v289 + 56 * v288 + 8) & 0x7FFFFFFF;
                if (v288 == 0x7FFFFFFF)
                {
                  unint64_t v3 = v299;
                  goto LABEL_339;
                }
              }
              goto LABEL_340;
            }
            unint64_t v3 = v287;
          }
          else
          {
            LODWORD(v286) = 0;
          }
LABEL_339:
          re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>((uint64_t)v281, v286, v285, (long long *)buf, (_OWORD *)(v282 + 40));
          ++*(_DWORD *)(v3 + 808);
LABEL_340:
          if (*((_DWORD *)v2 + 118) <= (v277 + 1)) {
            int v290 = v277 + 1;
          }
          else {
            int v290 = *((_DWORD *)v2 + 118);
          }
          unint64_t v3 = v299;
          while (1)
          {
            uint64_t v280 = (v277 + 1);
            if (v290 - 1 == v277) {
              break;
            }
            LODWORD(v277) = v277 + 1;
            int v291 = v280;
            if ((*(_DWORD *)(*((void *)v2 + 57) + 56 * v280 + 8) & 0x80000000) != 0) {
              goto LABEL_348;
            }
          }
          int v291 = v290;
LABEL_348:
          LODWORD(v277) = v291;
        }
        while (v276 != v291);
      }
      ++*(_DWORD *)(v3 + 24);
      re::TypeBuilder::reset((re::TypeBuilder *)v2, v14);
      return;
    case 9u:
      *(_DWORD *)unint64_t v16 = *(_DWORD *)(v299 + 744) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      unint64_t v103 = *(void *)(v299 + 744);
      unint64_t v104 = *(void *)(v299 + 736);
      if (v103 >= v104)
      {
        unint64_t v105 = v103 + 1;
        if (v104 < v103 + 1)
        {
          if (*(void *)(v299 + 728))
          {
            uint64_t v106 = 2 * v104;
            BOOL v100 = v104 == 0;
            unint64_t v107 = 8;
            if (!v100) {
              unint64_t v107 = v106;
            }
            if (v107 <= v105) {
              unint64_t v108 = v105;
            }
            else {
              unint64_t v108 = v107;
            }
            re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity((void *)(v299 + 728), v108);
          }
          else
          {
            re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity((void *)(v299 + 728), v105);
            ++*(_DWORD *)(v299 + 752);
          }
        }
        unint64_t v103 = *(void *)(v299 + 744);
      }
      uint64_t v226 = *(void *)(v299 + 760) + 104 * v103;
      long long v227 = *v17;
      long long v228 = *((_OWORD *)v2 + 4);
      *(_OWORD *)(v226 + 16) = *((_OWORD *)v2 + 3);
      *(_OWORD *)(v226 + 32) = v228;
      *(_OWORD *)uint64_t v226 = v227;
      long long v229 = *((_OWORD *)v2 + 5);
      long long v230 = *((_OWORD *)v2 + 6);
      long long v231 = *((_OWORD *)v2 + 7);
      *(void *)(v226 + 96) = *((void *)v2 + 16);
      *(_OWORD *)(v226 + 64) = v230;
      *(_OWORD *)(v226 + 8re::InputManager::notify(8, 0, 0, 0) = v231;
      *(_OWORD *)(v226 + 48) = v229;
      ++*(void *)(v299 + 744);
      ++*(_DWORD *)(v299 + 752);
      goto LABEL_321;
    default:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Unknown type category.", "!\"Unreachable code\"", "commitTo", 466);
      _os_crash();
      __break(1u);
      goto LABEL_377;
  }
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 4 * (unsigned __int16)a2;
}

unint64_t *re::DynamicArray<re::EnumConstant>::copy(unint64_t *this, unint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unint64_t v6 = this;
  unint64_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "copy";
    WORD6(v15) = 1024;
    HIWORD(v15) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v14, v15);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_13;
  }
  if (v7 >= v8)
  {
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,0>(a3, &a3[3 * a4], this[4] + 24 * a2);
  }
  else
  {
    re::DynamicArray<re::EnumConstant>::growCapacity(this, a2 + a4);
    unint64_t v10 = v6[2];
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,0>(a3, &a3[3 * (v10 - a2)], v6[4] + 24 * a2);
    if (v10 - a2 != v4)
    {
      uint64_t v11 = 24 * v4 + 24 * a2 - 24 * v10;
      uint64_t v12 = (const StringID *)((char *)a3 + 24 * v10 - 24 * a2 + 8);
      this = (unint64_t *)(v6[4] + 24 * v6[2] + 8);
      do
      {
        *(this - 1) = (unint64_t)v12[-1].var1;
        uint64_t v13 = re::StringID::StringID((re::StringID *)this, v12);
        uint64_t v12 = (const StringID *)((char *)v12 + 24);
        this = (unint64_t *)((char *)v13 + 24);
        v11 -= 24;
      }
      while (v11);
    }
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

re::StringID *re::DynamicArray<re::internal::ObjectMemberInfo>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 40 * v4;
  *(void *)uint64_t v5 = *(void *)a2;
  uint64_t result = re::StringID::StringID((re::StringID *)(v5 + 8), (const StringID *)(a2 + 8));
  uint64_t v7 = *(void *)(a2 + 24);
  *(_DWORD *)(v5 + 32) = *(_DWORD *)(a2 + 32);
  *(void *)(v5 + 24) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::TypeBuilder::setSharedInfo(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, int a5, unint64_t a6, unint64_t a7)
{
  int v8 = a6;
  if (HIDWORD(a6))
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Size (%zu) exceeds limit.", "size <= std::numeric_limits<uint32_t>::max()", "setSharedInfo", 497, a6);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v7 = a7;
    if (!HIDWORD(a7))
    {
      *(unsigned char *)a1 = a2;
      uint64_t result = (uint64_t)re::StringID::operator=((unint64_t *)(a1 + 8), a3);
      *(_DWORD *)(a1 + 24) = a4;
      *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
      *(_DWORD *)(a1 + 44) = v7;
      *(void *)(a1 + 72) = 0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
      *(_DWORD *)(a1 + 96) = a5;
      return result;
    }
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Alignment (%zu) exceeds limit.", "alignment <= std::numeric_limits<uint32_t>::max()", "setSharedInfo", 498, v7);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilder::setConstructor(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)result)
  {
    *(void *)(result + 48) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setConstructor", 514);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setDestructor(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)result)
  {
    *(void *)(result + 56) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setDestructor", 522);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setRetain(uint64_t this, void (*a2)(void *))
{
  if (*(unsigned char *)this)
  {
    *(void *)(this + 64) = a2;
    if (a2) {
      *(_DWORD *)(this + 80) |= 0x200u;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setRetain", 530);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setRelease(uint64_t this, void (*a2)(void *))
{
  if (*(unsigned char *)this)
  {
    *(void *)(this + 72) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setRelease", 540);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

unsigned char *re::TypeBuilder::setHasKnownSize(unsigned char *this, uint64_t a2)
{
  if (*this)
  {
    if (!this[28]) {
      this[28] = 1;
    }
    this[29] = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setHasKnownSize", 548);
    this = (unsigned char *)_os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setIsIncomplete(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this)
  {
    if (a2) {
      int v2 = 16;
    }
    else {
      int v2 = 0;
    }
    *(_DWORD *)(this + 8re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(this + 80) & 0xFFFFFFEF | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setIsIncomplete", 555);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setPreviousVersion(unsigned __int8 *a1, uint64_t *a2)
{
  if (!*a1)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setPreviousVersion", 562);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = *a2;
  if (!*a2)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "previousTypeID.isValid()", "setPreviousVersion", 563);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  int v2 = *a1;
  if (v2 != *(unsigned __int8 *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(v4 + 32, a2[1]) + 3))
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Previous version needs to be of the same type category.", "m_category == registry->typeCategory(previousTypeID)", "setPreviousVersion", 567);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (*a2)
  {
    unsigned int v7 = *((_DWORD *)a1 + 6);
    uint64_t result = re::DataArray<re::TextureAtlasTile>::tryGet(v4 + 96, a2[1]);
    if (result)
    {
      if (v7 > *(_DWORD *)(result + 16))
      {
        *((void *)a1 + 11) = a2[1];
        return result;
      }
    }
  }
LABEL_11:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) New version number needs to be greater than previous version number.", "m_version > registry->typeVersion(previousTypeID)", "setPreviousVersion", 568);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilder::setVersion(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this)
  {
    *(_DWORD *)(this + 24) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setVersion", 580);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setIsCallbackSerializer(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this)
  {
    if (a2) {
      int v2 = 256;
    }
    else {
      int v2 = 0;
    }
    *(_DWORD *)(this + 8re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(this + 80) & 0xFFFFFEFF | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setIsCallbackSerializer", 587);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginEnumType(uint64_t a1, uint64_t *a2, int a3, int a4, uint64_t a5)
{
  re::TypeRegistry::typeInfo(*(re **)a5, (re **)a5, v12);
  if (v12[0])
  {
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(void *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(_DWORD *)(a1 + 104) = -1;
    *(void *)(a1 + 116) = 0;
    *(void *)(a1 + 108) = 0;
    uint64_t result = re::TypeBuilder::setSharedInfo(a1, 2, a2, a3, a4, *(unsigned int *)(v13 + 8), *(unsigned int *)(v13 + 12));
    *(void *)(a1 + 104) = *(void *)(a5 + 8);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "underlyingTypeInfo", "beginEnumType", 614);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TypeBuilder::addEnumConstant(re::TypeBuilder *this, uint64_t a2, StringID *a3)
{
  if (*(unsigned char *)this == 2)
  {
    unint64_t v3 = (void *)((char *)this + 192);
    uint64_t v4 = a2;
    re::StringID::StringID((re::StringID *)v5, a3);
    re::DynamicArray<re::EnumConstant>::add(v3, &v4);
    re::StringID::destroyString((re::StringID *)v5);
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginEnumType() needs to be called before addEnumConstant().", "isBuilding()", "addEnumConstant", 625);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kEnum", "addEnumConstant", 626);
    _os_crash();
    __break(1u);
  }
}

void *re::DynamicArray<re::EnumConstant>::add(void *this, void *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::EnumConstant>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = (void *)(v3[4] + 24 * v4);
  *uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  v5[1] = v5[1] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  v5[1] = a2[1] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  void v5[2] = a2[2];
  a2[1] = 0;
  a2[2] = "";
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::TypeBuilder::addEnumConstantRenaming(re::TypeBuilder *this, uint64_t a2, StringID *a3)
{
  if (*(unsigned char *)this == 2)
  {
    unint64_t v3 = (void *)((char *)this + 232);
    uint64_t v4 = a2;
    re::StringID::StringID((re::StringID *)v5, a3);
    re::DynamicArray<re::EnumConstant>::add(v3, &v4);
    re::StringID::destroyString((re::StringID *)v5);
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginEnumType() needs to be called before addEnumConstantRenaming().", "isBuilding()", "addEnumConstantRenaming", 633);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kEnum", "addEnumConstantRenaming", 634);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::TypeBuilder::beginOptionalType(uint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, long long *a5)
{
  int v10 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_DWORD *)(a1 + 104) = -1;
  *(void *)(a1 + 116) = 0;
  *(void *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  long long v13 = *a5;
  re::TypeRegistry::typeInfo((re *)v13, (re **)&v13, v14);
  if (v14[0]) {
    int v10 = *(_DWORD *)(v15 + 64);
  }
  uint64_t result = re::TypeBuilder::setSharedInfo(a1, 3, a2, 1, v10, a3, a4);
  uint64_t v12 = *((void *)a5 + 1);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 104) = v12;
  return result;
}

uint64_t re::TypeBuilder::setOptionalAccessors(uint64_t this, void *(*a2)(void *), void (*a3)(void *, const void *))
{
  if (*(unsigned char *)this == 3)
  {
    *(void *)(this + 112) = a2;
    *(void *)(this + 12re::InputManager::notify(8, 0, 0, 0) = a3;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) beginOptionalType() needs to be called before setOptionalAccessors().", "isBuilding()", "setOptionalAccessors", 657);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kOptional", "setOptionalAccessors", 658);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginArrayType(uint64_t a1, uint64_t *a2, re **a3, unint64_t a4)
{
  if (a4 >= 0x7FFFFFFF)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array size. Value: %zu, max: %d", "length < std::numeric_limits<int32_t>::max()", "beginArrayType", 674, a4, 0x7FFFFFFFLL);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::TypeRegistry::typeInfo(*a3, a3, v14);
  if (!v14[0])
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "elementTypeInfo", "beginArrayType", 678);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  int v9 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(void *)&long long v10 = 0xFFFFFFFFLL;
  *((void *)&v10 + 1) = 0xFFFFFFFFLL;
  *(_OWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  long long v13 = *(_OWORD *)a3;
  re::TypeRegistry::typeInfo((re *)v13, (re **)&v13, v16);
  if (v16[0]) {
    int v9 = *(_DWORD *)(v17 + 64);
  }
  unint64_t v11 = re::internal::checkedArraySize(*(unsigned int *)(v15 + 8), a4);
  uint64_t result = re::TypeBuilder::setSharedInfo(a1, 4, a2, 1, v9, v11, *(unsigned int *)(v15 + 12));
  *(_DWORD *)(a1 + 80) |= 8u;
  *(void *)(a1 + 104) = a3[1];
  *(void *)(a1 + 112) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = a4;
  return result;
}

uint64_t re::TypeBuilder::beginArrayType(uint64_t a1, uint64_t *a2, re **a3, uint64_t a4, int a5)
{
  re::TypeRegistry::typeInfo(*a3, a3, v15);
  if (v15[0])
  {
    int v11 = -1;
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(void *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(void *)&long long v12 = 0xFFFFFFFFLL;
    *((void *)&v12 + 1) = 0xFFFFFFFFLL;
    *(_OWORD *)(a1 + 104) = v12;
    *(_DWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
    long long v14 = *(_OWORD *)a3;
    re::TypeRegistry::typeInfo((re *)v14, (re **)&v14, v17);
    if (v17[0]) {
      int v11 = *(_DWORD *)(v18 + 64);
    }
    uint64_t result = re::TypeBuilder::setSharedInfo(a1, 4, a2, 1, v11, 8uLL, *(unsigned int *)(v16 + 12));
    *(_DWORD *)(a1 + 80) |= 8u;
    *(void *)(a1 + 104) = a3[1];
    *(void *)(a1 + 112) = *(void *)(a4 + 8);
    *(_DWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = a5;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "elementTypeInfo", "beginArrayType", 697);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::TypeBuilder::beginListType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, long long *a6)
{
  long long v14 = *a6;
  re::TypeRegistry::typeInfo((re *)v14, (re **)&v14, v15);
  if (v15[0]) {
    int v12 = *(_DWORD *)(v16 + 64);
  }
  else {
    int v12 = -1;
  }
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_DWORD *)(a1 + 104) = -1;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 14re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_DWORD *)(a1 + 156) = 0;
  re::TypeBuilder::setSharedInfo(a1, 5, a2, a3, v12, a4, a5);
  *(void *)(a1 + 104) = *((void *)a6 + 1);
  double result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  return result;
}

uint64_t re::TypeBuilder::setListUsesContiguousStorage(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this == 5)
  {
    if (a2) {
      int v2 = 8;
    }
    else {
      int v2 = 0;
    }
    *(_DWORD *)(this + 8re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(this + 80) & 0xFFFFFFF7 | v2;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListAccessors().", "isBuilding()", "setListUsesContiguousStorage", 739);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListUsesContiguousStorage", 740);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setListAccessors(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)result == 5)
  {
    *(void *)(result + 112) = a2;
    *(void *)(result + 12re::InputManager::notify(8, 0, 0, 0) = a3;
  }
  else
  {
    if (!*(unsigned char *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListAccessors().", "isBuilding()", "setListAccessors", 747);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListAccessors", 748);
    double result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setListIndexer(uint64_t this, void *(*a2)(void *, unint64_t))
{
  if (*(unsigned char *)this == 5)
  {
    *(void *)(this + 128) = a2;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListIndexer().", "isBuilding()", "setListIndexer", 758);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListIndexer", 759);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setListIterator(uint64_t this, void *(*a2)(void *, re::Allocator *), void *(*a3)(void *), void (*a4)(void *, re::Allocator *))
{
  if (*(unsigned char *)this == 5)
  {
    *(void *)(this + 136) = a2;
    *(void *)(this + 144) = a3;
    *(void *)(this + 152) = a4;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListIterator().", "isBuilding()", "setListIterator", 769);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListIterator", 770);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginDictionaryType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, long long *a6, long long *a7)
{
  long long v19 = *a6;
  re::TypeRegistry::typeInfo((re *)v19, (re **)&v19, v20);
  if (v20[0]) {
    unsigned int v14 = *(_DWORD *)(v21 + 64);
  }
  else {
    unsigned int v14 = -1;
  }
  long long v18 = *a7;
  re::TypeRegistry::typeInfo((re *)v18, (re **)&v18, v20);
  if (v20[0]) {
    unsigned int v15 = *(_DWORD *)(v21 + 64);
  }
  else {
    unsigned int v15 = -1;
  }
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(void *)(a1 + 104) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 112) = -1;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 148) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  if (v14 <= v15) {
    int v16 = v15;
  }
  else {
    int v16 = v14;
  }
  *(_OWORD *)(a1 + 176) = 0uLL;
  uint64_t result = re::TypeBuilder::setSharedInfo(a1, 6, a2, a3, v16, a4, a5);
  *(void *)(a1 + 104) = *((void *)a6 + 1);
  *(void *)(a1 + 112) = *((void *)a7 + 1);
  return result;
}

uint64_t re::TypeBuilder::setDictionaryAccessors(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)result == 6)
  {
    *(void *)(result + 12re::InputManager::notify(8, 0, 0, 0) = a2;
    *(void *)(result + 128) = a3;
    *(void *)(result + 136) = a4;
    *(void *)(result + 184) = a5;
  }
  else
  {
    if (!*(unsigned char *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginDictionaryType() needs to be called before setDictionaryAccessors().", "isBuilding()", "setDictionaryAccessors", 803);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kDictionary", "setDictionaryAccessors", 804);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setDictionaryIterator(uint64_t this, void *(*a2)(void *, re::Allocator *), BOOL (*a3)(void *), const void *(*a4)(void *), void *(*a5)(void *), void (*a6)(void *, re::Allocator *))
{
  if (*(unsigned char *)this == 6)
  {
    *(void *)(this + 144) = a2;
    *(void *)(this + 152) = a3;
    *(void *)(this + 16re::InputManager::notify(8, 0, 0, 0) = a4;
    *(void *)(this + 168) = a5;
    *(void *)(this + 176) = a6;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, a5, a6, "assertion failure: '%s' (%s:line %i) beginDictionaryType() needs to be called before setDictionaryAccessors().", "isBuilding()", "setDictionaryIterator", 820);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, a5, a6, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kDictionary", "setDictionaryIterator", 821);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginObjectType(uint64_t a1, uint64_t *a2, int a3, int a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (*(void *)a7 && (re::TypeRegistry::typeInfo(*(re **)a7, (re **)a7, v17), !v17[0]))
  {
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Super class type is missing in type registry. Super classes need to be registered before their sub-classes.", "typeRegistry->typeInfo(superClass)", "beginObjectType", 867);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v15 = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(void *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    re::StringID::invalid((re::StringID *)(a1 + 136));
    *(unsigned char *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 168) = -1;
    *(void *)(a1 + 176) = 0;
    uint64_t result = re::TypeBuilder::setSharedInfo(a1, 8, a2, a3, a4, a5, a6);
    if (*(void *)a7) {
      uint64_t v15 = *(void *)(a7 + 8);
    }
    *(void *)(a1 + 104) = v15;
    *(_DWORD *)(a1 + 112) = 1;
  }
  return result;
}

uint64_t re::TypeBuilder::setObjectSuperClass(uint64_t result, void *a2)
{
  if (*(unsigned char *)result == 8)
  {
    if (*a2) {
      uint64_t v2 = a2[1];
    }
    else {
      uint64_t v2 = 0xFFFFFFFFLL;
    }
    *(void *)(result + 104) = v2;
  }
  else
  {
    if (!*(unsigned char *)result)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addObjectMember().", "isBuilding()", "setObjectSuperClass", 878);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "setObjectSuperClass", 879);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::addObjectMember(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  if (*(unsigned char *)a1 == 8)
  {
    int v8 = a2;
    uint64_t v13 = 0xFFFFFFFFLL;
    re::StringID::invalid((re::StringID *)v14);
    int v15 = 0;
    char v16 = 1;
    int v17 = 0;
    uint64_t v13 = *(void *)(a3 + 8);
    re::StringID::operator=(v14, a4);
    int v15 = a5;
    char v16 = 1;
    int v17 = v8;
    uint64_t v10 = (_anonymous_namespace_ *)(a1 + 312);
    uint64_t v11 = *(unsigned int *)(a1 + 328);
    re::DynamicArray<re::internal::ObjectMemberInfo>::add(v10, (uint64_t)&v13);
    re::StringID::destroyString((re::StringID *)v14);
    return v11;
  }
  else
  {
    if (!*(unsigned char *)a1)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addObjectMember().", "isBuilding()", "addObjectMember", 887);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMember", 888);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TypeBuilder::addObjectMemberRenaming(re::TypeBuilder *this, const re::StringID *a2, const re::StringID *a3)
{
  if (*(unsigned char *)this != 8)
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberRenaming", 911);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberRenaming", 912);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) No type member found with name \"%s\". Type members need to be defined before calls addObjectMemberRenaming().", "(size_t)index < m_objectMembers.size()", "addObjectMemberRenaming", 925, *((void *)v3 + 1));
    _os_crash();
    __break(1u);
    return;
  }
  unint64_t v3 = a2;
  unint64_t v5 = *((void *)this + 41);
  if (!v5) {
    goto LABEL_15;
  }
  unint64_t v7 = 0;
  int v8 = 0;
  uint64_t v9 = *((void *)this + 43);
  while (!re::StringID::operator==((void *)(v9 + 40 * v7 + 8), v3))
  {
    unint64_t v7 = (v8 + 1);
    int v8 = (const re::StringID *)v7;
    a2 = (const re::StringID *)v7;
    if (v5 <= v7) {
      goto LABEL_8;
    }
  }
  a2 = v8;
LABEL_8:
  if (v5 <= v7) {
    goto LABEL_15;
  }
  re::TypeBuilder::addObjectMemberRenaming(this, (uint64_t)a2, a3);
}

void re::TypeBuilder::addObjectMemberRenaming(re::TypeBuilder *this, uint64_t a2, const re::StringID *a3)
{
  if (*(unsigned char *)this == 8)
  {
    uint64_t v3 = a2;
    if (*((void *)this + 41) > (unint64_t)a2)
    {
      re::StringID::invalid((re::StringID *)&v6);
      int v7 = v3;
      re::StringID::operator=((unint64_t *)&v6, (uint64_t *)a3);
      re::DynamicArray<re::RenamedObjectMember>::add((re::TypeBuilder *)((char *)this + 352), &v6);
      re::StringID::destroyString((re::StringID *)&v6);
      return;
    }
    goto LABEL_6;
  }
  if (!*(unsigned char *)this)
  {
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberRenaming", 932);
    _os_crash();
    __break(1u);
LABEL_6:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid index %d. Type members need to be defined before calling addObjectMemberRenaming().", "memberIndex < m_objectMembers.size()", "addObjectMemberRenaming", 936, v3);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberRenaming", 933);
  _os_crash();
  __break(1u);
}

re::StringID *re::DynamicArray<re::RenamedObjectMember>::add(_anonymous_namespace_ *this, StringID *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::AttributeArgument>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t result = re::StringID::StringID((re::StringID *)(*((void *)this + 4) + 24 * v4), a2);
  *((_DWORD *)result + 4) = a2[1].var0;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::TypeBuilder::addCustomClassID(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this == 8)
  {
    if (!*(unsigned char *)(this + 152)) {
      *(unsigned char *)(this + 152) = 1;
    }
    *(void *)(this + 16re::InputManager::notify(8, 0, 0, 0) = a2;
  }
  else
  {
    if (!*(unsigned char *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addCustomClassID().", "isBuilding()", "addCustomClassID", 961);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addCustomClassID", 962);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

void re::TypeBuilder::addObjectMemberCustomClassID(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  if (*(unsigned char *)a1 != 8)
  {
    if (*(unsigned char *)a1)
    {
LABEL_13:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberCustomClassID", 970);
      _os_crash();
      __break(1u);
      return;
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberCustomClassID", 969);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if ((*(_DWORD *)(a1 + 108) & 0xFFFFFF) != 0)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) addObjectMemberCustomClassID() can only be added to root class.", "m_objectTypeInfo.superClass.isNull()", "addObjectMemberCustomClassID", 974);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  unint64_t v4 = (re::TypeInfo *)v20;
  re::TypeRegistry::typeInfo(*(re **)a2, (re **)a2, v20);
  if (!v20[0])
  {
LABEL_11:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "memberTypeInfo", "addObjectMemberCustomClassID", 978);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  unint64_t v4 = (re::TypeInfo *)v21;
  if ((re::TypeInfo::isInteger((re::TypeInfo *)v21) & 1) == 0)
  {
LABEL_12:
    re::TypeInfo::name(v4);
    uint64_t v10 = re::TypeInfo::name(v4);
    re::internal::assertLog((re::internal *)5, v11, "assertion failure: '%s' (%s:line %i) Custom class identifier expected to be basic or enum type. Type: %s", "memberTypeInfo.value().isInteger()", "addObjectMemberCustomClassID", 981, v10[1]);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v16 = 0xFFFFFFFFLL;
  re::StringID::invalid((re::StringID *)&v17);
  LODWORD(v18) = 0;
  BYTE4(v18) = 1;
  int v19 = 0;
  uint64_t v16 = *(void *)(a2 + 8);
  re::StringID::operator=((unint64_t *)&v17, a3);
  LODWORD(v18) = a4;
  BYTE4(v18) = 1;
  int v19 = -1;
  v12[0] = 1;
  uint64_t v13 = v16;
  re::StringID::StringID((re::StringID *)v14, &v17);
  unint64_t v14[2] = v18;
  int v15 = v19;
  re::Optional<re::internal::ObjectMemberInfo>::operator=(a1 + 392, v12);
  if (v12[0]) {
    re::StringID::destroyString((re::StringID *)v14);
  }
  re::StringID::destroyString((re::StringID *)&v17);
}

uint64_t re::TypeBuilder::setHideObjectWithOneMember(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)this)
  {
    if (a2) {
      int v2 = 4;
    }
    else {
      int v2 = 0;
    }
    *(_DWORD *)(this + 8re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(this + 80) & 0xFFFFFFFB | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before calling this function.", "isBuilding()", "setHideObjectWithOneMember", 1007);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginPointerType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, uint64_t a6, char a7)
{
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(void *)(a1 + 104) = 0xFFFFFFFFLL;
  *(unsigned char *)(a1 + 112) = 1;
  *(void *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 128) = 0;
  uint64_t result = re::TypeBuilder::setSharedInfo(a1, 9, a2, a3, -1, a4, a5);
  *(void *)(a1 + 104) = *(void *)(a6 + 8);
  *(unsigned char *)(a1 + 112) = a7;
  return result;
}

uint64_t re::TypeBuilder::addCustomClassIDForPointer(uint64_t result, uint64_t a2, int a3)
{
  if (*(unsigned char *)result == 9)
  {
    *(void *)(result + 12re::InputManager::notify(8, 0, 0, 0) = *(void *)(a2 + 8);
    *(_DWORD *)(result + 128) = a3;
  }
  else
  {
    if (!*(unsigned char *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginPointerType() needs to be called before setGetActualTypeFunction().", "isBuilding()", "addCustomClassIDForPointer", 1030);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kPointer", "addCustomClassIDForPointer", 1031);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::addAttribute(unsigned char *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (*a1)
  {
    *(void *)&long long v12 = *(void *)(a2 + 8);
    *((void *)&v12 + 1) = 0xFFFFFFFFLL;
    int v13 = a4;
    uint64_t v7 = (uint64_t)(a1 + 440);
    BOOL v8 = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::containsKey((uint64_t)(a1 + 440), (uint64_t *)&v12);
    if (v8)
    {
      uint64_t v9 = *re::foundationIntrospectionLogObjects((re *)v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_DEFAULT, "Same attribute type added multiple times to type. Previous attributes will be overwritten. Only the last attribute will be kept.", buf, 2u);
      }
    }
    *(void *)buf = a3;
    *(_DWORD *)&uint8_t buf[8] = a5;
    return re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(v7, &v12, buf);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling addAttribute.", "isBuilding()", "addAttribute", 1043);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

BOOL re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v9, (uint64_t)a2);
  uint64_t v5 = 0x7FFFFFFFLL;
  if (*(void *)a1)
  {
    uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      uint64_t v5 = 0x7FFFFFFFLL;
      while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v7 + 56 * v6 + 16), a2))
      {
        uint64_t v7 = *(void *)(a1 + 16);
        uint64_t v6 = *(_DWORD *)(v7 + 56 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF) {
          return v5 != 0x7FFFFFFF;
        }
      }
      uint64_t v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(uint64_t a1, long long *a2, _OWORD *a3)
{
  unint64_t v6 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v15, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 16) + 56 * v12;
    return v13 + 40;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    BOOL v11 = re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v10 + 56 * v9 + 16), (uint64_t *)a2);
    uint64_t v10 = *(void *)(a1 + 16);
    if (v11) {
      break;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  *(_OWORD *)(v10 + 56 * v9 + 4re::InputManager::notify(8, 0, 0, 0) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 16) + 56 * v9;
  return v13 + 40;
}

void *re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unint64_t v8 = (void *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[5 * v9];
        BOOL v11 = v7;
        do
        {
          void *v11 = *v8;
          uint64_t v13 = v8[1];
          unsigned int v12 = v8 + 1;
          v11[1] = v11[1] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[1] = *v12 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[2] = v12[1];
          void *v12 = 0;
          v12[1] = "";
          uint64_t v14 = v12[2];
          *((_DWORD *)v11 + 8) = *((_DWORD *)v12 + 6);
          v11[3] = v14;
          re::StringID::destroyString((re::StringID *)v12);
          unint64_t v8 = v12 + 4;
          v11 += 5;
        }
        while (v8 != v10);
        unint64_t v8 = (void *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x60uLL))
        {
          uint64_t v2 = 96 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 96 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::EnumConstant>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 57)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 128, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 7;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 7, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], v5[2] << 7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

unint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    unint64_t v4 = result;
    uint64_t result = (unint64_t *)(a3 + 8);
    uint64_t v5 = v4 + 1;
    do
    {
      *(result - 1) = *(v5 - 1);
      BOOL v6 = re::StringID::operator=(result, (uint64_t *)v5);
      unint64_t v7 = v5[2];
      *((_DWORD *)v6 + 6) = *((_DWORD *)v5 + 6);
      v6[2] = v7;
      uint64_t result = v6 + 5;
      unint64_t v8 = v5 + 4;
      v5 += 5;
    }
    while (v8 != a2);
  }
  return result;
}

unint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      uint64_t result = re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      *(_DWORD *)(a3 + 16) = *((_DWORD *)v5 + 4);
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return result;
}

void *re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x98uLL))
        {
          uint64_t v2 = 152 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 152 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 152, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 152 * v9;
        BOOL v11 = v7 + 16;
        uint64_t v12 = v8 + 128;
        do
        {
          *((_OWORD *)v11 - 8) = *(_OWORD *)(v12 - 128);
          long long v13 = *(_OWORD *)(v12 - 112);
          long long v14 = *(_OWORD *)(v12 - 96);
          long long v15 = *(_OWORD *)(v12 - 80);
          *(v11 - 8) = *(void *)(v12 - 64);
          *((_OWORD *)v11 - 6) = v14;
          *((_OWORD *)v11 - 5) = v15;
          *((_OWORD *)v11 - 7) = v13;
          long long v16 = *(_OWORD *)(v12 - 56);
          *(_OWORD *)((char *)v11 - 44) = *(_OWORD *)(v12 - 44);
          *(_OWORD *)(v11 - 7) = v16;
          uint64_t v17 = *(void *)(v12 - 24);
          *(v11 - 3) = *(v11 - 3) & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
          *(v11 - 3) = *(void *)(v12 - 24) & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
          *(v11 - 2) = *(void *)(v12 - 16);
          *(void *)(v12 - 24) = 0;
          *(void *)(v12 - 16) = "";
          LODWORD(v17) = *(unsigned __int8 *)(v12 - 8);
          *((unsigned char *)v11 - 8) = v17;
          if (v17) {
            void *v11 = *(void *)v12;
          }
          uint64_t v18 = v12 - 128;
          *(_OWORD *)(v11 + 1) = *(_OWORD *)(v12 + 8);
          re::StringID::destroyString((re::StringID *)(v12 - 24));
          v11 += 19;
          v12 += 152;
        }
        while (v18 + 152 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x68uLL))
        {
          uint64_t v2 = 104 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 104 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 104 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(uint64_t a1, unsigned int a2, unint64_t a3, long long *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v9) = a3;
  uint64_t v13 = *(void *)(a1 + 16) + 56 * v9;
  long long v14 = *a4;
  *(void *)(v13 + 32) = *((void *)a4 + 2);
  *(_OWORD *)(v13 + 16) = v14;
  *(_OWORD *)(*(void *)(a1 + 16) + 56 * v9 + 4re::InputManager::notify(8, 0, 0, 0) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::internal::TypeAttributeKey::operator==(unsigned __int16 *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a1 == (unsigned __int16)*a2
    && a1[1] == WORD1(v2)
    && ((*((_DWORD *)a1 + 1) ^ HIDWORD(v2)) & 0xFFFFFF) == 0
    && (uint64_t v3 = a2[1], a1[4] == (unsigned __int16)v3)
    && a1[5] == WORD1(v3)
    && ((*((_DWORD *)a1 + 3) ^ HIDWORD(v3)) & 0xFFFFFF) == 0)
  {
    return *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4);
  }
  else
  {
    return 0;
  }
}

uint64_t re::Hash<re::internal::TypeAttributeKey>::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (*(void *)a2 ^ (*(void *)a2 >> 30));
  unint64_t v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*(void *)(a2 + 8) ^ (*(void *)(a2 + 8) >> 30));
  unint64_t v5 = (0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31);
  unsigned int v6 = 73244475 * (*(_DWORD *)(a2 + 16) ^ HIWORD(*(_DWORD *)(a2 + 16)));
  return ((v3 << 6)
        + (v3 >> 2)
        - 0x61C8864680B583E9
        + (((v5 << 6)
          + (v5 >> 2)
          + ((73244475 * (v6 ^ HIWORD(v6))) ^ ((73244475 * (v6 ^ HIWORD(v6))) >> 16))
          - 0x61C8864680B583E9) ^ v5)) ^ v3;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 40);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t *re::internal::typeRegistryAllocator(re::internal *this)
{
  {
    byte_2687A0C58 = 0;
    re::internal::typeRegistryAllocator(void)::allocator = (uint64_t)&unk_26E6DEC70;
    unk_2687A0C50 = "TypeInfo allocator";
  }
  return &re::internal::typeRegistryAllocator(void)::allocator;
}

void anonymous namespace'::getOrCreateGlobalTypeRegistry(_anonymous_namespace_ *this, const re::IntrospectionBase *a2, char a3)
{
  int v4 = (int)a2;
  char v5 = (char)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985A0, memory_order_acquire) & 1) == 0) {
    goto LABEL_18;
  }
  while (1)
  {
    if ((v5 & 1) != 0 || v4)
    {
      if (_MergedGlobals_422) {
        return;
      }
    }
    else
    {
      re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v28);
      char v6 = _MergedGlobals_422;
      re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v28);
      if (v6) {
        return;
      }
    }
    if ((a3 & 1) == 0)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempting to create the global type registry when it cannot be created.", "canCreateRegistry", "getOrCreateGlobalTypeRegistry", 44);
      _os_crash();
      __break(1u);
      goto LABEL_17;
    }
    if (v5) {
      goto LABEL_11;
    }
    if (!v4) {
      break;
    }
LABEL_17:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempting to lock introspectionSharedMutex when it is already locked. Forcing a crash because this would hang otherwise.", "!threadOwnsSharedLock", "getOrCreateGlobalTypeRegistry", 49);
    _os_crash();
    __break(1u);
LABEL_18:
    this = (_anonymous_namespace_ *)__cxa_guard_acquire(&qword_26AF985A0);
    if (this)
    {
      re::internal::typeRegistryAllocator(this);
      __cxa_guard_release(&qword_26AF985A0);
    }
  }
  unsigned int v7 = re::introspectionSharedMutex(this);
  std::__shared_mutex_base::lock(v7);
LABEL_11:
  if ((_MergedGlobals_422 & 1) == 0)
  {
    _MergedGlobals_422 = 1;
    re::introspect_BOOL((re *)1, a2);
    re::introspect_char((re *)1, v8);
    re::introspect_double((re *)1, v9);
    re::introspect_float((re *)1, v10);
    re::introspect_short((re *)1, v11);
    re::introspect_int((re *)1, v12);
    re::introspect_long((re *)1, v13);
    re::introspect_size_t((re *)1, v14);
    re::introspect_int64_t((re *)1, v15);
    re::introspect_uint8_t((re *)1, v16);
    re::introspect_uint16_t((re *)1, v17);
    re::introspect_uint32_t((re *)1, v18);
    re::introspect_uint64_t((re *)1, v19);
    re::IntrospectionInfo<char *>::get(1, v20);
    uint64_t v28 = 218827000;
    uint64_t v29 = "short";
    *(void *)&v30.var0 = 0x2CE93A4A92;
    v30.var1 = "int16_t";
    re::StringID::destroyString((re::StringID *)&v30);
    re::StringID::destroyString((re::StringID *)&v28);
    uint64_t v28 = 208862;
    uint64_t v29 = "int";
    *(void *)&v30.var0 = 0x2CE93BFE06;
    v30.var1 = "int32_t";
    re::StringID::destroyString((re::StringID *)&v30);
    re::StringID::destroyString((re::StringID *)&v28);
    *(void *)&v30.var0 = 0x258C98EAAF29A10ALL;
    v30.var1 = "CallbackSerializerAttribute";
    v27[0] = 0;
    v27[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)&v28, (uint64_t *)&v30, 1, 1, 8uLL, 8uLL, (uint64_t)v27);
    re::StringID::destroyString((re::StringID *)&v30);
    *(void *)&v30.var0 = 0xAE8345F9D646D604;
    v30.var1 = "ComplexVersioningAttribute";
    v25[0] = 0;
    v25[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)&v28, (uint64_t *)&v30, 1, 1, 8uLL, 8uLL, (uint64_t)v25);
    re::StringID::destroyString((re::StringID *)&v30);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v28, v22);
  }
  if ((v5 & 1) == 0)
  {
    unint64_t v23 = re::introspectionSharedMutex(this);
    std::__shared_mutex_base::unlock(v23);
  }
}

uint64_t *re::IntrospectionInfo<char *>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionPointer::IntrospectionPointer((re::IntrospectionPointer *)&re::IntrospectionInfo<char *>::get(BOOL)::info);
  }
  if (a1)
  {
    if (re::IntrospectionInfo<char *>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    int v3 = re::IntrospectionInfo<char *>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
    }
    char v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::IntrospectionInfo<char *>::get(BOOL)::isInitialized)
    {
LABEL_19:
      uint64_t v13 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v13);
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
    }
  }
  re::IntrospectionInfo<char *>::get(BOOL)::isInitialized = 1;
  unsigned int v7 = re::introspect_char((re *)1, a2);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<char *>::get(BOOL)::info, 0);
  qword_268796200 = 0x800000001;
  dword_268796208 = 8;
  word_26879620C = 0;
  *(void *)&xmmword_268796210 = 0;
  *((void *)&xmmword_268796210 + 1) = 0xFFFFFFFFLL;
  re::IntrospectionInfo<char *>::get(BOOL)::info = (uint64_t)&unk_26E6CDA08;
  qword_268796220 = (uint64_t)v7;
  unk_268796228 = 0;
  re::IntrospectionRegistry::add(v8, v9);
  re::getPrettyTypeName((re *)&re::IntrospectionInfo<char *>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
  if (BYTE8(v16)) {
    unint64_t v11 = v17;
  }
  else {
    unint64_t v11 = (char *)&v16 + 9;
  }
  if (void)v16 && (BYTE8(v16)) {
    (*(void (**)(void))(*(void *)v16 + 40))();
  }
  if (v18 >> 1 == 94623636 && (__s1 == "char*" || !strcmp(__s1, "char*")))
  {
    long long v12 = v16;
  }
  else
  {
    long long v16 = v7[2];
    long long v12 = v15;
  }
  xmmword_268796210 = v12;
  re::StringID::destroyString((re::StringID *)&v18);
  if ((a1 & 1) == 0) {
    goto LABEL_19;
  }
  return &re::IntrospectionInfo<char *>::get(BOOL)::info;
}

uint64_t *re::foundationIntrospectionLogObjects(re *this)
{
  {
    re::foundationIntrospectionLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Introspection");
  }
  return &re::foundationIntrospectionLogObjects(void)::logObjects;
}

uint64_t re::TypeInfo::TypeInfo(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(void *)uint64_t result = a2;
  *(unsigned char *)(result + 12) = a3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 24);
  if ((a3 - 1) >= 9)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "TypeInfo", 46);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(result + 16) = a4;
  }
  return result;
}

uint64_t re::TypeInfo::TypeInfo(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = *(void *)a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  int v2 = *(unsigned __int8 *)(a2 + 12);
  *(unsigned char *)(result + 12) = v2;
  if ((v2 - 1) >= 9)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "TypeInfo", 66);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(result + 16) = *(void *)(a2 + 16);
  }
  return result;
}

uint64_t re::TypeInfo::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    *(void *)uint64_t result = *(void *)a2;
    *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
    int v2 = *(unsigned __int8 *)(a2 + 12);
    *(unsigned char *)(result + 12) = v2;
    if ((v2 - 1) >= 9)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "operator=", 91);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      *(void *)(result + 16) = *(void *)(a2 + 16);
    }
  }
  return result;
}

uint64_t *re::TypeInfo::name(re::TypeInfo *this)
{
  uint64_t result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
  if (!result)
  {
  }
  return result;
}

uint64_t re::TypeInfo::atVersion@<X0>(re::TypeInfo *this@<X0>, int a2@<W1>, unsigned __int8 *a3@<X8>)
{
  v9[0] = 1;
  for (uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v10, (uint64_t)this);
        ;
        uint64_t result = (uint64_t)re::Optional<re::TypeInfo>::operator=(v9, v8))
  {
    if (!v9[0])
    {
      *a3 = 0;
      return result;
    }
    uint64_t result = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(v10[0] + 12), *(void *)v11);
    int v6 = result ? *(_DWORD *)(result + 16) : -1;
    if (v6 == a2) {
      break;
    }
    if ((*(_DWORD *)(v11 + 60) & 0xFFFFFF) != 0) {
      re::TypeRegistry::typeInfo(v10[0], *(void *)(v11 + 56), v8);
    }
    else {
      v8[0] = 0;
    }
  }
  int v7 = v9[0];
  *a3 = v9[0];
  if (v7) {
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v10);
  }
  return result;
}

uint64_t re::TypeInfo::nextVersion@<X0>(re::TypeInfo *this@<X0>, const re::TypeInfo *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v10, (uint64_t)a2);
  if ((*(_DWORD *)(v11 + 60) & 0xFFFFFF) != 0
    && (uint64_t result = (uint64_t)re::TypeRegistry::typeInfo(v10[0], *(void *)(v11 + 56), v7), v7[0]))
  {
    while (v9 != *((void *)this + 2))
    {
      re::TypeInfo::operator=((uint64_t)v10, (uint64_t)&v8);
      if ((*(_DWORD *)(v9 + 60) & 0xFFFFFF) != 0) {
        re::TypeRegistry::typeInfo(v8, *(void *)(v9 + 56), v6);
      }
      else {
        v6[0] = 0;
      }
      uint64_t result = (uint64_t)re::Optional<re::TypeInfo>::operator=(v7, v6);
      if (!v7[0]) {
        goto LABEL_8;
      }
    }
    *a3 = 1;
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v10);
  }
  else
  {
LABEL_8:
    *a3 = 0;
  }
  return result;
}

void **re::TypeInfo::createInstance(re::TypeInfo *this, re::Allocator *a2, void *a3)
{
  uint64_t v6 = *((void *)this + 2);
  LODWORD(v7) = *(_DWORD *)(v6 + 8);
  unsigned int v8 = *(_DWORD *)(v6 + 12);
  if (v7 <= 8) {
    size_t v7 = 8;
  }
  else {
    size_t v7 = v7;
  }
  if (v8 <= 0x10) {
    uint64_t v9 = 16;
  }
  else {
    uint64_t v9 = v8;
  }
  if ((*(unsigned char *)(v6 + 48) & 0x20) != 0)
  {
    memptr = 0;
    malloc_type_posix_memalign(&memptr, (v9 + 7) & 0x1FFFFFFF8, v7, 0xC75C8B65uLL);
    BOOL v10 = (void **)memptr;
  }
  else
  {
    BOOL v10 = (void **)(*(uint64_t (**)(re::Allocator *, size_t, uint64_t))(*(void *)a2 + 32))(a2, v7, v9);
  }
  re::TypeInfo::construct(this, v10, a2, a3);
  return v10;
}

void re::TypeInfo::construct(re::TypeInfo *this, void **a2, re::Allocator *a3, void *a4)
{
  *(void *)&v27[9] = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = *(void (**)(void **, re::TypeInfo *))(v8 + 16);
  if (v9)
  {
    v9(a2, this);
  }
  else
  {
    switch(*((unsigned char *)this + 12))
    {
      case 1:
      case 3:
      case 8:
      case 9:
        goto LABEL_6;
      case 2:
        uint64_t v14 = re::TypeInfo::enumConstants(this);
        if (!v15) {
          goto LABEL_23;
        }
        long long v16 = (const void *)v14;
        uint64_t v17 = 0;
        break;
      case 4:
        re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)this);
        re::TypeRegistry::typeInfo(v24[0], *(void *)(v25 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v23, (uint64_t)&v27[1]);
        if ((*(_DWORD *)(v25 + 84) & 0xFFFFFF) != 0)
        {
          re::ArrayAccessor::reset((re::ArrayAccessor *)v24, a2, a3, 0);
        }
        else
        {
          uint64_t v19 = re::ArrayAccessor::size((re::ArrayAccessor *)v24, (char *)a2);
          if (v19)
          {
            uint64_t v20 = v19;
            for (uint64_t i = 0; i != v20; ++i)
            {
              uint64_t v22 = (void *)re::ArrayAccessor::elementAtUnchecked((re::ArrayAccessor *)v24, a2, i);
              re::TypeInfo::construct((re::TypeInfo *)v23, v22, a3, a4);
            }
          }
        }
        return;
      case 5:
      case 6:
        uint64_t v11 = *re::foundationIntrospectionLogObjects(this);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          long long v12 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
          if (!v12)
          {
          }
          uint64_t v13 = v12[1];
          *(_DWORD *)buf = 136315138;
          *(void *)uint64_t v27 = v13;
          _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "No explicit constructor set for %s.", buf, 0xCu);
        }
        bzero(a2, *(unsigned int *)(*((void *)this + 2) + 8));
        return;
      case 7:
        goto LABEL_29;
      default:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "construct", 371);
        _os_crash();
        __break(1u);
LABEL_29:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Tagged unions can't be created directly. They need to be embedded in a class/struct.", "!\"Unreachable code\"", "construct", 361);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D7F38CLL);
    }
    while (*(void *)(v14 + v17))
    {
      v17 += 24;
      if (24 * v15 == v17)
      {
        re::Slice<re::EnumConstant>::first(v15, v15);
        size_t v18 = *(unsigned int *)(*((void *)this + 2) + 8);
        memcpy(a2, v16, v18);
        return;
      }
    }
LABEL_23:
    uint64_t v8 = *((void *)this + 2);
LABEL_6:
    size_t v10 = *(unsigned int *)(v8 + 8);
    bzero(a2, v10);
  }
}

void re::TypeInfo::releaseInstance(re::TypeInfo *this, void *a2, re::Allocator *a3, void *a4)
{
  uint64_t v5 = *((void *)this + 2);
  if ((*(unsigned char *)(v5 + 49) & 2) != 0)
  {
    uint64_t v9 = *(void (**)(void *))(v5 + 40);
    if (v9)
    {
      v9(a2);
    }
  }
  else
  {
    re::TypeInfo::destruct(this, a2, a3, a4);
    if ((*(unsigned char *)(*((void *)this + 2) + 48) & 0x20) != 0)
    {
      free(a2);
    }
    else
    {
      uint64_t v8 = *(void (**)(re::Allocator *, void *))(*(void *)a3 + 40);
      v8(a3, a2);
    }
  }
}

void re::TypeInfo::destruct(re::TypeInfo *this, void *a2, re::Allocator *a3, void *a4)
{
  *(void *)&v20[9] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void (**)(void *, re::TypeInfo *))(*((void *)this + 2) + 24);
  if (!v8)
  {
    switch(*((unsigned char *)this + 12))
    {
      case 1:
      case 2:
      case 8:
      case 9:
        return;
      case 3:
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        (*(void (**)(void *, void))(*(void *)&v20[3] + 88))(a2, 0);
        return;
      case 4:
        re::TypeInfo::TypeInfo((uint64_t)v17, (uint64_t)this);
        re::TypeRegistry::typeInfo(v17[0], *(void *)(v18 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20[1]);
        if ((*(_DWORD *)(v18 + 84) & 0xFFFFFF) != 0)
        {
          re::ArrayAccessor::reset((re::ArrayAccessor *)v17, a2, a3, 0);
        }
        else
        {
          uint64_t v12 = re::ArrayAccessor::size((re::ArrayAccessor *)v17, (char *)a2);
          if (v12)
          {
            uint64_t v13 = v12;
            for (uint64_t i = 0; i != v13; ++i)
            {
              uint64_t v15 = (void *)re::ArrayAccessor::elementAtUnchecked((re::ArrayAccessor *)v17, (void **)a2, i);
              re::TypeInfo::destruct((re::TypeInfo *)v16, v15, a3, a4);
            }
          }
        }
        return;
      case 5:
      case 6:
        uint64_t v9 = *re::foundationIntrospectionLogObjects(this);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          size_t v10 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
          if (!v10)
          {
          }
          uint64_t v11 = v10[1];
          *(_DWORD *)buf = 136315138;
          *(void *)uint64_t v20 = v11;
          _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_DEFAULT, "No explicit destructor set for %s.", buf, 0xCu);
        }
        return;
      case 7:
        goto LABEL_18;
      default:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "destruct", 467);
        _os_crash();
        __break(1u);
LABEL_18:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Tagged unions can't be created directly. They need to be embedded in a class/struct.", "!\"Unreachable code\"", "destruct", 457);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D7F744);
    }
  }
  v8(a2, this);
}

uint64_t re::TypeInfo::enumConstants(re::TypeInfo *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!*(_DWORD *)(v1 + 84)) {
    return 0;
  }
  unint64_t v2 = *(unsigned int *)(v1 + 80);
  if (*(void *)(*(void *)this + 344) <= v2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)this + 360) + 24 * v2;
}

uint64_t re::Slice<re::EnumConstant>::first(uint64_t result, uint64_t a2)
{
  if (!result)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "first", 225, v2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeInfo::copy(re::TypeInfo *this, void **a2, char **a3, re::Allocator *a4, void *a5)
{
  switch(*((unsigned char *)this + 12))
  {
    case 1:
    case 2:
      memcpy(a2, a3, *(unsigned int *)(*((void *)this + 2) + 8));
      return 1;
    case 3:
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
      if ((*(uint64_t (**)(char **))(v46 + 80))(a3))
      {
        re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
        re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
        uint64_t v10 = (*(uint64_t (**)(char **))(v42 + 80))(a3);
        (*(void (**)(void **, uint64_t))(v46 + 88))(a2, v10);
      }
      else
      {
        re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
        (*(void (**)(void **, void))(v46 + 88))(a2, 0);
      }
      return 1;
    case 4:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(void *)(v42 + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      uint64_t v11 = re::ArrayAccessor::size((re::ArrayAccessor *)&v40, (char *)a3);
      uint64_t v12 = (const re::TypeInfo *)re::ArrayAccessor::size((re::ArrayAccessor *)&v40, (char *)a3);
      re::ArrayAccessor::reset((re::ArrayAccessor *)&v40, a2, a4, v12);
      if (!v11) {
        return 1;
      }
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = (void *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v40, (char *)a2, v13);
        uint64_t v15 = (void *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v40, (char *)a3, v13);
        if ((re::TypeInfo::copy((re::TypeInfo *)v38, v14, v15, a4, a5) & 1) == 0) {
          break;
        }
        if (v11 == ++v13) {
          return 1;
        }
      }
      return 0;
    case 5:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(void *)(v42 + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      uint64_t v16 = (*(uint64_t (**)(char **))(v42 + 80))(a3);
      uint64_t v17 = *(void (**)(void **, uint64_t *, re::Allocator *, uint64_t))(v42 + 88);
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)&v40);
      v17(a2, &v44, a4, v16);
      if (!v16) {
        return 1;
      }
      uint64_t v18 = 0;
      while (1)
      {
        uint64_t v19 = (void *)(*(uint64_t (**)(void **, uint64_t))(v42 + 96))(a2, v18);
        uint64_t v20 = (void *)(*(uint64_t (**)(char **, uint64_t))(v42 + 96))(a3, v18);
        if ((re::TypeInfo::copy((re::TypeInfo *)v38, v19, v20, a4, a5) & 1) == 0) {
          break;
        }
        if (v16 == ++v18) {
          return 1;
        }
      }
      return 0;
    case 6:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(void *)(v42 + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      uint64_t v21 = (*(uint64_t (**)(char **, re::Allocator *))(v42 + 112))(a3, a4);
      while ((*(unsigned int (**)(uint64_t))(v42 + 120))(v21))
      {
        uint64_t v22 = (*(uint64_t (**)(uint64_t))(v42 + 128))(v21);
        uint64_t v23 = (*(uint64_t (**)(void **, void **, re::Allocator *, uint64_t))(v42 + 104))(a2, &v40, a4, v22);
        if (v23)
        {
          uint64_t v24 = (void *)v23;
          uint64_t v25 = (void *)(*(uint64_t (**)(uint64_t))(v42 + 136))(v21);
          if (re::TypeInfo::copy((re::TypeInfo *)v38, v24, v25, a4, a5)) {
            continue;
          }
        }
        return 0;
      }
      return 1;
    case 7:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::UnionAccessor::activeMemberType((re::UnionAccessor *)&v40, (char *)a3, &v44);
      if (!(_BYTE)v44) {
        return 1;
      }
      Tag = (const re::TypeInfo *)re::UnionAccessor::readTag((re::UnionAccessor *)&v40, (char *)a3);
      re::UnionAccessor::reset((re::UnionAccessor *)&v40, (char *)a2, Tag, a4);
      return re::TypeInfo::copy((re::TypeInfo *)&v45, a2, a3, a4, a5);
    case 8:
      re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v44);
      if ((_BYTE)v44)
      {
        re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v44);
        re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
        if (*(_DWORD *)(v42 + 88) || (re::TypeRegistry::typeInfo(v40, *(void *)(v42 + 72), &v44), (_BYTE)v44))
        {
          uint64_t result = re::TypeInfo::copy((re::TypeInfo *)&v40, a2, a3, a4, a5);
          if (!result) {
            return result;
          }
        }
      }
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v40, *(void *)this, *((void *)this + 2));
      if (!v43) {
        goto LABEL_32;
      }
      unint64_t v28 = 0;
      break;
    case 9:
      long long v32 = *a3;
      unint64_t v33 = *a2;
      if (!*a3)
      {
        if (v33) {
          re::TypeInfo::releaseInstance(this, v33, a4, 0);
        }
        *a2 = 0;
        return 1;
      }
      if (!v33
        || (re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v44),
            re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45),
            v41 != 8)
        || *(_DWORD *)(v42 + 80) < 2u
        || (re::TypeRegistry::typeInfoChecked(*(void **)this, *(void *)(*((void *)this + 2) + 72), (uint64_t)v38),
            re::TypeInfo::getActualTypeFromPointer((uint64_t)v38, (char *)a2, &v44),
            re::TypeRegistry::typeInfoChecked(*(void **)this, *(void *)(*((void *)this + 2) + 72), (uint64_t)v37),
            re::TypeInfo::getActualType((re::TypeInfo *)v37, v32, &v34),
            v44 == v34)
        && (unsigned __int16)v45 == (unsigned __int16)v35
        && WORD1(v45) == HIWORD(v35)
        && ((HIDWORD(v45) ^ v36) & 0xFFFFFF) == 0)
      {
        if (*a2) {
          goto LABEL_52;
        }
      }
      else
      {
        re::TypeRegistry::typeInfoChecked(*(void **)this, *(void *)(*((void *)this + 2) + 72), (uint64_t)&v44);
        re::TypeInfo::releaseInstance((re::TypeInfo *)&v44, *a2, a4, 0);
        *a2 = 0;
      }
      re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
      *a2 = re::TypeInfo::createInstance((re::TypeInfo *)&v40, a4, 0);
LABEL_52:
      re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
      return (re::TypeInfo::copy((re::TypeInfo *)&v40, *a2, v32, a4, a5) & 1) != 0;
    default:
      return 1;
  }
  while (1)
  {
    re::TypeMemberCollection::operator[]((uint64_t *)&v40, v28, (uint64_t)v38);
    if (*(unsigned char *)(v39 + 28))
    {
      re::TypeRegistry::typeInfo(v38[0], *(void *)v39, &v44);
      re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v45);
      uint64_t result = re::TypeInfo::copy((re::TypeInfo *)v37, (char *)a2 + *(unsigned int *)(v39 + 24), (char *)a3 + *(unsigned int *)(v39 + 24), a4, a5);
      if (!result) {
        break;
      }
    }
    if (++v28 >= v43)
    {
      if (!v43)
      {
LABEL_32:
        uint64_t v29 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
        if (!v29)
        {
        }
        if ((unint64_t)*v29 >> 1 == 0x134375A94D9F7110
          && ((StringID v30 = (char *)v29[1], v30 == "DynamicString") || !strcmp(v30, "DynamicString")))
        {
          re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)a3);
        }
        else
        {
          uint64_t v31 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
          if (!v31)
          {
          }
          uint64_t v44 = 0x22C6ED80D0CLL;
          unint64_t v45 = "StringID";
          if (re::StringID::operator==(v31, &v44)) {
            re::StringID::operator=((unint64_t *)a2, (uint64_t *)a3);
          }
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t re::TypeInfo::referencedType@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeInfo::getActualTypeFromPointer@<X0>(uint64_t this@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(this + 16);
  if ((*(_DWORD *)(v4 + 92) & 0xFFFFFF) == 0) {
    goto LABEL_9;
  }
  if (!*(_DWORD *)(v4 + 96)) {
    goto LABEL_9;
  }
  uint64_t v6 = this;
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(v4 + 88), v27);
  re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v27[8]);
  uint64_t Unsigned = re::internal::readUnsigned((re::internal *)&a2[*(int *)(*(void *)(v6 + 16) + 96)], v18, v7);
  re::TypeRegistry::typeInfo(*(void **)v6, *(void *)(*(void *)(v6 + 16) + 72), v27);
  re::TypeInfo::TypeInfo((uint64_t)&v19, (uint64_t)&v27[8]);
  re::TypeInfo::rootClass((re::TypeInfo *)&v19, (uint64_t)v16);
  this = re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)v6 + 32, *(void *)v17);
  uint64_t v9 = *(unsigned int *)(v17 + 80);
  if (v9)
  {
    unsigned int v10 = *(_DWORD *)this & 0xFFFFFF;
    uint64_t v11 = *(void *)v6;
    unint64_t v12 = *(void *)(*(void *)v6 + 624);
    while (1)
    {
      uint64_t v13 = v10;
      if (v12 <= v10)
      {
        v18[4] = 0;
        memset(v27, 0, 80);
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v19 = 136315906;
        uint64_t v20 = "operator[]";
        __int16 v21 = 1024;
        int v22 = 797;
        __int16 v23 = 2048;
        uint64_t v24 = v13;
        __int16 v25 = 2048;
        unint64_t v26 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v14 = *(void *)(v11 + 640);
      if (*(unsigned char *)(v14 + 152 * v13 + 120))
      {
        if (*(void *)(v14 + 152 * v13 + 128) == Unsigned) {
          break;
        }
      }
      unsigned int v10 = v13 + 1;
      if (!--v9) {
        goto LABEL_9;
      }
    }
    uint64_t v15 = *(void *)(v14 + 152 * v13);
    *a3 = v11;
    a3[1] = v15;
  }
  else
  {
LABEL_9:
    *a3 = 0;
    a3[1] = 0xFFFFFFFFLL;
  }
  return this;
}

_DWORD *re::TypeInfo::getActualType@<X0>(re::TypeInfo *this@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(uint64_t (**)(char *, re::TypeInfo *))(*((void *)this + 2) + 144);
  if (v6)
  {
    return (_DWORD *)v6(a2, this);
  }
  else
  {
    re::TypeInfo::rootClass(this, (uint64_t)v22);
    uint64_t result = re::TypeInfo::customClassIDMember(v22, (uint64_t)v19);
    if (v19[0]
      && (uint64_t v8 = v21,
          re::TypeRegistry::typeInfo(v20, *v21, v33),
          re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v33 + 8),
          uint64_t Unsigned = re::internal::readUnsigned((re::internal *)&a2[*((unsigned int *)v8 + 6)], v18, v9),
          uint64_t result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, *(void *)v23),
          uint64_t v11 = *(unsigned int *)(v23 + 80),
          v11))
    {
      unsigned int v12 = *result & 0xFFFFFF;
      uint64_t v13 = *(void *)this;
      unint64_t v14 = *(void *)(*(void *)this + 624);
      while (1)
      {
        uint64_t v15 = v12;
        if (v14 <= v12)
        {
          uint64_t v24 = 0;
          memset(v33, 0, sizeof(v33));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v25 = 136315906;
          unint64_t v26 = "operator[]";
          __int16 v27 = 1024;
          int v28 = 797;
          __int16 v29 = 2048;
          uint64_t v30 = v15;
          __int16 v31 = 2048;
          unint64_t v32 = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v16 = *(void *)(v13 + 640);
        if (*(unsigned char *)(v16 + 152 * v15 + 120))
        {
          if (*(void *)(v16 + 152 * v15 + 128) == Unsigned) {
            break;
          }
        }
        unsigned int v12 = v15 + 1;
        if (!--v11) {
          goto LABEL_12;
        }
      }
      uint64_t v17 = *(void *)(v16 + 152 * v15);
      *a3 = v13;
      a3[1] = v17;
    }
    else
    {
LABEL_12:
      *a3 = 0;
      a3[1] = 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t re::TypeInfo::isInteger(re::TypeInfo *this)
{
  int v1 = *((unsigned __int8 *)this + 12);
  if (v1 == 2)
  {
    re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v4);
    re::TypeInfo::TypeInfo((uint64_t)v3, (uint64_t)&v5);
    return re::TypeInfo::isInteger((re::TypeInfo *)v3);
  }
  else
  {
    return v1 == 1 && *(unsigned __int8 *)(*((void *)this + 2) + 68) == 1;
  }
}

uint64_t re::TypeInfo::renamedEnumConstants(re::TypeInfo *this)
{
  int v1 = (_DWORD *)*((void *)this + 2);
  if (!v1[22]) {
    return 0;
  }
  unint64_t v2 = (v1[21] + v1[20]);
  if (*(void *)(*(void *)this + 344) <= v2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)this + 360) + 24 * v2;
}

uint64_t re::TypeInfo::dictionaryValueType@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 80), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeInfo::unionMember@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void **)this;
  unint64_t v6 = *(unsigned int *)(*((void *)this + 2) + 84) + a2;
  if (v5[73] <= v6)
  {
    memset(v8, 0, sizeof(v8));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::TypeRegistry::typeInfo(v5, *(void *)(v5[75] + 8 * v6), v8);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v8 + 8);
}

BOOL re::TypeInfo::isSubClassOf(void **a1, void *a2)
{
  if (!*a2) {
    return 0;
  }
  int v4 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(*a1 + 4), *a1[2]);
  unint64_t v5 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(*a1 + 4), a2[1]) & 0xFFFFFF;
  if ((*a1)[78] <= v5)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v5 < (v4 & 0xFFFFFFu)
      && (v4 & 0xFFFFFFu) < *(_DWORD *)((*a1)[80] + 152 * v5 + 80) + (int)v5;
}

uint64_t re::TypeInfo::rootClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  for (i = *(void **)this; (*(_DWORD *)(v4 + 76) & 0xFFFFFF) != 0; uint64_t v4 = i[80] + 152 * v6)
  {
    unint64_t v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(i + 4), *(void *)(v4 + 72)) & 0xFFFFFFLL;
    uint64_t i = *(void **)this;
    if (*(void *)(*(void *)this + 624) <= v6)
    {
      memset(v8, 0, sizeof(v8));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  re::TypeRegistry::typeInfo(i, *(void *)v4, v8);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)v8 + 8);
}

uint64_t re::TypeInfo::subClassCount(re::TypeInfo *this)
{
  unint64_t v2 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, **((void **)this + 2));
  uint64_t v3 = *(unsigned int *)(*((void *)this + 2) + 80);
  if (v3 < 2) {
    return 0;
  }
  uint64_t v4 = 0;
  unsigned int v5 = *v2 & 0xFFFFFF;
  uint64_t v6 = v3 - 1;
  unint64_t v7 = v5 + 1;
  uint64_t v8 = 152 * v5 + 224;
  do
  {
    if (*(void *)(*(void *)this + 624) <= v7)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if ((*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, *(void *)(*(void *)(*(void *)this + 640) + v8)) & 0xFFFFFF) == v5)++v4; {
    ++v7;
    }
    v8 += 152;
    --v6;
  }
  while (v6);
  return v4;
}

uint64_t re::TypeInfo::subClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v8 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, **((void **)this + 2));
  uint64_t v10 = *(unsigned int *)(*((void *)this + 2) + 80);
  if (v10 >= 2)
  {
    unsigned int v11 = *v8 & 0xFFFFFF;
    uint64_t v12 = v10 - 1;
    uint64_t v3 = 152 * v11;
    unint64_t v13 = v11 + 1;
    int v14 = a2;
    do
    {
      uint64_t v15 = *(void **)this;
      if (*(void *)(*(void *)this + 624) <= v13)
      {
        memset(v17, 0, sizeof(v17));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v4 = v15[80];
      if ((*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(v15 + 4), *(void *)(v4 + v3 + 224)) & 0xFFFFFF) == v11)
      {
        if (!v14) {
          goto LABEL_9;
        }
        --v14;
      }
      v3 += 152;
      ++v13;
      --v12;
    }
    while (v12);
  }
  re::internal::assertLog((re::internal *)5, v9, "assertion failure: '%s' (%s:line %i) Index out of range. Index: %zu", "!\"Unreachable code\"", "subClass", 943, a2);
  _os_crash();
  __break(1u);
LABEL_9:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(v4 + v3 + 152), v17);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v17 + 8);
}

uint64_t re::TypeInfo::derivedClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v5 = (*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, **((void **)this + 2)) & 0xFFFFFF)
     + a2;
  if (*(void *)(*(void *)this + 624) <= (unint64_t)(v5 + 1))
  {
    memset(v7, 0, sizeof(v7));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*(void *)(*(void *)this + 640) + 152 * (v5 + 1)), v7);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v7 + 8);
}

uint64_t re::TypeInfo::renamedObjectMembers(re::TypeInfo *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!*(_DWORD *)(v1 + 96)) {
    return 0;
  }
  unint64_t v2 = *(unsigned int *)(v1 + 92);
  if (*(void *)(*(void *)this + 704) <= v2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)this + 720) + 24 * v2;
}

void *re::TypeInfo::customClassIDMember@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = this[2];
  unint64_t v3 = *(unsigned int *)(v2 + 136);
  if ((v3 & 0x80000000) != 0)
  {
    char v7 = 0;
  }
  else
  {
    uint64_t v4 = *this;
    if (*(void *)(*this + 664) <= v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v5 = *(void *)(v4 + 680) + 40 * v3;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = v2;
    *(void *)(a2 + 24) = v5;
    int v6 = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(a2 + 32) = -1;
    *(_DWORD *)(a2 + 36) = v6;
    char v7 = 1;
  }
  *(unsigned char *)a2 = v7;
  return this;
}

uint64_t *re::TypeInfo::polymorphicObjectName(re::TypeInfo *this)
{
  uint64_t v2 = *((void *)this + 2);
  uint64_t result = (uint64_t *)(v2 + 104);
  BOOL v4 = *(void *)(v2 + 104) >= 0xFFFFFFFFFFFFFFFELL && (*(void *)(v2 + 104) & 1) == 0;
  if (v4 && !**(unsigned char **)(v2 + 112))
  {
    uint64_t result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, *(void *)v2);
    if (!result)
    {
    }
  }
  return result;
}

_DWORD *re::TypeInfo::typeIDForCustomClassID@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, **((void **)this + 2));
  uint64_t v7 = *(unsigned int *)(*((void *)this + 2) + 80);
  if (v7)
  {
    unint64_t v8 = *result & 0xFFFFFF;
    uint64_t v9 = *(void **)this;
    unint64_t v10 = *(void *)(*(void *)this + 624);
    if (v10 <= v8) {
      unint64_t v11 = *result & 0xFFFFFF;
    }
    else {
      unint64_t v11 = v10;
    }
    unint64_t v12 = v11 - v8;
    uint64_t v13 = 152 * v8;
    while (1)
    {
      if (!v12)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v14 = v9[80];
      if (*(unsigned char *)(v14 + v13 + 120))
      {
        if (*(void *)(v14 + v13 + 128) == a2) {
          break;
        }
      }
      --v12;
      v13 += 152;
      if (!--v7) {
        goto LABEL_10;
      }
    }
    uint64_t v15 = *(void *)(v14 + v13);
    *a3 = v9;
    a3[1] = v15;
  }
  else
  {
LABEL_10:
    *a3 = 0;
    a3[1] = 0xFFFFFFFFLL;
  }
  return result;
}

BOOL re::TypeInfo::isPointerToPolymorphicType(re::TypeInfo *this)
{
  if (*((unsigned char *)this + 12) == 9
    && (re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v4),
        re::TypeInfo::TypeInfo((uint64_t)v2, (uint64_t)&v5),
        v2[12] == 8))
  {
    return *(_DWORD *)(v3 + 80) > 1u;
  }
  else
  {
    return 0;
  }
}

void re::TypeInfo::setActualTypeForPointer(void **a1, uint64_t a2, re **a3)
{
  if (*a3)
  {
    if (*((unsigned char *)a1 + 12) == 9)
    {
      BOOL v4 = a1[2];
      if ((*((_DWORD *)v4 + 23) & 0xFFFFFF) != 0)
      {
        if (*((_DWORD *)v4 + 24))
        {
          re::TypeRegistry::typeInfo((re *)*a1, a3, v8);
          if (v8[0])
          {
            if (*(unsigned char *)(v9 + 120))
            {
              int v6 = *(const re::TypeInfo **)(v9 + 128);
              re::TypeRegistry::typeInfo(*a1, a1[2][11], v10);
              re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v11);
              re::internal::writeUnsigned((unsigned char *)(a2 + *((int *)a1[2] + 24)), v7, v6);
            }
          }
        }
      }
    }
  }
}

uint64_t re::TypeInfo::isDependentOn(unint64_t *a1, long long *a2, uint64_t a3, double a4)
{
  if (*(void *)a2)
  {
    unint64_t v7 = *a1;
    unint64_t v8 = *(void *)a1[2];
    if (*a1 != *(void *)a2
      || (uint64_t v9 = *((void *)a2 + 1), (unsigned __int16)*(void *)a1[2] != (unsigned __int16)v9)
      || ((v11 = WORD1(v8) == WORD1(v9), uint64_t v10 = (v9 ^ v8) & 0xFFFFFF00000000, v11) ? (v11 = v10 == 0) : (v11 = 0), !v11))
    {
      unint64_t v12 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      unint64_t v13 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
      unint64_t v14 = ((v13 ^ (v13 >> 31)) + ((v12 ^ (v12 >> 31)) << 6) + ((v12 ^ (v12 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v12 ^ (v12 >> 31);
      unint64_t v15 = *(unsigned int *)(a3 + 24);
      if (v15)
      {
        uint64_t v16 = v14 % v15;
        uint64_t v17 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (v14 % v15));
        if (v17 != 0x7FFFFFFF)
        {
          int v18 = (unsigned __int16)*(void *)a1[2];
          uint64_t v19 = *(void *)(a3 + 16);
          uint64_t v20 = v17;
          while (1)
          {
            uint64_t v21 = v19 + 32 * v20;
            if (*(void *)(v21 + 16) == v7 && *(unsigned __int16 *)(v21 + 24) == v18)
            {
              uint64_t v22 = v19 + 32 * v20;
              if (*(unsigned __int16 *)(v22 + 26) == WORD1(v8)
                && ((*(_DWORD *)(v22 + 28) ^ HIDWORD(v8)) & 0xFFFFFF) == 0)
              {
                return 0;
              }
            }
            uint64_t v20 = *(_DWORD *)(v21 + 8) & 0x7FFFFFFF;
            if (v20 == 0x7FFFFFFF)
            {
              v52[0].n128_u64[0] = *a1;
              v52[0].n128_u64[1] = v8;
              uint64_t v23 = *(void *)(a3 + 16);
              while (1)
              {
                uint64_t v24 = v23 + 32 * v17;
                if (*(void *)(v24 + 16) == v7 && *(unsigned __int16 *)(v24 + 24) == v18)
                {
                  uint64_t v25 = v23 + 32 * v17;
                  if (*(unsigned __int16 *)(v25 + 26) == WORD1(v8)
                    && ((*(_DWORD *)(v25 + 28) ^ HIDWORD(v8)) & 0xFFFFFF) == 0)
                  {
                    goto LABEL_26;
                  }
                }
                uint64_t v17 = *(_DWORD *)(v24 + 8) & 0x7FFFFFFF;
                if (v17 == 0x7FFFFFFF) {
                  goto LABEL_25;
                }
              }
            }
          }
        }
      }
      else
      {
        LODWORD(v16) = 0;
      }
      v52[0].n128_u64[0] = *a1;
      v52[0].n128_u64[1] = v8;
LABEL_25:
      *(void *)&a4 = re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(a3, v16, v14, v52).n128_u64[0];
      ++*(_DWORD *)(a3 + 40);
LABEL_26:
      uint64_t result = 0;
      switch(*((unsigned char *)a1 + 12))
      {
        case 0:
          re::internal::assertLog((re::internal *)4, v16, a4, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "isDependentOn", 1262);
          _os_crash();
          __break(1u);
          JUMPOUT(0x233D81CC0);
        case 2:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          __int16 v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v51 = *a2;
          int v28 = &v51;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 3:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          __int16 v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v50 = *a2;
          int v28 = &v50;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 4:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 80), v48);
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v52[0].n128_i64[1]);
          long long v47 = *a2;
          if (re::TypeInfo::isDependentOn(v38, &v47, a3)) {
            return 1;
          }
          if (!v48[0]) {
            return 0;
          }
          __int16 v27 = (__n128 *)v49;
          long long v46 = *a2;
          int v28 = &v46;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 5:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          __int16 v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v45 = *a2;
          int v28 = &v45;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 6:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          uint64_t v29 = re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v44 = *a2;
          if (re::TypeInfo::isDependentOn(v29, &v44, a3)) {
            return 1;
          }
          re::TypeRegistry::typeInfoChecked((void *)*a1, *(void *)(a1[2] + 80), (uint64_t)v52);
          long long v43 = *a2;
          __int16 v27 = v52;
          int v28 = &v43;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 7:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          uint64_t v30 = re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v42 = *a2;
          if (re::TypeInfo::isDependentOn(v30, &v42, a3)) {
            return 1;
          }
          if (!*(_DWORD *)(a1[2] + 88)) {
            return 0;
          }
          unint64_t v31 = 0;
          do
          {
            re::TypeInfo::unionMember((re::TypeInfo *)a1, v31, (uint64_t)v52);
            long long v41 = *a2;
            uint64_t result = re::TypeInfo::isDependentOn(v52, &v41, a3);
            if (result) {
              break;
            }
            ++v31;
          }
          while (v31 < *(unsigned int *)(a1[2] + 88));
          return result;
        case 8:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v48);
          if (v48[0])
          {
            long long v40 = *a2;
            if (re::TypeInfo::isDependentOn(v49, &v40, a3)) {
              return 1;
            }
          }
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)v38, *a1, a1[2]);
          if (!v39) {
            goto LABEL_49;
          }
          unint64_t v32 = 0;
          break;
        case 9:
          re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 72), v52);
          __int16 v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          long long v33 = *a2;
          int v28 = &v33;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        default:
          return result;
      }
      while (1)
      {
        re::TypeMemberCollection::operator[](v38, v32, (uint64_t)v36);
        re::TypeRegistry::typeInfo(v36[0], *v36[2], v52);
        re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v52[0].n128_i64[1]);
        long long v35 = *a2;
        if (re::TypeInfo::isDependentOn(v37, &v35, a3)) {
          break;
        }
        if (++v32 >= v39)
        {
LABEL_49:
          re::TypeInfo::customClassIDMember(a1, (uint64_t)v52);
          if (!v52[0].n128_u8[0]) {
            return 0;
          }
          re::TypeMemberInfo::memberType((re::TypeMemberInfo *)&v52[0].n128_i8[8], (uint64_t)v37);
          long long v34 = *a2;
          __int16 v27 = (__n128 *)v37;
          int v28 = &v34;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        }
      }
    }
    return 1;
  }
  return 0;
}

BOOL re::areSameTranslatedVersion(re *this, const re::TypeInfo *a2, const re::TypeInfo *a3)
{
  BOOL v4 = *(void **)(*(void *)a2 + 856);
  if (v4)
  {
    uint64_t v5 = **((void **)a2 + 2);
    v11[0] = *(void *)a2;
    v11[1] = v5;
    re::internal::TypeTranslationTable::translateType(v4, (uint64_t)v11, &v9);
    uint64_t v6 = v9;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  if (v6 == *(void *)this
    && (uint64_t v7 = **((void **)this + 2), (unsigned __int16)v10 == (unsigned __int16)v7)
    && WORD1(v10) == WORD1(v7))
  {
    return ((HIDWORD(v10) ^ HIDWORD(v7)) & 0xFFFFFF) == 0;
  }
  else
  {
    return 0;
  }
}

__n128 re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, __n128 *a4)
{
  uint64_t v7 = *(unsigned int *)(a1 + 36);
  if (v7 == 0x7FFFFFFF)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    int v8 = v7;
    if (v7 == *(_DWORD *)(a1 + 24))
    {
      int v9 = *(_DWORD *)(a1 + 28);
      signed int v10 = 2 * v9;
      uint64_t v11 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v10) {
          BOOL v12 = v7 == v10;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v24, 0, 36);
          *(void *)&v24[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>,re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>,re::internal::ValueAsKey<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,re::Hash<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,re::EqualTo<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,true,false>::init((uint64_t)v24, v11, v10);
          long long v13 = *(_OWORD *)v24;
          *(_OWORD *)uint64_t v24 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          uint64_t v14 = *(void *)&v24[16];
          *(void *)&v24[16] = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v14;
          long long v16 = *(_OWORD *)&v24[24];
          *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
          unsigned int v15 = *(_DWORD *)&v24[32];
          *(_OWORD *)(a1 + 24) = v16;
          unsigned int v17 = v15;
          if (v15)
          {
            uint64_t v18 = 0;
            unint64_t v19 = 0;
            do
            {
              if ((*(_DWORD *)(*(void *)&v24[16] + v18 + 8) & 0x80000000) != 0)
              {
                re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(a1, *(void *)(*(void *)&v24[16] + v18) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v24[16] + v18), *(void *)&v24[16] + v18 + 16);
                unsigned int v17 = *(_DWORD *)&v24[32];
              }
              ++v19;
              v18 += 32;
            }
            while (v19 < v17);
          }
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v24);
        }
      }
      else
      {
        if (v10) {
          signed int v22 = v10;
        }
        else {
          signed int v22 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 32 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v7) = a3;
  __n128 result = *a4;
  *(__n128 *)(*(void *)(a1 + 16) + 32 * v7 + 16) = *a4;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t re::TypeMemberCollection::TypeMemberCollection(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)__n128 result = a2;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 16) = a3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 24);
  uint64_t v3 = *(unsigned int *)(a3 + 88);
  if (v3)
  {
    unint64_t v4 = *(unsigned int *)(a3 + 84);
    if (*(void *)(a2 + 664) <= v4)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v5 = *(void *)(a2 + 680) + 40 * v4;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v3 = 0;
  }
  *(void *)(result + 24) = v5;
  *(void *)(result + 32) = v3;
  return result;
}

uint64_t *re::TypeMemberCollection::operator[]@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = result[4];
  if (v3 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a2, v3);
    __n128 result = (uint64_t *)_os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v4 = *result;
    uint64_t v5 = result[2];
    uint64_t v6 = result[3] + 40 * a2;
    *(void *)a3 = *result;
    *(void *)(a3 + 8) = v5;
    *(void *)(a3 + 16) = v6;
    LODWORD(v4) = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(a3 + 24) = a2;
    *(_DWORD *)(a3 + 28) = v4;
  }
  return result;
}

uint64_t re::internal::TypeTranslationTable::buildTables(re::internal::TypeTranslationTable *this)
{
  uint64_t v1 = this;
  uint64_t v132 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  *((_DWORD *)this + 4) = *(_DWORD *)(*(void *)this + 24);
  *((_DWORD *)this + 5) = *(_DWORD *)(v3 + 24);
  uint64_t v4 = *(void *)(v2 + 16);
  v108[0] = 0xFFFFFFFFLL;
  unint64_t v5 = *(void *)(v2 + 264);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)this + 3, v4, v5, v108);
  unint64_t v6 = *(void *)(*(void *)v1 + 304);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 6, v4, v6, v108);
  unint64_t v7 = *(void *)(*(void *)v1 + 344);
  LODWORD(v127) = -1;
  re::FixedArray<unsigned int>::init<unsigned int>((void *)v1 + 9, v4, v7, &v127);
  unint64_t v89 = *(void *)(*(void *)v1 + 384);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 12, v4, v89, v108);
  unint64_t v88 = *(void *)(*(void *)v1 + 424);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 15, v4, v88, v108);
  unint64_t v87 = *(void *)(*(void *)v1 + 464);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 18, v4, v87, v108);
  unint64_t v86 = *(void *)(*(void *)v1 + 504);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 21, v4, v86, v108);
  unint64_t v85 = *(void *)(*(void *)v1 + 544);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 24, v4, v85, v108);
  unint64_t v84 = *(void *)(*(void *)v1 + 624);
  re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 27, v4, v84, v108);
  unint64_t v8 = *(void *)(*(void *)v1 + 664);
  LODWORD(v127) = -1;
  re::FixedArray<unsigned int>::init<unsigned int>((void *)v1 + 30, v4, v8, &v127);
  unint64_t v82 = *(void *)(*(void *)v1 + 744);
  uint64_t result = (uint64_t)re::FixedArray<unsigned long>::init<unsigned long const&>((void *)v1 + 33, v4, v82, v108);
  if (v5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = *(void *)(*(void *)v1 + 264);
      if (v12 <= v11) {
        goto LABEL_137;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 280) + v10));
      unint64_t v12 = *((void *)v1 + 4);
      if (v12 <= v11) {
        break;
      }
      *(void *)(*((void *)v1 + 5) + 8 * v11++) = result;
      v10 += 72;
      if (v5 == v11) {
        goto LABEL_6;
      }
    }
LABEL_138:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v11;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_139;
  }
LABEL_6:
  long long v13 = (unsigned char *)v84;
  if (v6)
  {
    uint64_t v14 = 0;
    unint64_t v5 = 0;
    while (1)
    {
      unint64_t v11 = *(void *)(*(void *)v1 + 304);
      if (v11 <= v5) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 320) + v14));
      unint64_t v11 = *((void *)v1 + 7);
      if (v11 <= v5) {
        goto LABEL_140;
      }
      *(void *)(*((void *)v1 + 8) + 8 * v5++) = result;
      v14 += 96;
      if (v6 == v5) {
        goto LABEL_11;
      }
    }
LABEL_139:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v5;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    *(void *)unint64_t v109 = 0;
    unint64_t v51 = (unint64_t)v109;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v5;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_141;
  }
LABEL_11:
  uint64_t v15 = *(void *)(*(void *)v1 + 304);
  unint64_t v95 = v1;
  if (v15)
  {
    long long v16 = *(uint64_t **)(*(void *)v1 + 320);
    unsigned int v17 = &v16[12 * v15];
    unint64_t v83 = v17;
    do
    {
      re::TypeRegistry::typeInfo(*(void **)v1, *v16, &v127);
      re::TypeInfo::TypeInfo((uint64_t)v99, (uint64_t)&v127 + 8);
      uint64_t v18 = *v100;
      v107[0] = v99[0];
      v107[1] = v18;
      uint64_t result = (uint64_t)re::internal::TypeTranslationTable::translateType(v120, v1, v107);
      if (!*(void *)v120)
      {
        unint64_t v19 = (re::TypeRegistry *)*((void *)v1 + 1);
        uint64_t v20 = re::TypeInfo::name((re::TypeInfo *)v99);
        uint64_t result = (uint64_t)re::TypeRegistry::typeInfo(v19, (const re::StringID *)v20, &v116);
        if ((_BYTE)v116)
        {
          uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(v99[0] + 96, *v100);
          int v22 = v21 ? *(_DWORD *)(v21 + 16) : -1;
          re::TypeInfo::atVersion((re::TypeInfo *)&v117[4], v22, (unsigned __int8 *)&v127);
          uint64_t result = (uint64_t)re::Optional<re::TypeInfo>::operator=(&v116, (unsigned __int8 *)&v127);
          if ((_BYTE)v116)
          {
            uint64_t v94 = re::TypeInfo::enumConstants((re::TypeInfo *)v99);
            uint64_t v24 = v23;
            uint64_t result = re::TypeInfo::enumConstants((re::TypeInfo *)&v117[4]);
            uint64_t v90 = result;
            uint64_t v93 = v24;
            if (v24)
            {
              unint64_t v12 = v25;
              uint64_t v26 = 0;
              uint64_t v27 = -(uint64_t)v25;
              unint64_t v98 = (re::TypeInfo *)(result + 8);
              uint64_t v91 = -(uint64_t)v25;
              uint64_t v92 = v16;
              do
              {
                uint64_t v96 = v26;
                if (!v12) {
                  goto LABEL_27;
                }
                uint64_t v28 = 0;
                uint64_t v29 = v98;
                uint64_t v30 = (void *)(v94 + 24 * v26 + 8);
                while (1)
                {
                  uint64_t result = re::StringID::operator==(v29, v30);
                  if (result) {
                    break;
                  }
                  --v28;
                  uint64_t v29 = (re::TypeInfo *)((char *)v29 + 24);
                  if (v27 == v28) {
                    goto LABEL_27;
                  }
                }
                if (v28 != 1)
                {
                  uint64_t v36 = -v28;
                }
                else
                {
LABEL_27:
                  uint64_t v31 = re::TypeInfo::renamedEnumConstants((re::TypeInfo *)&v117[4]);
                  if (!v32) {
                    goto LABEL_40;
                  }
                  uint64_t v33 = v31;
                  uint64_t v34 = v32;
                  uint64_t v35 = 0;
                  LODWORD(v36) = -1;
                  do
                  {
                    uint64_t result = re::StringID::operator==((void *)(v33 + 24 * v35 + 8), (void *)(v94 + 24 * v96 + 8));
                    if (result) {
                      BOOL v37 = v12 == 0;
                    }
                    else {
                      BOOL v37 = 1;
                    }
                    if (!v37)
                    {
                      uint64_t v38 = 0;
                      unint64_t v39 = (uint64_t *)v90;
                      while (1)
                      {
                        uint64_t v40 = *v39;
                        v39 += 3;
                        if (v40 == *(void *)(v33 + 24 * v35)) {
                          break;
                        }
                        if (v12 == ++v38) {
                          goto LABEL_38;
                        }
                      }
                      LODWORD(v36) = v38;
                    }
LABEL_38:
                    ++v35;
                  }
                  while (v35 != v34);
                  if (v36 == -1)
                  {
LABEL_40:
                    uint64_t result = re::TypeInfo::renamedEnumConstants((re::TypeInfo *)v99);
                    if (v41)
                    {
                      uint64_t v42 = result;
                      uint64_t v43 = v41;
                      uint64_t v44 = 0;
                      uint64_t v45 = *(void *)(v94 + 24 * v96);
                      LODWORD(v36) = -1;
                      do
                      {
                        if (v12 && *(void *)(v42 + 24 * v44) == v45)
                        {
                          uint64_t v46 = 0;
                          long long v47 = v98;
                          while (1)
                          {
                            uint64_t result = re::StringID::operator==(v47, (void *)(v42 + 24 * v44 + 8));
                            if (result) {
                              break;
                            }
                            ++v46;
                            long long v47 = (re::TypeInfo *)((char *)v47 + 24);
                            if (v12 == v46) {
                              goto LABEL_49;
                            }
                          }
                          LODWORD(v36) = v46;
                        }
LABEL_49:
                        ++v44;
                      }
                      while (v44 != v43);
                    }
                    else
                    {
                      LODWORD(v36) = -1;
                    }
                  }
                }
                long long v16 = v92;
                uint64_t v1 = v95;
                unint64_t v48 = v96 + *((unsigned int *)v92 + 20);
                unint64_t v11 = *((void *)v95 + 10);
                if (v11 <= v48)
                {
                  v105[0] = 0;
                  unint64_t v5 = (unint64_t)v109;
                  long long v130 = 0u;
                  long long v131 = 0u;
                  long long v128 = 0u;
                  long long v129 = 0u;
                  long long v127 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)unint64_t v109 = 136315906;
                  *(void *)&v109[4] = "operator[]";
                  __int16 v110 = 1024;
                  int v111 = 468;
                  __int16 v112 = 2048;
                  unint64_t v113 = v48;
                  __int16 v114 = 2048;
                  *(void *)uint64_t v115 = v11;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_136;
                }
                *(_DWORD *)(*((void *)v95 + 11) + 4 * v48) = v36;
                uint64_t v26 = v96 + 1;
                uint64_t v27 = v91;
              }
              while (v96 + 1 != v93);
            }
          }
        }
        unsigned int v17 = v83;
        long long v13 = (unsigned char *)v84;
      }
      v16 += 12;
    }
    while (v16 != v17);
  }
  long long v49 = (unsigned char *)v82;
  if (v89)
  {
    uint64_t v50 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 384);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 400) + v50));
      unint64_t v5 = *((void *)v1 + 13);
      if (v5 <= v51) {
        goto LABEL_142;
      }
      *(void *)(*((void *)v1 + 14) + 8 * v51++) = result;
      v50 += 96;
      if (v89 == v51) {
        goto LABEL_62;
      }
    }
LABEL_141:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_143;
  }
LABEL_62:
  if (v88)
  {
    uint64_t v52 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 424);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 440) + v52));
      unint64_t v5 = *((void *)v1 + 16);
      if (v5 <= v51) {
        goto LABEL_144;
      }
      *(void *)(*((void *)v1 + 17) + 8 * v51++) = result;
      v52 += 96;
      if (v88 == v51) {
        goto LABEL_67;
      }
    }
LABEL_143:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_145;
  }
LABEL_67:
  if (v87)
  {
    uint64_t v53 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 464);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 480) + v53));
      unint64_t v5 = *((void *)v1 + 19);
      if (v5 <= v51) {
        goto LABEL_146;
      }
      *(void *)(*((void *)v1 + 20) + 8 * v51++) = result;
      v53 += 128;
      if (v87 == v51) {
        goto LABEL_72;
      }
    }
LABEL_145:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_146:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_147;
  }
LABEL_72:
  if (v86)
  {
    uint64_t v54 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 504);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 520) + v54));
      unint64_t v5 = *((void *)v1 + 22);
      if (v5 <= v51) {
        goto LABEL_148;
      }
      *(void *)(*((void *)v1 + 23) + 8 * v51++) = result;
      v54 += 160;
      if (v86 == v51) {
        goto LABEL_77;
      }
    }
LABEL_147:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_148:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_149;
  }
LABEL_77:
  if (v85)
  {
    uint64_t v55 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 544);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 560) + v55));
      unint64_t v5 = *((void *)v1 + 25);
      if (v5 <= v51) {
        goto LABEL_150;
      }
      *(void *)(*((void *)v1 + 26) + 8 * v51++) = result;
      v55 += 96;
      if (v85 == v51) {
        goto LABEL_82;
      }
    }
LABEL_149:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_150:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_151;
  }
LABEL_82:
  if (v13)
  {
    uint64_t v56 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 624);
      if (v5 <= v51) {
        break;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 640) + v56));
      unint64_t v5 = *((void *)v1 + 28);
      if (v5 <= v51) {
        goto LABEL_152;
      }
      *(void *)(*((void *)v1 + 29) + 8 * v51++) = result;
      v56 += 152;
      if (v13 == (unsigned char *)v51) {
        goto LABEL_87;
      }
    }
LABEL_151:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_152:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_153:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_154:
    *(void *)unint64_t v109 = 0;
    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v116 = 136315906;
    *(void *)uint64_t v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    __int16 v118 = 2048;
    *(void *)uint64_t v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(void *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_87:
  uint64_t v57 = *(void *)(*(void *)v1 + 624);
  if (v57)
  {
    uint64_t v58 = *(void *)(*(void *)v1 + 640);
    uint64_t v59 = v58 + 152 * v57;
    uint64_t v97 = v59;
    do
    {
      re::TypeRegistry::typeInfo(*(void **)v1, *(void *)v58, &v127);
      re::TypeInfo::TypeInfo((uint64_t)v105, (uint64_t)&v127 + 8);
      uint64_t v60 = *v106;
      v103[0] = v105[0];
      v103[1] = v60;
      uint64_t result = (uint64_t)re::internal::TypeTranslationTable::translateType(&v104, v1, v103);
      if (!v104)
      {
        __n128 v61 = (re::TypeRegistry *)*((void *)v1 + 1);
        long long v62 = re::TypeInfo::name((re::TypeInfo *)v105);
        uint64_t result = (uint64_t)re::TypeRegistry::typeInfo(v61, (const re::StringID *)v62, &v116);
        if ((_BYTE)v116)
        {
          uint64_t v63 = re::DataArray<re::TextureAtlasTile>::tryGet(v105[0] + 96, *v106);
          int v64 = v63 ? *(_DWORD *)(v63 + 16) : -1;
          re::TypeInfo::atVersion((re::TypeInfo *)&v117[4], v64, (unsigned __int8 *)&v127);
          uint64_t result = (uint64_t)re::Optional<re::TypeInfo>::operator=(&v116, (unsigned __int8 *)&v127);
          if ((_BYTE)v116)
          {
            re::TypeMemberCollection::TypeMemberCollection((uint64_t)v109, v105[0], (uint64_t)v106);
            uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v99, *(uint64_t *)&v117[4], *(uint64_t *)&v119[4]);
            uint64_t v65 = *(void *)&v115[2];
            if (*(void *)&v115[2])
            {
              unint64_t v66 = 0;
              while (1)
              {
                re::TypeMemberCollection::operator[]((uint64_t *)v109, v66, (uint64_t)&v127);
                if (!v102) {
                  goto LABEL_157;
                }
                uint64_t v67 = 0;
                unint64_t v68 = (void *)(v128 + 8);
                uint64_t v69 = -(uint64_t)v102;
                id v70 = (void *)(v101 + 8);
                while (1)
                {
                  uint64_t result = re::StringID::operator==(v70, v68);
                  if (result) {
                    break;
                  }
                  --v67;
                  v70 += 5;
                  if (v69 == v67) {
                    goto LABEL_105;
                  }
                }
                if (v67 != 1)
                {
                  unint64_t v5 = -v67;
                }
                else
                {
LABEL_157:
                {
LABEL_105:
                  uint64_t v71 = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)&v117[4]);
                  if (!v72) {
                    goto LABEL_111;
                  }
                  uint64_t v73 = v71;
                  uint64_t v74 = v72;
                  while (1)
                  {
                    re::TypeMemberCollection::operator[]((uint64_t *)v109, v66, (uint64_t)&v127);
                    uint64_t result = re::StringID::operator==((void *)v73, (void *)(v128 + 8));
                    if (result) {
                      break;
                    }
                    v73 += 24;
                    if (!--v74) {
                      goto LABEL_111;
                    }
                  }
                  unint64_t v5 = *(unsigned int *)(v73 + 16);
                  if (v5 == -1)
                  {
LABEL_111:
                    uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)v105);
                    if (v75)
                    {
                      uint64_t v76 = result;
                      uint64_t v77 = v75;
                      uint64_t v78 = 0;
                      unint64_t v5 = 0xFFFFFFFFLL;
                      do
                      {
                        if (v66 == *(_DWORD *)(v76 + 24 * v78 + 16) && v102 != 0)
                        {
                          unint64_t v80 = 0;
                          while (1)
                          {
                            re::TypeMemberCollection::operator[](v99, v80, (uint64_t)&v127);
                            uint64_t result = re::StringID::operator==((void *)(v128 + 8), (void *)(v76 + 24 * v78));
                            if (result) {
                              break;
                            }
                            if (++v80 >= v102) {
                              goto LABEL_122;
                            }
                          }
                          unint64_t v5 = v80;
                        }
LABEL_122:
                        ++v78;
                      }
                      while (v78 != v77);
                    }
                    else
                    {
                      unint64_t v5 = 0xFFFFFFFFLL;
                    }
                  }
                }
                }
                unint64_t v11 = v66 + *(unsigned int *)(v58 + 84);
                uint64_t v1 = v95;
                unint64_t v12 = *((void *)v95 + 31);
                if (v12 <= v11) {
                  break;
                }
                *(_DWORD *)(*((void *)v95 + 32) + 4 * v11) = v5;
                if (++v66 == v65) {
                  goto LABEL_128;
                }
              }
LABEL_136:
              v108[1] = 0;
              long long v130 = 0u;
              long long v131 = 0u;
              long long v128 = 0u;
              long long v129 = 0u;
              long long v127 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)uint64_t v120 = 136315906;
              *(void *)&v120[4] = "operator[]";
              __int16 v121 = 1024;
              int v122 = 468;
              __int16 v123 = 2048;
              unint64_t v124 = v11;
              __int16 v125 = 2048;
              unint64_t v126 = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_137:
              *(void *)unint64_t v109 = 0;
              long long v130 = 0u;
              long long v131 = 0u;
              long long v128 = 0u;
              long long v129 = 0u;
              long long v127 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v116 = 136315906;
              *(void *)uint64_t v117 = "operator[]";
              *(_WORD *)&v117[8] = 1024;
              *(_DWORD *)&v117[10] = 797;
              __int16 v118 = 2048;
              *(void *)uint64_t v119 = v11;
              *(_WORD *)&v119[8] = 2048;
              *(void *)&v119[10] = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_138;
            }
LABEL_128:
            long long v49 = (unsigned char *)v82;
            uint64_t v59 = v97;
          }
        }
      }
      v58 += 152;
    }
    while (v58 != v59);
  }
  if (v49)
  {
    uint64_t v81 = 0;
    unint64_t v51 = 0;
    while (1)
    {
      unint64_t v5 = *(void *)(*(void *)v1 + 744);
      if (v5 <= v51) {
        goto LABEL_153;
      }
      uint64_t result = re::internal::TypeTranslationTable::findMatchingType(v1, *(void *)(*(void *)(*(void *)v1 + 760) + v81));
      unint64_t v5 = *((void *)v1 + 34);
      if (v5 <= v51) {
        goto LABEL_154;
      }
      *(void *)(*((void *)v1 + 35) + 8 * v51++) = result;
      v81 += 104;
      if (v49 == (unsigned char *)v51) {
        return result;
      }
    }
  }
  return result;
}

uint64_t re::internal::TypeTranslationTable::rebuildIfNecessary(uint64_t this)
{
  uint64_t v1 = (uint64_t *)this;
  if (*(_DWORD *)(*(void *)this + 24) != *(_DWORD *)(this + 16)
    || *(_DWORD *)(*(void *)(this + 8) + 24) != *(_DWORD *)(this + 20))
  {
    uint64_t v2 = *re::foundationIntrospectionLogObjects((re *)this);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "Type registry was modified. Rebuilding type translation table.", v3, 2u);
    }
    re::FixedArray<CoreIKTransform>::deinit(v1 + 3);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 6);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 9);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 12);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 15);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 18);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 21);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 24);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 27);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 30);
    re::FixedArray<CoreIKTransform>::deinit(v1 + 33);
    return re::internal::TypeTranslationTable::buildTables((re::internal::TypeTranslationTable *)v1);
  }
  return this;
}

double re::internal::TypeTranslationTable::translateType@<D0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)a1);
  unint64_t v6 = (int *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(*a1 + 32, *(void *)(a2 + 8));
  if (v6)
  {
    int v7 = *v6;
    return re::internal::TypeTranslationTable::translateType(a1, v7, a3);
  }
  else
  {
    *a3 = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    a3[1] = 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 4 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

double re::internal::TypeTranslationTable::translateType@<D0>(void *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  unint64_t v3 = *(void *)&a2 & 0xFFFFFFLL;
  if ((*(void *)&a2 & 0xFFFFFFLL) == 0xFFFFFF) {
    goto LABEL_23;
  }
  switch(HIBYTE(a2))
  {
    case 1:
      if (a1[4] <= v3)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_26:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_27:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_28:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_29:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_30:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_31:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_32:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v4 = a1 + 5;
      break;
    case 2:
      if (a1[7] <= v3) {
        goto LABEL_26;
      }
      uint64_t v4 = a1 + 8;
      break;
    case 3:
      if (a1[13] <= v3) {
        goto LABEL_27;
      }
      uint64_t v4 = a1 + 14;
      break;
    case 4:
      if (a1[16] <= v3) {
        goto LABEL_28;
      }
      uint64_t v4 = a1 + 17;
      break;
    case 5:
      if (a1[19] <= v3) {
        goto LABEL_29;
      }
      uint64_t v4 = a1 + 20;
      break;
    case 6:
      if (a1[22] <= v3) {
        goto LABEL_30;
      }
      uint64_t v4 = a1 + 23;
      break;
    case 7:
      if (a1[25] <= v3) {
        goto LABEL_31;
      }
      uint64_t v4 = a1 + 26;
      break;
    case 8:
      if (a1[28] <= v3) {
        goto LABEL_32;
      }
      uint64_t v4 = a1 + 29;
      break;
    case 9:
      if (a1[34] <= v3) {
        goto LABEL_33;
      }
      uint64_t v4 = a1 + 35;
      break;
    default:
      goto LABEL_23;
  }
  uint64_t v5 = *(void *)(*v4 + 8 * v3);
  if ((v5 & 0xFFFFFF00000000) == 0)
  {
LABEL_23:
    *a3 = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    a3[1] = 0xFFFFFFFFLL;
  }
  else
  {
    *a3 = a1[1];
    a3[1] = v5;
  }
  return result;
}

uint64_t re::FixedArray<re::DataArrayHandle<re::internal::TypeInfoIndex>>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 16) + 8 * a2;
}

uint64_t re::internal::TypeTranslationTable::translateMember(re::internal::TypeTranslationTable *this, const re::TypeMemberInfo *a2)
{
  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  unint64_t v4 = (*((_DWORD *)a2 + 6) + *(_DWORD *)(*((void *)a2 + 1) + 84));
  if (*((void *)this + 31) <= v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(unsigned int *)(*((void *)this + 32) + 4 * v4);
}

uint64_t re::internal::TypeTranslationTable::translateSerializedEnum(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, int a3, const re::TypeInfo *a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  unint64_t v8 = re::TypeInfo::name(a2);
  int v9 = re::TypeInfo::name(a4);
  BOOL v10 = re::StringID::operator==(v8, v9);
  if (v10)
  {
    unint64_t v11 = (*(_DWORD *)(*((void *)a2 + 2) + 80) + a3);
    if (*((void *)this + 10) <= v11)
    {
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_10;
    }
    unint64_t v11 = *(unsigned int *)(*((void *)this + 11) + 4 * v11);
    if ((v11 & 0x80000000) == 0)
    {
      uint64_t v12 = re::TypeInfo::enumConstants(a4);
      if (v13 > v11) {
        return v12 + 24 * v11;
      }
LABEL_10:
      re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, v13);
      _os_crash();
      __break(1u);
    }
  }
  else
  {
    uint64_t v15 = *re::foundationIntrospectionLogObjects((re *)v10);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = re::TypeInfo::name(a2)[1];
      uint64_t v17 = re::TypeInfo::name(a4)[1];
      LODWORD(buf[0]) = 136315394;
      *(void *)((char *)buf + 4) = v16;
      WORD6(buf[0]) = 2080;
      *(void *)((char *)buf + 14) = v17;
      _os_log_error_impl(&dword_233120000, v15, OS_LOG_TYPE_ERROR, "Failed to translate enum value. Enum names don't match. Serialized type \"%s\", runtime type \"%s\".", (uint8_t *)buf, 0x16u);
    }
  }
  return 0;
}

uint64_t re::internal::TypeTranslationTable::translateRuntimeEnum(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, int a3, const re::TypeInfo *a4)
{
  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  uint64_t v7 = re::FixedArray<unsigned int>::slice((uint64_t)this + 72, *(unsigned int *)(*((void *)a4 + 2) + 80), *(unsigned int *)(*((void *)a4 + 2) + 84));
  if (!v8) {
    return 0;
  }
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  while (*(_DWORD *)(v7 + 4 * v10) != a3)
  {
    ++v10;
    v9 -= 24;
    if (v8 == v10) {
      return 0;
    }
  }
  uint64_t v12 = re::TypeInfo::enumConstants(a4);
  if (v13 > v10) {
    return v12 - v9;
  }
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, v13);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::internal::TypeTranslationTable::findMatchingType(re::internal::TypeTranslationTable *a1, uint64_t a2)
{
  re::TypeRegistry::typeInfo(*(void **)a1, a2, v9);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v10);
  unint64_t v4 = (const re::StringID *)re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a1 + 96, a2);
  if (!v4)
  {
  }
  re::TypeRegistry::typeInfo(*((re::TypeRegistry **)a1 + 1), v4, v9);
  if (v9[0]
    && ((uint64_t v5 = re::DataArray<re::TextureAtlasTile>::tryGet(v11[0] + 96, *(void *)v11[2])) == 0
      ? (int v6 = -1)
      : (int v6 = *(_DWORD *)(v5 + 16)),
        (re::TypeInfo::atVersion((re::TypeInfo *)v10, v6, v8), re::Optional<re::TypeInfo>::operator=(v9, v8), v9[0])
     && re::internal::TypeTranslationTable::areEquivalent(a1, (const re::TypeInfo *)v11, (const re::TypeInfo *)v10)))
  {
    return *(void *)v10[2];
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t re::internal::TypeTranslationTable::areEquivalent(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, const re::TypeInfo *a3)
{
  int v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(void *)this + 32, **((void **)a2 + 2));
  re::internal::TypeTranslationTable::translateType(this, v6, &v49);
  if (v49)
  {
    if (v49 == *(void *)a3)
    {
      uint64_t v7 = **((void **)a3 + 2);
      if (v50 == (unsigned __int16)v7 && v51 == WORD1(v7))
      {
        BOOL v8 = ((v52 ^ HIDWORD(v7)) & 0xFFFFFF) == 0;
LABEL_6:
        LOBYTE(v9) = v8;
        return v9 & 1;
      }
    }
LABEL_63:
    LOBYTE(v9) = 0;
    return v9 & 1;
  }
  if (*((unsigned __int8 *)a2 + 12) != *((unsigned __int8 *)a3 + 12)) {
    goto LABEL_63;
  }
  uint64_t v10 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a2 + 96, **((void **)a2 + 2));
  int v11 = v10 ? *(_DWORD *)(v10 + 16) : -1;
  uint64_t v9 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a3 + 96, **((void **)a3 + 2));
  int v13 = v9 ? *(_DWORD *)(v9 + 16) : -1;
  if (v11 != v13) {
    goto LABEL_63;
  }
  uint64_t v14 = *((void *)a2 + 2);
  if ((*(unsigned char *)(v14 + 48) & 0x80) != 0) {
    goto LABEL_63;
  }
  switch(*((unsigned char *)a2 + 12))
  {
    case 0:
      re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "areEquivalent", 573);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D85100);
    case 1:
      uint64_t v15 = *((void *)a3 + 2);
      if (*(_DWORD *)(v14 + 8) != *(_DWORD *)(v15 + 8) || *(_DWORD *)(v14 + 12) != *(_DWORD *)(v15 + 12)) {
        goto LABEL_63;
      }
      BOOL v8 = *(unsigned __int8 *)(v14 + 68) == *(unsigned __int8 *)(v15 + 68);
      goto LABEL_6;
    case 2:
      if (*(_DWORD *)(v14 + 8) != *(_DWORD *)(*((void *)a3 + 2) + 8)) {
        goto LABEL_63;
      }
      uint64_t v16 = re::TypeInfo::enumConstants(a2);
      unint64_t v18 = v17;
      uint64_t v46 = v16;
      v47[0] = v17;
      uint64_t v44 = re::TypeInfo::enumConstants(a3);
      v45[0] = v19;
      if (v18 != v19) {
        goto LABEL_63;
      }
      if (!v18) {
        goto LABEL_65;
      }
      unint64_t v20 = 0;
      while (1)
      {
        uint64_t v21 = (void *)re::Slice<re::EnumConstant>::operator[](&v46, v20);
        int v22 = (void *)re::Slice<re::EnumConstant>::operator[](&v44, v20);
        if (*v21 != *v22 || !re::StringID::operator==(v21 + 1, v22 + 1)) {
          break;
        }
        if (++v20 >= v47[0])
        {
LABEL_65:
          LOBYTE(v9) = 1;
          return v9 & 1;
        }
      }
      goto LABEL_63;
    case 3:
    case 5:
      goto LABEL_59;
    case 4:
      uint64_t v23 = *((void *)a3 + 2);
      int v24 = *(_DWORD *)(v14 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v23 + 84) & 0xFFFFFF) != 0)
      {
        if (!v24) {
          goto LABEL_63;
        }
      }
      else if (v24 || *(_DWORD *)(v23 + 88) != *(_DWORD *)(v14 + 88))
      {
        goto LABEL_63;
      }
LABEL_59:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      unint64_t v25 = (const re::TypeInfo *)&v46;
      uint64_t v26 = (const re::TypeInfo *)&v44;
LABEL_60:
      LOBYTE(v9) = re::internal::TypeTranslationTable::areEquivalent(this, v25, v26);
      return v9 & 1;
    case 6:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
      if (!v9) {
        return v9 & 1;
      }
      re::TypeInfo::dictionaryValueType(a2, (uint64_t)v40);
      re::TypeInfo::dictionaryValueType(a3, (uint64_t)v38);
      unint64_t v25 = (const re::TypeInfo *)v40;
      uint64_t v26 = (const re::TypeInfo *)v38;
      goto LABEL_60;
    case 7:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
      if (!v9) {
        return v9 & 1;
      }
      uint64_t v27 = *(unsigned int *)(*((void *)a2 + 2) + 88);
      if (v27 != *(_DWORD *)(*((void *)a3 + 2) + 88)) {
        goto LABEL_63;
      }
      if (!v27) {
        goto LABEL_65;
      }
      uint64_t v28 = 0;
      uint64_t v29 = v27 - 1;
      do
      {
        re::TypeInfo::unionMember(a2, v28, (uint64_t)&v46);
        re::TypeInfo::unionMember(a3, v28, (uint64_t)&v44);
        LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
        if (!v9) {
          break;
        }
        BOOL v8 = v29 == v28++;
      }
      while (!v8);
      return v9 & 1;
    case 8:
      uint64_t v30 = (void *)re::FixedArray<re::DataArrayHandle<re::internal::TypeInfoIndex>>::operator[]((uint64_t)this + 216, *(void *)&v6 & 0xFFFFFFLL);
      void *v30 = **((void **)a3 + 2);
      uint64_t v31 = *((void *)a2 + 2);
      if (((*(_DWORD *)(v31 + 76) & 0xFFFFFF) != 0) != ((*(_DWORD *)(*((void *)a3 + 2) + 76) & 0xFFFFFF) != 0)) {
        goto LABEL_71;
      }
      if ((*(_DWORD *)(v31 + 76) & 0xFFFFFF) == 0) {
        goto LABEL_47;
      }
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(v31 + 72), &v46);
      re::TypeRegistry::typeInfo(*(void **)a3, *(void *)(*((void *)a3 + 2) + 72), &v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v47, (const re::TypeInfo *)v45);
      if (!v9) {
        goto LABEL_72;
      }
      uint64_t v31 = *((void *)a2 + 2);
LABEL_47:
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v46, *(void *)a2, v31);
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v44, *(void *)a3, *((void *)a3 + 2));
      if (v48 != v45[3]) {
        goto LABEL_71;
      }
      if (!v48) {
        goto LABEL_53;
      }
      unint64_t v32 = 0;
      break;
    case 9:
      if (*(unsigned __int8 *)(v14 + 80) == *(unsigned __int8 *)(*((void *)a3 + 2) + 80)) {
        goto LABEL_59;
      }
      goto LABEL_63;
    default:
      return v9 & 1;
  }
  while (1)
  {
    re::TypeMemberCollection::operator[](&v46, v32, (uint64_t)v40);
    re::TypeMemberCollection::operator[](&v44, v32, (uint64_t)v38);
    if (!re::StringID::operator==((void *)(v41[1] + 8), (void *)(v39[1] + 8))) {
      break;
    }
    re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v40, (uint64_t)v43);
    re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v38, (uint64_t)v42);
    if ((re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v43, (const re::TypeInfo *)v42) & 1) == 0) {
      break;
    }
    if (++v32 >= v48)
    {
LABEL_53:
      uint64_t v33 = re::TypeInfo::polymorphicObjectName(a2);
      uint64_t v34 = re::TypeInfo::polymorphicObjectName(a3);
      LODWORD(v9) = re::StringID::operator==(v33, v34);
      if (!v9) {
        goto LABEL_72;
      }
      uint64_t v35 = *((void *)a2 + 2);
      uint64_t v36 = *((void *)a3 + 2);
      if (*(unsigned char *)(v35 + 120) && *(unsigned char *)(v36 + 120))
      {
        if (*(void *)(v35 + 128) != *(void *)(v36 + 128)) {
          break;
        }
      }
      else if (*(unsigned __int8 *)(v36 + 120) | *(unsigned __int8 *)(v35 + 120))
      {
        break;
      }
      re::TypeInfo::customClassIDMember(a2, (uint64_t)v40);
      re::TypeInfo::customClassIDMember(a3, (uint64_t)v38);
      if ((v40[0] != 0) == (v38[0] != 0))
      {
        if (!v40[0]
          || (re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v41, (uint64_t)v43),
              re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v39, (uint64_t)v42),
              (re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v43, (const re::TypeInfo *)v42) & 1) != 0))
        {
          LOBYTE(v9) = 1;
          goto LABEL_72;
        }
      }
      break;
    }
  }
LABEL_71:
  LOBYTE(v9) = 0;
LABEL_72:
  void *v30 = 0xFFFFFFFFLL;
  return v9 & 1;
}

BOOL re::IntrospectionRegistry::contains(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_2687A1038);
  uint64_t v5 = this;
  BOOL v3 = re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains((uint64_t)&unk_2687A1008, (uint64_t *)&v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_2687A1038);
  return v3;
}

void globalIntrospectionTable(void)
{
  {
    if (v0)
    {
    }
  }
}

BOOL re::IntrospectionRegistry::add(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  globalIntrospectionTable();
  PrettyTypeCFStringRef Name = (re *)re::getPrettyTypeName(this, (const re::IntrospectionBase *)&v8);
  if (v9) {
    unint64_t v4 = *(const char **)&v10[7];
  }
  else {
    unint64_t v4 = v10;
  }
  uint64_t v5 = (re::Allocator *)re::introspectionAllocator(PrettyTypeName);
  re::DynamicString::DynamicString((re::DynamicString *)&v11, v4, v5);
  if (v8 && (v9 & 1) != 0) {
    (*(void (**)(void))(*(void *)v8 + 40))();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&dword_2687A1038);
  BOOL v6 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)&v11);
  if (!v6)
  {
    BOOL v8 = this;
    re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew((uint64_t)&globalIntrospectionTable(void)::table, (re::DynamicString *)&v11, &v8);
    BOOL v8 = this;
    re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add((uint64_t)&unk_2687A1008, (uint64_t *)&v8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_2687A1038);
  if (v11 && (v12 & 1) != 0) {
    (*(void (**)(void))(*(void *)v11 + 40))();
  }
  return !v6;
}

uint64_t re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(uint64_t a1, re::DynamicString *a2, void *a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 56 * v11;
    return v12 + 48;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 56 * v9;
  return v12 + 48;
}

uint64_t re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t *re::IntrospectionRegistry::remove(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  globalIntrospectionTable();
  uint64_t v60 = 0;
  unint64_t v57 = 0;
  unint64_t v58 = 0;
  int v59 = 0;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v56, 0);
  int v4 = ++v59;
  unsigned int v54 = 0;
  *(_OWORD *)__b = 0u;
  long long v53 = 0u;
  unint64_t v55 = 0x7FFFFFFFLL;
  os_unfair_lock_lock((os_unfair_lock_t)&dword_2687A1038);
  int v5 = dword_2687A0FF8;
  uint64_t v6 = 0;
  if (dword_2687A0FF8)
  {
    unint64_t v7 = (int *)(qword_2687A0FE8 + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 14;
      if (v8 < 0) {
        break;
      }
      if (dword_2687A0FF8 == ++v6)
      {
        LODWORD(v6) = dword_2687A0FF8;
        break;
      }
    }
  }
  if (dword_2687A0FF8 != v6)
  {
    uint64_t v35 = v6;
    uint64_t v36 = qword_2687A0FE8;
    do
    {
      if (HIDWORD(v53))
      {
        if (DWORD2(v53)) {
          memset_pattern16(__b[1], &unk_2343655D0, 4 * DWORD2(v53));
        }
        if (v54)
        {
          uint64_t v37 = 0;
          uint64_t v38 = 24 * v54;
          do
          {
            int v39 = *(_DWORD *)(v53 + v37 + 8);
            if (v39 < 0) {
              *(_DWORD *)(v53 + v37 + 8) = v39 & 0x7FFFFFFF;
            }
            v37 += 24;
          }
          while (v38 != v37);
        }
        HIDWORD(v53) = 0;
        unsigned int v54 = 0;
        unint64_t v55 = __PAIR64__(HIDWORD(v55), 0x7FFFFFFF) + 0x100000000;
      }
      uint64_t v40 = v36 + 56 * v35;
      uint64_t v41 = *(void *)(v40 + 48);
      uint64_t v42 = this;
      if ((re::IntrospectionRegistry *)v41 != this)
      {
        uint64_t v41 = re::IntrospectionBase::references(v41, (uint64_t)this, (uint64_t)__b);
        if (!v41) {
          goto LABEL_53;
        }
        uint64_t v42 = *(re::IntrospectionRegistry **)(v40 + 48);
      }
      unint64_t v43 = v58 + 1;
      if (v58 >= v57 && v57 < v43)
      {
        if (v56)
        {
          unint64_t v49 = 8;
          if (v57) {
            unint64_t v49 = 2 * v57;
          }
          if (v49 <= v43) {
            unint64_t v50 = v58 + 1;
          }
          else {
            unint64_t v50 = v49;
          }
          re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v56, v50);
          int v4 = v59;
        }
        else
        {
          re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v56, v43);
          int v4 = v59 + 1;
        }
      }
      unint64_t v45 = v58;
      uint64_t v46 = (re::IntrospectionRegistry **)&v60[2 * v58];
      *uint64_t v46 = v42;
      v46[1] = (re::IntrospectionRegistry *)(v40 + 16);
      unint64_t v58 = v45 + 1;
      int v59 = ++v4;
LABEL_53:
      uint64_t v36 = qword_2687A0FE8;
      if (dword_2687A0FF8 <= (v6 + 1)) {
        int v47 = v6 + 1;
      }
      else {
        int v47 = dword_2687A0FF8;
      }
      while (1)
      {
        uint64_t v35 = (v6 + 1);
        if (v47 - 1 == v6) {
          break;
        }
        LODWORD(v6) = v6 + 1;
        int v48 = v35;
        if ((*(_DWORD *)(qword_2687A0FE8 + 56 * v35 + 8) & 0x80000000) != 0) {
          goto LABEL_60;
        }
      }
      int v48 = v47;
LABEL_60:
      LODWORD(v6) = v48;
    }
    while (v5 != v48);
  }
  unsigned __int16 v51 = v60;
  if (v58)
  {
    uint64_t v9 = v60;
    uint64_t v10 = &v60[2 * v58];
    do
    {
      uint64_t v11 = v9[1];
      unint64_t v12 = re::Hash<re::DynamicString>::operator()((uint64_t)&v61, v11);
      if ((void)globalIntrospectionTable(void)::table)
      {
        unint64_t v13 = v12 % dword_2687A0FF0;
        uint64_t v14 = *((void *)&globalIntrospectionTable(void)::table + 1);
        uint64_t v15 = *(unsigned int *)(*((void *)&globalIntrospectionTable(void)::table + 1) + 4 * v13);
        if (v15 != 0x7FFFFFFF)
        {
          uint64_t v16 = qword_2687A0FE8;
          if (re::DynamicString::operator==(qword_2687A0FE8 + 56 * v15 + 16, v11))
          {
            *(_DWORD *)(v14 + 4 * v13) = *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
LABEL_16:
            uint64_t v18 = qword_2687A0FE8;
            uint64_t v19 = qword_2687A0FE8 + 56 * v15;
            int v22 = *(_DWORD *)(v19 + 8);
            uint64_t v21 = (int *)(v19 + 8);
            int v20 = v22;
            if (v22 < 0)
            {
              int *v21 = v20 & 0x7FFFFFFF;
              re::DynamicString::deinit((re::DynamicString *)(v18 + 56 * v15 + 16));
              uint64_t v18 = qword_2687A0FE8;
              int v20 = *(_DWORD *)(qword_2687A0FE8 + 56 * v15 + 8);
            }
            *(_DWORD *)(v18 + 56 * v15 + 8) = dword_2687A0FFC | v20 & 0x80000000;
            --dword_2687A0FF4;
            dword_2687A0FFC = v15;
            ++dword_2687A1000;
          }
          else
          {
            while (1)
            {
              uint64_t v17 = v15;
              uint64_t v15 = *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
              if (v15 == 0x7FFFFFFF) {
                break;
              }
              if (re::DynamicString::operator==(v16 + 56 * v15 + 16, v11))
              {
                *(_DWORD *)(v16 + 56 * v17 + 8) = *(_DWORD *)(v16 + 56 * v17 + 8) & 0x80000000 | *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
                goto LABEL_16;
              }
            }
          }
        }
      }
      if (dword_2687A1020)
      {
        uint64_t v23 = *v9;
        unint64_t v24 = 0xBF58476D1CE4E5B9 * (*v9 ^ ((unint64_t)*v9 >> 30));
        unint64_t v25 = ((0x94D049BB133111EBLL * (v24 ^ (v24 >> 27))) ^ ((0x94D049BB133111EBLL * (v24 ^ (v24 >> 27))) >> 31))
            % dword_2687A1020;
        uint64_t v26 = *(unsigned int *)(qword_2687A1010 + 4 * v25);
        if (v26 != 0x7FFFFFFF)
        {
          if (*(void *)(qword_2687A1018 + 24 * v26 + 16) == v23)
          {
            *(_DWORD *)(qword_2687A1010 + 4 * v25) = *(_DWORD *)(qword_2687A1018 + 24 * v26 + 8) & 0x7FFFFFFF;
LABEL_26:
            uint64_t v28 = qword_2687A1018;
            uint64_t v29 = qword_2687A1018 + 24 * v26;
            int v32 = *(_DWORD *)(v29 + 8);
            uint64_t v31 = (int *)(v29 + 8);
            int v30 = v32;
            if (v32 < 0)
            {
              *uint64_t v31 = v30 & 0x7FFFFFFF;
              uint64_t v28 = qword_2687A1018;
              int v30 = *(_DWORD *)(qword_2687A1018 + 24 * v26 + 8);
            }
            *(_DWORD *)(v28 + 24 * v26 + 8) = dword_2687A102C | v30 & 0x80000000;
            --dword_2687A1024;
            dword_2687A102C = v26;
            ++dword_2687A1030;
          }
          else
          {
            while (1)
            {
              uint64_t v27 = v26;
              uint64_t v26 = *(_DWORD *)(qword_2687A1018 + 24 * v26 + 8) & 0x7FFFFFFF;
              if (v26 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(qword_2687A1018 + 24 * v26 + 16) == v23)
              {
                *(_DWORD *)(qword_2687A1018 + 24 * v27 + 8) = *(_DWORD *)(qword_2687A1018 + 24 * v27 + 8) & 0x80000000 | *(_DWORD *)(qword_2687A1018 + 24 * v26 + 8) & 0x7FFFFFFF;
                goto LABEL_26;
              }
            }
          }
        }
      }
      v9 += 2;
    }
    while (v9 != v10);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_2687A1038);
  double v33 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)__b);
  uint64_t result = v56;
  if (v56)
  {
    if (v51) {
      return (uint64_t *)(*(uint64_t (**)(double))(*v56 + 40))(v33);
    }
  }
  return result;
}

void *re::IntrospectionRegistry::lookupType(re::IntrospectionRegistry *this, const char *a2)
{
  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_2687A1038);
  int v4 = (void *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)&v6);
  if (v6 && (v7 & 1) != 0) {
    (*(void (**)(void))(*(void *)v6 + 40))();
  }
  if (v4) {
    int v4 = (void *)*v4;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_2687A1038);
  return v4;
}

uint64_t re::IntrospectionRegistry::query(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[2];
  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_2687A1038);
  int v5 = dword_2687A0FF8;
  uint64_t v6 = 0;
  if (dword_2687A0FF8)
  {
    char v7 = (int *)(qword_2687A0FE8 + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 14;
      if (v8 < 0) {
        break;
      }
      if (dword_2687A0FF8 == ++v6)
      {
        LODWORD(v6) = dword_2687A0FF8;
        break;
      }
    }
  }
  if (dword_2687A0FF8 != v6)
  {
    uint64_t v9 = v6;
    uint64_t v10 = qword_2687A0FE8;
    do
    {
      uint64_t v15 = 0;
      uint64_t v15 = *(void *)(v10 + 56 * v9 + 48);
      uint64_t v16 = v15;
      if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), &v16))
      {
        re::DynamicArray<re::TransitionCondition *>::add(a2, &v15);
      }
      uint64_t v10 = qword_2687A0FE8;
      if (dword_2687A0FF8 <= (v6 + 1)) {
        int v11 = v6 + 1;
      }
      else {
        int v11 = dword_2687A0FF8;
      }
      while (1)
      {
        uint64_t v9 = (v6 + 1);
        if (v11 - 1 == v6) {
          break;
        }
        LODWORD(v6) = v6 + 1;
        int v12 = v9;
        if ((*(_DWORD *)(qword_2687A0FE8 + 56 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      int v12 = v11;
LABEL_17:
      LODWORD(v6) = v12;
    }
    while (v5 != v12);
  }
  uint64_t v13 = a2[2] - v4;
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_2687A1038);
  return v13;
}

void anonymous namespace'::IntrospectionRegistryTable::IntrospectionRegistryTable(_anonymous_namespace_::IntrospectionRegistryTable *this)
{
  uint64_t v1 = re::introspectionAllocator(this);
  globalIntrospectionTable(void)::table = 0u;
  *(_OWORD *)&qword_2687A0FE8 = 0u;
  dword_2687A0FF8 = 0;
  *(void *)&dword_2687A0FFC = 0x7FFFFFFFLL;
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)v1, 3);
  BOOL v3 = re::introspectionAllocator(v2);
  unk_2687A1008 = 0u;
  *(_OWORD *)&qword_2687A1018 = 0u;
  dword_2687A1028 = 0;
  *(void *)&dword_2687A102C = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)&unk_2687A1008, (uint64_t)v3, 3);
  dword_2687A1038 = 0;
}

uint64_t re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  *(void *)(*(void *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

BOOL re::IntrospectionBase::references(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  if (v6)
  {
    unint64_t v7 = v6;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
    if (v8 == a2)
    {
      return 1;
    }
    else
    {
      uint64_t v9 = v8;
      unint64_t v10 = 1;
      BOOL v11 = 1;
      do
      {
        uint64_t v13 = v9;
        if (!re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a3, &v13))
        {
          uint64_t v13 = v9;
          re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add(a3, &v13);
          if (re::IntrospectionBase::references(v9, a2, a3)) {
            break;
          }
        }
        BOOL v11 = v10 < v7;
        if (v7 == v10) {
          break;
        }
        uint64_t v9 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a1 + 40))(a1, v10++);
      }
      while (v9 != a2);
    }
  }
  else
  {
    return 0;
  }
  return v11;
}

re::IntrospectionBasic *re::IntrospectionBasic::IntrospectionBasic(re::IntrospectionBasic *this, const char *a2, int a3, int a4, char a5, char a6)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(_DWORD *)(v12 + 16) = 0;
  *(_DWORD *)(v12 + 2re::InputManager::notify(8, 0, 0, 0) = a3;
  *(_DWORD *)(v12 + 24) = a4;
  *(unsigned char *)(v12 + 28) = a5;
  *(unsigned char *)(v12 + 29) = a5 & a6;
  *(void *)(v12 + 32) = 0;
  *(void *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
  *(void *)uint64_t v12 = &unk_26E715D00;
  *(void *)(v12 + 48) = a2;
  *(_DWORD *)(v12 + 56) = 0;
  if (!strcmp(a2, "BOOL"))
  {
    int v14 = 1;
    goto LABEL_26;
  }
  if (!strcmp(a2, "char"))
  {
    int v14 = 2;
    goto LABEL_26;
  }
  if (!strcmp(a2, "short"))
  {
    int v14 = 3;
    goto LABEL_26;
  }
  if (!strcmp(a2, "int"))
  {
    int v14 = 4;
    goto LABEL_26;
  }
  if (!strcmp(a2, "int64_t"))
  {
    int v14 = 5;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint8_t"))
  {
    int v14 = 6;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint16_t"))
  {
    int v14 = 7;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint32_t"))
  {
    int v14 = 8;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint64_t"))
  {
    int v14 = 9;
    goto LABEL_26;
  }
  if (!strcmp(a2, "float"))
  {
    int v14 = 10;
    goto LABEL_26;
  }
  if (!strcmp(a2, "double"))
  {
    int v14 = 11;
    goto LABEL_26;
  }
  int v13 = a3 - 1;
  if (a3 - 1) <= 7 && ((0x8Bu >> v13))
  {
    int v14 = dword_23440B0E4[v13];
LABEL_26:
    *((_DWORD *)this + 14) = v14;
  }
  return this;
}

void re::IntrospectionCStyleArray::IntrospectionCStyleArray(re::IntrospectionCStyleArray *this, const re::IntrospectionBase *a2, uint64_t a3)
{
  uint64_t v4 = *((unsigned int *)a2 + 5);
  if ((v4 & 0x80000000) != 0)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array element size.", "elementSize >= 0", "checkedArraySize", 20);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  uint64_t v3 = a3;
  if ((a3 & 0x80000000) != 0)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array element count.", "elementCount >= 0", "checkedArraySize", 21);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v5 = (int)v4 * (uint64_t)(int)a3;
  if (v5 == (int)v5)
  {
    int v7 = *((_DWORD *)a2 + 6);
    ArcSharedObject::ArcSharedObject(this, 0);
    *(_DWORD *)(v8 + 16) = 2;
    *(_DWORD *)(v8 + 2re::InputManager::notify(8, 0, 0, 0) = v5;
    *(_DWORD *)(v8 + 24) = v7;
    *(_WORD *)(v8 + 28) = 0;
    *(void *)(v8 + 32) = 0;
    *(void *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
    *(void *)uint64_t v8 = &unk_26E6C2018;
    *(void *)(v8 + 48) = a2;
    *(void *)(v8 + 56) = 0;
    *(_DWORD *)(v8 + 64) = v3;
    return;
  }
LABEL_7:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Size overflow in array. Element size = %d bytes, count = %d", "!overflow", "checkedArraySize", 27, v4, v3);
  _os_crash();
  __break(1u);
}

double re::IntrospectionDynamicString::IntrospectionDynamicString(re::IntrospectionDynamicString *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)(v1 + 16) = 0x2000000006;
  *(_DWORD *)(v1 + 24) = 8;
  *(_WORD *)(v1 + 28) = 0;
  *(void *)(v1 + 32) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(v1 + 4re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
  *(void *)uint64_t v1 = &unk_26E715DC0;
  return result;
}

double re::IntrospectionPointer::IntrospectionPointer(re::IntrospectionPointer *this, const re::IntrospectionBase *a2)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)(v3 + 16) = 0x800000001;
  *(_DWORD *)(v3 + 24) = 8;
  *(_WORD *)(v3 + 28) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(v3 + 4re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
  *(void *)uint64_t v3 = &unk_26E6CDA08;
  *(void *)(v3 + 48) = a2;
  *(void *)(v3 + 56) = 0;
  return result;
}

double re::IntrospectionStringID::IntrospectionStringID(re::IntrospectionStringID *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(_DWORD *)(v1 + 24) = 8;
  *(_WORD *)(v1 + 28) = 0;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 4re::InputManager::notify(8, 0, 0, 0) = 0xFFFFFFFFLL;
  *(void *)uint64_t v1 = &unk_26E715E80;
  *(void *)&double result = 0x100000000ALL;
  *(void *)(v1 + 16) = 0x100000000ALL;
  return result;
}

uint64_t re::IntrospectionStructure::childInfoCount(re::IntrospectionStructure *this)
{
  uint64_t v1 = *((unsigned int *)this + 14);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = (_DWORD **)*((void *)this + 8);
  do
  {
    uint64_t v5 = *v4++;
    if (*v5 == 1) {
      ++result;
    }
    --v1;
  }
  while (v1);
  return result;
}

uint64_t re::IntrospectionStructure::childInfo(re::IntrospectionStructure *this, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)this + 14);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (void *)*((void *)this + 8);
    do
    {
      uint64_t v5 = (_DWORD *)*v4;
      if (*(_DWORD *)*v4 == 1)
      {
        if (v3 == a2) {
          return *((void *)v5 + 2);
        }
        ++v3;
      }
      ++v4;
      --v2;
    }
    while (v2);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "!\"Unreachable code\"", "childInfo", 501);
  _os_crash();
  __break(1u);
  return *((void *)v5 + 2);
}

void *re::introspect_BOOL(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_BOOL(BOOL)::info, "BOOL", 1, 1, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_BOOL(BOOL)::isInitialized) {
      return &re::introspect_BOOL(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_BOOL(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_BOOL(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_BOOL(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_BOOL(BOOL)::info;
    }
  }
  re::introspect_BOOL(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_BOOL(BOOL)::info, a2);
  v8[0] = 6059476;
  v8[1] = (uint64_t)"BOOL";
  xmmword_2687A1068 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_BOOL(BOOL)::info;
}

std::__shared_mutex_base *re::introspectionSharedMutex(re *this)
{
  {
    std::__shared_mutex_base::__shared_mutex_base(&re::introspectionSharedMutex(void)::mutex);
  }
  return &re::introspectionSharedMutex(void)::mutex;
}

void re::TypeBuilderHelper::registerBasic<BOOL>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x100000001uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_char(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_char(BOOL)::info, "char", 1, 1, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_char(BOOL)::isInitialized) {
      return &re::introspect_char(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_char(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_char(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_char(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_char(BOOL)::info;
    }
  }
  re::introspect_char(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_char(BOOL)::info, a2);
  v8[0] = 6104748;
  v8[1] = (uint64_t)"char";
  xmmword_2687A10B8 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_char(BOOL)::info;
}

void *re::introspect_float(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_float(BOOL)::info, "float", 4, 4, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_float(BOOL)::isInitialized) {
      return &re::introspect_float(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v8);
    char v3 = re::introspect_float(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v8);
    if (v3) {
      return &re::introspect_float(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_float(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_float(BOOL)::info;
    }
  }
  re::introspect_float(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_float(BOOL)::info, a2);
  v7[0] = 195052728;
  v7[1] = (uint64_t)"float";
  xmmword_2687A1108 = v8;
  re::StringID::destroyString((re::StringID *)v7);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_float(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x400000004uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 2;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_double(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_double(BOOL)::info, "double", 8, 8, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_double(BOOL)::isInitialized) {
      return &re::introspect_double(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_double(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_double(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_double(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_double(BOOL)::info;
    }
  }
  re::introspect_double(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_double(BOOL)::info, a2);
  v8[0] = 0x161EEF7A2;
  v8[1] = (uint64_t)"double";
  xmmword_2687A1158 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_double(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<double>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x800000008uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 2;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_short(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_short(BOOL)::info, "short", 2, 2, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_short(BOOL)::isInitialized) {
      return &re::introspect_short(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_short(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_short(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_short(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_short(BOOL)::info;
    }
  }
  re::introspect_short(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_short(BOOL)::info, a2);
  v8[0] = 218827000;
  v8[1] = (uint64_t)"short";
  xmmword_2687A11A8 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_short(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<short>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x200000002uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_int(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_int(BOOL)::info, "int", 4, 4, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_int(BOOL)::isInitialized) {
      return &re::introspect_int(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_int(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_int(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_int(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_int(BOOL)::info;
    }
  }
  re::introspect_int(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_int(BOOL)::info, a2);
  v8[0] = 208862;
  v8[1] = (uint64_t)"int";
  xmmword_2687A11F8 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_int(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x400000004uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_long(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_long(BOOL)::info, "long", 8, 8, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_long(BOOL)::isInitialized) {
      return &re::introspect_long(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_long(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_long(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_long(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_long(BOOL)::info;
    }
  }
  re::introspect_long(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_long(BOOL)::info, a2);
  v8[0] = 6655224;
  v8[1] = (uint64_t)"long";
  xmmword_2687A1248 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_long(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<long>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  BOOL v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    int v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    int v12 = -1;
    memset(v13, 0, sizeof(v13));
    long long v14 = 0u;
    uint64_t v15 = 0xFFFFFFFFLL;
    int v16 = 1;
    char v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    int v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x800000008uLL;
    *(void *)((char *)&v14 + 4) = 0;
    *(void *)((char *)&v13[1] + 4) = 0;
    int v16 = 1;
    char v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_size_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_size_t(BOOL)::info, "size_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_size_t(BOOL)::isInitialized) {
      return &re::introspect_size_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_size_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_size_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_size_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_size_t(BOOL)::info;
    }
  }
  re::introspect_size_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_size_t(BOOL)::info, a2);
  v8[0] = 0x1947BDF6CLL;
  v8[1] = (uint64_t)"size_t";
  xmmword_2687A1298 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_size_t(BOOL)::info;
}

void *re::introspect_int64_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_int64_t(BOOL)::info, "int64_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_int64_t(BOOL)::isInitialized) {
      return &re::introspect_int64_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_int64_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_int64_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_int64_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_int64_t(BOOL)::info;
    }
  }
  re::introspect_int64_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_int64_t(BOOL)::info, a2);
  v8[0] = 0x2CE93EC744;
  v8[1] = (uint64_t)"int64_t";
  xmmword_2687A12E8 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_int64_t(BOOL)::info;
}

void *re::introspect_uint8_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint8_t(BOOL)::info, "uint8_t", 1, 1, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_uint8_t(BOOL)::isInitialized) {
      return &re::introspect_uint8_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_uint8_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_uint8_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_uint8_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint8_t(BOOL)::info;
    }
  }
  re::introspect_uint8_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint8_t(BOOL)::info, a2);
  v8[0] = 0x31CD534126;
  v8[1] = (uint64_t)"uint8_t";
  xmmword_2687A1338 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_uint8_t(BOOL)::info;
}

void *re::introspect_uint16_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint16_t(BOOL)::info, "uint16_t", 2, 2, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_uint16_t(BOOL)::isInitialized) {
      return &re::introspect_uint16_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_uint16_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_uint16_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_uint16_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint16_t(BOOL)::info;
    }
  }
  re::introspect_uint16_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint16_t(BOOL)::info, a2);
  v8[0] = 0x607DD0D4E68;
  v8[1] = (uint64_t)"uint16_t";
  xmmword_2687A1388 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_uint16_t(BOOL)::info;
}

void *re::introspect_uint32_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint32_t(BOOL)::info, "uint32_t", 4, 4, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_uint32_t(BOOL)::isInitialized) {
      return &re::introspect_uint32_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_uint32_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_uint32_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_uint32_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint32_t(BOOL)::info;
    }
  }
  re::introspect_uint32_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint32_t(BOOL)::info, a2);
  v8[0] = 0x607DD0F01DCLL;
  v8[1] = (uint64_t)"uint32_t";
  xmmword_2687A13D8 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_uint32_t(BOOL)::info;
}

void *re::introspect_uint64_t(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint64_t(BOOL)::info, "uint64_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if (re::introspect_uint64_t(BOOL)::isInitialized) {
      return &re::introspect_uint64_t(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    char v3 = re::introspect_uint64_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if (v3) {
      return &re::introspect_uint64_t(BOOL)::info;
    }
    re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if (re::introspect_uint64_t(BOOL)::isInitialized)
    {
LABEL_8:
      re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint64_t(BOOL)::info;
    }
  }
  re::introspect_uint64_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint64_t(BOOL)::info, a2);
  v8[0] = 0x607DD11CB1ALL;
  v8[1] = (uint64_t)"uint64_t";
  xmmword_2687A1428 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &re::introspect_uint64_t(BOOL)::info;
}

void *re::appendPrettyTypeName(re *this, const re::IntrospectionBase *a2, re::DynamicString *a3)
{
  switch(*((_DWORD *)this + 4))
  {
    case 0:
    case 8:
    case 9:
    case 0xB:
      uint64_t v5 = (const char *)*((void *)this + 6);
      size_t v6 = strlen(v5);
      int v7 = a2;
      uint64_t v8 = v5;
      goto LABEL_15;
    case 1:
      re::appendPrettyTypeName(*((re **)this + 6), a2, a3);
      uint64_t v8 = "*";
      goto LABEL_14;
    case 2:
      re::appendPrettyTypeName(*((re **)this + 6), a2, a3);
      return (void *)re::DynamicString::appendf(a2, "[%d]", *((_DWORD *)this + 16));
    case 3:
      unint64_t v10 = "DynamicArray<";
      int v11 = a2;
      size_t v12 = 13;
      goto LABEL_12;
    case 4:
      unint64_t v10 = "FixedArray<";
      int v11 = a2;
      size_t v12 = 11;
      goto LABEL_12;
    case 5:
      unint64_t v10 = "DataArray<";
      int v11 = a2;
      size_t v12 = 10;
      goto LABEL_12;
    case 6:
      uint64_t v8 = "DynamicString";
      int v7 = a2;
      size_t v6 = 13;
      goto LABEL_15;
    case 7:
      re::DynamicString::append(a2, "HashTable<", 0xAuLL);
      re::appendPrettyTypeName(*((re **)this + 6), a2, v13);
      re::DynamicString::append(a2, ",", 1uLL);
      uint64_t v15 = (re *)*((void *)this + 8);
      goto LABEL_13;
    case 0xA:
      uint64_t v8 = "StringID";
      int v7 = a2;
      size_t v6 = 8;
      goto LABEL_15;
    case 0xD:
      unint64_t v10 = "Optional<";
      int v11 = a2;
      size_t v12 = 9;
LABEL_12:
      re::DynamicString::append(v11, v10, v12);
      uint64_t v15 = (re *)*((void *)this + 6);
LABEL_13:
      re::appendPrettyTypeName(v15, a2, v14);
      uint64_t v8 = ">";
LABEL_14:
      int v7 = a2;
      size_t v6 = 1;
LABEL_15:
      return re::DynamicString::append(v7, v8, v6);
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "appendPrettyTypeName", 612);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D880B4);
  }
}

void *re::getPrettyTypeName@<X0>(re *this@<X0>, const re::IntrospectionBase *a2@<X8>)
{
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::appendPrettyTypeName(this, a2, v5);
}

const char **re::getIntrospectionPolymorphicTypeByName(unsigned int *a1, char *__s2)
{
  uint64_t v2 = *a1;
  if (!v2) {
    return 0;
  }
  for (uint64_t i = (const char **)*((void *)a1 + 1); strcmp(*i, __s2); i += 5)
  {
    if (!--v2) {
      return 0;
    }
  }
  return i;
}

uint64_t re::getIntrospectionPolymorphicTypeByPrettyType(_anonymous_namespace_ *a1, const char *a2)
{
  if (!*(_DWORD *)a1) {
    return 0;
  }
  char v3 = a1;
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  while (1)
  {
    size_t v6 = *(re **)(*((void *)v3 + 1) + v4 + 8);
    long long v13 = 0u;
    long long v14 = 0u;
    re::DynamicString::setCapacity(&v13, 0);
    re::appendPrettyTypeName(v6, (const re::IntrospectionBase *)&v13, v7);
    uint64_t v8 = BYTE8(v13) & 1;
    long long v9 = (BYTE8(v13) & 1) != 0 ? (const char *)v14 : (char *)&v13 + 9;
    int v10 = strcmp(v9, a2);
    uint64_t v11 = *((void *)v3 + 1);
    a1 = (_anonymous_namespace_ *)v13;
    if ((void)v13)
    {
      if (v8) {
        a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v13 + 40))();
      }
    }
    if (!v10) {
      break;
    }
    ++v5;
    v4 += 40;
    if (v5 >= *(unsigned int *)v3) {
      return 0;
    }
  }
  return v11 + v4;
}

const char **re::getIntrospectionEnumValueByName(unsigned int *a1, char *__s2)
{
  uint64_t v2 = *a1;
  if (!v2) {
    return 0;
  }
  for (uint64_t i = (const char ***)*((void *)a1 + 1); ; ++i)
  {
    unint64_t v5 = *i;
    if (*(_DWORD *)*i == 1 && !strcmp(v5[2], __s2)) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return v5;
}

const char **re::getIntrospectionEnumValueRename(unsigned int *a1, char *__s2)
{
  uint64_t v2 = *a1;
  if (!v2) {
    return 0;
  }
  for (uint64_t i = (const char ***)*((void *)a1 + 1); ; ++i)
  {
    unint64_t v5 = *i;
    if (*(_DWORD *)*i == 2 && !strcmp(v5[2], __s2)) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return v5;
}

const char **re::getIntrospectionEnumValueWithVersioning@<X0>(unsigned int *a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = re::getIntrospectionEnumValueRename(a1, a2);
  if (result || (uint64_t result = re::getIntrospectionEnumValueByName(a1, a2)) != 0)
  {
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = result[1];
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  return result;
}

void *re::makePrettyMemberName@<X0>(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  char v3 = this;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  size_t v5 = strlen((const char *)v3);
  size_t v6 = v5;
  if (v5 < 3)
  {
    if (v5 != 2) {
      goto LABEL_10;
    }
    int v7 = *(unsigned __int8 *)v3;
  }
  else
  {
    int v7 = *(unsigned __int8 *)v3;
    if (v7 == 109)
    {
      if (*((unsigned char *)v3 + 1) != 95) {
        goto LABEL_10;
      }
      char v3 = (re *)((char *)v3 + 2);
      goto LABEL_9;
    }
  }
  if (v7 != 95) {
    goto LABEL_10;
  }
  char v3 = (re *)((char *)v3 + 1);
LABEL_9:
  size_t v6 = strlen((const char *)v3);
LABEL_10:
  return re::DynamicString::append(a2, (const char *)v3, v6);
}

BOOL re::introspectionPrettyNameCompare(const char *a1, const char *a2, size_t a3)
{
  size_t v5 = a1;
  size_t v6 = strlen(a1);
  int v7 = *(unsigned __int8 *)v5;
  size_t v8 = v6 - 2;
  if (v6 >= 2 && v7 == 109)
  {
    int v9 = *((unsigned __int8 *)v5 + 1);
    BOOL v10 = v9 == 95;
    if (v9 == 95) {
      v5 += 2;
    }
  }
  else
  {
    size_t v8 = v6 - 1;
    BOOL v10 = v7 == 95;
    if (v7 == 95) {
      ++v5;
    }
  }
  if (!v10) {
    size_t v8 = v6;
  }
  BOOL result = 0;
  if (v8 && v8 == a3) {
    return !strncmp(v5, a2, a3) || __toupper(*v5) == *a2 && !strncmp(v5 + 1, a2 + 1, a3 - 1);
  }
  return result;
}

uint64_t re::getIntrospectionMemberByNameRecursive(re *this, const re::IntrospectionStructure *a2, const char *a3, int *a4)
{
  if (!*((_DWORD *)this + 14)) {
    return 0;
  }
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = *(void *)(*((void *)this + 8) + 8 * v7);
    if (*(_DWORD *)v8 != 1) {
      break;
    }
    if (*(_DWORD *)(v8 + 40) == 3)
    {
      BOOL v10 = *(re **)(v8 + 16);
      *(_DWORD *)a3 = 0;
      uint64_t IntrospectionMemberByNameRecursive = re::getIntrospectionMemberByNameRecursive(v10, a2, a3, a4);
      if (IntrospectionMemberByNameRecursive)
      {
        *(_DWORD *)a3 += *(_DWORD *)(v8 + 36);
        return IntrospectionMemberByNameRecursive;
      }
    }
    else
    {
      size_t v12 = strlen((const char *)a2);
      if (re::introspectionPrettyNameCompare(*(const char **)(v8 + 8), (const char *)a2, v12)) {
        return v8;
      }
    }
LABEL_11:
    if (++v7 >= (unint64_t)*((unsigned int *)this + 14)) {
      return 0;
    }
  }
  if (*(_DWORD *)v8 != 5) {
    goto LABEL_11;
  }
  size_t v9 = strlen((const char *)a2);
  if (!re::introspectionPrettyNameCompare(*(const char **)(v8 + 8), (const char *)a2, v9)) {
    goto LABEL_11;
  }
  re::makePrettyMemberName(*(re **)(v8 + 16), (re::DynamicString *)&v16);
  if (v17) {
    uint64_t v15 = *(const re::IntrospectionStructure **)&v18[7];
  }
  else {
    uint64_t v15 = (const re::IntrospectionStructure *)v18;
  }
  *(_DWORD *)a3 = 0;
  uint64_t v8 = re::getIntrospectionMemberByNameRecursive(this, v15, a3, v14);
  if (v16 && (v17 & 1) != 0) {
    (*(void (**)(void))(*(void *)v16 + 40))();
  }
  return v8;
}

re::IntrospectionBase *re::introspectionAllocPointer(re *a1, _anonymous_namespace_ *a2, re::Allocator *a3)
{
  unsigned int v6 = *((_DWORD *)a3 + 5);
  uint64_t v7 = *((int *)a3 + 6);
  if (v6 <= 8) {
    unsigned int v6 = 8;
  }
  uint64_t v8 = (re::IntrospectionBase *)(*(uint64_t (**)(re *, void, uint64_t))(*(void *)a1 + 32))(a1, (int)v6, v7);
  re::introspectionCallConstructor(a2, (uint64_t)a3, (uint64_t)v8);
  re::introspectionInitElement(a1, v9, a3, v8);
  return v8;
}

void re::introspectionDestroyAllocatedMemory(re::DynamicString *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  switch(*(_DWORD *)(a4 + 16))
  {
    case 1:
      if (*(void *)a1)
      {
        re::introspectionReleasePointer();
      }
      return;
    case 2:
      if (*(int *)(a4 + 64) >= 1)
      {
        int v8 = 0;
        do
          re::introspectionDestroyAllocatedMemory((char *)a1 + *(int *)(*(void *)(a4 + 48) + 20) * (uint64_t)v8++, a2, a3);
        while (v8 < *(_DWORD *)(a4 + 64));
      }
      return;
    case 3:
      int v9 = *(void (**)(uint64_t, re::DynamicString *))(*(void *)a4 + 56);
      uint64_t v10 = a4;
      uint64_t v11 = a1;
      goto LABEL_24;
    case 4:
      int v9 = *(void (**)(uint64_t, re::DynamicString *))(*(void *)a4 + 56);
      uint64_t v10 = a4;
      uint64_t v11 = a1;
      goto LABEL_24;
    case 5:
      int v9 = *(void (**)(uint64_t, re::DynamicString *))(*(void *)a4 + 56);
      uint64_t v10 = a4;
      uint64_t v11 = a1;
      goto LABEL_24;
    case 6:
      re::DynamicString::deinit(a1);
      return;
    case 7:
      int v9 = *(void (**)(uint64_t, re::DynamicString *))(*(void *)a4 + 56);
      uint64_t v10 = a4;
      uint64_t v11 = a1;
LABEL_24:
      v9(v10, v11);
      break;
    case 8:
      size_t v12 = *(void (**)(void))(a4 + 96);
      if (v12)
      {
        v12();
      }
      else
      {
        long long v13 = *(void (**)(uint64_t, uint64_t, re::DynamicString *))(a4 + 80);
        if (v13)
        {
          v13(a4, a3, a1);
        }
      }
      break;
    case 0xA:
      re::StringID::destroyString(a1);
      break;
    default:
      return;
  }
}

void re::introspectionReleasePointer(re::DynamicString *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  re::introspectionDestroyAllocatedMemory(a1, a2, a3, a4);
  if (*(_DWORD *)(a4 + 16) != 8 || !*(void *)(a4 + 96))
  {
    uint64_t v7 = *(void (**)(uint64_t, re::DynamicString *))(*(void *)a2 + 40);
    v7(a2, a1);
  }
}

re *re::introspectionInitMember(re *this, re::Allocator *a2, const re::IntrospectionBase *a3, void *a4)
{
  size_t v5 = this;
  switch(*((_DWORD *)a2 + 4))
  {
    case 3:
      unsigned int v6 = *(uint64_t (**)(re::Allocator *, const re::IntrospectionBase *, re *))(*(void *)a2 + 64);
      uint64_t v7 = a2;
      int v8 = a3;
      int v9 = v5;
      goto LABEL_4;
    case 5:
      unsigned int v6 = *(uint64_t (**)(re::Allocator *, const re::IntrospectionBase *, re *))(*(void *)a2 + 64);
      uint64_t v7 = a2;
      int v8 = a3;
      int v9 = v5;
LABEL_4:
      this = (re *)v6(v7, v8, v9);
      break;
    case 6:
      re::DynamicString::deinit(a3);
      *(void *)a3 = v5;
      this = (re *)re::DynamicString::setCapacity(a3, 0);
      break;
    case 7:
      uint64_t v10 = *(uint64_t (**)(re::Allocator *, const re::IntrospectionBase *, re *, uint64_t))(*(void *)a2 + 64);
      this = (re *)v10(a2, a3, this, 3);
      break;
    case 8:
      this = re::introspectionInitStructure(this, a2, a3, a4);
      break;
    default:
      return this;
  }
  return this;
}

re *re::introspectionInitStructure(re *this, re::Allocator *a2, const re::IntrospectionStructure *a3, void *a4)
{
  unint64_t v4 = *((unsigned int *)a2 + 14);
  if (v4)
  {
    uint64_t v7 = this;
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v9 = *(void *)(*((void *)a2 + 8) + 8 * i);
      if (*(_DWORD *)v9 == 1)
      {
        this = (re *)re::introspectionInitMember(v7, *(re::Allocator **)(v9 + 16), (const re::IntrospectionStructure *)((char *)a3 + *(int *)(v9 + 36)), a4);
        unint64_t v4 = *((unsigned int *)a2 + 14);
      }
    }
  }
  return this;
}

void re::introspectionCallConstructor(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  switch(*(_DWORD *)(a2 + 16))
  {
    case 2:
      if (*(int *)(a2 + 64) >= 1)
      {
        int v6 = 0;
        do
        {
          re::introspectionCallConstructor(a1);
          ++v6;
        }
        while (v6 < *(_DWORD *)(a2 + 64));
      }
      return;
    case 3:
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)a2 + 48);
      uint64_t v8 = a2;
      uint64_t v9 = a3;
      goto LABEL_20;
    case 4:
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)a2 + 48);
      uint64_t v8 = a2;
      uint64_t v9 = a3;
      goto LABEL_20;
    case 5:
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)a2 + 48);
      uint64_t v8 = a2;
      uint64_t v9 = a3;
      goto LABEL_20;
    case 6:
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      re::DynamicString::setCapacity((void *)a3, 0);
      return;
    case 7:
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)a2 + 48);
      uint64_t v8 = a2;
      uint64_t v9 = a3;
LABEL_20:
      v7(v8, v9);
      return;
    case 8:
      uint64_t v10 = *(void (**)(uint64_t, _anonymous_namespace_ *))(a2 + 72);
      if (v10) {
        goto LABEL_27;
      }
      size_t v11 = *(int *)(a2 + 20);
      bzero((void *)a3, v11);
      break;
    case 0xA:
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = "";
      return;
    case 0xB:
      uint64_t v10 = *(void (**)(uint64_t, _anonymous_namespace_ *))(a2 + 64);
      if (v10)
      {
LABEL_27:
        v10(a2, a1);
      }
      break;
    default:
      return;
  }
}

re *re::introspectionInitElement(re *this, int a2, re::Allocator *a3, re::IntrospectionBase *a4)
{
  int v7 = *((_DWORD *)a3 + 4);
  if (v7 == 2)
  {
    if (*(_DWORD *)(*((void *)a3 + 6) + 16) == 1) {
      bzero(a4, *((int *)a3 + 5));
    }
  }
  else if (v7 == 1)
  {
    *(void *)a4 = 0;
  }
  return re::introspectionInitMember(this, a3, a4, a4);
}

unint64_t re::introspectionFindStructureVersion(re *this, const re::IntrospectionStructure *a2)
{
  uint64_t v2 = *((unsigned int *)this + 14);
  if (!v2) {
    return 1;
  }
  char v3 = (void *)*((void *)this + 8);
  unint64_t result = 1;
  unint64_t v5 = 1;
  do
  {
    int v6 = (_DWORD *)*v3;
    if (*(_DWORD *)*v3 == 6 && !*((unsigned char *)v6 + 40))
    {
      unint64_t v7 = *((void *)v6 + 1);
      if (v7 > v5)
      {
        unint64_t result = v7;
        unint64_t v5 = v7;
      }
    }
    ++v3;
    --v2;
  }
  while (v2);
  return result;
}

re *re::introspectionFindForVersion(uint64_t **this, const re::IntrospectionStructure *a2)
{
  unint64_t v10 = 1;
  size_t v11 = (re *)this;
  uint64_t v9 = 0;
  uint64_t v3 = *((unsigned int *)this + 14);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = this[8];
    unint64_t v6 = 1;
    do
    {
      unint64_t v7 = (_DWORD *)*v5;
      if (*(_DWORD *)*v5 == 6 && !*((unsigned char *)v7 + 40) && *((void *)v7 + 1) > v6)
      {
        uint64_t v4 = *v5;
        unint64_t v6 = *((void *)v7 + 1);
      }
      ++v5;
      --v3;
    }
    while (v3);
    uint64_t v9 = v4;
    unint64_t v10 = v6;
  }
  while ((const re::IntrospectionStructure *)v10 != a2)
  {
      return 0;
  }
  return v11;
}

BOOL anonymous namespace'::findPreviousVersion(unint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, void *a5)
{
  if (a1 != 1)
  {
    *a3 = *(void *)(a2 + 16);
    *a4 = 1;
    *a5 = 0;
    uint64_t v5 = *a3;
    if (*(_DWORD *)(*a3 + 56))
    {
      unint64_t v6 = 0;
      unint64_t v7 = 1;
      do
      {
        uint64_t v8 = *(void *)(*(void *)(v5 + 64) + 8 * v6);
        if (*(_DWORD *)v8 == 6 && !*(unsigned char *)(v8 + 40))
        {
          unint64_t v9 = *(void *)(v8 + 8);
          if (v9 < a1 && v9 > v7)
          {
            *a4 = v9;
            *a5 = v8;
            uint64_t v5 = *a3;
            unint64_t v7 = v9;
          }
        }
        ++v6;
      }
      while (v6 < *(unsigned int *)(v5 + 56));
    }
  }
  return a1 != 1;
}

uint64_t re::introspectionRunComplexVersion(re *a1, _anonymous_namespace_ *a2, uint64_t a3, unint64_t a4, re::DynamicString *a5, uint64_t a6, unint64_t a7, re::IntrospectionBase *a8)
{
  uint64_t v13 = *(unsigned int *)(a6 + 56);
  if (v13)
  {
    long long v14 = *(_DWORD ***)(a6 + 64);
    do
    {
      uint64_t v15 = *v14;
      if (**v14 == 6 && !*((unsigned char *)v15 + 40) && *((void *)v15 + 1) == a7) {
        goto LABEL_8;
      }
      ++v14;
      --v13;
    }
    while (v13);
  }
  uint64_t v15 = 0;
LABEL_8:
  while (1)
  {
    unint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v26 = 0;
      break;
    unint64_t v16 = v27;
    uint64_t v17 = (uint64_t)v15;
    unint64_t v18 = a7;
    uint64_t v19 = (re::Allocator *)a6;
    while (v16 != a4)
    {
      unint64_t v18 = v16;
      uint64_t v19 = v28;
      uint64_t v17 = v26;
      unint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v26 = 0;
        goto LABEL_18;
      unint64_t v16 = v27;
    }
    int v20 = *(void (**)(_anonymous_namespace_ *, re::DynamicString *, re::IntrospectionBase *))(v17 + 32);
    if (!v20) {
      break;
    }
    uint64_t v21 = a8;
    if (v18 != a7)
    {
      uint64_t v21 = re::introspectionAllocPointer(a1, a2, v19);
      int v20 = *(void (**)(_anonymous_namespace_ *, re::DynamicString *, re::IntrospectionBase *))(v17 + 32);
    }
    v20(a2, a5, v21);
    re::introspectionReleasePointer(a5, (uint64_t)a1, (uint64_t)a2, a3);
    a3 = (uint64_t)v19;
    a4 = v18;
    a5 = v21;
    if (v18 >= a7) {
      return 1;
    }
  }
LABEL_18:
  re::introspectionReleasePointer(a5, (uint64_t)a1, (uint64_t)a2, a3);
  return 0;
}

void re::getDowngradeFunctions(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  v15[0] = 0;
  v15[1] = 0;
  long long v14 = (uint64_t *)v15;
  unint64_t v4 = *(unsigned int *)(a1 + 56);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 64) + 8 * i);
      if (*(_DWORD *)v8 == 6 && *(unsigned char *)(v8 + 40) && *(_DWORD *)(v8 + 56) >= a2)
      {
        LODWORD(v13) = *(_DWORD *)(v8 + 56);
        *((void *)&v13 + 1) = *(void *)(v8 + 48);
        std::__tree<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::__map_value_compare<re::DowngradeCode,std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::greater<re::DowngradeCode>,true>,std::allocator<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>>::__emplace_multi<std::pair<re::DowngradeCode const,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>(&v14, &v13);
        unint64_t v4 = *(unsigned int *)(a1 + 56);
      }
    }
    unint64_t v9 = v14;
    if (v14 != (uint64_t *)v15)
    {
      do
      {
        re::DynamicArray<re::TransitionCondition *>::add((void *)a3, v9 + 5);
        unint64_t v10 = (uint64_t *)v9[1];
        if (v10)
        {
          do
          {
            size_t v11 = v10;
            unint64_t v10 = (uint64_t *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            size_t v11 = (uint64_t *)v9[2];
            BOOL v12 = *v11 == (void)v9;
            unint64_t v9 = v11;
          }
          while (!v12);
        }
        unint64_t v9 = v11;
      }
      while (v11 != (uint64_t *)v15);
    }
  }
  std::__tree<unsigned long long>::destroy((uint64_t)&v14, v15[0]);
}

_DWORD *re::introspectionFirstStructureMember(re *this, const re::IntrospectionStructure *a2)
{
  uint64_t v2 = *((unsigned int *)this + 14);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)*((void *)this + 8);
    while (1)
    {
      unint64_t result = (_DWORD *)*v3;
      if (*(_DWORD *)*v3 == 1 && result[10] != 3) {
        break;
      }
      ++v3;
      if (!--v2) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) No member found in type info.", "!\"Unreachable code\"", "introspectionFirstStructureMember", 1237);
    unint64_t result = (_DWORD *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PolymorphicData::makeWithPointer@<X0>(uint64_t this@<X0>, const re::IntrospectionBase *a2@<X1>, void *a3@<X8>)
{
  if (*(_DWORD *)(this + 16) != 8) {
    goto LABEL_19;
  }
  uint64_t v4 = *(unsigned int *)(this + 56);
  if (!v4) {
    goto LABEL_19;
  }
  uint64_t v5 = *(void **)(this + 64);
  uint64_t v6 = *(unsigned int *)(this + 56);
  unint64_t v7 = v5;
  do
  {
    uint64_t v8 = (_DWORD *)*v7;
    if (*(_DWORD *)*v7 == 2) {
      goto LABEL_7;
    }
    ++v7;
    --v6;
  }
  while (v6);
  uint64_t v8 = 0;
LABEL_7:
  while (1)
  {
    unint64_t v9 = (_DWORD *)*v5;
    if (*(_DWORD *)*v5 == 3) {
      break;
    }
    ++v5;
    if (!--v4)
    {
      unint64_t v9 = 0;
      break;
    }
  }
  if (v8 && ((uint64_t v10 = *((void *)v8 + 1), v9) ? (v11 = v10 == 0) : (v11 = 1), !v11 && (v12 = *((void *)v9 + 1)) != 0))
  {
    *a3 = 0;
    if (a2) {
      *a3 = (char *)a2 + (int)v9[6];
    }
    a3[1] = v12;
    a3[2] = v10;
  }
  else
  {
LABEL_19:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return this;
}

void *re::introspectionAllocator(re *this)
{
  {
    byte_2687A1468 = 0;
    re::introspectionAllocator(void)::baseAllocator = (uint64_t)&unk_26E6DEC70;
    unk_2687A1460 = "Introspection allocator";
  }
  {
    re::ThreadSafeAutoFreeAllocator::ThreadSafeAutoFreeAllocator((re::ThreadSafeAutoFreeAllocator *)&re::introspectionAllocator(void)::autoFreeAllocator, "Introspection allocator", (re::Allocator *)&re::introspectionAllocator(void)::baseAllocator);
  }
  return &re::introspectionAllocator(void)::autoFreeAllocator;
}

uint64_t re::CustomPolymorphicTable::addType(re::CustomPolymorphicTable *this, const char *__s, const re::IntrospectionBase *a3, uint64_t a4, int a5)
{
  uint64_t v10 = (re *)strlen(__s);
  size_t v11 = (size_t)v10 + 1;
  uint64_t v12 = re::globalAllocators(v10);
  long long v13 = (void *)(*(uint64_t (**)(uint64_t, size_t, void))(*(void *)v12[2] + 32))(v12[2], v11, 0);
  memcpy(v13, __s, v11);
  uint64_t v15 = v13;
  v16[0] = a3;
  v16[1] = 0;
  v16[2] = a4;
  int v17 = a5;
  re::DynamicArray<re::IntrospectionPolymorphicType>::add(this, (uint64_t)&v15);
  uint64_t result = re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)v16);
  *((_DWORD *)this + 1re::InputManager::notify(8, 0, 0, 0) = *((void *)this + 2);
  *((void *)this + 6) = *((void *)this + 4);
  return result;
}

void *re::DynamicArray<re::IntrospectionPolymorphicType>::add(void *this, uint64_t a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::IntrospectionPolymorphicType>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4] + 40 * v4;
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v6 = *(void *)(v5 + 8);
  *(void *)(v5 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  *(_DWORD *)(v5 + 32) = *(_DWORD *)(a2 + 32);
  *(void *)(v5 + 24) = v7;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

re *re::CustomPolymorphicTable::removeType(re *this, const re::IntrospectionBase *a2)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (uint64_t)this;
    unint64_t v4 = 0;
    for (unint64_t i = (const re::IntrospectionBase **)(*((void *)this + 4) + 8); *i != a2; i += 5)
    {
      if (v2 == ++v4) {
        return this;
      }
    }
    uint64_t v6 = (uint64_t)*(i - 1);
    if (v6)
    {
      uint64_t v7 = re::globalAllocators(this);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7[2] + 40))(v7[2], v6);
    }
    this = (re *)re::DynamicArray<re::IntrospectionPolymorphicType>::removeStableAt(v3, v4);
    *(_DWORD *)(v3 + 4re::InputManager::notify(8, 0, 0, 0) = *(void *)(v3 + 16);
    *(void *)(v3 + 48) = *(void *)(v3 + 32);
  }
  return this;
}

uint64_t re::DynamicArray<re::IntrospectionPolymorphicType>::removeStableAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = v4 + 40 * a2 + 40;
    if (v5 != v4 + 40 * v2)
    {
      uint64_t v6 = -40 * a2 + 40 * v2 - 40;
      do
      {
        uint64_t v7 = *(void *)(v5 - 32);
        uint64_t v8 = *(void *)(v5 - 24);
        *(_OWORD *)(v5 - 4re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)v5;
        uint64_t v9 = *(void *)(v5 + 16);
        uint64_t v10 = *(void *)(v5 + 24);
        *(void *)(v5 + 8) = v7;
        *(void *)(v5 + 16) = v8;
        *(void *)(v5 - 24) = v9;
        *(void *)(v5 - 16) = v10;
        *(_DWORD *)(v5 - 8) = *(_DWORD *)(v5 + 32);
        v5 += 40;
        v6 -= 40;
      }
      while (v6);
      unint64_t v2 = *(void *)(a1 + 16);
    }
  }
  uint64_t result = re::SerializedReference<re::IntrospectionBase const*>::reset(*(void *)(a1 + 32) + 40 * v2 - 32);
  --*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::CustomPolymorphicTable::clear(uint64_t this)
{
  uint64_t v1 = this;
  *(void *)(*(void *)(this + 56) + 8) = 0;
  *(void *)(this + 48) = 0;
  *(_DWORD *)(this + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  unint64_t v2 = *(void *)(this + 16);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = *(void *)(this + 32);
    do
    {
      uint64_t v6 = *(void *)(v5 + v3);
      if (v6)
      {
        uint64_t v7 = re::globalAllocators((re *)this);
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7[2] + 40))(v7[2], v6);
        unint64_t v2 = *(void *)(v1 + 16);
      }
      if (v2 <= v4)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v5 = *(void *)(v1 + 32);
      *(void *)(v5 + v3) = 0;
      ++v4;
      v3 += 40;
    }
    while (v2 > v4);
    *(void *)(v1 + 16) = 0;
    uint64_t v8 = 40 * v2;
    uint64_t v9 = v5 + 8;
    do
    {
      this = re::SerializedReference<re::IntrospectionBase const*>::reset(v9);
      v9 += 40;
      v8 -= 40;
    }
    while (v8);
  }
  else
  {
    *(void *)(this + 16) = 0;
  }
  ++*(_DWORD *)(v1 + 24);
  *(void *)(v1 + 56) = 0;
  return this;
}

uint64_t re::internal::getOrCreateInfo(re::internal *this, uint64_t (*a2)(re::internal *), re::IntrospectionBase *(*a3)(void), void (*a4)(re::IntrospectionBase *), re::IntrospectionBase **a5)
{
  char v5 = (char)a5;
  if (a5)
  {
    uint64_t v9 = *(void *)a4;
    if (*(void *)a4) {
      return v9;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    uint64_t v9 = *(void *)a4;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    if (v9) {
      return v9;
    }
    re::introspectionSharedMutex(v10);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    uint64_t v9 = *(void *)a4;
    if (*(void *)a4)
    {
LABEL_7:
      re::introspectionSharedMutex(this);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return v9;
    }
  }
  uint64_t v9 = a2(this);
  *(void *)a4 = v9;
  this = a3();
  if ((v5 & 1) == 0) {
    goto LABEL_7;
  }
  return v9;
}

double re::internal::declareType@<D0>(re::StringID *a1@<X2>, re::TypeRegistry *a2@<X0>, int a3@<W1>, unsigned int a4@<W3>, void *a5@<X8>)
{
  re::TypeRegistry::typeID(a2, a1, a4, a5);
  if (*a5)
  {
    if (*(unsigned __int8 *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)a2 + 32, a5[1]) + 3) == a3) {
      return result;
    }
    re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) Type %s has already been declared with different type category.", "registry->typeCategory(typeID) == typeCategory", "declareType", 1483, *((void *)a1 + 1));
    _os_crash();
    __break(1u);
  }
  re::TypeRegistry::declareType((uint64_t)a2, a3, (StringID *)a1, a4, 0, &v12);
  double result = *(double *)&v12;
  *(_OWORD *)a5 = v12;
  return result;
}

void re::internal::registerCallbackSerializerType(re::internal *this@<X0>, re::TypeRegistry *a2@<X1>, const re::IntrospectionBase *a3@<X2>, const re::StringID *a4@<X3>, void (*a5)(void *, const re::TypeInfo *, re::Allocator *, void *)@<X4>, void *a6@<X8>)
{
  v22[0] = 0x258C98EAAF29A10ALL;
  v22[1] = "CallbackSerializerAttribute";
  long long v13 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v22);
  if (v13)
  {
    uint64_t v14 = *v13;
    uint64_t v15 = this;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0xFFFFFFFFLL;
  }
  re::StringID::destroyString((re::StringID *)v22);
  unint64_t v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 32))(*((void *)this + 2), 8, 8);
  *(void *)unint64_t v16 = a2;
  unint64_t v17 = *((int *)a2 + 5);
  unint64_t v18 = *((int *)a2 + 6);
  v21[0] = 0;
  v21[1] = 0xFFFFFFFFLL;
  re::TypeBuilder::beginObjectType((uint64_t)v22, (uint64_t *)a3, 1, 1, v17, v18, (uint64_t)v21);
  re::TypeBuilder::setConstructor((uint64_t)v22, (uint64_t)a4);
  re::TypeBuilder::setDestructor((uint64_t)v22, (uint64_t)a5);
  re::TypeBuilder::setIsCallbackSerializer((uint64_t)v22, 1);
  v20[0] = v15;
  v20[1] = v14;
  re::TypeBuilder::addAttribute(v22, (uint64_t)v20, (uint64_t)v16, -1, 1);
  re::TypeBuilder::commitTo((re::TypeBuilder *)v22, this, a6);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v22, v19);
}

void re::internal::registerStructureType(re *a1, uint64_t a2, unint64_t a3, unsigned int a4)
{
  uint64_t v189 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo(a1, (re **)a2, v177);
  if (!LOBYTE(v177[0]))
  {
    uint64_t v7 = (StringID *)re::TypeRegistry::typeName(a1, (void *)a2);
    unint64_t v145 = v7;
    if (*(void *)a2
      && (uint64_t v7 = (StringID *)re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)a1 + 96, *(void *)(a2 + 8))) != 0)
    {
      int var0 = (int)v7[1].var0;
      if (!a3) {
        goto LABEL_5;
      }
    }
    else
    {
      int var0 = -1;
      if (!a3)
      {
LABEL_5:
        uint64_t v139 = (long long *)a2;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
LABEL_30:
        char v138 = 1;
LABEL_31:
        char v143 = 1;
        goto LABEL_32;
      }
    }
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v11 = a3;
    while (!v9 || !v10)
    {
      uint64_t v12 = *(unsigned int *)(v11 + 56);
      if (!v12) {
        goto LABEL_23;
      }
      long long v13 = *(const char ***)(v11 + 64);
      unint64_t v11 = 0;
      do
      {
        uint64_t v14 = *v13;
        int v15 = *(_DWORD *)*v13;
        if (v15 == 3)
        {
          uint64_t v10 = *v13;
        }
        else if (v15 == 2)
        {
          uint64_t v9 = (unsigned int *)*((void *)v14 + 1);
        }
        else if (v15 == 1 && *((_DWORD *)v14 + 10) == 3)
        {
          unint64_t v11 = *((void *)v14 + 2);
        }
        ++v13;
        --v12;
      }
      while (v12);
      if (!v11)
      {
LABEL_23:
        if (!v9)
        {
          uint64_t v139 = (long long *)a2;
          goto LABEL_30;
        }
        break;
      }
      if (!*(_DWORD *)(v11 + 16)) {
        return;
      }
    }
    uint64_t v139 = (long long *)a2;
    uint64_t v16 = *v9;
    if (!v16)
    {
LABEL_28:
      char v138 = 0;
      goto LABEL_31;
    }
    unint64_t v17 = (unint64_t *)(*((void *)v9 + 1) + 24);
    while (*(v17 - 2) != a3)
    {
      v17 += 5;
      if (!--v16) {
        goto LABEL_28;
      }
    }
    char v138 = 0;
    char v143 = 0;
    unint64_t v140 = *v17;
LABEL_32:
    unint64_t v18 = *(unsigned int *)(a3 + 56);
    uint64_t v19 = *(void *)(a3 + 64);
    unint64_t v137 = v9;
    if (v18)
    {
      int v141 = var0;
      uint64_t v20 = 0;
      uint64_t v21 = 0xFFFFFFFFLL;
      int v22 = *(void **)(a3 + 64);
      uint64_t v23 = *(unsigned int *)(a3 + 56);
      do
      {
        unint64_t v24 = (_DWORD *)*v22;
        if (*(_DWORD *)*v22 == 1 && v24[10] == 3)
        {
          uint64_t v25 = *((void *)v24 + 2);
          uint64_t v20 = *(void *)(v25 + 32);
          uint64_t v21 = *(void *)(v25 + 40);
        }
        ++v22;
        --v23;
      }
      while (v23);
      uint64_t v26 = 0;
      uint64_t v142 = 0;
      *(void *)&long long v180 = 0;
      *((void *)&v180 + 1) = 0xFFFFFFFFLL;
      unsigned int v27 = v141 - 1;
      while (1)
      {
        uint64_t v28 = *(void *)(v19 + 8 * v26);
        if (*(_DWORD *)v28 == 6 && !*(unsigned char *)(v28 + 40))
        {
          if (*(void *)(v28 + 8) == v141)
          {
            uint64_t v142 = *(void *)(v28 + 32);
            uint64_t v29 = *(void *)(v28 + 16);
            if (v29 != a3) {
              goto LABEL_52;
            }
            int v30 = *(char **)(a3 + 48);
            if (v30)
            {
              uint64_t v31 = *v30;
              if (*v30)
              {
                char v32 = v30[1];
                if (v32)
                {
                  double v33 = (unsigned __int8 *)(v30 + 2);
                  do
                  {
                    uint64_t v31 = 31 * v31 + v32;
                    int v34 = *v33++;
                    char v32 = v34;
                  }
                  while (v34);
                }
              }
            }
            else
            {
              uint64_t v31 = 0;
            }
            *(void *)&v166.int var0 = 2 * v31;
            v166.var1 = v30;
            re::TypeRegistry::typeID(a1, (const re::StringID *)&v166, v27, v177);
            long long v180 = v177[0];
            re::StringID::destroyString((re::StringID *)&v166);
            if (!(void)v180)
            {
              re::TypeRegistry::declareType((uint64_t)a1, 8, v145, v27, 1, v177);
              long long v180 = v177[0];
              long long v179 = v177[0];
              uint64_t v7 = (StringID *)re::internal::registerStructureType(a1, &v179, a3, a4);
            }
          }
          else
          {
            uint64_t v29 = *(void *)(v28 + 16);
            if (v29 != a3)
            {
LABEL_52:
              long long v180 = *(_OWORD *)(v29 + 32);
              re::TypeRegistry::typeInfo(a1, (re **)&v180, v177);
              if (!LOBYTE(v177[0]))
              {
                if (!(void)v180)
                {
                  StructureVersiouint64_t n = re::introspectionFindStructureVersion((re *)v29, v35);
                  uint64_t v37 = *(char **)(v29 + 48);
                  if (v37)
                  {
                    uint64_t v38 = *v37;
                    if (*v37)
                    {
                      char v39 = v37[1];
                      if (v39)
                      {
                        uint64_t v40 = (unsigned __int8 *)(v37 + 2);
                        do
                        {
                          uint64_t v38 = 31 * v38 + v39;
                          int v41 = *v40++;
                          char v39 = v41;
                        }
                        while (v41);
                      }
                    }
                  }
                  else
                  {
                    uint64_t v38 = 0;
                  }
                  *(void *)&v166.int var0 = 2 * v38;
                  v166.var1 = v37;
                  re::TypeRegistry::declareType((uint64_t)a1, 8, &v166, StructureVersion, 0, v177);
                  long long v180 = v177[0];
                  re::StringID::destroyString((re::StringID *)&v166);
                  *(_OWORD *)(v29 + 32) = v180;
                }
                long long v178 = v180;
                uint64_t v7 = (StringID *)re::internal::registerStructureType(a1, &v178, v29, a4);
              }
            }
          }
        }
        if (++v26 == v18)
        {
          int var0 = v141;
          goto LABEL_68;
        }
      }
    }
    uint64_t v20 = 0;
    uint64_t v142 = 0;
    *(void *)&long long v180 = 0;
    uint64_t v21 = 0xFFFFFFFFLL;
    *((void *)&v180 + 1) = 0xFFFFFFFFLL;
LABEL_68:
    unint64_t v43 = *(int *)(a3 + 20);
    unint64_t v44 = *(int *)(a3 + 24);
    v165[0] = v20;
    v165[1] = v21;
    re::TypeBuilder::beginObjectType((uint64_t)v177, (uint64_t *)v145, var0, a4, v43, v44, (uint64_t)v165);
    re::TypeBuilder::setConstructor((uint64_t)v177, *(void *)(a3 + 104));
    re::TypeBuilder::setDestructor((uint64_t)v177, *(void *)(a3 + 112));
    re::TypeBuilder::setRetain((uint64_t)v177, *(void (**)(void *))(a3 + 88));
    re::TypeBuilder::setRelease((uint64_t)v177, *(void (**)(void *))(a3 + 96));
    if ((void)v180)
    {
      long long v164 = v180;
      re::TypeBuilder::setPreviousVersion((unsigned __int8 *)v177, (uint64_t *)&v164);
    }
    if ((v143 & 1) == 0) {
      re::TypeBuilder::addCustomClassID((uint64_t)v177, v140);
    }
    if (!v20 && v10)
    {
      long long v163 = *(_OWORD *)(*((void *)v10 + 1) + 32);
      *(void *)&long long v184 = 0xC98E91CCDF0B5FC4;
      *((void *)&v184 + 1) = "customClassID";
      re::TypeBuilder::addObjectMemberCustomClassID((uint64_t)v177, (uint64_t)&v163, (uint64_t *)&v184, *((_DWORD *)v10 + 6));
      re::StringID::destroyString((re::StringID *)&v184);
    }
    if (v18)
    {
      uint64_t v46 = 0;
      a3 = (unint64_t)&v184 + 9;
      do
      {
        uint64_t v47 = *(void *)(v19 + 8 * v46);
        if (*(_DWORD *)v47 == 1)
        {
          switch(*(_DWORD *)(v47 + 40))
          {
            case 0:
              uint64_t v48 = *(unsigned int *)(v47 + 32);
              unint64_t v49 = *(char **)(v47 + 8);
              long long v162 = *(_OWORD *)(*(void *)(v47 + 16) + 32);
              if (v49)
              {
                uint64_t v50 = *v49;
                if (*v49)
                {
                  char v51 = v49[1];
                  if (v51)
                  {
                    int v52 = (unsigned __int8 *)(v49 + 2);
                    do
                    {
                      uint64_t v50 = 31 * v50 + v51;
                      int v53 = *v52++;
                      char v51 = v53;
                    }
                    while (v53);
                  }
                }
              }
              else
              {
                uint64_t v50 = 0;
              }
              *(void *)&long long v184 = 2 * v50;
              *((void *)&v184 + 1) = v49;
              re::TypeBuilder::addObjectMember((uint64_t)v177, v48, (uint64_t)&v162, (uint64_t *)&v184, *(_DWORD *)(v47 + 36));
              re::StringID::destroyString((re::StringID *)&v184);
              break;
            case 1:
              long long v181 = *(_OWORD *)(*(void *)(*(void *)(v47 + 16) + 48) + 32);
              StringID v161 = *(StringID *)(*(void *)(v47 + 48) + 32);
              var1 = v145->var1;
              re::makePrettyMemberName(*(re **)(v47 + 8), (re::DynamicString *)&v147);
              unint64_t v55 = (char *)&v148 + 1;
              if (v148) {
                unint64_t v55 = (char *)v149;
              }
              re::DynamicString::format((re::DynamicString *)"%s::%s", (re::DynamicString *)&v184, var1, v55);
              if (v147 && (v148 & 1) != 0) {
                (*(void (**)(void))(*v147 + 40))();
              }
              if (BYTE8(v184)) {
                uint64_t v56 = (const char *)v185;
              }
              else {
                uint64_t v56 = (char *)&v184 + 9;
              }
              re::TypeRegistry::makeStringID(a1, v56, (re::StringID *)&v147);
              StringID v159 = v161;
              long long v160 = v181;
              re::TypeBuilder::beginArrayType((uint64_t)&v166, (uint64_t *)&v147, (re **)&v160, (uint64_t)&v159, *(_DWORD *)(v47 + 64) - *(_DWORD *)(v47 + 36));
              re::TypeBuilder::commitTo((re::TypeBuilder *)&v166, a1, &v158);
              uint64_t v57 = *(unsigned int *)(v47 + 32);
              long long v157 = v158;
              unint64_t v58 = *(char **)(v47 + 8);
              if (v58)
              {
                uint64_t v59 = *v58;
                if (*v58)
                {
                  char v60 = v58[1];
                  if (v60)
                  {
                    char v61 = (unsigned __int8 *)(v58 + 2);
                    do
                    {
                      uint64_t v59 = 31 * v59 + v60;
                      int v62 = *v61++;
                      char v60 = v62;
                    }
                    while (v62);
                  }
                }
              }
              else
              {
                uint64_t v59 = 0;
              }
              v156[0] = 2 * v59;
              v156[1] = (uint64_t)v58;
              re::TypeBuilder::addObjectMember((uint64_t)v177, v57, (uint64_t)&v157, v156, *(_DWORD *)(v47 + 36));
              uint64_t v73 = (re::StringID *)v156;
              goto LABEL_119;
            case 2:
              long long v181 = *(_OWORD *)(*(void *)(v47 + 48) + 32);
              uint64_t v63 = *(void *)(*(void *)(*(void *)(v47 + 16) + 48) + 40);
              int v64 = v145->var1;
              re::makePrettyMemberName(*(re **)(v47 + 8), (re::DynamicString *)&v147);
              uint64_t v65 = (char *)&v148 + 1;
              if (v148) {
                uint64_t v65 = (char *)v149;
              }
              uint64_t v136 = v64;
              uint64_t v10 = "%s::%s";
              re::DynamicString::format((re::DynamicString *)"%s::%s", (re::DynamicString *)&v184, v136, v65);
              if (v147 && (v148 & 1) != 0) {
                (*(void (**)(void))(*v147 + 40))();
              }
              if (BYTE8(v184)) {
                unint64_t v66 = (const char *)v185;
              }
              else {
                unint64_t v66 = (char *)&v184 + 9;
              }
              re::TypeRegistry::makeStringID(a1, v66, (re::StringID *)&v147);
              int v168 = -1;
              memset(v169, 0, sizeof(v169));
              long long v170 = 0u;
              uint64_t v171 = 0xFFFFFFFFLL;
              int v172 = 1;
              uint64_t v173 = 0xFFFFFFFFLL;
              char v174 = 1;
              uint64_t v175 = 0xFFFFFFFFLL;
              int v176 = 0;
              *(unsigned char *)&v166.int var0 = 9;
              re::StringID::operator=((unint64_t *)&v166.var1, (uint64_t *)&v147);
              int v167 = 1;
              *(void *)&v169[1] = 0x800000008;
              *(void *)((char *)&v170 + 4) = 0;
              *(void *)&v169[3] = 0;
              *(void *)&v169[5] = 0;
              int v172 = -1;
              uint64_t v173 = v63;
              char v174 = 1;
              long long v155 = v181;
              re::TypeBuilder::addCustomClassIDForPointer((uint64_t)&v166, (uint64_t)&v155, *(_DWORD *)(v47 + 64) - *(_DWORD *)(v47 + 36));
              re::TypeBuilder::commitTo((re::TypeBuilder *)&v166, a1, &v161);
              uint64_t v67 = *(unsigned int *)(v47 + 32);
              StringID v154 = v161;
              unint64_t v68 = *(char **)(v47 + 8);
              if (v68)
              {
                uint64_t v69 = *v68;
                if (*v68)
                {
                  char v70 = v68[1];
                  if (v70)
                  {
                    uint64_t v71 = (unsigned __int8 *)(v68 + 2);
                    do
                    {
                      uint64_t v69 = 31 * v69 + v70;
                      int v72 = *v71++;
                      char v70 = v72;
                    }
                    while (v72);
                  }
                }
              }
              else
              {
                uint64_t v69 = 0;
              }
              *(void *)&long long v158 = 2 * v69;
              *((void *)&v158 + 1) = v68;
              re::TypeBuilder::addObjectMember((uint64_t)v177, v67, (uint64_t)&v154, (uint64_t *)&v158, *(_DWORD *)(v47 + 36));
              uint64_t v73 = (re::StringID *)&v158;
LABEL_119:
              re::StringID::destroyString(v73);
              re::StringID::destroyString((re::StringID *)&v147);
              if (void)v184 && (BYTE8(v184)) {
                (*(void (**)(void))(*(void *)v184 + 40))();
              }
              break;
            case 3:
              break;
            default:
              re::internal::assertLog((re::internal *)4, v45, "assertion failure: '%s' (%s:line %i) Unexpected IntrospectionMemberType.", "!\"Unreachable code\"", "registerStructureType", 1835);
              _os_crash();
              __break(1u);
              JUMPOUT(0x233D8B1CCLL);
          }
        }
        ++v46;
      }
      while (v46 != v18);
      uint64_t v74 = 0;
      uint64_t v75 = v142;
      do
      {
        uint64_t v76 = *(void *)(v19 + 8 * v74);
        if (*(_DWORD *)v76 == 5)
        {
          uint64_t v77 = *(char **)(v76 + 16);
          if (v77)
          {
            uint64_t v78 = *v77;
            if (*v77)
            {
              char v79 = v77[1];
              if (v79)
              {
                unint64_t v80 = (unsigned __int8 *)(v77 + 2);
                do
                {
                  uint64_t v78 = 31 * v78 + v79;
                  int v81 = *v80++;
                  char v79 = v81;
                }
                while (v81);
              }
            }
          }
          else
          {
            uint64_t v78 = 0;
          }
          *(void *)&long long v184 = 2 * v78;
          *((void *)&v184 + 1) = v77;
          unint64_t v82 = *(char **)(v76 + 8);
          if (v82)
          {
            uint64_t v83 = *v82;
            if (*v82)
            {
              char v84 = v82[1];
              if (v84)
              {
                unint64_t v85 = (unsigned __int8 *)(v82 + 2);
                do
                {
                  uint64_t v83 = 31 * v83 + v84;
                  int v86 = *v85++;
                  char v84 = v86;
                }
                while (v86);
              }
            }
          }
          else
          {
            uint64_t v83 = 0;
          }
          unint64_t v147 = (uint64_t *)(2 * v83);
          unint64_t v148 = (unint64_t)v82;
          re::TypeBuilder::addObjectMemberRenaming((re::TypeBuilder *)v177, (const re::StringID *)&v184, (const re::StringID *)&v147);
          re::StringID::destroyString((re::StringID *)&v147);
          re::StringID::destroyString((re::StringID *)&v184);
        }
        ++v74;
      }
      while (v74 != v18);
      uint64_t v87 = 0;
      BOOL v88 = 1;
      do
      {
        unint64_t v89 = *(_DWORD **)(v19 + 8 * v87);
        if (*v89 == 4 && v89[1] == 1) {
          break;
        }
        BOOL v88 = ++v87 < v18;
      }
      while (v18 != v87);
    }
    else
    {
      BOOL v88 = 0;
      uint64_t v75 = v142;
    }
    re::TypeBuilder::setHideObjectWithOneMember((uint64_t)v177, v88);
    if (v75)
    {
      *(void *)&long long v184 = 0xAE8345F9D646D604;
      *((void *)&v184 + 1) = "ComplexVersioningAttribute";
      uint64_t v90 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, &v184);
      if (v90)
      {
        uint64_t v91 = *v90;
        uint64_t v92 = a1;
      }
      else
      {
        uint64_t v92 = 0;
        uint64_t v91 = 0xFFFFFFFFLL;
      }
      re::StringID::destroyString((re::StringID *)&v184);
      uint64_t v93 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(**((void **)a1 + 2) + 32))(*((void **)a1 + 2), 8, 8);
      void *v93 = v75;
      v153[0] = v92;
      v153[1] = v91;
      re::TypeBuilder::addAttribute(v177, (uint64_t)v153, (uint64_t)v93, -1, 1);
    }
    long long v152 = *v139;
    re::TypeBuilder::commitTo((unsigned __int8 *)v177, (uint64_t *)&v152);
    if (v138) {
      goto LABEL_235;
    }
    uint64_t v151 = 0;
    unint64_t v148 = 0;
    unint64_t v149 = 0;
    int v150 = 0;
    re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(&v147, 0);
    ++v150;
    unint64_t v95 = (long long *)v137;
    unint64_t v96 = *v137;
    if (v96)
    {
      unint64_t v97 = 0;
      unint64_t v98 = 40;
      do
      {
        uint64_t v99 = *((void *)v137 + 1);
        if (*(_DWORD *)(v99 + 40 * v97 + 32))
        {
          re::internal::assertLog((re::internal *)4, v94, "assertion failure: '%s' (%s:line %i) ", "polymorphicType.basePointerOffset == 0", "addPolymorphicLeaveTypes", 1545);
          _os_crash();
          __break(1u);
LABEL_241:
          *(void *)&v161.int var0 = 0;
          long long v187 = 0u;
          long long v188 = 0u;
          long long v185 = 0u;
          long long v186 = 0u;
          long long v184 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v181) = 136315906;
          *(void *)((char *)v95 + 4) = "operator[]";
          WORD6(v181) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 789;
          __int16 v182 = 2048;
          *(void *)((char *)v95 + 2re::InputManager::notify(8, 0, 0, 0) = v98;
          __int16 v183 = 2048;
          *(void *)((char *)v95 + 3re::InputManager::notify(8, 0, 0, 0) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_242:
          *(void *)&v161.int var0 = 0;
          long long v187 = 0u;
          long long v188 = 0u;
          long long v185 = 0u;
          long long v186 = 0u;
          long long v184 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v181) = 136315906;
          *(void *)((char *)v95 + 4) = "operator[]";
          WORD6(v181) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 789;
          __int16 v182 = 2048;
          *(void *)((char *)v95 + 2re::InputManager::notify(8, 0, 0, 0) = a3;
          __int16 v183 = 2048;
          *(void *)((char *)v95 + 3re::InputManager::notify(8, 0, 0, 0) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_243:
          *(void *)&long long v158 = 0;
          long long v187 = 0u;
          long long v188 = 0u;
          long long v185 = 0u;
          long long v186 = 0u;
          long long v184 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v181) = 136315906;
          *(void *)((char *)v95 + 4) = "removeStableAt";
          WORD6(v181) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 969;
          __int16 v182 = 2048;
          *(void *)((char *)v95 + 2re::InputManager::notify(8, 0, 0, 0) = v98;
          __int16 v183 = 2048;
          *(void *)((char *)v95 + 3re::InputManager::notify(8, 0, 0, 0) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_244:
          *(void *)&v161.int var0 = 0;
          long long v187 = 0u;
          long long v188 = 0u;
          long long v185 = 0u;
          long long v186 = 0u;
          long long v184 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v181) = 136315906;
          *(void *)((char *)v95 + 4) = "insert";
          WORD6(v181) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 855;
          __int16 v182 = 2048;
          *(void *)((char *)v95 + 2re::InputManager::notify(8, 0, 0, 0) = a3;
          __int16 v183 = 2048;
          *(void *)((char *)v95 + 3re::InputManager::notify(8, 0, 0, 0) = v98;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        *(void *)&long long v184 = 0;
        uint64_t v100 = *(void *)(v99 + 40 * v97 + 8);
        *(void *)&long long v184 = v100;
        if (v149)
        {
          uint64_t v101 = 8 * v149;
          unint64_t v102 = v151;
          while (*v102 != v100)
          {
            ++v102;
            v101 -= 8;
            if (!v101)
            {
              unint64_t v102 = &v151[v149];
              break;
            }
          }
        }
        else
        {
          unint64_t v102 = v151;
        }
        if (v149 == v102 - v151)
        {
          re::DynamicArray<re::IntrospectionStructure const*>::add(&v147, &v184);
          unint64_t v96 = *v137;
        }
        ++v97;
      }
      while (v97 < v96);
    }
    unint64_t v95 = &v181;
    unint64_t v42 = v149;
    unint64_t v98 = v149 - 1;
    if ((uint64_t)(v149 - 1) < 0)
    {
LABEL_177:
      if (v42)
      {
        a3 = 0;
        unint64_t v108 = v151;
        do
        {
          if (v42 <= a3) {
            goto LABEL_242;
          }
          uint64_t v109 = v108[a3];
          while (1)
          {
            unint64_t v108 = v151;
            uint64_t v110 = v151[a3];
            uint64_t v111 = *(unsigned int *)(v110 + 56);
            if (!v111) {
              goto LABEL_210;
            }
            __int16 v112 = *(void **)(v110 + 64);
            while (1)
            {
              unint64_t v113 = (_DWORD *)*v112;
              if (*(_DWORD *)*v112 == 1 && v113[10] == 3) {
                break;
              }
              ++v112;
              if (!--v111) {
                goto LABEL_209;
              }
            }
            uint64_t v114 = *((void *)v113 + 2);
            if (!v114) {
              break;
            }
            unint64_t v115 = 0;
            uint64_t v116 = 8 * v42;
            uint64_t v117 = &v151[v42];
            while (v151[v115 / 8] != v114)
            {
              v115 += 8;
              if (v116 == v115)
              {
                __int16 v118 = &v151[v42];
                goto LABEL_193;
              }
            }
            __int16 v118 = &v151[v115 / 8];
LABEL_193:
            if (v42 != v118 - v151) {
              break;
            }
            unint64_t v119 = 0;
            while (v151[v119 / 8] != v114)
            {
              v119 += 8;
              if (v116 == v119) {
                goto LABEL_199;
              }
            }
            uint64_t v117 = &v151[v119 / 8];
LABEL_199:
            if (v42 != v117 - v151) {
              break;
            }
            unint64_t v98 = v42 + 1;
            if (v42 + 1 <= a3) {
              goto LABEL_244;
            }
            if (v42 >= v148)
            {
              re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(&v147, v42 + 1);
              unint64_t v42 = v149;
              unint64_t v108 = v151;
            }
            uint64_t v120 = &v108[v42];
            if (v42 > a3)
            {
              *uint64_t v120 = *(v120 - 1);
              __int16 v121 = v151;
              uint64_t v94 = (uint64_t)&v151[a3];
              uint64_t v122 = (uint64_t)&v151[v42 - 1];
              if (v122 != v94)
              {
                memmove((void *)(v94 + 8), (const void *)v94, v122 - v94);
                __int16 v121 = v151;
                unint64_t v42 = v149;
              }
              uint64_t v120 = &v121[a3];
            }
            *uint64_t v120 = v114;
            unint64_t v149 = ++v42;
            ++v150;
            if (v42 <= a3) {
              goto LABEL_242;
            }
          }
LABEL_209:
          if (!v42) {
            goto LABEL_232;
          }
LABEL_210:
          uint64_t v123 = 0;
          unint64_t v124 = &v151[v42];
          while (v151[v123] != v109)
          {
            if (v42 == ++v123)
            {
              __int16 v125 = &v151[v42];
              goto LABEL_215;
            }
          }
          __int16 v125 = &v151[v123];
LABEL_215:
          uint64_t v126 = v125 - v151;
          if (v126 != v42) {
            uint64_t v10 = (const char *)v126;
          }
          a3 = (unint64_t)(v10 + 1);
        }
        while ((unint64_t)(v10 + 1) < v42);
        do
        {
          uint64_t v133 = *v108;
          if (!*(_DWORD *)(*v108 + 16)) {
            break;
          }
          long long v181 = *(_OWORD *)(v133 + 32);
          re::TypeRegistry::typeInfo(a1, (re **)&v181, &v184);
          if (!(_BYTE)v184)
          {
            if (!(void)v181)
            {
              unsigned int v127 = re::introspectionFindStructureVersion((re *)v133, (const re::IntrospectionStructure *)v94);
              long long v128 = *(char **)(v133 + 48);
              if (v128)
              {
                uint64_t v129 = *v128;
                if (*v128)
                {
                  char v130 = v128[1];
                  if (v130)
                  {
                    long long v131 = (unsigned __int8 *)(v128 + 2);
                    do
                    {
                      uint64_t v129 = 31 * v129 + v130;
                      int v132 = *v131++;
                      char v130 = v132;
                    }
                    while (v132);
                  }
                }
              }
              else
              {
                uint64_t v129 = 0;
              }
              *(void *)&v161.int var0 = 2 * v129;
              v161.var1 = v128;
              re::TypeRegistry::declareType((uint64_t)a1, 8, &v161, v127, 0, &v184);
              long long v181 = v184;
              re::StringID::destroyString((re::StringID *)&v161);
              *(_OWORD *)(v133 + 32) = v181;
            }
            long long v146 = v181;
            re::internal::registerStructureType(a1, &v146, v133, a4);
          }
          ++v108;
        }
        while (v108 != v124);
      }
LABEL_232:
      unint64_t v134 = v147;
      if (!v147) {
        goto LABEL_235;
      }
      uint64_t v94 = (uint64_t)v151;
      if (!v151) {
        goto LABEL_235;
      }
    }
    else
    {
      while (1)
      {
        unint64_t v42 = v149;
        if (v149 <= v98) {
          goto LABEL_241;
        }
        uint64_t v94 = (uint64_t)v151;
        uint64_t v103 = v151[v98];
        if (!*(_DWORD *)(v103 + 16)) {
          break;
        }
        StringID v161 = *(StringID *)(v103 + 32);
        re::TypeRegistry::typeInfo(a1, (re **)&v161, &v184);
        if ((_BYTE)v184)
        {
          unint64_t v42 = v149;
          if (v149 <= v98) {
            goto LABEL_243;
          }
          unint64_t v104 = v149 - 1;
          if (v149 - 1 > v98)
          {
            unint64_t v105 = (char *)&v151[v98];
            uint64_t v94 = (uint64_t)(v105 + 8);
            uint64_t v106 = (char *)&v151[v149];
            if (v105 + 8 != v106)
            {
              memmove(v105, (const void *)v94, (size_t)&v106[-v94]);
              unint64_t v104 = v149 - 1;
            }
          }
          unint64_t v149 = v104;
          ++v150;
        }
        if ((uint64_t)v98-- <= 0)
        {
          unint64_t v42 = v149;
          goto LABEL_177;
        }
      }
      unint64_t v134 = v147;
      if (!v147) {
        goto LABEL_235;
      }
    }
    (*(void (**)(uint64_t *))(*v134 + 40))(v134);
LABEL_235:
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v166, v94);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v177, v135);
  }
}

void re::IntrospectionStructure::~IntrospectionStructure(re::IntrospectionStructure *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionBasic::~IntrospectionBasic(re::IntrospectionBasic *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionBasic::childInfoCount(re::IntrospectionBasic *this)
{
  return 0;
}

void re::IntrospectionBasic::childInfo(re::IntrospectionBasic *this, uint64_t a2)
{
}

void re::IntrospectionDataArrayBase::~IntrospectionDataArrayBase(re::IntrospectionDataArrayBase *this)
{
  *(void *)this = &unk_26E715D40;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E715D40;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionDataArrayBase::childInfoCount(re::IntrospectionDataArrayBase *this)
{
  return 1;
}

uint64_t re::IntrospectionDataArrayBase::childInfo(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
  if (!a2) {
    return *((void *)this + 6);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 712);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::IntrospectionDataArrayBase::init(re::IntrospectionDataArrayBase *this, uint64_t a2, re::Allocator *a3)
{
}

void re::IntrospectionDataArrayBase::addElement(uint64_t a1, uint64_t a2)
{
}

void re::IntrospectionDataArrayBase::size(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
}

void re::IntrospectionDataArrayBase::begin(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
}

void re::IntrospectionDataArrayBase::end(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
}

void re::IntrospectionDataArrayBase::elementAt(uint64_t a1, uint64_t a2)
{
}

void re::IntrospectionDynamicString::~IntrospectionDynamicString(re::IntrospectionDynamicString *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionDynamicString::childInfoCount(re::IntrospectionDynamicString *this)
{
  return 1;
}

uint64_t re::IntrospectionDynamicString::childInfo(re::IntrospectionDynamicString *this, uint64_t a2)
{
  if (a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 827);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v2 = &re::mtl::introspect_BlendOperation(BOOL)::enumTable;
  }
  unint64_t v2 = (void *)&re::mtl::introspect_BlendOperation(BOOL)::enumTable;
  if (v4)
  {
    re::introspect_char(0, v5);
    re::introspect<char>(void)::info = (uint64_t)&re::introspect_char(BOOL)::info;
    unint64_t v2 = (void *)&re::mtl::introspect_BlendOperation(BOOL)::enumTable;
  }
  return v2[72];
}

void re::IntrospectionEnum::~IntrospectionEnum(re::IntrospectionEnum *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionCallbackSerializer::~IntrospectionCallbackSerializer(re::IntrospectionCallbackSerializer *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionCallbackSerializer::childInfoCount(re::IntrospectionCallbackSerializer *this)
{
  return 0;
}

void re::IntrospectionCallbackSerializer::childInfo(re::IntrospectionCallbackSerializer *this, uint64_t a2)
{
}

void re::IntrospectionStringID::~IntrospectionStringID(re::IntrospectionStringID *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionStringID::childInfoCount(re::IntrospectionStringID *this)
{
  return 0;
}

void re::IntrospectionStringID::childInfo(re::IntrospectionStringID *this, uint64_t a2)
{
}

void *re::DynamicArray<re::IntrospectionStructure const*>::add(void *this, void *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void *re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_OWORD *std::__tree<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::__map_value_compare<re::DowngradeCode,std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::greater<re::DowngradeCode>,true>,std::allocator<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>>::__emplace_multi<std::pair<re::DowngradeCode const,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>(uint64_t **a1, _OWORD *a2)
{
  unint64_t v4 = operator new(0x30uLL);
  uint64_t v5 = v4;
  v4[2] = *a2;
  uint64_t v6 = a1 + 1;
  unint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (*((_DWORD *)v4 + 8) <= *((_DWORD *)v7 + 8)) {
          break;
        }
        unint64_t v7 = (uint64_t *)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      unint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    uint64_t v8 = v6 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(a1, (uint64_t)v6, v8, (uint64_t *)v4);
  return v5;
}

void *re::DynamicArray<re::IntrospectionPolymorphicType>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (void *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[5 * v9];
        unint64_t v11 = v7;
        do
        {
          void *v11 = *v8;
          void v11[2] = 0;
          void v11[2] = v8[2];
          uint64_t v8[2] = 0;
          uint64_t v12 = v11[1];
          uint64_t v14 = v8[1];
          uint64_t v13 = (uint64_t)(v8 + 1);
          v11[1] = v14;
          *(void *)uint64_t v13 = v12;
          uint64_t v15 = *(void *)(v13 + 16);
          *((_DWORD *)v11 + 8) = *(_DWORD *)(v13 + 24);
          v11[3] = v15;
          re::SerializedReference<re::IntrospectionBase const*>::reset(v13);
          uint64_t v8 = (void *)(v13 + 32);
          v11 += 5;
        }
        while (v8 != v10);
        uint64_t v8 = (void *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::TypeRegistry *re::TypeRegistry::TypeRegistry(re::TypeRegistry *this, re::Allocator *a2)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)(v4 + 16) = a2;
  *(void *)uint64_t v4 = &unk_26E715FA8;
  *(_DWORD *)(v4 + 24) = 0;
  *(_OWORD *)(v4 + 4re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_DWORD *)(v4 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(v4 + 84) = 0x1FFFFFFFFLL;
  *(_OWORD *)(v4 + 104) = 0u;
  *(void *)(v4 + 96) = 0;
  uint64_t v5 = (void *)(v4 + 96);
  *(_DWORD *)(v4 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_DWORD *)(v4 + 144) = 0;
  *(void *)(v4 + 148) = 0x1FFFFFFFFLL;
  *(void *)(v4 + 176) = 0;
  *(_DWORD *)(v4 + 184) = 0;
  *(_OWORD *)(v4 + 16re::InputManager::notify(8, 0, 0, 0) = 0u;
  uint64_t v6 = (void *)(v4 + 160);
  uint64_t v24 = v4 + 200;
  *(_OWORD *)(v4 + 22re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = 0u;
  *(_OWORD *)(v4 + 208) = 0u;
  *(void *)(v4 + 236) = 0x7FFFFFFFLL;
  *(_DWORD *)(v4 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = 0;
  *(void *)(v4 + 264) = 0;
  *(_OWORD *)(v4 + 248) = 0u;
  unint64_t v7 = (void *)(v4 + 248);
  uint64_t v8 = (void *)(v4 + 328);
  uint64_t v13 = (void *)(v4 + 288);
  uint64_t v14 = (void *)(v4 + 368);
  uint64_t v9 = (void *)(v4 + 408);
  uint64_t v16 = (void *)(v4 + 448);
  uint64_t v10 = (void *)(v4 + 488);
  uint64_t v19 = (void *)(v4 + 528);
  uint64_t v21 = (void *)(v4 + 608);
  uint64_t v23 = (void *)(v4 + 688);
  uint64_t v20 = v4 + 768;
  *(_DWORD *)(v4 + re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312) = 0;
  *(_OWORD *)(v4 + 28re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 296) = 0u;
  *(_DWORD *)(v4 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = 0;
  *(_OWORD *)(v4 + 32re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_DWORD *)(v4 + 392) = 0;
  *(_OWORD *)(v4 + 36re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 376) = 0u;
  *(_DWORD *)(v4 + 432) = 0;
  *(_OWORD *)(v4 + 40re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_DWORD *)(v4 + 472) = 0;
  *(_OWORD *)(v4 + 44re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 456) = 0u;
  *(_DWORD *)(v4 + 512) = 0;
  *(_OWORD *)(v4 + 48re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 496) = 0u;
  *(_DWORD *)(v4 + 552) = 0;
  *(_OWORD *)(v4 + 52re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 536) = 0u;
  *(_DWORD *)(v4 + 592) = 0;
  *(_OWORD *)(v4 + 56re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 576) = 0u;
  *(_DWORD *)(v4 + 632) = 0;
  uint64_t v15 = (void *)(v4 + 568);
  *(_OWORD *)(v4 + 60re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 616) = 0u;
  *(_DWORD *)(v4 + 672) = 0;
  *(_OWORD *)(v4 + 64re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 656) = 0u;
  *(_DWORD *)(v4 + 712) = 0;
  unint64_t v17 = (void *)(v4 + 648);
  unint64_t v18 = (void *)(v4 + 728);
  *(_OWORD *)(v4 + 68re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 696) = 0u;
  *(_DWORD *)(v4 + 752) = 0;
  *(_OWORD *)(v4 + 72re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 736) = 0u;
  *(_OWORD *)(v4 + 788) = 0u;
  *(_OWORD *)(v4 + 76re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(v4 + 776) = 0u;
  *(void *)(v4 + 804) = 0x7FFFFFFFLL;
  int v22 = (void *)(v4 + 816);
  *(_DWORD *)(v4 + 84re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(v4 + 832) = 0;
  *(_OWORD *)(v4 + 816) = 0u;
  *(void *)(v4 + 856) = 0;
  *(void *)(v4 + 848) = 0;
  *(void *)(v4 + 32) = a2;
  unint64_t v11 = (void *)(v4 + 32);
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(v4 + 32), 0);
  ++*((_DWORD *)this + 14);
  *((_DWORD *)this + 19) = 1024;
  re::DataArray<re::internal::TypeInfoIndex>::allocBlock(v11);
  *uint64_t v5 = a2;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity(v5, 0);
  ++*((_DWORD *)this + 30);
  *((_DWORD *)this + 35) = 1024;
  re::DataArray<MetalHeap::TextureEntry>::allocBlock(v5);
  *uint64_t v6 = a2;
  re::DynamicArray<re::StringID>::setCapacity(v6, 0);
  ++*((_DWORD *)this + 46);
  void *v7 = a2;
  re::DynamicArray<re::PipelineStateCacheKey>::setCapacity(v7, 0);
  ++*((_DWORD *)this + 68);
  *((void *)this + 36) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v13, 0);
  ++*((_DWORD *)this + 78);
  *((void *)this + 41) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v8, 0);
  ++*((_DWORD *)this + 88);
  *((void *)this + 46) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v14, 0);
  ++*((_DWORD *)this + 98);
  *((void *)this + 51) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v9, 0);
  ++*((_DWORD *)this + 108);
  *((void *)this + 56) = a2;
  re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(v16, 0);
  ++*((_DWORD *)this + 118);
  *((void *)this + 61) = a2;
  re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity(v10, 0);
  ++*((_DWORD *)this + 128);
  *((void *)this + 66) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v19, 0);
  ++*((_DWORD *)this + 138);
  *((void *)this + 71) = a2;
  re::DynamicArray<float *>::setCapacity(v15, 0);
  ++*((_DWORD *)this + 148);
  *((void *)this + 76) = a2;
  re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v21, 0);
  ++*((_DWORD *)this + 158);
  *((void *)this + 81) = a2;
  re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v17, 0);
  ++*((_DWORD *)this + 168);
  *((void *)this + 86) = a2;
  re::DynamicArray<re::BlendParameterInputNode>::setCapacity(v23, 0);
  ++*((_DWORD *)this + 178);
  *((void *)this + 91) = a2;
  re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(v18, 0);
  ++*((_DWORD *)this + 188);
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(v24, (uint64_t)a2, 3);
  re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init(v20, (uint64_t)a2, 3);
  *((void *)this + 102) = a2;
  re::DynamicArray<float *>::setCapacity(v22, 0);
  ++*((_DWORD *)this + 210);
  return this;
}

void re::TypeRegistry::~TypeRegistry(re::TypeRegistry *this)
{
  uint64_t v21 = (uint64_t *)((char *)this + 768);
  uint64_t v2 = *((unsigned int *)this + 200);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 98) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 14;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    unsigned int v7 = *((_DWORD *)this + 200);
    do
    {
      uint64_t v8 = *((void *)this + 98);
      if (*(unsigned char *)(v8 + 56 * v6 + 48))
      {
        uint64_t v9 = v8 + 56 * v6;
        re::TypeRegistry::typeInfo(this, *(void *)(v9 + 16), v22);
        re::TypeInfo::releaseInstance((re::TypeInfo *)&v23, *(void **)(v9 + 40), *((re::Allocator **)this + 2), 0);
        unsigned int v7 = *((_DWORD *)this + 200);
      }
      if (v7 <= (int)v3 + 1) {
        unsigned int v10 = v3 + 1;
      }
      else {
        unsigned int v10 = v7;
      }
      while (1)
      {
        uint64_t v6 = (v3 + 1);
        if (v10 - 1 == v3) {
          break;
        }
        LODWORD(v3) = v3 + 1;
        unsigned int v11 = v6;
        if ((*(_DWORD *)(*((void *)this + 98) + 56 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_18;
        }
      }
      unsigned int v11 = v10;
LABEL_18:
      LODWORD(v3) = v11;
    }
    while (v2 != v11);
  }
  uint64_t v20 = (char *)this + 32;
  re::DataArray<re::internal::TypeInfoIndex>::deinit((uint64_t)this + 32);
  uint64_t v19 = (char *)this + 96;
  re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit((uint64_t)this + 96);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 160);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 248);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 288);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 328);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 368);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 408);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 448);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 488);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 528);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 568);
  re::DynamicArray<re::internal::ObjectTypeInfo>::deinit((uint64_t)this + 608);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 648);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 688);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 728);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 25);
  v12.n128_f64[0] = re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v21);
  uint64_t v13 = *((void *)this + 104);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)*((void *)this + 106);
    uint64_t v15 = 8 * v13;
    do
    {
      uint64_t v16 = *v14++;
      (*(void (**)(void, uint64_t, __n128))(**((void **)this + 2) + 40))(*((void *)this + 2), v16, v12);
      v15 -= 8;
    }
    while (v15);
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 816);
  unint64_t v17 = (uint64_t *)*((void *)this + 107);
  if (v17)
  {
    uint64_t v18 = *((void *)this + 2);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 33);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 30);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 27);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 24);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 21);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 18);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 15);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 12);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 9);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 6);
    re::FixedArray<CoreIKTransform>::deinit(v17 + 3);
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v18 + 40))(v18, v17);
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 816);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v21);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 728);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 688);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 648);
  re::DynamicArray<re::internal::ObjectTypeInfo>::deinit((uint64_t)this + 608);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 568);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 528);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 488);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 448);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 408);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 368);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 328);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 288);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 248);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 25);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 160);
  re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit((uint64_t)v19);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v19);
  re::DataArray<re::internal::TypeInfoIndex>::deinit((uint64_t)v20);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v20);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::TypeRegistry::~TypeRegistry(this);
  JUMPOUT(0x237DBCBD0);
}

_DWORD *re::TypeRegistry::typeInfo@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)(a1 + 4), a2);
  if (result && (unint64_t v7 = *result & 0xFFFFFF, (*result & 0xFFFFFF) != 0xFFFFFF))
  {
    int v8 = HIBYTE(*result);
    switch(v8)
    {
      case 1:
        if (a1[33] <= v7)
        {
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_28:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_29:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_30:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_31:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_32:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_33:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_34:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_35:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v9 = a1[35] + 72 * v7;
        goto LABEL_25;
      case 2:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[38] <= (unint64_t)v7) {
          goto LABEL_28;
        }
        uint64_t v11 = a1[40];
        goto LABEL_19;
      case 3:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[48] <= (unint64_t)v7) {
          goto LABEL_29;
        }
        uint64_t v11 = a1[50];
        goto LABEL_19;
      case 4:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[53] <= (unint64_t)v7) {
          goto LABEL_30;
        }
        uint64_t v11 = a1[55];
        goto LABEL_19;
      case 5:
        if (a1[58] <= (unint64_t)v7) {
          goto LABEL_31;
        }
        uint64_t v9 = a1[60] + ((unint64_t)v7 << 7);
        goto LABEL_25;
      case 6:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[63] <= (unint64_t)v7) {
          goto LABEL_32;
        }
        uint64_t v11 = a1[65];
        unsigned int v12 = 160;
        break;
      case 7:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[68] <= (unint64_t)v7) {
          goto LABEL_33;
        }
        uint64_t v11 = a1[70];
LABEL_19:
        unsigned int v12 = 96;
        break;
      case 8:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[78] <= (unint64_t)v7) {
          goto LABEL_34;
        }
        uint64_t v11 = a1[80];
        unsigned int v12 = 152;
        break;
      case 9:
        unsigned int v10 = *result & 0xFFFFFF;
        if (a1[93] <= (unint64_t)v7) {
          goto LABEL_35;
        }
        uint64_t v11 = a1[95];
        unsigned int v12 = 104;
        break;
      default:
        re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "typeInfo", 310);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D8D0F8);
    }
    uint64_t v9 = v11 + v10 * (unint64_t)v12;
LABEL_25:
    re::TypeInfo::TypeInfo((uint64_t)&v13, (uint64_t)a1, v8, v9);
    *a3 = 1;
    return (_DWORD *)re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)&v13);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::deinit(uint64_t result)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(result + 44)) {
    return result;
  }
  uint64_t v2 = (void *)result;
  uint64_t v11 = (void *)result;
  if (*(_DWORD *)(result + 40))
  {
    LODWORD(v12) = 0;
    if (!*(void *)(result + 16)) {
      goto LABEL_32;
    }
    uint64_t v3 = (void *)result;
    if (!**(_DWORD **)(*(void *)(result + 32) + 8))
    {
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      uint64_t v3 = v11;
    }
  }
  else
  {
    LODWORD(v12) = -1;
    uint64_t v3 = (void *)result;
  }
  uint64_t v11 = v3;
  uint64_t v4 = (unsigned __int16)v12;
  if (v3 != v2 || ((unsigned __int16)v12 == 0xFFFFLL ? (BOOL v5 = (v12 & 0xFFFF0000) == 4294901760) : (BOOL v5 = 0), !v5))
  {
    unint64_t v6 = WORD1(v12);
    do
    {
      unint64_t v7 = v3[2];
      if (v7 <= v6) {
        goto LABEL_31;
      }
      re::DataArray<re::internal::TypeInfoIndex>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(void *)(v3[4] + 16 * v6 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v6 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      uint64_t v3 = v11;
      uint64_t v4 = (unsigned __int16)v12;
      unint64_t v6 = WORD1(v12);
    }
    while (v11 != v2 || (unsigned __int16)v12 != 0xFFFFLL || WORD1(v12) != 0xFFFFLL);
  }
  unint64_t v8 = v2[2];
  unint64_t v6 = v8 - 1;
  if (v8 == 1) {
    goto LABEL_26;
  }
  unint64_t v7 = 16 * v8 - 16;
  do
  {
    if (v8 <= v6)
    {
      uint64_t v11 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 789;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_30:
      uint64_t v11 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "removeAt";
      __int16 v16 = 1024;
      int v17 = 931;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_31:
      uint64_t v13 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 797;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_32:
      uint64_t v13 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 797;
      __int16 v18 = 2048;
      unint64_t v19 = 0;
      __int16 v20 = 2048;
      unint64_t v21 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v9 = (void *)(v2[4] + v7);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v9);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v9[1]);
    unint64_t v1 = v2[2];
    if (v1 <= v6) {
      goto LABEL_30;
    }
    unint64_t v8 = v1 - 1;
    if (v1 - 1 > v6)
    {
      *(_OWORD *)(v2[4] + v7) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      unint64_t v8 = v2[2] - 1;
    }
    v2[2] = v8;
    ++*((_DWORD *)v2 + 6);
    v7 -= 16;
    --v6;
  }
  while (v6);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v8)
  {
    uint64_t v11 = 0;
    long long v26 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    uint64_t v2 = (void *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    long long v15 = "operator[]";
    __int16 v16 = 1024;
    int v17 = 789;
    __int16 v18 = 2048;
    unint64_t v19 = 0;
    __int16 v20 = 2048;
    unint64_t v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    v2[6] = 0xFFFFFFFF00000000;
  }
  unsigned int v10 = (void *)v2[4];
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v10);
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v10[1]);
  uint64_t result = re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

uint64_t re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit(uint64_t result)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(result + 44)) {
    return result;
  }
  uint64_t v2 = (void *)result;
  uint64_t v11 = (void *)result;
  if (*(_DWORD *)(result + 40))
  {
    LODWORD(v12) = 0;
    if (!*(void *)(result + 16)) {
      goto LABEL_32;
    }
    uint64_t v3 = (void *)result;
    if (!**(_DWORD **)(*(void *)(result + 32) + 8))
    {
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      uint64_t v3 = v11;
    }
  }
  else
  {
    LODWORD(v12) = -1;
    uint64_t v3 = (void *)result;
  }
  uint64_t v11 = v3;
  uint64_t v4 = (unsigned __int16)v12;
  if (v3 != v2 || ((unsigned __int16)v12 == 0xFFFFLL ? (BOOL v5 = (v12 & 0xFFFF0000) == 4294901760) : (BOOL v5 = 0), !v5))
  {
    unint64_t v6 = WORD1(v12);
    do
    {
      unint64_t v7 = v3[2];
      if (v7 <= v6) {
        goto LABEL_31;
      }
      re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(void *)(v3[4] + 16 * v6 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v6 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      uint64_t v3 = v11;
      uint64_t v4 = (unsigned __int16)v12;
      unint64_t v6 = WORD1(v12);
    }
    while (v11 != v2 || (unsigned __int16)v12 != 0xFFFFLL || WORD1(v12) != 0xFFFFLL);
  }
  unint64_t v8 = v2[2];
  unint64_t v6 = v8 - 1;
  if (v8 == 1) {
    goto LABEL_26;
  }
  unint64_t v7 = 16 * v8 - 16;
  do
  {
    if (v8 <= v6)
    {
      uint64_t v11 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 789;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_30:
      uint64_t v11 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "removeAt";
      __int16 v16 = 1024;
      int v17 = 931;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_31:
      uint64_t v13 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 797;
      __int16 v18 = 2048;
      unint64_t v19 = v6;
      __int16 v20 = 2048;
      unint64_t v21 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_32:
      uint64_t v13 = 0;
      long long v26 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      long long v15 = "operator[]";
      __int16 v16 = 1024;
      int v17 = 797;
      __int16 v18 = 2048;
      unint64_t v19 = 0;
      __int16 v20 = 2048;
      unint64_t v21 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v9 = (void *)(v2[4] + v7);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v9);
    (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v9[1]);
    unint64_t v1 = v2[2];
    if (v1 <= v6) {
      goto LABEL_30;
    }
    unint64_t v8 = v1 - 1;
    if (v1 - 1 > v6)
    {
      *(_OWORD *)(v2[4] + v7) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      unint64_t v8 = v2[2] - 1;
    }
    v2[2] = v8;
    ++*((_DWORD *)v2 + 6);
    v7 -= 16;
    --v6;
  }
  while (v6);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v8)
  {
    uint64_t v11 = 0;
    long long v26 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    uint64_t v2 = (void *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    long long v15 = "operator[]";
    __int16 v16 = 1024;
    int v17 = 789;
    __int16 v18 = 2048;
    unint64_t v19 = 0;
    __int16 v20 = 2048;
    unint64_t v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    v2[6] = 0xFFFFFFFF00000000;
  }
  unsigned int v10 = (void *)v2[4];
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, *v10);
  (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v10[1]);
  uint64_t result = re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

uint64_t re::DynamicArray<re::internal::ObjectTypeInfo>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 152 * v4;
        unint64_t v6 = (re::StringID *)(v3 + 104);
        do
        {
          re::StringID::destroyString(v6);
          unint64_t v6 = (re::StringID *)((char *)v6 + 152);
          v5 -= 152;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::TypeRegistry::declareType@<D0>(uint64_t a1@<X0>, int a2@<W1>, StringID *a3@<X2>, unsigned int a4@<W3>, char a5@<W4>, void *a6@<X8>)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t v13 = (void *)(a1 + 200);
  int v14 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a1 + 200, a3);
  unint64_t v15 = 1;
  if (!v14)
  {
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  uint64_t v16 = *v14;
  if (!a1)
  {
LABEL_7:
    char v19 = 1;
    goto LABEL_8;
  }
  if ((a5 & 1) == 0)
  {
    unint64_t v6 = a1 + 96;
    int v17 = (re *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
    unsigned int v18 = v17 ? *((_DWORD *)v17 + 4) : -1;
    if (v18 > a4)
    {
      unint64_t v49 = *re::foundationIntrospectionLogObjects(v17);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        int v64 = a6;
        var1 = a3->var1;
        uint64_t v51 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
        if (v51) {
          int v52 = *(_DWORD *)(v51 + 16);
        }
        else {
          int v52 = -1;
        }
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = var1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a4;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = var1;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v52;
        _os_log_impl(&dword_233120000, v49, OS_LOG_TYPE_DEFAULT, "Type \"%s\" version %u is defined after type \"%s\" version %u.", buf, 0x22u);
        a6 = v64;
      }
    }
  }
  uint64_t v53 = a1 + 96;
  unsigned int v54 = (re *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
  if (v54) {
    int v55 = *((_DWORD *)v54 + 4);
  }
  else {
    int v55 = -1;
  }
  if (v55 != a4)
  {
    char v61 = (unsigned __int8 *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, v16);
    if (v61[3] != a2)
    {
      int v62 = *re::foundationIntrospectionLogObjects((re *)v61);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        uint64_t v63 = a3->var1;
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v63;
        _os_log_error_impl(&dword_233120000, v62, OS_LOG_TYPE_ERROR, "An type with the same name (\"%s\") but with a different type category has already been declared.", buf, 0xCu);
      }
      goto LABEL_69;
    }
    char v19 = 0;
LABEL_8:
    re::TypeRegistry::makeStringID((re::TypeRegistry *)a1, a3, (re::StringID *)&v66);
    int v21 = *(_DWORD *)(a1 + 88);
    if ((v21 + 1) >> 24) {
      int v22 = 1;
    }
    else {
      int v22 = v21 + 1;
    }
    *(_DWORD *)(a1 + 88) = v22;
    uint64_t v23 = *(unsigned __int16 *)(a1 + 84);
    unint64_t v24 = *(unsigned __int16 *)(a1 + 86);
    if (v23 == 0xFFFF && v24 == 0xFFFF)
    {
      if (*(_DWORD *)(a1 + 80) >= *(_DWORD *)(a1 + 76)) {
        re::DataArray<re::internal::TypeInfoIndex>::allocBlock((void *)(a1 + 32));
      }
      uint64_t v25 = *(void *)(a1 + 48);
      unint64_t v24 = (unsigned __int16)(v25 - 1);
      if (v25)
      {
        uint64_t v23 = *(unsigned int *)(a1 + 80);
        if (v23 < 0x10000)
        {
          long long v26 = (void *)(*(void *)(a1 + 64) + 16 * v24);
          *(_DWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = v23 + 1;
          *(_DWORD *)(v26[1] + 4 * v23) = *(_DWORD *)(a1 + 88);
          uint64_t v27 = (int *)(*v26 + 4 * v23);
LABEL_20:
          ++*(_DWORD *)(a1 + 72);
          int *v27 = (a2 << 24) | 0xFFFFFF;
          unint64_t v29 = (v24 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 88) & 0xFFFFFF) << 32) | v23;
          unint64_t v65 = v29;
          int v30 = *(_DWORD *)(a1 + 152);
          if ((v30 + 1) >> 24) {
            int v31 = 1;
          }
          else {
            int v31 = v30 + 1;
          }
          *(_DWORD *)(a1 + 152) = v31;
          uint64_t v32 = *(unsigned __int16 *)(a1 + 148);
          unint64_t v6 = *(unsigned __int16 *)(a1 + 150);
          if (v32 != 0xFFFF || v6 != 0xFFFF)
          {
            unint64_t v15 = *(void *)(a1 + 112);
            if (v15 > v6)
            {
              uint64_t v37 = (void *)(*(void *)(a1 + 128) + 16 * v6);
              *(_DWORD *)(v37[1] + 4 * v32) = v31;
              uint64_t v36 = (re::StringID *)(*v37 + 24 * v32);
              *(_DWORD *)(a1 + 148) = *(_DWORD *)v36;
              goto LABEL_32;
            }
            goto LABEL_76;
          }
          if (*(_DWORD *)(a1 + 144) >= *(_DWORD *)(a1 + 140)) {
            re::DataArray<MetalHeap::TextureEntry>::allocBlock((void *)(a1 + 96));
          }
          uint64_t v33 = *(void *)(a1 + 112);
          unint64_t v6 = (unsigned __int16)(v33 - 1);
          if (v33)
          {
            uint64_t v34 = *(unsigned int *)(a1 + 144);
            if (v34 < 0x10000)
            {
              uint64_t v35 = (void *)(*(void *)(a1 + 128) + 16 * v6);
              *(_DWORD *)(a1 + 144) = v34 + 1;
              *(_DWORD *)(v35[1] + 4 * v34) = *(_DWORD *)(a1 + 152);
              uint64_t v36 = (re::StringID *)(*v35 + 24 * v34);
LABEL_32:
              ++*(_DWORD *)(a1 + 136);
              *((_DWORD *)re::StringID::StringID(v36, &v66) + 4) = a4;
              unint64_t v38 = *(void *)&v66.var0;
              if (*(void *)&v66.var0 >= 0xFFFFFFFFFFFFFFFELL && (*(unsigned char *)&v66.var0 & 1) == 0 && !*v66.var1) {
                goto LABEL_49;
              }
              if ((v19 & 1) == 0)
              {
                uint64_t v39 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
                if (!v39 || *(_DWORD *)(v39 + 16) >= a4) {
                  goto LABEL_49;
                }
                unint64_t v38 = *(void *)&v66.var0;
              }
              unint64_t v40 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * ((v38 >> 31) ^ (v38 >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                           * ((v38 >> 31) ^ (v38 >> 1))) >> 27));
              unint64_t v41 = v40 ^ (v40 >> 31);
              if (*v13)
              {
                unint64_t v42 = v41 % *(unsigned int *)(a1 + 224);
                uint64_t v43 = *(unsigned int *)(*(void *)(a1 + 208) + 4 * v42);
                if (v43 != 0x7FFFFFFF)
                {
                  uint64_t v44 = *(void *)(a1 + 216);
                  uint64_t v45 = v66.var1;
                  while (1)
                  {
                    uint64_t v46 = v44 + 32 * v43;
                    if ((*(void *)(v46 + 8) ^ v38) <= 1)
                    {
                      uint64_t v47 = *(const char **)(v46 + 16);
                      if (v47 == v45 || !strcmp(v47, v45)) {
                        break;
                      }
                    }
                    uint64_t v43 = *(_DWORD *)(v44 + 32 * v43) & 0x7FFFFFFF;
                    if (v43 == 0x7FFFFFFF) {
                      goto LABEL_48;
                    }
                  }
                  *(void *)(v44 + 32 * v43 + 24) = v29;
                  ++*(_DWORD *)(a1 + 240);
                  goto LABEL_49;
                }
              }
              else
              {
                LODWORD(v42) = 0;
              }
LABEL_48:
              re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>((uint64_t)v13, v42, v41, &v66, &v65);
              ++*(_DWORD *)(a1 + 240);
              unint64_t v29 = v65;
LABEL_49:
              ++*(_DWORD *)(a1 + 24);
              *a6 = a1;
              a6[1] = v29;
              re::StringID::destroyString((re::StringID *)&v66);
              return result;
            }
LABEL_77:
            re::internal::assertLog((re::internal *)5, v20, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v34);
            _os_crash();
            __break(1u);
          }
LABEL_75:
          uint64_t v67 = 0;
          long long v77 = 0u;
          long long v78 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v68 = 136315906;
          uint64_t v69 = "operator[]";
          __int16 v70 = 1024;
          int v71 = 789;
          __int16 v72 = 2048;
          unint64_t v73 = v6;
          __int16 v74 = 2048;
          unint64_t v75 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_76:
          uint64_t v67 = 0;
          long long v77 = 0u;
          long long v78 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v68 = 136315906;
          uint64_t v69 = "operator[]";
          __int16 v70 = 1024;
          int v71 = 789;
          __int16 v72 = 2048;
          unint64_t v73 = v6;
          __int16 v74 = 2048;
          unint64_t v75 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_77;
        }
LABEL_74:
        re::internal::assertLog((re::internal *)5, v20, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v23);
        _os_crash();
        __break(1u);
        goto LABEL_75;
      }
      uint64_t v67 = 0;
      long long v77 = 0u;
      long long v78 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v68 = 136315906;
      uint64_t v69 = "operator[]";
      __int16 v70 = 1024;
      int v71 = 789;
      __int16 v72 = 2048;
      unint64_t v73 = v24;
      __int16 v74 = 2048;
      unint64_t v75 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      unint64_t v6 = *(void *)(a1 + 48);
      if (v6 > v24)
      {
        uint64_t v28 = (void *)(*(void *)(a1 + 64) + 16 * v24);
        *(_DWORD *)(v28[1] + 4 * v23) = v22;
        uint64_t v27 = (int *)(*v28 + 4 * v23);
        *(_DWORD *)(a1 + 84) = *v27;
        goto LABEL_20;
      }
    }
    uint64_t v67 = 0;
    long long v77 = 0u;
    long long v78 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v68 = 136315906;
    uint64_t v69 = "operator[]";
    __int16 v70 = 1024;
    int v71 = 789;
    __int16 v72 = 2048;
    unint64_t v73 = v24;
    __int16 v74 = 2048;
    unint64_t v75 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_74;
  }
  uint64_t v56 = *re::foundationIntrospectionLogObjects(v54);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    uint64_t v57 = a6;
    unint64_t v58 = a3->var1;
    uint64_t v59 = re::DataArray<re::TextureAtlasTile>::tryGet(v53, v16);
    if (v59) {
      int v60 = *(_DWORD *)(v59 + 16);
    }
    else {
      int v60 = -1;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v58;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v60;
    _os_log_error_impl(&dword_233120000, v56, OS_LOG_TYPE_ERROR, "Duplicate types. A type with the same name (\"%s\") and version (%u) has already been declared.", buf, 0x12u);
    a6 = v57;
  }
LABEL_69:
  *a6 = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  a6[1] = 0xFFFFFFFFLL;
  return result;
}

re::StringID *re::TypeRegistry::makeStringID@<X0>(re::TypeRegistry *this@<X0>, const StringID *a2@<X1>, re::StringID *a3@<X8>)
{
  if (*(unsigned char *)&a2->var0) {
    return re::TypeRegistry::makeStringID(this, a2->var1, a3);
  }
  else {
    return re::StringID::StringID(a3, a2);
  }
}

void re::TypeRegistry::declareTypeAlias(re::TypeRegistry *this, uint64_t a2, const StringID *a3)
{
  if (*(void *)a2)
  {
    if (*(re::TypeRegistry **)a2 == this)
    {
      re::TypeRegistry::makeStringID(this, a3, (re::StringID *)&v5);
      re::DynamicArray<re::StringID>::add((re::TypeRegistry *)((char *)this + 160), &v5);
      re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<re::DataArrayHandle<re::internal::TypeInfoIndex>&>((uint64_t)this + 200, &v5, (void *)(a2 + 8));
      ++*((_DWORD *)this + 6);
      re::StringID::destroyString((re::StringID *)&v5);
      return;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "declareTypeAlias", 144);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "declareTypeAlias", 145);
  _os_crash();
  __break(1u);
}

uint64_t re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(uint64_t a1, StringID *a2, void *a3)
{
  unint64_t v6 = 0xBF58476D1CE4E5B9 * ((*(void *)&a2->var0 >> 31) ^ (*(void *)&a2->var0 >> 1));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v7 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(void *)(a1 + 16) + 32 * v12 + 24;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v11 = v10 + 32 * v9;
    if (re::StringID::operator==((void *)(v11 + 8), a2)) {
      return v11 + 24;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 32 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

void re::TypeRegistry::declareTypeAlias(re::TypeRegistry *this, const re::StringID *a2, const StringID *a3)
{
  StringID v5 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (v5)
  {
    uint64_t v8 = *v5;
    unint64_t v6 = this;
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  unint64_t v7 = v6;
  re::TypeRegistry::declareTypeAlias(this, (uint64_t)&v7, a3);
}

BOOL re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::containsKey(uint64_t a1, void *a2)
{
  uint64_t v2 = 0x7FFFFFFFLL;
  if (*(void *)a1)
  {
    unint64_t v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
    uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8)
                         + 4
                         * (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
                          % *(unsigned int *)(a1 + 24)));
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v2 = 0x7FFFFFFFLL;
      while (!re::StringID::operator==((void *)(v6 + 32 * v5 + 8), a2))
      {
        uint64_t v5 = *(_DWORD *)(v6 + 32 * v5) & 0x7FFFFFFF;
        if (v5 == 0x7FFFFFFF) {
          return v2 != 0x7FFFFFFF;
        }
      }
      uint64_t v2 = v5;
    }
  }
  return v2 != 0x7FFFFFFF;
}

double re::TypeRegistry::typeID@<D0>(re::TypeRegistry *this@<X0>, const re::StringID *a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  unint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (v7
    && (TypeWithVersiouint64_t n = re::TypeRegistry::findTypeWithVersion((uint64_t)this, *v7, a3),
        (TypeWithVersion & 0xFFFFFF00000000) != 0))
  {
    *a4 = this;
    a4[1] = TypeWithVersion;
  }
  else
  {
    *a4 = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    a4[1] = 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t re::TypeRegistry::findTypeWithVersion(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v46 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)a1, a2, v27);
  if (v27[0])
  {
    LODWORD(v4) = -1;
    while (1)
    {
      uint64_t v6 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(v28 + 12), *(void *)v29);
      int v7 = v6 ? *(_DWORD *)(v6 + 16) : -1;
      if (v7 == a3) {
        break;
      }
      if ((*(_DWORD *)(v29 + 60) & 0xFFFFFF) != 0) {
        re::TypeRegistry::typeInfo(v28, *(void *)(v29 + 56), &v41);
      }
      else {
        LOBYTE(v41) = 0;
      }
      re::Optional<re::TypeInfo>::operator=(v27, (unsigned __int8 *)&v41);
      if (!v27[0])
      {
        unint64_t v8 = 0;
        return v8 | v4;
      }
    }
    uint64_t v4 = *(void *)v29;
    goto LABEL_19;
  }
  uint64_t v9 = a1 + 96;
  uint64_t v10 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v4);
  if (!v10) {
    goto LABEL_33;
  }
  uint64_t v11 = (void *)v10;
  if (*(_DWORD *)(v10 + 16) != a3)
  {
    uint64_t v30 = a1 + 96;
    if (*(_DWORD *)(a1 + 136))
    {
      LODWORD(v31) = 0;
      if (!*(void *)(a1 + 112)) {
        goto LABEL_46;
      }
      uint64_t v12 = a1 + 96;
      if (!**(_DWORD **)(*(void *)(a1 + 128) + 8))
      {
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v30);
        uint64_t v12 = v30;
      }
    }
    else
    {
      LODWORD(v31) = -1;
      uint64_t v12 = a1 + 96;
    }
    uint64_t v25 = v12;
    uint64_t v26 = v31;
    uint64_t v13 = (unsigned __int16)v31;
    if (v9 != v12 || (unsigned __int16)v31 != 0xFFFFLL || (v31 & 0xFFFF0000) != 0xFFFF0000)
    {
      unint64_t v14 = WORD1(v31);
      while (1)
      {
        unint64_t v15 = *(void *)(v12 + 16);
        if (v15 <= v14) {
          goto LABEL_45;
        }
        unint64_t v14 = *(void *)(*(void *)(v12 + 32) + 16 * v14) + 24 * v13;
        if (re::StringID::operator==((void *)v14, v11) && *(_DWORD *)(v14 + 16) == a3) {
          break;
        }
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v25);
        uint64_t v12 = v25;
        uint64_t v13 = (unsigned __int16)v26;
        unint64_t v14 = WORD1(v26);
        if (v25 == v9 && (unsigned __int16)v26 == 0xFFFFLL && WORD1(v26) == 0xFFFFLL) {
          goto LABEL_33;
        }
      }
      uint64_t v19 = *(void *)(a1 + 112);
      if (!v19)
      {
LABEL_41:
        re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
        _os_crash();
        __break(1u);
LABEL_42:
        if (v24 < 0x10000)
        {
          LODWORD(v4) = v20 & 0xFFFF0000 | v24;
          unint64_t v8 = ((unint64_t)(*(_DWORD *)(*v22 + 4 * v24) & 0xFFFFFF) << 32) & 0xFFFFFF00000000 | v24 & 0xFFFFFF00000000;
          return v8 | v4;
        }
LABEL_47:
        re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v24);
        _os_crash();
        __break(1u);
      }
      int v20 = 0;
      uint64_t v21 = 0;
      int v22 = (void *)(*(void *)(a1 + 128) + 8);
      while (v21 != 0x10000)
      {
        uint64_t v23 = v14 - *(v22 - 1);
        if (v23 >= -23)
        {
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (v23 >> 3);
          if (v24 < *(unsigned int *)(a1 + 140)) {
            goto LABEL_42;
          }
        }
        ++v21;
        v20 += 0x10000;
        v22 += 2;
        if (v19 == v21) {
          goto LABEL_41;
        }
      }
      re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
      _os_crash();
      __break(1u);
LABEL_45:
      uint64_t v30 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v33 = 136315906;
      uint64_t v34 = "operator[]";
      __int16 v35 = 1024;
      int v36 = 797;
      __int16 v37 = 2048;
      unint64_t v38 = v14;
      __int16 v39 = 2048;
      unint64_t v40 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_46:
      uint64_t v32 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v33 = 136315906;
      uint64_t v34 = "operator[]";
      __int16 v35 = 1024;
      int v36 = 797;
      __int16 v37 = 2048;
      unint64_t v38 = 0;
      __int16 v39 = 2048;
      unint64_t v40 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
LABEL_33:
    unint64_t v8 = 0;
    LODWORD(v4) = -1;
    return v8 | v4;
  }
LABEL_19:
  unint64_t v8 = v4 & 0xFFFFFFFF00000000;
  return v8 | v4;
}

void re::TypeRegistry::typeInfo(re *a1@<X0>, re **a2@<X1>, unsigned char *a3@<X8>)
{
  if (!*a2) {
    goto LABEL_5;
  }
  if (*a2 != a1)
  {
    uint64_t v4 = *re::foundationIntrospectionLogObjects(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "Invalid type ID. Type was registered in a different type registry.", v6, 2u);
    }
LABEL_5:
    *a3 = 0;
    return;
  }
  uint64_t v5 = (uint64_t)a2[1];
  re::TypeRegistry::typeInfo(a1, v5, a3);
}

uint64_t *re::TypeRegistry::typeInfo@<X0>(re::TypeRegistry *this@<X0>, const re::StringID *a2@<X1>, unsigned char *a3@<X8>)
{
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (result)
  {
    uint64_t v6 = *result;
    return (uint64_t *)re::TypeRegistry::typeInfo(this, v6, a3);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

_anonymous_namespace_ *re::TypeRegistry::typeName(_anonymous_namespace_ *result, void *a2)
{
  if (!*a2
    || (double result = (_anonymous_namespace_ *)re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)result + 96, a2[1])) == 0)
  {
  }
  return result;
}

uint64_t re::TypeRegistry::typeInfoChecked@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  re::TypeRegistry::typeInfo(a1, a2, v5);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)&v6);
}

uint64_t *re::TypeRegistry::typeName(uint64_t a1, uint64_t a2)
{
  double result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, a2);
  if (!result)
  {
  }
  return result;
}

void anonymous namespace'::invalidTypeName(_anonymous_namespace_ *this)
{
  {
  }
}

void re::TypeRegistry::setGetActualType(re *a1, re **a2, uint64_t a3)
{
  re::TypeRegistry::typeInfo(a1, a2, v5);
  if (v5[0])
  {
    *(void *)(v6 + 144) = a3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Type has been forward declared but type information is missing.", "type", "setGetActualType", 399);
    _os_crash();
    __break(1u);
  }
}

void re::TypeRegistry::overridePolymorphicObjectName(uint64_t a1, uint64_t a2, StringID *a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!*(void *)a2) {
    goto LABEL_14;
  }
  if (*(void *)a2 != a1)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overridePolymorphicObjectName", 407);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (*(unsigned char *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, *(void *)(a2 + 8)) + 3) != 8)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "overridePolymorphicObjectName", 408);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Type has been forward declared but type information is missing.", "typeInfo", "overridePolymorphicObjectName", 411);
    _os_crash();
    __break(1u);
  }
  re::TypeRegistry::typeInfo((re *)a1, (re **)a2, v18);
  if (!v18[0]) {
    goto LABEL_17;
  }
  re::TypeRegistry::makeStringID((re::TypeRegistry *)a1, a3, (re::StringID *)v17);
  re::StringID::operator=(v20 + 13, v17);
  re::TypeInfo::rootClass((re::TypeInfo *)&v19, (uint64_t)v15);
  unint64_t v8 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(void *)v16) & 0xFFFFFF;
  uint64_t v9 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *v20);
  int v10 = *(_DWORD *)(v16 + 80);
  if (v8 < v10 + (int)v8)
  {
    uint64_t v11 = *v9 & 0xFFFFFF;
    uint64_t v12 = 152 * v8 + 104;
    do
    {
      if (v11 != v8)
      {
        unint64_t v13 = *(void *)(a1 + 624);
        if (v13 <= v8)
        {
          uint64_t v21 = 0;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          long long v30 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v22 = 136315906;
          uint64_t v23 = "operator[]";
          __int16 v24 = 1024;
          int v25 = 789;
          __int16 v26 = 2048;
          unint64_t v27 = v8;
          __int16 v28 = 2048;
          unint64_t v29 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_13:
          re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) Duplicate polymorphic object name \"%s\".", "m_objectTypes[i].polymorphicObjectName != polymorphicObjectName", "overridePolymorphicObjectName", 429, a3->var1);
          _os_crash();
          __break(1u);
LABEL_14:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overridePolymorphicObjectName", 406);
          _os_crash();
          __break(1u);
          goto LABEL_15;
        }
        if (re::StringID::operator==((void *)(*(void *)(a1 + 640) + v12), a3)) {
          goto LABEL_13;
        }
      }
      ++v8;
      v12 += 152;
      --v10;
    }
    while (v10);
  }
  ++*(_DWORD *)(a1 + 24);
  re::StringID::destroyString((re::StringID *)v17);
}

_DWORD *re::TypeRegistry::overrideCustomClassID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!*(void *)a2) {
    goto LABEL_16;
  }
  if (*(void *)a2 != a1)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overrideCustomClassID", 438);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "overrideCustomClassID", 439);
    _os_crash();
    __break(1u);
  }
  if (*(unsigned char *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, *(void *)(a2 + 8)) + 3) != 8) {
    goto LABEL_18;
  }
  re::TypeRegistry::typeInfo((re *)a1, (re **)a2, v18);
  uint64_t v7 = v20;
  if (!*(unsigned char *)(v20 + 120)) {
    *(unsigned char *)(v20 + 12re::InputManager::notify(8, 0, 0, 0) = 1;
  }
  *(void *)(v7 + 128) = a3;
  re::TypeInfo::rootClass((re::TypeInfo *)v19, (uint64_t)v16);
  unint64_t v8 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(void *)v17) & 0xFFFFFF;
  double result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(void *)v20);
  int v10 = *(_DWORD *)(v17 + 80);
  if (v8 < v10 + (int)v8)
  {
    uint64_t v11 = 152 * v8;
    do
    {
      if ((*result & 0xFFFFFF) != v8)
      {
        unint64_t v12 = *(void *)(a1 + 624);
        if (v12 <= v8)
        {
          uint64_t v21 = 0;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          long long v30 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v22 = 136315906;
          uint64_t v23 = "operator[]";
          __int16 v24 = 1024;
          int v25 = 789;
          __int16 v26 = 2048;
          unint64_t v27 = v8;
          __int16 v28 = 2048;
          unint64_t v29 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_15:
          re::TypeInfo::name((re::TypeInfo *)v19);
          uint64_t v14 = re::TypeInfo::name((re::TypeInfo *)v19);
          re::internal::assertLog((re::internal *)5, v15, "assertion failure: '%s' (%s:line %i) Duplicate class ID (type: \"%s\").", "m_objectTypes[i].customClassID != customClassID", "overrideCustomClassID", 457, v14[1]);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overrideCustomClassID", 437);
          _os_crash();
          __break(1u);
          goto LABEL_17;
        }
        uint64_t v13 = *(void *)(a1 + 640) + v11;
        if (*(unsigned char *)(v13 + 120) && *(void *)(v13 + 128) == a3) {
          goto LABEL_15;
        }
      }
      ++v8;
      v11 += 152;
      --v10;
    }
    while (v10);
  }
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::TypeRegistry::clearCustomClassID(re *a1, uint64_t a2)
{
  if (!*(void *)a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "clearCustomClassID", 465);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (*(re **)a2 != a1)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "clearCustomClassID", 466);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (*(unsigned char *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)a1 + 32, *(void *)(a2 + 8)) + 3) != 8)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "clearCustomClassID", 467);
    _os_crash();
    __break(1u);
    return;
  }
  re::TypeRegistry::typeInfo(a1, (re **)a2, v5);
  if (v5[0])
  {
    if (*(unsigned char *)(v6 + 120)) {
      *(unsigned char *)(v6 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
    }
    ++*((_DWORD *)a1 + 6);
  }
}

uint64_t re::TypeRegistry::addAttribute(uint64_t a1, void *a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!*a2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "addAttribute", 481);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (*a2 != a1)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "addAttribute", 482);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!*(void *)a4)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid attribute type ID.", "attributeTypeID.isValid()", "addAttribute", 483);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v10 = a2[1];
  *(void *)&long long v14 = *(void *)(a4 + 8);
  *((void *)&v14 + 1) = v10;
  int v15 = a3;
  uint64_t result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(a1 + 768, (uint64_t *)&v14);
  if (result)
  {
    unint64_t v12 = (void **)result;
    if (*(void *)result == a5) {
      return result;
    }
    if (*(void *)result)
    {
      if (*(unsigned char *)(result + 8))
      {
        re::TypeRegistry::typeInfo((re *)a1, (re **)a4, v13);
        re::TypeInfo::releaseInstance((re::TypeInfo *)((char *)v13 + 8), *v12, *(re::Allocator **)(a1 + 16), 0);
      }
    }
  }
  *(void *)&v13[0] = a5;
  DWORD2(v13[0]) = a6;
  uint64_t result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(a1 + 768, &v14, v13);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v9, (uint64_t)a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  while (1)
  {
    BOOL v7 = re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v6 + 56 * v5 + 16), a2);
    uint64_t v6 = *(void *)(a1 + 16);
    if (v7) {
      break;
    }
    uint64_t v5 = *(_DWORD *)(v6 + 56 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v6 + 56 * v5 + 40;
}

uint64_t re::TypeRegistry::attributesByAttributeType@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(void *)a2)
  {
    uint64_t v4 = result;
    if (*(void *)a2 == result)
    {
      uint64_t v6 = *(unsigned int *)(result + 800);
      if (v6)
      {
        uint64_t v7 = 0;
        unint64_t v8 = (int *)(*(void *)(result + 784) + 8);
        while (1)
        {
          int v9 = *v8;
          v8 += 14;
          if (v9 < 0) {
            break;
          }
          if (v6 == ++v7)
          {
            LODWORD(v7) = *(_DWORD *)(result + 800);
            break;
          }
        }
      }
      else
      {
        LODWORD(v7) = 0;
      }
      if (v6 == v7)
      {
        unint64_t v10 = 0;
      }
      else
      {
        unint64_t v10 = 0;
        uint64_t v11 = v7;
        uint64_t v12 = *(void *)(result + 784);
        do
        {
          uint64_t v13 = v12 + 56 * v11;
          int v15 = *(unsigned __int16 *)(v13 + 16);
          uint64_t v14 = v13 + 16;
          if (v15 == (unsigned __int16)*(_DWORD *)(a2 + 8)
            && *(unsigned __int16 *)(v14 + 2) == HIWORD(*(_DWORD *)(a2 + 8))
            && ((*(_DWORD *)(v14 + 4) ^ *(_DWORD *)(a2 + 12)) & 0xFFFFFF) == 0)
          {
            ++v10;
          }
          if (v6 <= (int)v7 + 1) {
            uint64_t v16 = (v7 + 1);
          }
          else {
            uint64_t v16 = v6;
          }
          while (1)
          {
            uint64_t v11 = (v7 + 1);
            if (v16 - 1 == v7) {
              break;
            }
            LODWORD(v7) = v7 + 1;
            uint64_t result = v11;
            if ((*(_DWORD *)(v12 + 56 * v11 + 8) & 0x80000000) != 0) {
              goto LABEL_24;
            }
          }
          uint64_t result = v16;
LABEL_24:
          LODWORD(v7) = result;
        }
        while (v6 != result);
      }
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(_DWORD *)(a3 + 24) = 0;
      uint64_t result = (uint64_t)re::DynamicArray<re::ecs2::CustomSystemRegistry::SystemDependency>::setCapacity((void *)a3, v10);
      int v17 = *(_DWORD *)(a3 + 24) + 1;
      *(_DWORD *)(a3 + 24) = v17;
      uint64_t v18 = *(unsigned int *)(v4 + 800);
      if (v18)
      {
        uint64_t v19 = 0;
        uint64_t v20 = (int *)(*(void *)(v4 + 784) + 8);
        while (1)
        {
          int v21 = *v20;
          v20 += 14;
          if (v21 < 0) {
            break;
          }
          if (v18 == ++v19)
          {
            LODWORD(v19) = *(_DWORD *)(v4 + 800);
            break;
          }
        }
      }
      else
      {
        LODWORD(v19) = 0;
      }
      if (v18 != v19)
      {
        uint64_t v22 = v19;
        unsigned int v23 = *(_DWORD *)(v4 + 800);
        do
        {
          uint64_t v24 = *(void *)(v4 + 784);
          uint64_t v25 = v24 + 56 * v22;
          int v27 = *(unsigned __int16 *)(v25 + 16);
          __int16 v26 = (uint64_t *)(v25 + 16);
          uint64_t v28 = *(void *)(a2 + 8);
          if (v27 == (unsigned __int16)v28
            && *((unsigned __int16 *)v26 + 1) == WORD1(v28)
            && ((*((_DWORD *)v26 + 1) ^ HIDWORD(v28)) & 0xFFFFFF) == 0)
          {
            unint64_t v29 = v26 + 3;
            uint64_t v30 = *v26;
            uint64_t v31 = v24 + 56 * v22;
            uint64_t v32 = *(void *)(v31 + 24);
            int v33 = *(_DWORD *)(v31 + 32);
            uint64_t v34 = *v29;
            unint64_t v36 = *(void *)(a3 + 8);
            unint64_t v35 = *(void *)(a3 + 16);
            if (v35 >= v36)
            {
              unint64_t v37 = v35 + 1;
              if (v36 < v35 + 1)
              {
                uint64_t v43 = v30;
                if (*(void *)a3)
                {
                  unint64_t v38 = 2 * v36;
                  if (!v36) {
                    unint64_t v38 = 8;
                  }
                  if (v38 <= v37) {
                    unint64_t v39 = v35 + 1;
                  }
                  else {
                    unint64_t v39 = v38;
                  }
                  uint64_t result = (uint64_t)re::DynamicArray<re::ecs2::CustomSystemRegistry::SystemDependency>::setCapacity((void *)a3, v39);
                  int v17 = *(_DWORD *)(a3 + 24);
                }
                else
                {
                  uint64_t result = (uint64_t)re::DynamicArray<re::ecs2::CustomSystemRegistry::SystemDependency>::setCapacity((void *)a3, v37);
                  int v17 = *(_DWORD *)(a3 + 24) + 1;
                }
                uint64_t v30 = v43;
              }
              unint64_t v35 = *(void *)(a3 + 16);
            }
            uint64_t v40 = *(void *)(a3 + 32) + 48 * v35;
            *(void *)uint64_t v40 = v4;
            *(void *)(v40 + 8) = v30;
            *(void *)(v40 + 16) = v4;
            *(void *)(v40 + 24) = v32;
            *(_DWORD *)(v40 + 32) = v33;
            *(void *)(v40 + 4re::InputManager::notify(8, 0, 0, 0) = v34;
            *(void *)(a3 + 16) = v35 + 1;
            *(_DWORD *)(a3 + 24) = ++v17;
            unsigned int v23 = *(_DWORD *)(v4 + 800);
          }
          if (v23 <= (int)v19 + 1) {
            unsigned int v41 = v19 + 1;
          }
          else {
            unsigned int v41 = v23;
          }
          while (1)
          {
            uint64_t v22 = (v19 + 1);
            if (v41 - 1 == v19) {
              break;
            }
            LODWORD(v19) = v19 + 1;
            unsigned int v42 = v22;
            if ((*(_DWORD *)(*(void *)(v4 + 784) + 56 * v22 + 8) & 0x80000000) != 0) {
              goto LABEL_56;
            }
          }
          unsigned int v42 = v41;
LABEL_56:
          LODWORD(v19) = v42;
        }
        while (v18 != v42);
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "attributeID.registry() == this", "attributesByAttributeType", 518);
      uint64_t result = _os_crash();
      __break(1u);
    }
  }
  else
  {
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
  }
  return result;
}

re::StringID *re::TypeRegistry::makeStringID@<X0>(re::TypeRegistry *this@<X0>, const char *__s@<X1>, re::StringID *a3@<X8>)
{
  if (__s)
  {
    uint64_t result = (re::StringID *)strlen(__s);
    if (result)
    {
      uint64_t v12 = (char *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 2) + 32))(*((void *)this + 2), (uint64_t)result + 1, 0);
      strcpy(v12, __s);
      uint64_t result = (re::StringID *)re::DynamicArray<re::TransitionCondition *>::add((void *)this + 102, &v12);
      uint64_t v7 = v12;
      if (v12)
      {
        uint64_t v8 = *v12;
        if (*v12)
        {
          char v9 = v12[1];
          if (v9)
          {
            unint64_t v10 = v12 + 2;
            do
            {
              uint64_t v8 = 31 * v8 + v9;
              int v11 = *v10++;
              char v9 = v11;
            }
            while (v11);
          }
        }
      }
      else
      {
        uint64_t v8 = 0;
      }
      *(void *)a3 = 2 * v8;
      *((void *)a3 + 1) = v7;
    }
    else
    {
      *(void *)a3 = 0;
      *((void *)a3 + 1) = "";
    }
  }
  else
  {
    return re::StringID::invalid(a3);
  }
  return result;
}

_anonymous_namespace_ *re::TypeRegistry::removeType(_anonymous_namespace_ *result, void *a2)
{
  uint64_t v180 = *MEMORY[0x263EF8340];
  if (*a2)
  {
    uint64_t v4 = (uint64_t)result;
    long long v165 = 0;
    v162[1] = 0;
    uint64_t v163 = 0;
    int v164 = 0;
    uint64_t v5 = (_anonymous_namespace_ *)re::DynamicArray<std::pair<re::ecs2::Component *,re::ecs2::VFXSceneComponent *>>::setCapacity(v162, 0);
    ++v164;
    unsigned int v160 = 0;
    *(_OWORD *)__b = 0u;
    long long v159 = 0u;
    unint64_t v161 = 0x7FFFFFFFLL;
    unint64_t v6 = v4 + 32;
    unint64_t v7 = (unint64_t)&v175;
    uint64_t v8 = (_anonymous_namespace_ *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v175, v4 + 32, 0);
    *(void *)int v167 = v4;
    *(_OWORD *)&v167[8] = v175;
    if (v4 + 32 != (void)v175 || WORD4(v175) != 0xFFFFLL || (DWORD2(v175) & 0xFFFF0000) != 0xFFFF0000)
    {
      unint64_t v7 = 0x7FFFFFFFLL;
      do
      {
        unint64_t v9 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v167[8]);
        *(void *)long long v170 = *(void *)v167;
        *(void *)&v170[8] = v9;
        if (*(void *)v167 == *a2)
        {
          uint64_t v10 = a2[1];
          BOOL v12 = v9 == v10;
          uint64_t v11 = (v9 ^ v10) & 0xFFFFFF00000000;
          BOOL v12 = v12 && v11 == 0;
          if (v12) {
            goto LABEL_22;
          }
        }
        if (HIDWORD(v159))
        {
          if (DWORD2(v159)) {
            memset_pattern16(__b[1], &unk_2343655D0, 4 * DWORD2(v159));
          }
          if (v160)
          {
            uint64_t v13 = 0;
            uint64_t v14 = 32 * v160;
            do
            {
              int v15 = *(_DWORD *)(v159 + v13 + 8);
              if (v15 < 0) {
                *(_DWORD *)(v159 + v13 + 8) = v15 & 0x7FFFFFFF;
              }
              v13 += 32;
            }
            while (v14 != v13);
          }
          HIDWORD(v159) = 0;
          unsigned int v160 = 0;
          unint64_t v161 = __PAIR64__(HIDWORD(v161), 0x7FFFFFFF) + 0x100000000;
        }
        re::TypeRegistry::typeInfo((re *)v4, (re **)v170, &v175);
        if ((_BYTE)v175)
        {
          long long v157 = *(_OWORD *)a2;
          if (re::TypeInfo::isDependentOn((unint64_t *)&v175 + 1, &v157, (uint64_t)__b, *(double *)&v157))LABEL_22:re::DynamicArray<re::TypeID>::add((_anonymous_namespace_ *)v162, (__n128 *)v170); {
        }
          }
        uint64_t v8 = (_anonymous_namespace_ *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v167[8]);
      }
      while (*(void *)&v167[8] != v6
           || *(unsigned __int16 *)&v167[16] != 0xFFFF
           || *(unsigned __int16 *)&v167[18] != 0xFFFF);
    }
    if (v163)
    {
      uint64_t v16 = v165;
      uint64_t v151 = v4 + 648;
      long long v152 = &v165[v163];
      uint64_t v153 = v4 + 32;
      uint64_t v155 = v4 + 200;
      while (1)
      {
        long long v156 = *v16;
        StringID v154 = v16;
        unint64_t v17 = *((void *)v16 + 1);
        unint64_t v18 = *(void *)(v4 + 176);
        memset(&v167[8], 0, 20);
        *(void *)&v169[2] = 0;
        re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(v167, v18);
        ++*(_DWORD *)&v167[24];
        *(void *)&long long v175 = 0;
        unint64_t v19 = *(void *)(v4 + 176);
        if (v19) {
          break;
        }
LABEL_42:
        unint64_t v26 = *(void *)&v167[16] - 1;
        unint64_t v27 = v4 + 200;
        if (*(void *)&v167[16] - 1 >= 0)
        {
          unint64_t v28 = -16 * *(void *)&v167[16];
          while (v19 > v26)
          {
            re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(v155, (void *)(*(void *)(v4 + 192) + 16 * v26));
            unint64_t v19 = *(void *)(v4 + 176);
            if (v19 <= v26) {
              goto LABEL_232;
            }
            uint64_t v29 = *(void *)(v4 + 192);
            unint64_t v7 = v29 + 16 * v26 + 16;
            if (v19 - 1 > v26 && v7 != v29 + 16 * v19)
            {
              unint64_t v31 = v28 + 16 * v19;
              do
              {
                uint64_t v32 = *(void *)v7;
                uint64_t v33 = *(void *)(v7 + 8);
                *(void *)unint64_t v7 = 0;
                *(void *)(v7 + 8) = "";
                uint64_t v34 = *(void *)(v7 - 8);
                unint64_t v35 = v32 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v7 - 16) & 1;
                *(void *)(v7 - 8) = v33;
                *(void *)&long long v175 = v35;
                *((void *)&v175 + 1) = v34;
                *(void *)(v7 - 16) = v32;
                re::StringID::destroyString((re::StringID *)&v175);
                v7 += 16;
                v31 -= 16;
              }
              while (v31);
              unint64_t v19 = *(void *)(v4 + 176);
              uint64_t v29 = *(void *)(v4 + 192);
            }
            re::StringID::destroyString((re::StringID *)(v29 + 16 * v19 - 16));
            unint64_t v19 = *(void *)(v4 + 176) - 1;
            *(void *)(v4 + 176) = v19;
            ++*(_DWORD *)(v4 + 184);
            v28 += 16;
            if ((uint64_t)v26-- <= 0) {
              goto LABEL_55;
            }
          }
          uint64_t v166 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v170 = 136315906;
          *(void *)&v170[4] = "operator[]";
          *(_WORD *)&v170[12] = 1024;
          *(_DWORD *)&v170[14] = 789;
          __int16 v171 = 2048;
          unint64_t v172 = v26;
          __int16 v173 = 2048;
          unint64_t v174 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_232:
          uint64_t v166 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v170 = 136315906;
          *(void *)&v170[4] = "removeStableAt";
          *(_WORD *)&v170[12] = 1024;
          *(_DWORD *)&v170[14] = 969;
          __int16 v171 = 2048;
          unint64_t v172 = v26;
          __int16 v173 = 2048;
          unint64_t v174 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_233:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v7;
          __int16 v168 = 2048;
          *(void *)int v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_234:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v19;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_235:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_236:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_237:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_238:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_239:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_240:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_241:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v2;
          __int16 v168 = 2048;
          *(void *)int v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_242:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_243:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_244:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v26;
          __int16 v168 = 2048;
          *(void *)int v169 = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_245:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v2;
          __int16 v168 = 2048;
          *(void *)int v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_246:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v2;
          __int16 v168 = 2048;
          *(void *)int v169 = v7;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_247:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v2;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_248:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeManyStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 986;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v7;
          __int16 v168 = 2048;
          *(void *)int v169 = v2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_249:
          *(void *)long long v170 = 0;
          long long v178 = 0u;
          long long v179 = 0u;
          long long v176 = 0u;
          long long v177 = 0u;
          long long v175 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v167 = 136315906;
          *(void *)&v167[4] = "removeManyStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 986;
          *(_WORD *)&v167[18] = 2048;
          *(void *)&v167[20] = v7;
          __int16 v168 = 2048;
          *(void *)int v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_55:
        ++*(_DWORD *)(v4 + 24);
        unint64_t v37 = *(_anonymous_namespace_ **)v167;
        if (*(void *)v167 && *(void *)&v169[2]) {
          unint64_t v37 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v167 + 40))();
        }
        unint64_t v26 = *((void *)&v156 + 1);
        *((void *)&v175 + 1) = 0;
        *(void *)&long long v176 = 0;
        DWORD2(v176) = 0;
        *(void *)&long long v177 = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v175, 0);
        ++DWORD2(v176);
        uint64_t v38 = *(unsigned int *)(v4 + 800);
        if (v38)
        {
          uint64_t v39 = 0;
          uint64_t v40 = (int *)(*(void *)(v4 + 784) + 8);
          while (1)
          {
            int v41 = *v40;
            v40 += 14;
            if (v41 < 0) {
              break;
            }
            if (v38 == ++v39)
            {
              LODWORD(v39) = *(_DWORD *)(v4 + 800);
              break;
            }
          }
        }
        else
        {
          LODWORD(v39) = 0;
        }
        if (v38 != v39)
        {
          uint64_t v42 = v39;
          unsigned int v43 = *(_DWORD *)(v4 + 800);
          do
          {
            uint64_t v44 = *(void *)(v4 + 784) + 56 * v42;
            int v46 = *(unsigned __int16 *)(v44 + 16);
            long long v45 = (__n128 *)(v44 + 16);
            if (v46 == (unsigned __int16)v26
              && v45->n128_u16[1] == WORD1(v26)
              && ((v45->n128_u32[1] ^ HIDWORD(v26)) & 0xFFFFFF) == 0)
            {
              re::DynamicArray<re::internal::TypeAttributeKey>::add((uint64_t)&v175, v45);
              unsigned int v43 = *(_DWORD *)(v4 + 800);
            }
            if (v43 <= (int)v39 + 1) {
              unsigned int v47 = v39 + 1;
            }
            else {
              unsigned int v47 = v43;
            }
            while (1)
            {
              uint64_t v42 = (v39 + 1);
              if (v47 - 1 == v39) {
                break;
              }
              LODWORD(v39) = v39 + 1;
              unsigned int v48 = v42;
              if ((*(_DWORD *)(*(void *)(v4 + 784) + 56 * v42 + 8) & 0x80000000) != 0) {
                goto LABEL_77;
              }
            }
            unsigned int v48 = v47;
LABEL_77:
            LODWORD(v39) = v48;
          }
          while (v38 != v48);
        }
        uint64_t v49 = v177;
        re::TypeRegistry::removeAttributes(v4, (long long *)v177, v176);
        ++*(_DWORD *)(v4 + 24);
        uint64_t v50 = (_anonymous_namespace_ *)v175;
        if ((void)v175 && v49) {
          uint64_t v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v175 + 40))();
        }
        *((void *)&v175 + 1) = 0;
        *(void *)&long long v176 = 0;
        DWORD2(v176) = 0;
        *(void *)&long long v177 = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v175, 0);
        ++DWORD2(v176);
        uint64_t v51 = *(unsigned int *)(v4 + 800);
        if (v51)
        {
          uint64_t v52 = 0;
          uint64_t v53 = (int *)(*(void *)(v4 + 784) + 8);
          while (1)
          {
            int v54 = *v53;
            v53 += 14;
            if (v54 < 0) {
              break;
            }
            if (v51 == ++v52)
            {
              LODWORD(v52) = *(_DWORD *)(v4 + 800);
              break;
            }
          }
        }
        else
        {
          LODWORD(v52) = 0;
        }
        if (v51 != v52)
        {
          uint64_t v55 = v52;
          unsigned int v56 = *(_DWORD *)(v4 + 800);
          do
          {
            uint64_t v57 = *(void *)(v4 + 784);
            uint64_t v58 = v57 + 56 * v55;
            int v60 = *(unsigned __int16 *)(v58 + 24);
            uint64_t v59 = v58 + 24;
            if (v60 == (unsigned __int16)v26
              && *(unsigned __int16 *)(v59 + 2) == WORD1(v26)
              && ((*(_DWORD *)(v57 + 56 * v55 + 28) ^ HIDWORD(v26)) & 0xFFFFFF) == 0)
            {
              re::DynamicArray<re::internal::TypeAttributeKey>::add((uint64_t)&v175, (__n128 *)(v59 - 8));
              unsigned int v56 = *(_DWORD *)(v4 + 800);
            }
            if (v56 <= (int)v52 + 1) {
              unsigned int v61 = v52 + 1;
            }
            else {
              unsigned int v61 = v56;
            }
            while (1)
            {
              uint64_t v55 = (v52 + 1);
              if (v61 - 1 == v52) {
                break;
              }
              LODWORD(v52) = v52 + 1;
              unsigned int v62 = v55;
              if ((*(_DWORD *)(*(void *)(v4 + 784) + 56 * v55 + 8) & 0x80000000) != 0) {
                goto LABEL_100;
              }
            }
            unsigned int v62 = v61;
LABEL_100:
            LODWORD(v52) = v62;
          }
          while (v51 != v62);
        }
        unint64_t v28 = v177;
        re::TypeRegistry::removeAttributes(v4, (long long *)v177, v176);
        ++*(_DWORD *)(v4 + 24);
        if ((void)v175 && v28) {
          (*(void (**)(void))(*(void *)v175 + 40))();
        }
        unint64_t v6 = v4 + 32;
        uint64_t v63 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(v153, v26);
        unint64_t v27 = 152;
        if (v63)
        {
          unint64_t v19 = *v63 & 0xFFFFFF;
          switch(HIBYTE(*v63))
          {
            case 0:
              re::internal::assertLog((re::internal *)4, v64, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "removeType", 706);
              _os_crash();
              __break(1u);
              JUMPOUT(0x233D92128);
            case 1:
              unint64_t v27 = *(void *)(v4 + 264);
              if (v27 <= v19) {
                goto LABEL_234;
              }
              unint64_t v67 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v69 = 72 * v27 - (72 * v19 + 72);
                if (v69)
                {
                  uint64_t v68 = *(void *)(v4 + 280) + 72 * v19;
                  memmove((void *)v68, (const void *)(v68 + 72), v69 - 3);
                  unint64_t v67 = *(void *)(v4 + 264) - 1;
                }
              }
              *(void *)(v4 + 264) = v67;
              ++*(_DWORD *)(v4 + 272);
              if (v67 > v19)
              {
                LODWORD(v7) = v19;
                do
                {
                  uint64_t v70 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 280) + 72 * v19));
                  unint64_t v19 = (v7 + 1);
                  *(_DWORD *)uint64_t v70 = v7 & 0xFFFFFF | (*(unsigned __int8 *)(v70 + 3) << 24);
                  unint64_t v7 = v19;
                }
                while (*(void *)(v4 + 264) > v19);
              }
              goto LABEL_106;
            case 2:
              unint64_t v26 = v19;
              unint64_t v6 = *(void *)(v4 + 304);
              if (v6 <= v19) {
                goto LABEL_235;
              }
              int v71 = (unsigned int *)(*(void *)(v4 + 320) + 96 * v19);
              unint64_t v28 = v71[20];
              unsigned int v72 = v71[21];
              unsigned int v73 = v71[22];
              unint64_t v2 = v73 + v72;
              if (!(v73 + v72)) {
                goto LABEL_127;
              }
              unint64_t v150 = v73 + v72;
              unint64_t v7 = v28 + v2 - 1;
              unint64_t v2 = *(void *)(v4 + 344);
              if (v7 >= v2) {
                goto LABEL_248;
              }
              if (v7 < v2 - 1)
              {
                uint64_t v74 = *(void *)(v4 + 360);
                if (v74 + 24 * v28 + 24 * v150 != v74 + 24 * v2)
                {
                  uint64_t v75 = 24 * v28;
                  uint64_t v76 = v74 + 24 * v150;
                  uint64_t v77 = 24 * v2 - 24 * v150;
                  do
                  {
                    uint64_t v78 = v76 + v75;
                    uint64_t v79 = (void *)(v74 + v75);
                    void *v79 = *(void *)(v76 + 24 * v28);
                    uint64_t v80 = *(void *)(v76 + v75 + 8);
                    uint64_t v81 = *(void *)(v76 + v75 + 16);
                    *(void *)(v78 + 8) = 0;
                    *(void *)(v78 + 16) = "";
                    uint64_t v82 = *(void *)(v74 + v75 + 16);
                    unint64_t v83 = v80 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v74 + v75 + 8) & 1;
                    v79[2] = v81;
                    *(void *)&long long v175 = v83;
                    *((void *)&v175 + 1) = v82;
                    v79[1] = v80;
                    re::StringID::destroyString((re::StringID *)&v175);
                    v74 += 24;
                    v76 += 24;
                    v77 -= 24;
                  }
                  while (v75 != v77);
                }
              }
              unint64_t v7 = 0;
              unint64_t v2 = v150;
              unint64_t v27 = -(uint64_t)v150;
              do
              {
                re::StringID::destroyString((re::StringID *)(*(void *)(v4 + 360)
                                                           + 24 * (v7 + *(void *)(v4 + 344))
                                                           - 16));
                --v7;
              }
              while (v27 != v7);
              *(void *)(v4 + 344) -= v150;
              ++*(_DWORD *)(v4 + 352);
              unint64_t v6 = *(void *)(v4 + 304);
              if (v6)
              {
LABEL_127:
                char v84 = (_DWORD *)(*(void *)(v4 + 320) + 80);
                unint64_t v85 = v6;
                do
                {
                  if (*v84 > v28) {
                    *v84 -= v2;
                  }
                  v84 += 24;
                  --v85;
                }
                while (v85);
              }
              if (v6 <= v19) {
                goto LABEL_243;
              }
              unint64_t v86 = v6 - 1;
              if (v6 - 1 <= v19)
              {
                unint64_t v6 = v4 + 32;
              }
              else
              {
                uint64_t v88 = 96 * v6 - (96 * v19 + 96);
                unint64_t v6 = v4 + 32;
                if (v88)
                {
                  uint64_t v87 = *(void *)(v4 + 320) + 96 * v19;
                  memmove((void *)v87, (const void *)(v87 + 96), v88 - 4);
                  unint64_t v86 = *(void *)(v4 + 304) - 1;
                }
              }
              *(void *)(v4 + 304) = v86;
              ++*(_DWORD *)(v4 + 312);
              while (v86 > v26)
              {
                uint64_t v142 = re::DataArray<re::internal::TypeInfoIndex>::get(v6, *(void *)(*(void *)(v4 + 320) + 96 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v142 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v142 + 3) << 24);
                unint64_t v86 = *(void *)(v4 + 304);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 3:
              unint64_t v26 = v19;
              unint64_t v27 = *(void *)(v4 + 384);
              if (v27 <= v19) {
                goto LABEL_236;
              }
              unint64_t v89 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v90 = *(void *)(v4 + 400);
                uint64_t v91 = v90 + 96 * v19;
                uint64_t v92 = v90 + 96 * v27;
                if (v92 != v91 + 96)
                {
                  memmove((void *)v91, (const void *)(v91 + 96), v92 - (v91 + 96));
                  unint64_t v89 = *(void *)(v4 + 384) - 1;
                }
              }
              *(void *)(v4 + 384) = v89;
              ++*(_DWORD *)(v4 + 392);
              while (v89 > v26)
              {
                uint64_t v93 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 400) + 96 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v93 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v93 + 3) << 24);
                unint64_t v89 = *(void *)(v4 + 384);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 4:
              unint64_t v26 = v19;
              unint64_t v27 = *(void *)(v4 + 424);
              if (v27 <= v19) {
                goto LABEL_237;
              }
              unint64_t v94 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v96 = 96 * v27 - (96 * v19 + 96);
                if (v96)
                {
                  uint64_t v95 = *(void *)(v4 + 440) + 96 * v19;
                  memmove((void *)v95, (const void *)(v95 + 96), v96 - 4);
                  unint64_t v94 = *(void *)(v4 + 424) - 1;
                }
              }
              *(void *)(v4 + 424) = v94;
              ++*(_DWORD *)(v4 + 432);
              while (v94 > v26)
              {
                uint64_t v97 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 440) + 96 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v97 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v97 + 3) << 24);
                unint64_t v94 = *(void *)(v4 + 424);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 5:
              unint64_t v26 = v19;
              unint64_t v27 = *(void *)(v4 + 464);
              if (v27 <= v19) {
                goto LABEL_238;
              }
              unint64_t v98 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v99 = *(void *)(v4 + 480);
                uint64_t v100 = v99 + ((unint64_t)v19 << 7);
                uint64_t v101 = v99 + (v27 << 7);
                if (v101 != v100 + 128)
                {
                  memmove((void *)v100, (const void *)(v100 + 128), v101 - (v100 + 128));
                  unint64_t v98 = *(void *)(v4 + 464) - 1;
                }
              }
              *(void *)(v4 + 464) = v98;
              ++*(_DWORD *)(v4 + 472);
              while (v98 > v26)
              {
                uint64_t v102 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 480) + (v26 << 7)));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v102 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v102 + 3) << 24);
                unint64_t v98 = *(void *)(v4 + 464);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 6:
              unint64_t v26 = v19;
              unint64_t v27 = *(void *)(v4 + 504);
              if (v27 <= v19) {
                goto LABEL_239;
              }
              unint64_t v103 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v104 = *(void *)(v4 + 520);
                uint64_t v105 = v104 + 160 * v19;
                uint64_t v106 = v104 + 160 * v27;
                if (v106 != v105 + 160)
                {
                  memmove((void *)v105, (const void *)(v105 + 160), v106 - (v105 + 160));
                  unint64_t v103 = *(void *)(v4 + 504) - 1;
                }
              }
              *(void *)(v4 + 504) = v103;
              ++*(_DWORD *)(v4 + 512);
              while (v103 > v26)
              {
                uint64_t v107 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 520) + 160 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v107 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v107 + 3) << 24);
                unint64_t v103 = *(void *)(v4 + 504);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 7:
              unint64_t v26 = v19;
              unint64_t v28 = *(void *)(v4 + 544);
              if (v28 <= v19) {
                goto LABEL_240;
              }
              uint64_t v108 = *(void *)(v4 + 560) + 96 * v19;
              uint64_t v109 = *(unsigned int *)(v108 + 84);
              unint64_t v2 = *(unsigned int *)(v108 + 88);
              if (!v2) {
                goto LABEL_216;
              }
              unint64_t v7 = v109 + v2 - 1;
              unint64_t v27 = *(void *)(v4 + 584);
              if (v7 >= v27) {
                goto LABEL_249;
              }
              if (v7 >= v27 - 1
                || (uint64_t v110 = *(void *)(v4 + 600),
                    uint64_t v111 = (char *)(v110 + 8 * v109),
                    __int16 v112 = &v111[8 * v2],
                    unint64_t v113 = (unsigned char *)(v110 + 8 * v27),
                    v113 == v112))
              {
                *(void *)(v4 + 584) = v27 - v2;
                ++*(_DWORD *)(v4 + 592);
              }
              else
              {
                memmove(v111, v112, v113 - v112);
                unint64_t v28 = *(void *)(v4 + 544);
                *(void *)(v4 + 584) -= v2;
                ++*(_DWORD *)(v4 + 592);
                if (!v28) {
                  goto LABEL_220;
                }
              }
LABEL_216:
              char v143 = (_DWORD *)(*(void *)(v4 + 560) + 84);
              unint64_t v144 = v28;
              do
              {
                if (*v143 > v109) {
                  *v143 -= v2;
                }
                v143 += 24;
                --v144;
              }
              while (v144);
LABEL_220:
              unint64_t v6 = v4 + 32;
              if (v28 <= v19) {
                goto LABEL_244;
              }
              unint64_t v145 = v28 - 1;
              if (v28 - 1 > v19)
              {
                uint64_t v147 = 96 * v28 - (96 * v19 + 96);
                if (v147)
                {
                  uint64_t v146 = *(void *)(v4 + 560) + 96 * v19;
                  memmove((void *)v146, (const void *)(v146 + 96), v147 - 4);
                  unint64_t v145 = *(void *)(v4 + 544) - 1;
                }
              }
              *(void *)(v4 + 544) = v145;
              ++*(_DWORD *)(v4 + 552);
              while (v145 > v26)
              {
                uint64_t v148 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 560) + 96 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v148 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v148 + 3) << 24);
                unint64_t v145 = *(void *)(v4 + 544);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 8:
              unint64_t v2 = v19;
              unint64_t v26 = *(void *)(v4 + 624);
              if (v26 <= v19) {
                goto LABEL_241;
              }
              uint64_t v114 = *(void *)(v4 + 640);
              uint64_t v115 = v114 + 152 * v19;
              break;
            case 9:
              unint64_t v26 = v19;
              unint64_t v27 = *(void *)(v4 + 744);
              if (v27 <= v19) {
                goto LABEL_242;
              }
              unint64_t v117 = v27 - 1;
              if (v27 - 1 > v19)
              {
                uint64_t v119 = 104 * v27 - (104 * v19 + 104);
                if (v119)
                {
                  uint64_t v118 = *(void *)(v4 + 760) + 104 * v19;
                  memmove((void *)v118, (const void *)(v118 + 104), v119 - 4);
                  unint64_t v117 = *(void *)(v4 + 744) - 1;
                }
              }
              *(void *)(v4 + 744) = v117;
              ++*(_DWORD *)(v4 + 752);
              while (v117 > v26)
              {
                uint64_t v120 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(void *)(*(void *)(v4 + 760) + 104 * v26));
                unint64_t v26 = (v19 + 1);
                *(_DWORD *)uint64_t v120 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v120 + 3) << 24);
                unint64_t v117 = *(void *)(v4 + 744);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            default:
              JUMPOUT(0);
          }
          while (1)
          {
            uint64_t v116 = *(void *)(v115 + 72);
            if ((v116 & 0xFFFFFF00000000) == 0) {
              break;
            }
            unint64_t v7 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v153, v116) & 0xFFFFFFLL;
            unint64_t v26 = *(void *)(v4 + 624);
            if (v26 <= v7) {
              goto LABEL_233;
            }
            uint64_t v114 = *(void *)(v4 + 640);
            uint64_t v115 = v114 + 152 * v7;
            --*(_DWORD *)(v115 + 80);
          }
          if (v26 <= v19) {
            goto LABEL_245;
          }
          uint64_t v121 = v114 + 152 * v19;
          unint64_t v122 = *(unsigned int *)(v121 + 84);
          unsigned int v123 = *(_DWORD *)(v121 + 88);
          unint64_t v27 = v4 + 648;
          re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(v151, v122, v123);
          unint64_t v7 = *(void *)(v4 + 624);
          if (v7 <= v19) {
            goto LABEL_246;
          }
          uint64_t v124 = *(void *)(v4 + 640) + 152 * v19;
          unsigned int v125 = *(_DWORD *)(v124 + 92);
          unint64_t v7 = *(unsigned int *)(v124 + 96);
          re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(v151, v125, v7);
          unint64_t v27 = *(void *)(v4 + 624);
          if (v27)
          {
            uint64_t v126 = (_DWORD *)(*(void *)(v4 + 640) + 84);
            uint64_t v127 = *(void *)(v4 + 624);
            do
            {
              if (*v126 > v122) {
                *v126 -= v123;
              }
              unint64_t v128 = (int)v126[13];
              if (v128 > v122) {
                v126[13] = v128 - v123;
              }
              unsigned int v129 = v126[2];
              if (v129 > v125) {
                v126[2] = v129 - v7;
              }
              v126 += 38;
              --v127;
            }
            while (v127);
          }
          unint64_t v6 = v4 + 32;
          if (v27 <= v19) {
            goto LABEL_247;
          }
          uint64_t v130 = *(void *)(v4 + 640);
          unint64_t v7 = 152;
          if (v27 - 1 > v19 && v130 + 152 * v19 + 152 != v130 + 152 * v27)
          {
            uint64_t v131 = 152 * v19;
            uint64_t v132 = 152 * v27 - 152;
            do
            {
              uint64_t v133 = v130 + v131;
              *(_DWORD *)(v133 + 64) = *(_DWORD *)(v130 + v131 + 216);
              uint64_t v134 = *(void *)(v130 + v131 + 256);
              uint64_t v135 = *(void *)(v130 + v131 + 264);
              uint64_t v136 = *(void *)(v130 + v131 + 112);
              unint64_t v137 = v134 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v130 + v131 + 104) & 1;
              long long v138 = *(_OWORD *)(v130 + v131 + 168);
              long long v139 = *(_OWORD *)(v130 + v131 + 200);
              *(_OWORD *)(v133 + 32) = *(_OWORD *)(v130 + v131 + 184);
              *(_OWORD *)(v133 + 48) = v139;
              *(_OWORD *)uint64_t v133 = *(_OWORD *)(v130 + v131 + 152);
              *(_OWORD *)(v133 + 16) = v138;
              *(_OWORD *)(v133 + 72) = *(_OWORD *)(v130 + v131 + 224);
              *(_OWORD *)(v133 + 84) = *(_OWORD *)(v130 + v131 + 236);
              *(void *)(v133 + 256) = 0;
              *(void *)(v133 + 264) = "";
              *(void *)(v133 + 112) = v135;
              *(void *)&long long v175 = v137;
              *((void *)&v175 + 1) = v136;
              *(void *)(v133 + 104) = v134;
              re::StringID::destroyString((re::StringID *)&v175);
              if (*(unsigned char *)(v130 + v131 + 120) || *(unsigned char *)(v130 + v131 + 272))
              {
                if (!*(unsigned char *)(v130 + v131 + 120) || *(unsigned char *)(v130 + v131 + 272))
                {
                  if (!*(unsigned char *)(v130 + v131 + 120) && *(unsigned char *)(v130 + v131 + 272)) {
                    *(unsigned char *)(v133 + 12re::InputManager::notify(8, 0, 0, 0) = 1;
                  }
                  *(void *)(v130 + v131 + 128) = *(void *)(v130 + v131 + 280);
                }
                else
                {
                  *(unsigned char *)(v133 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
                }
              }
              *(_OWORD *)(v130 + v131 + 136) = *(_OWORD *)(v130 + v131 + 288);
              v130 += 152;
              v132 -= 152;
            }
            while (v131 != v132);
            unint64_t v27 = *(void *)(v4 + 624);
            uint64_t v130 = *(void *)(v4 + 640);
            unint64_t v6 = v4 + 32;
            unint64_t v7 = 152;
          }
          re::StringID::destroyString((re::StringID *)(v130 + 152 * v27 - 48));
          unint64_t v140 = *(void *)(v4 + 624) - 1;
          *(void *)(v4 + 624) = v140;
          ++*(_DWORD *)(v4 + 632);
          while (v140 > v2)
          {
            uint64_t v141 = re::DataArray<re::internal::TypeInfoIndex>::get(v6, *(void *)(*(void *)(v4 + 640) + 152 * v2));
            unint64_t v2 = (v19 + 1);
            *(_DWORD *)uint64_t v141 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v141 + 3) << 24);
            unint64_t v140 = *(void *)(v4 + 624);
            LODWORD(v19) = v19 + 1;
          }
        }
LABEL_106:
        unint64_t v65 = re::TypeRegistry::typeName((_anonymous_namespace_ *)v4, &v156);
        re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(v155, v65);
        unint64_t v66 = *((void *)&v156 + 1);
        re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy(v4 + 96, *((unint64_t *)&v156 + 1));
        uint64_t v8 = (_anonymous_namespace_ *)re::DataArray<re::internal::TypeInfoIndex>::destroy(v6, v66);
        uint64_t v16 = v154 + 1;
        if (v154 + 1 == v152) {
          goto LABEL_227;
        }
      }
      unint64_t v2 = 0;
      unint64_t v6 = HIDWORD(v17);
      while (1)
      {
        if (*(void *)(v4 + 200))
        {
          uint64_t v20 = (void *)(*(void *)(v4 + 192) + 16 * v2);
          unint64_t v21 = 0xBF58476D1CE4E5B9 * ((*v20 >> 31) ^ (*v20 >> 1));
          uint64_t v22 = *(void *)(v4 + 216);
          unint64_t v7 = *(unsigned int *)(*(void *)(v4 + 208)
                               + 4
                               * (((0x94D049BB133111EBLL * (v21 ^ (v21 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                                  * (v21 ^ (v21 >> 27))) >> 31))
                                % *(unsigned int *)(v4 + 224)));
          if (v7 != 0x7FFFFFFF)
          {
            while (!re::StringID::operator==((void *)(v22 + 32 * v7 + 8), v20))
            {
              unint64_t v7 = *(_DWORD *)(v22 + 32 * v7) & 0x7FFFFFFF;
              if (v7 == 0x7FFFFFFF) {
                goto LABEL_36;
              }
            }
            goto LABEL_37;
          }
        }
        else
        {
          uint64_t v22 = *(void *)(v4 + 216);
        }
LABEL_36:
        unint64_t v7 = 0x7FFFFFFFLL;
LABEL_37:
        uint64_t v23 = v22 + 32 * v7;
        int v25 = *(unsigned __int16 *)(v23 + 24);
        uint64_t v24 = v23 + 24;
        if (v25 == (unsigned __int16)v17
          && *(unsigned __int16 *)(v24 + 2) == WORD1(v17)
          && ((*(_DWORD *)(v22 + 32 * v7 + 28) ^ HIDWORD(v17)) & 0xFFFFFF) == 0)
        {
          re::DynamicArray<unsigned long>::add(v167, &v175);
          unint64_t v2 = v175;
          unint64_t v19 = *(void *)(v4 + 176);
        }
        *(void *)&long long v175 = ++v2;
        if (v2 >= v19) {
          goto LABEL_42;
        }
      }
    }
LABEL_227:
    ++*(_DWORD *)(v4 + 24);
    double v149 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)__b);
    uint64_t result = (_anonymous_namespace_ *)v162[0];
    if (v162[0] && v165) {
      return (_anonymous_namespace_ *)(*(uint64_t (**)(double))(*(void *)v162[0] + 40))(v149);
    }
  }
  return result;
}

void re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unint64_t v5 = a2 + a3 - 1;
    unint64_t v6 = *(void *)(a1 + 16);
    if (v5 >= v6)
    {
      memset(v18, 0, sizeof(v18));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7 + 40 * a2 + 40 * a3 != v7 + 40 * v6)
      {
        uint64_t v8 = 40 * a2;
        uint64_t v9 = v7 + 40 * a3;
        uint64_t v10 = 40 * v6 - 40 * a3;
        do
        {
          uint64_t v11 = v9 + v8;
          uint64_t v12 = v7 + v8;
          *(void *)uint64_t v12 = *(void *)(v9 + v8);
          uint64_t v13 = *(void *)(v9 + v8 + 8);
          uint64_t v14 = *(void *)(v9 + v8 + 16);
          *(void *)(v11 + 8) = 0;
          *(void *)(v11 + 16) = "";
          uint64_t v15 = *(void *)(v7 + v8 + 16);
          unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v7 + v8 + 8) & 1;
          *(void *)(v12 + 16) = v14;
          *(void *)&v18[0] = v16;
          *((void *)&v18[0] + 1) = v15;
          *(void *)(v12 + 8) = v13;
          re::StringID::destroyString((re::StringID *)v18);
          *(void *)(v12 + 24) = *(void *)(v9 + v8 + 24);
          *(_DWORD *)(v12 + 32) = *(_DWORD *)(v9 + v8 + 32);
          v9 += 40;
          v7 += 40;
          v10 -= 40;
        }
        while (v8 != v10);
      }
    }
    uint64_t v17 = 0;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + 40 * (v17 + *(void *)(a1 + 16)) - 32));
      --v17;
    }
    while (-a3 != v17);
    *(void *)(a1 + 16) -= a3;
    ++*(_DWORD *)(a1 + 24);
  }
}

void re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(uint64_t a1, void *a2)
{
  if (*(void *)a1)
  {
    unint64_t v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
    unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
       % *(unsigned int *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v8 = *(void *)(a1 + 16);
      if (re::StringID::operator==((void *)(v8 + 32 * v7 + 8), a2))
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 32 * v7) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v11 = *(void *)(a1 + 16);
        uint64_t v12 = (int *)(v11 + 32 * v7);
        int v13 = *v12;
        if (*v12 < 0)
        {
          int *v12 = v13 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v12 + 2));
          uint64_t v11 = *(void *)(a1 + 16);
          int v13 = *(_DWORD *)(v11 + 32 * v7);
        }
        int v14 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 32 * v7) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v14 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v9 = v7;
          int v10 = *(_DWORD *)(v8 + 32 * v7);
          uint64_t v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          if (re::StringID::operator==((void *)(v8 + 32 * v7 + 8), a2))
          {
            *(_DWORD *)(v8 + 32 * v9) = *(_DWORD *)(v8 + 32 * v9) & 0x80000000 | *(_DWORD *)(v8 + 32 * v7) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = (re::StringID *)re::DataArray<re::TextureAtlasTile>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    uint64_t v6 = v5;
    re::StringID::destroyString(v5);
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

_DWORD *re::DataArray<re::internal::TypeInfoIndex>::destroy(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  uint64_t result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *uint64_t result = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

__n128 re::DynamicArray<re::internal::TypeAttributeKey>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = (__n128 *)(*(void *)(a1 + 32) + 24 * v5);
  __n128 result = *a2;
  v11[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v11 = result;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::TypeRegistry::removeAttributes(uint64_t a1, long long *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a2;
    unint64_t v5 = (long long *)((char *)a2 + 24 * a3);
    do
    {
      long long v6 = *v3;
      uint64_t v26 = *((void *)v3 + 2);
      long long v25 = v6;
      unint64_t v7 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)v23, (uint64_t)&v25);
      if (*(void *)(a1 + 768)
        && (uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 776) + 4 * (v7 % *(unsigned int *)(a1 + 792))),
            v8 != 0x7FFFFFFF))
      {
        uint64_t v22 = *(void *)(a1 + 784);
        while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v22 + 56 * v8 + 16), (uint64_t *)&v25))
        {
          uint64_t v22 = *(void *)(a1 + 784);
          uint64_t v8 = *(_DWORD *)(v22 + 56 * v8 + 8) & 0x7FFFFFFF;
          uint64_t v9 = 0x7FFFFFFFLL;
          if (v8 == 0x7FFFFFFF) {
            goto LABEL_6;
          }
        }
        uint64_t v9 = v8;
      }
      else
      {
        uint64_t v9 = 0x7FFFFFFFLL;
      }
LABEL_6:
      uint64_t v10 = *(void *)(a1 + 784);
      unint64_t v11 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)v23, (uint64_t)&v25);
      if (*(void *)(a1 + 768))
      {
        unint64_t v12 = v11 % *(unsigned int *)(a1 + 792);
        uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 776) + 4 * v12);
        if (v13 != 0x7FFFFFFF)
        {
          if (re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(*(void *)(a1 + 784) + 56 * v13 + 16), (uint64_t *)&v25))
          {
            *(_DWORD *)(*(void *)(a1 + 776) + 4 * v12) = *(_DWORD *)(*(void *)(a1 + 784)
                                                                     + 56 * v13
                                                                     + 8) & 0x7FFFFFFF;
LABEL_13:
            uint64_t v16 = *(void *)(a1 + 784);
            uint64_t v17 = v16 + 56 * v13;
            int v20 = *(_DWORD *)(v17 + 8);
            uint64_t v19 = (int *)(v17 + 8);
            int v18 = v20;
            if (v20 < 0)
            {
              int *v19 = v18 & 0x7FFFFFFF;
              uint64_t v16 = *(void *)(a1 + 784);
              int v18 = *(_DWORD *)(v16 + 56 * v13 + 8);
            }
            *(_DWORD *)(v16 + 56 * v13 + 8) = *(_DWORD *)(a1 + 804) | v18 & 0x80000000;
            *(_DWORD *)(a1 + 804) = v13;
            --*(_DWORD *)(a1 + 796);
            ++*(_DWORD *)(a1 + 808);
          }
          else
          {
            while (1)
            {
              uint64_t v14 = v13;
              uint64_t v15 = *(void *)(a1 + 784);
              uint64_t v13 = *(_DWORD *)(v15 + 56 * v13 + 8) & 0x7FFFFFFF;
              if (v13 == 0x7FFFFFFF) {
                break;
              }
              if (re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v15 + 56 * v13 + 16), (uint64_t *)&v25))
              {
                *(_DWORD *)(*(void *)(a1 + 784) + 56 * v14 + 8) = *(_DWORD *)(*(void *)(a1 + 784) + 56 * v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 784) + 56 * v13 + 8) & 0x7FFFFFFF;
                goto LABEL_13;
              }
            }
          }
        }
      }
      unint64_t v21 = (void **)(v10 + 56 * v9 + 40);
      if (*v21)
      {
        if (*(unsigned char *)(v10 + 56 * v9 + 48))
        {
          re::TypeRegistry::typeInfo((void *)a1, v25, v23);
          re::TypeInfo::releaseInstance((re::TypeInfo *)&v24, *v21, *(re::Allocator **)(a1 + 16), 0);
        }
      }
      uint64_t v3 = (long long *)((char *)v3 + 24);
    }
    while (v3 != v5);
  }
}

void re::TypeRegistry::overrideAllocator(re *a1, re **a2, int a3)
{
  if (!*a2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overrideAllocator", 787);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (*a2 != a1)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overrideAllocator", 788);
    _os_crash();
    __break(1u);
    return;
  }
  re::TypeRegistry::typeInfo(a1, a2, v6);
  if (a3) {
    int v5 = 32;
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)(v7 + 48) = *(_DWORD *)(v7 + 48) & 0xFFFFFFDF | v5;
  ++*((_DWORD *)a1 + 6);
}

uint64_t re::TypeRegistry::buildTranslationTable(uint64_t **this, const re::TypeRegistry *a2)
{
  if (a2)
  {
    re::TypeRegistry::setContainsPolymorphicFlags((re::TypeRegistry *)this);
    unint64_t v4 = this[107];
    if (v4)
    {
      int v5 = this[2];
      re::FixedArray<CoreIKTransform>::deinit(v4 + 33);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 30);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 27);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 24);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 21);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 18);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 15);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 12);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 9);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 6);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 3);
      (*(void (**)(uint64_t *, uint64_t *))(*v5 + 40))(v5, v4);
      this[107] = 0;
    }
    uint64_t v6 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*this[2] + 32))(this[2], 288, 8);
    *(void *)uint64_t v6 = this;
    *(void *)(v6 + 8) = a2;
    *(_OWORD *)(v6 + 4re::InputManager::notify(8, 0, 0, 0) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 104) = 0u;
    *(_OWORD *)(v6 + 12re::InputManager::notify(8, 0, 0, 0) = 0u;
    *(_OWORD *)(v6 + 136) = 0u;
    *(_OWORD *)(v6 + 152) = 0u;
    *(_OWORD *)(v6 + 168) = 0u;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_OWORD *)(v6 + 20re::InputManager::notify(8, 0, 0, 0) = 0u;
    *(_OWORD *)(v6 + 216) = 0u;
    *(_OWORD *)(v6 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 232) = 0u;
    *(_OWORD *)(v6 + 248) = 0u;
    *(void *)(v6 + 28re::InputManager::notify(8, 0, 0, 0) = 0;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 264) = 0u;
    uint64_t result = re::internal::TypeTranslationTable::buildTables((re::internal::TypeTranslationTable *)v6);
    this[107] = (uint64_t *)v6;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, 0, "assertion failure: '%s' (%s:line %i) runtimeTypeRegistry must not be null.", "runtimeTypeRegistry", "buildTranslationTable", 801);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeRegistry::setContainsPolymorphicFlags(re::TypeRegistry *this)
{
  int v2 = (char *)this + 32;
  uint64_t result = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v9, (uint64_t)this + 32, 0);
  unint64_t v12 = this;
  uint64_t v13 = v9;
  uint64_t v14 = v10[0];
  if (v2 != v9 || LOWORD(v10[0]) != 0xFFFFLL || (v10[0] & 0xFFFF0000) != 4294901760)
  {
    do
    {
      uint64_t v6 = (re *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v13);
      v11[0] = v12;
      v11[1] = v6;
      re::TypeRegistry::typeInfo(this, v11, &v9);
      if ((_BYTE)v9) {
        re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v10);
      }
      uint64_t result = (uint64_t)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v13);
    }
    while (v13 != v2 || (unsigned __int16)v14 != 0xFFFF || WORD1(v14) != 0xFFFF);
  }
  return result;
}

uint64_t re::TypeRegistry::setContainsPolymorphicFlag(re::TypeRegistry *this, const re::TypeInfo *a2)
{
  uint64_t v2 = *((void *)a2 + 2);
  unsigned int v3 = *(_DWORD *)(v2 + 48);
  if ((v3 & 0x40) != 0) {
    return (v3 >> 7) & 1;
  }
  *(_DWORD *)(v2 + 48) = v3 | 0x40;
  switch(*((unsigned char *)a2 + 12))
  {
    case 0:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "setContainsPolymorphicFlag", 940);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D93100);
    case 3:
    case 4:
    case 5:
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      uint64_t v6 = (const re::TypeInfo *)v18;
      goto LABEL_4;
    case 6:
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      if (re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v18)) {
        goto LABEL_23;
      }
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 80), v20);
      re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)v21);
      uint64_t v6 = (const re::TypeInfo *)v16;
LABEL_4:
      char v7 = re::TypeRegistry::setContainsPolymorphicFlag(this, v6);
      int v8 = *(_DWORD *)(v2 + 48);
      if (v7) {
        goto LABEL_24;
      }
      uint64_t result = 0;
      goto LABEL_26;
    case 7:
      uint64_t v10 = *(unsigned int *)(*((void *)a2 + 2) + 88);
      if (!v10) {
        goto LABEL_25;
      }
      uint64_t v11 = 0;
      while (1)
      {
        re::TypeInfo::unionMember(a2, v11, (uint64_t)v20);
        if (re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v20)) {
          goto LABEL_23;
        }
        if (v10 == ++v11) {
          goto LABEL_25;
        }
      }
    case 8:
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), v18);
      if (v18[0] && re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)&v19)) {
        goto LABEL_23;
      }
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *(void *)a2, *((void *)a2 + 2));
      if (!v17) {
        goto LABEL_25;
      }
      unint64_t v12 = 0;
      break;
    case 9:
      if (re::TypeInfo::isPointerToPolymorphicType(a2)) {
        goto LABEL_23;
      }
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      if (re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v18)) {
        goto LABEL_23;
      }
      goto LABEL_25;
    default:
      goto LABEL_25;
  }
  do
  {
    re::TypeMemberCollection::operator[](v16, v12, (uint64_t)v15);
    re::TypeRegistry::typeInfo(v15[0], *v15[2], v20);
    re::TypeInfo::TypeInfo((uint64_t)v14, (uint64_t)v21);
    if (re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v14))
    {
LABEL_23:
      int v8 = *(_DWORD *)(v2 + 48);
LABEL_24:
      unsigned int v13 = v8 | 0x80;
      uint64_t result = 1;
      goto LABEL_27;
    }
    ++v12;
  }
  while (v12 < v17);
LABEL_25:
  uint64_t result = 0;
  int v8 = *(_DWORD *)(v2 + 48);
LABEL_26:
  unsigned int v13 = v8 & 0xFFFFFF7F;
LABEL_27:
  *(_DWORD *)(v2 + 48) = v13;
  return result;
}

uint64_t re::TypeRegistry::fixupUndefinedInitialRelease(re::TypeRegistry *this)
{
  uint64_t v2 = (char *)this + 32;
  uint64_t result = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v9, (uint64_t)this + 32, 0);
  unint64_t v12 = this;
  unsigned int v13 = v9;
  uint64_t v14 = v10[0];
  if (v2 != v9 || LOWORD(v10[0]) != 0xFFFFLL || (v10[0] & 0xFFFF0000) != 4294901760)
  {
    do
    {
      uint64_t v6 = (re *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v13);
      v11[0] = v12;
      v11[1] = v6;
      re::TypeRegistry::typeInfo(this, v11, &v9);
      if ((_BYTE)v9) {
        re::TypeRegistry::fixupUndefinedInitialRelease(this, (const re::TypeInfo *)v10);
      }
      uint64_t result = (uint64_t)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v13);
    }
    while (v13 != v2 || (unsigned __int16)v14 != 0xFFFF || WORD1(v14) != 0xFFFF);
  }
  return result;
}

void *re::TypeRegistry::fixupUndefinedInitialRelease(void *this, const re::TypeInfo *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)a2 + 2);
  if (*(_DWORD *)(v2 + 64) == -1)
  {
    unint64_t v4 = this;
    this = (void *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(this + 4), *(void *)v2);
    int v5 = this;
    int v6 = *((unsigned __int8 *)a2 + 12);
    if (v6 == 6)
    {
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), &v20);
      this = (void *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
      unsigned int v12 = *(_DWORD *)(*(void *)&v17[2] + 64);
      if (v12 == -1) {
        return this;
      }
      re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 80), &v20);
      this = (void *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
      unint64_t v7 = *v5 & 0xFFFFFFLL;
      unint64_t v8 = v4[63];
      if (v8 > v7)
      {
        unsigned int v9 = *(_DWORD *)(*(void *)&v17[2] + 64);
        if (v12 > v9) {
          unsigned int v9 = v12;
        }
        uint64_t v10 = v4[65];
        unsigned int v11 = 160;
        goto LABEL_12;
      }
    }
    else
    {
      if (v6 == 5)
      {
        re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), &v20);
        this = (void *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
        unint64_t v7 = *v5 & 0xFFFFFFLL;
        unint64_t v8 = v4[58];
        if (v8 > v7)
        {
          unsigned int v9 = *(_DWORD *)(*(void *)&v17[2] + 64);
          unint64_t v13 = v4[60] + (v7 << 7);
          goto LABEL_15;
        }
      }
      else
      {
        if (v6 != 4) {
          return this;
        }
        re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*((void *)a2 + 2) + 72), &v20);
        this = (void *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
        unint64_t v7 = *v5 & 0xFFFFFFLL;
        unint64_t v8 = v4[53];
        if (v8 > v7)
        {
          unsigned int v9 = *(_DWORD *)(*(void *)&v17[2] + 64);
          uint64_t v10 = v4[55];
          unsigned int v11 = 96;
LABEL_12:
          unint64_t v13 = v10 + v7 * (unint64_t)v11;
LABEL_15:
          *(_DWORD *)(v13 + 64) = v9;
          return this;
        }
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v20 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v14 = 136315906;
        uint64_t v15 = "operator[]";
        __int16 v16 = 1024;
        *(_DWORD *)unint64_t v17 = 789;
        *(_WORD *)&v17[4] = 2048;
        *(void *)&v17[6] = v7;
        __int16 v18 = 2048;
        unint64_t v19 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v20 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v14 = 136315906;
      uint64_t v15 = "operator[]";
      __int16 v16 = 1024;
      *(_DWORD *)unint64_t v17 = 789;
      *(_WORD *)&v17[4] = 2048;
      *(void *)&v17[6] = v7;
      __int16 v18 = 2048;
      unint64_t v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v14 = 136315906;
    uint64_t v15 = "operator[]";
    __int16 v16 = 1024;
    *(_DWORD *)unint64_t v17 = 789;
    *(_WORD *)&v17[4] = 2048;
    *(void *)&v17[6] = v7;
    __int16 v18 = 2048;
    unint64_t v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return this;
}

_anonymous_namespace_ *re::DataArray<re::internal::TypeInfoIndex>::allocBlock(void *a1)
{
  uint64_t v3 = 4 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    uint64_t result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  unsigned int v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  *uint64_t v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

uint64_t re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,unsigned long long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 32 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 32 * v9 + 8), a4);
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::TypeMemberInfo::memberType@<X0>(re::TypeMemberInfo *this@<X0>, uint64_t a2@<X8>)
{
  re::TypeRegistry::typeInfo(*(void **)this, **((void **)this + 2), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeAttributeCollection::operator[](uint64_t *a1, void *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  v5[0] = a2[1];
  v5[1] = v2;
  int v6 = *((_DWORD *)a1 + 4);
  uint64_t result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v3 + 768, v5);
  if (result) {
    return *(void *)result;
  }
  return result;
}

{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;

  uint64_t v3 = *a1;
  uint64_t v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*a1 + 200, a2);
  if (v4)
  {
    unint64_t v7 = *v4;
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
  }
  int v6 = v3;
  return re::TypeAttributeCollection::operator[](a1, &v6);
}

void re::ArrayAccessor::reset(re::ArrayAccessor *this, void **a2, re::Allocator *a3, const re::TypeInfo *a4)
{
  uint64_t v8 = *(void **)this;
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v28);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v29);
  unsigned int v9 = v27[12];
  uint64_t v10 = *((void *)this + 2);
  if ((*(_DWORD *)(v10 + 84) & 0xFFFFFF) != 0)
  {
    re::TypeRegistry::typeInfo(v8, *(void *)(v10 + 80), v28);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v29);
    unint64_t v11 = (re::internal *)((char *)a2 + *(int *)(*((void *)this + 2) + 88));
    uint64_t Unsigned = re::internal::readUnsigned(v11, v25, v12);
    if (Unsigned)
    {
      if ((v9 & 1) == 0)
      {
        uint64_t v14 = Unsigned;
        for (uint64_t i = 0; i != v14; ++i)
        {
          __int16 v16 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, i);
          re::TypeInfo::destruct((re::TypeInfo *)v26, v16, a3, 0);
        }
      }
      (*(void (**)(re::Allocator *, void *))(*(void *)a3 + 40))(a3, *a2);
      re::internal::writeUnsigned(v11, v25, 0);
      *a2 = 0;
    }
    if (a4)
    {
      uint64_t v17 = re::internal::checkedArraySize(v27[2], (unint64_t)a4);
      re::internal::writeUnsigned(v11, v25, a4);
      __int16 v18 = (void **)(*(uint64_t (**)(re::Allocator *, uint64_t, void))(*(void *)a3 + 32))(a3, v17, v27[3]);
      *a2 = v18;
      if ((v9 & 1) == 0)
      {
        uint64_t v19 = 0;
        do
        {
          long long v20 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, v19);
          re::TypeInfo::construct((re::TypeInfo *)v26, v20, a3, 0);
          ++v19;
        }
        while (a4 != (const re::TypeInfo *)v19);
        return;
      }
      size_t v24 = v17;
LABEL_19:
      bzero(v18, v24);
    }
  }
  else
  {
    uint64_t v21 = *(int *)(v10 + 88);
    if (!v21) {
      return;
    }
    if (v9)
    {
      size_t v24 = re::internal::checkedArraySize(v27[2], (unint64_t)a4);
      __int16 v18 = a2;
      goto LABEL_19;
    }
    for (uint64_t j = 0; j != v21; ++j)
    {
      long long v23 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, j);
      re::TypeInfo::destruct((re::TypeInfo *)v26, v23, a3, 0);
      re::TypeInfo::construct((re::TypeInfo *)v26, v23, a3, 0);
    }
  }
}

uint64_t re::ArrayAccessor::elementAtUnchecked(re::ArrayAccessor *this, void **a2, uint64_t a3)
{
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v9);
  re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v10);
  if ((*(_DWORD *)(*((void *)this + 2) + 84) & 0xFFFFFF) != 0) {
    a2 = (void **)*a2;
  }
  return (uint64_t)a2 + *(unsigned int *)(v8 + 8) * a3;
}

uint64_t re::ArrayAccessor::size(re::ArrayAccessor *this, char *a2)
{
  uint64_t v2 = *((void *)this + 2);
  if ((*(_DWORD *)(v2 + 84) & 0xFFFFFF) == 0) {
    return *(int *)(v2 + 88);
  }
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(v2 + 80), v8);
  re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v9);
  return re::internal::readUnsigned((re::internal *)&a2[*(int *)(*((void *)this + 2) + 88)], v7, v5);
}

uint64_t re::IntrospectionWalker::walkPolymorphicPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(const void **)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t __dst = 0;
  memcpy(&__dst, v6, *(int *)(v7 + 20));
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(*(void *)(a1 + 16) + 8);
  if (*(void *)(v9 + 24) != __dst)
  {
    uint64_t v8 = 0;
    uint64_t v10 = (uint64_t *)(v9 + 64);
    do
    {
      ++v8;
      uint64_t v11 = *v10;
      v10 += 5;
    }
    while (v11 != __dst);
  }
  uint64_t v12 = v9 + 40 * v8;
  uint64_t v13 = a2 + *(int *)(v12 + 32);
  uint64_t v14 = *(void *)(v12 + 8);
  return re::IntrospectionWalker::walk(v14, v13, a3);
}

void re::IntrospectionWalker::walk(uint64_t a1, const re::IntrospectionBase **a2, uint64_t a3)
{
  v58[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a3 + 24);
  *(void *)&long long buf = a2;
  if (v6)
  {
    uint64_t v3 = a3;
    uint64_t v4 = a2;
    while (1)
    {
      uint64_t v7 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, long long *))(*(void *)v6 + 48))(v6, a1, &buf);
      int v9 = *(_DWORD *)(a1 + 16);
      if (v9 != 13) {
        break;
      }
      if (!(*(unsigned int (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 56))(a1, v4)) {
        return;
      }
      uint64_t v10 = *(void *)(a1 + 48);
      uint64_t v4 = (const re::IntrospectionBase **)(*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 80))(a1, v4);
      uint64_t v6 = *(void *)(v3 + 24);
      *(void *)&long long buf = v4;
      a1 = v10;
      if (!v6) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v7 = (re *)std::__throw_bad_function_call[abi:nn180100]();
  }
  switch(v9)
  {
    case 0:
    case 6:
    case 9:
    case 10:
      return;
    case 1:
      uint64_t v11 = *v4;
      if (v11)
      {
        re::PolymorphicData::makeWithPointer(*(void *)(a1 + 48), v11, &buf);
        if (v56) {
          re::IntrospectionWalker::walkPolymorphicPointer((uint64_t)&buf, (uint64_t)v11, v3);
        }
        else {
          re::IntrospectionWalker::walk(*(void *)(a1 + 48), v11, v3);
        }
      }
      return;
    case 2:
      if (*(int *)(a1 + 64) >= 1)
      {
        int v12 = 0;
        do
          re::IntrospectionWalker::walk(*(void *)(a1 + 48), (char *)v4 + *(int *)(*(void *)(a1 + 48) + 20) * (uint64_t)v12++, v3);
        while (v12 < *(_DWORD *)(a1 + 64));
      }
      return;
    case 3:
      if ((*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 88))(a1, v4))
      {
        unint64_t v13 = 0;
        do
        {
          uint64_t v14 = *(void *)(a1 + 48);
          uint64_t v15 = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **, unint64_t))(*(void *)a1 + 104))(a1, v4, v13);
          re::IntrospectionWalker::walk(v14, v15, v3);
          ++v13;
        }
        while ((*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 88))(a1, v4) > v13);
      }
      return;
    case 4:
      if ((*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 80))(a1, v4))
      {
        unint64_t v16 = 0;
        do
        {
          uint64_t v17 = *(void *)(a1 + 48);
          uint64_t v18 = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **, unint64_t))(*(void *)a1 + 104))(a1, v4, v16);
          re::IntrospectionWalker::walk(v17, v18, v3);
          ++v16;
        }
        while ((*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 80))(a1, v4) > v16);
      }
      return;
    case 5:
      *(void *)&long long buf = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 88))(a1, v4);
      *((void *)&buf + 1) = v19;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)a1 + 96))(a1, v4);
        if ((void)buf == v20 && WORD4(buf) == (unsigned __int16)v21 && WORD5(buf) == HIWORD(v21)) {
          break;
        }
        uint64_t v22 = *(void *)(a1 + 48);
        uint64_t v23 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)a1 + 104))(a1, &buf);
        re::IntrospectionWalker::walk(v22, v23, v3);
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&buf);
      }
      return;
    case 7:
      *(void *)&long long buf = &unk_26E715FF0;
      *((void *)&buf + 1) = a1;
      uint64_t v56 = v3;
      p_long long buf = &buf;
      (*(void (**)(uint64_t, const re::IntrospectionBase **, long long *))(*(void *)a1 + 104))(a1, v4, &buf);
      std::__function::__value_func<BOOL ()(void const*,void *)>::~__value_func[abi:nn180100](&buf);
      return;
    case 8:
      if (!*(_DWORD *)(a1 + 56)) {
        return;
      }
      uint64_t v24 = 0;
      break;
    case 11:
      if (*(void *)(a1 + 104))
      {
        uint64_t v37 = (*(uint64_t (**)(const re::IntrospectionBase **))(a1 + 96))(v4);
        if (v37)
        {
          uint64_t v38 = v37;
          for (uint64_t i = 0; i != v38; ++i)
          {
            uint64_t v40 = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(a1 + 104))(i, v4);
            if (v40) {
              BOOL v42 = v41 == 0;
            }
            else {
              BOOL v42 = 1;
            }
            if (!v42) {
              re::IntrospectionWalker::walk(v40, v41, v3);
            }
          }
        }
      }
      return;
    default:
      re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "walk", 156);
      _os_crash();
      __break(1u);
      return;
  }
  while (2)
  {
    uint64_t v25 = *(void *)(*(void *)(a1 + 64) + 8 * v24);
    if (*(_DWORD *)v25 != 1) {
      goto LABEL_42;
    }
    switch(*(_DWORD *)(v25 + 40))
    {
      case 0:
      case 3:
        uint64_t v7 = (re *)re::IntrospectionWalker::walk(*(void *)(v25 + 16), (char *)v4 + *(int *)(v25 + 36), v3);
        goto LABEL_42;
      case 1:
        uint64_t v26 = *(void *)(v25 + 48);
        if (v26)
        {
          uint64_t v27 = *(void *)(v25 + 16);
          unint64_t v28 = (char *)v4 + *(int *)(v25 + 64);
          unint64_t __dst = 0;
          uint64_t v29 = (re *)memcpy(&__dst, v28, *(int *)(v26 + 20));
          if (__dst >> 31)
          {
            unsigned int v43 = *re::foundationIntrospectionLogObjects(v29);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v46 = *(void *)(v25 + 8);
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v46;
              long long v45 = "Array too big for member '%s'.";
LABEL_59:
              _os_log_impl(&dword_233120000, v43, OS_LOG_TYPE_DEFAULT, v45, (uint8_t *)&buf, 0xCu);
            }
            return;
          }
          re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&buf, *(const re::IntrospectionBase **)(v27 + 48), __dst);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&v47, 0);
          v48[1] = 0x800000001;
          int v49 = 8;
          __int16 v50 = 0;
          uint64_t v51 = 0;
          uint64_t v52 = 0xFFFFFFFFLL;
          unsigned int v47 = &unk_26E6CDA08;
          v53[0] = &buf;
          v53[1] = 0;
          re::IntrospectionWalker::walk(&v47, (char *)v4 + *(int *)(v25 + 36), v3);
          unsigned int v47 = &unk_26E6CDA08;
          re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)v53);
          unsigned int v47 = &unk_26E6DECE0;
          objc_destructInstance(v48);
          *(void *)&long long buf = &unk_26E6C2018;
          re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)v58);
          *(void *)&long long buf = &unk_26E6DECE0;
          uint64_t v7 = (re *)objc_destructInstance((char *)&buf + 8);
LABEL_42:
          if (++v24 >= (unint64_t)*(unsigned int *)(a1 + 56)) {
            return;
          }
          continue;
        }
        unsigned int v43 = *re::foundationIntrospectionLogObjects(v7);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v44 = *(void *)(v25 + 8);
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v44;
          long long v45 = "Failed to get array length for member '%s'.";
          goto LABEL_59;
        }
        return;
      case 2:
        uint64_t v8 = *(uint64_t *)((char *)v4 + *(int *)(v25 + 36));
        if (v8)
        {
          uint64_t v30 = *(void *)(*(void *)(v25 + 16) + 48);
          unint64_t v31 = *(void **)(v30 + 64);
          uint64_t v32 = (_DWORD *)*v31;
          if (*(_DWORD *)*v31 != 2)
          {
            uint64_t v33 = (_DWORD **)(v31 + 1);
            uint64_t v34 = *(unsigned int *)(v30 + 56) - 1;
            do
            {
              unint64_t v35 = *v33++;
              uint64_t v32 = v35;
              --v34;
            }
            while (*v35 != 2);
          }
          uint64_t v36 = *(void *)(v25 + 48);
          *(void *)&long long buf = (char *)v4 + *(int *)(v25 + 64);
          *((void *)&buf + 1) = v36;
          uint64_t v56 = *((void *)v32 + 1);
          uint64_t v7 = (re *)re::IntrospectionWalker::walkPolymorphicPointer((uint64_t)&buf, v8, v3);
        }
        goto LABEL_42;
      default:
        re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "walkStructure", 63);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D945D8);
    }
  }
}

void std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::~__func()
{
}

__n128 std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26E715FF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E715FF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::operator()(uint64_t a1, const re::IntrospectionBase ***a2, const re::IntrospectionBase ***a3)
{
  uint64_t v4 = *a3;
  re::IntrospectionWalker::walk(*(void *)(*(void *)(a1 + 8) + 48), *a2, *(void *)(a1 + 16));
  re::IntrospectionWalker::walk(*(void *)(*(void *)(a1 + 8) + 64), v4, *(void *)(a1 + 16));
  return 1;
}

uint64_t std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::target_type()
{
}

uint64_t re::internal::readUnsigned(re::internal *this, void *a2, const re::TypeInfo *a3)
{
  switch(*(_DWORD *)(a2[2] + 8))
  {
    case 1:
      uint64_t result = *(unsigned __int8 *)this;
      break;
    case 2:
      uint64_t result = *(unsigned __int16 *)this;
      break;
    case 4:
      uint64_t result = *(unsigned int *)this;
      break;
    case 8:
      uint64_t result = *(void *)this;
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Unsupported integer type. Size of type in bytes: %zu", "!\"Unreachable code\"", "readUnsigned", 29, *(unsigned int *)(a2[2] + 8));
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D947ECLL);
  }
  return result;
}

unsigned char *re::internal::writeUnsigned(unsigned char *this, void *a2, const re::TypeInfo *a3)
{
  switch(*(_DWORD *)(a2[2] + 8))
  {
    case 1:
      *this = (_BYTE)a3;
      break;
    case 2:
      *(_WORD *)this = (_WORD)a3;
      break;
    case 4:
      *(_DWORD *)this = a3;
      break;
    case 8:
      *(void *)this = a3;
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Unsupported integer type. Size of type in bytes: %zu", "!\"Unreachable code\"", "writeUnsigned", 55, *(unsigned int *)(a2[2] + 8));
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D948B8);
  }
  return this;
}

uint64_t re::internal::checkedArraySize(unint64_t this, unint64_t a2)
{
  if (is_mul_ok(this, a2)) {
    return this * a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in array. Element size = %zu bytes, count = %zu", "!overflow", "checkedArraySize", 65, this, a2, v2, v3);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::UnionAccessor::memberType@<X0>(re::UnionAccessor *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  if (*(unsigned int *)(v4 + 88) <= a2)
  {
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v8 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v8 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v5 = *(void **)this;
  unint64_t v6 = *(unsigned int *)(v4 + 84) + a2;
  if (v5[73] <= v6) {
    goto LABEL_5;
  }
  re::TypeRegistry::typeInfo(v5, *(void *)(v5[75] + 8 * v6), &v8);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)&v8 + 8);
}

unint64_t re::UnionAccessor::activeMemberType@<X0>(re::UnionAccessor *this@<X0>, char *a2@<X1>, unsigned char *a3@<X8>)
{
  unint64_t result = re::UnionAccessor::readTag(this, a2);
  if (result >= *(unsigned int *)(*((void *)this + 2) + 88))
  {
    *a3 = 0;
  }
  else
  {
    re::UnionAccessor::memberType(this, result, (uint64_t)v6);
    *a3 = 1;
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v6);
  }
  return result;
}

uint64_t re::UnionAccessor::readTag(re::UnionAccessor *this, char *a2)
{
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v7);
  re::TypeInfo::TypeInfo((uint64_t)v6, (uint64_t)&v8);
  return re::internal::readUnsigned((re::internal *)&a2[*(int *)(*((void *)this + 2) + 80)], v6, v4);
}

unsigned char *re::UnionAccessor::reset(re::UnionAccessor *this, char *a2, const re::TypeInfo *a3, re::Allocator *a4)
{
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), v14);
  re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
  uint64_t v8 = (re::internal *)&a2[*(int *)(*((void *)this + 2) + 80)];
  unint64_t Unsigned = re::internal::readUnsigned(v8, v13, v9);
  unint64_t v11 = *(unsigned int *)(*((void *)this + 2) + 88);
  if (Unsigned < v11)
  {
    re::UnionAccessor::memberType(this, Unsigned, (uint64_t)v14);
    re::TypeInfo::destruct((re::TypeInfo *)v14, a2, a4, 0);
    unint64_t v11 = *(unsigned int *)(*((void *)this + 2) + 88);
  }
  if (v11 > (unint64_t)a3)
  {
    re::UnionAccessor::memberType(this, (unint64_t)a3, (uint64_t)v14);
    re::TypeInfo::construct((re::TypeInfo *)v14, (void **)a2, a4, 0);
  }
  return re::internal::writeUnsigned(v8, v13, a3);
}

void re::TypeBuilderHelper::registerArray(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, unint64_t a4@<X3>, re::TypeRegistry **a5@<X8>)
{
  long long v10 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v10)
  {
    unint64_t v11 = *(re::TypeRegistry **)v10;
    *a5 = a1;
    a5[1] = v11;
  }
  else
  {
    long long v13 = *a3;
    re::TypeBuilder::beginArrayType((uint64_t)v14, a2, (re **)&v13, a4);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v14, a1, a5);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v14, v12);
  }
}

void re::TypeBuilderHelper::registerPointer(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, re::TypeRegistry **a5@<X8>)
{
  long long v10 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v10)
  {
    unint64_t v11 = *(re::TypeRegistry **)v10;
    *a5 = a1;
    a5[1] = v11;
  }
  else
  {
    uint64_t v12 = *(void *)(a3 + 8);
    int v17 = -1;
    memset(v18, 0, sizeof(v18));
    long long v19 = 0u;
    uint64_t v20 = 0xFFFFFFFFLL;
    int v21 = 1;
    uint64_t v22 = 0xFFFFFFFFLL;
    char v23 = 1;
    uint64_t v24 = 0xFFFFFFFFLL;
    int v25 = 0;
    v14[0] = 9;
    re::StringID::operator=(&v15, a2);
    int v16 = 1;
    *(_OWORD *)((char *)v18 + 4) = 0x800000008uLL;
    *(void *)((char *)&v19 + 4) = 0;
    *(void *)((char *)&v18[1] + 4) = 0;
    int v21 = -1;
    uint64_t v22 = v12;
    char v23 = a4;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v14, a1, a5);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v14, v13);
  }
}

void re::TypeBuilderHelper::registerCString(re::TypeBuilderHelper *this@<X0>, void *a2@<X8>)
{
  v10[0] = 189247272;
  v10[1] = (uint64_t)"char*";
  uint64_t v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    uint64_t v6 = *(void *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 8uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

void re::TypeBuilderHelper::registerDynamicString(re::TypeBuilderHelper *this@<X0>, void *a2@<X8>)
{
  v10[0] = 0x2686EB529B3EE220;
  v10[1] = (uint64_t)"DynamicString";
  uint64_t v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    uint64_t v6 = *(void *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 0x20uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setConstructor((uint64_t)v9, (uint64_t)re::TypeBuilderHelper::registerDynamicString(re::TypeRegistry *)::$_0::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultDestructor<re::DynamicString>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

void re::TypeBuilderHelper::registerStringID(re::TypeBuilderHelper *this@<X0>, void *a2@<X8>)
{
  v10[0] = 0x458DDB01A18;
  v10[1] = (uint64_t)"StringID";
  uint64_t v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    uint64_t v6 = *(void *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 0x10uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setConstructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultConstructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultDestructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

void *re::TypeBuilderHelper::registerDynamicString(re::TypeRegistry *)::$_0::__invoke(void *a1, uint64_t a2, uint64_t a3)
{
  a1[2] = 0;
  a1[3] = 0;
  *a1 = a3;
  a1[1] = 0;
  return re::DynamicString::setCapacity(a1, 0);
}

void *re::TypeBuilder::setDefaultConstructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(void *result)
{
  *unint64_t result = 0;
  result[1] = "";
  return result;
}

float32x4_t re::lerp<float>@<Q0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>, float a4@<S0>)
{
  float v7 = 1.0;
  float v50 = 1.0 - a4;
  float32x4_t v8 = a1[1];
  float32x4_t v47 = *a2;
  float32x4_t v48 = *a1;
  float32x4_t v9 = a2[1];
  float32x4_t v10 = vmulq_f32(v8, v9);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL);
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)v10.f32, *(float32x2_t *)v11.f32);
  v10.f32[0] = vaddv_f32(*(float32x2_t *)v10.f32);
  v11.i64[0] = 0;
  float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v10, v11)), 0), (int8x16_t)vnegq_f32(v9), (int8x16_t)v9);
  float32x4_t v13 = vsubq_f32(v8, v12);
  int8x16_t v14 = (int8x16_t)vmulq_f32(v13, v13);
  float32x4_t v45 = v12;
  float32x4_t v46 = v8;
  float32x4_t v15 = vaddq_f32(v8, v12);
  int8x16_t v16 = (int8x16_t)vmulq_f32(v15, v15);
  float v17 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)))));
  float v18 = v17 + v17;
  BOOL v19 = (float)(v17 + v17) == 0.0;
  float v20 = 1.0;
  if (!v19) {
    float v20 = sinf(v18) / v18;
  }
  float v21 = v20;
  float32x2_t v22 = vrecpe_f32((float32x2_t)LODWORD(v20));
  float32x2_t v23 = vmul_f32(v22, vrecps_f32((float32x2_t)LODWORD(v21), v22));
  LODWORD(v24) = vmul_f32(v23, vrecps_f32((float32x2_t)LODWORD(v21), v23)).u32[0];
  float v25 = v50;
  if ((float)(v50 * v18) != 0.0)
  {
    float v43 = v24;
    v23.f32[0] = sinf(v50 * v18);
    float v24 = v43;
    float v25 = v50;
    float v7 = v23.f32[0] / (float)(v50 * v18);
  }
  v23.f32[0] = v25 * (float)(v24 * v7);
  float32x4_t v26 = (float32x4_t)vdupq_lane_s32((int32x2_t)v23, 0);
  float v27 = a4;
  float v28 = v18 * a4;
  float v29 = 1.0;
  if (v28 != 0.0)
  {
    float32x4_t v42 = v26;
    float v44 = v24;
    float v30 = sinf(v28);
    float32x4_t v26 = v42;
    float v24 = v44;
    float v25 = v50;
    float v27 = a4;
    float v29 = v30 / v28;
  }
  float32x4_t v31 = vmlaq_f32(vmulq_n_f32(v45, (float)(v24 * v29) * v27), v46, v26);
  int8x16_t v32 = (int8x16_t)vmulq_f32(v31, v31);
  float32x2_t v33 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  if (vaddv_f32(v33) == 0.0)
  {
    uint64_t v34 = 0;
    uint64_t v35 = 0x3F80000000000000;
  }
  else
  {
    unsigned __int32 v36 = vadd_f32(v33, (float32x2_t)vdup_lane_s32((int32x2_t)v33, 1)).u32[0];
    float32x2_t v37 = vrsqrte_f32((float32x2_t)v36);
    float32x2_t v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36, vmul_f32(v37, v37)));
    float32x4_t v39 = vmulq_n_f32(v31, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36, vmul_f32(v38, v38))).f32[0]);
    uint64_t v35 = v39.i64[1];
    uint64_t v34 = v39.i64[0];
  }
  float32x4_t result = vmlaq_n_f32(vmulq_n_f32(v47, v27), v48, v25);
  float32x4_t v41 = vmlaq_n_f32(vmulq_n_f32(a2[2], v27), a1[2], v25);
  *a3 = result;
  a3[1].i64[0] = v34;
  a3[1].i64[1] = v35;
  a3[2] = v41;
  return result;
}

double re::Projection::makeReverseDepth@<D0>(_OWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2 = &dword_2687A1000;
  uint64_t v3 = &dword_2687A1000;
  uint64_t v4 = &dword_2687A1000;
  uint64_t v5 = &dword_2687A1000;
  {
    float v20 = a2;
    float v21 = a1;
    uint64_t v5 = &dword_2687A1000;
    uint64_t v4 = &dword_2687A1000;
    uint64_t v3 = &dword_2687A1000;
    uint64_t v2 = &dword_2687A1000;
    int v19 = v18;
    a2 = v20;
    a1 = v21;
    if (v19)
    {
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_23435FD50;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_23435FD60;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_234382760;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_2343854A0;
      uint64_t v5 = &dword_2687A1000;
      uint64_t v4 = &dword_2687A1000;
      uint64_t v3 = &dword_2687A1000;
      uint64_t v2 = &dword_2687A1000;
      a2 = v20;
      a1 = v21;
    }
  }
  uint64_t v6 = 0;
  float32x4_t v7 = *((float32x4_t *)v2 + 90);
  float32x4_t v8 = *((float32x4_t *)v3 + 91);
  float32x4_t v9 = *((float32x4_t *)v4 + 92);
  float32x4_t v10 = *((float32x4_t *)v5 + 93);
  long long v11 = a1[1];
  long long v12 = a1[2];
  long long v13 = a1[3];
  v22[0] = *a1;
  v22[1] = v11;
  void v22[2] = v12;
  v22[3] = v13;
  do
  {
    v23[v6] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v7, COERCE_FLOAT(v22[v6])), v8, *(float32x2_t *)&v22[v6], 1), v9, (float32x4_t)v22[v6], 2), v10, (float32x4_t)v22[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  double result = *(double *)v23;
  long long v15 = v23[1];
  long long v16 = v23[2];
  long long v17 = v23[3];
  *a2 = v23[0];
  a2[1] = v15;
  a2[2] = v16;
  a2[3] = v17;
  return result;
}

void re::Projection::makePerspectiveFieldOfViewReverseDepth(float a1@<S0>, float a2@<S1>, float a3@<S2>, float a4@<S3>, _OWORD *a5@<X8>)
{
  float v10 = 1.0 / tanf(a1 * 0.5);
  if (a4 == INFINITY)
  {
    float v11 = -a3;
    LODWORD(v13) = 0;
    *((void *)&v13 + 1) = 0;
    DWORD1(v12) = 0;
    *((void *)&v12 + 1) = 0;
    *(float *)&long long v12 = v10 / a2;
    *((float *)&v13 + 1) = v10;
    long long v14 = xmmword_234394FA0;
  }
  else
  {
    DWORD1(v12) = 0;
    *((void *)&v12 + 1) = 0;
    *(float *)&long long v12 = v10 / a2;
    LODWORD(v13) = 0;
    *((void *)&v13 + 1) = 0;
    *((float *)&v13 + 1) = v10;
    *(void *)&long long v14 = 0;
    float v11 = (float)(a3 * a4) / (float)(a3 - a4);
    *((float *)&v14 + 2) = a4 / (float)(a3 - a4);
    HIDWORD(v14) = -1.0;
  }
  *(void *)&long long v15 = 0;
  *((void *)&v15 + 1) = LODWORD(v11);
  v16[0] = v12;
  v16[1] = v13;
  v16[2] = v14;
  void v16[3] = v15;
  re::Projection::makeReverseDepth(v16, a5);
}

float32x2_t re::Projection::computeMatrix4x4F@<D0>(re::Projection *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = *(_DWORD *)this;
  int v5 = *((_DWORD *)this + 12);
  LODWORD(v6) = 0;
  *((void *)&v6 + 1) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  float v7 = *((float *)this + 2);
  v8.i32[0] = *((_DWORD *)this + 3);
  float v9 = *((float *)this + 6);
  float32x2_t v10 = *(float32x2_t *)((char *)this + 16);
  float v11 = *((float *)this + 1);
  float v12 = v10.f32[1] - v9;
  if (v4)
  {
    float v13 = 2.0 / (float)(v10.f32[0] - v8.f32[0]);
    v8.i32[1] = *((_DWORD *)this + 6);
    float32x2_t v14 = vdiv_f32(vadd_f32(v8, v10), vsub_f32(v8, v10));
    *(float32x2_t *)&long long v15 = v14;
    HIDWORD(v15) = 1.0;
    if (v5 == 1)
    {
      float v16 = v7 - v11;
      float v17 = v7 / (float)(v7 - v11);
    }
    else
    {
      float v16 = v11 - v7;
      float v17 = v11 / (float)(v11 - v7);
    }
    *(float *)&unsigned int v29 = 1.0 / v16;
    *(void *)&long long v30 = 0;
    *((void *)&v30 + 1) = v29;
    *((float *)&v15 + 2) = v17;
    *(_OWORD *)a2 = LODWORD(v13);
    *((float *)&v6 + 1) = 2.0 / v12;
    *(_OWORD *)(a2 + 16) = v6;
    *(_OWORD *)(a2 + 32) = v30;
    *(_OWORD *)(a2 + 48) = v15;
    if (*((unsigned char *)this + 28))
    {
      float32x2_t v14 = *(float32x2_t *)(a2 + 48);
    }
    float32x2_t result = vadd_f32(v14, *(float32x2_t *)((char *)this + 56));
    *(float32x2_t *)(a2 + 48) = result;
  }
  else
  {
    float v18 = (float)(v11 + v11) / (float)(v10.f32[0] - v8.f32[0]);
    float v19 = (float)(v8.f32[0] + v10.f32[0]) / (float)(v10.f32[0] - v8.f32[0]);
    v10.f32[0] = (float)(v11 + v11) / v12;
    float v20 = (float)(v9 + v10.f32[1]) / v12;
    if (v7 == INFINITY)
    {
      LODWORD(v22) = 0;
      *((void *)&v22 + 1) = 0;
      long long v21 = LODWORD(v18);
      DWORD1(v22) = v10.i32[0];
      float v23 = -v11;
      __asm { FMOV            V5.4S, #-1.0 }
      *(void *)&_Q5 = __PAIR64__(LODWORD(v20), LODWORD(v19));
    }
    else
    {
      float v32 = v7 / (float)(v11 - v7);
      float v23 = (float)(v7 * v11) / (float)(v11 - v7);
      LODWORD(v22) = 0;
      *((void *)&v22 + 1) = 0;
      long long v21 = LODWORD(v18);
      DWORD1(v22) = v10.i32[0];
      __asm { FMOV            V5.4S, #-1.0 }
      *(void *)&_Q5 = __PAIR64__(LODWORD(v20), LODWORD(v19));
      *((float *)&_Q5 + 2) = v32;
    }
    *(void *)&long long v33 = 0;
    *((void *)&v33 + 1) = LODWORD(v23);
    *(_OWORD *)a2 = v21;
    *(_OWORD *)(a2 + 16) = v22;
    *(_OWORD *)(a2 + 32) = _Q5;
    *(_OWORD *)(a2 + 48) = v33;
    if (*((unsigned char *)this + 28)) {
    if (v5 == 1)
    }
    {
      re::Projection::makeReverseDepth((_OWORD *)a2, v36);
      long long v34 = v36[1];
      *(_OWORD *)a2 = v36[0];
      *(_OWORD *)(a2 + 16) = v34;
      long long v35 = v36[3];
      *(_OWORD *)(a2 + 32) = v36[2];
      *(_OWORD *)(a2 + 48) = v35;
    }
    float32x2_t result = vadd_f32(*(float32x2_t *)((char *)this + 56), *(float32x2_t *)(a2 + 32));
    *(float32x2_t *)(a2 + 32) = result;
  }
  return result;
}

float re::anonymous namespace'::applyObliqueClipPlane(uint64_t a1, float32x4_t a2)
{
  if (a2.f32[0] >= 0.0) {
    float v3 = 1.0;
  }
  else {
    float v3 = -1.0;
  }
  float v7 = v3;
  if (a2.f32[1] >= 0.0) {
    float v4 = 1.0;
  }
  else {
    float v4 = -1.0;
  }
  float v6 = v4;
  simd_float4x4 v9 = __invert_f4(*(simd_float4x4 *)a1);
  v9.columns[0] = (simd_float4)vmulq_f32(vaddq_f32((float32x4_t)v9.columns[3], vaddq_f32((float32x4_t)v9.columns[2], vmlaq_n_f32(vmulq_n_f32((float32x4_t)v9.columns[0], v7), (float32x4_t)v9.columns[1], v6))), a2);
  v9.columns[0] = (simd_float4)vmulq_n_f32(a2, 1.0/ vaddv_f32(vadd_f32(*(float32x2_t *)v9.columns[0].f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9.columns[0], (int8x16_t)v9.columns[0], 8uLL))));
  *(float *)(a1 + 8) = v9.columns[0].f32[0] - *(float *)(a1 + 12);
  *(float *)(a1 + 24) = v9.columns[0].f32[1] - *(float *)(a1 + 28);
  *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v9.columns[0].i32[2];
  float result = v9.columns[0].f32[3] - *(float *)(a1 + 60);
  *(float *)(a1 + 56) = result;
  return result;
}

float re::Projection::setFromMatrix4x4F(uint64_t a1, uint64_t a2)
{
  float v4 = *(float *)(a2 + 44);
  *(_DWORD *)a1 = v4 == 0.0;
  float v5 = *(float *)(a2 + 40);
  if (v4 != 0.0)
  {
    v15.i32[0] = *(_DWORD *)(a2 + 56);
    if (v5 == -1.0)
    {
      *(_DWORD *)(a1 + 8) = 2139095040;
      *(_DWORD *)(a1 + 48) = 0;
      *(float *)v15.i32 = -*(float *)v15.i32;
    }
    else
    {
      if (v5 != 0.0)
      {
        simd_float4x4 v18 = __invert_f4(*(simd_float4x4 *)a2);
        v18.columns[0] = (simd_float4)vaddq_f32((float32x4_t)v18.columns[2], vmlaq_f32(vmulq_f32((float32x4_t)v18.columns[0], (float32x4_t)0), (float32x4_t)0, (float32x4_t)v18.columns[1]));
        v18.columns[2].i64[0] = vextq_s8((int8x16_t)v18.columns[0], (int8x16_t)v18.columns[0], 8uLL).u64[0];
        v18.columns[0] = (simd_float4)vmlaq_f32((float32x4_t)v18.columns[0], (float32x4_t)vdupq_n_s32(0x799A130Cu), (float32x4_t)v18.columns[3]);
        *(float32x2_t *)v18.columns[1].f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v18.columns[3], (int8x16_t)v18.columns[3], 8uLL), *(float32x2_t *)v18.columns[2].f32);
        v18.columns[0].i64[0] = vextq_s8((int8x16_t)v18.columns[0], (int8x16_t)v18.columns[0], 8uLL).u64[0];
        int32x2_t v15 = (int32x2_t)vdiv_f32(vneg_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v18.columns[1].f32, *(int32x2_t *)v18.columns[0].f32)), (float32x2_t)vzip2_s32(*(int32x2_t *)v18.columns[1].f32, *(int32x2_t *)v18.columns[0].f32));
        *(int32x2_t *)(a1 + 4) = vrev64_s32(v15);
        if (*(float *)&v15.i32[1] <= *(float *)v15.i32)
        {
          *(_DWORD *)(a1 + 48) = 0;
          v15.i32[0] = v15.i32[1];
        }
        else
        {
          *(int32x2_t *)(a1 + 4) = v15;
          *(_DWORD *)(a1 + 48) = 1;
        }
        goto LABEL_13;
      }
      *(_DWORD *)(a1 + 8) = 2139095040;
      *(_DWORD *)(a1 + 48) = 1;
    }
    *(_DWORD *)(a1 + 4) = v15.i32[0];
LABEL_13:
    float v16 = 1.0 / *(float *)a2;
    *(float *)(a1 + 12) = v16 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 32) + -1.0));
    *(float *)(a1 + 16) = v16 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 32) + 1.0));
    float v17 = 1.0 / *(float *)(a2 + 20);
    *(float *)(a1 + 24) = v17 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 36) + -1.0));
    float result = v17 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 36) + 1.0));
    *(float *)(a1 + 2re::InputManager::notify(8, 0, 0, 0) = result;
    return result;
  }
  BOOL v6 = v5 < 0.0;
  BOOL v7 = v5 >= 0.0;
  float v8 = 1.0 / v5;
  float v9 = v8 * *(float *)(a2 + 56);
  float v10 = v9 - v8;
  if (v6) {
    float v11 = v9;
  }
  else {
    float v11 = v10;
  }
  if (!v6) {
    float v10 = v9;
  }
  *(_DWORD *)(a1 + 48) = v7;
  *(float *)(a1 + 4) = v11;
  *(float *)(a1 + 8) = v10;
  float v12 = 1.0 / *(float *)a2;
  *(float *)(a1 + 16) = v12 * (float)(1.0 - *(float *)(a2 + 48));
  *(float *)(a1 + 12) = -(float)((float)(*(float *)(a2 + 48) + 1.0) * v12);
  float v13 = 1.0 / *(float *)(a2 + 20);
  *(float *)(a1 + 2re::InputManager::notify(8, 0, 0, 0) = v13 * (float)(1.0 - *(float *)(a2 + 52));
  float result = -(float)((float)(*(float *)(a2 + 52) + 1.0) * v13);
  *(float *)(a1 + 24) = result;
  return result;
}

uint64_t re::Projection::unprojectPoint(float32x2_t *a1, uint64_t a2, int a3)
{
  float v3 = a1[5].f32[1];
  if (v3 == 0.0)
  {
    float32x2_t v6 = *a1;
    v6.i32[1] = a1[2].i32[1];
    return (uint64_t)vdiv_f32(vsub_f32((float32x2_t)a2, a1[6]), v6);
  }
  else
  {
    float32x2_t v4 = *a1;
    v4.i32[1] = a1[2].i32[1];
    return (uint64_t)vdiv_f32(vmul_n_f32(vmla_n_f32(vneg_f32(a1[4]), (float32x2_t)a2, v3), a1[7].f32[0] / (float)-(float)(a1[5].f32[0] - (float)(v3 * *(float *)&a3))), v4);
  }
}

uint64_t re::solveQuadraticRootsD(re *this, double *a2, double *a3)
{
  double v3 = *((double *)this + 1);
  double v4 = *((double *)this + 2);
  double v5 = *(double *)this;
  float v6 = v4;
  if (fabsf(v6) < 0.00001)
  {
    float v7 = v3;
    if (fabsf(v7) >= 0.00001)
    {
      *a2 = -v5 / v3;
      return 1;
    }
    return 0;
  }
  double v9 = v4 * -4.0 * v5 + v3 * v3;
  if (v9 < 0.0) {
    return 0;
  }
  double v10 = 1.0;
  if (v3 < 0.0) {
    double v10 = -1.0;
  }
  double v11 = (v3 + v10 * sqrt(v9)) * -0.5;
  double v12 = v5 / v11;
  *a2 = v11 / v4;
  a2[1] = v12;
  if (v12 < v11 / v4)
  {
    *a2 = v12;
    a2[1] = v11 / v4;
  }
  if (v9 <= 0.0) {
    return 1;
  }
  else {
    return 2;
  }
}

double re::Matrix4x4<float>::extractScale(uint64_t a1, float32x4_t a2, int32x4_t a3, int8x16_t a4)
{
  a2.i64[0] = *(void *)a1;
  a3.i64[0] = *(void *)(a1 + 16);
  a4.i64[0] = *(void *)(a1 + 32);
  a2.i32[2] = *(_DWORD *)(a1 + 8);
  a3.i32[2] = *(_DWORD *)(a1 + 24);
  a4.i32[2] = *(_DWORD *)(a1 + 40);
  float32x4_t v4 = vmulq_f32(a2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(a4, a4, 0xCuLL), a4, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a3, a3), (int8x16_t)a3, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a4, (int32x4_t)a4), a4, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a3, (int8x16_t)a3, 0xCuLL), (int8x16_t)a3, 8uLL)));
  BOOL v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] <= 0.0;
  float v6 = -1.0;
  if (!v5) {
    float v6 = 1.0;
  }
  float32x4_t v7 = vmulq_f32(a2, a2);
  float32x4_t v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
  float32x4_t v9 = vmulq_f32((float32x4_t)a3, (float32x4_t)a3);
  v8.f32[0] = sqrtf(v8.f32[0]);
  float32x4_t v10 = vmulq_f32((float32x4_t)a4, (float32x4_t)a4);
  v8.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  v8.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  *(void *)&double result = vmulq_n_f32(v8, v6).u64[0];
  return result;
}

double re::Matrix4x4<float>::makeRotation@<D0>(float32x4_t *a1@<X0>, _OWORD *a2@<X8>, float a3@<S0>)
{
  float32x4_t v4 = *a1;
  float32x4_t v5 = vmulq_f32(v4, v4);
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  if (fabsf(v6) >= 1.0e-10)
  {
    float v7 = v6;
    float32x2_t v8 = vrsqrte_f32((float32x2_t)LODWORD(v6));
    float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v8, v8)));
    float32x4_t v4 = vmulq_n_f32(v4, vmul_f32(v9, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v9, v9))).f32[0]);
  }
  float32x4_t v22 = v4;
  float v23 = vmulq_f32(v4, v4).f32[0];
  float v10 = vmuls_lane_f32(v4.f32[1], *(float32x2_t *)v4.f32, 1);
  float v11 = vmuls_lane_f32(v4.f32[2], v4, 2);
  float v12 = vmuls_lane_f32(v4.f32[0], *(float32x2_t *)v4.f32, 1);
  float v13 = vmuls_lane_f32(v4.f32[0], v4, 2);
  float v14 = vmuls_lane_f32(v4.f32[1], v4, 2);
  __float2 v15 = __sincosf_stret(a3);
  float v16 = vmuls_lane_f32(v15.__sinval, *(float32x2_t *)v22.f32, 1);
  float v17 = vmuls_lane_f32(v15.__sinval, v22, 2);
  *(float *)&long long v18 = v23 + (float)(v15.__cosval * (float)(1.0 - v23));
  *((float *)&v18 + 1) = v17 + (float)(v12 * (float)(1.0 - v15.__cosval));
  *((void *)&v18 + 1) = COERCE_UNSIGNED_INT(-(float)(v16 - (float)(v13 * (float)(1.0 - v15.__cosval))));
  *(float *)&long long v19 = -(float)(v17 - (float)(v12 * (float)(1.0 - v15.__cosval)));
  *((float *)&v19 + 1) = v10 + (float)(v15.__cosval * (float)(1.0 - v10));
  *((void *)&v19 + 1) = COERCE_UNSIGNED_INT((float)(v15.__sinval * v22.f32[0]) + (float)(v14
                                                                                         * (float)(1.0 - v15.__cosval)));
  *(float *)&long long v20 = v16 + (float)(v13 * (float)(1.0 - v15.__cosval));
  *((float *)&v20 + 1) = -(float)((float)(v15.__sinval * v22.f32[0]) - (float)(v14 * (float)(1.0 - v15.__cosval)));
  *((void *)&v20 + 1) = COERCE_UNSIGNED_INT(v11 + (float)(v15.__cosval * (float)(1.0 - v11)));
  *a2 = v18;
  a2[1] = v19;
  double result = 0.0;
  a2[2] = v20;
  a2[3] = xmmword_23435FBB0;
  return result;
}

uint64_t re::Quaternion<float>::makeRotation(float32x4_t *a1, float a2)
{
  float32x4_t v2 = *a1;
  float32x4_t v3 = vmulq_f32(v2, v2);
  LODWORD(v4) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u32[0];
  if (fabsf(v4) >= 1.0e-10)
  {
    float v5 = v4;
    float32x2_t v6 = vrsqrte_f32((float32x2_t)LODWORD(v4));
    float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)LODWORD(v5), vmul_f32(v6, v6)));
    v2.i64[0] = vmulq_n_f32(v2, vmul_f32(v7, vrsqrts_f32((float32x2_t)LODWORD(v5), vmul_f32(v7, v7))).f32[0]).u64[0];
  }
  return (uint64_t)vmul_n_f32(*(float32x2_t *)v2.f32, __sincosf_stret(a2 * 0.5).__sinval);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,float [4]>(re::snapshot::EncoderOPACK *this, void *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 9;
  }
  re::snapshot::EncoderOPACK::beginData((unsigned int *)this, 0x10uLL, 0x10uLL);
  return re::snapshot::Encoder::writeRaw<true>((unsigned int *)this, a2, 0x10uLL);
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,re::Vector4<float> [4]>(uint64_t a1, _OWORD *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if (result)
  {
    re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderOPACK>,re::Vector4<float>,4ul>(a1, a2);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,re::Vector4<float> [4]>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 9;
  }
  re::snapshot::EncoderOPACK::beginArray((unsigned int *)this, 4uLL);
  for (uint64_t i = 0; i != 64; i += 16)
  {
    re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,float [4]>(this, (void *)(a2 + i));
    uint64_t result = re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
  }
  return result;
}

void *re::allocInfo_Vector2F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF985B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF989E0, "Vector2F");
    __cxa_guard_release(&qword_26AF985B0);
  }
  return &unk_26AF989E0;
}

void re::initInfo_Vector2F(re *this, re::IntrospectionBase *a2)
{
  v12[0] = 0x478E8020DEELL;
  v12[1] = "Vector2F";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985B8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF985B8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      float32x2_t v7 = re::IntrospectionInfo<float [2]>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "array";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF986D8 = v8;
      float32x2_t v9 = re::introspectionAllocator((re *)v8);
      float v10 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 8, 4);
      void *v10 = 0x100000004;
      qword_26AF986E0 = (uint64_t)v10;
      __cxa_guard_release(&qword_26AF985B8);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF986D8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector2<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector2<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector2<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector2<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v11 = v13;
}

void re::internal::defaultConstruct<re::Vector2<float>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
}

void *re::internal::defaultConstructV2<re::Vector2<float>>(void *result)
{
  *uint64_t result = 0;
  return result;
}

uint64_t re::introspect_Vector2F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector2F", (uint64_t (*)(re::internal *))re::allocInfo_Vector2F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector2F, (void (*)(re::IntrospectionBase *))&qword_26AF985C0, this);
}

void *re::allocInfo_Vector3F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF985C8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98A58, "Vector3F");
    __cxa_guard_release(&qword_26AF985C8);
  }
  return &unk_26AF98A58;
}

void re::initInfo_Vector3F(re *this, re::IntrospectionBase *a2)
{
  v12[0] = 0x478E8020E2CLL;
  v12[1] = "Vector3F";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985D0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF985D0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      float32x2_t v7 = re::IntrospectionInfo<float [3]>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "array";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF986E8 = v8;
      float32x2_t v9 = re::introspectionAllocator((re *)v8);
      float v10 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 8, 4);
      void *v10 = 0x100000004;
      qword_26AF986F0 = (uint64_t)v10;
      __cxa_guard_release(&qword_26AF985D0);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF986E8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector3<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector3<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector3<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector3<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v11 = v13;
}

double re::internal::defaultConstruct<re::Vector3<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  *a3 = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector3<float>>(_OWORD *a1)
{
  double result = 0.0;
  *a1 = 0u;
  return result;
}

uint64_t re::introspect_Vector3F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector3F", (uint64_t (*)(re::internal *))re::allocInfo_Vector3F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector3F, (void (*)(re::IntrospectionBase *))&qword_26AF985D8, this);
}

void *re::allocInfo_Vector4F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF985E0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98AD0, "Vector4F");
    __cxa_guard_release(&qword_26AF985E0);
  }
  return &unk_26AF98AD0;
}

void re::initInfo_Vector4F(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x478E8020E6ALL;
  v11[1] = "Vector4F";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985E8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF985E8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<float [4]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "array";
      *(void *)(v7 + 16) = &unk_26AF987E8;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF986F8 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      float32x2_t v9 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 8, 4);
      *float32x2_t v9 = 0x100000004;
      qword_26AF98700 = (uint64_t)v9;
      __cxa_guard_release(&qword_26AF985E8);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF986F8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector4<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector4<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector4<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector4<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void re::IntrospectionInfo<float [4]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF986A0))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF987E8);
    __cxa_guard_release(&qword_26AF986A0);
  }
  if ((byte_26AF985A9 & 1) == 0)
  {
    byte_26AF985A9 = 1;
    float32x4_t v2 = (const re::IntrospectionBase *)re::introspect_float((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF987E8, v2, 4);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF987E8, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF98808 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

void re::internal::defaultConstruct<re::Vector4<float>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

void *re::internal::defaultConstructV2<re::Vector4<float>>(void *result)
{
  *double result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Vector4F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector4F", (uint64_t (*)(re::internal *))re::allocInfo_Vector4F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector4F, (void (*)(re::IntrospectionBase *))&qword_26AF985F0, this);
}

void *re::allocInfo_Vector2D(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF985F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF985F8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98B48, "Vector2D");
    __cxa_guard_release(&qword_26AF985F8);
  }
  return &unk_26AF98B48;
}

void re::initInfo_Vector2D(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x478E8020DEALL;
  v11[1] = "Vector2D";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98600, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98600);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<double [2]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "array";
      *(void *)(v7 + 16) = &unk_26AF98830;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF98708 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      float32x2_t v9 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 8, 4);
      *float32x2_t v9 = 0x100000004;
      qword_26AF98710 = (uint64_t)v9;
      __cxa_guard_release(&qword_26AF98600);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98708;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector2<double>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector2<double>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector2<double>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector2<double>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void re::IntrospectionInfo<double [2]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF986A8))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98830);
    __cxa_guard_release(&qword_26AF986A8);
  }
  if ((byte_26AF985AA & 1) == 0)
  {
    byte_26AF985AA = 1;
    float32x4_t v2 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98830, v2, 2);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF98830, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF98850 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

void re::internal::defaultConstruct<re::Vector2<double>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

void *re::internal::defaultConstructV2<re::Vector2<double>>(void *result)
{
  *double result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Vector2D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector2D", (uint64_t (*)(re::internal *))re::allocInfo_Vector2D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector2D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector2<double>>, this);
}

void *re::allocInfo_Vector3D(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98608, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98608))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98BC0, "Vector3D");
    __cxa_guard_release(&qword_26AF98608);
  }
  return &unk_26AF98BC0;
}

void re::initInfo_Vector3D(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x478E8020E28;
  v11[1] = "Vector3D";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98610, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98610);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<double [3]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "array";
      *(void *)(v7 + 16) = &unk_26AF98878;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF98718 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      float32x2_t v9 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 8, 4);
      *float32x2_t v9 = 0x100000004;
      qword_26AF98720 = (uint64_t)v9;
      __cxa_guard_release(&qword_26AF98610);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98718;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector3<double>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector3<double>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector3<double>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector3<double>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void re::IntrospectionInfo<double [3]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF986B0))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98878);
    __cxa_guard_release(&qword_26AF986B0);
  }
  if ((byte_26AF985AB & 1) == 0)
  {
    byte_26AF985AB = 1;
    float32x4_t v2 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98878, v2, 3);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF98878, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF98898 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

double re::internal::defaultConstruct<re::Vector3<double>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector3<double>>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t re::introspect_Vector3D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector3D", (uint64_t (*)(re::internal *))re::allocInfo_Vector3D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector3D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector3<double>>, this);
}

void *re::allocInfo_Vector4D(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98618, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98618))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98C38, "Vector4D");
    __cxa_guard_release(&qword_26AF98618);
  }
  return &unk_26AF98C38;
}

void re::initInfo_Vector4D(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x478E8020E66;
  v11[1] = "Vector4D";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98620, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98620);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<double [4]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "array";
      *(void *)(v7 + 16) = &unk_26AF988C0;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF98728 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      float32x2_t v9 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 8, 4);
      *float32x2_t v9 = 0x100000004;
      qword_26AF98730 = (uint64_t)v9;
      __cxa_guard_release(&qword_26AF98620);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98728;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Vector4<double>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Vector4<double>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Vector4<double>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Vector4<double>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void re::IntrospectionInfo<double [4]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF986B8))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF988C0);
    __cxa_guard_release(&qword_26AF986B8);
  }
  if ((byte_26AF985AC & 1) == 0)
  {
    byte_26AF985AC = 1;
    float32x4_t v2 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF988C0, v2, 4);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF988C0, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v2 + 2);
    xmmword_26AF988E0 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

double re::internal::defaultConstruct<re::Vector4<double>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector4<double>>(_OWORD *a1)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_Vector4D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector4D", (uint64_t (*)(re::internal *))re::allocInfo_Vector4D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector4D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector4<double>>, this);
}

void *re::allocInfo_QuaternionF(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98628, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98628))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98CB0, "QuaternionF");
    __cxa_guard_release(&qword_26AF98628);
  }
  return &unk_26AF98CB0;
}

void re::initInfo_QuaternionF(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x1EE51E553020190;
  v11[1] = "QuaternionF";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98630, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98630);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<float [4]>::get((uint64_t)v5, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "array";
      *(void *)(v7 + 16) = &unk_26AF987E8;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF98738 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      float32x2_t v9 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 8, 4);
      *float32x2_t v9 = 0x100000004;
      qword_26AF98740 = (uint64_t)v9;
      __cxa_guard_release(&qword_26AF98630);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98738;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Quaternion<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Quaternion<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Quaternion<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Quaternion<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

double re::internal::defaultConstruct<re::Quaternion<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  *a3 = xmmword_23435FBB0;
  return result;
}

double re::internal::defaultConstructV2<re::Quaternion<float>>(_OWORD *a1)
{
  double result = 0.0;
  *a1 = xmmword_23435FBB0;
  return result;
}

uint64_t re::introspect_QuaternionF(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"QuaternionF", (uint64_t (*)(re::internal *))re::allocInfo_QuaternionF, (re::IntrospectionBase *(*)(void))re::initInfo_QuaternionF, (void (*)(re::IntrospectionBase *))&qword_26AF98638, this);
}

void *re::allocInfo_Matrix2x2F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98640, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98640))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98D28, "Matrix2x2F");
    __cxa_guard_release(&qword_26AF98640);
  }
  return &unk_26AF98D28;
}

void re::initInfo_Matrix2x2F(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xF13AC04E85D76;
  v10[1] = "Matrix2x2F";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98648, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98648);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::Vector2<float> [2]>::get(v5);
      uint64_t v6 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "columns";
      *(void *)(v6 + 16) = &unk_26AF98908;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF98748 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      uint64_t v8 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 8, 4);
      void *v8 = 0x100000004;
      qword_26AF98750 = (uint64_t)v8;
      __cxa_guard_release(&qword_26AF98648);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98748;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Matrix2x2<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Matrix2x2<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Matrix2x2<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Matrix2x2<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

void re::IntrospectionInfo<re::Vector2<float> [2]>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986C0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF986C0);
    if (a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98908);
      __cxa_guard_release(&qword_26AF986C0);
    }
  }
  if ((byte_26AF985AD & 1) == 0)
  {
    byte_26AF985AD = 1;
    uint64_t v1 = (re *)qword_26AF985C0;
    if (!qword_26AF985C0)
    {
      uint64_t v1 = (re *)re::allocInfo_Vector2F(a1);
      qword_26AF985C0 = (uint64_t)v1;
      re::initInfo_Vector2F(v1, v2);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98908, v1, 2);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF98908, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v1 + 2);
    xmmword_26AF98928 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

void re::internal::defaultConstruct<re::Matrix2x2<float>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

void *re::internal::defaultConstructV2<re::Matrix2x2<float>>(void *result)
{
  *double result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Matrix2x2F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix2x2F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix2x2F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix2x2F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix2x2<float>>, this);
}

void *re::allocInfo_Matrix3x3F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98650, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98650))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98DA0, "Matrix3x3F");
    __cxa_guard_release(&qword_26AF98650);
  }
  return &unk_26AF98DA0;
}

void re::initInfo_Matrix3x3F(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xF13AC04E94672;
  v10[1] = "Matrix3x3F";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98658, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98658);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::Vector3<float> [3]>::get(v5);
      uint64_t v6 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "columns";
      *(void *)(v6 + 16) = &unk_26AF98950;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF98758 = v6;
      long long v7 = re::introspectionAllocator((re *)v6);
      uint64_t v8 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 8, 4);
      void *v8 = 0x100000004;
      qword_26AF98760 = (uint64_t)v8;
      __cxa_guard_release(&qword_26AF98658);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98758;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Matrix3x3<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Matrix3x3<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Matrix3x3<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Matrix3x3<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

void re::IntrospectionInfo<re::Vector3<float> [3]>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986C8, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF986C8);
    if (a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98950);
      __cxa_guard_release(&qword_26AF986C8);
    }
  }
  if ((byte_26AF985AE & 1) == 0)
  {
    byte_26AF985AE = 1;
    uint64_t v1 = (re *)qword_26AF985D8;
    if (!qword_26AF985D8)
    {
      uint64_t v1 = (re *)re::allocInfo_Vector3F(a1);
      qword_26AF985D8 = (uint64_t)v1;
      re::initInfo_Vector3F(v1, v2);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98950, v1, 3);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF98950, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v1 + 2);
    xmmword_26AF98970 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

double re::internal::defaultConstruct<re::Matrix3x3<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Matrix3x3<float>>(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t re::introspect_Matrix3x3F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix3x3F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix3x3F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix3x3F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix3x3<float>>, this);
}

void *re::allocInfo_Matrix4x4F(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98660, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98660))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98E18, "Matrix4x4F");
    __cxa_guard_release(&qword_26AF98660);
  }
  return &unk_26AF98E18;
}

void re::initInfo_Matrix4x4F(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xF13AC04EA2F6ELL;
  v10[1] = "Matrix4x4F";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98668, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98668);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::Vector4<float> [4]>::get(v5);
      uint64_t v6 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "columns";
      *(void *)(v6 + 16) = &unk_26AF98998;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF98768 = v6;
      long long v7 = re::introspectionAllocator((re *)v6);
      uint64_t v8 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 8, 4);
      void *v8 = 0x100000004;
      qword_26AF98770 = (uint64_t)v8;
      __cxa_guard_release(&qword_26AF98668);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 257;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98768;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Matrix4x4<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Matrix4x4<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Matrix4x4<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Matrix4x4<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

void re::IntrospectionInfo<re::Vector4<float> [4]>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF986D0, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF986D0);
    if (a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98998);
      __cxa_guard_release(&qword_26AF986D0);
    }
  }
  if ((byte_26AF985AF & 1) == 0)
  {
    byte_26AF985AF = 1;
    uint64_t v1 = (re *)qword_26AF985F0;
    if (!qword_26AF985F0)
    {
      uint64_t v1 = (re *)re::allocInfo_Vector4F(a1);
      qword_26AF985F0 = (uint64_t)v1;
      re::initInfo_Vector4F(v1, v2);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_26AF98998, v1, 4);
    re::IntrospectionRegistry::add(v3, v4);
    re::getPrettyTypeName((re *)&unk_26AF98998, (const re::IntrospectionBase *)&v7);
    if (BYTE8(v7)) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (char *)&v7 + 9;
    }
    if ((void)v7)
    {
      if (BYTE8(v7)) {
        (*(void (**)(void))(*(void *)v7 + 40))();
      }
    }
    long long v7 = *((_OWORD *)v1 + 2);
    xmmword_26AF989B8 = v6;
    re::StringID::destroyString((re::StringID *)v9);
  }
}

double re::internal::defaultConstruct<re::Matrix4x4<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result = 0.0;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Matrix4x4<float>>(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_Matrix4x4F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix4x4F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix4x4F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix4x4F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix4x4<float>>, this);
}

void *re::allocInfo_PoseF(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98670, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98670))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98E90, "PoseF");
    __cxa_guard_release(&qword_26AF98670);
  }
  return &unk_26AF98E90;
}

void re::initInfo_PoseF(re *this, re::IntrospectionBase *a2)
{
  v16[0] = 154604394;
  v16[1] = "PoseF";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)this + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98678, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98678);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      long long v6 = v5;
      long long v7 = (re *)qword_26AF985D8;
      if (!qword_26AF985D8)
      {
        long long v7 = (re *)re::allocInfo_Vector3F(v5);
        qword_26AF985D8 = (uint64_t)v7;
        re::initInfo_Vector3F(v7, v8);
      }
      uint64_t v9 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 72, 8);
      *(_DWORD *)uint64_t v9 = 1;
      *(void *)(v9 + 8) = "position";
      *(void *)(v9 + 16) = v7;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_26AF98778 = v9;
      long long v10 = (re *)re::introspectionAllocator((re *)v9);
      long long v11 = v10;
      long long v12 = (re *)qword_26AF98638;
      if (!qword_26AF98638)
      {
        long long v12 = (re *)re::allocInfo_QuaternionF(v10);
        qword_26AF98638 = (uint64_t)v12;
        re::initInfo_QuaternionF(v12, v13);
      }
      uint64_t v14 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "orientation";
      *(void *)(v14 + 16) = v12;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1000000002;
      *(_DWORD *)(v14 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF98780 = v14;
      __cxa_guard_release(&qword_26AF98678);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF98778;
  *((void *)this + 9) = re::internal::defaultConstruct<re::Pose<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::Pose<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::Pose<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::Pose<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v15 = v17;
}

void re::internal::defaultConstruct<re::Pose<float>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0x3F80000000000000;
}

void *re::internal::defaultConstructV2<re::Pose<float>>(void *result)
{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0x3F80000000000000;
  return result;
}

uint64_t re::introspect_PoseF(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PoseF", (uint64_t (*)(re::internal *))re::allocInfo_PoseF, (re::IntrospectionBase *(*)(void))re::initInfo_PoseF, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Pose<float>>, this);
}

void *re::allocInfo_SRT(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98680, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98680))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98F08, "SRT");
    __cxa_guard_release(&qword_26AF98680);
  }
  return &unk_26AF98F08;
}

void re::initInfo_SRT(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 164778;
  v21[1] = "SRT";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98688, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF98688);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      long long v6 = v5;
      long long v7 = (re *)qword_26AF985D8;
      if (!qword_26AF985D8)
      {
        long long v7 = (re *)re::allocInfo_Vector3F(v5);
        qword_26AF985D8 = (uint64_t)v7;
        re::initInfo_Vector3F(v7, v8);
      }
      uint64_t v9 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 72, 8);
      *(_DWORD *)uint64_t v9 = 1;
      *(void *)(v9 + 8) = "scale";
      *(void *)(v9 + 16) = v7;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_26AF98788 = v9;
      long long v10 = (re *)re::introspectionAllocator((re *)v9);
      long long v11 = v10;
      long long v12 = (re *)qword_26AF98638;
      if (!qword_26AF98638)
      {
        long long v12 = (re *)re::allocInfo_QuaternionF(v10);
        qword_26AF98638 = (uint64_t)v12;
        re::initInfo_QuaternionF(v12, v13);
      }
      uint64_t v14 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "rotation";
      *(void *)(v14 + 16) = v12;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1000000002;
      *(_DWORD *)(v14 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF98790 = v14;
      long long v15 = (re *)re::introspectionAllocator((re *)v14);
      float v16 = v15;
      long long v17 = (re *)qword_26AF985D8;
      if (!qword_26AF985D8)
      {
        long long v17 = (re *)re::allocInfo_Vector3F(v15);
        qword_26AF985D8 = (uint64_t)v17;
        re::initInfo_Vector3F(v17, v18);
      }
      uint64_t v19 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "translation";
      *(void *)(v19 + 16) = v17;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x2000000003;
      *(_DWORD *)(v19 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF98798 = v19;
      __cxa_guard_release(&qword_26AF98688);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 257;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF98788;
  *((void *)this + 9) = re::internal::defaultConstruct<re::GenericSRT<float>>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::GenericSRT<float>>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::GenericSRT<float>>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::GenericSRT<float>>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

void re::internal::defaultConstruct<re::GenericSRT<float>>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0x3F8000003F800000;
  a3[1] = 1065353216;
  a3[2] = 0;
  a3[3] = 0x3F80000000000000;
  a3[4] = 0;
  a3[5] = 0;
}

void *re::internal::defaultConstructV2<re::GenericSRT<float>>(void *result)
{
  *double result = 0x3F8000003F800000;
  result[1] = 1065353216;
  result[2] = 0;
  result[3] = 0x3F80000000000000;
  result[4] = 0;
  result[5] = 0;
  return result;
}

uint64_t re::introspect_SRT(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SRT", (uint64_t (*)(re::internal *))re::allocInfo_SRT, (re::IntrospectionBase *(*)(void))re::initInfo_SRT, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::GenericSRT<float>>, this);
}

uint64_t *re::introspect_RERotationOrder(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98690, memory_order_acquire) & 1) == 0)
  {
    float32x4_t v31 = (re *)__cxa_guard_acquire(&qword_26AF98690);
    if (v31)
    {
      float v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "XYZ";
      qword_26AF98F80 = (uint64_t)v33;
      long long v34 = re::introspectionAllocator(v33);
      long long v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)long long v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "YZX";
      qword_26AF98F88 = (uint64_t)v35;
      unsigned __int32 v36 = re::introspectionAllocator(v35);
      float32x2_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)float32x2_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "ZXY";
      qword_26AF98F90 = (uint64_t)v37;
      float32x2_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "XZY";
      qword_26AF98F98 = (uint64_t)v39;
      uint64_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "YXZ";
      qword_26AF98FA0 = (uint64_t)v41;
      float32x4_t v42 = re::introspectionAllocator(v41);
      float v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)float v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "ZYX";
      qword_26AF98FA8 = (uint64_t)v43;
      float v44 = re::introspectionAllocator(v43);
      float32x4_t v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)float32x4_t v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "Count";
      qword_26AF98FB0 = (uint64_t)v45;
      float32x4_t v46 = re::introspectionAllocator(v45);
      float32x4_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)float32x4_t v47 = 1;
      *((void *)v47 + 1) = 7;
      *((void *)v47 + 2) = "Invalid";
      qword_26AF98FB8 = (uint64_t)v47;
      float32x4_t v48 = re::introspectionAllocator(v47);
      int v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)int v49 = 2;
      *((void *)v49 + 1) = 0;
      *((void *)v49 + 2) = "RERotationOrderXYZ";
      qword_26AF98FC0 = (uint64_t)v49;
      float v50 = re::introspectionAllocator(v49);
      uint64_t v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)uint64_t v51 = 2;
      *((void *)v51 + 1) = 1;
      *((void *)v51 + 2) = "RERotationOrderYZX";
      qword_26AF98FC8 = (uint64_t)v51;
      uint64_t v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 2;
      *((void *)v53 + 1) = 2;
      *((void *)v53 + 2) = "RERotationOrderZXY";
      qword_26AF98FD0 = (uint64_t)v53;
      int v54 = re::introspectionAllocator(v53);
      uint64_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)uint64_t v55 = 2;
      *((void *)v55 + 1) = 3;
      *((void *)v55 + 2) = "RERotationOrderXZY";
      qword_26AF98FD8 = (uint64_t)v55;
      uint64_t v56 = re::introspectionAllocator(v55);
      uint64_t v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)uint64_t v57 = 2;
      *((void *)v57 + 1) = 4;
      *((void *)v57 + 2) = "RERotationOrderYXZ";
      qword_26AF98FE0 = (uint64_t)v57;
      uint64_t v58 = re::introspectionAllocator(v57);
      uint64_t v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)uint64_t v59 = 2;
      *((void *)v59 + 1) = 5;
      *((void *)v59 + 2) = "RERotationOrderZYX";
      qword_26AF98FE8 = (uint64_t)v59;
      int v60 = re::introspectionAllocator(v59);
      unsigned int v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)unsigned int v61 = 2;
      *((void *)v61 + 1) = 6;
      *((void *)v61 + 2) = "RERotationOrderCount";
      qword_26AF98FF0 = (uint64_t)v61;
      unsigned int v62 = re::introspectionAllocator(v61);
      uint64_t v63 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)uint64_t v63 = 2;
      *(void *)(v63 + 8) = 7;
      *(void *)(v63 + 16) = "RERotationOrderInvalid";
      qword_26AF98FF8 = v63;
      __cxa_guard_release(&qword_26AF98690);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98698, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98698))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF987A0, "RERotationOrder", 1, 1, 1, 1);
    qword_26AF987A0 = (uint64_t)&unk_26E715E00;
    qword_26AF987E0 = (uint64_t)&re::introspect_RERotationOrder(BOOL)::enumTable;
    dword_26AF987B0 = 9;
    __cxa_guard_release(&qword_26AF98698);
  }
  if (v2)
  {
    if (_MergedGlobals_423) {
      return &qword_26AF987A0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v69);
    char v3 = _MergedGlobals_423;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v69);
    if (v3) {
      return &qword_26AF987A0;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_423)
    {
LABEL_34:
      unsigned int v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF987A0;
    }
  }
  _MergedGlobals_423 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF987A0, a2);
  uint64_t v65 = 0x9091FC13CDF02DFALL;
  unint64_t v66 = "RERotationOrder";
  v69[0] = 0x31CD534126;
  v69[1] = "uint8_t";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v69);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v69);
    uint64_t v9 = (unsigned int *)qword_26AF987E0;
    v68[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v69, &v65, 1, 1, (uint64_t)v68);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                long long v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v67.int var0 = 2 * v15;
          v67.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v69, v19, &v67);
          re::StringID::destroyString((re::StringID *)&v67);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            long long v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  float v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v67.int var0 = 2 * v23;
            v67.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v69, v27, &v67);
            re::StringID::destroyString((re::StringID *)&v67);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v69, v28);
    xmmword_26AF987C0 = (__int128)v67;
    re::StringID::destroyString((re::StringID *)&v65);
    if (v2) {
      return &qword_26AF987A0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v69);
  re::internal::assertLog((re::internal *)5, v64, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RERotationOrder", v65, v66);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,float,4ul>(uint64_t *this, _OWORD *a2)
{
  char v3 = (re::snapshot::DecoderRaw *)this;
  unint64_t v12 = 0;
  uint64_t v4 = (void *)this[2];
  uint64_t v5 = this[3];
  if ((unint64_t)(v5 - (void)v4) < 8)
  {
    re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v5 - (void)v4);
    this = (uint64_t *)re::snapshot::DecoderRaw::beginArray(v3, &v12);
    if (this)
    {
      if (v12 == 4)
      {
        unsigned int v8 = 0;
        uint64_t v9 = -4;
        do
        {
          if (v8 <= 3)
          {
            unsigned int v10 = v8 + 1;
            this = re::snapshot::DecoderRaw::operator>><float>((uint64_t *)v3, (_DWORD *)a2 + v8);
            unsigned int v8 = v10;
          }
        }
        while (!__CFADD__(v9++, 1));
        if (v8 != 4) {
          return re::snapshot::Decoder::error((const char **)v3, "size mismatch: expected %zu, got %d");
        }
      }
      else
      {
        return re::snapshot::Decoder::error((const char **)v3, "unexpected C Array size: expected %zu, got %zu");
      }
    }
  }
  else
  {
    uint64_t v7 = *v4;
    long long v6 = v4 + 1;
    this[2] = (uint64_t)v6;
    if (v7 == 16)
    {
      if ((unint64_t)(v5 - (void)v6) <= 0xF)
      {
        return re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        *a2 = *v6;
        this[2] += 16;
      }
    }
    else
    {
      return re::snapshot::Decoder::error((const char **)this, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  return this;
}

uint64_t *re::snapshot::DecoderRaw::operator>><double>(uint64_t *result, void *a2)
{
  int v2 = (void *)result[2];
  unint64_t v3 = result[3] - (void)v2;
  if (v3 <= 7) {
    return re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v3);
  }
  *a2 = *v2;
  result[2] += 8;
  return result;
}

uint64_t *re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,re::Vector4<float>,4ul>(uint64_t *this, _OWORD *a2)
{
  unint64_t v3 = this;
  unint64_t v15 = 0;
  uint64_t v4 = (void *)this[2];
  uint64_t v5 = this[3];
  if ((unint64_t)(v5 - (void)v4) < 8)
  {
    re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v5 - (void)v4);
    this = (uint64_t *)re::snapshot::DecoderRaw::beginArray((re::snapshot::DecoderRaw *)v3, &v15);
    if (this)
    {
      if (v15 == 4)
      {
        unsigned int v11 = 0;
        uint64_t v12 = -4;
        do
        {
          if (v11 <= 3)
          {
            unsigned int v13 = v11 + 1;
            this = re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,float,4ul>(v3, &a2[v11]);
            *((_DWORD *)v3 + 8) = 0;
            unsigned int v11 = v13;
          }
        }
        while (!__CFADD__(v12++, 1));
        if (v11 != 4) {
          return re::snapshot::Decoder::error((const char **)v3, "size mismatch: expected %zu, got %d");
        }
      }
      else
      {
        return re::snapshot::Decoder::error((const char **)v3, "unexpected C Array size: expected %zu, got %zu");
      }
    }
  }
  else
  {
    uint64_t v7 = *v4;
    long long v6 = (long long *)(v4 + 1);
    this[2] = (uint64_t)v6;
    if (v7 == 64)
    {
      if ((unint64_t)(v5 - (void)v6) <= 0x3F)
      {
        return re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        long long v8 = *v6;
        long long v9 = v6[1];
        long long v10 = v6[3];
        a2[2] = v6[2];
        a2[3] = v10;
        *a2 = v8;
        a2[1] = v9;
        this[2] += 64;
      }
    }
    else
    {
      return re::snapshot::Decoder::error((const char **)this, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  return this;
}

uint64_t re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderOPACK>,re::Vector4<float>,4ul>(uint64_t a1, _OWORD *a2)
{
  unint64_t v25 = 0;
  uint64_t result = re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v25, 1);
  if (result)
  {
    if (v25 == 64)
    {
      uint64_t v5 = *(long long **)(a1 + 16);
      if (*(void *)(a1 + 24) - (void)v5 <= 0x3FuLL)
      {
        return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        long long v6 = *v5;
        long long v7 = v5[1];
        long long v8 = v5[3];
        a2[2] = v5[2];
        a2[3] = v8;
        *a2 = v6;
        a2[1] = v7;
        *(void *)(a1 + 16) += 64;
      }
    }
    else
    {
      return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  else
  {
    uint64_t result = re::snapshot::DecoderOPACK::beginArray((re::snapshot::DecoderOPACK *)a1, &v25);
    if (result)
    {
      if (v25 == 4)
      {
        unsigned int v9 = 0;
        if (re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25)) {
          return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
        }
        do
        {
          if (v9 > 3)
          {
            uint64_t v21 = *(unsigned __int8 **)(a1 + 16);
            if ((unint64_t)v21 >= *(void *)(a1 + 24))
            {
              int v22 = 0;
            }
            else
            {
              *(void *)(a1 + 16) = v21 + 1;
              int v22 = *v21;
            }
            re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v22);
          }
          else
          {
            unsigned int v10 = v9 + 1;
            if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
            {
              if (re::snapshot::DecoderOPACK::advanceTo<1>(a1))
              {
                unsigned int v11 = (float *)&a2[v9];
                unint64_t v26 = 0;
                if (re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v26, 1))
                {
                  if (v26 == 16)
                  {
                    uint64_t v12 = *(_OWORD **)(a1 + 16);
                    if (*(void *)(a1 + 24) - (void)v12 <= 0xFuLL)
                    {
                      re::snapshot::Decoder::error((const char **)a1, "overrun: attempted to read %zu bytes, only %zu remaining");
                    }
                    else
                    {
                      *(_OWORD *)unsigned int v11 = *v12;
                      *(void *)(a1 + 16) += 16;
                    }
                  }
                  else
                  {
                    re::snapshot::Decoder::error((const char **)a1, "C Array size mismatch: expected %zu, got %zu");
                  }
                }
                else if (re::snapshot::DecoderOPACK::beginArray((re::snapshot::DecoderOPACK *)a1, &v26))
                {
                  if (v26 == 4)
                  {
                    unsigned int v13 = 0;
                    if (re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26)) {
                      goto LABEL_35;
                    }
                    do
                    {
                      if (v13 > 3)
                      {
                        uint64_t v14 = *(unsigned __int8 **)(a1 + 16);
                        if ((unint64_t)v14 >= *(void *)(a1 + 24))
                        {
                          int v15 = 0;
                        }
                        else
                        {
                          *(void *)(a1 + 16) = v14 + 1;
                          int v15 = *v14;
                        }
                        re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v15);
                      }
                      else
                      {
                        re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, &v11[v13++]);
                      }
                    }
                    while (!re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26));
                    if (v13 != 4) {
LABEL_35:
                    }
                      re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
                  }
                  else
                  {
                    re::snapshot::Decoder::error((const char **)a1, "unexpected C Array size: expected %zu, got %zu", 4uLL, v26);
                    while (!re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26))
                    {
                      char v16 = *(unsigned __int8 **)(a1 + 16);
                      if ((unint64_t)v16 >= *(void *)(a1 + 24))
                      {
                        int v17 = 0;
                      }
                      else
                      {
                        *(void *)(a1 + 16) = v16 + 1;
                        int v17 = *v16;
                      }
                      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v17);
                    }
                  }
                }
                int v18 = *(unsigned __int8 **)(a1 + 16);
                if ((unint64_t)v18 >= *(void *)(a1 + 24) || (int v19 = *v18, v19 == 3))
                {
                  int Integer = 0x7FFFFFFF;
                }
                else if ((v19 - 7) > 0x28)
                {
                  int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
                }
                else
                {
                  *(void *)(a1 + 16) = v18 + 1;
                  int Integer = v19 - 8;
                }
                *(_DWORD *)(a1 + 32) = Integer;
              }
              re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
            }
            unsigned int v9 = v10;
          }
          uint64_t result = re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25);
        }
        while (!result);
        if (v9 != 4) {
          return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
        }
      }
      else
      {
        re::snapshot::Decoder::error((const char **)a1, "unexpected C Array size: expected %zu, got %zu", 4uLL, v25);
        while (1)
        {
          uint64_t result = re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25);
          if (result) {
            break;
          }
          uint64_t v23 = *(unsigned __int8 **)(a1 + 16);
          if ((unint64_t)v23 >= *(void *)(a1 + 24))
          {
            int v24 = 0;
          }
          else
          {
            *(void *)(a1 + 16) = v23 + 1;
            int v24 = *v23;
          }
          re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v24);
        }
      }
    }
  }
  return result;
}

void *re::Pose<float>::Pose(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

float32x2_t re::Pose<float>::Pose(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t *a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  int32x4_t v4 = *a4;
  int32x4_t v5 = a4[1];
  int32x4_t v6 = a4[2];
  LODWORD(v7) = HIDWORD(a4[1].i64[0]);
  float v8 = COERCE_FLOAT(a4[2].i64[1]);
  float v9 = v8 + (float)(COERCE_FLOAT(*a4) + v7);
  if (v9 >= 0.0)
  {
    float v20 = sqrtf(v9 + 1.0);
    float32_t v21 = v20 + v20;
    float32x2_t v22 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20));
    float32x2_t v23 = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20), v22));
    v23.i32[0] = vmul_f32(v23, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20), v23)).u32[0];
    *(float32x2_t *)&long long v34 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL), *(int32x2_t *)v6.i8), (float32x2_t)vext_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), 4uLL)), v23.f32[0]);
    v24.i32[0] = vsub_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v4.i8, 1), *(float32x2_t *)v5.i8).u32[0];
    v24.f32[1] = v21;
    v23.i32[1] = 0.25;
    float32x2_t result = vmul_f32(v24, v23);
  }
  else if (*(float *)v4.i32 < v7 || *(float *)v4.i32 < v8)
  {
    float v11 = 1.0 - *(float *)v4.i32;
    if (v7 >= v8)
    {
      float v37 = sqrtf(v7 + (float)(v11 - v8));
      *(float *)&unsigned int v38 = v37 + v37;
      float32x2_t v39 = vrecpe_f32((float32x2_t)v38);
      float32x2_t v40 = vmul_f32(v39, vrecps_f32((float32x2_t)v38, v39));
      v41.i32[0] = vmul_f32(v40, vrecps_f32((float32x2_t)v38, v40)).u32[0];
      v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v4.i8, 1), *(float32x2_t *)v5.i8).u32[0];
      v40.i32[1] = v38;
      float32x2_t v42 = (float32x2_t)vrev64_s32(*(int32x2_t *)v6.i8);
      v43.i32[0] = vadd_f32(v42, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL)).u32[0];
      v43.i32[1] = vsub_f32(v42, (float32x2_t)vdup_laneq_s32(v4, 2)).i32[1];
      float32x2_t result = vmul_n_f32(v43, v41.f32[0]);
      v41.i32[1] = 0.25;
      *(float32x2_t *)&long long v34 = vmul_f32(v40, v41);
    }
    else
    {
      float v12 = sqrtf(v8 + (float)(v11 - v7));
      int32x4_t v13 = *a4;
      *(float *)v13.i32 = v12;
      float32x2_t v14 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL)), *(float32x2_t *)v6.i8);
      float32x2_t v15 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 0);
      float32x2_t v16 = vsub_f32(*(float32x2_t *)v4.i8, v15);
      v15.i32[0] = 2.0;
      v15.i32[0] = vmul_f32(*(float32x2_t *)v13.i8, v15).u32[0];
      v15.i32[1] = v16.i32[1];
      float32x2_t v17 = vrecpe_f32((float32x2_t)v15.u32[0]);
      float32x2_t v18 = vmul_f32(v17, vrecps_f32((float32x2_t)v15.u32[0], v17));
      v16.i32[0] = vmul_f32(v18, vrecps_f32((float32x2_t)v15.u32[0], v18)).u32[0];
      *(float32x2_t *)&long long v34 = vmul_n_f32(v14, v16.f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
      _D2.i32[1] = v16.i32[0];
      float32x2_t result = vmul_f32(v15, _D2);
    }
  }
  else
  {
    float32x2_t v25 = (float32x2_t)__PAIR64__(v4.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v4.i32 + (float)((float)(1.0 - v7) - v8))));
    float32x2_t v26 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 0);
    float32x2_t v27 = vadd_f32(*(float32x2_t *)v4.i8, v26);
    v26.i32[0] = 2.0;
    v26.i32[0] = vmul_f32(v25, v26).u32[0];
    v26.i32[1] = v27.i32[1];
    float32x2_t v28 = vrecpe_f32((float32x2_t)v26.u32[0]);
    float32x2_t v29 = vmul_f32(v28, vrecps_f32((float32x2_t)v26.u32[0], v28));
    v25.i32[0] = vmul_f32(v29, vrecps_f32((float32x2_t)v26.u32[0], v29)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v25.i32[0];
    *(float32x2_t *)&long long v34 = vmul_f32(v26, _D5);
    v35.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), *(float32x2_t *)v6.i8).u32[0];
    v35.i32[1] = vsub_f32((float32x2_t)vdup_laneq_s32(v5, 2), *(float32x2_t *)&v6).i32[1];
    float32x2_t result = vmul_n_f32(v35, v25.f32[0]);
  }
  *((float32x2_t *)&v34 + 1) = result;
  *(_OWORD *)(a1 + 16) = v34;
  return result;
}

BOOL re::DynamicOffsetF::isInSteadyState(re::DynamicOffsetF *this)
{
  int v2 = (float *)((char *)this + 48);
  BOOL result = re::areAlmostEqual<float>((float *)this, (float *)this + 12);
  if (result)
  {
    float v4 = *((float *)this + 8);
    float v5 = *((float *)this + 20);
    if (v4 != v5 && vabds_f32(v4, v5) >= (float)((float)((float)(fabsf(v4) + fabsf(v5)) + 1.0) * 0.00001)) {
      return 0;
    }
    float v6 = *((float *)this + 9);
    float v7 = *((float *)this + 21);
    if (v6 != v7 && vabds_f32(v6, v7) >= (float)((float)((float)(fabsf(v6) + fabsf(v7)) + 1.0) * 0.00001)) {
      return 0;
    }
    float v8 = *((float *)this + 10);
    float v9 = *((float *)this + 22);
    if (v8 != v9 && vabds_f32(v8, v9) >= (float)((float)((float)(fabsf(v8) + fabsf(v9)) + 1.0) * 0.00001)) {
      return 0;
    }
    BOOL result = re::areAlmostEqual<float>(v2, (float *)this + 24);
    if (!result) {
      return result;
    }
    if (((float v10 = *((float *)this + 20), v11 = *((float *)this + 32), v10 == v11)
       || vabds_f32(v10, v11) < (float)((float)((float)(fabsf(v10) + fabsf(v11)) + 1.0) * 0.00001))
      && ((v12 = *((float *)this + 21), float v13 = *((float *)this + 33), v12 == v13)
       || vabds_f32(v12, v13) < (float)((float)((float)(fabsf(v12) + fabsf(v13)) + 1.0) * 0.00001)))
    {
      float v14 = *((float *)this + 22);
      float v15 = *((float *)this + 34);
      return v14 == v15 || vabds_f32(v14, v15) < (float)((float)((float)(fabsf(v14) + fabsf(v15)) + 1.0) * 0.00001);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

float32x4_t re::DynamicOffsetF::calculateConstrainedPose@<Q0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>)
{
  float32x4_t v5 = a1[9];
  _Q5 = a1[10];
  float32x4_t v7 = vnegq_f32(_Q5);
  float32x4_t v9 = *a2;
  float32x4_t v8 = a2[1];
  float32x4_t v10 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
  _S8 = _Q5.i32[3];
  _Q1 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), _Q5), v8, v10);
  float32x4_t v13 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), _Q1, 0xCuLL), v8, _Q5, 3);
  _Q1.i32[0] = v8.i32[3];
  float32x4_t v14 = vmlsq_laneq_f32(v13, _Q5, v8, 3);
  __asm { FMLA            S0, S1, V5.S[3] }
  _Q18 = v14;
  _Q18.f32[3] = _S0;
  float32x4_t v22 = a1[14];
  float32x4_t v21 = a1[15];
  float v23 = a1[17].f32[0];
  if (v23 != -3.4028e38 || a1[17].f32[1] != 3.4028e38)
  {
    float32x4_t v67 = a1[14];
    float32x4_t v68 = a1[15];
    float32x4_t v69 = *a2;
    float32x4_t v70 = v10;
    float32x4_t v71 = v7;
    float32x4_t v72 = a1[10];
    float32x4_t v73 = a1[9];
    float v24 = fabsf(_S0);
    if (v24 <= 1.0 || fabsf(v24 + -1.0) < (float)((float)((float)(v24 + 1.0) + 1.0) * 0.00001))
    {
      if (_S0 > 1.0) {
        _S0 = 1.0;
      }
      if (_S0 < -1.0) {
        _S0 = -1.0;
      }
      float32x4_t v64 = v14;
      float32x4_t v65 = _Q18;
      float v26 = acosf(_S0);
      float32x4_t v14 = v64;
      _Q18 = v65;
      float v25 = v26 + v26;
    }
    else
    {
      float v25 = NAN;
    }
    float32x4_t v27 = vmulq_f32(_Q18, _Q18);
    LODWORD(v28) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
    float32x4_t v29 = 0uLL;
    if (fabsf(v28) >= 1.0e-10)
    {
      float v30 = v28;
      float32x2_t v31 = vrsqrte_f32((float32x2_t)LODWORD(v28));
      float32x2_t v32 = vmul_f32(v31, vrsqrts_f32((float32x2_t)LODWORD(v30), vmul_f32(v31, v31)));
      float32x4_t v29 = vmulq_n_f32(v14, vmul_f32(v32, vrsqrts_f32((float32x2_t)LODWORD(v30), vmul_f32(v32, v32))).f32[0]);
    }
    float32x4_t v33 = a1[16];
    float32x4_t v34 = vmulq_f32(v29, v33);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0] < 0.0)float v25 = -v25; {
    if (v25 < v23)
    }
      float v25 = v23;
    if (v25 > a1[17].f32[1]) {
      float v25 = a1[17].f32[1];
    }
    float32x4_t v35 = vmulq_f32(v33, v33);
    LODWORD(v36) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).u32[0];
    if (fabsf(v36) >= 1.0e-10)
    {
      float v37 = v36;
      float32x2_t v38 = vrsqrte_f32((float32x2_t)LODWORD(v36));
      float32x2_t v39 = vmul_f32(v38, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v38, v38)));
      float32x4_t v33 = vmulq_n_f32(v33, vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v39, v39))).f32[0]);
    }
    float32x4_t v66 = v33;
    __float2 v40 = __sincosf_stret(v25 * 0.5);
    float32x4_t v22 = v67;
    *(float32x2_t *)_Q18.f32 = vmul_n_f32(*(float32x2_t *)v66.f32, v40.__sinval);
    _Q18.i64[1] = __PAIR64__(LODWORD(v40.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v40.__sinval, v66, 2)));
    _Q5 = v72;
    float32x4_t v5 = v73;
    float32x4_t v7 = v71;
    float32x4_t v9 = v69;
    float32x4_t v10 = v70;
    float32x4_t v21 = v68;
  }
  int8x16_t v41 = (int8x16_t)vnegq_f32(v5);
  float32x4_t v42 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), v41, 0xCuLL), _Q5), v10, v5);
  int8x16_t v43 = (int8x16_t)vaddq_f32(v42, v42);
  float32x4_t v44 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v43, 0xCuLL);
  int8x16_t v45 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL), _Q5), v44, v10);
  float32x4_t v46 = vaddq_f32(vsubq_f32(vmulq_laneq_f32(v44, _Q5, 3), v5), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), v45, 0xCuLL));
  float32x4_t v47 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), _Q5), v9, v10);
  int8x16_t v48 = (int8x16_t)vaddq_f32(v47, v47);
  float32x4_t v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL);
  float32x4_t v50 = vaddq_f32(v9, vmulq_laneq_f32(v49, _Q5, 3));
  int8x16_t v51 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL), _Q5), v49, v10);
  float32x4_t v52 = vaddq_f32(v46, vaddq_f32(v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), v51, 0xCuLL)));
  v52.i32[3] = 0;
  v22.i32[3] = 0;
  float32x4_t v53 = vmaxnmq_f32(v52, v22);
  v53.i32[3] = 0;
  v21.i32[3] = 0;
  float32x4_t v54 = vminnmq_f32(v53, v21);
  float32x4_t v55 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL);
  float32x4_t v56 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v54, (int32x4_t)v54), (int8x16_t)v54, 0xCuLL), v7), v54, v55);
  int8x16_t v57 = (int8x16_t)vaddq_f32(v56, v56);
  float32x4_t v58 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), v57, 0xCuLL);
  int8x16_t v59 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), (int8x16_t)v58, 0xCuLL), v7), v58, v55);
  float32x4_t v60 = vaddq_f32(vaddq_f32(v54, vmulq_laneq_f32(v58, _Q5, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), v59, 0xCuLL));
  _Q2 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q18, (int32x4_t)_Q18), (int8x16_t)_Q18, 0xCuLL), v7), _Q18, v55);
  float32x4_t v62 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), _Q2, 0xCuLL), _Q18, _Q5, 3), _Q5, _Q18, 3);
  __asm { FMLA            S2, S8, V18.S[3] }
  v62.i32[3] = _Q2.i32[0];
  float32x4_t result = vaddq_f32(v5, v60);
  *a3 = result;
  a3[1] = v62;
  return result;
}

void re::DynamicOffsetF::step(float32x4_t *this, float a2, int32x2_t a3)
{
  if (this[33].i8[0]) {
    return;
  }
  *(float *)a3.i32 = a2;
  float32x4_t v187 = *this;
  float32x4_t v177 = this[1];
  float32x4_t v188 = this[2];
  int32x2_t v192 = a3;
  float v4 = powf(this[11].f32[0], a2);
  float v5 = powf(this[11].f32[1], *(float *)v192.i32);
  float v6 = powf(this[11].f32[2], *(float *)v192.i32);
  float v7 = powf(this[13].f32[0], *(float *)v192.i32);
  float v185 = powf(this[12].f32[0], *(float *)v192.i32);
  float v182 = powf(this[12].f32[1], *(float *)v192.i32);
  float v179 = powf(this[12].f32[2], *(float *)v192.i32);
  float v8 = 1.0;
  float v9 = this[3].f32[1];
  float v10 = this[6].f32[1];
  float v170 = (float)(v4 * this[3].f32[0]) + (float)(this[6].f32[0] * (float)(1.0 - v4));
  this[3].f32[0] = v170;
  this[3].f32[1] = (float)(v5 * v9) + (float)(v10 * (float)(1.0 - v5));
  float v174 = (float)(v5 * v9) + (float)(v10 * (float)(1.0 - v5));
  float v168 = (float)(v6 * this[3].f32[2]) + (float)(this[6].f32[2] * (float)(1.0 - v6));
  this[3].f32[2] = v168;
  float32x4_t v11 = this[7];
  float32x4_t v12 = this[4];
  float32x4_t v13 = vmulq_f32(v11, v12);
  float32x4_t v14 = (float32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL);
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)v14.f32);
  v13.f32[0] = vaddv_f32(*(float32x2_t *)v13.f32);
  v14.i64[0] = 0;
  float32x4_t v15 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v13, v14)), 0), (int8x16_t)vnegq_f32(v12), (int8x16_t)v12);
  float v16 = 1.0 - v7;
  float32x4_t v17 = vsubq_f32(v11, v15);
  int8x16_t v18 = (int8x16_t)vmulq_f32(v17, v17);
  float32x4_t v166 = v15;
  float32x4_t v167 = v11;
  float32x4_t v19 = vaddq_f32(v11, v15);
  int8x16_t v20 = (int8x16_t)vmulq_f32(v19, v19);
  float v21 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL)))));
  float v22 = v21 + v21;
  BOOL v23 = (float)(v21 + v21) == 0.0;
  float v24 = 1.0;
  if (!v23) {
    float v24 = sinf(v22) / v22;
  }
  float v25 = v24;
  float32x2_t v26 = vrecpe_f32((float32x2_t)LODWORD(v24));
  float32x2_t v27 = vmul_f32(v26, vrecps_f32((float32x2_t)LODWORD(v25), v26));
  LODWORD(v28) = vmul_f32(v27, vrecps_f32((float32x2_t)LODWORD(v25), v27)).u32[0];
  if ((float)(v16 * v22) != 0.0)
  {
    float v163 = v28;
    v27.f32[0] = sinf(v16 * v22);
    float v28 = v163;
    float v8 = v27.f32[0] / (float)(v16 * v22);
  }
  v27.f32[0] = v16 * (float)(v28 * v8);
  float32x4_t v29 = (float32x4_t)vdupq_lane_s32((int32x2_t)v27, 0);
  float v30 = v7 * v22;
  float v31 = 1.0;
  if (v30 != 0.0)
  {
    float32x4_t v162 = v29;
    float v164 = v28;
    float v32 = sinf(v30);
    float32x4_t v29 = v162;
    float v28 = v164;
    float v31 = v32 / v30;
  }
  float32x4_t v33 = vmlaq_f32(vmulq_n_f32(v166, v7 * (float)(v28 * v31)), v167, v29);
  int8x16_t v34 = (int8x16_t)vmulq_f32(v33, v33);
  float32x2_t v35 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (vaddv_f32(v35) == 0.0)
  {
    float32x4_t v36 = (float32x4_t)xmmword_23435FBB0;
  }
  else
  {
    unsigned __int32 v37 = vadd_f32(v35, (float32x2_t)vdup_lane_s32((int32x2_t)v35, 1)).u32[0];
    float32x2_t v38 = vrsqrte_f32((float32x2_t)v37);
    float32x2_t v39 = vmul_f32(v38, vrsqrts_f32((float32x2_t)v37, vmul_f32(v38, v38)));
    float32x4_t v36 = vmulq_n_f32(v33, vmul_f32(v39, vrsqrts_f32((float32x2_t)v37, vmul_f32(v39, v39))).f32[0]);
  }
  int8x16_t v40 = (int8x16_t)vmulq_f32(v36, v36);
  *(float32x2_t *)v40.i8 = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL));
  v40.i32[0] = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1)).u32[0];
  float32x2_t v41 = vrsqrte_f32((float32x2_t)v40.u32[0]);
  float32x2_t v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v41, v41)));
  float32x4_t v43 = vmulq_n_f32(v36, vmul_f32(v42, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v42, v42))).f32[0]);
  this[4] = v43;
  float v44 = 1.0;
  float v45 = (float)(v185 * this[5].f32[0]) + (float)(this[8].f32[0] * (float)(1.0 - v185));
  float v46 = (float)(v182 * this[5].f32[1]) + (float)(this[8].f32[1] * (float)(1.0 - v182));
  this[5].f32[0] = v45;
  this[5].f32[1] = v46;
  float v165 = v46;
  float v161 = v45;
  float v47 = (float)(v179 * this[5].f32[2]) + (float)(this[8].f32[2] * (float)(1.0 - v179));
  this[5].f32[2] = v47;
  float v48 = (float)(v187.f32[1] * v5) + (float)(v174 * (float)(1.0 - v5));
  float v178 = (float)(v187.f32[0] * v4) + (float)(v170 * (float)(1.0 - v4));
  this->f32[0] = v178;
  this->f32[1] = v48;
  float v49 = (float)(v187.f32[2] * v6) + (float)(v168 * (float)(1.0 - v6));
  this->f32[2] = v49;
  float32x4_t v50 = vmulq_f32(v177, v43);
  float32x4_t v51 = (float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL);
  *(float32x2_t *)v50.f32 = vadd_f32(*(float32x2_t *)v50.f32, *(float32x2_t *)v51.f32);
  v50.f32[0] = vaddv_f32(*(float32x2_t *)v50.f32);
  v51.i64[0] = 0;
  float32x4_t v173 = vnegq_f32(v177);
  float32x4_t v52 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v50, v51)), 0), (int8x16_t)v173, (int8x16_t)v177);
  float32x4_t v53 = vsubq_f32(v43, v52);
  int8x16_t v54 = (int8x16_t)vmulq_f32(v53, v53);
  float32x4_t v189 = v43;
  float32x4_t v175 = v52;
  float32x4_t v55 = vaddq_f32(v43, v52);
  int8x16_t v56 = (int8x16_t)vmulq_f32(v55, v55);
  float v57 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)))));
  float v58 = v57 + v57;
  BOOL v23 = (float)(v57 + v57) == 0.0;
  float v59 = 1.0;
  if (!v23) {
    float v59 = sinf(v58) / v58;
  }
  float v60 = v59;
  float32x2_t v61 = vrecpe_f32((float32x2_t)LODWORD(v59));
  float32x2_t v62 = vmul_f32(v61, vrecps_f32((float32x2_t)LODWORD(v60), v61));
  LODWORD(v63) = vmul_f32(v62, vrecps_f32((float32x2_t)LODWORD(v60), v62)).u32[0];
  if ((float)(v16 * v58) != 0.0)
  {
    float v171 = v63;
    v62.f32[0] = sinf(v16 * v58);
    float v63 = v171;
    float v44 = v62.f32[0] / (float)(v16 * v58);
  }
  v62.f32[0] = v16 * (float)(v63 * v44);
  float32x4_t v64 = (float32x4_t)vdupq_lane_s32((int32x2_t)v62, 0);
  float v65 = v7 * v58;
  float v66 = 1.0;
  if (v65 != 0.0)
  {
    float32x4_t v169 = v64;
    float v172 = v63;
    float v67 = sinf(v65);
    float32x4_t v64 = v169;
    float v63 = v172;
    float v66 = v67 / v65;
  }
  float32x4_t v68 = vmlaq_f32(vmulq_n_f32(v175, v7 * (float)(v63 * v66)), v189, v64);
  int8x16_t v69 = (int8x16_t)vmulq_f32(v68, v68);
  float32x2_t v70 = vadd_f32(*(float32x2_t *)v69.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
  if (vaddv_f32(v70) == 0.0)
  {
    float32x4_t v71 = (float32x4_t)xmmword_23435FBB0;
  }
  else
  {
    unsigned __int32 v72 = vadd_f32(v70, (float32x2_t)vdup_lane_s32((int32x2_t)v70, 1)).u32[0];
    float32x2_t v73 = vrsqrte_f32((float32x2_t)v72);
    float32x2_t v74 = vmul_f32(v73, vrsqrts_f32((float32x2_t)v72, vmul_f32(v73, v73)));
    float32x4_t v71 = vmulq_n_f32(v68, vmul_f32(v74, vrsqrts_f32((float32x2_t)v72, vmul_f32(v74, v74))).f32[0]);
  }
  int8x16_t v75 = (int8x16_t)vmulq_f32(v71, v71);
  *(float32x2_t *)v75.i8 = vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL));
  v75.i32[0] = vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v75.i8, 1)).u32[0];
  float32x2_t v76 = vrsqrte_f32((float32x2_t)v75.u32[0]);
  float32x2_t v77 = vmul_f32(v76, vrsqrts_f32((float32x2_t)v75.u32[0], vmul_f32(v76, v76)));
  float32x4_t v190 = vmulq_n_f32(v71, vmul_f32(v77, vrsqrts_f32((float32x2_t)v75.u32[0], vmul_f32(v77, v77))).f32[0]);
  this[1] = v190;
  float v78 = (float)(v188.f32[1] * v182) + (float)(v165 * (float)(1.0 - v182));
  this[2].f32[0] = (float)(v188.f32[0] * v185) + (float)(v161 * (float)(1.0 - v185));
  this[2].f32[1] = v78;
  float v79 = (float)(v179 * v188.f32[2]) + (float)(v47 * (float)(1.0 - v179));
  this[2].f32[2] = v79;
  re::DynamicOffsetF::calculateConstrainedPose(this, this, &v194);
  float32x4_t v186 = this[2];
  float32x4_t v80 = v186;
  v80.i32[3] = 0;
  float32x4_t v81 = this[18];
  float32x4_t v83 = this[19];
  v81.i32[3] = 0;
  float32x4_t v82 = vmaxnmq_f32(v80, v81);
  v82.i32[3] = 0;
  v83.i32[3] = 0;
  float v84 = v194.f32[0];
  if (v178 != v194.f32[0]
    && vabds_f32(v178, v194.f32[0]) >= (float)((float)((float)(fabsf(v178) + fabsf(v194.f32[0])) + 1.0) * 0.00001))
  {
    float v85 = v194.f32[1];
LABEL_28:
    float v86 = this[22].f32[1];
    float v176 = v49;
    float v87 = (float)(v188.f32[1] * v182) + (float)(v165 * (float)(1.0 - v182));
    float v88 = v79;
    float v89 = this[22].f32[2];
    float32x4_t v180 = v82;
    float32x4_t v183 = v83;
    float v90 = powf(1.0 - this[22].f32[0], *(float *)v192.i32);
    this[6].f32[0] = (float)(v84 * v90) + (float)(v178 * (float)(1.0 - v90));
    float v91 = powf(1.0 - v86, *(float *)v192.i32);
    this[6].f32[1] = (float)(v85 * v91) + (float)(v48 * (float)(1.0 - v91));
    float v92 = v194.f32[2];
    float v93 = 1.0 - v89;
    float v79 = v88;
    float v78 = v87;
    float v94 = powf(v93, *(float *)v192.i32);
    float32x4_t v82 = v180;
    float32x4_t v83 = v183;
    this[6].f32[2] = (float)(v94 * v92) + (float)(v176 * (float)(1.0 - v94));
    goto LABEL_29;
  }
  float v85 = v194.f32[1];
  if (v48 != v194.f32[1]
    && vabds_f32(v48, v194.f32[1]) >= (float)((float)((float)(fabsf(v48) + fabsf(v194.f32[1])) + 1.0) * 0.00001)
    || v49 != v194.f32[2]
    && vabds_f32(v49, v194.f32[2]) >= (float)((float)((float)(fabsf(v49) + fabsf(v194.f32[2])) + 1.0) * 0.00001))
  {
    goto LABEL_28;
  }
LABEL_29:
  float32x4_t v95 = vminnmq_f32(v82, v83);
  float32x4_t v184 = v95;
  if (v190.f32[0] != v195.f32[0]
    && vabds_f32(v190.f32[0], v195.f32[0]) >= (float)((float)((float)(fabsf(v190.f32[0]) + fabsf(v195.f32[0])) + 1.0)
                                                    * 0.00001)
    || v190.f32[1] != v195.f32[1]
    && vabds_f32(v190.f32[1], v195.f32[1]) >= (float)((float)((float)(fabsf(v190.f32[1]) + fabsf(v195.f32[1])) + 1.0)
                                                    * 0.00001)
    || v190.f32[2] != v195.f32[2]
    && vabds_f32(v190.f32[2], v195.f32[2]) >= (float)((float)((float)(fabsf(v190.f32[2]) + fabsf(v195.f32[2])) + 1.0)
                                                    * 0.00001)
    || v190.f32[3] != v195.f32[3]
    && vabds_f32(v190.f32[3], v195.f32[3]) >= (float)((float)((float)(fabsf(v190.f32[3]) + fabsf(v195.f32[3])) + 1.0)
                                                    * 0.00001))
  {
    float v96 = powf(1.0 - this[23].f32[2], *(float *)v192.i32);
    float v97 = v195.f32[3];
    float v98 = fabsf(v195.f32[3]);
    if (v98 <= 1.0 || fabsf(v98 + -1.0) < (float)((float)((float)(v98 + 1.0) + 1.0) * 0.00001))
    {
      if (v195.f32[3] > 1.0) {
        float v97 = 1.0;
      }
      if (v97 < -1.0) {
        float v97 = -1.0;
      }
      float v100 = acosf(v97);
      float v99 = v100 + v100;
    }
    else
    {
      float v99 = NAN;
    }
    float32x4_t v101 = vmulq_f32(v195, v195);
    LODWORD(v102) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 2), vaddq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1))).u32[0];
    float32x4_t v103 = 0uLL;
    if (fabsf(v102) >= 1.0e-10)
    {
      float v104 = v102;
      float32x2_t v105 = vrsqrte_f32((float32x2_t)LODWORD(v102));
      float32x2_t v106 = vmul_f32(v105, vrsqrts_f32((float32x2_t)LODWORD(v104), vmul_f32(v105, v105)));
      float32x4_t v103 = vmulq_n_f32(v195, vmul_f32(v106, vrsqrts_f32((float32x2_t)LODWORD(v104), vmul_f32(v106, v106))).f32[0]);
    }
    float32x4_t v107 = this[16];
    float32x4_t v108 = vmulq_f32(v103, v107);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))).f32[0] >= 0.0)float v109 = v99; {
    else
    }
      float v109 = -v99;
    float v110 = fabsf(v190.f32[3]);
    float v111 = 1.0;
    float32x4_t v181 = this[16];
    if (v110 <= 1.0 || fabsf(v110 + -1.0) < (float)((float)((float)(v110 + 1.0) + 1.0) * 0.00001))
    {
      if (v190.f32[3] <= 1.0) {
        float v111 = v190.f32[3];
      }
      if (v111 < -1.0) {
        float v111 = -1.0;
      }
      float v113 = acosf(v111);
      float32x4_t v107 = v181;
      float v112 = v113 + v113;
    }
    else
    {
      float v112 = NAN;
    }
    float32x4_t v114 = vmulq_f32(v190, v190);
    LODWORD(v115) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 2), vaddq_f32(v114, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1))).u32[0];
    float32x4_t v116 = 0uLL;
    if (fabsf(v115) >= 1.0e-10)
    {
      float v117 = v115;
      float32x2_t v118 = vrsqrte_f32((float32x2_t)LODWORD(v115));
      float32x2_t v119 = vmul_f32(v118, vrsqrts_f32((float32x2_t)LODWORD(v117), vmul_f32(v118, v118)));
      float32x4_t v116 = vmulq_n_f32(v190, vmul_f32(v119, vrsqrts_f32((float32x2_t)LODWORD(v117), vmul_f32(v119, v119))).f32[0]);
    }
    float32x4_t v120 = vmulq_f32(v107, v116);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 2), vaddq_f32(v120, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v120.f32, 1))).f32[0] < 0.0)float v112 = -v112; {
    float v121 = (float)(v96 * v109) + (float)(v112 * (float)(1.0 - v96));
    }
    float32x4_t v122 = vmulq_f32(v107, v107);
    LODWORD(v123) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 2), vaddq_f32(v122, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v122.f32, 1))).u32[0];
    if (fabsf(v123) >= 1.0e-10)
    {
      float v124 = v123;
      float32x2_t v125 = vrsqrte_f32((float32x2_t)LODWORD(v123));
      float32x2_t v126 = vmul_f32(v125, vrsqrts_f32((float32x2_t)LODWORD(v124), vmul_f32(v125, v125)));
      float32x4_t v181 = vmulq_n_f32(v107, vmul_f32(v126, vrsqrts_f32((float32x2_t)LODWORD(v124), vmul_f32(v126, v126))).f32[0]);
    }
    __float2 v127 = __sincosf_stret(v121 * 0.5);
    float32x4_t v95 = v184;
    *(float32x2_t *)v128.f32 = vmul_n_f32(*(float32x2_t *)v181.f32, v127.__sinval);
    v128.i64[1] = __PAIR64__(LODWORD(v127.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v127.__sinval, v181, 2)));
    this[7] = v128;
  }
  float v129 = v95.f32[1];
  float v130 = v95.f32[2];
  float32x4_t v131 = v186;
  if ((vmovn_s32(vceqq_f32(v186, v95)).u8[0] & 1) == 0
    && fabsf(vsubq_f32(v186, v95).f32[0]) >= (float)((float)((float)(fabsf(v186.f32[0]) + fabsf(v95.f32[0])) + 1.0)
                                                   * 0.00001)
    || v186.f32[1] != v95.f32[1]
    && vabds_f32(v186.f32[1], v95.f32[1]) >= (float)((float)((float)(fabsf(v186.f32[1]) + fabsf(v95.f32[1])) + 1.0)
                                                   * 0.00001)
    || v186.f32[2] != v95.f32[2]
    && vabds_f32(v186.f32[2], v95.f32[2]) >= (float)((float)((float)(fabsf(v186.f32[2]) + fabsf(v95.f32[2])) + 1.0)
                                                   * 0.00001))
  {
    float v132 = this[26].f32[1];
    float v133 = this[26].f32[2];
    float v134 = powf(1.0 - this[26].f32[0], *(float *)v192.i32);
    this[8].f32[0] = (float)(v184.f32[0] * v134) + (float)(v186.f32[0] * (float)(1.0 - v134));
    float v135 = powf(1.0 - v132, *(float *)v192.i32);
    this[8].f32[1] = (float)(v129 * v135) + (float)(v78 * (float)(1.0 - v135));
    float v136 = powf(1.0 - v133, *(float *)v192.i32);
    float32x4_t v131 = v186;
    this[8].f32[2] = (float)(v130 * v136) + (float)(v79 * (float)(1.0 - v136));
  }
  if (*(float *)v192.i32 > 0.0)
  {
    float32x4_t v137 = (float32x4_t)vdupq_lane_s32(v192, 0);
    int8x16_t v138 = (int8x16_t)vmulq_f32(v177, v177);
    float v139 = vaddv_f32(vadd_f32(*(float32x2_t *)v138.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v138, v138, 8uLL)));
    float v140 = 1.0;
    float v141 = 1.0 / v139;
    float v142 = vmuls_lane_f32(v141, v177, 3);
    float32x4_t v143 = vmulq_n_f32(v173, v141);
    int8x16_t v144 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v190, (int32x4_t)v190), (int8x16_t)v190, 0xCuLL), vnegq_f32(v143)), v190, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v143, (int32x4_t)v143), (int8x16_t)v143, 0xCuLL));
    float32x4_t v145 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v144, (int32x4_t)v144), v144, 0xCuLL), v190, v142), v143, v190, 3);
    v143.f32[3] = v142;
    float32x4_t v146 = vmulq_f32(v143, v190);
    v145.f32[3] = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v146, 2), vaddq_f32(v146, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v146.f32, 1))).f32[0]- (float)(v142 * v190.f32[3]));
    int8x16_t v147 = (int8x16_t)vmulq_f32(v145, v145);
    *(float32x2_t *)v147.i8 = vadd_f32(*(float32x2_t *)v147.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v147, v147, 8uLL));
    v147.i32[0] = vadd_f32(*(float32x2_t *)v147.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v147.i8, 1)).u32[0];
    this[27] = vdivq_f32(vsubq_f32(*this, v187), v137);
    float32x2_t v148 = vrsqrte_f32((float32x2_t)v147.u32[0]);
    float32x2_t v149 = vmul_f32(v148, vrsqrts_f32((float32x2_t)v147.u32[0], vmul_f32(v148, v148)));
    float32x4_t v150 = vmulq_n_f32(v145, vmul_f32(v149, vrsqrts_f32((float32x2_t)v147.u32[0], vmul_f32(v149, v149))).f32[0]);
    float v151 = fabsf(v150.f32[3]);
    if (v151 <= 1.0 || fabsf(v151 + -1.0) < (float)((float)((float)(v151 + 1.0) + 1.0) * 0.00001))
    {
      if (v150.f32[3] <= 1.0) {
        float v140 = v150.f32[3];
      }
      if (v140 < -1.0) {
        float v140 = -1.0;
      }
      float32x4_t v191 = v150;
      float32x4_t v193 = v137;
      float v153 = acosf(v140);
      float32x4_t v150 = v191;
      float32x4_t v137 = v193;
      float32x4_t v131 = v186;
      float v152 = v153 + v153;
      float32x4_t v154 = 0uLL;
      if (v152 == 0.0) {
        goto LABEL_84;
      }
    }
    else
    {
      float v152 = NAN;
    }
    float32x4_t v155 = vmulq_f32(v150, v150);
    LODWORD(v156) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 2), vaddq_f32(v155, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v155.f32, 1))).u32[0];
    float32x4_t v157 = 0uLL;
    if (fabsf(v156) >= 1.0e-10)
    {
      float v158 = v156;
      float32x2_t v159 = vrsqrte_f32((float32x2_t)LODWORD(v156));
      float32x2_t v160 = vmul_f32(v159, vrsqrts_f32((float32x2_t)LODWORD(v158), vmul_f32(v159, v159)));
      float32x4_t v157 = vmulq_n_f32(v150, vmul_f32(v160, vrsqrts_f32((float32x2_t)LODWORD(v158), vmul_f32(v160, v160))).f32[0]);
    }
    float32x4_t v154 = vdivq_f32(vmulq_n_f32(v157, v152), v137);
LABEL_84:
    this[28] = v154;
    this[29] = vdivq_f32(vsubq_f32(v131, v188), v137);
  }
}

void re::DynamicOffsetF::updateInteraction(uint64_t a1, uint64_t a2, float32x4_t *a3, double a4)
{
  float32x4_t v87 = *(float32x4_t *)a1;
  float32x4_t v89 = *(float32x4_t *)(a1 + 16);
  float v5 = (float32x4_t *)(a1 + 32);
  float32x4_t v91 = *(float32x4_t *)(a1 + 32);
  long long v6 = *(_OWORD *)(a2 + 16);
  float32x4_t v98 = *(float32x4_t *)a2;
  long long v99 = v6;
  float32x4_t v97 = *a3;
  re::DynamicOffsetF::calculateConstrainedPose((float32x4_t *)a1, &v98, &v95);
  float32x4_t v7 = v97;
  float32x4_t v8 = v97;
  v8.i32[3] = 0;
  float32x4_t v9 = *(float32x4_t *)(a1 + 288);
  float32x4_t v10 = *(float32x4_t *)(a1 + 304);
  v9.i32[3] = 0;
  float32x4_t v11 = vmaxnmq_f32(v8, v9);
  v11.i32[3] = 0;
  v10.i32[3] = 0;
  float32x4_t v12 = vminnmq_f32(v11, v10);
  float32x4_t v94 = v12;
  if (v95.f32[0] != v98.f32[0]
    && vabds_f32(v95.f32[0], v98.f32[0]) >= (float)((float)((float)(fabsf(v95.f32[0]) + fabsf(v98.f32[0])) + 1.0)
                                                  * 0.00001)
    || v95.f32[1] != v98.f32[1]
    && vabds_f32(v95.f32[1], v98.f32[1]) >= (float)((float)((float)(fabsf(v95.f32[1]) + fabsf(v98.f32[1])) + 1.0)
                                                  * 0.00001)
    || v95.f32[2] != v98.f32[2]
    && vabds_f32(v95.f32[2], v98.f32[2]) >= (float)((float)((float)(fabsf(v95.f32[2]) + fabsf(v98.f32[2])) + 1.0)
                                                  * 0.00001))
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      float v14 = *(float *)(a1 + i * 4 + 320);
      if (v14 > 0.0)
      {
        float v15 = v95.f32[i];
        float v16 = v98.f32[i];
        if (v15 > v16) {
          float v14 = -v14;
        }
        v98.f32[i] = v16
                   + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v15 - v16) / v14) + -1.0)) + -1.0)
                                   / *(float *)(a1 + i * 4 + 336))
                           / v14);
      }
    }
  }
  if (v96.f32[0] != *(float *)&v99
    && vabds_f32(v96.f32[0], *(float *)&v99) >= (float)((float)((float)(fabsf(v96.f32[0]) + fabsf(*(float *)&v99)) + 1.0)
                                                      * 0.00001)
    || v96.f32[1] != *((float *)&v99 + 1)
    && vabds_f32(v96.f32[1], *((float *)&v99 + 1)) >= (float)((float)((float)(fabsf(v96.f32[1])
                                                                            + fabsf(*((float *)&v99 + 1)))
                                                                    + 1.0)
                                                            * 0.00001)
    || v96.f32[2] != *((float *)&v99 + 2)
    && vabds_f32(v96.f32[2], *((float *)&v99 + 2)) >= (float)((float)((float)(fabsf(v96.f32[2])
                                                                            + fabsf(*((float *)&v99 + 2)))
                                                                    + 1.0)
                                                            * 0.00001)
    || v96.f32[3] != *((float *)&v99 + 3)
    && vabds_f32(v96.f32[3], *((float *)&v99 + 3)) >= (float)((float)((float)(fabsf(v96.f32[3])
                                                                            + fabsf(*((float *)&v99 + 3)))
                                                                    + 1.0)
                                                            * 0.00001))
  {
    float v17 = *(float *)(a1 + 368);
    if (v17 > 0.0)
    {
      float32x4_t v84 = v12;
      float32x4_t v85 = v7;
      float v18 = v96.f32[3];
      float v19 = fabsf(v96.f32[3]);
      if (v19 <= 1.0 || fabsf(v19 + -1.0) < (float)((float)((float)(v19 + 1.0) + 1.0) * 0.00001))
      {
        if (v96.f32[3] > 1.0) {
          float v18 = 1.0;
        }
        if (v18 < -1.0) {
          float v18 = -1.0;
        }
        float v21 = acosf(v18);
        float v20 = v21 + v21;
      }
      else
      {
        float v20 = NAN;
      }
      float32x4_t v22 = vmulq_f32(v96, v96);
      LODWORD(v23) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).u32[0];
      float32x4_t v24 = 0uLL;
      if (fabsf(v23) >= 1.0e-10)
      {
        float v25 = v23;
        float32x2_t v26 = vrsqrte_f32((float32x2_t)LODWORD(v23));
        float32x2_t v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)LODWORD(v25), vmul_f32(v26, v26)));
        float32x4_t v24 = vmulq_n_f32(v96, vmul_f32(v27, vrsqrts_f32((float32x2_t)LODWORD(v25), vmul_f32(v27, v27))).f32[0]);
      }
      float v28 = *((float *)&v99 + 3);
      float v29 = fabsf(*((float *)&v99 + 3));
      if (v29 <= 1.0 || fabsf(v29 + -1.0) < (float)((float)((float)(v29 + 1.0) + 1.0) * 0.00001))
      {
        if (*((float *)&v99 + 3) > 1.0) {
          float v28 = 1.0;
        }
        if (v28 < -1.0) {
          float v28 = -1.0;
        }
        float32x4_t v82 = v24;
        float v31 = acosf(v28);
        float32x4_t v24 = v82;
        float v30 = v31 + v31;
      }
      else
      {
        float v30 = NAN;
      }
      float32x4_t v32 = *(float32x4_t *)(a1 + 256);
      float32x4_t v33 = vmulq_f32(v24, v32);
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0] < 0.0)float v30 = -v30; {
      float v34 = -v17;
      }
      if (v20 <= v30) {
        float v34 = v17;
      }
      float v35 = v30
          + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v20 - v30) / v34) + -1.0)) + -1.0)
                          / *(float *)(a1 + 372))
                  / v34);
      float32x4_t v36 = vmulq_f32(v32, v32);
      LODWORD(v37) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).u32[0];
      if (fabsf(v37) >= 1.0e-10)
      {
        float v38 = v37;
        float32x2_t v39 = vrsqrte_f32((float32x2_t)LODWORD(v37));
        float32x2_t v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v38), vmul_f32(v39, v39)));
        float32x4_t v32 = vmulq_n_f32(v32, vmul_f32(v40, vrsqrts_f32((float32x2_t)LODWORD(v38), vmul_f32(v40, v40))).f32[0]);
      }
      float32x4_t v83 = v32;
      __float2 v41 = __sincosf_stret(v35 * 0.5);
      float32x4_t v12 = v84;
      *(float32x2_t *)&long long v42 = vmul_n_f32(*(float32x2_t *)v83.f32, v41.__sinval);
      *((void *)&v42 + 1) = __PAIR64__(LODWORD(v41.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v41.__sinval, v83, 2)));
      long long v99 = v42;
      float32x4_t v7 = v85;
    }
  }
  if ((vmovn_s32(vceqq_f32(v12, v7)).u8[0] & 1) == 0
    && fabsf(vsubq_f32(v12, v7).f32[0]) >= (float)((float)((float)(fabsf(v7.f32[0]) + fabsf(v12.f32[0])) + 1.0) * 0.00001)
    || v12.f32[1] != v7.f32[1]
    && vabds_f32(v12.f32[1], v7.f32[1]) >= (float)((float)((float)(fabsf(v7.f32[1]) + fabsf(v12.f32[1])) + 1.0) * 0.00001)
    || v12.f32[2] != v7.f32[2]
    && vabds_f32(v12.f32[2], v7.f32[2]) >= (float)((float)((float)(fabsf(v7.f32[2]) + fabsf(v12.f32[2])) + 1.0) * 0.00001))
  {
    for (uint64_t j = 0; j != 3; ++j)
    {
      float v44 = *(float *)(a1 + j * 4 + 384);
      if (v44 > 0.0)
      {
        float v45 = v94.f32[j];
        float v46 = v97.f32[j];
        if (v45 > v46) {
          float v44 = -v44;
        }
        v97.f32[j] = v46
                   + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v45 - v46) / v44) + -1.0)) + -1.0)
                                   / *(float *)(a1 + j * 4 + 400))
                           / v44);
      }
    }
  }
  long long v47 = v99;
  *(float32x4_t *)a1 = v98;
  *(_OWORD *)(a1 + 16) = v47;
  *float v5 = v97;
  if (*(float *)&a4 > 0.0)
  {
    float32x4_t v48 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float32x4_t v49 = vdivq_f32(vsubq_f32(*(float32x4_t *)a1, v87), v48);
    __asm
    {
      FMOV            V7.4S, #0.25
      FMOV            V2.4S, #0.75
    }
    if (!(_NF ^ _VF | _ZF))
    {
      float32x4_t v56 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(a1 + 432), _Q7), _Q2, v49);
      *(_OWORD *)(a1 + 48re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(a1 + 432);
      *(float32x4_t *)(a1 + 432) = v56;
    }
    float32x4_t v93 = _Q2;
    int8x16_t v57 = (int8x16_t)vmulq_f32(v89, v89);
    float v58 = vaddv_f32(vadd_f32(*(float32x2_t *)v57.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)));
    float v59 = 1.0;
    float v60 = 1.0 / v58;
    _S2 = vmuls_lane_f32(v60, v89, 3);
    _Q1 = vmulq_n_f32(vnegq_f32(v89), v60);
    _Q3 = *(float32x4_t *)(a1 + 16);
    int8x16_t v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), vnegq_f32(_Q1)), _Q3, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
    float32x4_t v65 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL), _Q3, _S2), _Q1, _Q3, 3);
    __asm { FMLA            S1, S2, V3.S[3] }
    v65.i32[3] = _Q1.i32[0];
    int8x16_t v66 = (int8x16_t)vmulq_f32(v65, v65);
    *(float32x2_t *)v66.i8 = vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL));
    v66.i32[0] = vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1)).u32[0];
    float32x2_t v67 = vrsqrte_f32((float32x2_t)v66.u32[0]);
    float32x2_t v68 = vmul_f32(v67, vrsqrts_f32((float32x2_t)v66.u32[0], vmul_f32(v67, v67)));
    float32x4_t v69 = vmulq_n_f32(v65, vmul_f32(v68, vrsqrts_f32((float32x2_t)v66.u32[0], vmul_f32(v68, v68))).f32[0]);
    float v70 = fabsf(v69.f32[3]);
    if (v70 <= 1.0 || fabsf(v70 + -1.0) < (float)((float)((float)(v70 + 1.0) + 1.0) * 0.00001))
    {
      if (v69.f32[3] <= 1.0) {
        float v59 = v69.f32[3];
      }
      if (v59 < -1.0) {
        float v59 = -1.0;
      }
      float32x4_t v88 = v48;
      float32x4_t v90 = _Q7;
      float32x4_t v86 = v69;
      float v72 = acosf(v59);
      float32x4_t v69 = v86;
      float32x4_t v48 = v88;
      _Q7 = v90;
      float v71 = v72 + v72;
    }
    else
    {
      float v71 = NAN;
    }
    if (v71 > 0.008)
    {
      float32x4_t v73 = vmulq_f32(v69, v69);
      LODWORD(v74) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 2), vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 1))).u32[0];
      float32x4_t v75 = 0uLL;
      if (fabsf(v74) >= 1.0e-10)
      {
        float v76 = v74;
        float32x2_t v77 = vrsqrte_f32((float32x2_t)LODWORD(v74));
        float32x2_t v78 = vmul_f32(v77, vrsqrts_f32((float32x2_t)LODWORD(v76), vmul_f32(v77, v77)));
        float32x4_t v75 = vmulq_n_f32(v69, vmul_f32(v78, vrsqrts_f32((float32x2_t)LODWORD(v76), vmul_f32(v78, v78))).f32[0]);
      }
      *(_OWORD *)(a1 + 496) = *(_OWORD *)(a1 + 448);
      *(float32x4_t *)(a1 + 448) = vdivq_f32(vmulq_n_f32(v75, v71), v48);
    }
    float32x4_t v79 = vdivq_f32(vsubq_f32(*v5, v91), v48);
    float32x4_t v80 = vmulq_f32(v79, v79);
    if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 2), vaddq_f32(v80, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 1))).f32[0]) > 0.008)
    {
      float32x4_t v81 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(a1 + 464), _Q7), v93, v79);
      *(_OWORD *)(a1 + 512) = *(_OWORD *)(a1 + 464);
      *(float32x4_t *)(a1 + 464) = v81;
    }
  }
}

__n128 re::DynamicOffsetF::endInteraction(float32x4_t *this, float a2)
{
  __asm
  {
    FMOV            V1.4S, #0.25
    FMOV            V4.4S, #0.75
  }
  if (!_ZF) {
    this[27] = vmlaq_f32(vmulq_f32(this[30], _Q1), _Q4, this[27]);
  }
  if (this[31].f32[0] != 3.4028e38) {
    this[28] = vmlaq_f32(vmulq_f32(this[31], _Q1), _Q4, this[28]);
  }
  if (this[32].f32[0] != 3.4028e38) {
    this[29] = vmlaq_f32(vmulq_f32(this[32], _Q1), _Q4, this[29]);
  }
  this[3] = vaddq_f32(*this, vmulq_n_f32(this[27], a2));
  float32x4_t v9 = this + 3;
  float32x4_t v10 = this[28];
  float32x4_t v11 = vmulq_f32(v10, v10);
  int32x2_t v12 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u64[0];
  *(float *)v12.i32 = sqrtf(*(float *)v12.i32);
  if (*(float *)v12.i32 == 0.0)
  {
    this[4] = this[1];
  }
  else
  {
    float32x4_t v13 = vdivq_f32(v10, (float32x4_t)vdupq_lane_s32(v12, 0));
    float v30 = a2;
    float v14 = *(float *)v12.i32 * a2;
    float32x4_t v15 = vmulq_f32(v13, v13);
    LODWORD(v16) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).u32[0];
    if (fabsf(v16) >= 1.0e-10)
    {
      float v17 = v16;
      float32x2_t v18 = vrsqrte_f32((float32x2_t)LODWORD(v16));
      float32x2_t v19 = vmul_f32(v18, vrsqrts_f32((float32x2_t)LODWORD(v17), vmul_f32(v18, v18)));
      float32x4_t v13 = vmulq_n_f32(v13, vmul_f32(v19, vrsqrts_f32((float32x2_t)LODWORD(v17), vmul_f32(v19, v19))).f32[0]);
    }
    float32x4_t v29 = v13;
    __float2 v21 = __sincosf_stret(v14 * 0.5);
    _S1 = v21.__cosval;
    *(float32x2_t *)_Q2.f32 = vmul_n_f32(*(float32x2_t *)v29.f32, v21.__sinval);
    _Q2.i32[2] = vmuls_lane_f32(v21.__sinval, v29, 2);
    _Q0 = this[1];
    int8x16_t v24 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL), vnegq_f32(_Q2)), _Q0, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL));
    float32x4_t v25 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL), _Q0, v21.__cosval), _Q2, _Q0, 3);
    __asm { FMLA            S2, S1, V0.S[3] }
    v25.i32[3] = _Q2.i32[0];
    this[4] = v25;
    a2 = v30;
  }
  float32x4_t v26 = *v9;
  float32x4_t v27 = this[4];
  this[5] = vaddq_f32(this[2], vmulq_n_f32(this[29], a2));
  this[6] = v26;
  __n128 result = (__n128)this[5];
  this[7] = v27;
  this[8] = (float32x4_t)result;
  this[33].i8[0] = 0;
  return result;
}

float re::computeSVD3x3(float32x2_t *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, double *a5, double *a6, double *a7)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  *(float64x2_t *)__a = vcvtq_f64_f32(*a1);
  double v10 = a1[1].f32[0];
  float64x2_t v36 = vcvtq_f64_f32(a1[2]);
  double v11 = a1[3].f32[0];
  double v35 = v10;
  double v37 = v11;
  float64x2_t v38 = vcvtq_f64_f32(a1[4]);
  double v39 = a1[5].f32[0];
  {
    *(float32x2_t *)&long long v13 = vcvt_f32_f64(*(float64x2_t *)__u);
    *(float *)&unsigned int v14 = v29;
    *((void *)&v13 + 1) = __PAIR64__(HIDWORD(__u[1]), v14);
    *(float32x2_t *)&long long v15 = vcvt_f32_f64(v30);
    *(float *)&unsigned int v16 = v31;
    *((void *)&v15 + 1) = __PAIR64__(HIDWORD(v30.f64[1]), v16);
    *(float32x2_t *)&long long v17 = vcvt_f32_f64(v32);
    *(float *)&unsigned int v18 = v33;
    *((void *)&v17 + 1) = __PAIR64__(HIDWORD(v32.f64[1]), v18);
    *a2 = v13;
    a2[1] = v15;
    a2[2] = v17;
    *(float32x2_t *)&long long v15 = vcvt_f32_f64(v22);
    *(float *)&long long v13 = v23;
    *((void *)&v15 + 1) = __PAIR64__(HIDWORD(v22.f64[1]), v13);
    *(float32x2_t *)&long long v19 = vcvt_f32_f64(v24);
    *(float *)&long long v13 = v25;
    *((void *)&v19 + 1) = __PAIR64__(HIDWORD(v24.f64[1]), v13);
    *a4 = v15;
    a4[1] = v19;
    *(float32x2_t *)&long long v15 = vcvt_f32_f64(v26);
    *(float *)&long long v13 = v27;
    *((void *)&v15 + 1) = __PAIR64__(HIDWORD(v26.f64[1]), v13);
    a4[2] = v15;
    *(float32x2_t *)&long long v15 = vcvt_f32_f64(v20);
    float result = v21;
    *((void *)&v15 + 1) = __PAIR64__(HIDWORD(v20.f64[1]), LODWORD(result));
    *a3 = v15;
  }
  return result;
}

BOOL re::anonymous namespace'::computeSVD(__CLPK_doublereal *__a, __CLPK_doublereal *__u, __CLPK_doublereal *__s, double *a4, double *a5, double *a6, double *a7)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  __uint64_t n = 3;
  __uint64_t m = 3;
  __CLPK_integer __ldu = 3;
  __CLPK_integer __lda = 3;
  __CLPK_integer v16 = 0;
  __CLPK_integer __ldvt = 3;
  double v15 = 0.0;
  HIDWORD(__lwork) = -1;
  uint64_t v11 = dgesvd_("All", "All", &__m, &__n, __a, &__lda, __s, __u, &__ldu, a4, &__ldvt, &v15, (__CLPK_integer *)&__lwork + 1, &v16);
  HIDWORD(__lwork) = (int)v15;
  MEMORY[0x270FA5388](v11);
  dgesvd_("All", "All", &__m, &__n, __a, &__lda, __s, __u, &__ldu, a4, &__ldvt, (__CLPK_doublereal *)((char *)&__lwork - v12), (__CLPK_integer *)&__lwork + 1, &v16);
  return v16 == 0;
}

void re::OPackReader::Buffer::~Buffer(re::OPackReader::Buffer *this)
{
  uint64_t v2 = *(void *)this;
  if (*(re::OPackReader::Buffer **)this != (re::OPackReader::Buffer *)((char *)this + 32))
  {
    if (v2)
    {
      unint64_t v3 = re::globalAllocators(this);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3[2] + 40))(v3[2], v2);
    }
    *(void *)this = 0;
  }
}

uint64_t re::OPackReader::Buffer::resize(re::OPackReader::Buffer *this, unint64_t a2)
{
  if (*((void *)this + 2) - *(void *)this > a2) {
    return 1;
  }
  if (*((void *)this + 3) < a2) {
    return 0;
  }
  float v5 = re::globalAllocators(this);
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v5[2] + 32))(v5[2], a2, 0);
  if (result)
  {
    uint64_t v6 = result;
    float32x4_t v8 = *(re::OPackReader::Buffer **)this;
    uint64_t v7 = *((void *)this + 1);
    uint64_t v9 = v7 - *(void *)this;
    if (v7 != *(void *)this) {
      uint64_t result = (uint64_t)memcpy((void *)result, *(const void **)this, v7 - *(void *)this);
    }
    if (v8 != (re::OPackReader::Buffer *)((char *)this + 32))
    {
      if (v8)
      {
        double v10 = re::globalAllocators((re *)result);
        (*(void (**)(uint64_t, re::OPackReader::Buffer *))(*(void *)v10[2] + 40))(v10[2], v8);
      }
    }
    *(void *)this = v6;
    *((void *)this + 1) = v6 + v9;
    *((void *)this + 2) = v6 + a2;
    return 1;
  }
  return result;
}

uint64_t re::OPackReader::OPackReader(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 128;
  *(_DWORD *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = &unk_26E716178;
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 16re::InputManager::notify(8, 0, 0, 0) = a1 + 96;
  *(void *)(a1 + 168) = a1 + 96;
  *(void *)(a1 + 176) = a1 + 160;
  *(unsigned char *)(a1 + 184) = 0;
  *(void *)(a1 + 188) = 0;
  *(void *)(a1 + 20re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 24re::InputManager::notify(8, 0, 0, 0) = a1 + 272;
  *(void *)(a1 + 248) = a1 + 272;
  unint64_t v3 = (_anonymous_namespace_ *)(a1 + 336);
  *(void *)(a1 + 256) = a1 + 336;
  *(void *)(a1 + 264) = -1;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = 0;
  *(_DWORD *)(a1 + 36re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 196) = 0;
  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a1 + 336), 0x80uLL);
  v5.n128_u16[0] = 0;
  v5.n128_u64[1] = 0;
  uint64_t v6 = 0;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v3, &v5);
  return a1;
}

uint64_t re::OPackReader::next(re::OPackReader *this, uint64_t a2)
{
  if (*((unsigned char *)this + 2))
  {
    *((unsigned char *)this + 2) = 0;
    return 1;
  }
  else if (*((unsigned char *)this + 1) || *(unsigned char *)this)
  {
    return 0;
  }
  else
  {
    switch(*(unsigned char *)(*((void *)this + 46) + 24 * *((void *)this + 44) - 24))
    {
      case 0:
        int Object = re::OPackReader::readObject(this, 0);
        uint64_t result = 0;
        if (Object)
        {
          uint64_t result = 1;
          if (*((void *)this + 44) == 1) {
            *(unsigned char *)this = 1;
          }
        }
        break;
      case 1:
        uint64_t result = re::OPackReader::readArray(this);
        break;
      case 2:
        uint64_t result = re::OPackReader::readDictionary(this);
        break;
      case 3:
        uint64_t result = re::OPackReader::readChunkedData(this);
        break;
      case 5:
        uint64_t result = re::OPackReader::readExtArrayDelta(this);
        break;
      case 6:
        uint64_t result = 0;
        *((unsigned char *)this + 1) = 1;
        *((void *)this + 1) = "unimplemented";
        break;
      case 7:
        uint64_t result = re::OPackReader::readExtDictionaryDelta(this);
        break;
      default:
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "next", 158);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D9C0B0);
    }
  }
  return result;
}

uint64_t re::OPackReader::readObject(re::OPackReader *this, int a2)
{
  float v4 = (_DWORD *)((char *)this + 24);
  __n128 v5 = (_DWORD *)((char *)this + 192);
  uint64_t result = re::zerocopy::OPackTokenizer::readToken((_DWORD *)this + 6, (uint64_t)this + 192);
  if (!result) {
    return result;
  }
  if (!v7 & v6)
  {
    uint64_t result = 0;
    *((unsigned char *)this + 1) = 1;
    uint64_t v11 = "unhandled container type";
    goto LABEL_39;
  }
  switch(*((unsigned char *)this + 196))
  {
    case 0xC:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 1u, *((void *)this + 25));
      if (result)
      {
        char v9 = 2;
        goto LABEL_20;
      }
      return result;
    case 0xD:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 2u, *((void *)this + 25));
      if (result)
      {
        char v9 = 4;
        goto LABEL_20;
      }
      return result;
    case 0xE:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 3u, *((void *)this + 25));
      if (result)
      {
        char v9 = 6;
        goto LABEL_20;
      }
      return result;
    case 0xF:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 5u, *((void *)this + 25));
      if (result)
      {
        char v9 = 8;
        goto LABEL_20;
      }
      return result;
    case 0x10:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 7u, *((void *)this + 25));
      if (result)
      {
        char v9 = 10;
LABEL_20:
        *((unsigned char *)this + 184) = v9;
        goto LABEL_21;
      }
      return result;
    case 0x11:
      uint64_t result = re::OPackReader::beginState((uint64_t)this, 6u, *((void *)this + 25));
      if (result)
      {
        *((unsigned char *)this + 184) = 6;
LABEL_21:
        *((_DWORD *)this + 47) = a2;
        return 1;
      }
      return result;
    default:
      if ((*((unsigned char *)this + 196) & 0xFE) != 0xA) {
        goto LABEL_8;
      }
      unint64_t v10 = *((void *)this + 25);
      if (v10 == *((void *)this + 27)) {
        goto LABEL_8;
      }
      if (*((void *)this + 33) < v10) {
        goto LABEL_10;
      }
      *((void *)this + 31) = *((void *)this + 30);
      if (v10 == -1 || (re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v10) & 1) != 0)
      {
        char v12 = 1;
        while (*v5 == 2)
        {
          if ((v12 & 1) != 0
            && (unsigned int v14 = (const void *)*((void *)this + 26),
                size_t v13 = *((void *)this + 27),
                re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v13 + *((void *)this + 31) - *((void *)this + 30))))
          {
            memcpy(*((void **)this + 31), v14, v13);
            *((void *)this + 31) += v13;
            char v12 = 1;
          }
          else
          {
            char v12 = 0;
          }
          if ((re::zerocopy::OPackTokenizer::readToken(v4, (uint64_t)v5) & 1) == 0)
          {
            uint64_t result = 0;
            *((unsigned char *)this + 1) = 1;
            uint64_t v11 = "unable to read next chunk";
            goto LABEL_39;
          }
        }
        if (*v5 == 3)
        {
          if (v12)
          {
            __CLPK_integer v16 = (const void *)*((void *)this + 26);
            size_t v15 = *((void *)this + 27);
            if (re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v15 + *((void *)this + 31) - *((void *)this + 30)))
            {
              memcpy(*((void **)this + 31), v16, v15);
              size_t v17 = *((void *)this + 31) + v15;
              *((void *)this + 31) = v17;
              goto LABEL_43;
            }
          }
        }
        else if (v12)
        {
          size_t v17 = *((void *)this + 31);
LABEL_43:
          uint64_t v18 = *((void *)this + 30);
          *((void *)this + 26) = v18;
          *((void *)this + 27) = v17 - v18;
LABEL_8:
          uint64_t result = 1;
          *((unsigned char *)this + 184) = 1;
          *((_DWORD *)this + 47) = a2;
          return result;
        }
LABEL_10:
        uint64_t result = 0;
        *((unsigned char *)this + 1) = 1;
        uint64_t v11 = "multipart buffer exceeded maximum data length";
        goto LABEL_39;
      }
      uint64_t result = 0;
      *((unsigned char *)this + 1) = 1;
      uint64_t v11 = "out of memory when allocating multipart buffer";
LABEL_39:
      *((void *)this + 1) = v11;
      return result;
  }
}

uint64_t re::OPackReader::readArray(re::OPackReader *this)
{
  uint64_t v2 = *((void *)this + 46);
  uint64_t v3 = *((void *)this + 44) - 1;
  if (!*(unsigned char *)(v2 + 24 * v3 + 1))
  {
    uint64_t result = re::OPackReader::readObject(this, 1);
    if (!result) {
      return result;
    }
    if (*((unsigned char *)this + 196) != 1) {
      return 1;
    }
    uint64_t v9 = *((void *)this + 44) - 1;
    *((void *)this + 44) = v9;
    ++*((_DWORD *)this + 90);
    if (v9 == 1) {
      *(unsigned char *)this = 1;
    }
LABEL_12:
    *((unsigned char *)this + 184) = 3;
    *((_DWORD *)this + 47) = 0;
    return 1;
  }
  uint64_t v4 = v2 + 24 * v3;
  uint64_t v7 = *(void *)(v4 + 8);
  __n128 v5 = (void *)(v4 + 8);
  uint64_t v6 = v7;
  if (!v7)
  {
    *((_DWORD *)this + 48) = 1;
    *((unsigned char *)this + 196) = 1;
    *((void *)this + 44) = v3;
    ++*((_DWORD *)this + 90);
    if (v3 == 1) {
      *(unsigned char *)this = 1;
    }
    goto LABEL_12;
  }
  *__n128 v5 = v6 - 1;
  return re::OPackReader::readObject(this, 1);
}

uint64_t re::OPackReader::readDictionary(re::OPackReader *this)
{
  uint64_t v2 = *((void *)this + 46);
  uint64_t v3 = *((void *)this + 44) - 1;
  uint64_t v4 = v2 + 24 * v3;
  uint64_t v7 = *(void *)(v4 + 16);
  __n128 v5 = (void *)(v4 + 16);
  uint64_t v6 = v7;
  if (!*((unsigned char *)v5 - 15))
  {
    if (!v6)
    {
      *__n128 v5 = 1;
      return re::OPackReader::readDictionaryEntry((uint64_t)this, 2, 0, 5, 0);
    }
LABEL_6:
    *__n128 v5 = 0;
    int v12 = 4;
LABEL_7:
    uint64_t result = re::OPackReader::readObject(this, v12);
    if (result)
    {
      uint64_t result = 1;
      if (*((unsigned char *)this + 196) == 1)
      {
        *((unsigned char *)this + 1) = 1;
        *((void *)this + 1) = "unexpected terminator when reading dictionary entry";
        return 0;
      }
    }
    return result;
  }
  if (v6) {
    goto LABEL_6;
  }
  uint64_t v8 = v2 + 24 * v3;
  uint64_t v11 = *(void *)(v8 + 8);
  uint64_t v9 = (void *)(v8 + 8);
  uint64_t v10 = v11;
  if (v11)
  {
    *uint64_t v9 = v10 - 1;
    *__n128 v5 = 1;
    int v12 = 2;
    goto LABEL_7;
  }
  *((_DWORD *)this + 48) = 1;
  *((unsigned char *)this + 196) = 1;
  *((void *)this + 44) = v3;
  ++*((_DWORD *)this + 90);
  if (v3 == 1) {
    *(unsigned char *)this = 1;
  }
  *((unsigned char *)this + 184) = 5;
  *((_DWORD *)this + 47) = 0;
  return 1;
}

uint64_t re::OPackReader::readChunkedData(re::OPackReader *this)
{
  uint64_t result = re::OPackReader::readObject(this, 8);
  if (result)
  {
    int v3 = *((unsigned __int8 *)this + 196);
    if (v3 == 11)
    {
      uint64_t result = 1;
      *((unsigned char *)this + 184) = 1;
      *((_DWORD *)this + 47) = 8;
    }
    else if (v3 == 1)
    {
      uint64_t v4 = *((void *)this + 44) - 1;
      *((void *)this + 44) = v4;
      ++*((_DWORD *)this + 90);
      if (v4 == 1) {
        *(unsigned char *)this = 1;
      }
      *((unsigned char *)this + 184) = 6;
      *((_DWORD *)this + 47) = 0;
      return 1;
    }
    else
    {
      uint64_t result = 0;
      *((unsigned char *)this + 1) = 1;
      *((void *)this + 1) = "unexpected token reading chunked data";
    }
  }
  return result;
}

uint64_t re::OPackReader::readExtArrayDelta(re::OPackReader *this)
{
  uint64_t v2 = *((void *)this + 46) + 24 * *((void *)this + 44);
  uint64_t v5 = *(void *)(v2 - 8);
  uint64_t v4 = (void *)(v2 - 8);
  uint64_t v3 = v5;
  if (v5 == 1)
  {
    uint64_t result = re::OPackReader::readObject(this, 32);
    if (result)
    {
      if (*((unsigned char *)this + 196) == 1)
      {
        uint64_t v7 = *((void *)this + 44) - 1;
        *((void *)this + 44) = v7;
        ++*((_DWORD *)this + 90);
        if (v7 == 1) {
          *(unsigned char *)this = 1;
        }
        *((unsigned char *)this + 184) = 9;
        *((_DWORD *)this + 47) = 0;
      }
      else
      {
        *uint64_t v4 = 0;
      }
      return 1;
    }
  }
  else
  {
    if (v3) {
      return 0;
    }
    uint64_t result = re::OPackReader::readObject(this, 16);
    if (!result) {
      return result;
    }
    if (*((unsigned char *)this + 196) != 6)
    {
      return 0;
    }
    else
    {
      uint64_t result = 1;
      *uint64_t v4 = 1;
    }
  }
  return result;
}

uint64_t re::OPackReader::readExtDictionaryDelta(re::OPackReader *this)
{
  uint64_t v2 = *((void *)this + 46) + 24 * *((void *)this + 44);
  uint64_t v4 = *(void *)(v2 - 8);
  uint64_t v3 = (void *)(v2 - 8);
  if (v4)
  {
    *uint64_t v3 = 0;
    uint64_t result = re::OPackReader::readObject(this, 132);
    if (result)
    {
      uint64_t result = 1;
      if (*((unsigned char *)this + 196) == 1)
      {
        *((unsigned char *)this + 184) = 1;
        *((_DWORD *)this + 47) = 132;
      }
    }
  }
  else
  {
    *uint64_t v3 = 1;
    return re::OPackReader::readDictionaryEntry((uint64_t)this, 66, 0, 11, 0);
  }
  return result;
}

BOOL re::OPackReader::beginState(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 352);
  unint64_t v4 = *(int *)(a1 + 16);
  if (v3 >= v4)
  {
    *(unsigned char *)(a1 + 1) = 1;
    *(void *)(a1 + 8) = "max depth exceeded";
  }
  else
  {
    v6.n128_u8[0] = a2;
    v6.n128_u8[1] = a3 != -1;
    v6.n128_u64[1] = a3;
    uint64_t v7 = 0;
    re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)(a1 + 336), &v6);
  }
  return v3 < v4;
}

uint64_t re::OPackReader::readDictionaryEntry(uint64_t a1, int a2, uint64_t a3, char a4, int a5)
{
  uint64_t result = re::OPackReader::readObject((re::OPackReader *)a1, a2);
  if (result)
  {
    if (*(unsigned char *)(a1 + 196) == 1)
    {
      if (a5)
      {
        if (a5 == 2)
        {
          uint64_t result = 1;
          *(unsigned char *)(a1 + 184) = 1;
          *(_DWORD *)(a1 + 188) = a2;
          return result;
        }
        if (a5 == 1)
        {
          uint64_t result = 0;
          *(unsigned char *)(a1 + 1) = 1;
          *(void *)(a1 + 8) = "unexpected terminator when reading dictionary entry";
          return result;
        }
      }
      else
      {
        uint64_t v10 = *(void *)(a1 + 352) - 1;
        *(void *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = v10;
        ++*(_DWORD *)(a1 + 360);
        if (v10 == 1) {
          *(unsigned char *)a1 = 1;
        }
        *(unsigned char *)(a1 + 184) = a4;
        *(_DWORD *)(a1 + 188) = 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readToken(_DWORD *a1, uint64_t a2)
{
  switch(*a1)
  {
    case 0:
      uint64_t result = re::zerocopy::OPackTokenizer::readTag((uint64_t)a1, a2);
      break;
    case 1:
      uint64_t result = re::zerocopy::OPackTokenizer::readPrimitive((uint64_t)a1, a2);
      break;
    case 2:
      uint64_t result = re::zerocopy::OPackTokenizer::readLengthPrefixed((uint64_t)a1, a2);
      break;
    case 3:
      uint64_t result = re::zerocopy::OPackTokenizer::readChunks((uint64_t)a1, a2);
      break;
    case 4:
      uint64_t result = re::zerocopy::OPackTokenizer::readNullTerminated((uint64_t)a1, a2);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readTag(uint64_t a1, uint64_t a2)
{
  unsigned __int8 __dst = 0;
  if ((re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), (char *)1, v23) & 1) == 0)
  {
    uint64_t result = 0;
    *(_DWORD *)a2 = 0;
    goto LABEL_5;
  }
  memcpy(&__dst, v23[0], (size_t)v23[1]);
  int v4 = __dst;
  switch(__dst)
  {
    case 0u:
      uint64_t result = 1;
      *(_DWORD *)a2 = 1;
      *(unsigned char *)(a2 + 4) = 0;
      goto LABEL_14;
    case 1u:
      uint64_t result = 1;
      *(unsigned char *)(a2 + 32) = 1;
      goto LABEL_10;
    case 2u:
      *(unsigned char *)(a2 + 32) = 0;
      uint64_t result = 1;
LABEL_10:
      *(_DWORD *)a2 = 1;
      char v6 = 2;
      goto LABEL_13;
    case 3u:
      uint64_t result = 1;
      *(_DWORD *)a2 = 1;
      *(unsigned char *)(a2 + 4) = 1;
      goto LABEL_14;
    case 4u:
      uint64_t result = 1;
      *(_DWORD *)a2 = 1;
      char v6 = 3;
      goto LABEL_13;
    case 5u:
      *(_DWORD *)a1 = 1;
      *(unsigned char *)(a1 + 4) = 4;
      unint64_t v7 = 16;
      goto LABEL_19;
    case 6u:
      *(_DWORD *)a1 = 1;
      char v8 = 5;
LABEL_18:
      *(unsigned char *)(a1 + 4) = v8;
      unint64_t v7 = 8;
LABEL_19:
      *(int64x2_t *)(a1 + 8) = vdupq_n_s64(v7);
      return re::zerocopy::OPackTokenizer::readPrimitive(a1, a2);
    default:
      if (__dst - 7 <= 0x28)
      {
        *(void *)(a2 + 32) = __dst - 8;
        uint64_t result = 1;
        *(_DWORD *)a2 = 1;
        char v6 = 6;
LABEL_13:
        *(unsigned char *)(a2 + 4) = v6;
LABEL_14:
        *(_DWORD *)a1 = 0;
        return result;
      }
      break;
  }
  switch(__dst)
  {
    case '0':
      unint64_t v7 = 1;
      *(_DWORD *)a1 = 1;
      char v9 = 6;
LABEL_24:
      *(unsigned char *)(a1 + 4) = v9;
      goto LABEL_19;
    case '1':
      *(_DWORD *)a1 = 1;
      char v10 = 6;
LABEL_26:
      *(unsigned char *)(a1 + 4) = v10;
      unint64_t v7 = 2;
      goto LABEL_19;
    case '2':
      *(_DWORD *)a1 = 1;
      char v11 = 6;
      goto LABEL_36;
    case '3':
      *(_DWORD *)a1 = 1;
      char v8 = 6;
      goto LABEL_18;
    case '5':
      *(_DWORD *)a1 = 1;
      char v11 = 7;
LABEL_36:
      *(unsigned char *)(a1 + 4) = v11;
      unint64_t v7 = 4;
      goto LABEL_19;
    case '6':
      *(_DWORD *)a1 = 1;
      unint64_t v7 = 8;
      *(unsigned char *)(a1 + 4) = 8;
      goto LABEL_19;
    default:
      if (__dst - 64 > 0x20)
      {
        switch(__dst)
        {
          case 'a':
            *(_DWORD *)a1 = 2;
            char v15 = 10;
LABEL_40:
            *(unsigned char *)(a1 + 4) = v15;
            uint64_t v16 = 1;
            goto LABEL_52;
          case 'b':
            uint64_t v16 = 2;
            *(_DWORD *)a1 = 2;
            char v17 = 10;
LABEL_47:
            *(unsigned char *)(a1 + 4) = v17;
            goto LABEL_52;
          case 'c':
            *(_DWORD *)a1 = 2;
            char v18 = 10;
LABEL_49:
            *(unsigned char *)(a1 + 4) = v18;
            uint64_t v16 = 4;
            goto LABEL_52;
          case 'd':
            *(_DWORD *)a1 = 2;
            char v19 = 10;
LABEL_51:
            *(unsigned char *)(a1 + 4) = v19;
            uint64_t v16 = 8;
LABEL_52:
            *(void *)(a1 + 8) = v16;
            return re::zerocopy::OPackTokenizer::readLengthPrefixed(a1, a2);
          default:
            if (__dst == 111)
            {
              *(_DWORD *)a1 = 4;
              *(unsigned char *)(a1 + 4) = 10;
              *(void *)(a1 + 8) = 0;
              *(void *)(a1 + 16) = 0;
              return re::zerocopy::OPackTokenizer::readNullTerminated(a1, a2);
            }
            if (__dst - 112 <= 0x20)
            {
              *(_DWORD *)a1 = 3;
              char v12 = 11;
              *(unsigned char *)(a1 + 4) = 11;
              uint64_t v14 = (v4 - 112);
              BOOL v13 = v14 == 0;
              goto LABEL_31;
            }
            switch(__dst)
            {
              case 0x91u:
                *(_DWORD *)a1 = 2;
                char v15 = 11;
                goto LABEL_40;
              case 0x92u:
                uint64_t v16 = 2;
                *(_DWORD *)a1 = 2;
                char v17 = 11;
                goto LABEL_47;
              case 0x93u:
                *(_DWORD *)a1 = 2;
                char v18 = 11;
                goto LABEL_49;
              case 0x94u:
                *(_DWORD *)a1 = 2;
                char v19 = 11;
                goto LABEL_51;
              default:
                if (__dst == 159)
                {
                  *(void *)(a2 + 8) = -1;
                  uint64_t result = 1;
                  *(_DWORD *)a2 = 1;
                  char v6 = 14;
                  goto LABEL_13;
                }
                if ((__dst + 96) <= 0x20u)
                {
                  *(_DWORD *)(a2 + 32) = __dst - 160;
                  uint64_t result = 1;
                  *(_DWORD *)a2 = 1;
                  char v6 = 9;
                  goto LABEL_13;
                }
                break;
            }
            break;
        }
        switch(__dst)
        {
          case 0xC1u:
            unint64_t v7 = 1;
            *(_DWORD *)a1 = 1;
            char v9 = 9;
            goto LABEL_24;
          case 0xC2u:
            *(_DWORD *)a1 = 1;
            char v10 = 9;
            goto LABEL_26;
          case 0xC3u:
            *(_DWORD *)a1 = 1;
            *(unsigned char *)(a1 + 4) = 9;
            unint64_t v7 = 3;
            goto LABEL_19;
          case 0xC4u:
            *(_DWORD *)a1 = 1;
            char v11 = 9;
            goto LABEL_36;
          default:
            if ((__dst + 48) <= 0xEu)
            {
              uint64_t v20 = __dst - 208;
LABEL_75:
              *(void *)(a2 + 8) = v20;
              uint64_t result = 1;
              *(_DWORD *)a2 = 1;
              char v6 = 12;
              goto LABEL_13;
            }
            if (__dst == 223)
            {
              uint64_t v20 = -1;
              goto LABEL_75;
            }
            if ((__dst + 32) <= 0xEu)
            {
              uint64_t v21 = __dst - 224;
LABEL_80:
              *(void *)(a2 + 8) = v21;
              uint64_t result = 1;
              *(_DWORD *)a2 = 1;
              char v6 = 13;
              goto LABEL_13;
            }
            if (__dst == 239)
            {
              uint64_t v21 = -1;
              goto LABEL_80;
            }
            if (__dst == 240 && *(unsigned char *)(a1 + 24))
            {
              *(void *)(a2 + 8) = -1;
              uint64_t result = 1;
              *(_DWORD *)a2 = 1;
              char v6 = 15;
              goto LABEL_13;
            }
            if (__dst == 241 && *(unsigned char *)(a1 + 24))
            {
              *(void *)(a2 + 8) = -1;
              uint64_t result = 1;
              *(_DWORD *)a2 = 1;
              char v6 = 16;
              goto LABEL_13;
            }
            if (__dst == 242 && *(unsigned char *)(a1 + 24))
            {
              *(void *)(a2 + 8) = -1;
              uint64_t result = 1;
              *(_DWORD *)a2 = 1;
              char v6 = 17;
              goto LABEL_13;
            }
            if (*(_DWORD *)a1 != 5) {
              *(_DWORD *)a1 = 5;
            }
            uint64_t result = 0;
            *(_DWORD *)a2 = 4;
            break;
        }
LABEL_5:
        *(unsigned char *)(a2 + 4) = 0;
        return result;
      }
      *(_DWORD *)a1 = 3;
      char v12 = 10;
      *(unsigned char *)(a1 + 4) = 10;
      uint64_t v14 = (v4 - 64);
      BOOL v13 = v14 == 0;
LABEL_31:
      *(void *)(a1 + 8) = v14;
      *(void *)(a1 + 16) = v14;
      if (v13)
      {
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        *(void *)(a2 + 24) = 0;
        *(_DWORD *)a2 = 3;
        *(unsigned char *)(a2 + 4) = v12;
        uint64_t result = 1;
        goto LABEL_14;
      }
      return re::zerocopy::OPackTokenizer::readChunks(a1, a2);
  }
}

uint64_t re::zerocopy::OPackTokenizer::readPrimitive(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), *(char **)(a1 + 8), v5);
  if (result) {
    return re::zerocopy::OPackTokenizer::endPrimitive(a1, a2, v5);
  }
  *(_DWORD *)a2 = 0;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readLengthPrefixed(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), *(char **)(a1 + 8), v5);
  if (result) {
    return re::zerocopy::OPackTokenizer::endLengthPrefixed(a1, a2, *(unsigned char *)(a1 + 4), v5);
  }
  *(_DWORD *)a2 = 0;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readChunks(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::zerocopy::BufferedReadStream::boundedRead(a1 + 32, *(void *)(a1 + 16), (uint64_t)&v8);
  if (result)
  {
    uint64_t v6 = v8;
    uint64_t v5 = v9;
    uint64_t v7 = *(void *)(a1 + 16) - v9;
    *(void *)(a1 + 16) = v7;
    *(void *)(a2 + 16) = v6;
    *(void *)(a2 + 24) = v5;
    *(void *)(a2 + 8) = *(void *)(a1 + 8);
    if (v7)
    {
      *(_DWORD *)a2 = 2;
      *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 4);
    }
    else
    {
      *(_DWORD *)a2 = 3;
      *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 4);
      *(_DWORD *)a1 = 0;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(unsigned char *)(a2 + 4) = 0;
  }
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readNullTerminated(uint64_t a1, uint64_t a2)
{
  int v4 = (re::zerocopy::BufferedReadStream *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 136);
  uint64_t v5 = *(void *)(a1 + 144);
  if (v6 == v5)
  {
    uint64_t v7 = *(void *)(a1 + 56);
    if (!v7)
    {
      uint64_t result = re::zerocopy::BufferedReadStream::nextFromStream((re::zerocopy::BufferedReadStream *)(a1 + 32));
      if (!result)
      {
        *(_DWORD *)a2 = 0;
        *(unsigned char *)(a2 + 4) = 0;
        return result;
      }
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v6 = *(void *)(a1 + 48);
  }
  else
  {
    uint64_t v7 = v5 - v6;
  }
  if (v7 < 1)
  {
LABEL_11:
    *(void *)(a2 + 24) = v7;
    *(void *)(a2 + 8) = *(void *)(a1 + 8);
    *(void *)(a2 + 16) = v6;
    *(_DWORD *)a2 = 2;
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 4);
  }
  else
  {
    uint64_t v9 = 0;
    while (*(unsigned char *)(v6 + v9))
    {
      ++v9;
      if (v6 + v9 >= (unint64_t)(v6 + v7)) {
        goto LABEL_11;
      }
    }
    re::zerocopy::BufferedReadStream::advanceRead(v4, v9 + 1);
    *(void *)(a2 + 24) = v9;
    *(void *)(a2 + 8) = *(void *)(a1 + 8);
    *(void *)(a2 + 16) = v6;
    *(_DWORD *)a2 = 3;
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 4);
    *(_DWORD *)a1 = 0;
  }
  return 1;
}

uint64_t re::zerocopy::OPackTokenizer::endLengthPrefixed(uint64_t a1, uint64_t a2, char a3, unsigned __int8 **a4)
{
  switch((unint64_t)a4[1])
  {
    case 1uLL:
      uint64_t v4 = **a4;
      goto LABEL_6;
    case 2uLL:
      uint64_t v4 = *(unsigned __int16 *)*a4;
      goto LABEL_6;
    case 4uLL:
      uint64_t v4 = *(unsigned int *)*a4;
      goto LABEL_6;
    case 8uLL:
      uint64_t v4 = *(void *)*a4;
LABEL_6:
      *(_DWORD *)a1 = 3;
      *(unsigned char *)(a1 + 4) = a3;
      *(void *)(a1 + 8) = v4;
      *(void *)(a1 + 16) = v4;
      if (v4) {
        return re::zerocopy::OPackTokenizer::readChunks(a1, a2);
      }
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 3;
      *(unsigned char *)(a2 + 4) = a3;
      uint64_t v6 = 1;
      *(_DWORD *)a1 = 0;
      return v6;
    default:
      if (*(_DWORD *)a1 != 5) {
        *(_DWORD *)a1 = 5;
      }
      uint64_t v6 = 0;
      *(_DWORD *)a2 = 4;
      *(unsigned char *)(a2 + 4) = 0;
      return v6;
  }
}

uint64_t re::zerocopy::OPackTokenizer::endPrimitive(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  switch(*(unsigned char *)(a1 + 4))
  {
    case 4:
      *(_OWORD *)(a2 + 32) = *(_OWORD *)*a3;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 4;
      goto LABEL_21;
    case 5:
      *(void *)(a2 + 32) = **a3;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 5;
      goto LABEL_21;
    case 6:
      uint64_t v5 = *a3;
      switch((unint64_t)a3[1])
      {
        case 1uLL:
          uint64_t v6 = *(char *)v5;
          break;
        case 2uLL:
          uint64_t v6 = *(__int16 *)v5;
          break;
        case 4uLL:
          uint64_t v6 = *(int *)v5;
          break;
        case 8uLL:
          uint64_t v6 = *v5;
          break;
        default:
          goto LABEL_10;
      }
      *(void *)(a2 + 32) = v6;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 6;
      goto LABEL_21;
    case 7:
      *(_DWORD *)(a2 + 32) = *(_DWORD *)*a3;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 7;
      goto LABEL_21;
    case 8:
      *(void *)(a2 + 32) = **a3;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 8;
      goto LABEL_21;
    case 9:
      uint64_t v7 = *a3;
      switch((unint64_t)a3[1])
      {
        case 1uLL:
          unint64_t v8 = *(unsigned __int8 *)v7;
          break;
        case 2uLL:
          unint64_t v8 = *(unsigned __int16 *)v7;
          break;
        case 3uLL:
          unint64_t v8 = *(unsigned __int16 *)v7 | ((unint64_t)*((unsigned __int8 *)v7 + 2) << 16);
          break;
        case 4uLL:
          unint64_t v8 = *(unsigned int *)v7;
          break;
        default:
          goto LABEL_10;
      }
      *(void *)(a2 + 32) = v8;
      uint64_t v3 = 1;
      *(_DWORD *)a2 = 1;
      char v4 = 9;
LABEL_21:
      *(unsigned char *)(a2 + 4) = v4;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_10:
      if (*(_DWORD *)a1 != 5) {
        *(_DWORD *)a1 = 5;
      }
      uint64_t v3 = 0;
      *(_DWORD *)a2 = 4;
      *(unsigned char *)(a2 + 4) = 0;
      break;
  }
  return v3;
}

re::zerocopy::DispatchReadStream *re::zerocopy::DispatchReadStream::DispatchReadStream(re::zerocopy::DispatchReadStream *this, void *a2)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(void *)this = &unk_26E716070;
  *((void *)this + 25) = (char *)this + 8;
  *((_OWORD *)this + 13) = xmmword_2343C0850;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 4re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 12re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  dispatch_data_apply_f();
  return this;
}

void re::zerocopy::DispatchReadStream::~DispatchReadStream(NSObject *this)
{
  uint64_t v1 = this;
  this->isa = (Class)&unk_26E716070;
  isa = this[25].isa;
  if (isa != (re::zerocopy::DispatchReadStream *)&this[1])
  {
    Class v3 = this[26].isa;
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < (unint64_t)v3; ++i)
      {
        Class v6 = v1[25].isa;
        this = *(NSObject **)((char *)v6 + v4);
        if (this)
        {
          dispatch_release(this);
          *(void *)((char *)v6 + v4) = 0;
          Class v3 = v1[26].isa;
        }
        v4 += 24;
      }
      isa = v1[25].isa;
    }
    if (isa)
    {
      uint64_t v7 = re::globalAllocators((re *)this);
      (*(void (**)(uint64_t, re::zerocopy::DispatchReadStream *))(*(void *)v7[2] + 40))(v7[2], isa);
    }
    v1[25].isa = 0;
  }
  for (uint64_t j = 22; j != -2; j -= 3)
  {
    uint64_t v9 = v1[j].isa;
    if (v9)
    {
      dispatch_release(v9);
      v1[j].isa = 0;
    }
  }
}

{
  uint64_t vars8;

  re::zerocopy::DispatchReadStream::~DispatchReadStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::zerocopy::DispatchReadStream::nextRead(void *a1, void *a2)
{
  unint64_t v2 = a1[28];
  unint64_t v3 = a1[26];
  if (v2 < v3)
  {
    unint64_t v4 = a1[29];
    uint64_t v5 = a1[25];
    unint64_t v6 = *(void *)(v5 + 24 * v2 + 16);
    if (v4 < v6)
    {
LABEL_5:
      *a2 = *(void *)(v5 + 24 * v2 + 8) + v4;
      a2[1] = v6 - v4;
      return 1;
    }
    a1[28] = ++v2;
    a1[29] = 0;
    if (v2 < v3)
    {
      unint64_t v4 = 0;
      unint64_t v6 = *(void *)(v5 + 24 * v2 + 16);
      goto LABEL_5;
    }
  }
  return 0;
}

void *re::zerocopy::DispatchReadStream::advanceRead(void *this, unint64_t a2)
{
  unint64_t v2 = this[28];
  if (v2 < this[26])
  {
    uint64_t v3 = this[29];
    unint64_t v4 = *(void *)(this[25] + 24 * v2 + 16) - v3;
    if (v4 >= a2) {
      unint64_t v4 = a2;
    }
    this[29] = v4 + v3;
  }
  return this;
}

uint64_t re::zerocopy::DispatchReadStream::DispatchReadStream(void *)::$_0::__invoke(re *a1, dispatch_object_t object, uint64_t a3, objc_class *a4, objc_class *a5)
{
  unint64_t v9 = *((void *)a1 + 26);
  if (v9 == *((void *)a1 + 27))
  {
    uint64_t v10 = 2 * v9;
    uint64_t v11 = 48 * v9;
    char v12 = re::globalAllocators(a1);
    BOOL v13 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v12[2] + 32))(v12[2], v11, 0);
    uint64_t v14 = v13;
    unint64_t v9 = *((void *)a1 + 26);
    if (v9)
    {
      uint64_t v15 = 0;
      for (unint64_t i = 0; i < v9; ++i)
      {
        char v17 = &v13[v15];
        uint64_t v18 = *((void *)a1 + 25) + v15 * 8;
        *(_OWORD *)&v17->isa = *(_OWORD *)v18;
        v17[2].isa = *(Class *)(v18 + 16);
        *(void *)uint64_t v18 = 0;
        *(void *)(v18 + 8) = 0;
        *(void *)(v18 + 16) = 0;
        unint64_t v9 = *((void *)a1 + 26);
        v15 += 3;
      }
      char v19 = (void *)*((void *)a1 + 25);
      if (v19 != (void *)((char *)a1 + 8))
      {
        if (v9)
        {
          uint64_t v20 = 0;
          for (unint64_t j = 0; j < v9; ++j)
          {
            uint64_t v22 = *((void *)a1 + 25);
            BOOL v13 = *(NSObject **)(v22 + v20);
            if (v13)
            {
              dispatch_release(v13);
              *(void *)(v22 + v2re::InputManager::notify(8, 0, 0, 0) = 0;
              unint64_t v9 = *((void *)a1 + 26);
            }
            v20 += 24;
          }
          char v19 = (void *)*((void *)a1 + 25);
        }
        goto LABEL_14;
      }
    }
    else
    {
      char v19 = (void *)*((void *)a1 + 25);
      if (v19 != (void *)((char *)a1 + 8))
      {
LABEL_14:
        if (v19)
        {
          double v23 = re::globalAllocators((re *)v13);
          (*(void (**)(uint64_t, void *))(*(void *)v23[2] + 40))(v23[2], v19);
          unint64_t v9 = *((void *)a1 + 26);
        }
      }
    }
    *((void *)a1 + 25) = v14;
    *((void *)a1 + 27) = v10;
    goto LABEL_17;
  }
  uint64_t v14 = *((void *)a1 + 25);
LABEL_17:
  *((void *)a1 + 26) = v9 + 1;
  float64x2_t v24 = &v14[3 * v9];
  dispatch_retain(object);
  v24->isa = (Class)object;
  v24[1].isa = a4;
  v24[2].isa = a5;
  return 1;
}

void re::zerocopy::FileWriteStream::~FileWriteStream(re::zerocopy::FileWriteStream *this)
{
  *(void *)this = &unk_26E7160C8;
  unint64_t v2 = (FILE *)*((void *)this + 1);
  if (v2 && *((unsigned char *)this + 16)) {
    fclose(v2);
  }
  *((void *)this + 1) = 0;
}

{
  uint64_t vars8;

  re::zerocopy::FileWriteStream::~FileWriteStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::zerocopy::FileWriteStream::nextWrite(uint64_t a1, void *a2)
{
  *a2 = a1 + 17;
  a2[1] = 4096;
  return 1;
}

size_t re::zerocopy::FileWriteStream::advanceWrite(size_t this, unint64_t a2)
{
  unint64_t v2 = *(FILE **)(this + 8);
  if (v2)
  {
    if (a2 >= 0x1000) {
      size_t v3 = 4096;
    }
    else {
      size_t v3 = a2;
    }
    return fwrite((const void *)(this + 17), 1uLL, v3, v2);
  }
  return this;
}

BOOL re::zerocopy::FileWriteStream::flushWrite(FILE **this)
{
  return fflush(this[1]) == 0;
}

uint64_t re::OPackWriter::writeInteger(re::zerocopy **this, uint64_t a2)
{
  uint64_t v8 = a2;
  if ((unint64_t)(a2 + 1) > 0x28)
  {
    if (a2 != (char)a2)
    {
      LOBYTE(v7) = 51;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v7, (char *)1);
      size_t v3 = *this;
      unint64_t v4 = (re::zerocopy::WriteStream *)&v8;
      uint64_t v5 = 8;
      return re::zerocopy::writeAll(v3, v4, (char *)v5);
    }
    char v9 = a2;
    LOBYTE(v7) = 48;
    re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v7, (char *)1);
    size_t v3 = *this;
    unint64_t v4 = (re::zerocopy::WriteStream *)&v9;
  }
  else
  {
    LOBYTE(v7) = a2 + 8;
    size_t v3 = *this;
    unint64_t v4 = (re::zerocopy::WriteStream *)&v7;
  }
  uint64_t v5 = 1;
  return re::zerocopy::writeAll(v3, v4, (char *)v5);
}

uint64_t re::OPackWriter::writeFloat64(re::zerocopy **this, double a2)
{
  double v4 = a2;
  char v5 = 54;
  re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v5, (char *)1);
  return re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v4, (char *)8);
}

uint64_t re::OPackWriter::writeString(re::zerocopy **this, re::zerocopy::WriteStream *a2, unint64_t a3)
{
  if (a3 >= 0x21)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = 97;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = a3;
      int v7 = *this;
      uint64_t v8 = 1;
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = 100;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
        unint64_t v10 = a3;
        int v7 = *this;
        uint64_t v8 = 8;
      }
      else
      {
        LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = 99;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = a3;
        int v7 = *this;
        uint64_t v8 = 4;
      }
    }
    else
    {
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = 98;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
      LOWORD(v1re::InputManager::notify(8, 0, 0, 0) = a3;
      int v7 = *this;
      uint64_t v8 = 2;
    }
    re::zerocopy::writeAll(v7, (re::zerocopy::WriteStream *)&v10, (char *)v8);
  }
  else
  {
    LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = a3 + 64;
    uint64_t result = re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
    if (!a3) {
      return result;
    }
  }
  char v9 = *this;
  return re::zerocopy::writeAll(v9, a2, (char *)a3);
}

uint64_t re::OPackWriter::writeData(re::zerocopy **this, re::zerocopy::WriteStream *a2, unint64_t a3)
{
  if (a3 >= 0x21)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = -111;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = a3;
      int v7 = *this;
      uint64_t v8 = 1;
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = -108;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
        unint64_t v10 = a3;
        int v7 = *this;
        uint64_t v8 = 8;
      }
      else
      {
        LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = -109;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = a3;
        int v7 = *this;
        uint64_t v8 = 4;
      }
    }
    else
    {
      LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = -110;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
      LOWORD(v1re::InputManager::notify(8, 0, 0, 0) = a3;
      int v7 = *this;
      uint64_t v8 = 2;
    }
    re::zerocopy::writeAll(v7, (re::zerocopy::WriteStream *)&v10, (char *)v8);
  }
  else
  {
    LOBYTE(v1re::InputManager::notify(8, 0, 0, 0) = a3 + 112;
    uint64_t result = re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v10, (char *)1);
    if (!a3) {
      return result;
    }
  }
  char v9 = *this;
  return re::zerocopy::writeAll(v9, a2, (char *)a3);
}

uint64_t re::OPackWriter::writeArrayBegin(re::zerocopy **this, unint64_t a2)
{
  if (a2 > 0xE)
  {
    char v6 = -33;
    unint64_t v2 = *this;
    size_t v3 = (re::zerocopy::WriteStream *)&v6;
  }
  else
  {
    char v5 = a2 - 48;
    unint64_t v2 = *this;
    size_t v3 = (re::zerocopy::WriteStream *)&v5;
  }
  return re::zerocopy::writeAll(v2, v3, (char *)1);
}

uint64_t re::OPackWriter::writeDictionaryBegin(re::zerocopy **this, unint64_t a2)
{
  if (a2 > 0xE)
  {
    char v6 = -17;
    unint64_t v2 = *this;
    size_t v3 = (re::zerocopy::WriteStream *)&v6;
  }
  else
  {
    char v5 = a2 - 32;
    unint64_t v2 = *this;
    size_t v3 = (re::zerocopy::WriteStream *)&v5;
  }
  return re::zerocopy::writeAll(v2, v3, (char *)1);
}

uint64_t re::zerocopy::DynamicWriteStream::nextWrite(uint64_t a1, void *a2)
{
  double v4 = *(void **)(a1 + 8);
  uint64_t v6 = v4[1];
  uint64_t v5 = v4[2];
  if (v5 == v6)
  {
    unint64_t v7 = 2 * v5;
    if (v7 <= 0x40) {
      unint64_t v8 = 64;
    }
    else {
      unint64_t v8 = v7;
    }
    re::DynamicArray<BOOL>::setCapacity(v4, v8);
    double v4 = *(void **)(a1 + 8);
    uint64_t v6 = v4[1];
    uint64_t v5 = v4[2];
  }
  *a2 = v4[4] + v5;
  a2[1] = v6 - v5;
  return 1;
}

void *re::zerocopy::DynamicWriteStream::advanceWrite(re::zerocopy::DynamicWriteStream *this, unint64_t a2)
{
  unint64_t v2 = (void *)*((void *)this + 1);
  uint64_t v3 = v2[2];
  unint64_t v4 = v2[1] - v3;
  if (v4 >= a2) {
    unint64_t v4 = a2;
  }
  return re::DynamicArray<unsigned char>::resizeUninitialized(v2, v4 + v3);
}

void re::zerocopy::DynamicWriteStream::~DynamicWriteStream(re::zerocopy::DynamicWriteStream *this)
{
}

uint64_t re::zerocopy::WriteStream::flushWrite(re::zerocopy::WriteStream *this)
{
  return 1;
}

uint64_t re::zerocopy::writeAll(re::zerocopy *this, re::zerocopy::WriteStream *a2, char *a3)
{
  char v9 = 0;
  unint64_t v10 = 0;
  if (!a3) {
    return 1;
  }
  uint64_t v3 = a3;
  do
  {
    uint64_t v6 = (*(uint64_t (**)(re::zerocopy *, void **))(*(void *)this + 16))(this, &v9);
    if (!v6) {
      break;
    }
    size_t v7 = (size_t)(v3 >= v10 ? v10 : v3);
    memcpy(v9, a2, v7);
    (*(void (**)(re::zerocopy *, size_t))(*(void *)this + 24))(this, v7);
    a2 = (re::zerocopy::WriteStream *)((char *)a2 + v7);
    v3 -= v7;
  }
  while (v3);
  return v6;
}

void re::zerocopy::BufferedReadStream::~BufferedReadStream(re::zerocopy::BufferedReadStream *this)
{
  uint64_t v1 = this;
  *(void *)this = &unk_26E716178;
  if (*((void *)this + 4))
  {
    this = (re::zerocopy::BufferedReadStream *)(*(uint64_t (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
    *((void *)v1 + 4) = 0;
  }
  unint64_t v2 = (re::zerocopy::BufferedReadStream *)*((void *)v1 + 13);
  if (v2 != (re::zerocopy::BufferedReadStream *)((char *)v1 + 40) && v2 != 0)
  {
    unint64_t v4 = re::globalAllocators(this);
    (*(void (**)(uint64_t, re::zerocopy::BufferedReadStream *))(*(void *)v4[2] + 40))(v4[2], v2);
  }
  *((void *)v1 + 13) = 0;
  *((void *)v1 + 14) = 0;
  *((void *)v1 + 15) = 0;
}

{
  uint64_t vars8;

  re::zerocopy::BufferedReadStream::~BufferedReadStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::zerocopy::BufferedReadStream::contiguousRead(re::zerocopy::BufferedReadStream *this, char *a2, void *a3)
{
  if (*((void *)this + 13) != *((void *)this + 14)) {
    goto LABEL_2;
  }
  unint64_t v8 = *((void *)this + 3);
  if (!v8)
  {
    uint64_t result = re::zerocopy::BufferedReadStream::nextFromStream(this);
    if (!result) {
      return result;
    }
    unint64_t v8 = *((void *)this + 3);
  }
  if (v8 >= (unint64_t)a2)
  {
    a3[1] = a2;
    unint64_t v9 = *((void *)this + 3);
    *a3 = *((void *)this + 2);
    if (v9 >= (unint64_t)a2) {
      unint64_t v10 = (unint64_t)a2;
    }
    else {
      unint64_t v10 = v9;
    }
    *((void *)this + 2) += v10;
    *((void *)this + 3) = v9 - v10;
    *((void *)this + 4) += v10;
  }
  else
  {
LABEL_2:
    uint64_t result = re::zerocopy::BufferedReadStream::fillInternal(this, a2);
    if (!result) {
      return result;
    }
    uint64_t v7 = *((void *)this + 13);
    *a3 = v7;
    a3[1] = a2;
    *((void *)this + 14) = v7;
  }
  return 1;
}

uint64_t re::zerocopy::BufferedReadStream::nextFromStream(re::zerocopy::BufferedReadStream *this)
{
  if (*((void *)this + 4))
  {
    (*(void (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
    *((void *)this + 4) = 0;
  }
  unint64_t v2 = *(uint64_t (**)(void))(**((void **)this + 1) + 16);
  return v2();
}

uint64_t re::zerocopy::BufferedReadStream::fillInternal(re::zerocopy::BufferedReadStream *this, char *a2)
{
  uint64_t v3 = (char *)*((void *)this + 14);
  uint64_t v4 = *((void *)this + 13);
  if (&v3[-v4] < a2)
  {
    size_t v6 = *((void *)this + 3);
    do
    {
      if (!v6)
      {
        uint64_t result = re::zerocopy::BufferedReadStream::nextFromStream(this);
        if (!result) {
          return result;
        }
        uint64_t v4 = *((void *)this + 13);
        uint64_t v3 = (char *)*((void *)this + 14);
        size_t v6 = *((void *)this + 3);
      }
      size_t v8 = &a2[v4] - v3;
      if (v8 >= v6) {
        size_t v9 = v6;
      }
      else {
        size_t v9 = v8;
      }
      memcpy(v3, *((const void **)this + 2), v9);
      size_t v10 = *((void *)this + 3);
      if (v10 >= v9) {
        size_t v11 = v9;
      }
      else {
        size_t v11 = *((void *)this + 3);
      }
      size_t v6 = v10 - v11;
      *((void *)this + 2) += v11;
      *((void *)this + 3) = v6;
      *((void *)this + 4) += v11;
      uint64_t v4 = *((void *)this + 13);
      uint64_t v3 = (char *)(*((void *)this + 14) + v9);
      *((void *)this + 14) = v3;
    }
    while (&v3[-v4] < a2);
  }
  return 1;
}

uint64_t re::zerocopy::BufferedReadStream::boundedRead(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16))(a1, a3);
  if (v6)
  {
    if (*(void *)(a3 + 8) >= a2) {
      unint64_t v7 = a2;
    }
    else {
      unint64_t v7 = *(void *)(a3 + 8);
    }
    *(void *)(a3 + 8) = v7;
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  }
  return v6;
}

uint64_t re::zerocopy::BufferedReadStream::nextRead(re::zerocopy::BufferedReadStream *this, void *a2)
{
  uint64_t v3 = *((void *)this + 13);
  uint64_t v4 = *((void *)this + 14);
  if (v3 != v4)
  {
    *a2 = v3;
    a2[1] = v4 - v3;
    return 1;
  }
  if (*((void *)this + 3) || (uint64_t result = re::zerocopy::BufferedReadStream::nextFromStream(this), result))
  {
    *(_OWORD *)a2 = *((_OWORD *)this + 1);
    return 1;
  }
  return result;
}

char *re::zerocopy::BufferedReadStream::advanceRead(re::zerocopy::BufferedReadStream *this, unint64_t a2)
{
  uint64_t result = (char *)*((void *)this + 13);
  uint64_t v4 = (char *)*((void *)this + 14);
  if (result == v4)
  {
    unint64_t v7 = *((void *)this + 3);
    if (v7 >= a2) {
      unint64_t v8 = a2;
    }
    else {
      unint64_t v8 = *((void *)this + 3);
    }
    *((void *)this + 2) += v8;
    *((void *)this + 3) = v7 - v8;
    *((void *)this + 4) += v8;
  }
  else
  {
    unint64_t v5 = v4 - result;
    size_t v6 = v5 - a2;
    if (v5 > a2)
    {
      memmove(result, &result[a2], v6);
      uint64_t result = (char *)(*((void *)this + 13) + v6);
    }
    *((void *)this + 14) = result;
  }
  return result;
}

__n128 re::TransferStats::aggregate(__n128 *a1, __n128 *a2)
{
  if (a2->n128_u32[0])
  {
    if (a1->n128_u32[0])
    {
      unsigned __int32 v2 = a1->n128_u32[2];
      int v3 = a1->n128_u32[1] + a2->n128_u32[1];
      a1->n128_u32[0] += a2->n128_u32[0];
      a1->n128_u32[1] = v3;
      unsigned __int32 v4 = a2->n128_u32[2];
      if (v4 >= v2) {
        unsigned __int32 v4 = v2;
      }
      a1->n128_u32[2] = v4;
      unsigned __int32 v5 = a1->n128_u32[3];
      if (v5 <= a2->n128_u32[3]) {
        unsigned __int32 v5 = a2->n128_u32[3];
      }
      a1->n128_u32[3] = v5;
    }
    else
    {
      __n128 result = *a2;
      *a1 = *a2;
    }
  }
  return result;
}

_DWORD *re::PeerTransferReport::addEntry(_DWORD *this, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  unint64_t v24 = a2;
  if (a5)
  {
    uint64_t v8 = a2;
    size_t v9 = this;
    uint64_t v10 = (uint64_t)(this + 2);
    size_t v11 = (_DWORD *)re::HashTable<re::ecs2::Entity const*,re::ecs2::ShadowPlaneTrackingState,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)(this + 2), a2);
    if (v11)
    {
      if (*v11)
      {
        unsigned int v12 = v11[2];
        unsigned int v13 = v11[1] + a5;
        ++*v11;
        v11[1] = v13;
        if (a5 >= v12) {
          unsigned int v14 = v12;
        }
        else {
          unsigned int v14 = a5;
        }
        unsigned int v15 = v11[3];
        if (v15 <= a5) {
          unsigned int v15 = a5;
        }
        void v11[2] = v14;
        v11[3] = v15;
      }
      else
      {
        _DWORD *v11 = 1;
        v11[1] = a5;
        void v11[2] = a5;
        v11[3] = a5;
      }
    }
    else
    {
      LODWORD(v22) = 1;
      DWORD1(v22) = a5;
      DWORD2(v22) = a5;
      HIDWORD(v22) = a5;
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v10, (uint64_t *)&v24, &v22);
      uint64_t v8 = v24;
    }
    uint64_t v16 = (uint64_t)(v9 + 14);
    *(void *)&long long v22 = a3;
    *((void *)&v22 + 1) = a4;
    uint64_t v23 = v8;
    this = (_DWORD *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet(v16, &v22);
    if (this)
    {
      if (*this)
      {
        unsigned int v17 = this[2];
        unsigned int v18 = this[1] + a5;
        ++*this;
        this[1] = v18;
        if (a5 >= v17) {
          unsigned int v19 = v17;
        }
        else {
          unsigned int v19 = a5;
        }
        unsigned int v20 = this[3];
        if (v20 <= a5) {
          unsigned int v20 = a5;
        }
        this[2] = v19;
        this[3] = v20;
      }
      else
      {
        *this = 1;
        this[1] = a5;
        this[2] = a5;
        this[3] = a5;
      }
    }
    else
    {
      *(void *)&long long v22 = a3;
      *((void *)&v22 + 1) = a4;
      uint64_t v23 = v8;
      LODWORD(v21) = 1;
      DWORD1(v21) = a5;
      DWORD2(v21) = a5;
      HIDWORD(v21) = a5;
      return (_DWORD *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew(v16, &v22, &v21);
    }
  }
  return this;
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 40 * v10 + 16) != v6)
  {
    LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 40 * v10;
  return v12 + 24;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet(uint64_t a1, void *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = a2[1];
  uint64_t v3 = a2[2];
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * ((((*a2 << 6)
                          + (*a2 >> 2)
                          - 0x61C8864680B583E9
                          + ((v3 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2)) ^ *a2)
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  while (*(void *)(v5 + 56 * v4 + 16) != *a2
       || *(void *)(v5 + 56 * v4 + 24) != v2
       || *(void *)(v5 + 56 * v4 + 32) != v3)
  {
    uint64_t v4 = *(_DWORD *)(v5 + 56 * v4 + 8) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v5 + 56 * v4 + 40;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew(uint64_t a1, long long *a2, _OWORD *a3)
{
  unint64_t v6 = *(void *)a2;
  unint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = *((void *)a2 + 2);
  unint64_t v9 = ((*(void *)a2 << 6)
      + (*(void *)a2 >> 2)
      - 0x61C8864680B583E9
      + ((v8 + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583E9) ^ v7)) ^ *(void *)a2;
  if (!*(void *)a1)
  {
    LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = 0;
    goto LABEL_10;
  }
  unint64_t v10 = v9 % *(unsigned int *)(a1 + 24);
  uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v10);
  if (v11 == 0x7FFFFFFF)
  {
LABEL_10:
    unsigned int v13 = re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, v10, v9, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 16) + 56 * v13;
    return v14 + 40;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  while (*(void *)(v12 + 56 * v11 + 16) != v6
       || *(void *)(v12 + 56 * v11 + 24) != v7
       || *(void *)(v12 + 56 * v11 + 32) != v8)
  {
    uint64_t v11 = *(_DWORD *)(v12 + 56 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF) {
      goto LABEL_10;
    }
  }
  uint64_t v14 = v12 + 56 * v11;
  return v14 + 40;
}

void re::PeerTransferReport::aggregate(re::PeerTransferReport *this, const re::PeerTransferReport *a2)
{
  uint64_t v4 = *((unsigned int *)a2 + 10);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*((void *)a2 + 3) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 10;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)a2 + 10);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    unint64_t v9 = (unint64_t *)((char *)this + 8);
    uint64_t v10 = *((void *)a2 + 3);
    float32x4_t v52 = (unint64_t *)((char *)this + 8);
    do
    {
      uint64_t v11 = v10 + 40 * v8;
      unint64_t v14 = *(void *)(v11 + 16);
      uint64_t v13 = v11 + 16;
      unint64_t v12 = v14;
      unsigned int v15 = (__n128 *)re::HashTable<re::ecs2::Entity const*,re::ecs2::ShadowPlaneTrackingState,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)v9, v14);
      if (v15)
      {
        re::TransferStats::aggregate(v15, (__n128 *)(v13 + 8));
      }
      else
      {
        unint64_t v16 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27));
        unint64_t v17 = v16 ^ (v16 >> 31);
        unint64_t v18 = *v9;
        if (!*v9
          || (unint64_t v18 = v17 % *((unsigned int *)this + 8),
              uint64_t v19 = *(unsigned int *)(*((void *)this + 2) + 4 * v18),
              v19 == 0x7FFFFFFF))
        {
LABEL_16:
          uint64_t v21 = *((unsigned int *)this + 11);
          if (v21 == 0x7FFFFFFF)
          {
            uint64_t v21 = *((unsigned int *)this + 10);
            int v22 = v21;
            if (v21 == *((_DWORD *)this + 8))
            {
              re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v52, 2 * *((_DWORD *)this + 9));
              unint64_t v18 = v17 % *((unsigned int *)this + 8);
              int v22 = *((_DWORD *)this + 10);
              unint64_t v12 = *(void *)v13;
            }
            *((_DWORD *)this + 1re::InputManager::notify(8, 0, 0, 0) = v22 + 1;
            uint64_t v23 = *((void *)this + 3);
            int v24 = *(_DWORD *)(v23 + 40 * v21 + 8);
          }
          else
          {
            uint64_t v23 = *((void *)this + 3);
            int v24 = *(_DWORD *)(v23 + 40 * v21 + 8);
            *((_DWORD *)this + 11) = v24 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v23 + 40 * v21 + 8) = v24 | 0x80000000;
          *(_DWORD *)(*((void *)this + 3) + 40 * v21 + 8) = *(_DWORD *)(*((void *)this + 3) + 40 * v21 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 2) + 4 * v18);
          *(void *)(*((void *)this + 3) + 40 * v21) = v17;
          *(void *)(*((void *)this + 3) + 40 * v21 + 16) = v12;
          *(_OWORD *)(*((void *)this + 3) + 40 * v21 + 24) = *(_OWORD *)(v13 + 8);
          *(_DWORD *)(*((void *)this + 2) + 4 * v18) = v21;
          ++*((_DWORD *)this + 9);
          ++*((_DWORD *)this + 12);
          unint64_t v9 = v52;
        }
        else
        {
          uint64_t v20 = *((void *)this + 3);
          while (*(void *)(v20 + 40 * v19 + 16) != v12)
          {
            LODWORD(v19) = *(_DWORD *)(v20 + 40 * v19 + 8) & 0x7FFFFFFF;
            if (v19 == 0x7FFFFFFF) {
              goto LABEL_16;
            }
          }
        }
      }
      uint64_t v10 = *((void *)a2 + 3);
      if (*((_DWORD *)a2 + 10) <= (v5 + 1)) {
        int v25 = v5 + 1;
      }
      else {
        int v25 = *((_DWORD *)a2 + 10);
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v25 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        int v26 = v8;
        if ((*(_DWORD *)(v10 + 40 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_29;
        }
      }
      int v26 = v25;
LABEL_29:
      LODWORD(v5) = v26;
    }
    while (v4 != v26);
  }
  uint64_t v53 = *((unsigned int *)a2 + 22);
  uint64_t v27 = 0;
  if (v53)
  {
    float v28 = (int *)(*((void *)a2 + 9) + 8);
    while (1)
    {
      int v29 = *v28;
      v28 += 14;
      if (v29 < 0) {
        break;
      }
      if (v53 == ++v27)
      {
        LODWORD(v27) = *((_DWORD *)a2 + 22);
        break;
      }
    }
  }
  if (v53 != v27)
  {
    uint64_t v30 = v27;
    double v31 = (unint64_t *)((char *)this + 56);
    uint64_t v32 = *((void *)a2 + 9);
    do
    {
      uint64_t v33 = v32 + 56 * v30;
      float v34 = (void *)(v33 + 16);
      double v35 = (__n128 *)(v33 + 40);
      float64x2_t v36 = (__n128 *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet((uint64_t)this + 56, (void *)(v33 + 16));
      if (v36)
      {
        re::TransferStats::aggregate(v36, v35);
      }
      else
      {
        uint64_t v37 = v32 + 56 * v30;
        unint64_t v38 = *(void *)(v37 + 24);
        uint64_t v39 = *(void *)(v37 + 32);
        unint64_t v40 = ((*v34 << 6)
             - 0x61C8864680B583E9
             + (*v34 >> 2)
             + ((v39 - 0x61C8864680B583E9 + (v38 << 6) + (v38 >> 2)) ^ v38)) ^ *v34;
        unint64_t v41 = *v31;
        if (!*v31
          || (unint64_t v41 = v40 % *((unsigned int *)this + 20),
              uint64_t v42 = *(unsigned int *)(*((void *)this + 8) + 4 * v41),
              v42 == 0x7FFFFFFF))
        {
LABEL_46:
          uint64_t v44 = *((unsigned int *)this + 23);
          if (v44 == 0x7FFFFFFF)
          {
            uint64_t v44 = *((unsigned int *)this + 22);
            int v45 = v44;
            if (v44 == *((_DWORD *)this + 20))
            {
              re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity((uint64_t)this + 56, 2 * *((_DWORD *)this + 21));
              unint64_t v41 = v40 % *((unsigned int *)this + 20);
              int v45 = *((_DWORD *)this + 22);
            }
            *((_DWORD *)this + 22) = v45 + 1;
            uint64_t v46 = *((void *)this + 9);
            int v47 = *(_DWORD *)(v46 + 56 * v44 + 8);
          }
          else
          {
            uint64_t v46 = *((void *)this + 9);
            int v47 = *(_DWORD *)(v46 + 56 * v44 + 8);
            *((_DWORD *)this + 23) = v47 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v46 + 56 * v44 + 8) = v47 | 0x80000000;
          *(_DWORD *)(*((void *)this + 9) + 56 * v44 + 8) = *(_DWORD *)(*((void *)this + 9) + 56 * v44 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 8) + 4 * v41);
          *(void *)(*((void *)this + 9) + 56 * v44) = v40;
          uint64_t v48 = *((void *)this + 9) + 56 * v44;
          long long v49 = *(_OWORD *)v34;
          *(void *)(v48 + 32) = v34[2];
          *(_OWORD *)(v48 + 16) = v49;
          *(__n128 *)(*((void *)this + 9) + 56 * v44 + 4re::InputManager::notify(8, 0, 0, 0) = *v35;
          *(_DWORD *)(*((void *)this + 8) + 4 * v41) = v44;
          ++*((_DWORD *)this + 21);
          ++*((_DWORD *)this + 24);
        }
        else
        {
          uint64_t v43 = *((void *)this + 9);
          while (*(void *)(v43 + 56 * v42 + 16) != *v34
               || *(void *)(v43 + 56 * v42 + 24) != v38
               || *(void *)(v43 + 56 * v42 + 32) != v39)
          {
            uint64_t v42 = *(_DWORD *)(v43 + 56 * v42 + 8) & 0x7FFFFFFF;
            if (v42 == 0x7FFFFFFF) {
              goto LABEL_46;
            }
          }
        }
      }
      unsigned int v50 = *((_DWORD *)a2 + 22);
      uint64_t v32 = *((void *)a2 + 9);
      if (v50 <= (int)v27 + 1) {
        unsigned int v50 = v27 + 1;
      }
      while (1)
      {
        uint64_t v30 = (v27 + 1);
        if (v50 - 1 == v27) {
          break;
        }
        LODWORD(v27) = v27 + 1;
        unsigned int v51 = v30;
        if ((*(_DWORD *)(v32 + 56 * v30 + 8) & 0x80000000) != 0) {
          goto LABEL_58;
        }
      }
      unsigned int v51 = v50;
LABEL_58:
      LODWORD(v27) = v51;
    }
    while (v53 != v51);
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 40 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 40;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

void re::SessionTransferReport::aggregate(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 48);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (int *)(*(void *)(a2 + 32) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 32;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *(_DWORD *)(a2 + 48);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 != v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = a1 + 16;
    uint64_t v9 = *(void *)(a2 + 32);
    do
    {
      uint64_t v10 = v9 + (v7 << 7);
      uint64_t v11 = (uint64_t *)(v10 + 16);
      unint64_t v12 = (const re::PeerTransferReport *)(v10 + 24);
      uint64_t v13 = (re::PeerTransferReport *)re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v8, (uint64_t *)(v10 + 16));
      if (v13) {
        re::PeerTransferReport::aggregate(v13, v12);
      }
      else {
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerTransferReport&>(v8, v11, v12);
      }
      uint64_t v9 = *(void *)(a2 + 32);
      if (*(_DWORD *)(a2 + 48) <= (v4 + 1)) {
        int v14 = v4 + 1;
      }
      else {
        int v14 = *(_DWORD *)(a2 + 48);
      }
      while (1)
      {
        uint64_t v7 = (v4 + 1);
        if (v14 - 1 == v4) {
          break;
        }
        LODWORD(v4) = v4 + 1;
        int v15 = v7;
        if ((*(_DWORD *)(v9 + (v7 << 7) + 8) & 0x80000000) != 0) {
          goto LABEL_19;
        }
      }
      int v15 = v14;
LABEL_19:
      LODWORD(v4) = v15;
    }
    while (v3 != v15);
  }
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerTransferReport&>(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)a1)
  {
    unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(a1 + 16);
      if (*(void *)(v11 + (v10 << 7) + 16) == v6)
      {
LABEL_6:
        uint64_t v12 = v11 + (v10 << 7);
        return v12 + 24;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v11 + (v10 << 7) + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + (v10 << 7) + 16) == v6) {
          goto LABEL_6;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 36);
  if (v13 == 0x7FFFFFFF)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 32);
    int v14 = v13;
    if (v13 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(a1 + 24);
      int v14 = *(_DWORD *)(a1 + 32);
      uint64_t v6 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v14 + 1;
    uint64_t v15 = *(void *)(a1 + 16);
    int v16 = *(_DWORD *)(v15 + (v13 << 7) + 8);
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 16);
    int v16 = *(_DWORD *)(v15 + (v13 << 7) + 8);
    *(_DWORD *)(a1 + 36) = v16 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v15 + (v13 << 7) + 8) = v16 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v13 << 7) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v13 << 7) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v9);
  *(void *)(*(void *)(a1 + 16) + (v13 << 7)) = v8;
  *(void *)(*(void *)(a1 + 16) + (v13 << 7) + 16) = v6;
  uint64_t v17 = *(void *)(a1 + 16) + (v13 << 7);
  *(void *)(v17 + 24) = *a3;
  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v17 + 32, (uint64_t)(a3 + 1));
  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(v17 + 80, (uint64_t)(a3 + 7));
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v9) = v13;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 16) + (v13 << 7);
  return v12 + 24;
}

void re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::EntryWithHash::free(*(void *)(a1 + 16) + v3);
        ++v4;
        v3 += 128;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v5;
  }
}

void re::TransferReport::aggregate(double *a1, uint64_t a2)
{
  double v2 = *(double *)a2;
  if (*(double *)a2 > 0.0 && v2 < *(double *)(a2 + 8))
  {
    double v5 = *a1;
    if (*a1 <= 0.0 || (double v6 = a1[1], v5 >= v6))
    {
      *(_OWORD *)a1 = *(_OWORD *)a2;
      uint64_t v12 = (uint64_t)(a1 + 2);
      uint64_t v13 = a2 + 16;
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::operator=(v12, v13);
    }
    else
    {
      if (v2 >= v5) {
        double v2 = *a1;
      }
      *a1 = v2;
      double v7 = *(double *)(a2 + 8);
      if (v6 >= v7) {
        double v7 = v6;
      }
      a1[1] = v7;
      uint64_t v8 = *(unsigned int *)(a2 + 48);
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = (int *)(*(void *)(a2 + 32) + 8);
        while (1)
        {
          int v11 = *v10;
          v10 += 22;
          if (v11 < 0) {
            break;
          }
          if (v8 == ++v9)
          {
            LODWORD(v9) = *(_DWORD *)(a2 + 48);
            break;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if (v8 != v9)
      {
        uint64_t v14 = v9;
        uint64_t v15 = (uint64_t)(a1 + 2);
        uint64_t v16 = *(void *)(a2 + 32);
        do
        {
          uint64_t v17 = v16 + 88 * v14;
          unint64_t v18 = (uint64_t *)(v17 + 16);
          uint64_t v19 = (uint64_t *)(v17 + 24);
          uint64_t v20 = re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(v15, (uint64_t *)(v17 + 16));
          if (v20) {
            re::SessionTransferReport::aggregate(v20, (uint64_t)v19);
          }
          else {
            re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew<re::SessionTransferReport&>(v15, v18, v19);
          }
          uint64_t v16 = *(void *)(a2 + 32);
          if (*(_DWORD *)(a2 + 48) <= (v9 + 1)) {
            int v21 = v9 + 1;
          }
          else {
            int v21 = *(_DWORD *)(a2 + 48);
          }
          while (1)
          {
            uint64_t v14 = (v9 + 1);
            if (v21 - 1 == v9) {
              break;
            }
            LODWORD(v9) = v9 + 1;
            int v22 = v14;
            if ((*(_DWORD *)(v16 + 88 * v14 + 8) & 0x80000000) != 0) {
              goto LABEL_33;
            }
          }
          int v22 = v21;
LABEL_33:
          LODWORD(v9) = v22;
        }
        while (v8 != v22);
      }
    }
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew<re::SessionTransferReport&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 88 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 88 * v10 + 16) != v6)
  {
    LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v11 + 88 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 88 * v10;
  return v12 + 24;
}

void re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(v6 + 40));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 88;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init(a1, v4, v5);
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (uint64_t *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 88;
    }
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 88 * v10;
  *(_DWORD *)(v12 + v14 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v14) = a3;
  *(void *)(*(void *)(a1 + 16) + v14 + 16) = *a4;
  uint64_t v15 = *(void *)(a1 + 16) + v14;
  uint64_t v16 = *a5;
  *(unsigned char *)(v15 + 32) = *((unsigned char *)a5 + 8);
  *(void *)(v15 + 24) = v16;
  re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v15 + 40, (uint64_t)(a5 + 2));
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (void *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 128;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 7) + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 7) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 7) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 7) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 7) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v10 << 7)) = a3;
  *(void *)(*(void *)(a1 + 16) + (v10 << 7) + 16) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + (v10 << 7);
  *(void *)(v14 + 24) = *a5;
  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v14 + 32, (uint64_t)(a5 + 1));
  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(v14 + 80, (uint64_t)(a5 + 7));
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  signed int v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      signed int v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_20, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (_OWORD *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 40;
    }
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 40 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 40 * v9 + 16) = *a4;
  *(_OWORD *)(*(void *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init(a1, v4, v5);
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  signed int v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      signed int v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_10, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (long long *)(v8 + 16), (_OWORD *)(v8 + 40));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 56 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 56;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 40);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, long long *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v9) = a3;
  uint64_t v13 = *(void *)(a1 + 16) + 56 * v9;
  long long v14 = *a4;
  *(void *)(v13 + 32) = *((void *)a4 + 2);
  *(_OWORD *)(v13 + 16) = v14;
  *(_OWORD *)(*(void *)(a1 + 16) + 56 * v9 + 4re::InputManager::notify(8, 0, 0, 0) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::zerocopy::MemoryReadStream::nextRead(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24) - v2;
  *a2 = v2;
  a2[1] = v3;
  return v3 != 0;
}

uint64_t re::zerocopy::MemoryReadStream::advanceRead(uint64_t this, unint64_t a2)
{
  uint64_t v2 = *(void *)(this + 16);
  unint64_t v3 = *(void *)(this + 24) - v2;
  if (v3 >= a2) {
    unint64_t v3 = a2;
  }
  *(void *)(this + 16) = v2 + v3;
  return this;
}

void re::zerocopy::MemoryReadStream::~MemoryReadStream(re::zerocopy::MemoryReadStream *this)
{
}

uint64_t re::TransferReportWriter::write(re::zerocopy ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  char v66 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v66, (char *)1);
  long long v5 = *a1;
  char v66 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v66, (char *)1);
  uint64_t v6 = *a1;
  char v66 = -30;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  char v66 = 8;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  re::OPackWriter::writeFloat64(v6, *(double *)a2);
  char v66 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  re::OPackWriter::writeFloat64(v6, *(double *)(a2 + 8));
  unsigned int v7 = *a1;
  char v66 = 9;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v66, (char *)1);
  long long v8 = *a1;
  uint64_t result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(a2 + 44));
  uint64_t v58 = *(unsigned int *)(a2 + 48);
  uint64_t v10 = 0;
  if (v58)
  {
    uint64_t v11 = (int *)(*(void *)(a2 + 32) + 8);
    while (1)
    {
      int v12 = *v11;
      v11 += 22;
      if (v12 < 0) {
        break;
      }
      if (v58 == ++v10)
      {
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(a2 + 48);
        break;
      }
    }
  }
  if (v58 != v10)
  {
    uint64_t v13 = v10;
    uint64_t v14 = *(void *)(a2 + 32);
    uint64_t v57 = a2;
    do
    {
      uint64_t v15 = v14 + 88 * v13;
      re::OPackWriter::writeInteger(v8, *(void *)(v15 + 16));
      char v66 = -29;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      char v66 = 8;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      re::OPackWriter::writeInteger(v8, *(void *)(v15 + 24));
      char v66 = 9;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      if (*(unsigned char *)(v15 + 32)) {
        char v16 = 1;
      }
      else {
        char v16 = 2;
      }
      char v66 = v16;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      char v66 = 10;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      uint64_t result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v15 + 68));
      unsigned int v17 = *(_DWORD *)(v15 + 72);
      float32x2_t v62 = (int *)(v15 + 72);
      uint64_t v63 = v17;
      float v59 = (_DWORD *)(v15 + 68);
      int v60 = v10;
      if (v17)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (int *)(*(void *)(v14 + 88 * v13 + 56) + 8);
        while (1)
        {
          int v20 = *v19;
          v19 += 32;
          if (v20 < 0) {
            break;
          }
          if (v63 == ++v18)
          {
            LODWORD(v18) = v63;
            break;
          }
        }
      }
      else
      {
        LODWORD(v18) = 0;
      }
      if (v63 != v18)
      {
        uint64_t v21 = v18;
        uint64_t v22 = v14 + 88 * v13;
        uint64_t v23 = *(void *)(v22 + 56);
        float32x2_t v61 = (uint64_t *)(v22 + 56);
        do
        {
          uint64_t v24 = v23 + (v21 << 7);
          re::OPackWriter::writeInteger(v8, *(void *)(v24 + 16));
          char v66 = -29;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          char v66 = 8;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          re::OPackWriter::writeInteger(v8, *(void *)(v24 + 24));
          char v66 = 9;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          int8x16_t v64 = (_DWORD *)(v24 + 60);
          re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v24 + 60));
          int v26 = (int *)(v24 + 64);
          uint64_t v25 = *(unsigned int *)(v24 + 64);
          uint64_t v65 = v23;
          uint64_t v27 = 0;
          if (v25)
          {
            float v28 = (int *)(*(void *)(v24 + 48) + 8);
            while (1)
            {
              int v29 = *v28;
              v28 += 10;
              if (v29 < 0) {
                break;
              }
              if (v25 == ++v27)
              {
                LODWORD(v27) = *(_DWORD *)(v24 + 64);
                break;
              }
            }
          }
          if (v25 != v27)
          {
            uint64_t v30 = v27;
            uint64_t v31 = v23 + (v21 << 7);
            uint64_t v34 = *(void *)(v31 + 48);
            uint64_t v33 = (uint64_t *)(v31 + 48);
            uint64_t v32 = v34;
            do
            {
              uint64_t v35 = v32 + 40 * v30;
              float64x2_t v36 = (unsigned int *)(v35 + 24);
              re::OPackWriter::writeInteger(v8, *(void *)(v35 + 16));
              uint64_t v32 = *v33;
              if (*v26 <= (v27 + 1)) {
                int v37 = v27 + 1;
              }
              else {
                int v37 = *v26;
              }
              int v38 = v27;
              while (1)
              {
                uint64_t v30 = (v38 + 1);
                if (v37 - 1 == v38) {
                  break;
                }
                ++v38;
                LODWORD(v27) = v30;
                if ((*(_DWORD *)(v32 + 40 * v30 + 8) & 0x80000000) != 0) {
                  goto LABEL_34;
                }
              }
              LODWORD(v27) = v37;
LABEL_34:
              ;
            }
            while (v25 != v27);
          }
          if (*v64 >= 0xFu)
          {
            char v66 = 3;
            re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          }
          char v66 = 10;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          uint64_t v39 = v65 + (v21 << 7);
          uint64_t result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v39 + 108));
          uint64_t v40 = *(unsigned int *)(v39 + 112);
          if (v40)
          {
            uint64_t v41 = 0;
            uint64_t v42 = (int *)(*(void *)(v39 + 96) + 8);
            while (1)
            {
              int v43 = *v42;
              v42 += 14;
              if (v43 < 0) {
                break;
              }
              if (v40 == ++v41)
              {
                LODWORD(v41) = *(_DWORD *)(v39 + 112);
                break;
              }
            }
          }
          else
          {
            LODWORD(v41) = 0;
          }
          if (v40 != v41)
          {
            uint64_t v44 = v41;
            uint64_t v45 = v65 + (v21 << 7);
            uint64_t v48 = *(void *)(v45 + 96);
            int v47 = (uint64_t *)(v45 + 96);
            uint64_t v46 = v48;
            do
            {
              uint64_t v49 = v46 + 56 * v44;
              char v66 = -45;
              re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
              re::OPackWriter::writeInteger(v8, *(void *)(v49 + 16));
              re::OPackWriter::writeInteger(v8, *(void *)(v49 + 24));
              re::OPackWriter::writeInteger(v8, *(void *)(v49 + 32));
              uint64_t v46 = *v47;
              if (*(_DWORD *)(v39 + 112) <= (v41 + 1)) {
                int v50 = v41 + 1;
              }
              else {
                int v50 = *(_DWORD *)(v39 + 112);
              }
              int v51 = v41;
              while (1)
              {
                uint64_t v44 = (v51 + 1);
                if (v50 - 1 == v51) {
                  break;
                }
                ++v51;
                LODWORD(v41) = v44;
                if ((*(_DWORD *)(v46 + 56 * v44 + 8) & 0x80000000) != 0) {
                  goto LABEL_53;
                }
              }
              LODWORD(v41) = v50;
LABEL_53:
              ;
            }
            while (v40 != v41);
          }
          if (*(_DWORD *)(v39 + 108) >= 0xFu)
          {
            char v66 = 3;
            uint64_t result = re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          }
          int v52 = *v62;
          uint64_t v23 = *v61;
          if (*v62 <= (v18 + 1)) {
            int v52 = v18 + 1;
          }
          while (1)
          {
            uint64_t v21 = (v18 + 1);
            if (v52 - 1 == v18) {
              break;
            }
            LODWORD(v18) = v18 + 1;
            int v53 = v21;
            if ((*(_DWORD *)(v23 + (v21 << 7) + 8) & 0x80000000) != 0) {
              goto LABEL_62;
            }
          }
          int v53 = v52;
LABEL_62:
          LODWORD(v18) = v53;
        }
        while (v63 != v53);
      }
      if (*v59 >= 0xFu)
      {
        char v66 = 3;
        uint64_t result = re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      }
      a2 = v57;
      unsigned int v54 = *(_DWORD *)(v57 + 48);
      uint64_t v14 = *(void *)(v57 + 32);
      int v55 = v60;
      if (v54 <= v60 + 1) {
        unsigned int v54 = v60 + 1;
      }
      while (1)
      {
        uint64_t v13 = (v55 + 1);
        if (v54 - 1 == v55) {
          break;
        }
        ++v55;
        unsigned int v56 = v13;
        if ((*(_DWORD *)(v14 + 88 * v13 + 8) & 0x80000000) != 0) {
          goto LABEL_71;
        }
      }
      unsigned int v56 = v54;
LABEL_71:
      LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v56;
    }
    while (v58 != v56);
  }
  if (*(_DWORD *)(a2 + 44) >= 0xFu)
  {
    char v66 = 3;
    return re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
  }
  return result;
}

uint64_t re::TransferReportReader::read(re::OPackReader **a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t result = re::OPackReader::next(*a1, (uint64_t)a2);
  if (result)
  {
    if (*((unsigned char *)v4 + 196) != 13) {
      return 0;
    }
    unsigned int v7 = *a1;
    if (!re::OPackReader::next(*a1, v6)) {
      return *((unsigned __int8 *)*a1 + 184) == 5;
    }
    while (1)
    {
      if (*((unsigned char *)v7 + 196) != 6) {
        return *((unsigned __int8 *)*a1 + 184) == 5;
      }
      if (*((unsigned char *)v7 + 224) == 1) {
        break;
      }
      if (!*((unsigned char *)v7 + 224))
      {
        uint64_t v9 = *a1;
        uint64_t result = re::OPackReader::next(*a1, v8);
        if (!result) {
          return result;
        }
        if (*((unsigned char *)v9 + 196) != 13) {
          return 0;
        }
        if (re::OPackReader::next(v9, v10))
        {
          while (*((unsigned char *)v9 + 196) == 6)
          {
            if (*((unsigned char *)v9 + 224) == 1)
            {
              uint64_t result = re::OPackReader::next(v9, v11);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v9 + 196) != 8) {
                return 0;
              }
              a2[1] = *((void *)v9 + 28);
            }
            else if (*((unsigned char *)v9 + 224))
            {
              re::OPackReader::next(v9, v11);
            }
            else
            {
              uint64_t result = re::OPackReader::next(v9, v11);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v9 + 196) != 8) {
                return 0;
              }
              *a2 = *((void *)v9 + 28);
            }
            if ((re::OPackReader::next(v9, v12) & 1) == 0) {
              break;
            }
          }
        }
LABEL_89:
        if (*((unsigned char *)v9 + 184) != 5) {
          return 0;
        }
        goto LABEL_92;
      }
      re::OPackReader::next(*a1, v8);
LABEL_92:
      unsigned int v7 = *a1;
      if ((re::OPackReader::next(*a1, v11) & 1) == 0) {
        return *((unsigned __int8 *)*a1 + 184) == 5;
      }
    }
    uint64_t v9 = *a1;
    uint64_t result = re::OPackReader::next(*a1, v8);
    if (!result) {
      return result;
    }
    if (*((unsigned char *)v9 + 196) != 13) {
      return 0;
    }
    uint64_t v14 = re::OPackReader::next(v9, v13);
    if (!v14) {
      goto LABEL_89;
    }
    while (1)
    {
      if (*((unsigned char *)v9 + 196) != 6) {
        goto LABEL_89;
      }
      uint64_t v15 = *((void *)v9 + 28);
      uint64_t v37 = 0;
      char v38 = 0;
      memset(v39, 0, sizeof(v39));
      int v40 = 0;
      uint64_t v41 = 0x7FFFFFFFLL;
      if (!re::OPackReader::next(v9, v16) || *((unsigned char *)v9 + 196) != 13) {
        goto LABEL_95;
      }
      if (re::OPackReader::next(v9, v17)) {
        break;
      }
LABEL_87:
      if (*((unsigned char *)v9 + 184) != 5)
      {
LABEL_95:
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v39);
        return 0;
      }
      *(void *)uint64_t v42 = v15;
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew((uint64_t)(a2 + 2), (uint64_t *)v42, &v37);
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v39);
      uint64_t v14 = re::OPackReader::next(v9, v36);
      if ((v14 & 1) == 0) {
        goto LABEL_89;
      }
    }
    while (1)
    {
      if (*((unsigned char *)v9 + 196) != 6) {
        goto LABEL_87;
      }
      int v19 = *((unsigned __int8 *)v9 + 224);
      if (v19 == 2) {
        break;
      }
      if (v19 == 1)
      {
        if (!re::OPackReader::next(v9, v18) || *((unsigned char *)v9 + 196) != 2) {
          goto LABEL_95;
        }
        char v38 = *((unsigned char *)v9 + 224);
      }
      else if (*((unsigned char *)v9 + 224))
      {
        re::OPackReader::next(v9, v18);
      }
      else
      {
        if (!re::OPackReader::next(v9, v18) || *((unsigned char *)v9 + 196) != 6) {
          goto LABEL_95;
        }
        uint64_t v37 = *((void *)v9 + 28);
      }
LABEL_86:
      if ((re::OPackReader::next(v9, v20) & 1) == 0) {
        goto LABEL_87;
      }
    }
    if (!re::OPackReader::next(v9, v18) || *((unsigned char *)v9 + 196) != 13) {
      goto LABEL_95;
    }
    uint64_t v47 = 0;
    uint64_t v22 = re::OPackReader::next(v9, v21);
    if (v22)
    {
      do
      {
        if (*((unsigned char *)v9 + 196) != 6) {
          break;
        }
        uint64_t v47 = *((void *)v9 + 28);
        memset(v42, 0, sizeof(v42));
        uint64_t v43 = 0x7FFFFFFFLL;
        memset(v44, 0, sizeof(v44));
        int v45 = 0;
        uint64_t v46 = 0x7FFFFFFFLL;
        if (!re::OPackReader::next(v9, v23) || *((unsigned char *)v9 + 196) != 13) {
          goto LABEL_94;
        }
        if (re::OPackReader::next(v9, v24))
        {
          while (1)
          {
            if (*((unsigned char *)v9 + 196) != 6) {
              goto LABEL_78;
            }
            int v26 = *((unsigned __int8 *)v9 + 224);
            if (v26 == 2) {
              break;
            }
            if (v26 == 1)
            {
              if (!re::OPackReader::next(v9, v25) || *((unsigned char *)v9 + 196) != 13) {
                goto LABEL_94;
              }
              *(void *)&long long v48 = 0;
              if (re::OPackReader::next(v9, v33))
              {
                do
                {
                  if (*((unsigned char *)v9 + 196) != 6) {
                    break;
                  }
                  *(void *)&long long v48 = *((void *)v9 + 28);
                  long long v49 = 0uLL;
                    goto LABEL_94;
                  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v42[8], (uint64_t *)&v48, &v49);
                }
                while ((re::OPackReader::next(v9, v34) & 1) != 0);
              }
LABEL_74:
              if (*((unsigned char *)v9 + 184) != 5) {
                goto LABEL_94;
              }
              goto LABEL_77;
            }
            if (*((unsigned char *)v9 + 224))
            {
              re::OPackReader::next(v9, v25);
            }
            else
            {
              if (!re::OPackReader::next(v9, v25) || *((unsigned char *)v9 + 196) != 6) {
                goto LABEL_94;
              }
              *(void *)uint64_t v42 = *((void *)v9 + 28);
            }
LABEL_77:
            if ((re::OPackReader::next(v9, v27) & 1) == 0) {
              goto LABEL_78;
            }
          }
          if (!re::OPackReader::next(v9, v25) || *((unsigned char *)v9 + 196) != 13) {
            goto LABEL_94;
          }
          if (re::OPackReader::next(v9, v28))
          {
            while (*((unsigned char *)v9 + 196) == 12)
            {
              long long v49 = 0uLL;
              uint64_t v50 = 0;
              if (re::OPackReader::next(v9, v27) && *((unsigned char *)v9 + 196) == 6) {
                *(void *)&long long v49 = *((void *)v9 + 28);
              }
              if (re::OPackReader::next(v9, v29) && *((unsigned char *)v9 + 196) == 6) {
                *((void *)&v49 + 1) = *((void *)v9 + 28);
              }
              if (re::OPackReader::next(v9, v30) && *((unsigned char *)v9 + 196) == 6) {
                uint64_t v50 = *((void *)v9 + 28);
              }
              if (!re::OPackReader::next(v9, v31)) {
                goto LABEL_94;
              }
              if (*((unsigned char *)v9 + 184) != 3) {
                goto LABEL_94;
              }
              long long v48 = 0uLL;
                goto LABEL_94;
              re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew((uint64_t)v44, &v49, &v48);
              if ((re::OPackReader::next(v9, v32) & 1) == 0) {
                goto LABEL_74;
              }
            }
          }
          goto LABEL_74;
        }
LABEL_78:
        if (*((unsigned char *)v9 + 184) != 5)
        {
LABEL_94:
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v44);
          re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v42[8]);
          goto LABEL_95;
        }
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v39, &v47, v42);
        re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v44);
        re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v42[8]);
        uint64_t v22 = re::OPackReader::next(v9, v35);
      }
      while ((v22 & 1) != 0);
    }
    if (*((unsigned char *)v9 + 184) != 5) {
      goto LABEL_95;
    }
    goto LABEL_86;
  }
  return result;
}

uint64_t re::anonymous namespace'::writeTransferStats(re::zerocopy **a1, unsigned int *a2)
{
  char v6 = -28;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v6, (char *)1);
  char v7 = 8;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v7, (char *)1);
  re::OPackWriter::writeInteger(a1, *a2);
  char v8 = 9;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v8, (char *)1);
  re::OPackWriter::writeInteger(a1, a2[1]);
  char v9 = 10;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v9, (char *)1);
  re::OPackWriter::writeInteger(a1, a2[2]);
  char v10 = 11;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v10, (char *)1);
  uint64_t v4 = a2[3];
  return re::OPackWriter::writeInteger(a1, v4);
}

BOOL re::anonymous namespace'::readTransferStats(uint64_t a1, _DWORD *a2)
{
  int v5 = re::OPackReader::next((re::OPackReader *)a1, (uint64_t)a2);
  BOOL result = 0;
  if (v5 && *(unsigned char *)(a1 + 196) == 13)
  {
    while (re::OPackReader::next((re::OPackReader *)a1, v4) && *(unsigned char *)(a1 + 196) == 6)
    {
      switch(*(unsigned char *)(a1 + 224))
      {
        case 0:
          int v8 = re::OPackReader::next((re::OPackReader *)a1, v7);
          BOOL result = 0;
          if (!v8 || *(unsigned char *)(a1 + 196) != 6) {
            return result;
          }
          *a2 = *(void *)(a1 + 224);
          break;
        case 1:
          int v9 = re::OPackReader::next((re::OPackReader *)a1, v7);
          BOOL result = 0;
          if (!v9 || *(unsigned char *)(a1 + 196) != 6) {
            return result;
          }
          a2[1] = *(void *)(a1 + 224);
          break;
        case 2:
          int v10 = re::OPackReader::next((re::OPackReader *)a1, v7);
          BOOL result = 0;
          if (!v10 || *(unsigned char *)(a1 + 196) != 6) {
            return result;
          }
          a2[2] = *(void *)(a1 + 224);
          break;
        case 3:
          int v11 = re::OPackReader::next((re::OPackReader *)a1, v7);
          BOOL result = 0;
          if (!v11 || *(unsigned char *)(a1 + 196) != 6) {
            return result;
          }
          a2[3] = *(void *)(a1 + 224);
          break;
        default:
          re::OPackReader::next((re::OPackReader *)a1, v7);
          continue;
      }
    }
    return *(unsigned char *)(a1 + 184) == 5;
  }
  return result;
}

void re::zerocopy::DispatchWriteStream::clear(re::zerocopy::DispatchWriteStream *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    dispatch_release(v2);
    *((void *)this + 1) = 0;
  }
  unint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + 2) = 0;
  }
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
}

void re::zerocopy::DispatchWriteStream::~DispatchWriteStream(re::zerocopy::DispatchWriteStream *this)
{
  *(void *)this = &unk_26E716208;
  re::zerocopy::DispatchWriteStream::clear(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E716208;
  re::zerocopy::DispatchWriteStream::clear(this);
  JUMPOUT(0x237DBCBD0);
}

void re::zerocopy::DispatchWriteStream::mergeTail(re::zerocopy::DispatchWriteStream *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    unint64_t v3 = (dispatch_object_t *)((char *)this + 16);
    subrange = dispatch_data_create_subrange(*((dispatch_data_t *)this + 2), 0, *((void *)this + 5) - v2);
    if (!*v3) {
      goto LABEL_6;
    }
    dispatch_release(*v3);
  }
  else
  {
    unint64_t v3 = (dispatch_object_t *)((char *)this + 16);
    subrange = *((void *)this + 2);
  }
  *unint64_t v3 = 0;
LABEL_6:
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  int v5 = *((void *)this + 1);
  if (v5)
  {
    dispatch_data_t concat = dispatch_data_create_concat(v5, subrange);
    dispatch_release(*((dispatch_object_t *)this + 1));
    *((void *)this + 1) = concat;
    dispatch_release(subrange);
  }
  else
  {
    *((void *)this + 1) = subrange;
  }
}

uint64_t re::zerocopy::DispatchWriteStream::nextWrite(re::zerocopy::DispatchWriteStream *this, void *a2)
{
  uint64_t v4 = *((void *)this + 4);
  if (!v4)
  {
    re::zerocopy::DispatchWriteStream::mergeTail(this);
    uint64_t v5 = (unint64_t)(2 * *((void *)this + 5)) <= 0x1000 ? 4096 : 2 * *((void *)this + 5);
    *((void *)this + 4) = v5;
    *((void *)this + 5) = v5;
    *((void *)this + 2) = dispatch_data_create_alloc();
    uint64_t v4 = *((void *)this + 4);
    if (!v4) {
      return 0;
    }
  }
  *a2 = *((void *)this + 3);
  a2[1] = v4;
  return 1;
}

uint64_t re::zerocopy::DispatchWriteStream::advanceWrite(uint64_t this, unint64_t a2)
{
  unint64_t v2 = *(void *)(this + 32);
  if (v2 >= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *(void *)(this + 32);
  }
  *(void *)(this + 24) += v3;
  *(void *)(this + 32) = v2 - v3;
  return this;
}

void *re::Raft::init@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X8>)
{
  re::Config::validate((_anonymous_namespace_ *)a1, (uint64_t)v132);
  if (v132[0])
  {
    BOOL result = (*(void *(**)(uint64_t *__return_ptr))(*(void *)*a2 + 16))(&v120);
    if (!(_BYTE)v120)
    {
      *a3 = 0;
      a3[8] = 1;
      goto LABEL_83;
    }
    uint64_t v32 = a3;
    RaftState::RaftState((uint64_t)v105, (uint64_t)v121);
    long long v82 = 0u;
    long long v80 = 0u;
    memset(v81, 0, sizeof(v81));
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    DWORD1(v82) = 0x7FFFFFFF;
    uint64_t v85 = 0;
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    int v86 = 0;
    long long v87 = 0u;
    long long v88 = 0u;
    int v89 = 0;
    long long v91 = 0u;
    uint64_t v92 = 0;
    memset(v90, 0, sizeof(v90));
    long long v94 = 0u;
    HIDWORD(v91) = 0x7FFFFFFF;
    memset(v93, 0, sizeof(v93));
    char v95 = 0;
    v96[0] = 0;
    v98[0] = 0;
    char v99 = 0;
    memset(v104, 0, 53);
    long long v103 = 0u;
    long long v102 = 0u;
    long long v101 = 0u;
    long long v100 = 0u;
    re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v81, 0);
    *(void *)&long long v101 = *(void *)(a1 + 8);
    uint64_t v7 = *a2;
    *a2 = 0;
    *((void *)&v37 + 1) = 0;
    uint64_t v33 = v7;
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    LODWORD(v37) = 0;
    LOBYTE(v38[0]) = 0;
    uint64_t v43 = 0;
    (*(void (**)(long long *__return_ptr))(*(void *)v7 + 32))(&v48);
    uint64_t v8 = *((void *)&v48 + 1);
    (*(void (**)(long long *__return_ptr))(*(void *)v33 + 40))(&v48);
    uint64_t v44 = v8 - 1;
    uint64_t v45 = v8 - 1;
    uint64_t v9 = *((void *)&v48 + 1) + 1;
    *(void *)&long long v50 = 0;
    *(void *)&long long v49 = 0;
    long long v48 = 0uLL;
    DWORD2(v49) = 0;
    BYTE8(v5re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)&long long v59 = v9;
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v34, (uint64_t)&v48);
    re::Optional<re::Snapshot>::operator=((unsigned __int8 *)v38, (uint64_t *)&v50 + 1);
    uint64_t v43 = v59;
    re::Unstable::~Unstable((re::Unstable *)&v48);
    re::RaftLog::operator=((unsigned __int8 *)&v62, &v33);
    re::RaftLog::~RaftLog((re::RaftLog *)&v33);
    *(void *)&long long v103 = *(void *)(a1 + 24);
    unint64_t v10 = v112;
    uint64_t v11 = v117;
    long long v48 = 0u;
    long long v49 = 0u;
    LODWORD(v5re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)((char *)&v50 + 4) = 0x7FFFFFFFLL;
    unsigned int v54 = 0;
    uint64_t v52 = 0;
    v51[0] = 0;
    v51[1] = 0;
    int v53 = 0;
    char v55 = 0;
    memset(v56, 0, sizeof(v56));
    long long v57 = 0u;
    memset(v58, 0, sizeof(v58));
    long long v59 = 0u;
    DWORD1(v57) = 0x7FFFFFFF;
    DWORD1(v59) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v56, v112);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v58, v11);
    unint64_t v60 = v10;
    uint64_t v61 = v11;
    re::DynamicArray<double>::resize((uint64_t)v51, v10);
    LOBYTE(v33) = 1;
    re::ProgressSet::ProgressSet((uint64_t)&v34, (uint64_t)&v48);
    re::Optional<re::ProgressSet>::operator=(v96, &v33);
    if ((_BYTE)v33) {
      re::ProgressSet::~ProgressSet((re::ProgressSet *)&v34);
    }
    re::ProgressSet::~ProgressSet((re::ProgressSet *)&v48);
    *((void *)&v102 + 1) = 0;
    char v95 = 0;
    LOBYTE(v104[3]) = 0;
    *(_WORD *)((char *)&v104[3] + 1) = *(_WORD *)(a1 + 64);
    re::ReadOnly::ReadOnly((uint64_t)&v33, (unsigned char *)a1);
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=((uint64_t)&v90[8], &v33);
    re::Queue<re::DynamicArray<unsigned char>>::operator=((uint64_t)v93, (uint64_t *)v38);
    BYTE8(v94) = v38[3];
    re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)v38);
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit(&v33);
    *(int8x16_t *)((char *)v104 + 8) = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
    *((void *)&v101 + 1) = 0;
    if (v99) {
      char v99 = 0;
    }
    *(void *)&long long v100 = 0;
    *((void *)&v103 + 1) = 0;
    *(void *)&long long v102 = 0;
    LOBYTE(v33) = 0;
    re::Optional<re::ConfChange>::operator=(v98, (unsigned __int8 *)&v33);
    re::Optional<re::ConfChange>::~Optional(&v33);
    *((void *)&v100 + 1) = 0;
    *(void *)&v104[0] = 0;
    *((void *)&v104[1] + 1) = 0;
    v13.i64[0] = *(void *)(a1 + 48);
    v13.i64[1] = 2 * v13.i64[0];
    v104[2] = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(a1 + 32)), v13, *(int8x16_t *)(a1 + 32));
    *(_WORD *)((char *)&v104[3] + 3) = *(_WORD *)(a1 + 66);
    if (v112)
    {
      uint64_t v14 = v114;
      uint64_t v15 = 8 * v112;
      do
      {
        unint64_t v34 = 0;
        uint64_t v35 = 0;
        uint64_t v33 = 0;
        LODWORD(v36) = 0;
        *(void *)&v38[0] = 0;
        long long v37 = 0uLL;
        *((void *)&v38[0] + 1) = v103;
        re::DynamicArray<float *>::setCapacity(&v33, v103);
        LOBYTE(v38[1]) = 0;
        *(_OWORD *)((char *)&v38[1] + 8) = xmmword_234361D20;
        *((void *)&v38[2] + 1) = 0;
        *(void *)&void v38[3] = 0;
        WORD4(v38[3]) = 0;
        v16.n128_f64[0] = re::ProgressSet::insertVoter((re::ProgressSet *)v97, (const re::Progress *)&v33, *v14, (uint64_t)&v48);
        if (!(_BYTE)v48 && *((void *)&v49 + 1) && (v50 & 1) != 0) {
          (*(void (**)(double))(**((void **)&v49 + 1) + 40))(v16.n128_f64[0]);
        }
        if (v33)
        {
          uint64_t v12 = v37;
          if ((void)v37) {
            (*(void (**)(__n128))(*(void *)v33 + 40))(v16);
          }
        }
        ++v14;
        v15 -= 8;
      }
      while (v15);
    }
    if (v117)
    {
      uint64_t v17 = v119;
      uint64_t v18 = 8 * v117;
      do
      {
        unint64_t v34 = 0;
        uint64_t v35 = 0;
        uint64_t v33 = 0;
        LODWORD(v36) = 0;
        *(void *)&v38[0] = 0;
        long long v37 = 0uLL;
        *((void *)&v38[0] + 1) = v103;
        re::DynamicArray<float *>::setCapacity(&v33, v103);
        LOBYTE(v38[1]) = 0;
        *(_OWORD *)((char *)&v38[1] + 8) = xmmword_234361D20;
        *((void *)&v38[2] + 1) = 0;
        *(void *)&void v38[3] = 0;
        WORD4(v38[3]) = 0;
        v19.n128_f64[0] = re::ProgressSet::insertLearner((re::ProgressSet *)v97, (const re::Progress *)&v33, *v17, (uint64_t)&v48);
        if (*v17 == (void)v101) {
          LOBYTE(v104[3]) = 1;
        }
        if (!(_BYTE)v48 && *((void *)&v49 + 1) && (v50 & 1) != 0) {
          (*(void (**)(__n128))(**((void **)&v49 + 1) + 40))(v19);
        }
        if (v33)
        {
          uint64_t v12 = v37;
          if ((void)v37) {
            (*(void (**)(__n128))(*(void *)v33 + 40))(v19);
          }
        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
    unint64_t v20 = v109;
    if ((void)v108 || __PAIR128__(*((unint64_t *)&v108 + 1), 0) != v109)
    {
      if (v109 < (unint64_t)v80
        || (!*((void *)&v63 + 1)
          ? (!(_BYTE)v65
           ? ((*(void (**)(uint64_t *__return_ptr))(*(void *)v62 + 40))(&v33), unint64_t v21 = v34)
           : (unint64_t v21 = *((void *)&v78 + 1)))
          : (unint64_t v21 = *((void *)&v63 + 1) + *((void *)&v79 + 1) - 1),
            v20 > v21))
      {
        re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) hs.commit is out of range", "!\"Unreachable code\"", "loadState", 149, v121);
        _os_crash();
        __break(1u);
        goto LABEL_89;
      }
      *(void *)&long long v80 = v109;
      long long v100 = v108;
    }
    unint64_t v22 = *(void *)(a1 + 16);
    if (v22) {
      re::Raft::commitApply((re::Raft *)&v62, v22);
    }
    uint64_t v23 = *((void *)&v102 + 1);
    re::Raft::reset((re::Raft *)&v62, v100);
    *((void *)&v101 + 1) = 0;
    char v95 = 0;
    *((void *)&v102 + 1) = v23;
    re::Optional<re::ConfState>::Optional(&v48, v105);
    if (v106)
    {
      if ((_BYTE)v48)
      {
        uint64_t v25 = v107;
        uint64_t v33 = 0;
        unint64_t v34 = 0;
        LODWORD(v36) = 0;
        uint64_t v35 = 0;
        long long v37 = 0u;
        memset(v38, 0, 73);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v39 = 0;
        char v42 = 0;
        if (*((void *)&v49 + 1))
        {
          int v26 = (uint64_t *)*((void *)&v50 + 1);
          uint64_t v27 = 8 * *((void *)&v49 + 1);
          do
          {
            uint64_t v28 = *v26++;
            uint64_t v47 = v28;
            re::DynamicArray<re::TransitionCondition *>::add((void *)&v37 + 1, &v47);
            v27 -= 8;
          }
          while (v27);
        }
        if (v52)
        {
          uint64_t v29 = v54;
          uint64_t v30 = 8 * v52;
          do
          {
            uint64_t v31 = *v29++;
            uint64_t v47 = v31;
            re::DynamicArray<re::TransitionCondition *>::add(&v38[2], &v47);
            v30 -= 8;
          }
          while (v30);
        }
        char v42 = 1;
        BYTE8(v38[4]) = 3;
        uint64_t v41 = v25;
        re::Raft::beginMembershipChange((uint64_t)&v62, (uint64_t)&v33, v46);
        if (*(void *)&v38[2])
        {
          if (*(void *)&v38[4]) {
            (*(void (**)(void))(**(void **)&v38[2] + 40))();
          }
          *(void *)&uint64_t v38[4] = 0;
          memset(&v38[2], 0, 24);
          ++DWORD2(v38[3]);
        }
        if (*((void *)&v37 + 1))
        {
          if (*((void *)&v38[1] + 1)) {
            (*(void (**)(void))(**((void **)&v37 + 1) + 40))();
          }
          *((void *)&v38[1] + 1) = 0;
          v38[0] = 0uLL;
          *((void *)&v37 + 1) = 0;
          ++LODWORD(v38[1]);
        }
        if (v33 && (void)v37) {
          (*(void (**)(void))(*(void *)v33 + 40))();
        }
        goto LABEL_65;
      }
    }
    else if (!(_BYTE)v48)
    {
LABEL_65:
      re::Raft::Raft((uint64_t)&v33, (uint64_t *)&v62);
      *uint64_t v32 = 1;
      re::Raft::Raft((uint64_t)(v32 + 8), &v33);
      re::Raft::~Raft((re::Raft *)&v33);
      re::Optional<re::ConfState>::~Optional(&v48);
      re::Raft::~Raft((re::Raft *)&v62);
      if (v115)
      {
        if (v119) {
          (*(void (**)(void))(*(void *)v115 + 40))();
        }
        float32x2_t v119 = 0;
        uint64_t v116 = 0;
        uint64_t v117 = 0;
        uint64_t v115 = 0;
        ++v118;
      }
      if (v110)
      {
        if (v114) {
          (*(void (**)(void))(*(void *)v110 + 40))();
        }
        float32x4_t v114 = 0;
        uint64_t v111 = 0;
        unint64_t v112 = 0;
        uint64_t v110 = 0;
        ++v113;
      }
      BOOL result = re::Optional<re::ConfState>::~Optional(v105);
      if ((_BYTE)v120)
      {
        if (v127)
        {
          if (v131) {
            (*(void (**)(void))(*(void *)v127 + 40))();
          }
          uint64_t v131 = 0;
          uint64_t v128 = 0;
          uint64_t v129 = 0;
          uint64_t v127 = 0;
          ++v130;
        }
        if (v122)
        {
          if (v126) {
            (*(void (**)(void))(*(void *)v122 + 40))();
          }
          uint64_t v126 = 0;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          uint64_t v122 = 0;
          ++v125;
        }
        BOOL result = re::Optional<re::ConfState>::~Optional(v121);
      }
LABEL_83:
      if (v132[0]) {
        return result;
      }
      goto LABEL_84;
    }
LABEL_89:
    re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Should never find pendingConfChange without an index", "!\"Unreachable code\"", "init", 110);
    BOOL result = (void *)_os_crash();
    __break(1u);
    return result;
  }
  *a3 = 0;
  a3[8] = 5;
LABEL_84:
  BOOL result = v133;
  if (v133)
  {
    if (v134) {
      return (void *)(*(uint64_t (**)(void))(*v133 + 40))();
    }
  }
  return result;
}

unsigned __int8 *re::RaftLog::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void *)a1;
  *(void *)a1 = v4;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a1 + 8), (uint64_t)(a2 + 1));
  re::Optional<re::Snapshot>::operator=(a1 + 48, a2 + 6);
  *((void *)a1 + 35) = a2[35];
  *((_OWORD *)a1 + 18) = *((_OWORD *)a2 + 18);
  return a1;
}

unsigned char *re::Optional<re::ProgressSet>::operator=(unsigned char *a1, uint64_t *a2)
{
  int v3 = *a1;
  int v4 = *(unsigned __int8 *)a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    char v6 = (re::ProgressSet *)(a1 + 8);
    if (v3) {
      BOOL v7 = v4 == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      re::ProgressSet::~ProgressSet(v6);
      *a1 = 0;
    }
    else
    {
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::ProgressSet::operator=((uint64_t)v6, a2 + 1);
      }
      else
      {
        *a1 = 1;
        re::ProgressSet::ProgressSet((uint64_t)v6, (uint64_t)(a2 + 1));
      }
    }
  }
  return a1;
}

unsigned char *re::Optional<re::ConfChange>::operator=(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  int v4 = *a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    if (*a1) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 88));
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 48));
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 8));
      *a1 = 0;
    }
    else
    {
      uint64_t v7 = (uint64_t)(a1 + 8);
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::ConfChange::operator=(v7, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        re::ConfChange::ConfChange(v7, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

uint64_t re::Raft::commitApply(re::Raft *this, unint64_t a2)
{
  uint64_t result = re::RaftLog::appliedTo((uint64_t)this, a2);
  if (*((unsigned char *)this + 856) && *((void *)this + 126) <= a2 && *((unsigned char *)this + 536) == 2)
  {
    return re::Raft::appendFinalizeConfChangeEntry(this);
  }
  return result;
}

uint64_t re::Raft::beginMembershipChange@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  if (*(unsigned char *)(a2 + 120) == 3 && *(unsigned char *)(a2 + 152) && *(void *)(a2 + 144))
  {
    uint64_t v5 = result;
    LOBYTE(v27) = 1;
    re::ConfChange::ConfChange((uint64_t)v28, a2);
    re::Optional<re::ConfChange>::operator=((unsigned char *)(v5 + 856), (unsigned __int8 *)&v27);
    re::Optional<re::ConfChange>::~Optional(&v27);
    uint64_t Index = re::RaftLog::lastIndex((re::RaftLog *)v5);
    unint64_t v7 = *(void *)(v5 + 1088);
    uint64_t v8 = Index + 1;
    v28[0] = 0;
    v28[1] = 0;
    uint64_t v27 = 0;
    int v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    unint64_t v33 = v7;
    re::DynamicArray<float *>::setCapacity(&v27, v7);
    char v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = v8;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    __int16 v39 = 0;
    memset(v23, 0, sizeof(v23));
    long long v24 = 0u;
    memset(v25, 0, sizeof(v25));
    DWORD1(v24) = 0x7FFFFFFF;
    long long v26 = 0u;
    DWORD1(v26) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v23, 0);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v25, 0);
    uint64_t v9 = *(void *)(a2 + 56);
    if (v9)
    {
      unint64_t v10 = *(uint64_t **)(a2 + 72);
      uint64_t v11 = 8 * v9;
      do
      {
        uint64_t v12 = *v10++;
        v20[0] = v12;
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v23, v20);
        v11 -= 8;
      }
      while (v11);
    }
    uint64_t v13 = *(void *)(a2 + 96);
    if (v13)
    {
      uint64_t v14 = *(uint64_t **)(a2 + 112);
      uint64_t v15 = 8 * v13;
      do
      {
        uint64_t v16 = *v14++;
        v20[0] = v16;
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v25, v20);
        v15 -= 8;
      }
      while (v15);
    }
    double v17 = re::ProgressSet::beginMembershipChange((re::ProgressSet *)(v5 + 552), (const re::Configuration *)v23, (re::Progress *)&v27, (uint64_t)v20);
    if (LOBYTE(v20[0]))
    {
      char v18 = 1;
    }
    else
    {
      a3[1] = 13;
      if (v21 && (v22 & 1) != 0) {
        (*(void (**)(double))(*(void *)v21 + 40))(v17);
      }
      char v18 = 0;
    }
    *a3 = v18;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v25);
    double v19 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v23);
    uint64_t result = v27;
    if (v27)
    {
      if (v30) {
        return (*(uint64_t (**)(double))(*(void *)v27 + 40))(v19);
      }
    }
  }
  else
  {
    *(_WORD *)a3 = 2560;
  }
  return result;
}

uint64_t re::Raft::appendFinalizeConfChangeEntry(re::Raft *this)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  memset(v11, 0, sizeof(v11));
  int v12 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  char v23 = 0;
  char v19 = 4;
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  LOBYTE(v9) = 1;
  DWORD2(v5) = 1;
  v25[0] = &unk_26E716118;
  v25[1] = &v4;
  v3[0] = v25;
  long long v24 = (re::zerocopy **)v3;
  re::ConsensusWriter::write(&v24, (uint64_t)v11);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v25, (uint64_t *)&v4);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v26, (uint64_t *)&v6 + 1);
  long long v29 = v9;
  uint64_t v30 = v10;
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v3, (uint64_t)v25, 1uLL);
  if (v26[0])
  {
    if (v28) {
      (*(void (**)(void))(*(void *)v26[0] + 40))(v26[0]);
    }
    uint64_t v28 = 0;
    memset(v26, 0, sizeof(v26));
    ++v27;
  }
  if (v25[0] && v25[4]) {
    (*(void (**)(void))(*(void *)v25[0] + 40))();
  }
  re::Raft::appendEntry((uint64_t)this, (uint64_t)v3);
  re::Raft::broadcastAppend(this);
  re::DynamicArray<re::Entry>::deinit((uint64_t)v3);
  if (*((void *)&v6 + 1))
  {
    if (*((void *)&v8 + 1)) {
      (*(void (**)(void))(**((void **)&v6 + 1) + 40))();
    }
    *((void *)&v8 + 1) = 0;
    long long v7 = 0uLL;
    *((void *)&v6 + 1) = 0;
    LODWORD(v8) = v8 + 1;
  }
  uint64_t result = v4;
  if ((void)v4)
  {
    if ((void)v6) {
      return (*(uint64_t (**)(void))(*(void *)v4 + 40))();
    }
  }
  return result;
}

uint64_t re::Raft::appendEntry(uint64_t a1, uint64_t a2)
{
  uint64_t Index = re::RaftLog::lastIndex((re::RaftLog *)a1);
  unint64_t v5 = *(void *)(a2 + 16);
  if (v5)
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(void *)(a1 + 1040);
    long long v8 = (void *)(*(void *)(a2 + 32) + 96);
    do
    {
      *(v8 - 1) = Index + 1 + v6;
      void *v8 = v7;
      v6 += 2;
      v8 += 26;
    }
    while (v6 < v5);
  }
  unint64_t v9 = re::RaftLog::append((re::RaftLog *)a1, a2);
  LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = 0x7FFFFFFF;
  if (*(void *)(a1 + 552))
  {
    unint64_t v11 = *(void *)(a1 + 1056);
    unint64_t v12 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
    uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 576)));
    if (v13 != 0x7FFFFFFF)
    {
      uint64_t v14 = *(void *)(a1 + 568);
      LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v13;
      if (*(void *)(v14 + 136 * v13 + 16) != v11)
      {
        uint64_t v10 = v13;
        while (1)
        {
          LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v14 + 136 * v10 + 8) & 0x7FFFFFFF;
          if (v10 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v14 + 136 * v10 + 16) == v11) {
            goto LABEL_12;
          }
        }
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = 0x7FFFFFFF;
      }
    }
  }
LABEL_12:
  uint64_t v15 = *(void *)(a1 + 568) + 136 * v10;
  if (*(void *)(v15 + 96) < v9)
  {
    *(void *)(v15 + 96) = v9;
    *(unsigned char *)(v15 + 128) = 0;
  }
  if (*(void *)(v15 + 104) < v9 + 1) {
    *(void *)(v15 + 104) = v9 + 1;
  }
  unint64_t v16 = re::ProgressSet::maximalCommittedIndex((re::ProgressSet *)(a1 + 552));
  uint64_t v17 = *(void *)(a1 + 1040);
  return re::RaftLog::maybeCommit((re::RaftLog *)a1, v16, v17);
}

void re::Raft::broadcastAppend(re::Raft *this)
{
  unint64_t v2 = (char *)this + 544;
  uint64_t v3 = *((unsigned int *)this + 146);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = (int *)(*((void *)this + 71) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 34;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 146);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  uint64_t v7 = (re::Raft *)((char *)this + 552);
  if (v3 != v4)
  {
    uint64_t v8 = v4;
    uint64_t v9 = *((void *)this + 132);
    unsigned int v10 = *((_DWORD *)this + 146);
    do
    {
      uint64_t v11 = *((void *)this + 71);
      unint64_t v12 = *(void *)(v11 + 136 * v8 + 16);
      if (v9 != v12)
      {
        if (*(void *)v7
          && (unint64_t v13 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27)),
              uint64_t v14 = *(unsigned int *)(*((void *)this + 70) + 4 * ((v13 ^ (v13 >> 31)) % *((unsigned int *)this + 144))),
              v14 != 0x7FFFFFFF))
        {
          uint64_t v17 = *(void *)(v11 + 136 * v14 + 16);
          for (uint64_t i = v14; v17 != v12; LODWORD(v14) = i)
          {
            uint64_t i = *(_DWORD *)(v11 + 136 * i + 8) & 0x7FFFFFFF;
            LODWORD(v14) = 0x7FFFFFFF;
            if (i == 0x7FFFFFFF) {
              break;
            }
            uint64_t v17 = *(void *)(v11 + 136 * i + 16);
          }
        }
        else
        {
          LODWORD(v14) = 0x7FFFFFFF;
        }
        re::Raft::sendAppend(this, v12, (re::Progress *)(v11 + 136 * v14 + 24));
        unsigned int v10 = *((_DWORD *)this + 146);
      }
      if (v10 <= (int)v4 + 1) {
        unsigned int v15 = v4 + 1;
      }
      else {
        unsigned int v15 = v10;
      }
      while (1)
      {
        uint64_t v8 = (v4 + 1);
        if (v15 - 1 == v4) {
          break;
        }
        LODWORD(v4) = v4 + 1;
        unsigned int v16 = v8;
        if ((*(_DWORD *)(*((void *)this + 71) + 136 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_24;
        }
      }
      unsigned int v16 = v15;
LABEL_24:
      LODWORD(v4) = v16;
    }
    while (v3 != v16);
  }
  LOBYTE(v19) = 1;
  re::ProgressSet::ProgressSet((re::ProgressSet *)v20, v7);
  re::Optional<re::ProgressSet>::operator=(v2, &v19);
  if ((_BYTE)v19) {
    re::ProgressSet::~ProgressSet((re::ProgressSet *)v20);
  }
}

uint64_t re::Raft::becomeLeader(re::Raft *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  re::Raft::reset(this, *((void *)this + 130));
  unint64_t v2 = *((void *)this + 132);
  *((void *)this + 133) = v2;
  *((unsigned char *)this + 536) = 2;
  LODWORD(v3) = 0x7FFFFFFF;
  if (*((void *)this + 69))
  {
    unint64_t v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
    uint64_t v5 = *(unsigned int *)(*((void *)this + 70) + 4 * ((v4 ^ (v4 >> 31)) % *((unsigned int *)this + 144)));
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *((void *)this + 71);
      LODWORD(v3) = v5;
      if (*(void *)(v6 + 136 * v5 + 16) != v2)
      {
        uint64_t v3 = v5;
        while (1)
        {
          LODWORD(v3) = *(_DWORD *)(v6 + 136 * v3 + 8) & 0x7FFFFFFF;
          if (v3 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v6 + 136 * v3 + 16) == v2) {
            goto LABEL_9;
          }
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  uint64_t v7 = *((void *)this + 71) + 136 * v3;
  *(unsigned char *)(v7 + 128) = 0;
  *(unsigned char *)(v7 + 88) = 1;
  *(void *)(v7 + 64) = 0;
  *(void *)(v7 + 72) = 0;
  *(void *)(v7 + 104) = *(void *)(v7 + 96) + 1;
  *(void *)(v7 + 112) = 0;
  *((void *)this + 134) = re::RaftLog::lastIndex(this);
  uint64_t v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v9, (uint64_t)v10, 1uLL);
  if (*((void *)&v11 + 1))
  {
    if (*((void *)&v13 + 1)) {
      (*(void (**)(void))(**((void **)&v11 + 1) + 40))();
    }
    *((void *)&v13 + 1) = 0;
    long long v12 = 0uLL;
    *((void *)&v11 + 1) = 0;
    LODWORD(v13) = v13 + 1;
  }
  if (*(void *)&v10[0] && (void)v11) {
    (*(void (**)(void))(**(void **)&v10[0] + 40))();
  }
  re::Raft::appendEntry((uint64_t)this, (uint64_t)v9);
  if (*((unsigned char *)this + 856) && *((void *)this + 126) <= *((void *)this + 36)) {
    re::Raft::appendFinalizeConfChangeEntry(this);
  }
  return re::DynamicArray<re::Entry>::deinit((uint64_t)v9);
}

uint64_t re::Raft::reset(re::Raft *this, uint64_t a2)
{
  if (*((void *)this + 130) != a2)
  {
    *((void *)this + 13re::InputManager::notify(8, 0, 0, 0) = a2;
    *((void *)this + 131) = 0;
  }
  *((void *)this + 133) = 0;
  std::random_device::random_device[abi:nn180100](&v31);
  uint32_t v3 = arc4random();
  v30.__x_[0] = v3;
  for (uint64_t i = 1; i != 624; ++i)
  {
    uint32_t v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
    v30.__x_[i] = v3;
  }
  v30.__i_ = 0;
  signed int v5 = *((_DWORD *)this + 284);
  int v6 = *((_DWORD *)this + 286) - 1 - v5;
  if (v6)
  {
    unsigned int v7 = *((_DWORD *)this + 286) - v5;
    if (v6 == -1)
    {
      signed int v5 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v30);
    }
    else
    {
      uint64_t v8 = __clz(v7);
      uint64_t v9 = 31;
      if (((v7 << v8) & 0x7FFFFFFF) != 0) {
        uint64_t v9 = 32;
      }
      unint64_t v10 = v9 - v8;
      unint64_t v11 = v10 >> 5;
      if ((v10 & 0x1F) != 0) {
        ++v11;
      }
      if (v11 <= v10) {
        unsigned int v12 = 0xFFFFFFFF >> -(v10 / v11);
      }
      else {
        unsigned int v12 = 0;
      }
      do
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v13 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v30) & v12;
      while (v13 >= v7);
      v5 += v13;
    }
  }
  *((void *)this + 141) = v5;
  std::random_device::~random_device(&v31);
  *(_OWORD *)((char *)this + 1096) = 0u;
  if (*((unsigned char *)this + 1024)) {
    *((unsigned char *)this + 1024) = 0;
  }
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)this + 304);
  *((void *)this + 134) = 0;
  re::ReadOnly::ReadOnly((uint64_t)&v30, (unsigned char *)this + 528);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=((uint64_t)this + 432, (uint64_t *)&v30);
  re::Queue<re::DynamicArray<unsigned char>>::operator=((uint64_t)this + 480, (uint64_t *)&v30.__x_[12]);
  *((unsigned char *)this + 528) = v30.__x_[24];
  re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)&v30.__x_[12]);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)&v30);
  *((void *)this + 135) = 0;
  uint64_t result = re::RaftLog::lastIndex(this);
  uint64_t v15 = *((unsigned int *)this + 146);
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = (int *)(*((void *)this + 71) + 8);
    while (1)
    {
      int v18 = *v17;
      v17 += 34;
      if (v18 < 0) {
        break;
      }
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 146);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if (v15 != v16)
  {
    uint64_t v19 = v16;
    uint64_t v20 = *((void *)this + 132);
    do
    {
      uint64_t v21 = *((void *)this + 71);
      unint64_t v22 = *(void *)(v21 + 136 * v19 + 16);
      if (*((void *)this + 69)
        && (unint64_t v23 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) >> 27)),
            uint64_t v24 = *(unsigned int *)(*((void *)this + 70) + 4 * ((v23 ^ (v23 >> 31)) % *((unsigned int *)this + 144))),
            v24 != 0x7FFFFFFF))
      {
        uint64_t v28 = *(void *)(v21 + 136 * v24 + 16);
        for (uint64_t j = v24; v28 != v22; LODWORD(v24) = j)
        {
          uint64_t j = *(_DWORD *)(v21 + 136 * j + 8) & 0x7FFFFFFF;
          LODWORD(v24) = 0x7FFFFFFF;
          if (j == 0x7FFFFFFF) {
            break;
          }
          uint64_t v28 = *(void *)(v21 + 136 * j + 16);
        }
      }
      else
      {
        LODWORD(v24) = 0x7FFFFFFF;
      }
      uint64_t v25 = v21 + 136 * v24;
      *(void *)(v25 + 96) = 0;
      *(void *)(v25 + 104) = result + 1;
      *(unsigned char *)(v25 + 88) = 0;
      *(void *)(v25 + 64) = 0;
      *(void *)(v25 + 72) = 0;
      *(void *)(v25 + 112) = 0;
      *(void *)(v25 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
      *(_WORD *)(v25 + 128) = 0;
      if (v22 == v20) {
        *(void *)(v21 + 136 * v24 + 96) = result;
      }
      unsigned int v26 = *((_DWORD *)this + 146);
      if (v26 <= (int)v16 + 1) {
        unsigned int v26 = v16 + 1;
      }
      while (1)
      {
        uint64_t v19 = (v16 + 1);
        if (v26 - 1 == v16) {
          break;
        }
        LODWORD(v16) = v16 + 1;
        unsigned int v27 = v19;
        if ((*(_DWORD *)(*((void *)this + 71) + 136 * v19 + 8) & 0x80000000) != 0) {
          goto LABEL_38;
        }
      }
      unsigned int v27 = v26;
LABEL_38:
      LODWORD(v16) = v27;
    }
    while (v15 != v27);
  }
  return result;
}

re::Raft *re::Raft::sendAppend(re::Raft *this, uint64_t a2, re::Progress *a3)
{
  uint64_t v5 = (uint64_t)this;
  if (*((unsigned char *)a3 + 64))
  {
    if (*((unsigned char *)a3 + 64) != 1 || *((void *)a3 + 6) == *((void *)a3 + 7)) {
      return this;
    }
  }
  else if (*((unsigned char *)a3 + 104))
  {
    return this;
  }
  __n128 v26 = 0uLL;
  int v28 = 0;
  uint64_t v27 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  int v31 = 0;
  memset(v32, 0, 233);
  long long v34 = 0u;
  memset(v35, 0, 25);
  long long v33 = 0u;
  v32[30] = a2;
  if (*((void *)a3 + 12))
  {
    if ((re::Raft::prepareSendSnapshot(this, (re::Message *)&v26, a3) & 1) == 0) {
      goto LABEL_41;
    }
    goto LABEL_35;
  }
  re::RaftLog::getTerm(this, *((void *)a3 + 10) - 1, (uint64_t)v24);
  re::RaftLog::entries((re::RaftLog *)v5, *((void *)a3 + 10), (uint64_t)v20);
  if (!v24[0] || !v20[0])
  {
    if ((re::Raft::prepareSendSnapshot((re::Raft *)v5, (re::Message *)&v26, a3) & 1) == 0) {
      goto LABEL_29;
    }
LABEL_33:
    if (v20[0]) {
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v21);
    }
LABEL_35:
    re::Message::Message((re::Message *)v13, (const re::Message *)&v26);
    re::Raft::send(v5, (uint64_t)v13);
    re::Snapshot::~Snapshot((re::Snapshot *)&v19);
    if (v14)
    {
      if (v18) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      uint64_t v18 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v14 = 0;
      ++v17;
    }
    unsigned int v12 = (__n128 *)v13;
    goto LABEL_40;
  }
  if (!*(unsigned char *)(v5 + 1156)) {
    goto LABEL_31;
  }
  uint64_t v6 = *(void *)(v5 + 408);
  if (!v6) {
    goto LABEL_31;
  }
  unsigned int v7 = v23;
  uint64_t v8 = *(__n128 **)(v5 + 424);
  while (v8[19].n128_u8[0] != 3 || v8[19].n128_u64[1] != a2)
  {
    v8 += 24;
    if (!--v6) {
      goto LABEL_31;
    }
  }
  if (!v22) {
    goto LABEL_28;
  }
  unint64_t v10 = v8[1].n128_u64[0];
  if (v10)
  {
    if (*(void *)(v8[2].n128_u64[0] + 104 * v10 - 16) + 1 != v23[5].n128_u64[1])
    {
LABEL_31:
      LOBYTE(v32[29]) = 3;
      *((void *)&v34 + 1) = *((void *)a3 + 10) - 1;
      *(void *)&long long v34 = v25;
      re::DynamicArray<re::Entry>::clear((uint64_t)&v26);
      re::DynamicArray<re::Entry>::operator=(&v26, &v21);
      v35[0] = *(void *)(v5 + 288);
      if (v27) {
        re::Progress::updateState(a3, *(void *)(v29 + 104 * v27 - 16));
      }
      goto LABEL_33;
    }
  }
  uint64_t v11 = 104 * v22;
  do
  {
    re::DynamicArray<re::Entry>::add(v8, v7);
    unsigned int v7 = (__n128 *)((char *)v7 + 104);
    v11 -= 104;
  }
  while (v11);
  re::Progress::updateState(a3, *(void *)(v8[2].n128_u64[0] + 104 * v8[1].n128_u64[0] - 16));
LABEL_28:
  v8[22].n128_u64[0] = *(void *)(v5 + 288);
LABEL_29:
  if (v20[0])
  {
    unsigned int v12 = &v21;
LABEL_40:
    re::DynamicArray<re::Entry>::deinit((uint64_t)v12);
  }
LABEL_41:
  re::Snapshot::~Snapshot((re::Snapshot *)&v32[1]);
  if (*((void *)&v29 + 1))
  {
    if (v32[0]) {
      (*(void (**)(void))(**((void **)&v29 + 1) + 40))();
    }
    v32[0] = 0;
    long long v30 = 0uLL;
    *((void *)&v29 + 1) = 0;
    ++v31;
  }
  return (re::Raft *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v26);
}

uint64_t re::Raft::prepareSendSnapshot(re::Raft *this, re::Message *a2, re::Progress *a3)
{
  if (!*((unsigned char *)a3 + 105)) {
    return 0;
  }
  *((unsigned char *)a2 + 304) = 7;
  re::RaftLog::snapshot(this, *((void *)a3 + 12), (uint64_t)v17);
  BOOL v6 = v17[0] != 0;
  if (!v17[0])
  {
    if (LOBYTE(v18[0]) != 3) {
      goto LABEL_10;
    }
    return v6;
  }
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v10, v18);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v11, v19);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v12, v20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v13, v21);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v14, v22);
  long long v15 = v23;
  uint64_t v16 = v24;
  uint64_t v8 = *((void *)&v23 + 1);
  if (*((void *)&v23 + 1))
  {
    re::DynamicArray<BOOL>::operator=((uint64_t)a2 + 80, v10);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 120, v11);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 160, v12);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 200, v13);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 240, v14);
    *(_OWORD *)((char *)a2 + 28re::InputManager::notify(8, 0, 0, 0) = v15;
    *((void *)a2 + 37) = v16;
    *((unsigned char *)a3 + 104) = 0;
    *((unsigned char *)a3 + 64) = 2;
    *((void *)a3 + 5) = 0;
    *((void *)a3 + 6) = 0;
    *((void *)a3 + 11) = v8;
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
    if (v17[0]) {
      re::Snapshot::~Snapshot((re::Snapshot *)v18);
    }
    return v6;
  }
  re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Need non-empty snapshot", "!\"Unreachable code\"", "prepareSendSnapshot", 320);
  _os_crash();
  __break(1u);
LABEL_10:
  re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Unexpected error", "!\"Unreachable code\"", "prepareSendSnapshot", 315);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

re::Message *re::Raft::send(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32re::InputManager::notify(8, 0, 0, 0) = *(void *)(a1 + 1056);
  unsigned int v2 = *(unsigned __int8 *)(a2 + 304);
  if (v2 > 0x12 || ((1 << v2) & 0x60060) == 0)
  {
    if (!*(void *)(a2 + 328))
    {
      if (v2 != 2 && v2 != 15) {
        *(void *)(a2 + 328) = *(void *)(a1 + 1040);
      }
      goto LABEL_6;
    }
LABEL_16:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) term should be set when sending, was", "!\"Unreachable code\"", "send", 354);
    uint64_t result = (re::Message *)_os_crash();
    __break(1u);
    return result;
  }
  if (!*(void *)(a2 + 328))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) term should be set when sending", "!\"Unreachable code\"", "send", 350);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
LABEL_6:
  uint64_t v4 = a1 + 392;
  return re::DynamicArray<re::Message>::add(v4, (re::Message *)a2);
}

void re::Message::~Message(re::Message *this)
{
}

uint64_t re::DynamicArray<re::Entry>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 104 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v3 + 40);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v3);
      v3 += 104;
      v4 -= 104;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

__n128 *re::DynamicArray<re::Entry>::operator=(__n128 *a1, __n128 *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a2->n128_u64[0];
    if (a1->n128_u64[0])
    {
      if (v4)
      {
        re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
        ++a1[1].n128_u32[2];
      }
      else
      {
        re::DynamicArray<re::Entry>::clear((uint64_t)a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[1].n128_u64[0];
      a1->n128_u64[0] = v4;
      re::DynamicArray<re::Entry>::setCapacity(a1, v5);
      ++a1[1].n128_u32[2];
      re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

re::Message *re::DynamicArray<re::Message>::add(uint64_t a1, re::Message *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::Message>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Message>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t result = re::Message::Message((re::Message *)(*(void *)(a1 + 32) + 384 * v5), a2);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::Raft::broadcastHeartbeat(re::Raft *this)
{
  re::ReadOnly::lastPendingRequestCtx((void *)this + 54, v2);
  re::Raft::broadcastHeatbeatWithCtx((uint64_t)this, v2);
  if (v2[0] && v3)
  {
    if (v4) {
      (*(void (**)(void))(*(void *)v3 + 40))();
    }
  }
}

void re::Raft::broadcastHeatbeatWithCtx(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 584);
  uint64_t v19 = (unsigned char *)(a1 + 544);
  uint64_t v4 = 0;
  if (v3)
  {
    unint64_t v5 = (int *)(*(void *)(a1 + 568) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 34;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *(_DWORD *)(a1 + 584);
        break;
      }
    }
  }
  uint64_t v22 = (re::ProgressSet *)(a1 + 552);
  if (v3 != v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = *(void *)(a1 + 1056);
    uint64_t v20 = (uint64_t *)(a2 + 8);
    unsigned int v9 = *(_DWORD *)(a1 + 584);
    do
    {
      uint64_t v10 = *(void *)(a1 + 568);
      unint64_t v11 = *(void *)(v10 + 136 * v7 + 16);
      if (v11 != v8)
      {
        if (*(void *)v22
          && (unint64_t v12 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27)),
              uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 576))),
              v13 != 0x7FFFFFFF))
        {
          uint64_t v17 = *(void *)(v10 + 136 * v13 + 16);
          for (uint64_t i = v13; v17 != v11; LODWORD(v13) = i)
          {
            uint64_t i = *(_DWORD *)(v10 + 136 * i + 8) & 0x7FFFFFFF;
            LODWORD(v13) = 0x7FFFFFFF;
            if (i == 0x7FFFFFFF) {
              break;
            }
            uint64_t v17 = *(void *)(v10 + 136 * i + 16);
          }
        }
        else
        {
          LODWORD(v13) = 0x7FFFFFFF;
        }
        unint64_t v14 = *(void *)(v10 + 136 * v13 + 96);
        uint64_t v30 = 0;
        v31[0] = 0;
        int v32 = 0;
        v31[1] = 0;
        long long v33 = 0u;
        long long v34 = 0u;
        int v35 = 0;
        memset(v36, 0, sizeof(v36));
        long long v40 = 0u;
        memset(v41, 0, 25);
        long long v39 = 0u;
        char v37 = 8;
        if (*(void *)(a1 + 288) < v14) {
          unint64_t v14 = *(void *)(a1 + 288);
        }
        unint64_t v38 = v11;
        v41[0] = v14;
        if (*a2) {
          re::DynamicArray<BOOL>::operator=((uint64_t)&v33 + 8, v20);
        }
        re::Message::Message((re::Message *)v23, (const re::Message *)&v30);
        re::Raft::send(a1, (uint64_t)v23);
        re::Snapshot::~Snapshot((re::Snapshot *)&v29);
        if (v24)
        {
          if (v28) {
            (*(void (**)(void))(*(void *)v24 + 40))();
          }
          uint64_t v28 = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          uint64_t v24 = 0;
          ++v27;
        }
        re::DynamicArray<re::Entry>::deinit((uint64_t)v23);
        re::Snapshot::~Snapshot((re::Snapshot *)&v36[1]);
        if (*((void *)&v33 + 1))
        {
          if (v36[0]) {
            (*(void (**)(void))(**((void **)&v33 + 1) + 40))();
          }
          v36[0] = 0;
          long long v34 = 0uLL;
          *((void *)&v33 + 1) = 0;
          ++v35;
        }
        re::DynamicArray<re::Entry>::deinit((uint64_t)&v30);
        unsigned int v9 = *(_DWORD *)(a1 + 584);
      }
      if (v9 <= (int)v4 + 1) {
        unsigned int v15 = v4 + 1;
      }
      else {
        unsigned int v15 = v9;
      }
      while (1)
      {
        uint64_t v7 = (v4 + 1);
        if (v15 - 1 == v4) {
          break;
        }
        LODWORD(v4) = v4 + 1;
        unsigned int v16 = v7;
        if ((*(_DWORD *)(*(void *)(a1 + 568) + 136 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_35;
        }
      }
      unsigned int v16 = v15;
LABEL_35:
      LODWORD(v4) = v16;
    }
    while (v3 != v16);
  }
  LOBYTE(v3re::InputManager::notify(8, 0, 0, 0) = 1;
  re::ProgressSet::ProgressSet((re::ProgressSet *)v31, v22);
  re::Optional<re::ProgressSet>::operator=(v19, &v30);
  if ((_BYTE)v30) {
    re::ProgressSet::~ProgressSet((re::ProgressSet *)v31);
  }
}

std::random_device *std::random_device::random_device[abi:nn180100](std::random_device *a1)
{
  std::string::basic_string[abi:nn180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  return a1;
}

BOOL re::Raft::tick(re::Raft *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 536);
  if (v1 < 2) {
    return re::Raft::tickElection(this);
  }
  if (v1 == 2) {
    return re::Raft::tickHeartbeat(this);
  }
  if (v1 == 3) {
    return re::Raft::tickElection(this);
  }
  return 0;
}

BOOL re::Raft::tickElection(re::Raft *this)
{
  unint64_t v1 = *((void *)this + 137) + 1;
  *((void *)this + 137) = v1;
  if (v1 < *((void *)this + 141)) {
    return 0;
  }
  BOOL result = re::Raft::promotable(this);
  if (result)
  {
    *((void *)this + 137) = 0;
    uint64_t v4 = *((void *)this + 132);
    memset(v5, 0, sizeof(v5));
    int v6 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    int v9 = 0;
    memset(v10, 0, sizeof(v10));
    uint64_t v11 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v13 = 0;
    long long v15 = 0u;
    char v18 = 0;
    uint64_t v14 = v4;
    char v12 = 0;
    re::Raft::step((uint64_t)this, v5, v19);
    re::Snapshot::~Snapshot((re::Snapshot *)((char *)v10 + 8));
    if (*((void *)&v7 + 1))
    {
      if (*(void *)&v10[0]) {
        (*(void (**)(void))(**((void **)&v7 + 1) + 40))();
      }
      *(void *)&v10[0] = 0;
      long long v8 = 0uLL;
      *((void *)&v7 + 1) = 0;
      ++v9;
    }
    re::DynamicArray<re::Entry>::deinit((uint64_t)v5);
    return 1;
  }
  return result;
}

BOOL re::Raft::tickHeartbeat(re::Raft *this)
{
  int64x2_t v2 = vaddq_s64(*(int64x2_t *)((char *)this + 1096), vdupq_n_s64(1uLL));
  *(int64x2_t *)((char *)this + 1096) = v2;
  if (v2.i64[0] < *((void *)this + 140))
  {
    BOOL v3 = 0;
    if (*((unsigned char *)this + 536) != 2) {
      return v3;
    }
    goto LABEL_17;
  }
  *((void *)this + 137) = 0;
  BOOL v3 = *((unsigned char *)this + 1153) != 0;
  if (*((unsigned char *)this + 1153))
  {
    uint64_t v4 = *((void *)this + 132);
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    int v26 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    int v29 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v44 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    uint64_t v46 = 0;
    long long v48 = 0u;
    char v51 = 0;
    uint64_t v47 = v4;
    char v45 = 12;
    re::Message::Message((re::Message *)v15, (const re::Message *)&v23);
    re::Raft::step((uint64_t)this, v15, v22);
    re::Snapshot::~Snapshot((re::Snapshot *)&v21);
    if (v16)
    {
      if (v20) {
        (*(void (**)(void))(*(void *)v16 + 40))();
      }
      uint64_t v20 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      ++v19;
    }
    re::DynamicArray<re::Entry>::deinit((uint64_t)v15);
    re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v30 + 8));
    if (*((void *)&v27 + 1))
    {
      if ((void)v30) {
        (*(void (**)(void))(**((void **)&v27 + 1) + 40))();
      }
      *(void *)&long long v30 = 0;
      long long v28 = 0uLL;
      *((void *)&v27 + 1) = 0;
      ++v29;
    }
    re::DynamicArray<re::Entry>::deinit((uint64_t)&v23);
  }
  if (*((unsigned char *)this + 536) == 2)
  {
    if (*((unsigned char *)this + 1024)) {
      *((unsigned char *)this + 1024) = 0;
    }
LABEL_17:
    if (*((void *)this + 138) >= *((void *)this + 139))
    {
      *((void *)this + 138) = 0;
      uint64_t v5 = *((void *)this + 132);
      uint64_t v25 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      int v26 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      int v29 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      uint64_t v44 = 0;
      long long v49 = 0u;
      long long v50 = 0u;
      uint64_t v46 = 0;
      long long v48 = 0u;
      char v51 = 0;
      uint64_t v47 = v5;
      char v45 = 1;
      re::Message::Message((re::Message *)v7, (const re::Message *)&v23);
      re::Raft::step((uint64_t)this, v7, v14);
      re::Snapshot::~Snapshot((re::Snapshot *)&v13);
      if (v8)
      {
        if (v12) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
        uint64_t v12 = 0;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        uint64_t v8 = 0;
        ++v11;
      }
      re::DynamicArray<re::Entry>::deinit((uint64_t)v7);
      re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v30 + 8));
      if (*((void *)&v27 + 1))
      {
        if ((void)v30) {
          (*(void (**)(void))(**((void **)&v27 + 1) + 40))();
        }
        *(void *)&long long v30 = 0;
        long long v28 = 0uLL;
        *((void *)&v27 + 1) = 0;
        ++v29;
      }
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v23);
      return 1;
    }
  }
  return v3;
}

BOOL re::Raft::promotable(re::Raft *this)
{
  re::ProgressSet::voterIds((re::Raft *)((char *)this + 552), (uint64_t)v4);
  BOOL v2 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v4, (uint64_t *)this + 132);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v4);
  return v2;
}

void re::Raft::step(uint64_t a1@<X0>, void *a2@<X1>, unsigned char *a3@<X8>)
{
  BOOL v3 = a2;
  unint64_t v6 = a2[41];
  if (!v6) {
    goto LABEL_42;
  }
  unint64_t v7 = *(void *)(a1 + 1040);
  if (v6 <= v7)
  {
    if (v6 < v7)
    {
      if (*(unsigned char *)(a1 + 1153) || *(unsigned char *)(a1 + 1154))
      {
        int v16 = *((unsigned __int8 *)a2 + 304);
        if (v16 == 8 || v16 == 3)
        {
          unint64_t v17 = a2[40];
          uint64_t v183 = 0;
          __n128 v182 = 0uLL;
          int v184 = 0;
          *(_OWORD *)__s2 = 0u;
          long long v186 = 0u;
          int v187 = 0;
          long long v200 = 0u;
          long long v201 = 0u;
          long long v188 = 0u;
          long long v189 = 0u;
          long long v190 = 0u;
          long long v191 = 0u;
          long long v192 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v197 = 0u;
          long long v198 = 0u;
          long long v199 = 0u;
          uint64_t v202 = 0;
          memset(v207, 0, 25);
          long long v206 = 0u;
          long long v205 = 0u;
          unint64_t v204 = v17;
          char v203 = 4;
          re::Message::Message((re::Message *)v153, (const re::Message *)&v182);
          re::Raft::send(a1, (uint64_t)v153);
          re::Snapshot::~Snapshot((re::Snapshot *)&v159);
          if (v154)
          {
            if (v158) {
              (*(void (**)(void))(*(void *)v154 + 40))();
            }
            uint64_t v158 = 0;
            uint64_t v155 = 0;
            uint64_t v156 = 0;
            uint64_t v154 = 0;
            ++v157;
          }
          uint64_t v18 = v153;
          goto LABEL_71;
        }
      }
      else
      {
        int v16 = *((unsigned __int8 *)a2 + 304);
      }
      if (v16 != 17) {
        goto LABEL_88;
      }
      unint64_t v32 = a2[40];
      uint64_t v183 = 0;
      __n128 v182 = 0uLL;
      int v184 = 0;
      *(_OWORD *)__s2 = 0u;
      long long v186 = 0u;
      int v187 = 0;
      long long v200 = 0u;
      long long v201 = 0u;
      long long v188 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v193 = 0u;
      long long v194 = 0u;
      long long v195 = 0u;
      long long v196 = 0u;
      long long v197 = 0u;
      long long v198 = 0u;
      long long v199 = 0u;
      uint64_t v202 = 0;
      memset(v207, 0, 24);
      *(void *)&long long v205 = 0;
      long long v206 = 0u;
      unint64_t v204 = v32;
      char v203 = 18;
      *((void *)&v205 + 1) = v7;
      BYTE8(v207[1]) = 1;
      re::Message::Message((re::Message *)v146, (const re::Message *)&v182);
      re::Raft::send(a1, (uint64_t)v146);
      re::Snapshot::~Snapshot((re::Snapshot *)&v152);
      if (v147)
      {
        if (v151) {
          (*(void (**)(void))(*(void *)v147 + 40))();
        }
        uint64_t v151 = 0;
        uint64_t v148 = 0;
        uint64_t v149 = 0;
        uint64_t v147 = 0;
        ++v150;
      }
      uint64_t v18 = v146;
      goto LABEL_71;
    }
  }
  else
  {
    int v8 = *((unsigned __int8 *)a2 + 304);
    if (v8 == 17 || v8 == 5)
    {
      LOBYTE(v173[0]) = 0;
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v182, (char *)v173, 1uLL);
      BOOL v10 = 0;
      size_t v11 = v3[7];
      if (v11 == v183) {
        BOOL v10 = memcmp((const void *)v3[9], __s2[0], v11) == 0;
      }
      if (v182.n128_u64[0])
      {
        a2 = __s2[0];
        if (__s2[0]) {
          (*(void (**)(void))(*(void *)v182.n128_u64[0] + 40))();
        }
      }
      if (*(unsigned char *)(a1 + 1153) && *(void *)(a1 + 1064))
      {
        int v12 = *(void *)(a1 + 1096) >= *(void *)(a1 + 1120) || v10;
        if (v12 != 1) {
          goto LABEL_88;
        }
      }
      int v8 = *((unsigned __int8 *)v3 + 304);
    }
    uint64_t v13 = 0;
    if (v8 <= 16)
    {
      if ((v8 - 7) < 2 || v8 == 3) {
        uint64_t v13 = v3[40];
      }
      goto LABEL_27;
    }
    if (v8 != 17)
    {
      if (v8 != 18)
      {
LABEL_27:
        uint64_t v15 = *(void *)(a1 + 1080);
        re::Raft::reset((re::Raft *)a1, v3[41]);
        *(void *)(a1 + 1064) = v13;
        *(unsigned char *)(a1 + 536) = 0;
        *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v15;
        goto LABEL_42;
      }
      if (*((unsigned char *)v3 + 376))
      {
        uint64_t v13 = 0;
        goto LABEL_27;
      }
    }
  }
LABEL_42:
  uint64_t v19 = *((unsigned __int8 *)v3 + 304);
  if (v19 == 17 || v19 == 5)
  {
    uint64_t v21 = *(void *)(a1 + 1048);
    unint64_t v22 = v3[40];
    if (v21 != v22 && (v21 || *(void *)(a1 + 1064)))
    {
      if (v19 != 17) {
        goto LABEL_59;
      }
      if (v3[41] <= *(void *)(a1 + 1040)) {
        goto LABEL_61;
      }
    }
    BOOL isUpToDate = re::RaftLog::isUpToDate((re::RaftLog *)a1, v3[43], v3[42]);
    unint64_t v22 = v3[40];
    uint64_t v19 = *((unsigned __int8 *)v3 + 304);
    if (isUpToDate)
    {
      if (v19 == 5)
      {
        char v24 = 6;
        goto LABEL_76;
      }
      if (v19 == 17)
      {
        char v24 = 18;
LABEL_76:
        __n128 v182 = 0uLL;
        int v184 = 0;
        uint64_t v183 = 0;
        *(_OWORD *)__s2 = 0u;
        long long v186 = 0u;
        int v187 = 0;
        long long v200 = 0u;
        long long v201 = 0u;
        long long v188 = 0u;
        long long v189 = 0u;
        long long v190 = 0u;
        long long v191 = 0u;
        long long v192 = 0u;
        long long v193 = 0u;
        long long v194 = 0u;
        long long v195 = 0u;
        long long v196 = 0u;
        long long v197 = 0u;
        long long v198 = 0u;
        long long v199 = 0u;
        uint64_t v202 = 0;
        memset(v207, 0, 25);
        long long v205 = 0u;
        long long v206 = 0u;
        unint64_t v204 = v22;
        char v203 = v24;
        *((void *)&v205 + 1) = v3[41];
        re::Message::Message((re::Message *)v139, (const re::Message *)&v182);
        re::Raft::send(a1, (uint64_t)v139);
        re::Snapshot::~Snapshot((re::Snapshot *)&v145);
        if (v140)
        {
          if (v144) {
            (*(void (**)(void))(*(void *)v140 + 40))();
          }
          uint64_t v144 = 0;
          uint64_t v141 = 0;
          uint64_t v142 = 0;
          uint64_t v140 = 0;
          ++v143;
        }
        re::DynamicArray<re::Entry>::deinit((uint64_t)v139);
        if (*((unsigned char *)v3 + 304) == 5)
        {
          *(void *)(a1 + 1096) = 0;
          *(void *)(a1 + 1048) = v3[40];
        }
        re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v188 + 8));
        if (!__s2[1]) {
          goto LABEL_87;
        }
        if ((void)v188) {
          (*(void (**)(void))(*(void *)__s2[1] + 40))();
        }
        *(void *)&long long v188 = 0;
        long long v186 = 0uLL;
        __s2[1] = 0;
        goto LABEL_86;
      }
LABEL_349:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not a vote message %hhu", "!\"Unreachable code\"", "voteRespMsgType", 281, v19);
      _os_crash();
      __break(1u);
      goto LABEL_350;
    }
LABEL_59:
    if (v19 == 5)
    {
      char v25 = 6;
      goto LABEL_66;
    }
    if (v19 == 17)
    {
LABEL_61:
      char v25 = 18;
LABEL_66:
      __n128 v182 = 0uLL;
      int v184 = 0;
      uint64_t v183 = 0;
      *(_OWORD *)__s2 = 0u;
      long long v186 = 0u;
      int v187 = 0;
      long long v200 = 0u;
      long long v201 = 0u;
      long long v188 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v193 = 0u;
      long long v194 = 0u;
      long long v195 = 0u;
      long long v196 = 0u;
      long long v197 = 0u;
      long long v198 = 0u;
      long long v199 = 0u;
      uint64_t v202 = 0;
      memset(v207, 0, 24);
      long long v205 = 0u;
      long long v206 = 0u;
      unint64_t v204 = v22;
      char v203 = v25;
      BYTE8(v207[1]) = 1;
      *((void *)&v205 + 1) = *(void *)(a1 + 1040);
      re::Message::Message((re::Message *)v132, (const re::Message *)&v182);
      re::Raft::send(a1, (uint64_t)v132);
      re::Snapshot::~Snapshot((re::Snapshot *)&v138);
      if (v133)
      {
        if (v137) {
          (*(void (**)(void))(*(void *)v133 + 40))();
        }
        uint64_t v137 = 0;
        uint64_t v134 = 0;
        uint64_t v135 = 0;
        uint64_t v133 = 0;
        ++v136;
      }
      uint64_t v18 = v132;
LABEL_71:
      re::DynamicArray<re::Entry>::deinit((uint64_t)v18);
      re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v188 + 8));
      if (!__s2[1])
      {
LABEL_87:
        re::DynamicArray<re::Entry>::deinit((uint64_t)&v182);
        goto LABEL_88;
      }
      if ((void)v188) {
        (*(void (**)(void))(*(void *)__s2[1] + 40))();
      }
      *(void *)&long long v188 = 0;
      long long v186 = 0uLL;
      __s2[1] = 0;
LABEL_86:
      ++v187;
      goto LABEL_87;
    }
    re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not a vote message %hhu", "!\"Unreachable code\"", "voteRespMsgType", 281, v19);
    _os_crash();
    __break(1u);
    goto LABEL_349;
  }
  if (!*((unsigned char *)v3 + 304))
  {
    re::Raft::hup(a1, 0);
LABEL_88:
    *a3 = 1;
    return;
  }
  int v26 = *(unsigned __int8 *)(a1 + 536);
  switch(*(unsigned char *)(a1 + 536))
  {
    case 0:
      switch(*((unsigned char *)v3 + 304))
      {
        case 2:
          uint64_t v27 = *(void *)(a1 + 1064);
          if (!v27) {
            goto LABEL_64;
          }
          v3[39] = v27;
          re::Message::Message((re::Message *)&v182, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)&v182);
          re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v188 + 8));
          if (__s2[1])
          {
            if ((void)v188) {
              (*(void (**)(void))(*(void *)__s2[1] + 40))();
            }
            *(void *)&long long v188 = 0;
            long long v186 = 0uLL;
            __s2[1] = 0;
            ++v187;
          }
          long long v28 = &v182;
          break;
        case 3:
          *(void *)(a1 + 1096) = 0;
          *(void *)(a1 + 1064) = v3[40];
          re::Raft::handleAppendEntries((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_168;
        case 7:
          *(void *)(a1 + 1096) = 0;
          *(void *)(a1 + 1064) = v3[40];
          re::Raft::handleSnapshot((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_168;
        case 8:
          *(void *)(a1 + 1096) = 0;
          *(void *)(a1 + 1064) = v3[40];
          re::Raft::handleHeartbeat((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_168;
        case 0xD:
          uint64_t v50 = *(void *)(a1 + 1064);
          if (!v50) {
            goto LABEL_168;
          }
          v3[39] = v50;
          re::Message::Message((re::Message *)v173, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)v173);
          re::Snapshot::~Snapshot((re::Snapshot *)&v181);
          if (v176)
          {
            if (v180) {
              (*(void (**)(void))(*(void *)v176 + 40))();
            }
            uint64_t v180 = 0;
            uint64_t v177 = 0;
            uint64_t v178 = 0;
            uint64_t v176 = 0;
            ++v179;
          }
          long long v28 = (__n128 *)v173;
          break;
        case 0xE:
          if (re::Raft::promotable((re::Raft *)a1)) {
            re::Raft::hup(a1, 1);
          }
          goto LABEL_168;
        case 0xF:
          uint64_t v51 = *(void *)(a1 + 1064);
          if (!v51) {
            goto LABEL_168;
          }
          v3[39] = v51;
          re::Message::Message((re::Message *)&v164, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)&v164);
          re::Snapshot::~Snapshot((re::Snapshot *)&v171);
          if (v166[1])
          {
            if (v170) {
              (*(void (**)(void))(*(void *)v166[1] + 40))();
            }
            uint64_t v170 = 0;
            uint64_t v167 = 0;
            uint64_t v168 = 0;
            v166[1] = 0;
            ++v169;
          }
          long long v28 = (__n128 *)&v164;
          break;
        case 0x10:
          if (v3[2] == 1)
          {
            memset(v160, 0, sizeof(v160));
            int v161 = 0;
            uint64_t v52 = v3[43];
            uint64_t v162 = 0;
            uint64_t v163 = v52;
            re::DynamicArray<BOOL>::operator=((uint64_t)v160, (uint64_t *)v3[4]);
            re::DynamicArray<re::ReadState>::add(a1 + 352, v160);
            if (v160[0])
            {
              if (v162) {
                (*(void (**)(void))(*(void *)v160[0] + 40))();
              }
            }
          }
          goto LABEL_168;
        default:
          goto LABEL_168;
      }
      re::DynamicArray<re::Entry>::deinit((uint64_t)v28);
LABEL_168:
      *a3 = 1;
      goto LABEL_88;
    case 1:
    case 3:
      switch(*((unsigned char *)v3 + 304))
      {
        case 2:
LABEL_64:
          *(_WORD *)a3 = 1024;
          return;
        case 3:
          uint64_t v37 = v3[40];
          uint64_t v38 = *(void *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(void *)(a1 + 1064) = v37;
          *(unsigned char *)(a1 + 536) = 0;
          *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v38;
          re::Raft::handleAppendEntries((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_88;
        case 4:
        case 5:
          goto LABEL_88;
        case 6:
          goto LABEL_121;
        case 7:
          uint64_t v39 = v3[40];
          uint64_t v40 = *(void *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(void *)(a1 + 1064) = v39;
          *(unsigned char *)(a1 + 536) = 0;
          *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v40;
          re::Raft::handleSnapshot((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_88;
        case 8:
          uint64_t v41 = v3[40];
          uint64_t v42 = *(void *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(void *)(a1 + 1064) = v41;
          *(unsigned char *)(a1 + 536) = 0;
          *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v42;
          re::Raft::handleHeartbeat((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_88;
        default:
          if (v19 != 18) {
            goto LABEL_88;
          }
LABEL_121:
          if ((v19 == 18 || v26 != 3) && (v19 == 6 || v26 != 1))
          {
            re::Raft::registerVote((re::Raft *)a1, v3[40], *((unsigned char *)v3 + 376) == 0);
            int v36 = re::ProgressSet::candidacyStatus(a1 + 552, a1 + 304);
            if (v36 == 2)
            {
              uint64_t v54 = *(void *)(a1 + 1080);
              re::Raft::reset((re::Raft *)a1, *(void *)(a1 + 1040));
              *(void *)(a1 + 1064) = 0;
              *(unsigned char *)(a1 + 536) = 0;
              *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v54;
            }
            else if (!v36)
            {
              if (*(unsigned char *)(a1 + 536) == 3)
              {
                LOBYTE(v173[0]) = 2;
                re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v182, (char *)v173, 1uLL);
                re::Raft::campaign(a1, (uint64_t)&v182);
                if (v182.n128_u64[0] && __s2[0]) {
                  (*(void (**)(void))(*(void *)v182.n128_u64[0] + 40))();
                }
              }
              else
              {
                re::Raft::becomeLeader((re::Raft *)a1);
                re::Raft::broadcastAppend((re::Raft *)a1);
              }
            }
          }
          break;
      }
      goto LABEL_88;
    case 2:
      re::Message::Message((re::Message *)&v117, (const re::Message *)v3);
      if (v126 <= 0xBu)
      {
        if (v126 != 1)
        {
          if (v126 == 2)
          {
            if (v118)
            {
              re::ProgressSet::voterIds((re::ProgressSet *)(a1 + 552), (uint64_t)&v182);
              BOOL v30 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v182, (uint64_t *)(a1 + 1056));
              re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v182);
              if (!v30 || *(unsigned char *)(a1 + 1024))
              {
                *(_WORD *)a3 = 1024;
                char v31 = 1;
                goto LABEL_342;
              }
              unint64_t v55 = v118;
              if (v118)
              {
                uint64_t v56 = 0;
                unint64_t v57 = 1;
                do
                {
                  uint64_t v58 = &v119[v56];
                  if (LOBYTE(v119[v56 + 10]) == 1)
                  {
                    if (*(void *)(a1 + 1072) > *(void *)(a1 + 296) || *(unsigned char *)(a1 + 856))
                    {
                      long long v59 = &v119[v56];
                      v59[7] = 0;
                      v59[11] = 0;
                      v59[12] = 0;
                      ++*((_DWORD *)v59 + 16);
                      v59[2] = 0;
                      ++*((_DWORD *)v59 + 6);
                      *((unsigned char *)v58 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
                    }
                    else
                    {
                      *(void *)(a1 + 1072) = re::RaftLog::lastIndex((re::RaftLog *)a1) + v57;
                      unint64_t v55 = v118;
                    }
                  }
                  v56 += 13;
                }
                while (v57++ < v55);
              }
              re::Raft::appendEntry(a1, (uint64_t)&v117);
              re::Raft::broadcastAppend((re::Raft *)a1);
              goto LABEL_190;
            }
LABEL_350:
            re::internal::assertLog((re::internal *)4, v29, "assertion failure: '%s' (%s:line %i) stepped empty msgprop", "!\"Unreachable code\"", "stepLeader", 994);
            _os_crash();
            __break(1u);
            JUMPOUT(0x233DA5C98);
          }
          goto LABEL_134;
        }
        re::Raft::broadcastHeartbeat((re::Raft *)a1);
LABEL_190:
        char v31 = 0;
        *a3 = 1;
        goto LABEL_342;
      }
      if (v126 == 12)
      {
        if (!re::ProgressSet::quorumRecentlyActive((re::ProgressSet *)(a1 + 552), *(void *)(a1 + 1056)))
        {
          uint64_t v49 = *(void *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, *(void *)(a1 + 1040));
          *(void *)(a1 + 1064) = 0;
          *(unsigned char *)(a1 + 536) = 0;
          *(void *)(a1 + 108re::InputManager::notify(8, 0, 0, 0) = v49;
        }
        goto LABEL_190;
      }
      if (v126 == 15)
      {
        re::RaftLog::getTerm((re::RaftLog *)a1, *(void *)(a1 + 288), (uint64_t)&v182);
        if (v182.n128_u8[0]) {
          unint64_t v33 = v182.n128_u64[1];
        }
        else {
          unint64_t v33 = 0;
        }
        if (v33 != *(void *)(a1 + 1040)) {
          goto LABEL_190;
        }
        *(_OWORD *)float32x4_t v166 = 0u;
        long long v165 = 0u;
        long long v164 = 0u;
        HIDWORD(v166[0]) = 0x7FFFFFFF;
        long long v34 = (void *)(a1 + 1056);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v164, (uint64_t *)(a1 + 1056));
        if (re::ProgressSet::hasQuorum(a1 + 552, (uint64_t)&v164))
        {
          if (!v127[0] || v127[0] == *v34)
          {
            __n128 v182 = 0uLL;
            int v184 = 0;
            uint64_t v183 = 0;
            long long v35 = *(void **)(a1 + 288);
LABEL_228:
            __s2[0] = 0;
            __s2[1] = v35;
            re::DynamicArray<BOOL>::operator=((uint64_t)&v182, v119);
            re::DynamicArray<re::ReadState>::add(a1 + 352, (uint64_t *)&v182);
            uint64_t v53 = v182.n128_u64[0];
            if (!v182.n128_u64[0] || !__s2[0]) {
              goto LABEL_234;
            }
            goto LABEL_230;
          }
          __n128 v182 = 0uLL;
          int v184 = 0;
          uint64_t v183 = 0;
          *(_OWORD *)__s2 = 0u;
          long long v186 = 0u;
          int v187 = 0;
          long long v200 = 0u;
          long long v201 = 0u;
          long long v188 = 0u;
          long long v189 = 0u;
          long long v190 = 0u;
          long long v191 = 0u;
          long long v192 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v197 = 0u;
          long long v198 = 0u;
          long long v199 = 0u;
          uint64_t v202 = 0;
          memset(v207, 0, 25);
          long long v206 = 0u;
          long long v205 = 0u;
          char v203 = 16;
          unint64_t v204 = v127[0];
          long long v35 = *(void **)(a1 + 288);
        }
        else
        {
          if (*(unsigned char *)(a1 + 528) != 1)
          {
            if (*(unsigned char *)(a1 + 528)) {
              goto LABEL_234;
            }
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)v173, v119);
            re::ReadOnly::addRequest((re::ReadOnly *)(a1 + 432), *(void *)(a1 + 288), (const re::Message *)&v117);
            v182.n128_u8[0] = 1;
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v182.n128_i64[1], v173);
            re::Raft::broadcastHeatbeatWithCtx(a1, &v182);
            if (v182.n128_u8[0] && v182.n128_u64[1] && __s2[1]) {
              (*(void (**)(void))(*(void *)v182.n128_u64[1] + 40))();
            }
            uint64_t v53 = v173[0];
            if (!v173[0] || !v175) {
              goto LABEL_234;
            }
LABEL_230:
            (*(void (**)(uint64_t))(*(void *)v53 + 40))(v53);
LABEL_234:
            *a3 = 1;
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v164);
            goto LABEL_341;
          }
          long long v35 = *(void **)(a1 + 288);
          if (!v127[0] || v127[0] == *v34)
          {
            uint64_t v183 = 0;
            __n128 v182 = 0uLL;
            int v184 = 0;
            goto LABEL_228;
          }
          __n128 v182 = 0uLL;
          int v184 = 0;
          uint64_t v183 = 0;
          *(_OWORD *)__s2 = 0u;
          long long v186 = 0u;
          int v187 = 0;
          long long v200 = 0u;
          long long v201 = 0u;
          long long v188 = 0u;
          long long v189 = 0u;
          long long v190 = 0u;
          long long v191 = 0u;
          long long v192 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v197 = 0u;
          long long v198 = 0u;
          long long v199 = 0u;
          uint64_t v202 = 0;
          memset(v207, 0, 25);
          long long v206 = 0u;
          long long v205 = 0u;
          char v203 = 16;
          unint64_t v204 = v127[0];
        }
        *((void *)&v206 + 1) = v35;
        re::DynamicArray<re::Entry>::operator=(&v182, &v117);
        re::Message::Message((re::Message *)v173, (const re::Message *)&v182);
        re::Raft::send(a1, (uint64_t)v173);
        re::Message::~Message((re::Message *)v173);
        re::Message::~Message((re::Message *)&v182);
        goto LABEL_234;
      }
LABEL_134:
      LOBYTE(v160[0]) = 0;
      char v172 = 0;
      v166[0] = 0;
      *(void *)&long long v165 = 0;
      long long v164 = 0uLL;
      long long v43 = (void *)(a1 + 552);
      DWORD2(v165) = 0;
      if (re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a1 + 552, (uint64_t *)v127))
      {
        hasQuoruuint64_t m = 0;
        switch(v126)
        {
          case 4u:
            LODWORD(v45) = 0x7FFFFFFF;
            if (!*v43) {
              goto LABEL_236;
            }
            unint64_t v46 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v127[0] ^ (v127[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v127[0] ^ (v127[0] >> 30))) >> 27));
            uint64_t v47 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v46 ^ (v46 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v47 == 0x7FFFFFFF) {
              goto LABEL_236;
            }
            uint64_t v48 = *(void *)(a1 + 568);
            LODWORD(v45) = v47;
            if (*(void *)(v48 + 136 * v47 + 16) == v127[0]) {
              goto LABEL_236;
            }
            uint64_t v45 = v47;
            while (1)
            {
              LODWORD(v45) = *(_DWORD *)(v48 + 136 * v45 + 8) & 0x7FFFFFFF;
              if (v45 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v48 + 136 * v45 + 16) == v127[0]) {
                goto LABEL_236;
              }
            }
            LODWORD(v45) = 0x7FFFFFFF;
LABEL_236:
            uint64_t v79 = *(void *)(a1 + 568);
            unsigned int v80 = v45;
            uint64_t v81 = v79 + 136 * v45;
            uint64_t v82 = v81 + 24;
            *(unsigned char *)(v81 + 129) = 1;
            if (v131)
            {
              if (!re::Progress::maybeDecrementTo((re::Progress *)v82, v128, v130, v129)) {
                goto LABEL_308;
              }
              if (*(unsigned char *)(v79 + 136 * v80 + 88) == 1) {
                re::Progress::becomeProbe(v82);
              }
              hasQuoruuint64_t m = 0;
              uint64_t v83 = v160;
LABEL_303:
              *(unsigned char *)uint64_t v83 = 1;
              goto LABEL_309;
            }
            if (*(unsigned char *)(v81 + 88) == 1)
            {
              hasQuoruuint64_t m = *(void *)(v81 + 72) == *(void *)(v81 + 80);
            }
            else if (*(unsigned char *)(v81 + 88))
            {
              hasQuoruuint64_t m = 1;
            }
            else
            {
              hasQuoruuint64_t m = *(unsigned char *)(v81 + 128) != 0;
            }
            unint64_t v84 = v128;
            unint64_t v85 = *(void *)(v82 + 72);
            if (v85 < v128)
            {
              *(void *)(v82 + 72) = v128;
              *(unsigned char *)(v82 + 104) = 0;
            }
            if (*(void *)(v82 + 80) < v84 + 1) {
              *(void *)(v82 + 8re::InputManager::notify(8, 0, 0, 0) = v84 + 1;
            }
            if (v85 < v84)
            {
              if (*(unsigned char *)(a1 + 1024))
              {
                uint64_t Index = re::RaftLog::lastIndex((re::RaftLog *)a1);
                if (v127[0] == *(void *)(a1 + 1032) && *(void *)(v79 + 136 * v80 + 96) == Index) {
                  re::Raft::sendTimeoutNow((re::Raft *)a1, v127[0]);
                }
              }
              int v87 = *(unsigned __int8 *)(v79 + 136 * v80 + 88);
              if (v87 == 2)
              {
                if (*(void *)(v79 + 136 * v80 + 96) < *(void *)(v79 + 136 * v80 + 112)) {
                  goto LABEL_309;
                }
                re::Progress::becomeProbe(v82);
              }
              else if (v87 == 1)
              {
                re::Inflights::freeTo((void *)v82, v128);
              }
              else if (!*(unsigned char *)(v79 + 136 * v80 + 88))
              {
                *(unsigned char *)(v82 + 104) = 0;
                *(unsigned char *)(v82 + 64) = 1;
                *(void *)(v82 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
                *(void *)(v82 + 48) = 0;
                *(void *)(v82 + 8re::InputManager::notify(8, 0, 0, 0) = *(void *)(v82 + 72) + 1;
                *(void *)(v82 + 88) = 0;
              }
              uint64_t v83 = (uint64_t *)&v172;
              goto LABEL_303;
            }
LABEL_309:
            v182.n128_u8[0] = 1;
            re::ProgressSet::ProgressSet((re::ProgressSet *)&v182.n128_i8[8], (const re::ProgressSet *)(a1 + 552));
            re::Optional<re::ProgressSet>::operator=((unsigned char *)(a1 + 544), (uint64_t *)&v182);
            if (v182.n128_u8[0]) {
              re::ProgressSet::~ProgressSet((re::ProgressSet *)&v182.n128_i8[8]);
            }
            if (!v172) {
              goto LABEL_317;
            }
            unint64_t v107 = re::ProgressSet::maximalCommittedIndex((re::ProgressSet *)(a1 + 552));
            if (re::RaftLog::maybeCommit((re::RaftLog *)a1, v107, *(void *)(a1 + 1040)))
            {
              if (!*(unsigned char *)(a1 + 1155) || *(void *)(a1 + 1072) > *(void *)(a1 + 296) || *(unsigned char *)(a1 + 856)) {
                re::Raft::broadcastAppend((re::Raft *)a1);
              }
              goto LABEL_317;
            }
            if (hasQuorum | LOBYTE(v160[0])) {
              goto LABEL_318;
            }
            break;
          case 9u:
            LODWORD(v61) = 0x7FFFFFFF;
            if (!*v43) {
              goto LABEL_260;
            }
            unint64_t v62 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v127[0] ^ (v127[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v127[0] ^ (v127[0] >> 30))) >> 27));
            uint64_t v63 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v62 ^ (v62 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v63 == 0x7FFFFFFF) {
              goto LABEL_260;
            }
            uint64_t v64 = *(void *)(a1 + 568);
            LODWORD(v61) = v63;
            if (*(void *)(v64 + 136 * v63 + 16) == v127[0]) {
              goto LABEL_260;
            }
            uint64_t v61 = v63;
            while (1)
            {
              LODWORD(v61) = *(_DWORD *)(v64 + 136 * v61 + 8) & 0x7FFFFFFF;
              if (v61 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v64 + 136 * v61 + 16) == v127[0]) {
                goto LABEL_260;
              }
            }
            LODWORD(v61) = 0x7FFFFFFF;
LABEL_260:
            uint64_t v88 = *(void *)(a1 + 568);
            unsigned int v89 = v61;
            uint64_t v90 = v88 + 136 * v61;
            *(_WORD *)(v90 + 128) = 256;
            if (*(unsigned char *)(v90 + 88) == 1 && *(void *)(v90 + 72) == *(void *)(v90 + 80)) {
              re::Inflights::freeFirstOne((re::Inflights *)(v90 + 24));
            }
            uint64_t v91 = v88 + 136 * v89;
            unint64_t v92 = *(void *)(v91 + 96);
            if (v92 < re::RaftLog::lastIndex((re::RaftLog *)a1) || *(void *)(v91 + 120) != 0) {
              LOBYTE(v160[0]) = 1;
            }
            hasQuoruuint64_t m = 0;
            if (!*(unsigned char *)(a1 + 528))
            {
              if (v122)
              {
                re::ReadOnly::recvAck((re::ReadOnly *)(a1 + 432), (const re::Message *)&v117, (uint64_t)&v182);
                hasQuoruuint64_t m = re::ProgressSet::hasQuorum(a1 + 552, (uint64_t)&v182);
                re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v182);
                if (hasQuorum)
                {
                  re::ReadOnly::advance((re::ReadOnly *)(a1 + 432), (const re::Message *)&v117, (uint64_t)v173);
                  if (v174)
                  {
                    long long v94 = v175;
                    uint64_t v95 = 440 * v174;
                    do
                    {
                      unint64_t v96 = *((void *)v94 + 46);
                      if (v96 && v96 != *(void *)(a1 + 1056))
                      {
                        __n128 v182 = 0uLL;
                        int v184 = 0;
                        uint64_t v183 = 0;
                        *(_OWORD *)__s2 = 0u;
                        long long v186 = 0u;
                        int v187 = 0;
                        long long v188 = 0u;
                        long long v189 = 0u;
                        long long v190 = 0u;
                        long long v191 = 0u;
                        long long v192 = 0u;
                        long long v193 = 0u;
                        long long v194 = 0u;
                        long long v195 = 0u;
                        long long v196 = 0u;
                        long long v197 = 0u;
                        long long v198 = 0u;
                        long long v199 = 0u;
                        long long v200 = 0u;
                        long long v201 = 0u;
                        uint64_t v202 = 0;
                        long long v206 = 0u;
                        memset(v207, 0, 25);
                        long long v205 = 0u;
                        char v203 = 16;
                        unint64_t v204 = v96;
                        *((void *)&v206 + 1) = *((void *)v94 + 54);
                        re::DynamicArray<re::Entry>::operator=(&v182, (__n128 *)v94 + 3);
                        re::DynamicArray<re::Message>::add((uint64_t)&v164, (re::Message *)&v182);
                        re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v188 + 8));
                        if (__s2[1])
                        {
                          if ((void)v188) {
                            (*(void (**)(void))(*(void *)__s2[1] + 40))();
                          }
                          *(void *)&long long v188 = 0;
                          long long v186 = 0uLL;
                          __s2[1] = 0;
                          ++v187;
                        }
                        re::DynamicArray<re::Entry>::deinit((uint64_t)&v182);
                      }
                      else
                      {
                        __n128 v182 = 0uLL;
                        int v184 = 0;
                        uint64_t v183 = 0;
                        __s2[0] = 0;
                        __s2[1] = *((void **)v94 + 54);
                        re::DynamicArray<BOOL>::operator=((uint64_t)&v182, *((uint64_t **)v94 + 10));
                        re::DynamicArray<re::ReadState>::add(a1 + 352, (uint64_t *)&v182);
                        if (v182.n128_u64[0] && __s2[0]) {
                          (*(void (**)(void))(*(void *)v182.n128_u64[0] + 40))();
                        }
                      }
                      long long v94 = (re::ReadIndexStatus *)((char *)v94 + 440);
                      v95 -= 440;
                    }
                    while (v95);
                  }
                  uint64_t v97 = v173[0];
                  if (v173[0])
                  {
                    float32x4_t v98 = v175;
                    if (v175)
                    {
                      if (v174)
                      {
                        uint64_t v99 = 440 * v174;
                        do
                        {
                          re::ReadIndexStatus::~ReadIndexStatus(v98);
                          float32x4_t v98 = (re::ReadIndexStatus *)((char *)v98 + 440);
                          v99 -= 440;
                        }
                        while (v99);
                        uint64_t v97 = v173[0];
                        float32x4_t v98 = v175;
                      }
                      (*(void (**)(uint64_t, re::ReadIndexStatus *))(*(void *)v97 + 40))(v97, v98);
                    }
                  }
                  goto LABEL_308;
                }
              }
            }
            goto LABEL_309;
          case 0xAu:
            LODWORD(v65) = 0x7FFFFFFF;
            if (!*v43) {
              goto LABEL_292;
            }
            unint64_t v66 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v127[0] ^ (v127[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v127[0] ^ (v127[0] >> 30))) >> 27));
            uint64_t v67 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v66 ^ (v66 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v67 == 0x7FFFFFFF) {
              goto LABEL_292;
            }
            uint64_t v68 = *(void *)(a1 + 568);
            LODWORD(v65) = v67;
            if (*(void *)(v68 + 136 * v67 + 16) == v127[0]) {
              goto LABEL_292;
            }
            uint64_t v65 = v67;
            while (1)
            {
              LODWORD(v65) = *(_DWORD *)(v68 + 136 * v65 + 8) & 0x7FFFFFFF;
              if (v65 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v68 + 136 * v65 + 16) == v127[0]) {
                goto LABEL_292;
              }
            }
            LODWORD(v65) = 0x7FFFFFFF;
LABEL_292:
            uint64_t v100 = *(void *)(a1 + 568);
            if (*(unsigned char *)(v100 + 136 * v65 + 88) == 1) {
              re::Progress::becomeProbe(v100 + 136 * v65 + 24);
            }
            goto LABEL_308;
          case 0xBu:
            LODWORD(v69) = 0x7FFFFFFF;
            if (!*v43) {
              goto LABEL_295;
            }
            unint64_t v70 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v127[0] ^ (v127[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v127[0] ^ (v127[0] >> 30))) >> 27));
            uint64_t v71 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v70 ^ (v70 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v71 == 0x7FFFFFFF) {
              goto LABEL_295;
            }
            uint64_t v72 = *(void *)(a1 + 568);
            LODWORD(v69) = v71;
            if (*(void *)(v72 + 136 * v71 + 16) == v127[0]) {
              goto LABEL_295;
            }
            uint64_t v69 = v71;
            while (1)
            {
              LODWORD(v69) = *(_DWORD *)(v72 + 136 * v69 + 8) & 0x7FFFFFFF;
              if (v69 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v72 + 136 * v69 + 16) == v127[0]) {
                goto LABEL_295;
              }
            }
            LODWORD(v69) = 0x7FFFFFFF;
LABEL_295:
            uint64_t v101 = *(void *)(a1 + 568);
            uint64_t v102 = v101 + 136 * v69;
            if (*(unsigned char *)(v102 + 88) != 2) {
              goto LABEL_308;
            }
            unsigned int v103 = v69;
            if (v131) {
              *(void *)(v101 + 136 * v69 + 112) = 0;
            }
            re::Progress::becomeProbe(v102 + 24);
            hasQuoruuint64_t m = 0;
            uint64_t v104 = v101 + 136 * v103;
            *(unsigned char *)(v104 + 128) = 1;
            *(void *)(v104 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
            goto LABEL_309;
          case 0xDu:
            v173[0] = v127[0];
            re::ProgressSet::learnerIds((re::ProgressSet *)(a1 + 552), (uint64_t)&v182);
            BOOL v73 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v182, v173);
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v182);
            if (v73) {
              goto LABEL_308;
            }
            unint64_t v74 = v173[0];
            if (!*(unsigned char *)(a1 + 1024)) {
              goto LABEL_217;
            }
            if (*(void *)(a1 + 1032) == v173[0]) {
              goto LABEL_308;
            }
            *(unsigned char *)(a1 + 1024) = 0;
LABEL_217:
            if (v74 == *(void *)(a1 + 1056)) {
              goto LABEL_308;
            }
            *(void *)(a1 + 1096) = 0;
            *(unsigned char *)(a1 + 1024) = 1;
            *(void *)(a1 + 1032) = v74;
            LODWORD(v75) = 0x7FFFFFFF;
            if (!*(void *)(a1 + 552)) {
              goto LABEL_305;
            }
            unint64_t v76 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v74 ^ (v74 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v74 ^ (v74 >> 30))) >> 27));
            uint64_t v77 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v76 ^ (v76 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v77 == 0x7FFFFFFF) {
              goto LABEL_305;
            }
            uint64_t v78 = *(void *)(a1 + 568);
            LODWORD(v75) = v77;
            if (*(void *)(v78 + 136 * v77 + 16) == v74) {
              goto LABEL_305;
            }
            uint64_t v75 = v77;
            while (1)
            {
              LODWORD(v75) = *(_DWORD *)(v78 + 136 * v75 + 8) & 0x7FFFFFFF;
              if (v75 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v78 + 136 * v75 + 16) == v74) {
                goto LABEL_305;
              }
            }
            LODWORD(v75) = 0x7FFFFFFF;
LABEL_305:
            uint64_t v105 = *(void *)(a1 + 568);
            uint64_t v106 = *(void *)(v105 + 136 * v75 + 96);
            if (v106 == re::RaftLog::lastIndex((re::RaftLog *)a1)) {
              re::Raft::sendTimeoutNow((re::Raft *)a1, v74);
            }
            else {
              re::Raft::sendAppend((re::Raft *)a1, v74, (re::Progress *)(v105 + 136 * v75 + 24));
            }
LABEL_308:
            hasQuoruuint64_t m = 0;
            goto LABEL_309;
          default:
            goto LABEL_309;
        }
      }
      else
      {
LABEL_317:
        if (LOBYTE(v160[0]))
        {
LABEL_318:
          LODWORD(v108) = 0x7FFFFFFF;
          if (*v43)
          {
            unint64_t v109 = 0x94D049BB133111EBLL
                 * ((0xBF58476D1CE4E5B9 * (v127[0] ^ (v127[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                           * (v127[0] ^ (v127[0] >> 30))) >> 27));
            uint64_t v110 = *(unsigned int *)(*(void *)(a1 + 560) + 4 * ((v109 ^ (v109 >> 31)) % *(unsigned int *)(a1 + 576)));
            if (v110 != 0x7FFFFFFF)
            {
              uint64_t v111 = *(void *)(a1 + 568);
              LODWORD(v108) = v110;
              if (*(void *)(v111 + 136 * v110 + 16) != v127[0])
              {
                uint64_t v108 = v110;
                while (1)
                {
                  LODWORD(v108) = *(_DWORD *)(v111 + 136 * v108 + 8) & 0x7FFFFFFF;
                  if (v108 == 0x7FFFFFFF) {
                    break;
                  }
                  if (*(void *)(v111 + 136 * v108 + 16) == v127[0]) {
                    goto LABEL_328;
                  }
                }
                LODWORD(v108) = 0x7FFFFFFF;
              }
            }
          }
LABEL_328:
          re::Raft::sendAppend((re::Raft *)a1, v127[0], (re::Progress *)(*(void *)(a1 + 568) + 136 * v108 + 24));
          v182.n128_u8[0] = 1;
          re::ProgressSet::ProgressSet((re::ProgressSet *)&v182.n128_i8[8], (const re::ProgressSet *)(a1 + 552));
          re::Optional<re::ProgressSet>::operator=((unsigned char *)(a1 + 544), (uint64_t *)&v182);
          if (v182.n128_u8[0]) {
            re::ProgressSet::~ProgressSet((re::ProgressSet *)&v182.n128_i8[8]);
          }
        }
      }
      uint64_t v112 = v165;
      if ((void)v165)
      {
        int v113 = v166[0];
        uint64_t v114 = 384 * v165;
        uint64_t v115 = v166[0];
        do
        {
          re::Message::Message((re::Message *)&v182, v115);
          re::Raft::send(a1, (uint64_t)&v182);
          re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v188 + 8));
          if (__s2[1])
          {
            if ((void)v188) {
              (*(void (**)(void))(*(void *)__s2[1] + 40))();
            }
            *(void *)&long long v188 = 0;
            long long v186 = 0uLL;
            __s2[1] = 0;
            ++v187;
          }
          re::DynamicArray<re::Entry>::deinit((uint64_t)&v182);
          uint64_t v115 = (const re::Message *)((char *)v115 + 384);
          v114 -= 384;
        }
        while (v114);
        *(void *)&long long v165 = 0;
        uint64_t v116 = 384 * v112;
        do
        {
          re::Snapshot::~Snapshot((re::Message *)((char *)v113 + 80));
          re::DynamicArray<unsigned long>::deinit((uint64_t)v113 + 40);
          re::DynamicArray<re::Entry>::deinit((uint64_t)v113);
          int v113 = (re::Message *)((char *)v113 + 384);
          v116 -= 384;
        }
        while (v116);
        ++DWORD2(v165);
      }
      *a3 = 1;
      re::DynamicArray<re::Message>::deinit((uint64_t)&v164);
LABEL_341:
      char v31 = 0;
LABEL_342:
      re::Snapshot::~Snapshot((re::Snapshot *)&v125);
      if (v120)
      {
        if (v124) {
          (*(void (**)(void))(*(void *)v120 + 40))();
        }
        uint64_t v124 = 0;
        uint64_t v121 = 0;
        uint64_t v122 = 0;
        uint64_t v120 = 0;
        ++v123;
      }
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v117);
      if ((v31 & 1) == 0) {
        goto LABEL_88;
      }
      return;
    default:
      goto LABEL_88;
  }
}

uint64_t re::Raft::hup(uint64_t this, int a2)
{
  if (*(unsigned char *)(this + 536) != 2)
  {
    uint64_t v3 = this;
    uint64_t v4 = 264;
    if (!*(unsigned char *)(this + 48)) {
      uint64_t v4 = 296;
    }
    re::RaftLog::slice((re::RaftLog *)this, *(void *)(this + v4) + 1, *(void *)(this + 288) + 1, &v10);
    re::DynamicArray<re::Entry>::DynamicArray(&v12, &v10.n128_u64[1]);
    if (v10.n128_u8[0]) {
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v10.n128_i64[1]);
    }
    if (!v13) {
      goto LABEL_12;
    }
    uint64_t v5 = 0;
    uint64_t v6 = 104 * v13;
    unint64_t v7 = (unsigned __int8 *)(v14 + 80);
    do
    {
      int v8 = *v7;
      v7 += 104;
      if (v8 == 1) {
        ++v5;
      }
      v6 -= 104;
    }
    while (v6);
    if (!v5)
    {
LABEL_12:
      if (a2)
      {
        char v9 = 0;
      }
      else if (*(unsigned char *)(v3 + 1154))
      {
        char v9 = 1;
      }
      else
      {
        char v9 = 2;
      }
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v10, &v9, 1uLL);
      re::Raft::campaign(v3, (uint64_t)&v10);
      if (v10.n128_u64[0])
      {
        if (v11) {
          (*(void (**)(void))(*(void *)v10.n128_u64[0] + 40))();
        }
      }
    }
    return re::DynamicArray<re::Entry>::deinit((uint64_t)&v12);
  }
  return this;
}

void re::Raft::campaign(uint64_t a1, uint64_t a2)
{
  LOBYTE(v50[0]) = 1;
  re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v37, (char *)v50, 1uLL);
  size_t v4 = *(void *)(a2 + 16);
  BOOL v5 = v4 == v38 && memcmp(*(const void **)(a2 + 32), (const void *)__s2, v4) == 0;
  if (v37[0] && (void)__s2) {
    (*(void (**)(void))(*(void *)v37[0] + 40))();
  }
  if (v5)
  {
    *(unsigned char *)(a1 + 536) = 3;
    re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 304);
    *(void *)(a1 + 1064) = 0;
    uint64_t v24 = *(void *)(a1 + 1040) + 1;
    unint64_t v6 = *(void *)(a1 + 1056);
    char v7 = 17;
  }
  else
  {
    re::Raft::reset((re::Raft *)a1, *(void *)(a1 + 1040) + 1);
    unint64_t v6 = *(void *)(a1 + 1056);
    *(void *)(a1 + 1048) = v6;
    *(unsigned char *)(a1 + 536) = 1;
    uint64_t v24 = *(void *)(a1 + 1040);
    char v7 = 5;
  }
  char v23 = v7;
  unint64_t v25 = v6;
  re::Raft::registerVote((re::Raft *)a1, v6, 1);
  if (re::ProgressSet::candidacyStatus(a1 + 552, a1 + 304))
  {
    re::ProgressSet::voterIds((re::ProgressSet *)(a1 + 552), (uint64_t)v50);
    unsigned int v8 = v52;
    uint64_t v26 = a2;
    uint64_t v9 = 0;
    if (v52)
    {
      __n128 v10 = (int *)(v51 + 8);
      unint64_t v11 = v25;
      while (1)
      {
        int v12 = *v10;
        v10 += 6;
        if (v12 < 0) {
          break;
        }
        if (v52 == ++v9)
        {
          LODWORD(v9) = v52;
          break;
        }
      }
    }
    else
    {
      unint64_t v11 = v25;
    }
    if (v52 != v9)
    {
      uint64_t v15 = v9;
      uint64_t v16 = v51;
      unsigned int v17 = v52;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24 * v15 + 16);
        if (v18 != v11)
        {
          v37[0] = 0;
          v37[1] = 0;
          int v39 = 0;
          uint64_t v38 = 0;
          long long __s2 = 0u;
          long long v41 = 0u;
          int v42 = 0;
          memset(v43, 0, sizeof(v43));
          long long v48 = 0u;
          memset(v49, 0, sizeof(v49));
          uint64_t v46 = 0;
          char v44 = v23;
          uint64_t v45 = v18;
          uint64_t v47 = v24;
          *((void *)&v48 + 1) = re::RaftLog::lastIndex((re::RaftLog *)a1);
          *(void *)&long long v48 = re::RaftLog::lastTerm((re::RaftLog *)a1);
          char v34 = 0;
          re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v35, &v34, 1uLL);
          BOOL v19 = 0;
          size_t v20 = *(void *)(v26 + 16);
          if (v20 == v35[2]) {
            BOOL v19 = memcmp(*(const void **)(v26 + 32), v36, v20) == 0;
          }
          if (v35[0] && v36) {
            (*(void (**)(void))(*(void *)v35[0] + 40))();
          }
          if (v19) {
            re::DynamicArray<BOOL>::operator=((uint64_t)&__s2 + 8, (uint64_t *)v26);
          }
          re::Message::Message((re::Message *)v27, (const re::Message *)v37);
          re::Raft::send(a1, (uint64_t)v27);
          re::Snapshot::~Snapshot((re::Snapshot *)&v33);
          if (v28)
          {
            if (v32) {
              (*(void (**)(void))(*(void *)v28 + 40))();
            }
            uint64_t v32 = 0;
            uint64_t v29 = 0;
            uint64_t v30 = 0;
            uint64_t v28 = 0;
            ++v31;
          }
          re::DynamicArray<re::Entry>::deinit((uint64_t)v27);
          re::Snapshot::~Snapshot((re::Snapshot *)&v43[1]);
          if (*((void *)&__s2 + 1))
          {
            if (v43[0]) {
              (*(void (**)(void))(**((void **)&__s2 + 1) + 40))();
            }
            v43[0] = 0;
            long long v41 = 0uLL;
            *((void *)&__s2 + 1) = 0;
            ++v42;
          }
          re::DynamicArray<re::Entry>::deinit((uint64_t)v37);
          unsigned int v17 = v52;
          uint64_t v16 = v51;
          unint64_t v11 = v25;
        }
        if (v17 <= (int)v9 + 1) {
          unsigned int v21 = v9 + 1;
        }
        else {
          unsigned int v21 = v17;
        }
        while (1)
        {
          uint64_t v15 = (v9 + 1);
          if (v21 - 1 == v9) {
            break;
          }
          LODWORD(v9) = v9 + 1;
          unsigned int v22 = v15;
          if ((*(_DWORD *)(v16 + 24 * v15 + 8) & 0x80000000) != 0) {
            goto LABEL_45;
          }
        }
        unsigned int v22 = v21;
LABEL_45:
        LODWORD(v9) = v22;
      }
      while (v8 != v22);
    }
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v50);
  }
  else
  {
    LOBYTE(v50[0]) = 1;
    re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v37, (char *)v50, 1uLL);
    size_t v13 = *(void *)(a2 + 16);
    BOOL v14 = v13 == v38 && memcmp(*(const void **)(a2 + 32), (const void *)__s2, v13) == 0;
    if (v37[0] && (void)__s2) {
      (*(void (**)(void))(*(void *)v37[0] + 40))();
    }
    if (v14)
    {
      LOBYTE(v50[0]) = 2;
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v37, (char *)v50, 1uLL);
      re::Raft::campaign(a1, v37);
      if (v37[0] && (void)__s2) {
        (*(void (**)(void))(*(void *)v37[0] + 40))();
      }
    }
    else
    {
      re::Raft::becomeLeader((re::Raft *)a1);
    }
  }
}

void re::Raft::registerVote(re::Raft *this, unint64_t a2, char a3)
{
  unint64_t v6 = *((void *)this + 38);
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v9 = *(unsigned int *)(*((void *)this + 39) + 4 * (v8 % *((unsigned int *)this + 82)));
  if (v9 != 0x7FFFFFFF)
  {
    uint64_t v15 = *((void *)this + 40);
    if (*(void *)(v15 + 32 * v9 + 16) == a2) {
      return;
    }
    while (1)
    {
      uint64_t v9 = *(_DWORD *)(v15 + 32 * v9 + 8) & 0x7FFFFFFF;
      if (v9 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v15 + 32 * v9 + 16) == a2) {
        return;
      }
    }
  }
  unint64_t v6 = v8 % *((unsigned int *)this + 82);
  uint64_t v10 = *(unsigned int *)(*((void *)this + 39) + 4 * v6);
  if (v10 == 0x7FFFFFFF) {
    goto LABEL_4;
  }
  uint64_t v17 = *((void *)this + 40);
  if (*(void *)(v17 + 32 * v10 + 16) != a2)
  {
    while (1)
    {
      uint64_t v10 = *(_DWORD *)(v17 + 32 * v10 + 8) & 0x7FFFFFFF;
      if (v10 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v17 + 32 * v10 + 16) == a2) {
        goto LABEL_19;
      }
    }
LABEL_4:
    uint64_t v11 = *((unsigned int *)this + 85);
    if (v11 == 0x7FFFFFFF)
    {
      uint64_t v11 = *((unsigned int *)this + 84);
      int v12 = v11;
      if (v11 == *((_DWORD *)this + 82))
      {
        re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)this + 304, 2 * *((_DWORD *)this + 83));
        LODWORD(v6) = v8 % *((unsigned int *)this + 82);
        int v12 = *((_DWORD *)this + 84);
      }
      *((_DWORD *)this + 84) = v12 + 1;
      uint64_t v13 = *((void *)this + 40);
      int v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
    }
    else
    {
      uint64_t v13 = *((void *)this + 40);
      int v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
      *((_DWORD *)this + 85) = v14 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v13 + 32 * v11 + 8) = v14 | 0x80000000;
    uint64_t v16 = *((void *)this + 39);
    *(_DWORD *)(*((void *)this + 40) + 32 * v11 + 8) = *(_DWORD *)(*((void *)this + 40) + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v6);
    *(void *)(*((void *)this + 40) + 32 * v11) = v8;
    *(void *)(*((void *)this + 40) + 32 * v11 + 16) = a2;
    *(unsigned char *)(*((void *)this + 40) + 32 * v11 + 24) = a3;
    *(_DWORD *)(v16 + 4 * v6) = v11;
    ++*((_DWORD *)this + 83);
    goto LABEL_14;
  }
LABEL_19:
  *(unsigned char *)(v17 + 32 * v10 + 24) = a3;
LABEL_14:
  ++*((_DWORD *)this + 86);
}

unsigned char *re::Raft::finalizeMembershipChange@<X0>(unsigned char *result@<X0>, uint64_t a2@<X1>, __int16 *a3@<X8>)
{
  if (*(unsigned char *)(a2 + 120) != 4 || *(unsigned char *)(a2 + 152))
  {
    __int16 v4 = 2560;
LABEL_4:
    *a3 = v4;
    return result;
  }
  BOOL v5 = result;
  if (!result[640])
  {
    __int16 v4 = 3584;
    goto LABEL_4;
  }
  if (!re::Configuration::contains((re::Configuration *)(result + 648), *((void *)result + 133)))
  {
    Teruint64_t m = re::RaftLog::lastTerm((re::RaftLog *)v5);
    if (v5[536] == 2)
    {
      uint64_t v7 = *((void *)v5 + 135);
      re::Raft::reset((re::Raft *)v5, Term);
      *((void *)v5 + 133) = 0;
      v5[536] = 0;
      *((void *)v5 + 135) = v7;
    }
    else
    {
      *((void *)v5 + 133) = 0;
    }
  }
  re::ProgressSet::finalizeMembershipChange((re::ProgressSet *)(v5 + 552), (uint64_t)v10);
  if (v10[0])
  {
    v9[0] = 0;
    re::Optional<re::ConfChange>::operator=(v5 + 856, v9);
    BOOL result = re::Optional<re::ConfChange>::~Optional(v9);
    int v8 = v10[0];
    *(unsigned char *)a3 = 1;
    if (v8) {
      return result;
    }
  }
  else
  {
    *a3 = 3584;
  }
  BOOL result = v11;
  if (v11)
  {
    if (v12) {
      return (unsigned char *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
    }
  }
  return result;
}

BOOL re::Configuration::contains(re::Configuration *this, uint64_t a2)
{
  uint64_t v4 = a2;
  return re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this, &v4)|| re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 48, &v4);
}

uint64_t re::Raft::sendTimeoutNow(re::Raft *this, uint64_t a2)
{
  memset(v11, 0, sizeof(v11));
  int v12 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  int v15 = 0;
  memset(v16, 0, sizeof(v16));
  long long v20 = 0u;
  memset(v21, 0, sizeof(v21));
  long long v19 = 0u;
  uint64_t v18 = a2;
  char v17 = 14;
  re::Message::Message((re::Message *)v4, (const re::Message *)v11);
  re::Raft::send((uint64_t)this, (uint64_t)v4);
  re::Snapshot::~Snapshot((re::Snapshot *)&v10);
  if (v5)
  {
    if (v9) {
      (*(void (**)(void))(*(void *)v5 + 40))();
    }
    uint64_t v9 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v5 = 0;
    ++v8;
  }
  re::DynamicArray<re::Entry>::deinit((uint64_t)v4);
  re::Snapshot::~Snapshot((re::Snapshot *)&v16[1]);
  if (*((void *)&v13 + 1))
  {
    if (v16[0]) {
      (*(void (**)(void))(**((void **)&v13 + 1) + 40))();
    }
    v16[0] = 0;
    long long v14 = 0uLL;
    *((void *)&v13 + 1) = 0;
    ++v15;
  }
  return re::DynamicArray<re::Entry>::deinit((uint64_t)v11);
}

uint64_t re::DynamicArray<re::ReadState>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::ReadState>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::ReadState>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t result = re::DynamicArray<BOOL>::DynamicArray(*(void *)(a1 + 32) + 48 * v5, a2);
  *(void *)(result + 4re::InputManager::notify(8, 0, 0, 0) = a2[5];
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

BOOL re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 136 * v4 + 16) == v2) {
    return 1;
  }
  do
  {
    LODWORD(v4) = *(_DWORD *)(v6 + 136 * v4 + 8) & 0x7FFFFFFF;
    BOOL result = v4 != 0x7FFFFFFF;
  }
  while (v4 != 0x7FFFFFFF && *(void *)(v6 + 136 * v4 + 16) != v2);
  return result;
}

uint64_t re::Raft::handleAppendEntries(re::Raft *this, const re::Message *a2)
{
  if (*((void *)this + 135))
  {
    return re::Raft::sendRequestSnapshot(this);
  }
  unint64_t v5 = *((void *)a2 + 43);
  unint64_t v6 = *((void *)this + 36);
  if (v5 < v6)
  {
    uint64_t v26 = 0;
    uint64_t v25 = 0;
    int v28 = 0;
    uint64_t v27 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    int v31 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    uint64_t v46 = 0;
    memset(v51, 0, 25);
    long long v50 = 0u;
    long long v49 = 0u;
    char v47 = 4;
    uint64_t v48 = *((void *)a2 + 40);
    *((void *)&v50 + 1) = v6;
    re::Message::Message((re::Message *)v18, (const re::Message *)&v25);
    re::Raft::send((uint64_t)this, (uint64_t)v18);
    re::Snapshot::~Snapshot((re::Snapshot *)&v24);
    if (v19)
    {
      if (v23) {
        (*(void (**)(void))(*(void *)v19 + 40))();
      }
      uint64_t v23 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v19 = 0;
      ++v22;
    }
    uint64_t v7 = v18;
    goto LABEL_22;
  }
  uint64_t v26 = 0;
  uint64_t v25 = 0;
  int v28 = 0;
  uint64_t v27 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  int v31 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v46 = 0;
  memset(v51, 0, 25);
  long long v50 = 0u;
  long long v49 = 0u;
  uint64_t v48 = *((void *)a2 + 40);
  char v47 = 4;
  re::RaftLog::maybeAppend(this, v5, *((void *)a2 + 42), *((void *)a2 + 44), (uint64_t)a2, (uint64_t)v16);
  if (v16[0])
  {
    *((void *)&v50 + 1) = v17;
    BOOL v8 = v13;
    re::Message::Message((re::Message *)v13, (const re::Message *)&v25);
    re::Raft::send((uint64_t)this, (uint64_t)v13);
    re::Snapshot::~Snapshot((re::Snapshot *)&v15);
    if (v14[0])
    {
      unint64_t v9 = v14;
      if (v14[4]) {
        (*(void (**)(void))(*(void *)v14[0] + 40))();
      }
      BOOL v8 = v13;
LABEL_20:
      *((void *)v8 + 9) = 0;
      v9[1] = 0;
      uint64_t v9[2] = 0;
      *unint64_t v9 = 0;
      ++*((_DWORD *)v8 + 16);
    }
  }
  else
  {
    *((void *)&v50 + 1) = *((void *)a2 + 43);
    BYTE8(v51[1]) = 1;
    *(void *)&v51[1] = re::RaftLog::lastIndex(this);
    BOOL v8 = v10;
    re::Message::Message((re::Message *)v10, (const re::Message *)&v25);
    re::Raft::send((uint64_t)this, (uint64_t)v10);
    re::Snapshot::~Snapshot((re::Snapshot *)&v12);
    if (v11[0])
    {
      unint64_t v9 = v11;
      if (v11[4]) {
        (*(void (**)(void))(*(void *)v11[0] + 40))();
      }
      BOOL v8 = v10;
      goto LABEL_20;
    }
  }
  uint64_t v7 = v8;
LABEL_22:
  re::DynamicArray<re::Entry>::deinit((uint64_t)v7);
  re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v32 + 8));
  if (*((void *)&v29 + 1))
  {
    if ((void)v32) {
      (*(void (**)(void))(**((void **)&v29 + 1) + 40))();
    }
    *(void *)&long long v32 = 0;
    long long v30 = 0uLL;
    *((void *)&v29 + 1) = 0;
    ++v31;
  }
  return re::DynamicArray<re::Entry>::deinit((uint64_t)&v25);
}

uint64_t re::Raft::handleHeartbeat(re::Raft *this, const re::Message *a2)
{
  re::RaftLog::commitTo(this, *((void *)a2 + 44));
  if (*((void *)this + 135))
  {
    return re::Raft::sendRequestSnapshot(this);
  }
  else
  {
    memset(v12, 0, sizeof(v12));
    int v13 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    int v16 = 0;
    memset(v17, 0, sizeof(v17));
    long long v21 = 0u;
    memset(v22, 0, sizeof(v22));
    long long v20 = 0u;
    char v18 = 9;
    uint64_t v19 = *((void *)a2 + 40);
    re::DynamicArray<BOOL>::operator=((uint64_t)&v14 + 8, (uint64_t *)a2 + 5);
    re::Message::Message((re::Message *)v5, (const re::Message *)v12);
    re::Raft::send((uint64_t)this, (uint64_t)v5);
    re::Snapshot::~Snapshot((re::Snapshot *)&v11);
    if (v6)
    {
      if (v10) {
        (*(void (**)(void))(*(void *)v6 + 40))();
      }
      uint64_t v10 = 0;
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t v6 = 0;
      ++v9;
    }
    re::DynamicArray<re::Entry>::deinit((uint64_t)v5);
    re::Snapshot::~Snapshot((re::Snapshot *)&v17[1]);
    if (*((void *)&v14 + 1))
    {
      if (v17[0]) {
        (*(void (**)(void))(**((void **)&v14 + 1) + 40))();
      }
      v17[0] = 0;
      long long v15 = 0uLL;
      *((void *)&v14 + 1) = 0;
      ++v16;
    }
    return re::DynamicArray<re::Entry>::deinit((uint64_t)v12);
  }
}

uint64_t re::Raft::handleSnapshot(re::Raft *this, const re::Message *a2)
{
  unint64_t v4 = *((void *)this + 36);
  if (*((void *)a2 + 36) < v4) {
    goto LABEL_2;
  }
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v78, (uint64_t *)a2 + 15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v79, (uint64_t *)a2 + 20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v83, (uint64_t *)a2 + 25);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v86, (uint64_t *)a2 + 30);
  long long v89 = *(_OWORD *)((char *)a2 + 280);
  uint64_t v90 = *((void *)a2 + 37);
  if (!*((void *)this + 135))
  {
    uint64_t v12 = v90;
    re::RaftLog::getTerm(this, *((unint64_t *)&v89 + 1), (uint64_t)&v32);
    if ((_BYTE)v32)
    {
      if (v33 == v12)
      {
        re::RaftLog::commitTo(this, *((unint64_t *)&v89 + 1));
LABEL_22:
        char v60 = 1;
        int v13 = &v59;
        goto LABEL_54;
      }
    }
  }
  if (*((_DWORD *)this + 145) && !*((unsigned char *)this + 1152) && v80)
  {
    long long v14 = v82;
    uint64_t v15 = 8 * v80;
    while (*v14 != *((void *)this + 132))
    {
      ++v14;
      v15 -= 8;
      if (!v15) {
        goto LABEL_10;
      }
    }
    goto LABEL_22;
  }
LABEL_10:
  uint64_t Index = re::RaftLog::lastIndex(this);
  re::ProgressSet::restoreSnapshotMeta(v78, Index + 1, *((void *)this + 136), (uint64_t)v65);
  LOBYTE(v32) = 1;
  re::ProgressSet::ProgressSet((uint64_t)&v33, (uint64_t)v65);
  re::Optional<re::ProgressSet>::operator=((unsigned char *)this + 544, &v32);
  if ((_BYTE)v32) {
    re::ProgressSet::~ProgressSet((re::ProgressSet *)&v33);
  }
  re::ProgressSet::~ProgressSet((re::ProgressSet *)v65);
  LODWORD(v7) = 0x7FFFFFFF;
  if (*((void *)this + 69))
  {
    unint64_t v8 = *((void *)this + 132);
    unint64_t v9 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
    uint64_t v10 = *(unsigned int *)(*((void *)this + 70) + 4 * ((v9 ^ (v9 >> 31)) % *((unsigned int *)this + 144)));
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *((void *)this + 71);
      LODWORD(v7) = v10;
      if (*(void *)(v11 + 136 * v10 + 16) != v8)
      {
        uint64_t v7 = v10;
        while (1)
        {
          LODWORD(v7) = *(_DWORD *)(v11 + 136 * v7 + 8) & 0x7FFFFFFF;
          if (v7 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v11 + 136 * v7 + 16) == v8) {
            goto LABEL_29;
          }
        }
        LODWORD(v7) = 0x7FFFFFFF;
      }
    }
  }
LABEL_29:
  *(void *)(*((void *)this + 71) + 136 * v7 + 96) = Index;
  if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 792, (uint64_t *)this + 132))
  {
    char v16 = 1;
LABEL_33:
    *((unsigned char *)this + 1152) = v16;
    goto LABEL_34;
  }
  if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 744, (uint64_t *)this + 132))
  {
    char v16 = 0;
    goto LABEL_33;
  }
LABEL_34:
  if ((void)v89)
  {
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v61, v83);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v62, v86);
    memset(v65, 0, sizeof(v65));
    int v66 = 0;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    uint64_t v72 = 0;
    uint64_t v76 = 0;
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    char v77 = 0;
    char v73 = 3;
    re::DynamicArray<unsigned long long>::operator=((uint64_t)&v67 + 8, v61);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)&v70, v62);
    char v77 = 1;
    uint64_t v76 = v89;
    LOBYTE(v32) = 1;
    re::ConfChange::ConfChange((uint64_t)&v33, (uint64_t)v65);
    re::Optional<re::ConfChange>::operator=((unsigned char *)this + 856, (unsigned __int8 *)&v32);
    re::Optional<re::ConfChange>::~Optional(&v32);
    if ((void)v70)
    {
      if (v72) {
        (*(void (**)(void))(*(void *)v70 + 40))();
      }
      uint64_t v72 = 0;
      *(void *)&long long v71 = 0;
      long long v70 = 0uLL;
      ++DWORD2(v71);
    }
    if (*((void *)&v67 + 1))
    {
      if (*((void *)&v69 + 1)) {
        (*(void (**)(void))(**((void **)&v67 + 1) + 40))();
      }
      *((void *)&v69 + 1) = 0;
      long long v68 = 0uLL;
      *((void *)&v67 + 1) = 0;
      LODWORD(v69) = v69 + 1;
    }
    if (v65[0] && (void)v67) {
      (*(void (**)(void))(*(void *)v65[0] + 40))();
    }
    if (v62[0])
    {
      if (v64) {
        (*(void (**)(void))(*(void *)v62[0] + 40))();
      }
      uint64_t v64 = 0;
      memset(v62, 0, sizeof(v62));
      ++v63;
    }
    if (v61[0] && v61[4]) {
      (*(void (**)(void))(*(void *)v61[0] + 40))();
    }
  }
  *((void *)this + 135) = 0;
  int v13 = &v60;
LABEL_54:
  *int v13 = 0;
  if (v86[0])
  {
    if (v88) {
      (*(void (**)(void))(*(void *)v86[0] + 40))();
    }
    uint64_t v88 = 0;
    memset(v86, 0, sizeof(v86));
    ++v87;
  }
  if (v83[0])
  {
    if (v85) {
      (*(void (**)(void))(*(void *)v83[0] + 40))();
    }
    uint64_t v85 = 0;
    memset(v83, 0, sizeof(v83));
    ++v84;
  }
  if (v79[0])
  {
    if (v82) {
      (*(void (**)(void))(*(void *)v79[0] + 40))();
    }
    uint64_t v82 = 0;
    v79[1] = 0;
    uint64_t v80 = 0;
    v79[0] = 0;
    ++v81;
  }
  if (v78[0] && v78[4]) {
    (*(void (**)(void))(*(void *)v78[0] + 40))();
  }
  if (v60)
  {
    if (!v59)
    {
      unint64_t v4 = *((void *)this + 36);
LABEL_2:
      uint64_t v33 = 0;
      uint64_t v32 = 0;
      int v35 = 0;
      uint64_t v34 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      int v38 = 0;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      uint64_t v53 = 0;
      memset(v58, 0, sizeof(v58));
      long long v57 = 0u;
      long long v56 = 0u;
      char v54 = 4;
      uint64_t v55 = *((void *)a2 + 40);
      *((void *)&v57 + 1) = v4;
      re::Message::Message((re::Message *)v18, (const re::Message *)&v32);
      re::Raft::send((uint64_t)this, (uint64_t)v18);
      re::Snapshot::~Snapshot((re::Snapshot *)&v24);
      if (v19)
      {
        if (v23) {
          (*(void (**)(void))(*(void *)v19 + 40))();
        }
        uint64_t v23 = 0;
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v19 = 0;
        ++v22;
      }
      unint64_t v5 = v18;
      goto LABEL_78;
    }
  }
  else
  {
    *((void *)this + 36) = *((void *)a2 + 36);
    re::Unstable::restore((re::Raft *)((char *)this + 8), (const re::Message *)((char *)a2 + 80));
  }
  uint64_t v33 = 0;
  uint64_t v32 = 0;
  int v35 = 0;
  uint64_t v34 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  int v38 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v53 = 0;
  memset(v58, 0, sizeof(v58));
  long long v57 = 0u;
  long long v56 = 0u;
  char v54 = 4;
  uint64_t v55 = *((void *)a2 + 40);
  *((void *)&v57 + 1) = re::RaftLog::lastIndex(this);
  re::Message::Message((re::Message *)v25, (const re::Message *)&v32);
  re::Raft::send((uint64_t)this, (uint64_t)v25);
  re::Snapshot::~Snapshot((re::Snapshot *)&v31);
  if (v26)
  {
    if (v30) {
      (*(void (**)(void))(*(void *)v26 + 40))();
    }
    uint64_t v30 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v26 = 0;
    ++v29;
  }
  unint64_t v5 = v25;
LABEL_78:
  re::DynamicArray<re::Entry>::deinit((uint64_t)v5);
  re::Snapshot::~Snapshot((re::Snapshot *)((char *)&v39 + 8));
  if (*((void *)&v36 + 1))
  {
    if ((void)v39) {
      (*(void (**)(void))(**((void **)&v36 + 1) + 40))();
    }
    *(void *)&long long v39 = 0;
    long long v37 = 0uLL;
    *((void *)&v36 + 1) = 0;
    ++v38;
  }
  return re::DynamicArray<re::Entry>::deinit((uint64_t)&v32);
}

uint64_t re::Raft::sendRequestSnapshot(re::Raft *this)
{
  memset(v12, 0, sizeof(v12));
  int v13 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  int v16 = 0;
  memset(v17, 0, sizeof(v17));
  long long v20 = 0u;
  long long v21 = 0u;
  char v18 = 4;
  uint64_t v2 = *((void *)this + 36);
  uint64_t v22 = 0;
  *((void *)&v21 + 1) = v2;
  char v25 = 1;
  uint64_t Index = re::RaftLog::lastIndex(this);
  uint64_t v3 = *((void *)this + 135);
  uint64_t v19 = *((void *)this + 133);
  uint64_t v23 = v3;
  re::Message::Message((re::Message *)v5, (const re::Message *)v12);
  re::Raft::send((uint64_t)this, (uint64_t)v5);
  re::Snapshot::~Snapshot((re::Snapshot *)&v11);
  if (v6)
  {
    if (v10) {
      (*(void (**)(void))(*(void *)v6 + 40))();
    }
    uint64_t v10 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v6 = 0;
    ++v9;
  }
  re::DynamicArray<re::Entry>::deinit((uint64_t)v5);
  re::Snapshot::~Snapshot((re::Snapshot *)&v17[1]);
  if (*((void *)&v14 + 1))
  {
    if (v17[0]) {
      (*(void (**)(void))(**((void **)&v14 + 1) + 40))();
    }
    v17[0] = 0;
    long long v15 = 0uLL;
    *((void *)&v14 + 1) = 0;
    ++v16;
  }
  return re::DynamicArray<re::Entry>::deinit((uint64_t)v12);
}

__n128 re::DynamicArray<re::Entry>::add(__n128 *this, __n128 *a2)
{
  unint64_t v4 = this[1].n128_u64[0];
  if (v4 >= this->n128_u64[1])
  {
    re::DynamicArray<re::Entry>::growCapacity(this, v4 + 1);
    unint64_t v4 = this[1].n128_u64[0];
  }
  unint64_t v5 = (__n128 *)(this[2].n128_u64[0] + 104 * v4);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v5, (uint64_t *)a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v5[2].n128_i64[1], &a2[2].n128_i64[1]);
  __n128 result = a2[5];
  v5[6].n128_u64[0] = a2[6].n128_u64[0];
  v5[5] = result;
  ++this[1].n128_u64[0];
  ++this[1].n128_u32[2];
  return result;
}

void re::Raft::addVoterOrLearner(re::Raft *this@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned char *a4@<X8>)
{
  char v4 = a3;
  uint64_t v40 = a2;
  *a4 = 1;
  if (a3)
  {
    uint64_t Index = re::RaftLog::lastIndex(this);
    unint64_t v9 = *((void *)this + 136);
    uint64_t v10 = Index + 1;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v26 = 0;
    int v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    unint64_t v33 = v9;
    re::DynamicArray<float *>::setCapacity(&v26, v9);
    char v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = v10;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    __int16 v39 = 0;
    re::ProgressSet::insertLearner((re::Raft *)((char *)this + 552), (const re::Progress *)&v26, a2, (uint64_t)v23);
    goto LABEL_10;
  }
  re::ProgressSet::learnerIds((re::Raft *)((char *)this + 552), (uint64_t)&v26);
  BOOL v11 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v26, &v40);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(&v26);
  if (!v11)
  {
    uint64_t v12 = re::RaftLog::lastIndex(this);
    unint64_t v13 = *((void *)this + 136);
    uint64_t v14 = v12 + 1;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v26 = 0;
    int v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    unint64_t v33 = v13;
    re::DynamicArray<float *>::setCapacity(&v26, v13);
    char v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = v14;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    __int16 v39 = 0;
    re::ProgressSet::insertVoter((re::Raft *)((char *)this + 552), (const re::Progress *)&v26, v40, (uint64_t)v23);
LABEL_10:
    re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)a4, (uint64_t)v23);
    if (!v23[0] && v24 && (v25 & 1) != 0) {
      (*(void (**)(void))(*(void *)v24 + 40))();
    }
    if (v26 && v30) {
      (*(void (**)(void))(*(void *)v26 + 40))();
    }
    goto LABEL_14;
  }
  re::ProgressSet::promoteLearner((re::Raft *)((char *)this + 552), v40, (uint64_t)v20);
  if (!v20[0] && (void)v21)
  {
    if (BYTE8(v21)) {
      (*(void (**)(void))(*(void *)v21 + 40))();
    }
    long long v21 = 0u;
    long long v22 = 0u;
  }
LABEL_14:
  if (*a4)
  {
    unint64_t v15 = v40;
    if (*((void *)this + 132) == v40) {
      *((unsigned char *)this + 1152) = v4;
    }
    LODWORD(v16) = 0x7FFFFFFF;
    if (*((void *)this + 69))
    {
      unint64_t v17 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
      uint64_t v18 = *(unsigned int *)(*((void *)this + 70) + 4 * ((v17 ^ (v17 >> 31)) % *((unsigned int *)this + 144)));
      if (v18 != 0x7FFFFFFF)
      {
        uint64_t v19 = *((void *)this + 71);
        LODWORD(v16) = v18;
        if (*(void *)(v19 + 136 * v18 + 16) != v15)
        {
          uint64_t v16 = v18;
          while (1)
          {
            LODWORD(v16) = *(_DWORD *)(v19 + 136 * v16 + 8) & 0x7FFFFFFF;
            if (v16 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v19 + 136 * v16 + 16) == v15) {
              goto LABEL_28;
            }
          }
          LODWORD(v16) = 0x7FFFFFFF;
        }
      }
    }
LABEL_28:
    *(unsigned char *)(*((void *)this + 71) + 136 * v16 + 129) = 1;
  }
}

unsigned char *re::Raft::removeNode@<X0>(re::Raft *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v18[13] = *MEMORY[0x263EF8340];
  uint64_t v6 = (re::Raft *)((char *)this + 552);
  re::ProgressSet::remove((re::Raft *)((char *)this + 552), a2, (uint64_t)v16);
  if (v16[0])
  {
    re::ProgressSet::voterIds(v6, (uint64_t)&v12);
    if (DWORD1(v14))
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v12);
    }
    else
    {
      re::ProgressSet::learnerIds(v6, (uint64_t)v10);
      int v7 = v11;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v10);
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v12);
      if (!v7)
      {
LABEL_12:
        *(unsigned char *)a3 = 1;
        return re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result(v16);
      }
    }
    unint64_t v8 = re::ProgressSet::maximalCommittedIndex(v6);
    if (re::RaftLog::maybeCommit(this, v8, *((void *)this + 130))) {
      re::Raft::broadcastAppend(this);
    }
    if (*((unsigned char *)this + 536) == 2 && *((unsigned char *)this + 1024) && *((void *)this + 129) == a2) {
      *((unsigned char *)this + 1024) = 0;
    }
    goto LABEL_12;
  }
  long long v12 = v17;
  re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)v18);
  *(unsigned char *)a3 = 0;
  *(_OWORD *)(a3 + 8) = v12;
  *(void *)(a3 + 24) = v13;
  *(void *)(a3 + 48) = v15;
  *(_OWORD *)(a3 + 32) = v14;
  return re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result(v16);
}

uint64_t RaftState::RaftState(uint64_t a1, uint64_t a2)
{
  char v4 = re::Optional<re::ConfState>::Optional((unsigned char *)a1, (uint64_t *)a2);
  int v5 = *(unsigned __int8 *)(a2 + 88);
  v4[88] = v5;
  if (v5) {
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
  }
  long long v6 = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = *(void *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v6;
  re::DynamicArray<char const*>::DynamicArray(a1 + 128, (uint64_t *)(a2 + 128));
  re::DynamicArray<char const*>::DynamicArray(a1 + 168, (uint64_t *)(a2 + 168));
  return a1;
}

unsigned __int8 *re::Optional<re::Snapshot>::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  int v3 = *a1;
  int v4 = *(unsigned __int8 *)a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    if (*a1) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      re::Snapshot::~Snapshot((re::Snapshot *)(a1 + 8));
      *a1 = 0;
    }
    else
    {
      uint64_t v8 = (uint64_t)(a1 + 8);
      if (v3) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v4 == 0;
      }
      if (v9)
      {
        re::DynamicArray<BOOL>::operator=(v8, a2 + 1);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 48), a2 + 6);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 88), a2 + 11);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 128), a2 + 16);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 168), a2 + 21);
        uint64_t v10 = a2[28];
        *((_OWORD *)a1 + 13) = *((_OWORD *)a2 + 13);
        *((void *)a1 + 28) = v10;
      }
      else
      {
        *a1 = 1;
        re::DynamicArray<BOOL>::DynamicArray(v8, a2 + 1);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 48), a2 + 6);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 88), a2 + 11);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 128), a2 + 16);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 168), a2 + 21);
        long long v11 = *((_OWORD *)a2 + 13);
        *((void *)a1 + 28) = a2[28];
        *((_OWORD *)a1 + 13) = v11;
      }
    }
  }
  return a1;
}

void re::Unstable::~Unstable(re::Unstable *this)
{
  if (*((unsigned char *)this + 40)) {
    re::Snapshot::~Snapshot((re::Unstable *)((char *)this + 48));
  }
  re::DynamicArray<re::Entry>::deinit((uint64_t)this);
}

void re::RaftLog::~RaftLog(re::RaftLog *this)
{
  re::Unstable::~Unstable((re::RaftLog *)((char *)this + 8));
  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

uint64_t re::ProgressSet::ProgressSet(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
  *(void *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v5 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v5;
  uint64_t v6 = *(void *)(a1 + 80);
  *(void *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = *(void *)(a2 + 80);
  *(void *)(a2 + 8re::InputManager::notify(8, 0, 0, 0) = v6;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(a1 + 72);
  re::Optional<re::Configuration>::Optional(a1 + 88, (uint64_t *)(a2 + 88));
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = 0u;
  *(void *)(a1 + 228) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 192), (uint64_t *)(a2 + 192));
  *(_OWORD *)(a1 + 256) = 0u;
  *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = 0x7FFFFFFF00000000;
  *(_OWORD *)(a1 + 24re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_DWORD *)(a1 + 28re::InputManager::notify(8, 0, 0, 0) = 0;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 240), (uint64_t *)(a2 + 240));
  *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
  return a1;
}

uint64_t re::Optional<re::Configuration>::Optional(uint64_t a1, uint64_t *a2)
{
  int v3 = *(unsigned __int8 *)a2;
  *(unsigned char *)a1 = v3;
  if (v3)
  {
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(void *)(a1 + 44) = 0x7FFFFFFFLL;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 8), a2 + 1);
    *(_OWORD *)(a1 + 56) = 0u;
    *(_DWORD *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(void *)(a1 + 92) = 0x7FFFFFFFLL;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 56), a2 + 7);
  }
  return a1;
}

void re::ProgressSet::~ProgressSet(re::ProgressSet *this)
{
  uint64_t v2 = (uint64_t *)((char *)this + 192);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 30);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  re::Optional<re::Configuration>::~Optional((uint64_t)this + 88);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 48);
  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this);
}

uint64_t re::Optional<re::Configuration>::~Optional(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 56));
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 8));
  }
  return a1;
}

double re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<unsigned long>::deinit(v6 + 24);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 136;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::ReadOnly::ReadOnly(uint64_t a1, unsigned char *a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  *(void *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  unint64_t v3 = (void *)(a1 + 48);
  *(unsigned char *)(a1 + 96) = *a2;
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, 0);
  re::Queue<re::DynamicArray<unsigned char>>::setCapacity(v3, 0);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  return a1;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (uint64_t *)(*(void *)&v13[16] + v10 + 16), (uint64_t *)(*(void *)&v13[16] + v10 + 56));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 496;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 496 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 496 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 496 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 496 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  re::DynamicArray<BOOL>::DynamicArray(*(void *)(a1 + 16) + 496 * v10 + 16, a4);
  uint64_t v14 = *(void *)(a1 + 16) + 496 * v10;
  *(_OWORD *)(v14 + 56) = 0u;
  v14 += 56;
  *(_DWORD *)(v14 + 32) = 0;
  *(_OWORD *)(v14 + 16) = 0u;
  *(void *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, a5);
  re::Message::Message(v14 + 48, (uint64_t)(a5 + 6));
  *(void *)(v14 + 432) = a5[54];
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 496 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::Message::Message(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  uint64_t v7 = *(void *)(a2 + 48);
  *(void *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v7;
  *(void *)(a2 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a2 + 48) = 0;
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v8;
  uint64_t v9 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v9;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(a1 + 64);
  uint64_t v10 = a1 + 80;
  uint64_t v11 = a2 + 80;
  re::DynamicArray<BOOL>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 120, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 160, (uint64_t *)(a2 + 160));
  re::DynamicArray<char const*>::DynamicArray(a1 + 200, (uint64_t *)(a2 + 200));
  re::DynamicArray<char const*>::DynamicArray(a1 + 240, (uint64_t *)(a2 + 240));
  long long v12 = *(_OWORD *)(v11 + 200);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(_OWORD *)(v10 + 20re::InputManager::notify(8, 0, 0, 0) = v12;
  long long v14 = *(_OWORD *)(a2 + 336);
  long long v13 = *(_OWORD *)(a2 + 352);
  long long v15 = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 361) = *(_OWORD *)(a2 + 361);
  *(_OWORD *)(a1 + 336) = v14;
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = v13;
  *(_OWORD *)(a1 + 32re::InputManager::notify(8, 0, 0, 0) = v15;
  *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
  return a1;
}

double re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 496;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::DynamicArray<unsigned long>::deinit(a1 + 16);
    re::ReadIndexStatus::~ReadIndexStatus((re::ReadIndexStatus *)(a1 + 56));
  }
}

void re::ReadIndexStatus::~ReadIndexStatus(re::ReadIndexStatus *this)
{
  uint64_t v2 = (char *)this + 48;
  re::Snapshot::~Snapshot((re::ReadIndexStatus *)((char *)this + 128));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 88);
  re::DynamicArray<re::Entry>::deinit((uint64_t)v2);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this);
}

void *re::Queue<re::DynamicArray<unsigned char>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = result + 2;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::Queue<re::DynamicArray<unsigned char>>::setCapacity(v5, a2);
        *uint64_t v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v8 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        uint64_t v9 = 0;
        uint64_t v10 = v5[3];
        do
        {
          uint64_t v11 = v5[5] + 40 * ((unint64_t)(v9 + v5[3]) % v5[1]);
          long long v12 = &v8[5 * v10];
          v12[4] = 0;
          *((_DWORD *)v12 + 6) = 0;
          v12[1] = 0;
          void v12[2] = 0;
          void *v12 = 0;
          uint64_t v13 = *(void *)(v11 + 8);
          void *v12 = *(void *)v11;
          v12[1] = v13;
          *(void *)uint64_t v11 = 0;
          *(void *)(v11 + 8) = 0;
          uint64_t v14 = v12[2];
          void v12[2] = *(void *)(v11 + 16);
          *(void *)(v11 + 16) = v14;
          uint64_t v15 = v12[4];
          v12[4] = *(void *)(v11 + 32);
          *(void *)(v11 + 32) = v15;
          ++*(_DWORD *)(v11 + 24);
          ++*((_DWORD *)v12 + 6);
          re::DynamicArray<unsigned long>::deinit(v11);
          if (v10 + 1 < a2) {
            ++v10;
          }
          else {
            uint64_t v10 = 0;
          }
          ++v9;
        }
        while (v9 != v5[2]);
      }
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::Queue<re::DynamicArray<unsigned char>>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = *a2;
    if (*(void *)a1) {
      BOOL v5 = v3 == v4;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      uint64_t v7 = a2[1];
      *(void *)a1 = v4;
      *(void *)(a1 + 8) = v7;
      *a2 = v3;
      a2[1] = v6;
      uint64_t v8 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = a2[2];
      a2[2] = v8;
      uint64_t v9 = *(void *)(a1 + 40);
      *(void *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = a2[5];
      a2[5] = v9;
      uint64_t v10 = *(void *)(a1 + 24);
      *(void *)(a1 + 24) = a2[3];
      a2[3] = v10;
    }
    else if (v4)
    {
      re::Queue<re::DynamicArray<unsigned char>>::copy((void *)a1, a2);
      ++*(_DWORD *)(a1 + 32);
    }
    else
    {
      re::Queue<re::DynamicArray<unsigned char>>::clear(a1);
    }
  }
  return a1;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(*(void *)(a1 + 16) + v3);
        ++v4;
        v3 += 496;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v5;
  }
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (uint64_t *)(v8 + 16), v8 + 56);
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 496;
    }
  }
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 496 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 496 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 496 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 496 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  re::DynamicArray<BOOL>::DynamicArray(*(void *)(a1 + 16) + 496 * v10 + 16, a4);
  uint64_t v14 = *(void *)(a1 + 16) + 496 * v10;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(v14 + 56, a5);
  re::Message::Message((re::Message *)(v14 + 104), (const re::Message *)(a5 + 48));
  *(void *)(v14 + 488) = *(void *)(a5 + 432);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::Queue<re::DynamicArray<unsigned char>>::clear(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 16))
  {
    unint64_t v2 = 0;
    do
    {
      double result = re::DynamicArray<unsigned long>::deinit(*(void *)(v1 + 40) + 40
                                                                            * ((v2 + *(void *)(v1 + 24))
                                                                             % *(void *)(v1 + 8)));
      ++v2;
    }
    while (v2 < *(void *)(v1 + 16));
  }
  *(void *)(v1 + 16) = 0;
  ++*(_DWORD *)(v1 + 32);
  return result;
}

uint64_t re::Queue<re::DynamicArray<unsigned char>>::copy(void *a1, void *a2)
{
  unint64_t v4 = a2[2];
  if (v4 >= a1[2])
  {
    re::Queue<re::DynamicArray<unsigned char>>::setCapacity(a1, a2[2]);
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>(a2, 0, a2, a1[2], a1, 0, v8);
    uint64_t v7 = a1[2];
    for (a1[2] = v4; v7 != a2[2]; ++v7)
      uint64_t result = re::DynamicArray<BOOL>::DynamicArray(a1[5] + 40 * ((unint64_t)(v7 + a1[3]) % a1[1]), (uint64_t *)(a2[5] + 40 * ((unint64_t)(v7 + a2[3]) % a2[1])));
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>(a2, 0, a2, a2[2], a1, 0, v8);
    if (v4 != a1[2])
    {
      unint64_t v6 = v4;
      do
      {
        uint64_t result = re::DynamicArray<unsigned long>::deinit(a1[5] + 40 * ((v6 + a1[3]) % a1[1]));
        ++v6;
      }
      while (v6 != a1[2]);
    }
    a1[2] = v4;
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>@<X0>(void *a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, uint64_t a4@<X4>, void *a5@<X5>, uint64_t a6@<X6>, void *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    uint64_t v13 = a4 - 1;
    do
    {
      do
      {
        uint64_t v14 = a2;
        uint64_t result = re::DynamicArray<BOOL>::operator=(a5[5] + 40 * ((unint64_t)(a6 + a5[3]) % a5[1]), (uint64_t *)(a1[5] + 40 * ((unint64_t)(a2 + a1[3]) % a1[1])));
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
  return result;
}

double re::Queue<re::DynamicArray<unsigned char>>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      if (a1[2])
      {
        uint64_t v4 = 0;
        do
        {
          re::DynamicArray<unsigned long>::deinit(a1[5] + 40 * ((v4 + a1[3]) % (unint64_t)a1[1]));
          ++v4;
        }
        while (v4 != a1[2]);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    double result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

void re::Raft::~Raft(re::Raft *this)
{
  re::Optional<re::ConfChange>::~Optional((unsigned char *)this + 856);
  if (*((unsigned char *)this + 544)) {
    re::ProgressSet::~ProgressSet((re::Raft *)((char *)this + 552));
  }
  re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)this + 60);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)this + 54);
  re::DynamicArray<re::Message>::deinit((uint64_t)this + 392);
  re::DynamicArray<re::ReadState>::deinit((uint64_t)this + 352);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 38);
  re::RaftLog::~RaftLog(this);
}

uint64_t re::DynamicArray<re::ReadState>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 48 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 48;
          v5 -= 48;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

re::ProgressSet *re::ProgressSet::ProgressSet(re::ProgressSet *this, const re::ProgressSet *a2)
{
  uint64_t v4 = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable((uint64_t)this, (uint64_t)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 48, (uint64_t *)a2 + 6);
  re::Optional<re::Configuration>::Optional((unsigned char *)this + 88, (unsigned __int8 *)a2 + 88);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)this + 192, (uint64_t)a2 + 192);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)this + 240, (uint64_t)a2 + 240);
  *((_OWORD *)this + 18) = *((_OWORD *)a2 + 18);
  return this;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  signed int v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      signed int v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 136 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (re::Progress *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 136;
    }
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<unsigned long>::deinit(v6 + 24);
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 136;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (void *)(*(void *)&v13[16] + v10 + 16), (_OWORD *)(*(void *)&v13[16] + v10 + 24));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 136;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, re::Progress *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 136 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 136 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 136 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 136 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  *(void *)(*(void *)(a1 + 16) + 136 * v10 + 16) = *a4;
  re::Progress::Progress((re::Progress *)(*(void *)(a1 + 16) + 136 * v10 + 24), a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, _OWORD *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 136 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 136 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 136 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 136 * v1re::InputManager::notify(8, 0, 0, 0) = a3;
  *(void *)(*(void *)(a1 + 16) + 136 * v10 + 16) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 136 * v10;
  re::Inflights::Inflights(v14 + 24, (uint64_t)a5);
  long long v15 = a5[4];
  long long v16 = a5[5];
  *(_OWORD *)(v14 + 114) = *(_OWORD *)((char *)a5 + 90);
  *(_OWORD *)(v14 + 104) = v16;
  *(_OWORD *)(v14 + 88) = v15;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

__n128 re::Inflights::Inflights(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = result;
  return result;
}

__n128 re::Progress::Progress(re::Progress *this, const re::Progress *a2)
{
  uint64_t v3 = re::DynamicArray<char const*>::DynamicArray((uint64_t)this, (uint64_t *)a2);
  long long v4 = *(_OWORD *)((char *)a2 + 40);
  *(void *)(v3 + 56) = *((void *)a2 + 7);
  *(_OWORD *)(v3 + 4re::InputManager::notify(8, 0, 0, 0) = v4;
  *(unsigned char *)(v3 + 64) = *((unsigned char *)a2 + 64);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)((char *)a2 + 72);
  __n128 result = *(__n128 *)((char *)a2 + 88);
  *(__n128 *)(v3 + 88) = result;
  *(unsigned char *)(v3 + 104) = *((unsigned char *)a2 + 104);
  *(unsigned char *)(v3 + 105) = *((unsigned char *)a2 + 105);
  return result;
}

unsigned char *re::Optional<re::Configuration>::Optional(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  *a1 = v3;
  if (v3)
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)(a1 + 56), (uint64_t)(a2 + 56));
  }
  return a1;
}

re::Message *re::Message::Message(re::Message *this, const re::Message *a2)
{
  long long v4 = re::DynamicArray<re::Entry>::DynamicArray((__n128 *)this, (unint64_t *)a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v4[2].n128_i64[1], (uint64_t *)a2 + 5);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)this + 80, (uint64_t *)a2 + 10);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 120, (uint64_t *)a2 + 15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 160, (uint64_t *)a2 + 20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 200, (uint64_t *)a2 + 25);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 240, (uint64_t *)a2 + 30);
  long long v5 = *(_OWORD *)((char *)a2 + 280);
  *((void *)this + 37) = *((void *)a2 + 37);
  *(_OWORD *)((char *)this + 28re::InputManager::notify(8, 0, 0, 0) = v5;
  long long v7 = *((_OWORD *)a2 + 21);
  long long v6 = *((_OWORD *)a2 + 22);
  long long v8 = *((_OWORD *)a2 + 20);
  *(_OWORD *)((char *)this + 361) = *(_OWORD *)((char *)a2 + 361);
  *((_OWORD *)this + 21) = v7;
  *((_OWORD *)this + 22) = v6;
  *((_OWORD *)this + 2re::InputManager::notify(8, 0, 0, 0) = v8;
  *((_OWORD *)this + 19) = *((_OWORD *)a2 + 19);
  return this;
}

void re::Snapshot::~Snapshot(re::Snapshot *this)
{
  uint64_t v2 = (char *)this + 40;
  int v3 = (char *)this + 120;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 160);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v3);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 80);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this);
}

uint64_t re::ConfChange::ConfChange(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::DynamicArray<BOOL>::DynamicArray(a1, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 40, (uint64_t *)(a2 + 40));
  re::DynamicArray<char const*>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  long long v5 = *(_OWORD *)(a2 + 120);
  long long v6 = *(_OWORD *)(a2 + 136);
  *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v6;
  *(_OWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = v5;
  return a1;
}

{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  long long v7;
  long long v8;

  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  long long v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  long long v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  re::ConfState::ConfState(a1 + 40, a2 + 40);
  long long v7 = *(_OWORD *)(a2 + 120);
  long long v8 = *(_OWORD *)(a2 + 136);
  *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v8;
  *(_OWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = v7;
  return a1;
}

uint64_t re::Optional<re::Snapshot>::Optional(uint64_t a1, uint64_t *a2)
{
  int v3 = *(unsigned __int8 *)a2;
  *(unsigned char *)a1 = v3;
  if (v3)
  {
    re::DynamicArray<BOOL>::DynamicArray(a1 + 8, a2 + 1);
    re::DynamicArray<char const*>::DynamicArray(a1 + 48, a2 + 6);
    re::DynamicArray<char const*>::DynamicArray(a1 + 88, a2 + 11);
    re::DynamicArray<char const*>::DynamicArray(a1 + 128, a2 + 16);
    re::DynamicArray<char const*>::DynamicArray(a1 + 168, a2 + 21);
    long long v5 = *((_OWORD *)a2 + 13);
    *(void *)(a1 + 224) = a2[28];
    *(_OWORD *)(a1 + 208) = v5;
  }
  return a1;
}

unsigned char *re::Optional<re::ConfState>::~Optional(unsigned char *a1)
{
  if (*a1)
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 48));
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 8));
  }
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 104 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 104;
          v5 -= 104;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

unsigned char *re::Optional<re::ConfState>::Optional(unsigned char *a1, uint64_t *a2)
{
  int v3 = *(unsigned __int8 *)a2;
  *a1 = v3;
  if (v3)
  {
    re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 8), a2 + 1);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 48), a2 + 6);
  }
  return a1;
}

uint64_t re::DynamicArray<re::Message>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 384 * v4;
        do
        {
          re::Snapshot::~Snapshot((re::Snapshot *)(v3 + 80));
          re::DynamicArray<unsigned long>::deinit(v3 + 40);
          re::DynamicArray<re::Entry>::deinit(v3);
          v3 += 384;
          v5 -= 384;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

unsigned char *re::Optional<re::ConfChange>::~Optional(unsigned char *a1)
{
  if (*a1)
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 88));
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 48));
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 8));
  }
  return a1;
}

uint64_t re::ProgressSet::operator=(uint64_t a1, uint64_t *a2)
{
  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1, a2);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 48, (uint64_t)(a2 + 6));
  re::Optional<re::Configuration>::operator=((unsigned __int8 *)(a1 + 88), a2 + 11);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 192, a2 + 24);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 240, a2 + 30);
  *(void *)(a1 + 288) = a2[36];
  *(void *)(a1 + 296) = a2[37];
  return a1;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
    }
  }
  return a1;
}

unsigned __int8 *re::Optional<re::Configuration>::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  int v3 = *a1;
  int v4 = *(unsigned __int8 *)a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    if (*a1) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)a1 + 7);
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)a1 + 1);
      *a1 = 0;
    }
    else
    {
      long long v8 = (uint64_t *)(a1 + 8);
      if (v3) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v4 == 0;
      }
      if (v9)
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v8, a2 + 1);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)(a1 + 56), a2 + 7);
      }
      else
      {
        *a1 = 1;
        *(_OWORD *)long long v8 = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
        *((_DWORD *)a1 + 1re::InputManager::notify(8, 0, 0, 0) = 0;
        *(void *)(a1 + 44) = 0x7FFFFFFFLL;
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v8, a2 + 1);
        *(_OWORD *)(a1 + 56) = 0u;
        *((_DWORD *)a1 + 22) = 0;
        *(_OWORD *)(a1 + 72) = 0u;
        *(void *)(a1 + 92) = 0x7FFFFFFFLL;
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1 + 7, a2 + 7);
      }
    }
  }
  return a1;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::ConfChange::operator=(uint64_t a1, uint64_t a2)
{
  re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a1, a2);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 40, a2 + 40);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 80, a2 + 80);
  char v4 = *(unsigned char *)(a2 + 152);
  long long v5 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 12re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = v5;
  *(unsigned char *)(a1 + 152) = v4;
  return a1;
}

uint64_t re::ConfState::ConfState(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 24) = 0;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = *(void *)a2;
  *(void *)(result + 8) = v2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(result + 24);
  *(void *)(result + 72) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_DWORD *)(result + 64) = 0;
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(result + 4re::InputManager::notify(8, 0, 0, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v5;
  *(void *)(a2 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a2 + 48) = 0;
  uint64_t v6 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v6;
  uint64_t v7 = *(void *)(result + 72);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v7;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(result + 64);
  return result;
}

uint64_t re::Raft::Raft(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *(void *)a1 = v4;
  re::Unstable::Unstable(a1 + 8, (uint64_t)(a2 + 1));
  *(_OWORD *)(a1 + 288) = *((_OWORD *)a2 + 18);
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 32re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_DWORD *)(a1 + 336) = 0;
  *(void *)(a1 + 34re::InputManager::notify(8, 0, 0, 0) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 304), a2 + 38);
  *(void *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(void *)(a1 + 36re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = 0;
  uint64_t v5 = a2[45];
  *(void *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = a2[44];
  *(void *)(a1 + 36re::InputManager::notify(8, 0, 0, 0) = v5;
  a2[44] = 0;
  a2[45] = 0;
  uint64_t v6 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = a2[46];
  a2[46] = v6;
  uint64_t v7 = *(void *)(a1 + 384);
  *(void *)(a1 + 384) = a2[48];
  a2[48] = v7;
  ++*((_DWORD *)a2 + 94);
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 40re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  uint64_t v8 = a2[50];
  *(void *)(a1 + 392) = a2[49];
  *(void *)(a1 + 40re::InputManager::notify(8, 0, 0, 0) = v8;
  a2[49] = 0;
  a2[50] = 0;
  uint64_t v9 = *(void *)(a1 + 408);
  *(void *)(a1 + 408) = a2[51];
  a2[51] = v9;
  uint64_t v10 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = a2[53];
  a2[53] = v10;
  ++*((_DWORD *)a2 + 104);
  ++*(_DWORD *)(a1 + 416);
  re::ReadOnly::ReadOnly(a1 + 432, (uint64_t)(a2 + 54));
  *(unsigned char *)(a1 + 536) = *((unsigned char *)a2 + 536);
  int v11 = *((unsigned __int8 *)a2 + 544);
  *(unsigned char *)(a1 + 544) = v11;
  if (v11) {
    re::ProgressSet::ProgressSet(a1 + 552, (uint64_t)(a2 + 69));
  }
  int v12 = *((unsigned __int8 *)a2 + 856);
  *(unsigned char *)(a1 + 856) = v12;
  if (v12) {
    re::ConfChange::ConfChange(a1 + 864, (uint64_t)(a2 + 108));
  }
  int v13 = *((unsigned __int8 *)a2 + 1024);
  *(unsigned char *)(a1 + 1024) = v13;
  if (v13) {
    *(void *)(a1 + 1032) = a2[129];
  }
  long long v14 = *((_OWORD *)a2 + 65);
  long long v15 = *((_OWORD *)a2 + 66);
  long long v16 = *((_OWORD *)a2 + 67);
  *(_OWORD *)(a1 + 1088) = *((_OWORD *)a2 + 68);
  *(_OWORD *)(a1 + 1072) = v16;
  *(_OWORD *)(a1 + 1056) = v15;
  *(_OWORD *)(a1 + 104re::InputManager::notify(8, 0, 0, 0) = v14;
  long long v17 = *((_OWORD *)a2 + 69);
  long long v18 = *((_OWORD *)a2 + 70);
  long long v19 = *((_OWORD *)a2 + 71);
  *(void *)(a1 + 1149) = *(uint64_t *)((char *)a2 + 1149);
  *(_OWORD *)(a1 + 1136) = v19;
  *(_OWORD *)(a1 + 112re::InputManager::notify(8, 0, 0, 0) = v18;
  *(_OWORD *)(a1 + 1104) = v17;
  return a1;
}

uint64_t re::Unstable::Unstable(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  re::Optional<re::Snapshot>::Optional(a1 + 40, (uint64_t *)(a2 + 40));
  *(void *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = *(void *)(a2 + 272);
  return a1;
}

uint64_t re::ReadOnly::ReadOnly(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v5 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v5;
  uint64_t v6 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v6;
  uint64_t v7 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v7;
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::DynamicArray(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if (a3)
  {
    re::DynamicArray<re::Entry>::setCapacity((__n128 *)a1, a3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Entry>::copy((__n128 *)a1, 0, a2, a3);
  }
  return a1;
}

__n128 *re::DynamicArray<re::Entry>::setCapacity(__n128 *result, unint64_t a2)
{
  uint64_t v3 = result->n128_i64[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[1].n128_u64[0] <= a2)
    {
      uint64_t result = (__n128 *)result->n128_u64[0];
      if (!v5->n128_u64[0])
      {
        uint64_t result = (__n128 *)re::DynamicArray<re::Entry>::setCapacity(v5, a2);
        ++v5[1].n128_u32[2];
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x68uLL))
        {
          uint64_t v2 = 104 * a2;
          uint64_t result = (__n128 *)(*(uint64_t (**)(__n128 *, unint64_t, uint64_t))(result->n128_u64[0] + 32))(result, 104 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5->n128_u64[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(v5->n128_u64[0] + 8));
        uint64_t result = (__n128 *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[2].n128_u64[0] = (unint64_t)v7;
        v5->n128_u64[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (__n128 *)v5[2].n128_u64[0];
      uint64_t v9 = v5[1].n128_i64[0];
      if (v9)
      {
        uint64_t v10 = 104 * v9;
        int v11 = v7;
        do
        {
          re::Entry::Entry(v11, v8);
          re::DynamicArray<unsigned long>::deinit((uint64_t)&v8[2].n128_i64[1]);
          re::DynamicArray<unsigned long>::deinit((uint64_t)v8);
          uint64_t v8 = (__n128 *)((char *)v8 + 104);
          int v11 = (__n128 *)((char *)v11 + 104);
          v10 -= 104;
        }
        while (v10);
        uint64_t v8 = (__n128 *)v5[2].n128_u64[0];
      }
      uint64_t result = (__n128 *)(*(uint64_t (**)(unint64_t, __n128 *))(*(void *)v5->n128_u64[0] + 40))(v5->n128_u64[0], v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 re::Entry::Entry(__n128 *a1, __n128 *a2)
{
  a1[2].n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a1[1].n128_u32[2] = 0;
  unint64_t v2 = a2->n128_u64[1];
  a1->n128_u64[0] = a2->n128_u64[0];
  a1->n128_u64[1] = v2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  unint64_t v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  unint64_t v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  ++a2[1].n128_u32[2];
  ++a1[1].n128_u32[2];
  a1[4].n128_u64[1] = 0;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[2].n128_u64[1] = 0;
  a1[4].n128_u32[0] = 0;
  unint64_t v5 = a2[3].n128_u64[0];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a1[3].n128_u64[0] = v5;
  a2[2].n128_u64[1] = 0;
  a2[3].n128_u64[0] = 0;
  unint64_t v6 = a1[3].n128_u64[1];
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  a2[3].n128_u64[1] = v6;
  unint64_t v7 = a1[4].n128_u64[1];
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  a2[4].n128_u64[1] = v7;
  ++a2[4].n128_u32[0];
  ++a1[4].n128_u32[0];
  __n128 result = a2[5];
  a1[6].n128_u64[0] = a2[6].n128_u64[0];
  a1[5] = result;
  return result;
}

__n128 *re::DynamicArray<re::Entry>::copy(__n128 *this, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!a4) {
    return this;
  }
  unint64_t v6 = this;
  unint64_t v7 = this[1].n128_u64[0];
  if (v7 + 1 <= a2)
  {
    uint64_t v17 = 0;
    memset(v19, 0, sizeof(v19));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v18) = 136315906;
    *(void *)((char *)&v18 + 4) = "copy";
    WORD6(v18) = 1024;
    HIWORD(v18) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v17, v18);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_13;
  }
  if (v7 >= v8)
  {
    this = (__n128 *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)v19, a3, a3 + 104 * a4, this[2].n128_u64[0] + 104 * a2);
  }
  else
  {
    re::DynamicArray<re::Entry>::growCapacity(this, a2 + a4);
    unint64_t v10 = v6[1].n128_u64[0];
    uint64_t v11 = a3 + 104 * (v10 - a2);
    this = (__n128 *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)v19, a3, v11, v6[2].n128_u64[0] + 104 * a2);
    if (v10 - a2 != v4)
    {
      uint64_t v12 = 0;
      uint64_t v13 = v6[2].n128_u64[0] + 104 * v6[1].n128_u64[0];
      uint64_t v14 = 104 * a2 + 104 * v4 - 104 * v10;
      do
      {
        uint64_t v15 = v13 + v12;
        re::DynamicArray<BOOL>::DynamicArray(v13 + v12, (uint64_t *)(v11 + v12));
        this = (__n128 *)re::DynamicArray<BOOL>::DynamicArray(v13 + v12 + 40, (uint64_t *)(v11 + v12 + 40));
        long long v16 = *(_OWORD *)(v11 + v12 + 80);
        *(void *)(v15 + 96) = *(void *)(v11 + v12 + 96);
        *(_OWORD *)(v15 + 8re::InputManager::notify(8, 0, 0, 0) = v16;
        v12 += 104;
      }
      while (v14 != v12);
    }
    v6[1].n128_u64[0] = v8;
  }
  ++v6[1].n128_u32[2];
  return this;
}

__n128 *re::DynamicArray<re::Entry>::growCapacity(__n128 *this, unint64_t a2)
{
  unint64_t v2 = this->n128_u64[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (this->n128_u64[0])
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Entry>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Entry>::setCapacity(v4, v3);
      ++v4[1].n128_u32[2];
    }
  }
  return this;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    re::DynamicArray<BOOL>::operator=(a4, (uint64_t *)v5);
    re::DynamicArray<BOOL>::operator=(a4 + 40, (uint64_t *)(v5 + 40));
    uint64_t v7 = *(void *)(v5 + 96);
    *(_OWORD *)(a4 + 8re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(v5 + 80);
    *(void *)(a4 + 96) = v7;
    a4 += 104;
    v5 += 104;
  }
  while (v5 != v6);
  return v6;
}

__n128 *re::DynamicArray<re::Entry>::DynamicArray(__n128 *a1, unint64_t *a2)
{
  a1[2].n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a1[1].n128_u32[2] = 0;
  unint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    a1->n128_u64[0] = v3;
    re::DynamicArray<re::Entry>::setCapacity(a1, v5);
    ++a1[1].n128_u32[2];
    re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::copy(__n128 *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[1].n128_u64[0])
  {
    re::DynamicArray<re::Entry>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)&v17, *(void *)(a2 + 32), *(void *)(a2 + 32) + 104 * a1[1].n128_u64[0], a1[2].n128_i64[0]);
    unint64_t v9 = a1[1].n128_u64[0];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      unint64_t v11 = a1[2].n128_u64[0];
      uint64_t v12 = 104 * v9;
      uint64_t v13 = 104 * v4;
      do
      {
        unint64_t v14 = v11 + v12;
        re::DynamicArray<BOOL>::DynamicArray(v11 + v12, (uint64_t *)(v10 + v12));
        uint64_t result = re::DynamicArray<BOOL>::DynamicArray(v11 + v12 + 40, (uint64_t *)(v10 + v12 + 40));
        long long v15 = *(_OWORD *)(v10 + v12 + 80);
        *(void *)(v14 + 96) = *(void *)(v10 + v12 + 96);
        *(_OWORD *)(v14 + 8re::InputManager::notify(8, 0, 0, 0) = v15;
        v13 -= 104;
        v10 += 104;
        v11 += 104;
      }
      while (v12 != v13);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)&v16, *(void *)(a2 + 32), *(void *)(a2 + 32) + 104 * v4, a1[2].n128_i64[0]);
    unint64_t v6 = a1[1].n128_u64[0];
    if (v4 != v6)
    {
      uint64_t v7 = a1[2].n128_u64[0] + 104 * v4;
      uint64_t v8 = -104 * v4 + 104 * v6;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v7 + 40);
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v7);
        v7 += 104;
        v8 -= 104;
      }
      while (v8);
    }
  }
  a1[1].n128_u64[0] = v4;
  return result;
}

void *re::DynamicArray<re::Message>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::Message>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x180uLL))
        {
          uint64_t v2 = 384 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 384 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 384, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 384 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::Message::Message(v11, v8);
          re::Snapshot::~Snapshot((re::Snapshot *)(v8 + 80));
          re::DynamicArray<unsigned long>::deinit(v8 + 40);
          re::DynamicArray<re::Entry>::deinit(v8);
          v8 += 384;
          v11 += 384;
          v10 -= 384;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, char *a2, unint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if (a3)
  {
    re::DynamicArray<BOOL>::setCapacity((void *)a1, a3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<REFrameAnalysisBottleneck>::copy((void *)a1, 0, a2, a3);
  }
  return a1;
}

void *re::DynamicArray<re::ReadState>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::ReadState>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 48 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::ReadState::ReadState(v11, v8);
          re::DynamicArray<unsigned long>::deinit(v8);
          v8 += 48;
          v11 += 48;
          v10 -= 48;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::ReadState::ReadState(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 24) = 0;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = *(void *)a2;
  *(void *)(result + 8) = v2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(result + 24);
  *(void *)(result + 4re::InputManager::notify(8, 0, 0, 0) = v5;
  return result;
}

unsigned char *re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1)
  {
    if (a1[8]) {
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 16));
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::Progress::becomeProbe(uint64_t this)
{
  if (*(unsigned char *)(this + 64) == 2)
  {
    uint64_t v1 = *(void *)(this + 88);
    *(unsigned char *)(this + 104) = 0;
    *(void *)(this + 88) = 0;
    *(void *)(this + 4re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)(this + 48) = 0;
    if (*(void *)(this + 72) + 1 <= (unint64_t)(v1 + 1)) {
      uint64_t v2 = v1 + 1;
    }
    else {
      uint64_t v2 = *(void *)(this + 72) + 1;
    }
  }
  else
  {
    *(unsigned char *)(this + 104) = 0;
    *(void *)(this + 88) = 0;
    *(void *)(this + 4re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)(this + 48) = 0;
    uint64_t v2 = *(void *)(this + 72) + 1;
  }
  *(unsigned char *)(this + 64) = 0;
  *(void *)(this + 8re::InputManager::notify(8, 0, 0, 0) = v2;
  return this;
}

uint64_t re::Progress::maybeDecrementTo(re::Progress *this, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*((unsigned char *)this + 64) != 1)
  {
    uint64_t v5 = *((void *)this + 10);
    if (v5)
    {
      if (!a4 && v5 - 1 != a2) {
        return 0;
      }
      if (!a4)
      {
        if (a3 + 1 < a2) {
          unint64_t v6 = a3 + 1;
        }
        else {
          unint64_t v6 = a2;
        }
        if (v6 <= 1) {
          unint64_t v6 = 1;
        }
        *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = v6;
LABEL_20:
        *((unsigned char *)this + 104) = 0;
        return 1;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*((void *)this + 12)) {
      *((void *)this + 12) = a4;
    }
    goto LABEL_20;
  }
  unint64_t v4 = *((void *)this + 9);
  if (v4 <= a2 && (a4 || v4 != a2))
  {
    if (a4) {
      *((void *)this + 12) = a4;
    }
    else {
      *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = v4 + 1;
    }
    return 1;
  }
  return 0;
}

void *re::Progress::updateState(void *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 64);
  if (!*((unsigned char *)this + 64))
  {
LABEL_5:
    *((unsigned char *)this + 104) = 1;
    return this;
  }
  if (v2 != 1)
  {
    if (v2 != 2) {
      return this;
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) updating progress state in unhandled state: %hhu", "!\"Unreachable code\"", "updateState", 116, 2);
    this = (void *)_os_crash();
    __break(1u);
    goto LABEL_5;
  }
  this[10] = a2 + 1;
  return re::Inflights::add(this, a2);
}

_anonymous_namespace_ *re::Config::validate@<X0>(_anonymous_namespace_ *this@<X0>, uint64_t a2@<X8>)
{
  if (!*((void *)this + 1))
  {
    uint64_t v7 = "Invalid node ID";
LABEL_13:
    goto LABEL_14;
  }
  unint64_t v3 = *((void *)this + 7);
  if (!v3)
  {
    uint64_t v7 = "Heartbeat must be greater than 0";
    goto LABEL_13;
  }
  unint64_t v4 = *((void *)this + 6);
  if (v4 <= v3)
  {
    uint64_t v7 = "Election tick must be greater than heartbeat tick";
    goto LABEL_13;
  }
  unint64_t v5 = *((void *)this + 4);
  unint64_t v6 = *((void *)this + 5);
  if (!v5) {
    unint64_t v5 = *((void *)this + 6);
  }
  if (!v6) {
    unint64_t v6 = 2 * v4;
  }
  if (v5 >= v4)
  {
    if (v5 >= v6)
    {
      this = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"Min election tick %zu should be less than max election tick %zu", (re::DynamicString *)&v11, v5, v6);
      goto LABEL_14;
    }
    if (*((void *)this + 3))
    {
      *(unsigned char *)a2 = 1;
      return this;
    }
    uint64_t v7 = "Max inflight messages must be greater than 0";
    goto LABEL_13;
  }
  this = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"Election tick %zu must be greater than heartbeat tick %zu", (re::DynamicString *)&v11, v5, v4);
LABEL_14:
  long long v8 = v11;
  uint64_t v9 = v12;
  uint64_t v10 = v13;
  *(unsigned char *)a2 = 0;
  *(void *)(a2 + 8) = 5;
  *(void *)(a2 + 16) = re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v8;
  *(void *)(a2 + 4re::InputManager::notify(8, 0, 0, 0) = v9;
  *(void *)(a2 + 48) = v10;
  return this;
}

uint64_t MemStorageCore::lastIndex(MemStorageCore *this)
{
  uint64_t v1 = *((void *)this + 28);
  if (v1) {
    int v2 = (char *)(*((void *)this + 30) + 104 * v1 - 16);
  }
  else {
    int v2 = (char *)this + 416;
  }
  return *(void *)v2;
}

unsigned char *re::Optional<re::ConfState>::operator=(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  int v4 = *a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    if (*a1) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 48));
      re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 8));
      *a1 = 0;
    }
    else
    {
      uint64_t v8 = (uint64_t)(a1 + 8);
      if (v3) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v4 == 0;
      }
      if (v9)
      {
        re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v8, (uint64_t)(a2 + 8));
        re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=((uint64_t)(a1 + 48), (uint64_t)(a2 + 48));
      }
      else
      {
        *a1 = 1;
        re::ConfState::ConfState(v8, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::removeManyStableAt(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v4 = result;
    unint64_t v5 = a2 + a3 - 1;
    unint64_t v6 = *(void *)(result + 16);
    if (v5 >= v6)
    {
      memset(v10, 0, sizeof(v10));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1) {
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry *,re::Entry *,re::Entry *>((uint64_t)v10, *(void *)(result + 32) + 104 * a2 + 104 * a3, *(void *)(result + 32) + 104 * v6, *(void *)(result + 32) + 104 * a2);
    }
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)(v4 + 32) + 104 * (v7 + *(void *)(v4 + 16));
      uint64_t v9 = v8 - 104;
      re::DynamicArray<unsigned long>::deinit(v8 - 64);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v9);
      --v7;
    }
    while (-a3 != v7);
    *(void *)(v4 + 16) -= a3;
    ++*(_DWORD *)(v4 + 24);
  }
  return result;
}

uint64_t MemStorageCore::setConfState(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  re::DynamicArray<unsigned long long>::operator=(a1 + 128, a2);
  uint64_t result = re::DynamicArray<unsigned long long>::operator=(a1 + 168, a2 + 5);
  if (*(unsigned char *)a3)
  {
    v8[0] = 1;
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v9, (uint64_t *)(a3 + 8));
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v10, (uint64_t *)(a3 + 48));
    re::Optional<re::ConfState>::operator=((unsigned char *)a1, v8);
    uint64_t result = (uint64_t)re::Optional<re::ConfState>::~Optional(v8);
    uint64_t v7 = *(void *)(a3 + 88);
    if (!*(unsigned char *)(a1 + 88)) {
      *(unsigned char *)(a1 + 88) = 1;
    }
    *(void *)(a1 + 96) = v7;
  }
  return result;
}

unsigned char *MemStorage::initialState@<X0>(MemStorage *this@<X0>, uint64_t a2@<X8>)
{
  RaftState::RaftState((uint64_t)v6, (uint64_t)this + 8);
  *(unsigned char *)a2 = 1;
  int v3 = v6[0];
  *(unsigned char *)(a2 + 8) = v6[0];
  if (v3) {
    re::ConfState::ConfState(a2 + 16, (uint64_t)&v7);
  }
  int v4 = v8;
  *(unsigned char *)(a2 + 96) = v8;
  if (v4) {
    *(void *)(a2 + 104) = v9;
  }
  *(_OWORD *)(a2 + 112) = v10;
  *(void *)(a2 + 128) = v11;
  re::ConfState::ConfState(a2 + 136, (uint64_t)v12);
  if (v15)
  {
    if (v19) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    uint64_t v19 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    ++v18;
  }
  if (v12[0])
  {
    if (v14) {
      (*(void (**)(void))(*(void *)v12[0] + 40))();
    }
    uint64_t v14 = 0;
    memset(v12, 0, sizeof(v12));
    ++v13;
  }
  return re::Optional<re::ConfState>::~Optional(v6);
}

void *MemStorage::firstIndex@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  if (this[29]) {
    uint64_t v2 = *(void *)(this[31] + 88);
  }
  else {
    uint64_t v2 = this[53] + 1;
  }
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = v2;
  return this;
}

void *MemStorage::lastIndex@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = this[29];
  if (v2) {
    int v3 = (uint64_t *)(this[31] + 104 * v2 - 16);
  }
  else {
    int v3 = this + 53;
  }
  uint64_t v4 = *v3;
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = v4;
  return this;
}

void *MemStorage::entries@<X0>(void *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  unint64_t v5 = this[29];
  if (v5)
  {
    uint64_t v6 = this[31];
    if (*(void *)(v6 + 88) <= a2)
    {
      unint64_t v7 = *(void *)(v6 + 104 * v5 - 16) + 1;
      goto LABEL_6;
    }
LABEL_5:
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 8) = 0;
    return this;
  }
  unint64_t v7 = this[53] + 1;
  if (v7 > a2) {
    goto LABEL_5;
  }
LABEL_6:
  if (v7 < a3)
  {
    uint64_t Index = MemStorageCore::lastIndex((MemStorageCore *)(this + 1));
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of bound (last: %llu, high: %llu)", "!\"Unreachable code\"", "entries", 202, Index + 1, a3);
    this = (void *)_os_crash();
    __break(1u);
    return this;
  }
  uint64_t v8 = this[31];
  unint64_t v9 = a2 - *(void *)(v8 + 88);
  unint64_t v10 = v5 + 1;
  if (v5 + 1 <= v9)
  {
    v18[0] = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    memset(v22, 0, sizeof(v22));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v19 = 136315906;
    *(void *)&v19[4] = "slice";
    *(_WORD *)&v19[12] = 1024;
    *(_DWORD *)&v19[14] = 1119;
    *(_WORD *)&v19[18] = 2048;
    *(void *)&v19[20] = v9;
    __int16 v20 = 2048;
    *(void *)long long v21 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_13;
  }
  unint64_t v11 = a3 - a2;
  if (__CFADD__(v9, a3 - a2))
  {
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 1125, v9, v11, v5);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 1129, v9, v11, v5);
    _os_crash();
    __break(1u);
  }
  if (a3 - *(void *)(v8 + 88) > v5) {
    goto LABEL_14;
  }
  v18[0] = v8 + 104 * v9;
  v18[1] = a3 - a2;
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v19, v18);
  uint64_t v12 = *(void *)v19;
  *(void *)uint64_t v19 = 0;
  uint64_t v13 = *(void *)&v21[2];
  *(void *)&void v21[2] = 0;
  ++*(_DWORD *)&v19[24];
  *(unsigned char *)a4 = 1;
  *(void *)(a4 + 8) = v12;
  *(void *)&v22[0] = 0;
  long long v14 = *(_OWORD *)&v19[8];
  *(_OWORD *)&unsigned char v19[8] = 0u;
  *(_OWORD *)(a4 + 16) = v14;
  *(_OWORD *)((char *)v22 + 8) = 0u;
  *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v13;
  *(void *)&long long v23 = 0;
  DWORD2(v22[1]) = 2;
  *(_DWORD *)(a4 + 32) = 1;
  re::DynamicArray<re::Entry>::deinit((uint64_t)v22);
  return (void *)re::DynamicArray<re::Entry>::deinit((uint64_t)v19);
}

uint64_t MemStorage::initializeWithConfState(void *a1, uint64_t *a2)
{
  a1[53] = 1;
  a1[54] = 1;
  a1[16] = 1;
  a1[14] = 1;
  re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 17), a2);
  return re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 22), a2 + 5);
}

void *MemStorage::term@<X0>(void *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = this[53];
  if (v3 == a2)
  {
    uint64_t v4 = this[54];
LABEL_10:
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v4;
    return this;
  }
  unint64_t v5 = this[29];
  if (v5) {
    unint64_t v6 = *(void *)(this[31] + 88);
  }
  else {
    unint64_t v6 = v3 + 1;
  }
  if (v6 > a2)
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 8) = 0;
    return this;
  }
  uint64_t v7 = this[31];
  unint64_t v8 = a2 - *(void *)(v7 + 88);
  if (v8 < v5)
  {
    uint64_t v4 = *(void *)(v7 + 104 * v8 + 96);
    goto LABEL_10;
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 8) = 1;
  return this;
}

void MemStorage::snapshot(MemStorage *this@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (*((unsigned char *)this + 440))
  {
    *((unsigned char *)this + 44re::InputManager::notify(8, 0, 0, 0) = 0;
    *a3 = 0;
    a3[8] = 3;
  }
  else
  {
    long long v12 = 0u;
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    memset(v9, 0, sizeof(v9));
    uint64_t v6 = *((void *)this + 14);
    unint64_t v13 = *((void *)this + 16);
    uint64_t v14 = v6;
    re::DynamicArray<unsigned long long>::operator=((uint64_t)&v9[2] + 8, (uint64_t *)this + 17);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)v10, (uint64_t *)this + 22);
    if (*((unsigned char *)this + 8))
    {
      uint64_t v7 = *((void *)this + 13);
      re::DynamicArray<unsigned long long>::operator=((uint64_t)&v10[2] + 8, (uint64_t *)this + 2);
      re::DynamicArray<unsigned long long>::operator=((uint64_t)v11, (uint64_t *)this + 7);
      *((void *)&v12 + 1) = v7;
    }
    if (v13 < a2) {
      unint64_t v13 = a2;
    }
    re::types::Ok<re::Snapshot>::Ok((uint64_t)v8, (uint64_t)v9);
    re::Result<re::Snapshot,re::StorageError>::Result((uint64_t)a3, (uint64_t)v8);
    re::Snapshot::~Snapshot((re::Snapshot *)v8);
    re::Snapshot::~Snapshot((re::Snapshot *)v9);
  }
}

void MemStorage::append(void *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (!*(void *)(a2 + 16)) {
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = a1[29];
  if (v6)
  {
    uint64_t v7 = a1[31];
    unint64_t v8 = *(void *)(v7 + 88);
    unint64_t v9 = *(void *)(v5 + 88);
    if (v8 <= v9)
    {
      uint64_t v10 = *(void *)(v7 + 104 * v6 - 16);
      unint64_t v11 = v10 + 1;
      goto LABEL_7;
    }
LABEL_6:
    re::DynamicString::format((re::DynamicString *)"Overwrite compacted logs, compacted: %llu, append: %llu", (re::DynamicString *)&v16, v8 - 1, v9);
LABEL_9:
    if (v16 && (v17 & 1) != 0) {
      (*(void (**)(void))(*(void *)v16 + 40))();
    }
    goto LABEL_15;
  }
  uint64_t v10 = a1[53];
  unint64_t v8 = v10 + 1;
  unint64_t v9 = *(void *)(v5 + 88);
  unint64_t v11 = v10 + 1;
  if (v10 + 1 > v9) {
    goto LABEL_6;
  }
LABEL_7:
  if (v11 < v9)
  {
    re::DynamicString::format((re::DynamicString *)"Raft logs should be continuous. Last index: %llu, newly appended: %llu", (re::DynamicString *)&v16, v10, v9);
    goto LABEL_9;
  }
  long long v12 = (__n128 *)(a1 + 27);
  re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)(a1 + 27), v9 - v8, v6 - (v9 - v8));
  uint64_t v13 = *(void *)(a2 + 16);
  if (v13)
  {
    uint64_t v14 = *(__n128 **)(a2 + 32);
    uint64_t v15 = 104 * v13;
    do
    {
      re::DynamicArray<re::Entry>::add(v12, v14);
      uint64_t v14 = (__n128 *)((char *)v14 + 104);
      v15 -= 104;
    }
    while (v15);
  }
LABEL_15:
  *a3 = 1;
}

void *MemStorage::compact@<X0>(void *this@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v4 = this[29];
  if (v4)
  {
    uint64_t v5 = this[31];
    unint64_t v6 = *(void *)(v5 + 88);
    if (a2 <= v6) {
      goto LABEL_9;
    }
    uint64_t v7 = *(void *)(v5 + 104 * v4 - 16);
    if (v7 + 1 >= a2)
    {
      this = (void *)re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)(this + 27), 0, a2 - v6);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v7 = this[53];
    if (v7 + 1 >= a2) {
      goto LABEL_9;
    }
  }
  re::DynamicString::format((re::DynamicString *)"Compact not received raft logs: %llu, last index: %llu", (re::DynamicString *)&v8, a2, v7);
  this = (void *)v8;
  if (v8 && (v9 & 1) != 0) {
    this = (void *)(*(uint64_t (**)(void))(*(void *)v8 + 40))();
  }
LABEL_9:
  *a3 = 1;
  return this;
}

uint64_t MemStorage::triggerSnapUnavailable(uint64_t this)
{
  *(unsigned char *)(this + 44re::InputManager::notify(8, 0, 0, 0) = 1;
  return this;
}

void *MemStorage::applySnapshot@<X0>(void *this@<X0>, const re::Snapshot *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v4 = (uint64_t)this;
  unint64_t v6 = *((void *)a2 + 26);
  if (this[29]) {
    unint64_t v7 = *(void *)(this[31] + 88);
  }
  else {
    unint64_t v7 = this[53] + 1;
  }
  if (v7 <= v6)
  {
    uint64_t v8 = *((void *)a2 + 27);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)(this + 32), (uint64_t *)a2 + 5);
    re::DynamicArray<unsigned long long>::operator=(v4 + 296, (uint64_t *)a2 + 10);
    re::DynamicArray<unsigned long long>::operator=(v4 + 336, (uint64_t *)a2 + 15);
    re::DynamicArray<unsigned long long>::operator=(v4 + 376, (uint64_t *)a2 + 20);
    uint64_t v9 = *((void *)a2 + 27);
    *(_OWORD *)(v4 + 416) = *(_OWORD *)((char *)a2 + 200);
    *(void *)(v4 + 432) = v9;
    *(void *)(v4 + 112) = v8;
    *(void *)(v4 + 128) = v6;
    re::DynamicArray<re::Entry>::clear(v4 + 216);
    re::DynamicArray<unsigned long long>::operator=(v4 + 136, (uint64_t *)a2 + 5);
    this = (void *)re::DynamicArray<unsigned long long>::operator=(v4 + 176, (uint64_t *)a2 + 10);
    if (*((void *)a2 + 25))
    {
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v14, (uint64_t *)a2 + 15);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v15, (uint64_t *)a2 + 20);
      uint64_t v10 = *((void *)a2 + 25);
      v11[0] = 1;
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v12, v14);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13, v15);
      re::Optional<re::ConfState>::operator=((unsigned char *)(v4 + 8), v11);
      re::Optional<re::ConfState>::~Optional(v11);
      if (!*(unsigned char *)(v4 + 96)) {
        *(unsigned char *)(v4 + 96) = 1;
      }
      *(void *)(v4 + 104) = v10;
      if (v15[0])
      {
        if (v17) {
          (*(void (**)(void))(*(void *)v15[0] + 40))();
        }
        uint64_t v17 = 0;
        memset(v15, 0, sizeof(v15));
        ++v16;
      }
      this = (void *)v14[0];
      if (v14[0])
      {
        if (v14[4]) {
          this = (void *)(*(uint64_t (**)(void))(*(void *)v14[0] + 40))();
        }
      }
    }
    *a3 = 1;
  }
  else
  {
    *(_WORD *)a3 = 512;
  }
  return this;
}

void MemStorage::~MemStorage(MemStorage *this)
{
  *(void *)this = &unk_26E716258;
  MemStorageCore::~MemStorageCore((MemStorage *)((char *)this + 8));
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E716258;
  MemStorageCore::~MemStorageCore((MemStorage *)((char *)this + 8));
  JUMPOUT(0x237DBCBD0);
}

void MemStorageCore::~MemStorageCore(MemStorageCore *this)
{
  uint64_t v2 = (char *)this + 248;
  uint64_t v3 = (char *)this + 328;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 368);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v3);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 288);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  re::DynamicArray<re::Entry>::deinit((uint64_t)this + 208);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 168);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 128);
  re::Optional<re::ConfState>::~Optional(this);
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry *,re::Entry *,re::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a4, v5);
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a4 + 40, v5 + 40);
    uint64_t v7 = *(void *)(v5 + 96);
    *(_OWORD *)(a4 + 8re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(v5 + 80);
    *(void *)(a4 + 96) = v7;
    a4 += 104;
    v5 += 104;
  }
  while (v5 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::Entry>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  unint64_t v3 = a2[1];
  if (v3)
  {
    re::DynamicArray<re::Entry>::setCapacity((__n128 *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Entry>::copy((__n128 *)a1, 0, *a2, a2[1]);
  }
  return a1;
}

uint64_t re::types::Ok<re::Snapshot>::Ok(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::DynamicArray<BOOL>::DynamicArray(a1, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 40, (uint64_t *)(a2 + 40));
  re::DynamicArray<char const*>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 120, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 160, (uint64_t *)(a2 + 160));
  long long v5 = *(_OWORD *)(a2 + 200);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(_OWORD *)(a1 + 20re::InputManager::notify(8, 0, 0, 0) = v5;
  return a1;
}

uint64_t re::Result<re::Snapshot,re::StorageError>::Result(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 1;
  re::DynamicArray<BOOL>::DynamicArray(a1 + 8, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(a1 + 48, (uint64_t *)(a2 + 40));
  re::DynamicArray<char const*>::DynamicArray(a1 + 88, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 128, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 168, (uint64_t *)(a2 + 160));
  long long v4 = *(_OWORD *)(a2 + 200);
  *(void *)(a1 + 224) = *(void *)(a2 + 216);
  *(_OWORD *)(a1 + 208) = v4;
  return a1;
}

uint64_t re::ReadOnly::addRequest(re::ReadOnly *this, uint64_t a2, const re::Message *a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  if (!*((void *)a3 + 2))
  {
    v21[0] = 0;
    memset(v27, 0, 32);
    long long v25 = 0u;
    long long v26 = 0u;
    long long v24 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v29 = 136315906;
    *(void *)&v29[4] = "operator[]";
    __int16 v30 = 1024;
    int v31 = 797;
    __int16 v32 = 2048;
    uint64_t v33 = 0;
    __int16 v34 = 2048;
    *(void *)uint64_t v35 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v29, *((uint64_t **)a3 + 4));
  if (!re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey((uint64_t)this, (uint64_t)v29))
  {
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)v21, (uint64_t *)v29);
    long long v25 = 0u;
    long long v26 = 0u;
    long long v24 = 0u;
    DWORD1(v26) = 0x7FFFFFFF;
    re::Message::Message((re::Message *)v27, a3);
    uint64_t v28 = a2;
    unint64_t v6 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)&v23, (uint64_t)v21);
    unint64_t v7 = v6;
    if (*(void *)this)
    {
      unint64_t v8 = v6 % *((unsigned int *)this + 6);
      uint64_t v9 = *(unsigned int *)(*((void *)this + 1) + 4 * v8);
      if (v9 != 0x7FFFFFFF)
      {
        uint64_t v10 = *((void *)this + 2);
        size_t v11 = v21[2];
        uint64_t v12 = __s2;
        do
        {
          if (*(void *)(v10 + 496 * v9 + 32) == v11)
          {
            uint64_t v13 = memcmp(*(const void **)(v10 + 496 * v9 + 48), v12, v11);
            if (!v13) {
              goto LABEL_12;
            }
          }
          uint64_t v9 = *(_DWORD *)(v10 + 496 * v9 + 8) & 0x7FFFFFFF;
        }
        while (v9 != 0x7FFFFFFF);
      }
    }
    else
    {
      LODWORD(v8) = 0;
    }
    uint64_t v13 = re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove((uint64_t)this, v8, v7, v21, (uint64_t *)&v24);
    ++*((_DWORD *)this + 10);
LABEL_12:
    uint64_t v15 = (uint64_t *)((char *)this + 64);
    uint64_t v14 = *((void *)this + 8);
    unint64_t v16 = v14 + 1;
    unint64_t v17 = *((void *)this + 7);
    if (v14 + 1 >= v17)
    {
      if (v17 < v16)
      {
        if (*((void *)this + 6))
        {
          unint64_t v18 = 2 * v17;
          if (!v17) {
            unint64_t v18 = 8;
          }
          if (v18 <= v16) {
            unint64_t v19 = v16;
          }
          else {
            unint64_t v19 = v18;
          }
          re::Queue<re::DynamicArray<unsigned char>>::setCapacity((void *)this + 6, v19);
          uint64_t v14 = *v15;
        }
        else
        {
          re::Queue<re::DynamicArray<unsigned char>>::setCapacity((void *)this + 6, v16);
          uint64_t v14 = 0;
          *uint64_t v15 = 0;
          *((void *)this + 9) = 0;
          *((_DWORD *)this + 2re::InputManager::notify(8, 0, 0, 0) = 0;
        }
      }
      unint64_t v17 = *((void *)this + 7);
    }
    re::DynamicArray<BOOL>::DynamicArray(*((void *)this + 11) + 40 * ((*((void *)this + 9) + v14) % v17), v21);
    ++*((void *)this + 8);
    ++*((_DWORD *)this + 20);
    re::ReadIndexStatus::~ReadIndexStatus((re::ReadIndexStatus *)&v24);
    if (v21[0] && __s2) {
      (*(void (**)(void))(*(void *)v21[0] + 40))();
    }
  }
  uint64_t result = *(void *)v29;
  if (*(void *)v29)
  {
    if (*(void *)&v35[2]) {
      return (*(uint64_t (**)(void))(**(void **)v29 + 40))(*(void *)v29);
    }
  }
  return result;
}

BOOL re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)&v11, a2);
  uint64_t v5 = 0x7FFFFFFFLL;
  if (*(void *)a1)
  {
    uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      size_t v8 = *(void *)(a2 + 16);
      uint64_t v5 = 0x7FFFFFFFLL;
      uint64_t v9 = *(const void **)(a2 + 32);
      while (*(void *)(v7 + 496 * v6 + 32) != v8 || memcmp(*(const void **)(v7 + 496 * v6 + 48), v9, v8))
      {
        uint64_t v6 = *(_DWORD *)(v7 + 496 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF) {
          return v5 != 0x7FFFFFFF;
        }
      }
      uint64_t v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

double re::ReadOnly::recvAck@<D0>(re::ReadOnly *this@<X0>, const re::Message *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (char *)a2 + 40;
  if (re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey((uint64_t)this, (uint64_t)a2 + 40))
  {
    unint64_t v7 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v15, (uint64_t)v6);
    if (*(void *)this
      && (uint64_t v8 = *(unsigned int *)(*((void *)this + 1) + 4 * (v7 % *((unsigned int *)this + 6))),
          v8 != 0x7FFFFFFF))
    {
      uint64_t v11 = *((void *)this + 2);
      size_t v12 = *((void *)a2 + 7);
      uint64_t v9 = 0x7FFFFFFFLL;
      uint64_t v13 = (const void *)*((void *)a2 + 9);
      while (*(void *)(v11 + 496 * v8 + 32) != v12 || memcmp(*(const void **)(v11 + 496 * v8 + 48), v13, v12))
      {
        uint64_t v8 = *(_DWORD *)(v11 + 496 * v8 + 8) & 0x7FFFFFFF;
        if (v8 == 0x7FFFFFFF) {
          goto LABEL_12;
        }
      }
      uint64_t v9 = v8;
    }
    else
    {
      uint64_t v9 = 0x7FFFFFFFLL;
    }
LABEL_12:
    uint64_t v14 = *((void *)this + 2) + 496 * v9 + 56;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v14, (uint64_t *)a2 + 40);
    long long v16 = 0u;
    memset(v15, 0, sizeof(v15));
    DWORD1(v16) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v15, (uint64_t *)a2 + 39);
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet(v14, (uint64_t)v15, a3);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v15);
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 36) = 0x7FFFFFFF;
  }
  return result;
}

uint64_t re::ReadOnly::advance@<X0>(re::ReadOnly *this@<X0>, const re::Message *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  uint64_t v5 = *((void *)this + 8);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)this + 9);
    unint64_t v8 = *((void *)this + 7);
    uint64_t v9 = *((void *)this + 11);
    size_t v10 = *((void *)a2 + 7);
    uint64_t v11 = (const void *)*((void *)a2 + 9);
    while (1)
    {
      unint64_t v12 = (v7 + v6) % v8;
      if (*(void *)(v9 + 40 * v12 + 16) == v10 && !memcmp(*(const void **)(v9 + 40 * v12 + 32), v11, v10)) {
        break;
      }
      if (v5 == ++v6)
      {
        uint64_t v42 = v5;
        goto LABEL_9;
      }
    }
    uint64_t v42 = v6;
  }
  else
  {
    uint64_t v42 = 0;
  }
LABEL_9:
  uint64_t v13 = 0;
  while (*((void *)this + 8))
  {
    uint64_t v14 = *((void *)this + 11) + 40 * *((void *)this + 9);
    uint64_t v47 = *(void *)v14;
    *(void *)uint64_t v14 = 0;
    long long v48 = *(_OWORD *)(v14 + 8);
    *(void *)(v14 + 8) = 0;
    *(void *)(v14 + 16) = 0;
    long long v50 = *(const re::Message **)(v14 + 32);
    *(void *)(v14 + 32) = 0;
    ++*(_DWORD *)(v14 + 24);
    int v49 = 1;
    re::DynamicArray<unsigned long>::deinit(*((void *)this + 11) + 40 * *((void *)this + 9));
    uint64_t v15 = *((void *)this + 9);
    if ((unint64_t)(v15 + 1) < *((void *)this + 7)) {
      uint64_t v16 = v15 + 1;
    }
    else {
      uint64_t v16 = 0;
    }
    --*((void *)this + 8);
    *((void *)this + 9) = v16;
    ++*((_DWORD *)this + 20);
    unint64_t v17 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v51, (uint64_t)&v47);
    uint64_t v43 = v13;
    if (*(void *)this)
    {
      uint64_t v18 = *((void *)this + 2);
      uint64_t v19 = *(unsigned int *)(*((void *)this + 1) + 4 * (v17 % *((unsigned int *)this + 6)));
      if (v19 != 0x7FFFFFFF)
      {
        size_t v20 = *((void *)&v48 + 1);
        long long v21 = v50;
        while (*(void *)(v18 + 496 * v19 + 32) != v20 || memcmp(*(const void **)(v18 + 496 * v19 + 48), v21, v20))
        {
          uint64_t v19 = *(_DWORD *)(v18 + 496 * v19 + 8) & 0x7FFFFFFF;
          if (v19 == 0x7FFFFFFF) {
            goto LABEL_22;
          }
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v18 = *((void *)this + 2);
    }
LABEL_22:
    uint64_t v19 = 0x7FFFFFFFLL;
LABEL_23:
    uint64_t v22 = v18 + 496 * v19;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v44, v22 + 56);
    char v23 = re::Message::Message((re::Message *)v45, (const re::Message *)(v22 + 104));
    uint64_t v46 = *(void *)(v22 + 488);
    unint64_t v24 = *(void *)(a3 + 8);
    unint64_t v25 = *(void *)(a3 + 16);
    if (v25 >= v24)
    {
      if (v24 < v25 + 1)
      {
        if (*(void *)a3)
        {
          uint64_t v26 = 2 * v24;
          BOOL v27 = v24 == 0;
          unint64_t v28 = 8;
          if (!v27) {
            unint64_t v28 = v26;
          }
          if (v28 <= v25 + 1) {
            unint64_t v29 = v25 + 1;
          }
          else {
            unint64_t v29 = v28;
          }
          re::DynamicArray<re::ReadIndexStatus>::setCapacity((void *)a3, v29);
        }
        else
        {
          re::DynamicArray<re::ReadIndexStatus>::setCapacity((void *)a3, v25 + 1);
          ++*(_DWORD *)(a3 + 24);
        }
      }
      unint64_t v25 = *(void *)(a3 + 16);
    }
    uint64_t v30 = *(void *)(a3 + 32) + 440 * v25;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(v30, (uint64_t)v44);
    re::Message::Message((re::Message *)(v30 + 48), (const re::Message *)v45);
    *(void *)(v30 + 432) = v46;
    *(void *)(a3 + 16) = v25 + 1;
    ++*(_DWORD *)(a3 + 24);
    unint64_t v31 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v51, (uint64_t)&v47);
    if (*(void *)this)
    {
      uint64_t v32 = *((void *)this + 1);
      unint64_t v41 = v31 % *((unsigned int *)this + 6);
      uint64_t v33 = *(unsigned int *)(v32 + 4 * v41);
      if (v33 != 0x7FFFFFFF)
      {
        uint64_t v34 = *((void *)this + 2);
        uint64_t v35 = 0x7FFFFFFFLL;
        size_t v36 = *((void *)&v48 + 1);
        uint64_t v37 = v50;
        while (*(void *)(v34 + 496 * v33 + 32) != v36 || memcmp(*(const void **)(v34 + 496 * v33 + 48), v37, v36))
        {
          uint64_t v35 = v33;
          uint64_t v33 = *(_DWORD *)(v34 + 496 * v33 + 8) & 0x7FFFFFFF;
          if (v33 == 0x7FFFFFFF) {
            goto LABEL_45;
          }
        }
        int v38 = *(_DWORD *)(v34 + 496 * v33 + 8) & 0x7FFFFFFF;
        if (v35 == 0x7FFFFFFF) {
          *(_DWORD *)(v32 + 4 * v41) = v38;
        }
        else {
          *(_DWORD *)(v34 + 496 * v35 + 8) = *(_DWORD *)(v34 + 496 * v35 + 8) & 0x80000000 | v38;
        }
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(*((void *)this + 2) + 496 * v33);
        *(_DWORD *)(*((void *)this + 2) + 496 * v33 + 8) = *(_DWORD *)(*((void *)this + 2) + 496 * v33 + 8) & 0x80000000 | *((_DWORD *)this + 9);
        --*((_DWORD *)this + 7);
        int v39 = *((_DWORD *)this + 10) + 1;
        *((_DWORD *)this + 9) = v33;
        *((_DWORD *)this + 1re::InputManager::notify(8, 0, 0, 0) = v39;
      }
    }
LABEL_45:
    re::ReadIndexStatus::~ReadIndexStatus((re::ReadIndexStatus *)v44);
    uint64_t result = v47;
    if (v47)
    {
      a2 = v50;
      if (v50) {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v47 + 40))();
      }
    }
    uint64_t v13 = v43 + 1;
    if (v43 == v42) {
      return result;
    }
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Queue<T> is empty", "m_size > 0", "dequeue", 569);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void *re::ReadOnly::lastPendingRequestCtx@<X0>(void *this@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v2 = this[8];
  if (v2)
  {
    unint64_t v3 = (uint64_t *)(this[11] + 40 * ((unint64_t)(this[9] + v2) % this[7]));
    *a2 = 1;
    return (void *)re::DynamicArray<BOOL>::DynamicArray((uint64_t)(a2 + 8), v3);
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

unint64_t re::Hash<re::DynamicArray<unsigned char>>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5[2] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return 0;
  }
  MurmurHash3_x64_128(*(void *)(a2 + 32), v3, 0, v5);
  return (v5[1] + (v5[0] << 6) + (v5[0] >> 2) - 0x61C8864680B583E9) ^ v5[0];
}

void *re::DynamicArray<re::ReadIndexStatus>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::ReadIndexStatus>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x1B8uLL))
        {
          uint64_t v2 = 440 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 440 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 440, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        size_t v10 = &v8[55 * v9];
        uint64_t v11 = (uint64_t)(v7 + 6);
        do
        {
          *(_DWORD *)(v11 - 16) = 0;
          *(_OWORD *)(v11 - 32) = 0u;
          *(_OWORD *)(v11 - 48) = 0u;
          *(void *)(v11 - 12) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(v11 - 48), v8);
          re::Message::Message(v11, (uint64_t)(v8 + 6));
          *(void *)(v11 + 384) = v8[54];
          re::ReadIndexStatus::~ReadIndexStatus((re::ReadIndexStatus *)v8);
          v11 += 440;
          v8 += 55;
        }
        while (v8 != v10);
        unint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::Configuration::validate@<D0>(re::Configuration *this@<X0>, uint64_t a2@<X8>)
{
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  DWORD1(v27) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v25);
  uint64_t v5 = *((unsigned int *)this + 8);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (int *)(*((void *)this + 2) + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 6;
      if (v8 < 0) {
        break;
      }
      if (v5 == ++v6)
      {
        LODWORD(v6) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v5 != v6)
  {
    uint64_t v9 = v6;
    uint64_t v10 = *((void *)this + 2);
    do
    {
      uint64_t v4 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 48, (uint64_t *)(v10 + 24 * v9 + 16));
      if (v4) {
        uint64_t v4 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v25, (uint64_t *)(*((void *)this + 2) + 24 * v9 + 16));
      }
      unsigned int v11 = *((_DWORD *)this + 8);
      uint64_t v10 = *((void *)this + 2);
      if (v11 <= (int)v6 + 1) {
        int v12 = v6 + 1;
      }
      else {
        int v12 = *((_DWORD *)this + 8);
      }
      while (1)
      {
        uint64_t v9 = (v6 + 1);
        if (v12 - 1 == v6) {
          break;
        }
        LODWORD(v6) = v6 + 1;
        int v13 = v9;
        if ((*(_DWORD *)(v10 + 24 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_18;
        }
      }
      int v13 = v12;
LABEL_18:
      LODWORD(v6) = v13;
    }
    while (v11 != v13);
  }
  if (HIDWORD(v26))
  {
    uint64_t v14 = 0;
    if (v27)
    {
      uint64_t v15 = (int *)(v26 + 8);
      while (1)
      {
        int v16 = *v15;
        v15 += 6;
        if (v16 < 0) {
          break;
        }
        if (v27 == ++v14)
        {
          LODWORD(v14) = v27;
          break;
        }
      }
    }
    re::DynamicString::format((re::DynamicString *)"There can be no overlap of voters and learners: %llu", (re::DynamicString *)&v22, *(void *)(v26 + 24 * v14 + 16));
    long long v17 = v22;
    uint64_t v18 = v23;
    uint64_t v19 = v24;
    *(unsigned char *)a2 = 0;
    uint64_t v20 = 6;
  }
  else
  {
    if (*((_DWORD *)this + 7))
    {
      *(unsigned char *)a2 = 1;
      return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v25);
    }
    long long v17 = v22;
    uint64_t v18 = v23;
    uint64_t v19 = v24;
    *(unsigned char *)a2 = 0;
    uint64_t v20 = 5;
  }
  *(void *)(a2 + 8) = v20;
  *(void *)(a2 + 16) = re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v17;
  *(void *)(a2 + 4re::InputManager::notify(8, 0, 0, 0) = v18;
  *(void *)(a2 + 48) = v19;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v25);
}

BOOL re::Configuration::hasQuorum(uint64_t a1, uint64_t a2)
{
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  DWORD1(v17) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v15);
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(a1 + 16) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    uint64_t v9 = *(void *)(a1 + 16);
    do
    {
      if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(a2, (uint64_t *)(v9 + 24 * v8 + 16)))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v15, (uint64_t *)(*(void *)(a1 + 16) + 24 * v8 + 16));
      }
      unsigned int v10 = *(_DWORD *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 16);
      if (v10 <= (int)v5 + 1) {
        int v11 = v5 + 1;
      }
      else {
        int v11 = *(_DWORD *)(a1 + 32);
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v11 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        int v12 = v8;
        if ((*(_DWORD *)(v9 + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_18;
        }
      }
      int v12 = v11;
LABEL_18:
      LODWORD(v5) = v12;
    }
    while (v10 != v12);
  }
  BOOL v13 = HIDWORD(v16) > *(_DWORD *)(a1 + 28) >> 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v15);
  return v13;
}

void re::ProgressSet::voterIds(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  if (*((unsigned char *)this + 88))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 192, (uint64_t)this + 96, a2);
  }
  else
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(a2, (uint64_t)this + 192);
  }
}

void re::ProgressSet::learnerIds(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  if (*((unsigned char *)this + 88))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 240, (uint64_t)this + 144, a2);
  }
  else
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(a2, (uint64_t)this + 240);
  }
}

double re::ProgressSet::assertProgressAndConfigurationConsistent(re::ProgressSet *this)
{
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  DWORD1(v18) = 0x7FFFFFFF;
  re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 192, (uint64_t)this + 240, (uint64_t)&v16);
  if (v18)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (int *)(v17 + 8);
    while (1)
    {
      int v4 = *v3;
      v3 += 6;
      if (v4 < 0) {
        break;
      }
      if (v18 == ++v2)
      {
        LODWORD(v2) = v18;
        break;
      }
    }
  }
  else
  {
    LODWORD(v2) = 0;
  }
  while (v18 != v2)
  {
    if (v18 <= (int)v2 + 1) {
      int v5 = v2 + 1;
    }
    else {
      int v5 = v18;
    }
    while (v5 - 1 != v2)
    {
      LODWORD(v2) = v2 + 1;
      if ((*(_DWORD *)(v17 + 24 * v2 + 8) & 0x80000000) != 0) {
        goto LABEL_15;
      }
    }
    LODWORD(v2) = v5;
LABEL_15:
    ;
  }
  uint64_t v6 = *((unsigned int *)this + 8);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (int *)(*((void *)this + 2) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 34;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if (v6 != v7)
  {
    uint64_t v10 = v7;
    do
    {
      uint64_t v11 = *((void *)this + 2);
      uint64_t v15 = 0;
      uint64_t v15 = *(void *)(v11 + 136 * v10 + 16);
      if (*((unsigned char *)this + 88)
        && !re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 144, &v15))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 96, &v15);
      }
      if (*((_DWORD *)this + 8) <= (v7 + 1)) {
        int v12 = v7 + 1;
      }
      else {
        int v12 = *((_DWORD *)this + 8);
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v12 - 1 == v7) {
          break;
        }
        LODWORD(v7) = v7 + 1;
        int v13 = v10;
        if ((*(_DWORD *)(*((void *)this + 2) + 136 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_34;
        }
      }
      int v13 = v12;
LABEL_34:
      LODWORD(v7) = v13;
    }
    while (v6 != v13);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v16);
}

uint64_t re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(void *)(v11 + 40 * v10 + 16) == v6) {
        return result;
      }
      while (1)
      {
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + 40 * v10 + 16) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  uint64_t result = re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::ProgressSet::restoreSnapshotMeta@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 16re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 8re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 24re::InputManager::notify(8, 0, 0, 0) = 0u;
  uint64_t v8 = a4 + 240;
  *(_OWORD *)(a4 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = 0u;
  uint64_t v9 = a4 + 192;
  *(_DWORD *)(a4 + 36) = 0x7FFFFFFF;
  *(void *)(a4 + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a4 + 56) = 0;
  *(void *)(a4 + 64) = 0;
  *(void *)(a4 + 48) = 0;
  *(_DWORD *)(a4 + 72) = 0;
  *(_OWORD *)(a4 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_DWORD *)(a4 + 228) = 0x7FFFFFFF;
  *(_OWORD *)(a4 + 24re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = 0u;
  *(_DWORD *)(a4 + 276) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a4 + 192, 0);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v8, 0);
  *(void *)(a4 + 288) = 0;
  *(void *)(a4 + 296) = 0;
  memset(v35, 0, sizeof(v35));
  int v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  unint64_t v40 = a3;
  re::DynamicArray<float *>::setCapacity(v35, a3);
  char v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = a2;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  __int16 v46 = 0;
  uint64_t v10 = a1[2];
  if (v10)
  {
    uint64_t v11 = (uint64_t *)a1[4];
    uint64_t v12 = 8 * v10;
    do
    {
      uint64_t v13 = *v11++;
      uint64_t v28 = v13;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(a4, &v28, (re::Progress *)v35);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v9, &v28);
      v12 -= 8;
    }
    while (v12);
  }
  uint64_t v14 = a1[7];
  if (v14)
  {
    uint64_t v15 = (uint64_t *)a1[9];
    uint64_t v16 = 8 * v14;
    do
    {
      uint64_t v17 = *v15++;
      uint64_t v28 = v17;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(a4, &v28, (re::Progress *)v35);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v8, &v28);
      v16 -= 8;
    }
    while (v16);
  }
  if (a1[20])
  {
    memset(v31, 0, sizeof(v31));
    long long v32 = 0u;
    memset(v33, 0, sizeof(v33));
    long long v34 = 0u;
    DWORD1(v32) = 0x7FFFFFFF;
    DWORD1(v34) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v31, 0);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v33, 0);
    uint64_t v18 = a1[12];
    if (v18)
    {
      uint64_t v19 = (uint64_t *)a1[14];
      uint64_t v20 = 8 * v18;
      do
      {
        uint64_t v21 = *v19++;
        uint64_t v28 = v21;
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<re::Progress&>(a4, &v28, (re::Progress *)v35);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v31, &v28);
        v20 -= 8;
      }
      while (v20);
    }
    uint64_t v22 = a1[17];
    if (v22)
    {
      uint64_t v23 = (uint64_t *)a1[19];
      uint64_t v24 = 8 * v22;
      do
      {
        uint64_t v25 = *v23++;
        uint64_t v28 = v25;
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<re::Progress&>(a4, &v28, (re::Progress *)v35);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v33, &v28);
        v24 -= 8;
      }
      while (v24);
    }
    LOBYTE(v28) = 1;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v29, (uint64_t)v31);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v30, (uint64_t)v33);
    re::Optional<re::Configuration>::operator=((unsigned __int8 *)(a4 + 88), &v28);
    re::Optional<re::Configuration>::~Optional((uint64_t)&v28);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v33);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v31);
  }
  double v26 = re::ProgressSet::assertProgressAndConfigurationConsistent((re::ProgressSet *)a4);
  uint64_t result = v35[0];
  if (v35[0])
  {
    if (v37) {
      return (*(uint64_t (**)(double))(*(void *)v35[0] + 40))(v26);
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(uint64_t result, uint64_t *a2, re::Progress *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(void *)(v11 + 136 * v10 + 16) == v6) {
        return result;
      }
      while (1)
      {
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v11 + 136 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + 136 * v10 + 16) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  uint64_t result = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<re::Progress&>(uint64_t a1, uint64_t *a2, re::Progress *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    goto LABEL_9;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 136 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 136 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = 17 * v10;
  re::DynamicArray<unsigned long>::deinit(v11 + 136 * v10 + 24);
  re::Progress::Progress((re::Progress *)(*(void *)(a1 + 16) + 8 * v12 + 24), a3);
LABEL_9:
  ++*(_DWORD *)(a1 + 40);
}

double re::ProgressSet::insertVoter@<D0>(re::ProgressSet *this@<X0>, const re::Progress *a2@<X2>, uint64_t a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t v22 = a3;
  re::ProgressSet::learnerIds(this, (uint64_t)v21);
  if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v21, &v22))
  {
    re::ProgressSet::voterIds(this, (uint64_t)&v18);
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v18, &v22))
    {
      re::DynamicString::format((re::DynamicString *)"voters", (re::DynamicString *)&v15);
      long long v10 = v15;
      uint64_t v11 = v16;
      uint64_t v12 = v17;
      *(unsigned char *)a4 = 0;
      uint64_t v13 = 6;
    }
    else
    {
      if (!*((unsigned char *)this + 88))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 192, &v22);
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace((uint64_t)this, &v22, a2);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(unsigned char *)a4 = 1;
        goto LABEL_9;
      }
      re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v15);
      long long v10 = v15;
      uint64_t v11 = v16;
      uint64_t v12 = v17;
      *(unsigned char *)a4 = 0;
      uint64_t v13 = 10;
    }
    *(void *)(a4 + 8) = v13;
    *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v10;
    *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v11;
    *(void *)(a4 + 48) = v12;
LABEL_9:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v18);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
  }
  re::DynamicString::format((re::DynamicString *)"learners", (re::DynamicString *)&v18);
  long long v7 = v18;
  uint64_t v8 = v19;
  uint64_t v9 = v20;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 6;
  *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v7;
  *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  *(void *)(a4 + 48) = v9;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, re::Progress *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    uint64_t result = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    goto LABEL_9;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 136 * v10 + 16) != v6)
  {
    LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *(_DWORD *)(v11 + 136 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 136 * v10;
  uint64_t result = re::DynamicArray<unsigned long long>::operator=(v12 + 24, (uint64_t *)a3);
  long long v14 = *(_OWORD *)((char *)a3 + 40);
  *(void *)(v12 + 8re::InputManager::notify(8, 0, 0, 0) = *((void *)a3 + 7);
  *(_OWORD *)(v12 + 64) = v14;
  long long v15 = *(_OWORD *)((char *)a3 + 90);
  long long v16 = *((_OWORD *)a3 + 5);
  *(_OWORD *)(v12 + 88) = *((_OWORD *)a3 + 4);
  *(_OWORD *)(v12 + 104) = v16;
  *(_OWORD *)(v12 + 114) = v15;
LABEL_9:
  ++*(_DWORD *)(a1 + 40);
  return result;
}

double re::ProgressSet::insertLearner@<D0>(re::ProgressSet *this@<X0>, const re::Progress *a2@<X2>, uint64_t a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t v22 = a3;
  re::ProgressSet::learnerIds(this, (uint64_t)v21);
  if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v21, &v22))
  {
    re::ProgressSet::voterIds(this, (uint64_t)&v18);
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v18, &v22))
    {
      re::DynamicString::format((re::DynamicString *)"voters", (re::DynamicString *)&v15);
      long long v10 = v15;
      uint64_t v11 = v16;
      uint64_t v12 = v17;
      *(unsigned char *)a4 = 0;
      uint64_t v13 = 6;
    }
    else
    {
      if (!*((unsigned char *)this + 88))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 240, &v22);
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace((uint64_t)this, &v22, a2);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(unsigned char *)a4 = 1;
        goto LABEL_9;
      }
      re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v15);
      long long v10 = v15;
      uint64_t v11 = v16;
      uint64_t v12 = v17;
      *(unsigned char *)a4 = 0;
      uint64_t v13 = 10;
    }
    *(void *)(a4 + 8) = v13;
    *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v10;
    *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v11;
    *(void *)(a4 + 48) = v12;
LABEL_9:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v18);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
  }
  re::DynamicString::format((re::DynamicString *)"learners", (re::DynamicString *)&v18);
  long long v7 = v18;
  uint64_t v8 = v19;
  uint64_t v9 = v20;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 6;
  *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v7;
  *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  *(void *)(a4 + 48) = v9;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
}

void re::ProgressSet::remove(re::ProgressSet *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v23 = a2;
  if (*((unsigned char *)this + 88))
  {
    re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v16);
    long long v4 = v16;
    long long v5 = v17;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 10;
    *(void *)(a3 + 16) = re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v4;
    *(_OWORD *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = v5;
  }
  else
  {
    long long v7 = (char *)this + 192;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 240, (uint64_t *)&v23);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v7, (uint64_t *)&v23);
    LODWORD(v8) = 0x7FFFFFFF;
    if (*(void *)this)
    {
      unint64_t v9 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) >> 27));
      uint64_t v10 = *(unsigned int *)(*((void *)this + 1) + 4 * ((v9 ^ (v9 >> 31)) % *((unsigned int *)this + 6)));
      if (v10 != 0x7FFFFFFF)
      {
        uint64_t v11 = *((void *)this + 2);
        LODWORD(v8) = v10;
        if (*(void *)(v11 + 136 * v10 + 16) != v23)
        {
          uint64_t v8 = v10;
          while (1)
          {
            LODWORD(v8) = *(_DWORD *)(v11 + 136 * v8 + 8) & 0x7FFFFFFF;
            if (v8 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v11 + 136 * v8 + 16) == v23) {
              goto LABEL_11;
            }
          }
          LODWORD(v8) = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    uint64_t v12 = (const re::Progress *)(*((void *)this + 2) + 136 * v8 + 24);
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, v23);
    re::ProgressSet::assertProgressAndConfigurationConsistent(this);
    re::Progress::Progress((re::Progress *)((char *)&v16 + 8), v12);
    uint64_t v13 = *((void *)&v16 + 1);
    uint64_t v14 = v18;
    *(_OWORD *)(a3 + 56) = v19;
    *(void *)(a3 + 72) = v20;
    long long v15 = v22[0];
    *(_OWORD *)(a3 + 8re::InputManager::notify(8, 0, 0, 0) = v21;
    *(_OWORD *)(a3 + 96) = v15;
    *(_OWORD *)(a3 + 106) = *(_OWORD *)((char *)v22 + 10);
    *(void *)(a3 + 16) = v13;
    *(_OWORD *)(a3 + 24) = v17;
    *(void *)(a3 + 48) = v14;
    *(_DWORD *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = 1;
    *(unsigned char *)a3 = 1;
    *(unsigned char *)(a3 + 8) = 1;
  }
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t result, unint64_t a2)
{
  if (*(void *)result)
  {
    uint64_t v2 = result;
    unint64_t v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(result + 24);
    uint64_t v5 = *(void *)(result + 8);
    uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(result + 16);
      if (*(void *)(v7 + 136 * v6 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v7 + 136 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v10 = *(void *)(result + 16);
        uint64_t v11 = v10 + 136 * v6;
        int v14 = *(_DWORD *)(v11 + 8);
        uint64_t v13 = (int *)(v11 + 8);
        int v12 = v14;
        if (v14 < 0)
        {
          *uint64_t v13 = v12 & 0x7FFFFFFF;
          uint64_t result = re::DynamicArray<unsigned long>::deinit(v10 + 136 * v6 + 24);
          uint64_t v10 = *(void *)(v2 + 16);
          int v12 = *(_DWORD *)(v10 + 136 * v6 + 8);
        }
        int v15 = *(_DWORD *)(v2 + 40);
        *(_DWORD *)(v10 + 136 * v6 + 8) = *(_DWORD *)(v2 + 36) | v12 & 0x80000000;
        --*(_DWORD *)(v2 + 28);
        *(_DWORD *)(v2 + 36) = v6;
        *(_DWORD *)(v2 + 4re::InputManager::notify(8, 0, 0, 0) = v15 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v8 = v6;
          int v9 = *(_DWORD *)(v7 + 136 * v6 + 8);
          uint64_t v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v7 + 136 * v6 + 16) == a2)
          {
            *(_DWORD *)(v7 + 136 * v8 + 8) = *(_DWORD *)(v7 + 136 * v8 + 8) & 0x80000000 | *(_DWORD *)(v7 + 136 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::ProgressSet::promoteLearner(re::ProgressSet *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = a2;
  if (*((unsigned char *)this + 88))
  {
    re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v10);
    long long v4 = v10;
    uint64_t v5 = v11;
    uint64_t v6 = v12;
    *(unsigned char *)a3 = 0;
    uint64_t v7 = 10;
  }
  else
  {
    int v9 = (char *)this + 240;
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 240, &v13))
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v9, &v13);
      if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 192, &v13))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 192, &v13);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(unsigned char *)a3 = 1;
        return;
      }
      re::DynamicString::format((re::DynamicString *)"Already exists as voter, caller should know this was noop.", (re::DynamicString *)&v10);
      long long v4 = v10;
      uint64_t v5 = v11;
      uint64_t v6 = v12;
      *(unsigned char *)a3 = 0;
      uint64_t v7 = 6;
    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"Can't promote a learner which doesn't exist", (re::DynamicString *)&v10);
      long long v4 = v10;
      uint64_t v5 = v11;
      uint64_t v6 = v12;
      *(unsigned char *)a3 = 0;
      uint64_t v7 = 7;
    }
  }
  *(void *)(a3 + 8) = v7;
  *(void *)(a3 + 16) = re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v4;
  *(void *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = v5;
  *(void *)(a3 + 48) = v6;
}

unint64_t re::ProgressSet::maximalCommittedIndex(re::ProgressSet *this)
{
  uint64_t v2 = (void *)((char *)this + 48);
  *((void *)this + 8) = 0;
  ++*((_DWORD *)this + 18);
  uint64_t v3 = *((unsigned int *)this + 56);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (int *)(*((void *)this + 26) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 6;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 56);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 == v4)
  {
    unint64_t v7 = 0;
    goto LABEL_26;
  }
  uint64_t v8 = v4;
  do
  {
    if (!*(void *)this)
    {
      uint64_t v12 = *((void *)this + 2);
LABEL_16:
      LODWORD(v13) = 0x7FFFFFFF;
      goto LABEL_17;
    }
    unint64_t v9 = *(void *)(*((void *)this + 26) + 24 * v8 + 16);
    unint64_t v10 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
    unint64_t v11 = (v10 ^ (v10 >> 31)) % *((unsigned int *)this + 6);
    uint64_t v12 = *((void *)this + 2);
    uint64_t v13 = *(unsigned int *)(*((void *)this + 1) + 4 * v11);
    if (v13 == 0x7FFFFFFF) {
      goto LABEL_16;
    }
    while (*(void *)(v12 + 136 * v13 + 16) != v9)
    {
      uint64_t v13 = *(_DWORD *)(v12 + 136 * v13 + 8) & 0x7FFFFFFF;
      if (v13 == 0x7FFFFFFF) {
        goto LABEL_16;
      }
    }
LABEL_17:
    re::DynamicArray<re::TransitionCondition *>::add(v2, (void *)(v12 + 136 * v13 + 96));
    if (*((_DWORD *)this + 56) <= (v4 + 1)) {
      int v14 = v4 + 1;
    }
    else {
      int v14 = *((_DWORD *)this + 56);
    }
    while (1)
    {
      uint64_t v8 = (v4 + 1);
      if (v14 - 1 == v4) {
        break;
      }
      LODWORD(v4) = v4 + 1;
      int v15 = v8;
      if ((*(_DWORD *)(*((void *)this + 26) + 24 * v8 + 8) & 0x80000000) != 0) {
        goto LABEL_24;
      }
    }
    int v15 = v14;
LABEL_24:
    LODWORD(v4) = v15;
  }
  while (v3 != v15);
  unint64_t v7 = *((void *)this + 8);
LABEL_26:
  unint64_t v16 = 126 - 2 * __clz(v7);
  if (v7) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(*((void *)this + 10) + 8 * v7, (char *)(*((void *)this + 10) + 8 * v7), *((void *)this + 10), *((unint64_t **)this + 10), v17, 1);
  unint64_t v18 = *((void *)this + 8);
  unint64_t v19 = v18 >> 1;
  if (v18 <= v18 >> 1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_65;
  }
  uint64_t v20 = (unint64_t *)*((void *)this + 10);
  unint64_t v21 = v20[v19];
  if (!*((unsigned char *)this + 88)) {
    return v20[v19];
  }
  *((void *)this + 8) = 0;
  ++*((_DWORD *)this + 18);
  uint64_t v22 = *((unsigned int *)this + 32);
  if (v22)
  {
    uint64_t v23 = 0;
    uint64_t v24 = (int *)(*((void *)this + 14) + 8);
    while (1)
    {
      int v25 = *v24;
      v24 += 6;
      if (v25 < 0) {
        break;
      }
      if (v22 == ++v23)
      {
        LODWORD(v23) = *((_DWORD *)this + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v23) = 0;
  }
  if (v22 == v23)
  {
    unint64_t v27 = 0;
    goto LABEL_57;
  }
  uint64_t v28 = v23;
  while (2)
  {
    if (!*(void *)this)
    {
      uint64_t v32 = *((void *)this + 2);
      goto LABEL_47;
    }
    unint64_t v29 = *(void *)(*((void *)this + 14) + 24 * v28 + 16);
    unint64_t v30 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v29 ^ (v29 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v29 ^ (v29 >> 30))) >> 27));
    unint64_t v31 = (v30 ^ (v30 >> 31)) % *((unsigned int *)this + 6);
    uint64_t v32 = *((void *)this + 2);
    uint64_t v33 = *(unsigned int *)(*((void *)this + 1) + 4 * v31);
    if (v33 == 0x7FFFFFFF)
    {
LABEL_47:
      LODWORD(v33) = 0x7FFFFFFF;
      goto LABEL_48;
    }
    while (*(void *)(v32 + 136 * v33 + 16) != v29)
    {
      uint64_t v33 = *(_DWORD *)(v32 + 136 * v33 + 8) & 0x7FFFFFFF;
      if (v33 == 0x7FFFFFFF) {
        goto LABEL_47;
      }
    }
LABEL_48:
    re::DynamicArray<re::TransitionCondition *>::add(v2, (void *)(v32 + 136 * v33 + 96));
    if (*((_DWORD *)this + 32) <= (v23 + 1)) {
      int v34 = v23 + 1;
    }
    else {
      int v34 = *((_DWORD *)this + 32);
    }
    while (1)
    {
      uint64_t v28 = (v23 + 1);
      if (v34 - 1 == v23) {
        break;
      }
      LODWORD(v23) = v23 + 1;
      int v35 = v28;
      if ((*(_DWORD *)(*((void *)this + 14) + 24 * v28 + 8) & 0x80000000) != 0) {
        goto LABEL_55;
      }
    }
    int v35 = v34;
LABEL_55:
    LODWORD(v23) = v35;
    if (v22 != v35) {
      continue;
    }
    break;
  }
  uint64_t v20 = (unint64_t *)*((void *)this + 10);
  unint64_t v27 = *((void *)this + 8);
LABEL_57:
  unint64_t v36 = 126 - 2 * __clz(v27);
  if (v27) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>((uint64_t)&v20[v27], (char *)&v20[v27], (uint64_t)v20, v20, v37, 1);
  unint64_t v38 = *((void *)this + 8);
  unint64_t v39 = v38 >> 1;
  if (v38 <= v38 >> 1)
  {
LABEL_65:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(*((void *)this + 10) + 8 * v39) >= v21) {
    return v21;
  }
  else {
    return *(void *)(*((void *)this + 10) + 8 * v39);
  }
}

uint64_t re::ProgressSet::candidacyStatus(uint64_t a1, uint64_t a2)
{
  long long v23 = 0u;
  memset(v22, 0, sizeof(v22));
  DWORD1(v23) = 0x7FFFFFFF;
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  DWORD1(v21) = 0x7FFFFFFF;
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    int v6 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 8;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    uint64_t v9 = *(void *)(a2 + 16);
    do
    {
      uint64_t v10 = v9 + 32 * v8;
      if (*(unsigned char *)(v10 + 24)) {
        unint64_t v11 = v22;
      }
      else {
        unint64_t v11 = v20;
      }
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v11, (uint64_t *)(v10 + 16));
      uint64_t v9 = *(void *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v5 + 1)) {
        int v12 = v5 + 1;
      }
      else {
        int v12 = *(_DWORD *)(a2 + 32);
      }
      int v13 = v5;
      while (1)
      {
        uint64_t v8 = (v13 + 1);
        if (v12 - 1 == v13) {
          break;
        }
        ++v13;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(v9 + 32 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_20;
        }
      }
      LODWORD(v5) = v12;
LABEL_20:
      ;
    }
    while (v4 != v5);
  }
  if (!*(unsigned char *)(a1 + 88))
  {
    uint64_t v16 = a1 + 192;
    if (re::Configuration::hasQuorum(v16, (uint64_t)v22))
    {
      uint64_t v14 = 0;
      goto LABEL_36;
    }
    if (re::Configuration::hasQuorum(v16, (uint64_t)v20))
    {
      uint64_t v14 = 2;
      goto LABEL_36;
    }
LABEL_35:
    uint64_t v14 = 1;
    goto LABEL_36;
  }
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v18, a1 + 96);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v19, a1 + 144);
  if (re::Configuration::hasQuorum((uint64_t)v18, (uint64_t)v22) && re::Configuration::hasQuorum(a1 + 192, (uint64_t)v22))
  {
    uint64_t v14 = 0;
    BOOL v15 = 0;
  }
  else
  {
    BOOL v15 = !re::Configuration::hasQuorum((uint64_t)v18, (uint64_t)v20)
       && !re::Configuration::hasQuorum(a1 + 192, (uint64_t)v20);
    uint64_t v14 = 2;
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v18);
  if (v15) {
    goto LABEL_35;
  }
LABEL_36:
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v20);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
  return v14;
}

BOOL re::ProgressSet::quorumRecentlyActive(re::ProgressSet *this, uint64_t a2)
{
  long long v77 = 0u;
  memset(v76, 0, sizeof(v76));
  DWORD1(v77) = 0x7FFFFFFF;
  re::ProgressSet::voterIds(this, (uint64_t)v81);
  long long v74 = 0u;
  long long v75 = 0u;
  long long v73 = 0u;
  DWORD1(v75) = 0x7FFFFFFF;
  unsigned int v4 = v83;
  if (v83)
  {
    uint64_t v5 = 0;
    int v6 = (int *)(v82 + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v83 == ++v5)
      {
        LODWORD(v5) = v83;
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v83 == v5)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v81);
    LODWORD(v8) = 0;
LABEL_32:
    LODWORD(v21) = 0;
    goto LABEL_33;
  }
  uint64_t v9 = v5;
  uint64_t v10 = v82;
  do
  {
    unint64_t v11 = *(void *)(v10 + 24 * v9 + 16);
    unint64_t v80 = v11;
    if (!*(void *)this)
    {
      uint64_t v14 = *((void *)this + 2);
LABEL_16:
      LODWORD(v15) = 0x7FFFFFFF;
      goto LABEL_17;
    }
    unint64_t v12 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
    unint64_t v13 = (v12 ^ (v12 >> 31)) % *((unsigned int *)this + 6);
    uint64_t v14 = *((void *)this + 2);
    uint64_t v15 = *(unsigned int *)(*((void *)this + 1) + 4 * v13);
    if (v15 == 0x7FFFFFFF) {
      goto LABEL_16;
    }
    while (*(void *)(v14 + 136 * v15 + 16) != v11)
    {
      uint64_t v15 = *(_DWORD *)(v14 + 136 * v15 + 8) & 0x7FFFFFFF;
      if (v15 == 0x7FFFFFFF) {
        goto LABEL_16;
      }
    }
LABEL_17:
    uint64_t v16 = (const re::Progress *)(v14 + 136 * v15 + 24);
    uint64_t v17 = (std::__shared_weak_count *)operator new(0x88uLL);
    v17->__shared_owners_ = 0;
    v17->__shared_weak_owners_ = 0;
    v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_26E7162F8;
    re::Progress::Progress((re::Progress *)&v17[1], v16);
    uint64_t v78 = v18;
    uint64_t v79 = v17;
    re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v73, (uint64_t *)&v80, (uint64_t)&v78);
    if (v79) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v79);
    }
    uint64_t v10 = v82;
    if (v83 <= (int)v5 + 1) {
      unsigned int v19 = v5 + 1;
    }
    else {
      unsigned int v19 = v83;
    }
    while (1)
    {
      uint64_t v9 = (v5 + 1);
      if (v19 - 1 == v5) {
        break;
      }
      LODWORD(v5) = v5 + 1;
      unsigned int v20 = v9;
      if ((*(_DWORD *)(v82 + 24 * v9 + 8) & 0x80000000) != 0) {
        goto LABEL_26;
      }
    }
    unsigned int v20 = v19;
LABEL_26:
    LODWORD(v5) = v20;
  }
  while (v4 != v20);
  uint64_t v8 = v75;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v81);
  if (!v8) {
    goto LABEL_32;
  }
  uint64_t v21 = 0;
  uint64_t v22 = (int *)(v74 + 8);
  while (1)
  {
    int v23 = *v22;
    v22 += 10;
    if (v23 < 0) {
      break;
    }
    if (v8 == ++v21)
    {
      LODWORD(v21) = v8;
      break;
    }
  }
LABEL_33:
  if (v8 != v21)
  {
    uint64_t v24 = v21;
    uint64_t v25 = v74;
    while (1)
    {
      uint64_t v26 = v25 + 40 * v24;
      unint64_t v29 = *(void *)(v26 + 16);
      uint64_t v28 = (uint64_t *)(v26 + 16);
      unint64_t v27 = v29;
      if (v29 != a2) {
        break;
      }
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v76, v28);
LABEL_54:
      uint64_t v25 = v74;
      if (v75 <= (int)v21 + 1) {
        int v39 = v21 + 1;
      }
      else {
        int v39 = v75;
      }
      while (1)
      {
        uint64_t v24 = (v21 + 1);
        if (v39 - 1 == v21) {
          break;
        }
        LODWORD(v21) = v21 + 1;
        int v40 = v24;
        if ((*(_DWORD *)(v74 + 40 * v24 + 8) & 0x80000000) != 0) {
          goto LABEL_61;
        }
      }
      int v40 = v39;
LABEL_61:
      LODWORD(v21) = v40;
      if (v8 == v40) {
        goto LABEL_62;
      }
    }
    uint64_t v30 = *(void *)this;
    if (*(void *)this)
    {
      unint64_t v31 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) >> 27));
      unint64_t v32 = (v31 ^ (v31 >> 31)) % *((unsigned int *)this + 6);
      uint64_t v33 = *((void *)this + 2);
      uint64_t v34 = *(unsigned int *)(*((void *)this + 1) + 4 * v32);
      if (v34 != 0x7FFFFFFF)
      {
        while (*(void *)(v33 + 136 * v34 + 16) != v27)
        {
          uint64_t v34 = *(_DWORD *)(v33 + 136 * v34 + 8) & 0x7FFFFFFF;
          if (v34 == 0x7FFFFFFF) {
            goto LABEL_43;
          }
        }
LABEL_44:
        if (*(unsigned char *)(v33 + 136 * v34 + 129))
        {
          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v76, v28);
          unint64_t v27 = *v28;
          uint64_t v30 = *(void *)this;
        }
        if (v30)
        {
          unint64_t v35 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) >> 27));
          unint64_t v36 = (v35 ^ (v35 >> 31)) % *((unsigned int *)this + 6);
          uint64_t v37 = *((void *)this + 2);
          uint64_t v38 = *(unsigned int *)(*((void *)this + 1) + 4 * v36);
          if (v38 != 0x7FFFFFFF)
          {
            while (*(void *)(v37 + 136 * v38 + 16) != v27)
            {
              uint64_t v38 = *(_DWORD *)(v37 + 136 * v38 + 8) & 0x7FFFFFFF;
              if (v38 == 0x7FFFFFFF) {
                goto LABEL_52;
              }
            }
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v37 = *((void *)this + 2);
        }
LABEL_52:
        LODWORD(v38) = 0x7FFFFFFF;
LABEL_53:
        *(unsigned char *)(v37 + 136 * v38 + 129) = 0;
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v33 = *((void *)this + 2);
    }
LABEL_43:
    LODWORD(v34) = 0x7FFFFFFF;
    goto LABEL_44;
  }
LABEL_62:
  re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v73);
  re::ProgressSet::learnerIds(this, (uint64_t)v81);
  long long v74 = 0u;
  long long v75 = 0u;
  long long v73 = 0u;
  DWORD1(v75) = 0x7FFFFFFF;
  unsigned int v41 = v83;
  if (v83)
  {
    uint64_t v42 = 0;
    uint64_t v43 = (int *)(v82 + 8);
    while (1)
    {
      int v44 = *v43;
      v43 += 6;
      if (v44 < 0) {
        break;
      }
      if (v83 == ++v42)
      {
        LODWORD(v42) = v83;
        break;
      }
    }
  }
  else
  {
    LODWORD(v42) = 0;
  }
  if (v83 == v42)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v81);
    LODWORD(v45) = 0;
LABEL_93:
    LODWORD(v58) = 0;
    goto LABEL_94;
  }
  uint64_t v46 = v42;
  uint64_t v47 = v82;
  while (2)
  {
    unint64_t v48 = *(void *)(v47 + 24 * v46 + 16);
    unint64_t v80 = v48;
    if (!*(void *)this)
    {
      uint64_t v51 = *((void *)this + 2);
      goto LABEL_77;
    }
    unint64_t v49 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v48 ^ (v48 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v48 ^ (v48 >> 30))) >> 27));
    unint64_t v50 = (v49 ^ (v49 >> 31)) % *((unsigned int *)this + 6);
    uint64_t v51 = *((void *)this + 2);
    uint64_t v52 = *(unsigned int *)(*((void *)this + 1) + 4 * v50);
    if (v52 == 0x7FFFFFFF)
    {
LABEL_77:
      LODWORD(v52) = 0x7FFFFFFF;
      goto LABEL_78;
    }
    while (*(void *)(v51 + 136 * v52 + 16) != v48)
    {
      uint64_t v52 = *(_DWORD *)(v51 + 136 * v52 + 8) & 0x7FFFFFFF;
      if (v52 == 0x7FFFFFFF) {
        goto LABEL_77;
      }
    }
LABEL_78:
    uint64_t v53 = (const re::Progress *)(v51 + 136 * v52 + 24);
    char v54 = (std::__shared_weak_count *)operator new(0x88uLL);
    v54->__shared_owners_ = 0;
    v54->__shared_weak_owners_ = 0;
    v54->__vftable = (std::__shared_weak_count_vtbl *)&unk_26E7162F8;
    re::Progress::Progress((re::Progress *)&v54[1], v53);
    uint64_t v78 = v55;
    uint64_t v79 = v54;
    re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v73, (uint64_t *)&v80, (uint64_t)&v78);
    if (v79) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v79);
    }
    uint64_t v47 = v82;
    if (v83 <= (int)v42 + 1) {
      unsigned int v56 = v42 + 1;
    }
    else {
      unsigned int v56 = v83;
    }
    while (1)
    {
      uint64_t v46 = (v42 + 1);
      if (v56 - 1 == v42) {
        break;
      }
      LODWORD(v42) = v42 + 1;
      unsigned int v57 = v46;
      if ((*(_DWORD *)(v82 + 24 * v46 + 8) & 0x80000000) != 0) {
        goto LABEL_87;
      }
    }
    unsigned int v57 = v56;
LABEL_87:
    LODWORD(v42) = v57;
    if (v41 != v57) {
      continue;
    }
    break;
  }
  uint64_t v45 = v75;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v81);
  if (!v45) {
    goto LABEL_93;
  }
  uint64_t v58 = 0;
  char v59 = (int *)(v74 + 8);
  while (1)
  {
    int v60 = *v59;
    v59 += 10;
    if (v60 < 0) {
      break;
    }
    if (v45 == ++v58)
    {
      LODWORD(v58) = v45;
      break;
    }
  }
LABEL_94:
  if (v45 != v58)
  {
    uint64_t v61 = v58;
    uint64_t v62 = *(void *)this;
    uint64_t v63 = v74;
    do
    {
      if (v62)
      {
        unint64_t v64 = *(void *)(v63 + 40 * v61 + 16);
        unint64_t v65 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v64 ^ (v64 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v64 ^ (v64 >> 30))) >> 27));
        unint64_t v66 = (v65 ^ (v65 >> 31)) % *((unsigned int *)this + 6);
        uint64_t v67 = *((void *)this + 2);
        uint64_t v68 = *(unsigned int *)(*((void *)this + 1) + 4 * v66);
        if (v68 != 0x7FFFFFFF)
        {
          while (*(void *)(v67 + 136 * v68 + 16) != v64)
          {
            uint64_t v68 = *(_DWORD *)(v67 + 136 * v68 + 8) & 0x7FFFFFFF;
            if (v68 == 0x7FFFFFFF) {
              goto LABEL_102;
            }
          }
          goto LABEL_103;
        }
      }
      else
      {
        uint64_t v67 = *((void *)this + 2);
      }
LABEL_102:
      LODWORD(v68) = 0x7FFFFFFF;
LABEL_103:
      *(unsigned char *)(v67 + 136 * v68 + 129) = 0;
      if (v45 <= (int)v58 + 1) {
        int v69 = v58 + 1;
      }
      else {
        int v69 = v45;
      }
      while (1)
      {
        uint64_t v61 = (v58 + 1);
        if (v69 - 1 == v58) {
          break;
        }
        LODWORD(v58) = v58 + 1;
        int v70 = v61;
        if ((*(_DWORD *)(v63 + 40 * v61 + 8) & 0x80000000) != 0) {
          goto LABEL_110;
        }
      }
      int v70 = v69;
LABEL_110:
      LODWORD(v58) = v70;
    }
    while (v45 != v70);
  }
  re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v73);
  if (re::Configuration::hasQuorum((uint64_t)this + 192, (uint64_t)v76))
  {
    if (*((unsigned char *)this + 88)) {
      hasQuoruuint64_t m = re::Configuration::hasQuorum((uint64_t)this + 96, (uint64_t)v76);
    }
    else {
      hasQuoruuint64_t m = 1;
    }
  }
  else
  {
    hasQuoruuint64_t m = 0;
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v76);
  return hasQuorum;
}

double re::ProgressSet::beginMembershipChange@<D0>(re::ProgressSet *this@<X0>, const re::Configuration *a2@<X1>, re::Progress *a3@<X2>, uint64_t a4@<X8>)
{
  double v8 = re::Configuration::validate(a2, (uint64_t)&v46);
  if ((_BYTE)v46)
  {
    long long v52 = 0u;
    long long v53 = 0u;
    long long v51 = 0u;
    DWORD1(v53) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v51);
    uint64_t v9 = *((unsigned int *)this + 56);
    if (v9)
    {
      uint64_t v10 = 0;
      unint64_t v11 = (int *)(*((void *)this + 26) + 8);
      while (1)
      {
        int v12 = *v11;
        v11 += 6;
        if (v12 < 0) {
          break;
        }
        if (v9 == ++v10)
        {
          LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = *((_DWORD *)this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = 0;
    }
    if (v9 != v10)
    {
      uint64_t v16 = v10;
      uint64_t v17 = *((void *)this + 26);
      do
      {
        if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)a2 + 48, (uint64_t *)(v17 + 24 * v16 + 16)))
        {
          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v51, (uint64_t *)(*((void *)this + 26) + 24 * v16 + 16));
        }
        unsigned int v18 = *((_DWORD *)this + 56);
        uint64_t v17 = *((void *)this + 26);
        if (v18 <= (int)v10 + 1) {
          int v19 = v10 + 1;
        }
        else {
          int v19 = *((_DWORD *)this + 56);
        }
        while (1)
        {
          uint64_t v16 = (v10 + 1);
          if (v19 - 1 == v10) {
            break;
          }
          LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v10 + 1;
          int v20 = v16;
          if ((*(_DWORD *)(v17 + 24 * v16 + 8) & 0x80000000) != 0) {
            goto LABEL_23;
          }
        }
        int v20 = v19;
LABEL_23:
        LODWORD(v1re::InputManager::notify(8, 0, 0, 0) = v20;
      }
      while (v18 != v20);
    }
    if (HIDWORD(v52))
    {
      uint64_t v21 = 0;
      if (v53)
      {
        uint64_t v22 = (int *)(v52 + 8);
        while (1)
        {
          int v23 = *v22;
          v22 += 6;
          if (v23 < 0) {
            break;
          }
          if (v53 == ++v21)
          {
            LODWORD(v21) = v53;
            break;
          }
        }
      }
      re::DynamicString::format((re::DynamicString *)"Learners: %llu", (re::DynamicString *)&v46, *(void *)(v52 + 24 * v21 + 16));
      long long v24 = v46;
      uint64_t v25 = v47;
      uint64_t v26 = v48;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 6;
      *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
      *(_OWORD *)(a4 + 24) = v24;
      *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v25;
      *(void *)(a4 + 48) = v26;
    }
    else
    {
      *((_WORD *)a3 + 52) = 256;
      uint64_t v27 = *((unsigned int *)a2 + 8);
      if (v27)
      {
        uint64_t v28 = 0;
        unint64_t v29 = (int *)(*((void *)a2 + 2) + 8);
        while (1)
        {
          int v30 = *v29;
          v29 += 6;
          if (v30 < 0) {
            break;
          }
          if (v27 == ++v28)
          {
            LODWORD(v28) = *((_DWORD *)a2 + 8);
            break;
          }
        }
      }
      else
      {
        LODWORD(v28) = 0;
      }
      if (v27 != v28)
      {
        uint64_t v31 = v28;
        uint64_t v32 = *((void *)a2 + 2);
        unsigned int v33 = *((_DWORD *)a2 + 8);
        do
        {
          *(void *)&long long v46 = 0;
          *(void *)&long long v46 = *(void *)(v32 + 24 * v31 + 16);
          if (!re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this, v46))
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>((uint64_t)this, (uint64_t *)&v46, a3);
            unsigned int v33 = *((_DWORD *)a2 + 8);
            uint64_t v32 = *((void *)a2 + 2);
          }
          if (v33 <= (int)v28 + 1) {
            unsigned int v34 = v28 + 1;
          }
          else {
            unsigned int v34 = v33;
          }
          while (1)
          {
            uint64_t v31 = (v28 + 1);
            if (v34 - 1 == v28) {
              break;
            }
            LODWORD(v28) = v28 + 1;
            unsigned int v35 = v31;
            if ((*(_DWORD *)(v32 + 24 * v31 + 8) & 0x80000000) != 0) {
              goto LABEL_48;
            }
          }
          unsigned int v35 = v34;
LABEL_48:
          LODWORD(v28) = v35;
        }
        while (v27 != v35);
      }
      uint64_t v36 = *((unsigned int *)a2 + 20);
      if (v36)
      {
        uint64_t v37 = 0;
        uint64_t v38 = (int *)(*((void *)a2 + 8) + 8);
        while (1)
        {
          int v39 = *v38;
          v38 += 6;
          if (v39 < 0) {
            break;
          }
          if (v36 == ++v37)
          {
            LODWORD(v37) = *((_DWORD *)a2 + 20);
            break;
          }
        }
      }
      else
      {
        LODWORD(v37) = 0;
      }
      if (v36 != v37)
      {
        uint64_t v40 = v37;
        uint64_t v41 = *((void *)a2 + 8);
        unsigned int v42 = *((_DWORD *)a2 + 20);
        do
        {
          *(void *)&long long v46 = 0;
          *(void *)&long long v46 = *(void *)(v41 + 24 * v40 + 16);
          if (!re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this, v46))
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>((uint64_t)this, (uint64_t *)&v46, a3);
            unsigned int v42 = *((_DWORD *)a2 + 20);
            uint64_t v41 = *((void *)a2 + 8);
          }
          if (v42 <= (int)v37 + 1) {
            unsigned int v43 = v37 + 1;
          }
          else {
            unsigned int v43 = v42;
          }
          while (1)
          {
            uint64_t v40 = (v37 + 1);
            if (v43 - 1 == v37) {
              break;
            }
            LODWORD(v37) = v37 + 1;
            unsigned int v44 = v40;
            if ((*(_DWORD *)(v41 + 24 * v40 + 8) & 0x80000000) != 0) {
              goto LABEL_66;
            }
          }
          unsigned int v44 = v43;
LABEL_66:
          LODWORD(v37) = v44;
        }
        while (v36 != v44);
      }
      LOBYTE(v46) = 1;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v46 + 8, (uint64_t)a2);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v50, (uint64_t)a2 + 48);
      re::Optional<re::Configuration>::operator=((unsigned __int8 *)this + 88, (uint64_t *)&v46);
      re::Optional<re::Configuration>::~Optional((uint64_t)&v46);
      *(unsigned char *)a4 = 1;
    }
    *(double *)&long long v13 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v51);
  }
  else
  {
    if (v48 && (v49 & 1) != 0) {
      (*(void (**)(double))(*(void *)v48 + 40))(v8);
    }
    re::DynamicString::format((re::DynamicString *)"Invalid Configuration", (re::DynamicString *)&v46);
    long long v13 = v46;
    uint64_t v14 = v47;
    uint64_t v15 = v48;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 5;
    *(void *)(a4 + 16) = re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v13;
    *(void *)(a4 + 4re::InputManager::notify(8, 0, 0, 0) = v14;
    *(void *)(a4 + 48) = v15;
  }
  return *(double *)&v13;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 136 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 136 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 136 * v3 + 16) == a2) {
        return v5 + 136 * v3 + 24;
      }
    }
    return 0;
  }
  return v5 + 136 * v3 + 24;
}

double re::ProgressSet::finalizeMembershipChange@<D0>(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (unsigned __int8 *)this + 88;
  if (*((unsigned char *)this + 88))
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v52, (uint64_t)this + 96);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v53, (uint64_t)this + 144);
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    DWORD1(v51) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v49);
    uint64_t v5 = *((unsigned int *)this + 56);
    if (v5)
    {
      uint64_t v6 = 0;
      int v7 = (int *)(*((void *)this + 26) + 8);
      while (1)
      {
        int v8 = *v7;
        v7 += 6;
        if (v8 < 0) {
          break;
        }
        if (v5 == ++v6)
        {
          LODWORD(v6) = *((_DWORD *)this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v6) = 0;
    }
    if (v5 != v6)
    {
      uint64_t v12 = v6;
      uint64_t v13 = *((void *)this + 26);
      do
      {
        if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v52, (uint64_t *)(v13 + 24 * v12 + 16)))re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v49, (uint64_t *)(*((void *)this + 26) + 24 * v12 + 16)); {
        unsigned int v14 = *((_DWORD *)this + 56);
        }
        uint64_t v13 = *((void *)this + 26);
        if (v14 <= (int)v6 + 1) {
          int v15 = v6 + 1;
        }
        else {
          int v15 = *((_DWORD *)this + 56);
        }
        while (1)
        {
          uint64_t v12 = (v6 + 1);
          if (v15 - 1 == v6) {
            break;
          }
          LODWORD(v6) = v6 + 1;
          int v16 = v12;
          if ((*(_DWORD *)(v13 + 24 * v12 + 8) & 0x80000000) != 0) {
            goto LABEL_20;
          }
        }
        int v16 = v15;
LABEL_20:
        LODWORD(v6) = v16;
      }
      while (v14 != v16);
    }
    long long v48 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    DWORD1(v48) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v46);
    uint64_t v17 = *((unsigned int *)this + 68);
    if (v17)
    {
      uint64_t v18 = 0;
      int v19 = (int *)(*((void *)this + 32) + 8);
      while (1)
      {
        int v20 = *v19;
        v19 += 6;
        if (v20 < 0) {
          break;
        }
        if (v17 == ++v18)
        {
          LODWORD(v18) = *((_DWORD *)this + 68);
          break;
        }
      }
    }
    else
    {
      LODWORD(v18) = 0;
    }
    if (v17 != v18)
    {
      uint64_t v21 = v18;
      uint64_t v22 = *((void *)this + 32);
      do
      {
        if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v53, (uint64_t *)(v22 + 24 * v21 + 16)))re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v46, (uint64_t *)(*((void *)this + 32) + 24 * v21 + 16)); {
        unsigned int v23 = *((_DWORD *)this + 68);
        }
        uint64_t v22 = *((void *)this + 32);
        if (v23 <= (int)v18 + 1) {
          int v24 = v18 + 1;
        }
        else {
          int v24 = *((_DWORD *)this + 68);
        }
        while (1)
        {
          uint64_t v21 = (v18 + 1);
          if (v24 - 1 == v18) {
            break;
          }
          LODWORD(v18) = v18 + 1;
          int v25 = v21;
          if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0) {
            goto LABEL_38;
          }
        }
        int v25 = v24;
LABEL_38:
        LODWORD(v18) = v25;
      }
      while (v23 != v25);
    }
    int v26 = v51;
    if (v51)
    {
      uint64_t v27 = 0;
      uint64_t v28 = (int *)(v50 + 8);
      while (1)
      {
        int v29 = *v28;
        v28 += 6;
        if (v29 < 0) {
          break;
        }
        if (v51 == ++v27)
        {
          LODWORD(v27) = v51;
          break;
        }
      }
    }
    else
    {
      LODWORD(v27) = 0;
    }
    if (v51 != v27)
    {
      uint64_t v30 = v27;
      uint64_t v31 = v50;
      do
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, *(void *)(v31 + 24 * v30 + 16));
        uint64_t v31 = v50;
        if (v51 <= (int)v27 + 1) {
          int v32 = v27 + 1;
        }
        else {
          int v32 = v51;
        }
        int v33 = v27;
        while (1)
        {
          uint64_t v30 = (v33 + 1);
          if (v32 - 1 == v33) {
            break;
          }
          ++v33;
          LODWORD(v27) = v30;
          if ((*(_DWORD *)(v50 + 24 * v30 + 8) & 0x80000000) != 0) {
            goto LABEL_55;
          }
        }
        LODWORD(v27) = v32;
LABEL_55:
        ;
      }
      while (v26 != v27);
    }
    int v34 = v48;
    if (v48)
    {
      uint64_t v35 = 0;
      uint64_t v36 = (int *)(v47 + 8);
      while (1)
      {
        int v37 = *v36;
        v36 += 6;
        if (v37 < 0) {
          break;
        }
        if (v48 == ++v35)
        {
          LODWORD(v35) = v48;
          break;
        }
      }
    }
    else
    {
      LODWORD(v35) = 0;
    }
    if (v48 != v35)
    {
      uint64_t v38 = v35;
      uint64_t v39 = v47;
      do
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, *(void *)(v39 + 24 * v38 + 16));
        uint64_t v39 = v47;
        if (v48 <= (int)v35 + 1) {
          int v40 = v35 + 1;
        }
        else {
          int v40 = v48;
        }
        int v41 = v35;
        while (1)
        {
          uint64_t v38 = (v41 + 1);
          if (v40 - 1 == v41) {
            break;
          }
          ++v41;
          LODWORD(v35) = v38;
          if ((*(_DWORD *)(v47 + 24 * v38 + 8) & 0x80000000) != 0) {
            goto LABEL_72;
          }
        }
        LODWORD(v35) = v40;
LABEL_72:
        ;
      }
      while (v34 != v35);
    }
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)this + 192, (uint64_t)v52);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)this + 240, (uint64_t)v53);
    LOBYTE(v43) = 0;
    re::Optional<re::Configuration>::operator=(v3, (uint64_t *)&v43);
    re::Optional<re::Configuration>::~Optional((uint64_t)&v43);
    *(unsigned char *)a2 = 1;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v46);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v49);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v53);
    *(double *)&long long v9 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v52);
  }
  else
  {
    long long v9 = v43;
    uint64_t v10 = v44;
    uint64_t v11 = v45;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 9;
    *(void *)(a2 + 16) = re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v9;
    *(void *)(a2 + 4re::InputManager::notify(8, 0, 0, 0) = v10;
    *(void *)(a2 + 48) = v11;
  }
  return *(double *)&v9;
}

uint64_t re::ProgressSet::hasQuorum(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::Configuration::hasQuorum(a1 + 192, a2);
  if (result)
  {
    if (*(unsigned char *)(a1 + 88))
    {
      return re::Configuration::hasQuorum(a1 + 96, a2);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

double re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          int v8 = *(std::__shared_weak_count **)(v6 + 32);
          if (v8)
          {
            std::__shared_weak_count::__release_shared[abi:nn180100](v8);
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 40;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void std::__shared_ptr_emplace<re::Progress>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26E7162F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::Progress>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26E7162F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t std::__shared_ptr_emplace<re::Progress>::__on_zero_shared(uint64_t a1)
{
  return re::DynamicArray<unsigned long>::deinit(a1 + 24);
}

uint64_t re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(void *)&v26[36] = 0x7FFFFFFFLL;
          re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v26, v13, v12);
          long long v15 = *(_OWORD *)v26;
          *(_OWORD *)int v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v26[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&unsigned char v26[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21, v21 + 8);
              }
              v21 += 40;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 40 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 40 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 40 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 40 * v9 + 16) = *a4;
  *(_OWORD *)(*(void *)(a1 + 16) + 40 * v9 + 24) = *(_OWORD *)a5;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, uint64_t a5, char a6)
{
  while (1)
  {
    uint64_t v13 = a2 - (char *)a4;
    unint64_t v14 = (a2 - (char *)a4) >> 3;
    if (v7 || !v6)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v46 = *((void *)a2 - 1);
          if (*a4 < v46)
          {
            *((void *)a2 - 1) = *a4;
            *a4 = v46;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), a3, (uint64_t)(a4 + 1));
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), (uint64_t)(a2 - 16), (uint64_t)(a2 - 16), a3, (uint64_t)(a4 + 1));
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), (uint64_t)(a2 - 16), (uint64_t)(a2 - 16), (uint64_t)(a2 - 24), (uint64_t)(a2 - 24), a3, (uint64_t)(a4 + 1));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v13 <= 191) {
      break;
    }
    if (!a5)
    {
      if (a2 != (char *)a4)
      {
        int64_t v57 = (v14 - 2) >> 1;
        int64_t v58 = v57;
        do
        {
          int64_t v59 = v58;
          uint64_t v60 = 8 * v58;
          if (v57 >= v60 >> 3)
          {
            uint64_t v61 = v60 >> 2;
            uint64_t v62 = (v60 >> 2) | 1;
            uint64_t v63 = &a2[-8 * v62];
            uint64_t v64 = v61 + 2;
            if (v64 < (uint64_t)v14 && *((void *)v63 - 1) < *((void *)v63 - 2))
            {
              v63 -= 8;
              uint64_t v62 = v64;
            }
            unint64_t v65 = &a2[-8 * v59];
            unint64_t v66 = *((void *)v63 - 1);
            unint64_t v67 = *((void *)v65 - 1);
            if (v66 >= v67)
            {
              do
              {
                *((void *)v65 - 1) = v66;
                unint64_t v65 = v63;
                if (v57 < v62) {
                  break;
                }
                uint64_t v68 = (2 * v62) | 1;
                uint64_t v63 = &a2[-8 * v68];
                uint64_t v69 = 2 * v62 + 2;
                if (v69 < (uint64_t)v14 && *((void *)v63 - 1) < *((void *)v63 - 2))
                {
                  v63 -= 8;
                  uint64_t v68 = v69;
                }
                unint64_t v66 = *((void *)v63 - 1);
                uint64_t v62 = v68;
              }
              while (v66 >= v67);
              *((void *)v65 - 1) = v67;
            }
          }
          int64_t v58 = v59 - 1;
        }
        while (v59);
        uint64_t v70 = (unint64_t)v13 >> 3;
        do
        {
          uint64_t v71 = 0;
          unint64_t v72 = *((void *)a2 - 1);
          long long v73 = a2;
          do
          {
            long long v74 = (unint64_t *)&v73[8 * ~v71];
            uint64_t v75 = (2 * v71) | 1;
            uint64_t v76 = 2 * v71 + 2;
            if (v76 < v70 && *(v74 - 1) < *(v74 - 2))
            {
              --v74;
              uint64_t v75 = v76;
            }
            *((void *)v73 - 1) = *(v74 - 1);
            long long v73 = (char *)v74;
            uint64_t v71 = v75;
          }
          while (v75 <= (uint64_t)((unint64_t)(v70 - 2) >> 1));
          long long v77 = v74 - 1;
          if (v74 == a4 + 1)
          {
            *long long v77 = v72;
          }
          else
          {
            *long long v77 = *a4;
            *a4 = v72;
            if (a2 - (char *)v77 >= 9)
            {
              unint64_t v78 = (((unint64_t)(a2 - (char *)v77) >> 3) - 2) >> 1;
              uint64_t v79 = (unint64_t *)&a2[-8 * v78];
              unint64_t v80 = *(v79 - 1);
              unint64_t v81 = *v77;
              if (v80 < v81)
              {
                do
                {
                  *(v74 - 1) = v80;
                  long long v74 = v79;
                  if (!v78) {
                    break;
                  }
                  unint64_t v78 = (v78 - 1) >> 1;
                  uint64_t v79 = (unint64_t *)&a2[-8 * v78];
                  unint64_t v80 = *(v79 - 1);
                }
                while (v80 < v81);
                *(v74 - 1) = v81;
              }
            }
          }
          ++a4;
        }
        while (v70-- > 2);
      }
      return;
    }
    unint64_t v15 = v14 >> 1;
    uint64_t v16 = (uint64_t)&a2[-8 * (v14 >> 1)];
    uint64_t v17 = (uint64_t)(a4 + 1);
    unsigned int v18 = a2;
    uint64_t v19 = a1;
    if ((unint64_t)v13 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)&a2[-8 * (v14 >> 1)], (uint64_t)&a2[-8 * (v14 >> 1)], v17, (uint64_t)(a4 + 1));
      uint64_t v20 = (uint64_t)&a2[8 * (1 - v15)];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)(a2 - 8), (uint64_t)(a2 - 8), v20, v20, (uint64_t)(a4 + 2), (uint64_t)(a4 + 2));
      uint64_t v21 = (uint64_t)&a2[8 * ~v15];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)(a2 - 16), (uint64_t)(a2 - 16), v21, v21, (uint64_t)(a4 + 3), (uint64_t)(a4 + 3));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(v20, v20, v16, v16, v21, v21);
      uint64_t v22 = *((void *)a2 - 1);
      *((void *)a2 - 1) = *(void *)(v16 - 8);
      *(void *)(v16 - 8) = v22;
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)&a2[-8 * (v14 >> 1)], (uint64_t)&a2[-8 * (v14 >> 1)], a1, (uint64_t)a2, v17, (uint64_t)(a4 + 1));
    }
    --a5;
    int v23 = (unint64_t *)(a2 - 8);
    if (a6)
    {
      unint64_t v24 = *v23;
      goto LABEL_11;
    }
    unint64_t v24 = *((void *)a2 - 1);
    if (*(void *)a2 >= v24)
    {
      int v37 = (unint64_t *)(a2 - 8);
      if (v24 >= *a4)
      {
        do
        {
          uint64_t v39 = v37;
          if (v37 <= a4) {
            break;
          }
          --v37;
        }
        while (v24 >= *(v39 - 1));
      }
      else
      {
        uint64_t v38 = a2;
        do
        {
          uint64_t v39 = (unint64_t *)(v38 - 8);
          unint64_t v40 = *((void *)v38 - 2);
          v38 -= 8;
        }
        while (v24 >= v40);
      }
      int v41 = a4;
      if (v39 > a4)
      {
        int v41 = a4;
        do
          unint64_t v42 = *v41++;
        while (v24 < v42);
      }
      while (v39 > v41)
      {
        unint64_t v43 = *(v39 - 1);
        *(v39 - 1) = *(v41 - 1);
        *(v41 - 1) = v43;
        do
        {
          unint64_t v44 = *(v39 - 2);
          --v39;
        }
        while (v24 >= v44);
        do
          unint64_t v45 = *v41++;
        while (v24 < v45);
      }
      BOOL v6 = v39 + 1 >= (unint64_t *)a2;
      BOOL v7 = v39 + 1 == (unint64_t *)a2;
      if (v39 + 1 != (unint64_t *)a2) {
        *int v23 = *v39;
      }
      a6 = 0;
      *uint64_t v39 = v24;
      a2 = (char *)v39;
    }
    else
    {
LABEL_11:
      uint64_t v25 = 0;
      do
      {
        unint64_t v26 = *(void *)&a2[v25 - 16];
        v25 -= 8;
      }
      while (v26 < v24);
      uint64_t v27 = (unint64_t *)&a2[v25];
      uint64_t v28 = a4;
      if (v25 == -8)
      {
        uint64_t v28 = a4;
        do
        {
          if (v27 <= v28) {
            break;
          }
          unint64_t v30 = *v28++;
        }
        while (v30 >= v24);
      }
      else
      {
        do
          unint64_t v29 = *v28++;
        while (v29 >= v24);
      }
      uint64_t v31 = (unint64_t *)&a2[v25];
      if (v27 > v28)
      {
        int v32 = v28;
        do
        {
          unint64_t v33 = *(v31 - 1);
          *(v31 - 1) = *(v32 - 1);
          *(v32 - 1) = v33;
          do
          {
            unint64_t v34 = *(v31 - 2);
            --v31;
          }
          while (v34 < v24);
          do
            unint64_t v35 = *v32++;
          while (v35 >= v24);
        }
        while (v31 > v32);
      }
      if (v31 + 1 != (unint64_t *)a2) {
        *int v23 = *v31;
      }
      *uint64_t v31 = v24;
      if (v27 <= v28)
      {
        char v36 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(v31 + 1), v31 + 1);
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)v31, (uint64_t)v31, a3, a4))
        {
          a3 = (uint64_t)(v31 + 1);
          a4 = v31 + 1;
          if (v36) {
            return;
          }
        }
        else
        {
          a1 = (uint64_t)(v31 + 1);
          a2 = (char *)v31;
          if ((v36 & 1) == 0) {
            goto LABEL_28;
          }
        }
      }
      else
      {
LABEL_28:
        std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(v19, v18, v31 + 1, v31 + 1, a5, a6 & 1);
        a6 = 0;
        a1 = (uint64_t)(v31 + 1);
        a2 = (char *)v31;
      }
    }
  }
  long long v47 = (unint64_t *)(a2 - 8);
  BOOL v49 = a2 == (char *)a4 || v47 == a4;
  if (a6)
  {
    if (!v49)
    {
      uint64_t v50 = 0;
      long long v51 = (unint64_t *)(a2 - 8);
      do
      {
        unint64_t v53 = *--v51;
        unint64_t v52 = v53;
        unint64_t v54 = *v47;
        if (v53 < v54)
        {
          uint64_t v55 = v50;
          do
          {
            unsigned int v56 = &a2[v55];
            *(void *)&a2[v55 - 16] = v54;
            if (!v55) {
              break;
            }
            unint64_t v54 = *(void *)&a2[v55];
            v55 += 8;
          }
          while (v52 < v54);
          *((void *)v56 - 1) = v52;
        }
        v50 -= 8;
        long long v47 = v51;
      }
      while (v51 != a4);
    }
  }
  else if (!v49)
  {
    unsigned int v83 = a2 - 16;
    int v84 = (unint64_t *)(a2 - 8);
    do
    {
      unint64_t v86 = *--v84;
      unint64_t v85 = v86;
      unint64_t v87 = *v47;
      if (v86 < v87)
      {
        uint64_t v88 = v83;
        do
        {
          *uint64_t v88 = v87;
          unint64_t v87 = v88[2];
          ++v88;
        }
        while (v85 < v87);
        *uint64_t v88 = v85;
      }
      v83 -= 8;
      long long v47 = v84;
    }
    while (v84 != a4);
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6 = *(void *)(a4 - 8);
  unint64_t v7 = *(void *)(a2 - 8);
  unint64_t v8 = *(void *)(a6 - 8);
  if (v6 >= v7)
  {
    if (v8 < v6)
    {
      *(void *)(a4 - 8) = v8;
      *(void *)(a6 - 8) = v6;
      unint64_t v9 = *(void *)(a4 - 8);
      unint64_t v10 = *(void *)(a2 - 8);
      if (v9 < v10)
      {
        *(void *)(a2 - 8) = v9;
        *(void *)(a4 - 8) = v10;
      }
    }
  }
  else
  {
    if (v8 >= v6)
    {
      *(void *)(a2 - 8) = v6;
      *(void *)(a4 - 8) = v7;
      unint64_t v11 = *(void *)(a6 - 8);
      if (v11 >= v7) {
        return;
      }
      *(void *)(a4 - 8) = v11;
    }
    else
    {
      *(void *)(a2 - 8) = v8;
    }
    *(void *)(a6 - 8) = v7;
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  char v6 = 1;
  switch((a2 - (uint64_t)a4) >> 3)
  {
    case 0:
    case 1:
      return v6 & 1;
    case 2:
      unint64_t v7 = *(void *)(a2 - 8);
      if (*a4 < v7)
      {
        *(void *)(a2 - 8) = *a4;
        *a4 = v7;
      }
      goto LABEL_18;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a3, (uint64_t)(a4 + 1));
      goto LABEL_18;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16, a3, (uint64_t)(a4 + 1));
      goto LABEL_18;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16, a2 - 24, a2 - 24, a3, (uint64_t)(a4 + 1));
LABEL_18:
      char v6 = 1;
      return v6 & 1;
    default:
      uint64_t v8 = a2 - 16;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16);
      unint64_t v10 = (void *)(a2 - 24);
      if ((unint64_t *)(a2 - 24) == a4) {
        goto LABEL_14;
      }
      int v11 = 0;
      uint64_t v9 = a2 - 24;
      break;
  }
  while (1)
  {
    unint64_t v13 = *(void *)(v9 - 8);
    v9 -= 8;
    unint64_t v12 = v13;
    if (v13 < *(void *)(v8 - 8))
    {
      unint64_t v14 = v10;
      while (1)
      {
        *(v14 - 1) = *v14;
        if (v14 + 1 == (void *)a2) {
          break;
        }
        unint64_t v15 = v14 + 1;
        unint64_t v16 = v14[1];
        ++v14;
        if (v12 >= v16) {
          goto LABEL_12;
        }
      }
      unint64_t v15 = (void *)a2;
LABEL_12:
      *(v15 - 1) = v12;
      if (++v11 == 8) {
        break;
      }
    }
    uint64_t v8 = (uint64_t)v10;
    unint64_t v10 = (void *)v9;
    if ((unint64_t *)v9 == a4)
    {
LABEL_14:
      char v17 = 1;
      goto LABEL_20;
    }
  }
  char v17 = 0;
  LOBYTE(v9) = v9 == (void)a4;
LABEL_20:
  char v6 = v17 | v9;
  return v6 & 1;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a3, a4, a5, a6);
  unint64_t v12 = *(void *)(a8 - 8);
  unint64_t v13 = *(void *)(a6 - 8);
  if (v12 < v13)
  {
    *(void *)(a6 - 8) = v12;
    *(void *)(a8 - 8) = v13;
    unint64_t v14 = *(void *)(a6 - 8);
    unint64_t v15 = *(void *)(a4 - 8);
    if (v14 < v15)
    {
      *(void *)(a4 - 8) = v14;
      *(void *)(a6 - 8) = v15;
      unint64_t v16 = *(void *)(a4 - 8);
      unint64_t v17 = *(void *)(a2 - 8);
      if (v16 < v17)
      {
        *(void *)(a2 - 8) = v16;
        *(void *)(a4 - 8) = v17;
      }
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a3, a4, a5, a6, a7, a8);
  unint64_t v14 = *(void *)(a10 - 8);
  unint64_t v15 = *(void *)(a8 - 8);
  if (v14 < v15)
  {
    *(void *)(a8 - 8) = v14;
    *(void *)(a10 - 8) = v15;
    unint64_t v16 = *(void *)(a8 - 8);
    unint64_t v17 = *(void *)(a6 - 8);
    if (v16 < v17)
    {
      *(void *)(a6 - 8) = v16;
      *(void *)(a8 - 8) = v17;
      unint64_t v18 = *(void *)(a6 - 8);
      unint64_t v19 = *(void *)(a4 - 8);
      if (v18 < v19)
      {
        *(void *)(a4 - 8) = v18;
        *(void *)(a6 - 8) = v19;
        unint64_t v20 = *(void *)(a4 - 8);
        unint64_t v21 = *(void *)(a2 - 8);
        if (v20 < v21)
        {
          *(void *)(a2 - 8) = v20;
          *(void *)(a4 - 8) = v21;
        }
      }
    }
  }
}

void *re::Inflights::add(void *this, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v10 = a2;
  uint64_t v4 = this[6];
  unint64_t v3 = this[7];
  if (v4 == v3) {
    goto LABEL_13;
  }
  uint64_t v5 = this;
  if (this[1] != v3)
  {
    this = re::DynamicArray<float *>::setCapacity(this, v3);
    uint64_t v4 = v5[6];
    unint64_t v3 = v5[7];
  }
  unint64_t v6 = v5[5] + v4;
  if (v6 >= v3) {
    unint64_t v7 = v3;
  }
  else {
    unint64_t v7 = 0;
  }
  unint64_t v8 = v6 - v7;
  unint64_t v9 = v5[2];
  if (v6 - v7 != v9)
  {
    if (v9 > v8)
    {
      *(void *)(v5[4] + 8 * v8) = a2;
      goto LABEL_11;
    }
    uint64_t v11 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v17 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v12 = 136315906;
    *(void *)&v12[4] = "operator[]";
    *(_WORD *)&v12[12] = 1024;
    *(_DWORD *)&v12[14] = 789;
    __int16 v13 = 2048;
    unint64_t v14 = v8;
    __int16 v15 = 2048;
    unint64_t v16 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Cannot add into a full inflights", "!\"Unreachable code\"", "add", 8, v10, v11, *(_OWORD *)v12);
    _os_crash();
    __break(1u);
  }
  this = re::DynamicArray<re::TransitionCondition *>::add(v5, &v10);
  uint64_t v4 = v5[6];
LABEL_11:
  v5[6] = v4 + 1;
  return this;
}

void *re::Inflights::freeTo(void *this, unint64_t a2)
{
  uint64_t v2 = this[6];
  if (!v2) {
    return this;
  }
  unint64_t v3 = this[5];
  unint64_t v4 = this[2];
  if (v4 <= v3)
  {
LABEL_14:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v5 = this[4];
  if (*(void *)(v5 + 8 * v3) > a2) {
    return this;
  }
  for (uint64_t i = 0; i != v2; ++i)
  {
    if (v4 <= v3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_14;
    }
    if (*(void *)(v5 + 8 * v3) > a2) {
      goto LABEL_11;
    }
    unint64_t v7 = this[7];
    if (v3 + 1 < v7) {
      unint64_t v7 = 0;
    }
    unint64_t v3 = v3 + 1 - v7;
  }
  uint64_t i = this[6];
LABEL_11:
  this[5] = v3;
  this[6] = v2 - i;
  return this;
}

void *re::Inflights::freeFirstOne(re::Inflights *this)
{
  unint64_t v1 = *((void *)this + 5);
  if (*((void *)this + 2) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v2 = *(void *)(*((void *)this + 4) + 8 * v1);
  return re::Inflights::freeTo(this, v2);
}

re::RaftLog *re::RaftLog::getTerm@<X0>(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = this;
  if (*((unsigned char *)this + 48))
  {
    unint64_t v6 = *((void *)this + 33);
  }
  else
  {
    this = (re::RaftLog *)(*(void *(**)(uint64_t *__return_ptr))(**(void **)this + 32))(&v9);
    unint64_t v6 = v10 - 1;
  }
  if (v6 <= a2 && (this = (re::RaftLog *)re::RaftLog::lastIndex(v4), (unint64_t)this >= a2))
  {
    this = (re::RaftLog *)re::Unstable::maybeTerm((uint64_t)v4 + 8, a2, (uint64_t)&v9);
    if ((_BYTE)v9)
    {
      uint64_t v7 = v10;
      *(unsigned char *)a3 = 1;
      *(void *)(a3 + 8) = v7;
    }
    else
    {
      this = (re::RaftLog *)(*(uint64_t (**)(void, unint64_t))(**(void **)v4 + 56))(*(void *)v4, a2);
      if (!*(unsigned char *)a3 && *(unsigned __int8 *)(a3 + 8) >= 2u)
      {
        re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) unexpected error", "!\"Unreachable code\"", "getTerm", 25);
        this = (re::RaftLog *)_os_crash();
        __break(1u);
      }
    }
  }
  else
  {
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = 0;
  }
  return this;
}

uint64_t re::RaftLog::lastIndex(re::RaftLog *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return v1 + *((void *)this + 35) - 1;
  }
  if (*((unsigned char *)this + 48)) {
    return *((void *)this + 33);
  }
  (*(void (**)(void *__return_ptr))(**(void **)this + 40))(v3);
  return v3[1];
}

unint64_t re::RaftLog::findConflict(re::RaftLog *this, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (!v2) {
    return 0;
  }
  unint64_t v4 = (unint64_t *)(*(void *)(a2 + 32) + 88);
  uint64_t v5 = 104 * v2;
  while (1)
  {
    unint64_t v6 = v4[1];
    re::RaftLog::getTerm(this, *v4, (uint64_t)v9);
    if (!v9[0] || v10 != v6) {
      break;
    }
    v4 += 13;
    v5 -= 104;
    if (!v5) {
      return 0;
    }
  }
  re::RaftLog::lastIndex(this);
  return *v4;
}

uint64_t re::RaftLog::maybeAppend@<X0>(re::RaftLog *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = *(void *)(a5 + 16);
  uint64_t result = (uint64_t)re::RaftLog::getTerm(a1, a2, (uint64_t)v21);
  if (v21[0]) {
    BOOL v14 = v22 == a3;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    *(unsigned char *)a6 = 0;
    return result;
  }
  unint64_t Conflict = re::RaftLog::findConflict(a1, a5);
  if (Conflict)
  {
    if (Conflict <= *((void *)a1 + 36))
    {
      re::internal::assertLog((re::internal *)6, v16, "assertion failure: '%s' (%s:line %i) %llu conflicts with committed entry %llu", "!\"Unreachable code\"", "maybeAppend", 80, Conflict, a4);
      uint64_t result = _os_crash();
      __break(1u);
      return result;
    }
    v20[0] = re::DynamicArray<re::Entry>::sliceRange(a5, Conflict + ~a2, *(void *)(a5 + 16));
    v20[1] = v17;
    re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v21, v20);
    re::RaftLog::append(a1, (uint64_t)v21);
    re::DynamicArray<re::Entry>::deinit((uint64_t)v21);
  }
  unint64_t v18 = v12 + a2;
  if (v18 >= a4) {
    unint64_t v19 = a4;
  }
  else {
    unint64_t v19 = v18;
  }
  uint64_t result = (uint64_t)re::RaftLog::commitTo(a1, v19);
  *(unsigned char *)a6 = 1;
  *(void *)(a6 + 8) = v18;
  return result;
}

uint64_t re::RaftLog::append(re::RaftLog *this, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    unint64_t v3 = *((void *)this + 36);
    if (*(void *)(*(void *)(a2 + 32) + 88) - 1 < v3)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) after %llu is out of range [committed %lli]", "!\"Unreachable code\"", "append", 110, *(void *)(*(void *)(a2 + 32) + 88) - 1, v3);
      uint64_t result = _os_crash();
      __break(1u);
      return result;
    }
    re::Unstable::truncateAndAppend((__n128 *)((char *)this + 8), a2);
  }
  return re::RaftLog::lastIndex(this);
}

uint64_t re::DynamicArray<re::Entry>::sliceRange(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 16) + 1;
  if (v3 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (a3 + 1 <= a2)
  {
LABEL_6:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_7:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v3 <= a3) {
    goto LABEL_7;
  }
  return *(void *)(a1 + 32) + 104 * a2;
}

void *re::RaftLog::commitTo(void *this, unint64_t a2)
{
  if (this[36] < a2)
  {
    unint64_t v3 = this;
    this = (void *)re::RaftLog::lastIndex((re::RaftLog *)this);
    if ((unint64_t)this < a2)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) is out of range", "!\"Unreachable code\"", "commitTo", 123);
      this = (void *)_os_crash();
      __break(1u);
    }
    else
    {
      v3[36] = a2;
    }
  }
  return this;
}

uint64_t re::RaftLog::maybeCommit(re::RaftLog *this, unint64_t a2, uint64_t a3)
{
  if (*((void *)this + 36) >= a2) {
    return 0;
  }
  re::RaftLog::getTerm(this, a2, (uint64_t)v8);
  uint64_t v6 = v8[0] ? v9 : 0;
  if (v6 != a3) {
    return 0;
  }
  re::RaftLog::commitTo(this, a2);
  return 1;
}

uint64_t re::RaftLog::appliedTo(uint64_t this, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(void *)(this + 288);
    if (v2 < a2 || *(void *)(this + 296) > a2)
    {
      re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) applied(%llu) is out of range [prevApplied(%llu), committed(%llu)]", "!\"Unreachable code\"", "appliedTo", 137, a2, *(void *)(this + 296), v2);
      this = _os_crash();
      __break(1u);
    }
    else
    {
      *(void *)(this + 296) = a2;
    }
  }
  return this;
}

re::RaftLog *re::RaftLog::entries@<X0>(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t Index = re::RaftLog::lastIndex(this);
  if (Index >= a2)
  {
    return re::RaftLog::slice(this, a2, Index + 1, (__n128 *)a3);
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v8 = 0;
    long long v9 = 0u;
    int v10 = 1;
    *(unsigned char *)a3 = 1;
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)(a3 + 24) = 0;
    long long v13 = 0u;
    *(void *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
    uint64_t v15 = 0;
    int v14 = 2;
    *(_DWORD *)(a3 + 32) = 1;
    re::DynamicArray<re::Entry>::deinit((uint64_t)&v12);
    return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v8);
  }
}

re::RaftLog *re::RaftLog::slice@<X0>(re::RaftLog *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, __n128 *a4@<X8>)
{
  if (a2 > a3)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid slice", "!\"Unreachable code\"", "mustCheckOutOfBounds", 244);
    _os_crash();
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v4 = a3;
  unint64_t v6 = a2;
  uint64_t v5 = this;
  if (*((unsigned char *)this + 48))
  {
    unint64_t v8 = *((void *)this + 33) + 1;
  }
  else
  {
    this = (re::RaftLog *)(*(void *(**)(unint64_t *__return_ptr))(**(void **)this + 32))(&v24);
    unint64_t v8 = v25.n128_u64[0];
  }
  if (v8 > v6)
  {
    char v42 = 1;
    long long v9 = (char *)&v41;
    goto LABEL_9;
  }
  this = (re::RaftLog *)re::RaftLog::lastIndex(v5);
  if ((unint64_t)this + 1 < v4)
  {
LABEL_41:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Slice out of bound", "!\"Unreachable code\"", "mustCheckOutOfBounds", 253);
    _os_crash();
    __break(1u);
LABEL_42:
    unint64_t v23 = *((void *)v5 + 35);
    if (v23 >= v4) {
      unint64_t v23 = v4;
    }
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) entries[%llu:%llu] is unavailable from storage", "!\"Unreachable code\"", "slice", 209, v6, v23);
    _os_crash();
    __break(1u);
LABEL_45:
    re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 213, 2);
    _os_crash();
    __break(1u);
LABEL_46:
    re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 216, 3);
    _os_crash();
    __break(1u);
LABEL_47:
    re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 219, 4);
    _os_crash();
    __break(1u);
    JUMPOUT(0x233DB2004);
  }
  long long v9 = &v42;
LABEL_9:
  *long long v9 = 0;
  if (v42)
  {
    unsigned __int8 v11 = v41;
    a4->n128_u8[0] = 0;
    a4->n128_u8[8] = v11;
    return this;
  }
  uint64_t v40 = 0;
  unint64_t v38 = 0;
  __n128 v37 = 0uLL;
  int v39 = 0;
  if (v6 == v4) {
    goto LABEL_37;
  }
  unint64_t v12 = *((void *)v5 + 35);
  if (v12 <= v6)
  {
LABEL_24:
    if (v12 < v4)
    {
      if (v12 > v6) {
        unint64_t v6 = v12;
      }
      re::Unstable::mustCheckOutOfBounds((uint64_t)v5 + 8, v6, v4);
      uint64_t v17 = re::DynamicArray<re::Entry>::sliceRange((uint64_t)v5 + 8, v6 - *((void *)v5 + 35), v4 - *((void *)v5 + 35));
      if (v18)
      {
        uint64_t v19 = v17;
        uint64_t v20 = v17 + 104 * v18;
        do
        {
          re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v24, (uint64_t *)v19);
          re::DynamicArray<BOOL>::DynamicArray((uint64_t)v28, (uint64_t *)(v19 + 40));
          long long v21 = *(_OWORD *)(v19 + 80);
          uint64_t v32 = *(void *)(v19 + 96);
          long long v31 = v21;
          __n128 v22 = re::DynamicArray<re::Entry>::add(&v37, (__n128 *)&v24);
          if (v28[0])
          {
            if (v30) {
              (*(void (**)(__n128))(*(void *)v28[0] + 40))(v22);
            }
            uint64_t v30 = 0;
            memset(v28, 0, sizeof(v28));
            ++v29;
          }
          if (v24 && v27) {
            (*(void (**)(__n128))(*(void *)v24 + 40))(v22);
          }
          v19 += 104;
        }
        while (v19 != v20);
      }
    }
LABEL_37:
    re::DynamicArray<re::Entry>::DynamicArray((__n128 *)&v24, v37.n128_u64);
    a4->n128_u8[0] = 1;
    a4->n128_u64[1] = v24;
    a4[1] = v25;
    unint64_t v24 = 0;
    __n128 v25 = 0uLL;
    a4[2].n128_u64[1] = v27;
    unint64_t v27 = 0;
    ++v26;
    a4[2].n128_u32[0] = 1;
    uint64_t v16 = (__n128 *)&v24;
    goto LABEL_38;
  }
  (*(void (**)(unint64_t *__return_ptr))(**(void **)v5 + 24))(&v24);
  if (!(_BYTE)v24)
  {
    switch(v25.n128_u8[0])
    {
      case 0u:
        a4->n128_u8[0] = 0;
        a4->n128_u8[8] = 0;
        return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v37);
      case 1u:
        goto LABEL_42;
      case 2u:
        goto LABEL_45;
      case 3u:
        goto LABEL_46;
      case 4u:
        goto LABEL_47;
      default:
        break;
    }
  }
  re::DynamicArray<re::Entry>::operator=(&v37, &v25);
  unint64_t v12 = *((void *)v5 + 35);
  if (v12 >= v4) {
    unint64_t v14 = v4;
  }
  else {
    unint64_t v14 = *((void *)v5 + 35);
  }
  if (v38 >= v14 - v6)
  {
    if ((_BYTE)v24)
    {
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v25);
      unint64_t v12 = *((void *)v5 + 35);
    }
    goto LABEL_24;
  }
  uint64_t v15 = re::DynamicArray<re::Entry>::DynamicArray((__n128 *)&v33, v37.n128_u64);
  a4->n128_u8[0] = 1;
  a4->n128_u64[1] = v33;
  a4[1] = v34;
  unint64_t v33 = 0;
  __n128 v34 = 0uLL;
  a4[2].n128_u64[1] = v36;
  unint64_t v36 = 0;
  ++v35;
  a4[2].n128_u32[0] = 1;
  re::DynamicArray<re::Entry>::deinit((uint64_t)v15);
  if ((_BYTE)v24)
  {
    uint64_t v16 = &v25;
LABEL_38:
    re::DynamicArray<re::Entry>::deinit((uint64_t)v16);
  }
  return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v37);
}

uint64_t re::RaftLog::lastTerm(re::RaftLog *this)
{
  unint64_t Index = re::RaftLog::lastIndex(this);
  re::RaftLog::getTerm(this, Index, (uint64_t)v5);
  if (v5[0]) {
    return v6;
  }
  re::internal::assertLog((re::internal *)5, v3, "assertion failure: '%s' (%s:line %i) Unexpected error getting last term: %hhu", "!\"Unreachable code\"", "lastTerm", 271, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::RaftLog::isUpToDate(re::RaftLog *this, unint64_t a2, unint64_t a3)
{
  if (re::RaftLog::lastTerm(this) < a3) {
    return 1;
  }
  if (re::RaftLog::lastTerm(this) == a3) {
    return re::RaftLog::lastIndex(this) <= a2;
  }
  return 0;
}

re::RaftLog *re::RaftLog::nextEntriesSince@<X0>(re::RaftLog *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = this;
  unint64_t v5 = a2 + 1;
  if (*((unsigned char *)this + 48))
  {
    unint64_t v6 = *((void *)this + 33) + 1;
  }
  else
  {
    this = (re::RaftLog *)(*(void *(**)(__n128 *__return_ptr))(**(void **)this + 32))(v10);
    unint64_t v6 = v10[0].n128_u64[1];
  }
  if (v5 <= v6) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v5;
  }
  unint64_t v8 = *((void *)v3 + 36) + 1;
  if (v8 <= v7)
  {
    *(unsigned char *)a3 = 0;
  }
  else
  {
    re::RaftLog::slice(v3, v7, v8, v10);
    if (v10[0].n128_u8[0])
    {
      *(unsigned char *)a3 = 1;
      this = (re::RaftLog *)re::DynamicArray<re::Entry>::DynamicArray((__n128 *)(a3 + 8), &v10[0].n128_u64[1]);
      if (v10[0].n128_u8[0]) {
        return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v10[0].n128_i64[1]);
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)5, v9, "assertion failure: '%s' (%s:line %i) %hhu", "!\"Unreachable code\"", "nextEntriesSince", 303, v10[0].n128_u8[8]);
      this = (re::RaftLog *)_os_crash();
      __break(1u);
    }
  }
  return this;
}

BOOL re::RaftLog::hasNextEntries(re::RaftLog *this)
{
  uint64_t v2 = *((void *)this + 37);
  if (*((unsigned char *)this + 48))
  {
    unint64_t v3 = *((void *)this + 33) + 1;
  }
  else
  {
    (*(void (**)(void *__return_ptr))(**(void **)this + 32))(v5);
    unint64_t v3 = v5[1];
  }
  if (v2 + 1 > v3) {
    unint64_t v3 = v2 + 1;
  }
  return *((void *)this + 36) + 1 > v3;
}

BOOL re::RaftLog::hasNextEntriesSince(re::RaftLog *this, uint64_t a2)
{
  if (*((unsigned char *)this + 48))
  {
    unint64_t v4 = *((void *)this + 33) + 1;
  }
  else
  {
    (*(void (**)(void *__return_ptr))(**(void **)this + 32))(v6);
    unint64_t v4 = v6[1];
  }
  if (a2 + 1 > v4) {
    unint64_t v4 = a2 + 1;
  }
  return *((void *)this + 36) + 1 > v4;
}

void re::RaftLog::snapshot(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  re::Optional<re::Snapshot>::Optional((uint64_t)v13, (uint64_t *)this + 6);
  if (!v13[0]) {
    goto LABEL_4;
  }
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v7, v14);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v8, v15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v9, v16);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v10, v17);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v11, v18);
  *(_OWORD *)&v11[40] = v19;
  uint64_t v12 = v20;
  if (*((void *)&v19 + 1) < a2)
  {
    re::Snapshot::~Snapshot((re::Snapshot *)v7);
LABEL_4:
    (*(void (**)(void, unint64_t))(**(void **)this + 48))(*(void *)this, a2);
    goto LABEL_6;
  }
  re::types::Ok<re::Snapshot>::Ok((uint64_t)v6, (uint64_t)v7);
  re::Result<re::Snapshot,re::StorageError>::Result(a3, (uint64_t)v6);
  re::Snapshot::~Snapshot((re::Snapshot *)v6);
  re::Snapshot::~Snapshot((re::Snapshot *)v7);
LABEL_6:
  if (v13[0]) {
    re::Snapshot::~Snapshot((re::Snapshot *)v14);
  }
}

void re::RawNode::init(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  re::Raft::init(a1, a2, v45);
  if (v45[0])
  {
    long long v14 = 0u;
    long long v13 = 0u;
    long long v12 = 0u;
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    DWORD1(v14) = 0x7FFFFFFF;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    int v18 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    int v21 = 0;
    int v29 = 0;
    long long v24 = 0u;
    uint64_t v25 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v30 = 0u;
    HIDWORD(v24) = 0x7FFFFFFF;
    int v28 = 0;
    long long v27 = 0u;
    long long v26 = 0u;
    char v31 = 0;
    char v32 = 0;
    char v33 = 0;
    char v34 = 0;
    memset(v41, 0, sizeof(v41));
    long long v40 = 0u;
    long long v39 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    uint64_t v44 = 0;
    re::Raft::operator=((uint64_t)v10, (uint64_t)v46);
    long long v43 = v35;
    uint64_t v44 = v11;
    *(void *)&long long v42 = *((void *)&v36 + 1);
    BYTE8(v42) = v31;
    re::Raft::Raft((uint64_t)v6, (uint64_t *)v10);
    long long v7 = v42;
    long long v8 = v43;
    uint64_t v9 = v44;
    *(unsigned char *)a3 = 1;
    re::Raft::Raft(a3 + 8, v6);
    long long v4 = v8;
    *(_OWORD *)(a3 + 1168) = v7;
    *(_OWORD *)(a3 + 1184) = v4;
    *(void *)(a3 + 120re::InputManager::notify(8, 0, 0, 0) = v9;
    re::Raft::~Raft((re::Raft *)v6);
    re::Raft::~Raft((re::Raft *)v10);
    if (v45[0]) {
      re::Raft::~Raft((re::Raft *)v46);
    }
  }
  else
  {
    char v5 = v46[0];
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 8) = v5;
  }
}

uint64_t re::Raft::operator=(uint64_t a1, uint64_t a2)
{
  re::RaftLog::operator=((unsigned __int8 *)a1, (uint64_t *)a2);
  re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 304, (uint64_t *)(a2 + 304));
  re::DynamicArray<re::ReadState>::operator=(a1 + 352, a2 + 352);
  re::DynamicArray<re::ReadState>::operator=(a1 + 392, a2 + 392);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=(a1 + 432, (uint64_t *)(a2 + 432));
  re::Queue<re::DynamicArray<unsigned char>>::operator=(a1 + 480, (uint64_t *)(a2 + 480));
  *(unsigned char *)(a1 + 528) = *(unsigned char *)(a2 + 528);
  *(unsigned char *)(a1 + 536) = *(unsigned char *)(a2 + 536);
  re::Optional<re::ProgressSet>::operator=((unsigned char *)(a1 + 544), (uint64_t *)(a2 + 544));
  re::Optional<re::ConfChange>::operator=((unsigned char *)(a1 + 856), (unsigned __int8 *)(a2 + 856));
  if (*(unsigned char *)(a1 + 1024) || *(unsigned char *)(a2 + 1024))
  {
    if (!*(unsigned char *)(a1 + 1024) || *(unsigned char *)(a2 + 1024))
    {
      if (!*(unsigned char *)(a1 + 1024) && *(unsigned char *)(a2 + 1024)) {
        *(unsigned char *)(a1 + 1024) = 1;
      }
      *(void *)(a1 + 1032) = *(void *)(a2 + 1032);
    }
    else
    {
      *(unsigned char *)(a1 + 1024) = 0;
    }
  }
  long long v4 = *(_OWORD *)(a2 + 1040);
  long long v5 = *(_OWORD *)(a2 + 1056);
  long long v6 = *(_OWORD *)(a2 + 1072);
  *(_OWORD *)(a1 + 1088) = *(_OWORD *)(a2 + 1088);
  *(_OWORD *)(a1 + 1072) = v6;
  *(_OWORD *)(a1 + 1056) = v5;
  *(_OWORD *)(a1 + 104re::InputManager::notify(8, 0, 0, 0) = v4;
  long long v7 = *(_OWORD *)(a2 + 1104);
  long long v8 = *(_OWORD *)(a2 + 1120);
  long long v9 = *(_OWORD *)(a2 + 1136);
  *(void *)(a1 + 1149) = *(void *)(a2 + 1149);
  *(_OWORD *)(a1 + 1136) = v9;
  *(_OWORD *)(a1 + 112re::InputManager::notify(8, 0, 0, 0) = v8;
  *(_OWORD *)(a1 + 1104) = v7;
  return a1;
}

void re::RawNode::commitReady(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 392))
  {
    uint64_t v4 = *(void *)(a2 + 400);
    *(unsigned char *)(a1 + 1168) = *(unsigned char *)(a2 + 408);
    *(void *)(a1 + 116re::InputManager::notify(8, 0, 0, 0) = v4;
  }
  if (*(unsigned char *)(a2 + 416))
  {
    BOOL v5 = !*(void *)(a2 + 424) && *(void *)(a2 + 432) == 0;
    if (!v5 || *(void *)(a2 + 440) != 0)
    {
      long long v7 = *(_OWORD *)(a2 + 424);
      *(void *)(a1 + 1re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = *(void *)(a2 + 440);
      *(_OWORD *)(a1 + 1176) = v7;
    }
  }
  uint64_t v8 = *(void *)(a2 + 56);
  if (v8) {
    re::Unstable::stableTo((re::Unstable *)(a1 + 8), *(void *)(*(void *)(a2 + 72) + 104 * v8 - 16), *(void *)(*(void *)(a2 + 72) + 104 * v8 - 8));
  }
  memset(v10, 0, sizeof(v10));
  if (*(void *)(a2 + 136))
  {
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
  }
  else
  {
    BOOL v9 = re::SnapshotMetadata::operator==((void *)(a2 + 160), (void *)&v10[2] + 1);
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
    if (v9) {
      goto LABEL_18;
    }
  }
  re::Unstable::stableSnapTo((re::Unstable *)(a1 + 8), *(void *)(a2 + 328));
LABEL_18:
  if (*(void *)(a2 + 96)) {
    re::DynamicArray<re::ReadState>::clear(a1 + 352);
  }
}

uint64_t re::DynamicArray<re::ReadState>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 48 * v2;
    do
    {
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v3);
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

void re::DynamicArray<re::Entry>::add(__n128 *this, __n128 *a2)
{
  unint64_t v4 = this[1].n128_u64[0];
  if (v4 >= this->n128_u64[1])
  {
    re::DynamicArray<re::Entry>::growCapacity(this, v4 + 1);
    unint64_t v4 = this[1].n128_u64[0];
  }
  re::Entry::Entry((__n128 *)(this[2].n128_u64[0] + 104 * v4), a2);
  ++this[1].n128_u64[0];
  ++this[1].n128_u32[2];
}

uint64_t re::RawNode::hasReadySince(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 408)) {
    return 1;
  }
  if (*(void *)(a1 + 24))
  {
    v17[0] = 1;
    long long v6 = re::DynamicArray<re::Entry>::DynamicArray(v18, (unint64_t *)(a1 + 8));
    re::DynamicArray<re::Entry>::deinit((uint64_t)v6);
    return 1;
  }
  if (*(void *)(a1 + 368)) {
    return 1;
  }
  re::Optional<re::Snapshot>::Optional((uint64_t)v17, (uint64_t *)(a1 + 48));
  if (v17[0])
  {
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)v11, (uint64_t *)v18);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v12, v19);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13, v20);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v14, v21);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v15, v22);
    *(_OWORD *)&v15[40] = v23;
    uint64_t v16 = v24;
    uint64_t v7 = *((void *)&v23 + 1);
    re::Snapshot::~Snapshot((re::Snapshot *)v11);
    if (v7) {
      goto LABEL_23;
    }
  }
  if (*(unsigned char *)a2)
  {
    if (re::RaftLog::hasNextEntriesSince((re::RaftLog *)a1, *(void *)(a2 + 8))) {
      goto LABEL_23;
    }
  }
  else if (re::RaftLog::hasNextEntries((re::RaftLog *)a1))
  {
    goto LABEL_23;
  }
  if (*(void *)(a1 + 1064) == *(void *)(a1 + 1160)
    && *(unsigned __int8 *)(a1 + 536) == *(unsigned __int8 *)(a1 + 1168))
  {
    if ((v8 = *(void *)(a1 + 1040), uint64_t v9 = *(void *)(a1 + 1048), v10 = *(void *)(a1 + 288), !v8) && !v9 && !v10
      || v8 == *(void *)(a1 + 1176) && v9 == *(void *)(a1 + 1184) && v10 == *(void *)(a1 + 1192))
    {
      uint64_t v2 = 0;
      goto LABEL_24;
    }
  }
LABEL_23:
  uint64_t v2 = 1;
LABEL_24:
  if (v17[0]) {
    re::Snapshot::~Snapshot((re::Snapshot *)v18);
  }
  return v2;
}

void re::RawNode::advance(re::Raft *a1, uint64_t a2)
{
  re::RawNode::commitReady((uint64_t)a1, a2);
  unint64_t v3 = *((void *)a1 + 149);
  if (v3)
  {
    re::Raft::commitApply(a1, v3);
  }
}

uint64_t re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::ReadState>::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)a2;
    if (*(void *)result) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4 || v2 == v3)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)uint64_t result = v3;
      *(void *)(result + 8) = v7;
      *(void *)a2 = v2;
      *(void *)(a2 + 8) = v6;
      uint64_t v8 = *(void *)(result + 16);
      *(void *)(result + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v8;
      uint64_t v9 = *(void *)(result + 32);
      *(void *)(result + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      uint64_t result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

void re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = (uint64_t *)(*(void *)(a2 + 16) + v6);
      if ((v8[1] & 0x80000000) != 0)
      {
        unint64_t v9 = *v8;
        unint64_t v10 = *(unsigned int *)(a1 + 24);
        unint64_t v11 = *v8 % v10;
        uint64_t v12 = *(unsigned int *)(a1 + 36);
        if (v12 == 0x7FFFFFFF)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 32);
          int v13 = v12;
          if (v12 == v10)
          {
            re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
            unint64_t v11 = v9 % *(unsigned int *)(a1 + 24);
            int v13 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + 32) = v13 + 1;
          uint64_t v14 = *(void *)(a1 + 16);
          int v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
        }
        else
        {
          uint64_t v14 = *(void *)(a1 + 16);
          int v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
          *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v14 + 32 * v12 + 8) = v15 | 0x80000000;
        uint64_t v16 = *(void *)(a1 + 8);
        *(_DWORD *)(*(void *)(a1 + 16) + 32 * v12 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v12 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v11);
        *(void *)(*(void *)(a1 + 16) + 32 * v12) = v9;
        *(void *)(*(void *)(a1 + 16) + 32 * v12 + 16) = v8[2];
        *(unsigned char *)(*(void *)(a1 + 16) + 32 * v12 + 24) = *((unsigned char *)v8 + 24);
        *(_DWORD *)(v16 + 4 * v11) = v12;
        ++*(_DWORD *)(a1 + 28);
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

BOOL re::SnapshotMetadata::operator==(void *a1, void *a2)
{
  BOOL result = re::ConfState::operator==((uint64_t)a1, (uint64_t)a2);
  if (result)
  {
    BOOL result = re::ConfState::operator==((uint64_t)(a1 + 10), (uint64_t)(a2 + 10));
    if (result) {
      return a1[20] == a2[20] && a1[21] == a2[21] && a1[22] == a2[22];
    }
  }
  return result;
}

BOOL re::ConfState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16)
    && !memcmp(*(const void **)(a1 + 32), *(const void **)(a2 + 32), 8 * v2)
    && (uint64_t v5 = *(void *)(a1 + 56), v5 == *(void *)(a2 + 56)))
  {
    return memcmp(*(const void **)(a1 + 72), *(const void **)(a2 + 72), 8 * v5) == 0;
  }
  else
  {
    return 0;
  }
}

_anonymous_namespace_ *re::ConfState::ConfState(_anonymous_namespace_ *this, uint64_t a2, uint64_t a3)
{
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((void *)this + 9) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  uint64_t v6 = *(unsigned int *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 6;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if (v6 != v7)
  {
    uint64_t v10 = v7;
    uint64_t v11 = *(void *)(a2 + 16);
    do
    {
      uint64_t v23 = 0;
      uint64_t v23 = *(void *)(v11 + 24 * v10 + 16);
      re::DynamicArray<re::TransitionCondition *>::add(this, &v23);
      uint64_t v11 = *(void *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v7 + 1)) {
        int v12 = v7 + 1;
      }
      else {
        int v12 = *(_DWORD *)(a2 + 32);
      }
      int v13 = v7;
      while (1)
      {
        uint64_t v10 = (v13 + 1);
        if (v12 - 1 == v13) {
          break;
        }
        ++v13;
        LODWORD(v7) = v10;
        if ((*(_DWORD *)(v11 + 24 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v7) = v12;
LABEL_17:
      ;
    }
    while (v6 != v7);
  }
  uint64_t v14 = *(unsigned int *)(a3 + 32);
  if (v14)
  {
    uint64_t v15 = 0;
    uint64_t v16 = (int *)(*(void *)(a3 + 16) + 8);
    while (1)
    {
      int v17 = *v16;
      v16 += 6;
      if (v17 < 0) {
        break;
      }
      if (v14 == ++v15)
      {
        LODWORD(v15) = *(_DWORD *)(a3 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v15) = 0;
  }
  if (v14 != v15)
  {
    uint64_t v18 = v15;
    uint64_t v19 = *(void *)(a3 + 16);
    do
    {
      uint64_t v23 = 0;
      uint64_t v23 = *(void *)(v19 + 24 * v18 + 16);
      re::DynamicArray<re::TransitionCondition *>::add((void *)this + 5, &v23);
      uint64_t v19 = *(void *)(a3 + 16);
      if (*(_DWORD *)(a3 + 32) <= (v15 + 1)) {
        int v20 = v15 + 1;
      }
      else {
        int v20 = *(_DWORD *)(a3 + 32);
      }
      int v21 = v15;
      while (1)
      {
        uint64_t v18 = (v21 + 1);
        if (v20 - 1 == v21) {
          break;
        }
        ++v21;
        LODWORD(v15) = v18;
        if ((*(_DWORD *)(v19 + 24 * v18 + 8) & 0x80000000) != 0) {
          goto LABEL_34;
        }
      }
      LODWORD(v15) = v20;
LABEL_34:
      ;
    }
    while (v14 != v15);
  }
  return this;
}

uint64_t re::Ready::Ready(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = (__n128 *)(a1 + 40);
  uint64_t v11 = a1 + 120;
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  *(unsigned char *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(unsigned char *)(a1 + 344) = 0;
  if (*(void *)(a2 + 24))
  {
    v38[0] = 1;
    re::DynamicArray<re::Entry>::DynamicArray(v39, (unint64_t *)(a2 + 8));
    uint64_t v37 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    int v12 = v39;
    int v36 = 0;
  }
  else
  {
    v38[0] = 0;
    uint64_t v37 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    int v36 = 0;
    int v12 = (__n128 *)&v33;
  }
  re::DynamicArray<re::Entry>::operator=(v10, v12);
  re::DynamicArray<re::Entry>::deinit((uint64_t)&v33);
  if (v38[0]) {
    re::DynamicArray<re::Entry>::deinit((uint64_t)v39);
  }
  if (*(void *)(a2 + 408))
  {
    uint64_t v13 = *(void *)(a2 + 392);
    *(void *)(a2 + 392) = *(void *)a1;
    *(void *)a1 = v13;
    uint64_t v14 = *(void *)(a2 + 400);
    *(void *)(a2 + 40re::InputManager::notify(8, 0, 0, 0) = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = v14;
    uint64_t v15 = *(void *)(a2 + 408);
    *(void *)(a2 + 408) = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v15;
    uint64_t v16 = *(void *)(a2 + 424);
    *(void *)(a2 + 424) = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v16;
    ++*(_DWORD *)(a1 + 24);
    ++*(_DWORD *)(a2 + 416);
  }
  if (*(unsigned char *)a5) {
    uint64_t v17 = *(void *)(a5 + 8);
  }
  else {
    uint64_t v17 = *(void *)(a2 + 296);
  }
  re::RaftLog::nextEntriesSince((re::RaftLog *)a2, v17, (uint64_t)&v33);
  uint64_t v32 = 0;
  memset(v30, 0, sizeof(v30));
  int v31 = 0;
  if ((_BYTE)v33) {
    uint64_t v18 = (unint64_t *)&v34;
  }
  else {
    uint64_t v18 = v30;
  }
  v38[0] = 1;
  re::DynamicArray<re::Entry>::DynamicArray(v39, v18);
  re::Optional<re::DynamicArray<re::Entry>>::operator=((unsigned __int8 *)(a1 + 344), v38);
  if (v38[0]) {
    re::DynamicArray<re::Entry>::deinit((uint64_t)v39);
  }
  re::DynamicArray<re::Entry>::deinit((uint64_t)v30);
  if ((_BYTE)v33) {
    re::DynamicArray<re::Entry>::deinit((uint64_t)&v34);
  }
  uint64_t v19 = *(void *)(a2 + 1064);
  uint64_t v20 = *(unsigned __int8 *)(a2 + 536);
  if (*(void *)a3 != v19 || *(unsigned __int8 *)(a3 + 8) != v20)
  {
    if (*(unsigned char *)(a1 + 392))
    {
      *(void *)(a1 + 40re::InputManager::notify(8, 0, 0, 0) = v19;
      *(unsigned char *)(a1 + 408) = v20;
    }
    else
    {
      *(unsigned char *)(a1 + 392) = 1;
      *(void *)(a1 + 40re::InputManager::notify(8, 0, 0, 0) = v19;
      *(void *)(a1 + 408) = v20;
    }
  }
  uint64_t v21 = *(void *)(a2 + 1040);
  uint64_t v22 = *(void *)(a2 + 1048);
  uint64_t v23 = *(void *)(a2 + 288);
  if (*a4 == v21 && a4[1] == v22)
  {
    if (a4[2] == v23) {
      goto LABEL_31;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 448) = 1;
  }
  if (!*(unsigned char *)(a1 + 416)) {
    *(unsigned char *)(a1 + 416) = 1;
  }
  *(void *)(a1 + 424) = v21;
  *(void *)(a1 + 432) = v22;
  *(void *)(a1 + 44re::InputManager::notify(8, 0, 0, 0) = v23;
LABEL_31:
  if (*(unsigned char *)(a2 + 48))
  {
    re::DynamicArray<BOOL>::operator=(v11, (uint64_t *)(a2 + 56));
    re::DynamicArray<unsigned long long>::operator=(a1 + 160, (uint64_t *)(a2 + 96));
    re::DynamicArray<unsigned long long>::operator=(a1 + 200, (uint64_t *)(a2 + 136));
    re::DynamicArray<unsigned long long>::operator=(a1 + 240, (uint64_t *)(a2 + 176));
    re::DynamicArray<unsigned long long>::operator=(a1 + 280, (uint64_t *)(a2 + 216));
    uint64_t v24 = *(void *)(a2 + 272);
    *(_OWORD *)(a1 + 32re::InputManager::notify(8, 0, 0, 0) = *(_OWORD *)(a2 + 256);
    *(void *)(a1 + 336) = v24;
  }
  unint64_t v25 = *(void *)(a2 + 368);
  if (v25)
  {
    long long v26 = (uint64_t *)(a2 + 352);
    if ((uint64_t *)(a1 + 80) != v26)
    {
      uint64_t v27 = *v26;
      if (*(void *)(a1 + 80))
      {
        int v28 = (void *)(a1 + 80);
        if (v27)
        {
          re::DynamicArray<re::ReadState>::copy(v28, (uint64_t)v26);
          ++*(_DWORD *)(a1 + 104);
        }
        else
        {
          re::DynamicArray<re::ReadState>::clear((uint64_t)v28);
        }
      }
      else if (v27)
      {
        *(void *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = v27;
        re::DynamicArray<re::ReadState>::setCapacity((void *)(a1 + 80), v25);
        ++*(_DWORD *)(a1 + 104);
        re::DynamicArray<re::ReadState>::copy((void *)(a1 + 80), (uint64_t)v26);
      }
    }
  }
  return a1;
}

unsigned __int8 *re::Optional<re::DynamicArray<re::Entry>>::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  int v4 = *a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = a1 + 8;
    if (v3) {
      BOOL v7 = v4 == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      re::DynamicArray<re::Entry>::deinit((uint64_t)v6);
      *a1 = 0;
    }
    else
    {
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v6, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        *((void *)a1 + 5) = 0;
        *((void *)a1 + 2) = 0;
        *((void *)a1 + 3) = 0;
        *uint64_t v6 = 0;
        *((_DWORD *)a1 + 8) = 0;
        uint64_t v9 = *((void *)a2 + 2);
        *((void *)a1 + 1) = *((void *)a2 + 1);
        *((void *)a1 + 2) = v9;
        *((void *)a2 + 1) = 0;
        *((void *)a2 + 2) = 0;
        uint64_t v10 = *((void *)a1 + 3);
        *((void *)a1 + 3) = *((void *)a2 + 3);
        *((void *)a2 + 3) = v10;
        uint64_t v11 = *((void *)a1 + 5);
        *((void *)a1 + 5) = *((void *)a2 + 5);
        *((void *)a2 + 5) = v11;
        ++*((_DWORD *)a2 + 8);
        ++*((_DWORD *)a1 + 8);
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::ReadState>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::ReadState>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 48 * a1[2]), a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = 3 * v9;
      uint64_t v11 = (uint64_t *)(*(void *)(a2 + 32) + 16 * v10);
      uint64_t result = a1[4] + 16 * v10;
      uint64_t v12 = 48 * v4 - 16 * v10;
      do
      {
        uint64_t v13 = re::DynamicArray<BOOL>::DynamicArray(result, v11);
        *(void *)(v13 + 4re::InputManager::notify(8, 0, 0, 0) = v11[5];
        v11 += 6;
        uint64_t result = v13 + 48;
        v12 -= 48;
      }
      while (v12);
    }
  }
  else
  {
    uint64_t result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(*(void *)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 48 * v4), a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = a1[4] + 48 * v4;
      uint64_t v8 = 48 * v6 - 48 * v4;
      do
      {
        uint64_t result = re::DynamicArray<unsigned long>::deinit(v7);
        v7 += 48;
        v8 -= 48;
      }
      while (v8);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)result != a2)
  {
    BOOL v5 = (uint64_t *)result;
    do
    {
      uint64_t result = re::DynamicArray<BOOL>::operator=(a3, v5);
      *(void *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = v5[5];
      v5 += 6;
      a3 += 48;
    }
    while (v5 != a2);
  }
  return result;
}

void re::ConsensusErrorCategoryImpl::~ConsensusErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x237DBCBD0);
}

const char *re::ConsensusErrorCategoryImpl::name(re::ConsensusErrorCategoryImpl *this)
{
  return "Consensus error";
}

void *re::ConsensusErrorCategoryImpl::message@<X0>(unsigned __int8 a1@<W1>, void *a2@<X8>)
{
  if (a1 > 0xFu) {
    int v3 = "Unknown ConsensusError error";
  }
  else {
    int v3 = off_264BE81B8[(char)a1];
  }
  return std::string::basic_string[abi:nn180100]<0>(a2, v3);
}

uint64_t re::Unstable::maybeTerm@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  uint64_t v32 = *MEMORY[0x263EF8340];
  unint64_t v6 = *(void *)(this + 272);
  unint64_t v7 = a2 - v6;
  if (a2 < v6)
  {
    if (*(unsigned char *)(this + 40))
    {
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v12, (uint64_t *)(this + 88));
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13 + 8, (uint64_t *)(v4 + 128));
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v16, (uint64_t *)(v4 + 168));
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v19, (uint64_t *)(v4 + 208));
      long long v22 = *(_OWORD *)(v4 + 248);
      uint64_t v23 = *(void *)(v4 + 264);
      if (*((void *)&v22 + 1) == a2)
      {
        *(void *)(a3 + 8) = v23;
        char v8 = 1;
      }
      else
      {
        char v8 = 0;
      }
      *(unsigned char *)a3 = v8;
      if (v19[0])
      {
        if (v21) {
          (*(void (**)(void))(*(void *)v19[0] + 40))();
        }
        uint64_t v21 = 0;
        memset(v19, 0, sizeof(v19));
        ++v20;
      }
      if (v16[0])
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v16[0] + 40))();
        }
        uint64_t v18 = 0;
        memset(v16, 0, sizeof(v16));
        ++v17;
      }
      if (*((void *)&v13 + 1))
      {
        if (*((void *)&v15 + 1)) {
          (*(void (**)(void))(**((void **)&v13 + 1) + 40))();
        }
        *((void *)&v15 + 1) = 0;
        long long v14 = 0uLL;
        *((void *)&v13 + 1) = 0;
        LODWORD(v15) = v15 + 1;
      }
      this = *(void *)&v12[0];
      if (*(void *)&v12[0])
      {
        if ((void)v13) {
          return (*(uint64_t (**)(void))(**(void **)&v12[0] + 40))();
        }
      }
      return this;
    }
LABEL_10:
    *(unsigned char *)a3 = 0;
    return this;
  }
  unint64_t v9 = *(void *)(this + 16);
  if (v9)
  {
    unint64_t v10 = v6 + v9 - 1;
  }
  else
  {
    if (!*(unsigned char *)(this + 40)) {
      goto LABEL_10;
    }
    unint64_t v10 = *(void *)(this + 256);
  }
  if (v10 < a2) {
    goto LABEL_10;
  }
  if (v9 <= v7)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = 0u;
    memset(v12, 0, sizeof(v12));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v24 = 136315906;
    unint64_t v25 = "operator[]";
    __int16 v26 = 1024;
    int v27 = 797;
    __int16 v28 = 2048;
    unint64_t v29 = v7;
    __int16 v30 = 2048;
    unint64_t v31 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v11 = *(void *)(this + 32) + 104 * v7;
  *(unsigned char *)a3 = 1;
  *(void *)(a3 + 8) = *(void *)(v11 + 96);
  return this;
}

uint64_t re::Unstable::stableTo(re::Unstable *this, unint64_t a2, uint64_t a3)
{
  uint64_t result = re::Unstable::maybeTerm((uint64_t)this, a2, (uint64_t)v10);
  if (v10[0]) {
    BOOL v7 = v11 == a3;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    unint64_t v8 = *((void *)this + 34);
    if (v8 <= a2)
    {
      unint64_t v9 = a2 + 1;
      uint64_t result = re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)this, 0, v9 - v8);
      *((void *)this + 34) = v9;
    }
  }
  return result;
}

void re::Unstable::stableSnapTo(re::Unstable *this, uint64_t a2)
{
  int v4 = *((unsigned __int8 *)this + 40);
  int v3 = (unsigned __int8 *)this + 40;
  if (v4 && *((void *)this + 32) == a2)
  {
    LOBYTE(v5) = 0;
    re::Optional<re::Snapshot>::operator=(v3, &v5);
    if ((_BYTE)v5) {
      re::Snapshot::~Snapshot((re::Snapshot *)&v6);
    }
  }
}

void re::Unstable::restore(re::Unstable *this, const re::Snapshot *a2)
{
  re::DynamicArray<re::Entry>::clear((uint64_t)this);
  *((void *)this + 34) = *((void *)a2 + 26) + 1;
  re::Result<re::Snapshot,re::StorageError>::Result((uint64_t)&v4, (uint64_t)a2);
  re::Optional<re::Snapshot>::operator=((unsigned __int8 *)this + 40, &v4);
  if ((_BYTE)v4) {
    re::Snapshot::~Snapshot((re::Snapshot *)&v5);
  }
}

uint64_t re::Unstable::mustCheckOutOfBounds(uint64_t this, unint64_t a2, unint64_t a3)
{
  if (a2 > a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid unstable.slice %llu > %llu", "!\"Unreachable code\"", "mustCheckOutOfBounds", 90, a2, a3);
    _os_crash();
    __break(1u);
LABEL_9:
    re::internal::assertLog((re::internal *)8, a2, "assertion failure: '%s' (%s:line %i) unstable.slice[%llu, %llu] out of bound[%llu, %llu]", "!\"Unreachable code\"", "mustCheckOutOfBounds", 96, a2, a3, v3, v4);
    this = _os_crash();
    __break(1u);
    return this;
  }
  unint64_t v3 = *(void *)(this + 272);
  unint64_t v4 = *(void *)(this + 16) + v3;
  if (v3 > a2 || v4 < a3) {
    goto LABEL_9;
  }
  return this;
}

__n128 *re::Unstable::truncateAndAppend(__n128 *this, uint64_t a2)
{
  unint64_t v3 = (re::Unstable *)this;
  uint64_t v4 = *(void *)(a2 + 32);
  unint64_t v5 = *(void *)(v4 + 88);
  unint64_t v6 = this[17].n128_u64[0];
  if (v5 == this[1].n128_u64[0] + v6)
  {
    uint64_t v7 = *(void *)(a2 + 16);
    unint64_t v8 = this[1].n128_u64[0];
    uint64_t v9 = v4;
  }
  else
  {
    unint64_t v10 = v5 - v6;
    if (v5 <= v6)
    {
      this[17].n128_u64[0] = v5;
      re::DynamicArray<re::Entry>::clear((uint64_t)this);
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v7 = *(void *)(a2 + 16);
      this = (__n128 *)v3;
      unint64_t v8 = 0;
    }
    else
    {
      re::Unstable::mustCheckOutOfBounds((uint64_t)this, v6, v5);
      re::DynamicArray<re::Entry>::resize((__n128 *)v3, v10);
      unint64_t v8 = *((void *)v3 + 2);
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v7 = *(void *)(a2 + 16);
      this = (__n128 *)v3;
    }
  }
  return re::DynamicArray<re::Entry>::copy(this, v8, v9, v7);
}

__n128 *re::DynamicArray<re::Entry>::resize(__n128 *result, unint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = result[1].n128_u64[0];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
    uint64_t v8 = 104 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = v3[2].n128_u64[0] + v8;
      re::DynamicArray<unsigned long>::deinit(v10 + 40);
      uint64_t result = (__n128 *)re::DynamicArray<unsigned long>::deinit(v10);
      ++v9;
      v8 += 104;
    }
    while (v9 < v3[1].n128_u64[0]);
  }
  else
  {
    if (result->n128_u64[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::Entry>::setCapacity(result, a2);
      unint64_t v4 = v3[1].n128_u64[0];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 104 * v4;
      do
      {
        uint64_t v7 = v3[2].n128_u64[0] + v6;
        *(void *)(v7 + 96) = 0;
        *(_OWORD *)(v7 + 64) = 0uLL;
        *(_OWORD *)(v7 + 8re::InputManager::notify(8, 0, 0, 0) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_OWORD *)uint64_t v7 = 0uLL;
        *(_OWORD *)(v7 + 16) = 0uLL;
        v6 += 104;
        --v5;
      }
      while (v5);
    }
  }
  v3[1].n128_u64[0] = a2;
  ++v3[1].n128_u32[2];
  return result;
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***a1, uint64_t a2)
{
  uint64_t result = re::OPackWriter::writeArrayBegin(*a1, *(void *)(a2 + 16));
  uint64_t v5 = *(void *)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = *(const Entry **)(a2 + 32);
    uint64_t v7 = 104 * v5;
    do
    {
      uint64_t result = re::ConsensusWriter::write(a1, v6);
      v6 += 13;
      v7 -= 104;
    }
    while (v7);
    if (*(void *)(a2 + 16) >= 0xFuLL)
    {
      uint64_t v8 = *a1;
      char v9 = 3;
      return re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v9, (char *)1);
    }
  }
  return result;
}

{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  re::zerocopy **v10;
  re::zerocopy **v11;
  re::zerocopy **v12;
  char v13;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  char v20;
  char v21;
  char v22;
  char v23;

  unint64_t v4 = *a1;
  long long v15 = -25;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v15, (char *)1);
  uint64_t v5 = *a1;
  uint64_t v16 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v16, (char *)1);
  re::OPackWriter::writeData(*a1, *(re::zerocopy::WriteStream **)(a2 + 32), *(void *)(a2 + 16));
  uint64_t v6 = *a1;
  int v17 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v17, (char *)1);
  re::ConsensusWriter::write(a1, (unint64_t *)(a2 + 40));
  uint64_t v7 = *a1;
  uint64_t v18 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v18, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(unsigned __int8 *)(a2 + 120));
  uint64_t v8 = *a1;
  uint64_t v19 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v19, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(void *)(a2 + 128));
  char v9 = *a1;
  int v20 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v20, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(void *)(a2 + 136));
  uint64_t v10 = *a1;
  uint64_t v21 = 13;
  re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v21, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(void *)(a2 + 144));
  uint64_t v11 = *a1;
  long long v22 = 14;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v22, (char *)1);
  uint64_t v12 = *a1;
  if (*(unsigned char *)(a2 + 152)) {
    long long v13 = 1;
  }
  else {
    long long v13 = 2;
  }
  uint64_t v23 = v13;
  return re::zerocopy::writeAll(*v12, (re::zerocopy::WriteStream *)&v23, (char *)1);
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const Entry *a2)
{
  unint64_t v4 = *this;
  char v13 = -27;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v13, (char *)1);
  uint64_t v5 = *this;
  char v14 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v14, (char *)1);
  re::OPackWriter::writeData(*this, (re::zerocopy::WriteStream *)a2[4].withoutHash, (unint64_t)a2[2].withoutHash);
  uint64_t v6 = *this;
  char v15 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v15, (char *)1);
  re::OPackWriter::writeData(*this, (re::zerocopy::WriteStream *)a2[9].withoutHash, (unint64_t)a2[7].withoutHash);
  uint64_t v7 = *this;
  char v16 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v16, (char *)1);
  re::OPackWriter::writeInteger(*this, LOBYTE(a2[10].withoutHash));
  uint64_t v8 = *this;
  char v17 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v17, (char *)1);
  re::OPackWriter::writeInteger(*this, (uint64_t)a2[11].withoutHash);
  char v9 = *this;
  char v18 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v18, (char *)1);
  uint64_t v10 = *this;
  uint64_t withoutHash = (uint64_t)a2[12].withoutHash;
  return re::OPackWriter::writeInteger(v10, withoutHash);
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***a1, unint64_t *a2)
{
  unint64_t v4 = *a1;
  char v18 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v18, (char *)1);
  uint64_t v5 = *a1;
  char v19 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v19, (char *)1);
  re::OPackWriter::writeArrayBegin(*a1, a2[2]);
  unint64_t v6 = a2[2];
  if (v6)
  {
    uint64_t v7 = (uint64_t *)a2[4];
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7++;
      re::OPackWriter::writeInteger(*a1, v9);
      v8 -= 8;
    }
    while (v8);
    if (a2[2] >= 0xF)
    {
      uint64_t v10 = *a1;
      char v20 = 3;
      re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v20, (char *)1);
    }
  }
  uint64_t v11 = *a1;
  char v21 = 9;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v21, (char *)1);
  uint64_t result = re::OPackWriter::writeArrayBegin(*a1, a2[7]);
  unint64_t v13 = a2[7];
  if (v13)
  {
    char v14 = (uint64_t *)a2[9];
    uint64_t v15 = 8 * v13;
    do
    {
      uint64_t v16 = *v14++;
      uint64_t result = re::OPackWriter::writeInteger(*a1, v16);
      v15 -= 8;
    }
    while (v15);
    if (a2[7] >= 0xF)
    {
      char v17 = *a1;
      char v22 = 3;
      return re::zerocopy::writeAll(*v17, (re::zerocopy::WriteStream *)&v22, (char *)1);
    }
  }
  return result;
}

{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  re::zerocopy **v10;
  uint64_t v11;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  uint64_t vars8;

  unint64_t v4 = *a1;
  unint64_t v13 = -27;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v13, (char *)1);
  uint64_t v5 = *a1;
  char v14 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v14, (char *)1);
  re::ConsensusWriter::write(a1, a2);
  unint64_t v6 = *a1;
  uint64_t v15 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v15, (char *)1);
  re::ConsensusWriter::write(a1, a2 + 10);
  uint64_t v7 = *a1;
  uint64_t v16 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v16, (char *)1);
  re::OPackWriter::writeInteger(*a1, a2[20]);
  uint64_t v8 = *a1;
  char v17 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v17, (char *)1);
  re::OPackWriter::writeInteger(*a1, a2[21]);
  uint64_t v9 = *a1;
  char v18 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v18, (char *)1);
  uint64_t v10 = *a1;
  uint64_t v11 = a2[22];
  return re::OPackWriter::writeInteger(v10, v11);
}

uint64_t re::ConsensusReader::read(re::OPackReader **a1, void *a2)
{
  unint64_t v4 = *a1;
  uint64_t result = re::OPackReader::next(*a1, (uint64_t)a2);
  if (result)
  {
    if (*((unsigned char *)v4 + 196) == 13)
    {
      int v8 = re::OPackReader::next(*a1, v6);
      uint64_t result = 1;
      if (v8)
      {
        while (1)
        {
          uint64_t v9 = *a1;
          if (*((unsigned char *)*a1 + 184) == 5) {
            break;
          }
          if (*((unsigned char *)v9 + 196) != 6) {
            return 0;
          }
          if (*((unsigned char *)v9 + 224) == 1)
          {
            uint64_t result = re::OPackReader::next(*a1, v7);
            if (!result) {
              return result;
            }
            if (*((unsigned char *)v9 + 196) != 12) {
              return 0;
            }
            if (re::OPackReader::next(*a1, v14))
            {
              do
              {
                uint64_t v15 = *a1;
                if (*((unsigned char *)*a1 + 184) == 3) {
                  break;
                }
                uint64_t v18 = 0;
                *((unsigned char *)v15 + 2) = 1;
                if (re::OPackReader::next(v15, v11) && *((unsigned char *)v15 + 196) == 6) {
                  uint64_t v18 = *((void *)v15 + 28);
                }
                re::DynamicArray<re::TransitionCondition *>::add(a2 + 5, &v18);
              }
              while ((re::OPackReader::next(*a1, v16) & 1) != 0);
            }
          }
          else
          {
            if (*((unsigned char *)v9 + 224)) {
              return 0;
            }
            uint64_t result = re::OPackReader::next(*a1, v7);
            if (!result) {
              return result;
            }
            if (*((unsigned char *)v9 + 196) != 12) {
              return 0;
            }
            if (re::OPackReader::next(*a1, v10))
            {
              do
              {
                uint64_t v12 = *a1;
                if (*((unsigned char *)*a1 + 184) == 3) {
                  break;
                }
                *((unsigned char *)v12 + 2) = 1;
                uint64_t v18 = 0;
                if (re::OPackReader::next(v12, v11))
                {
                  if (*((unsigned char *)v12 + 196) == 6) {
                    uint64_t v18 = *((void *)v12 + 28);
                  }
                }
                re::DynamicArray<re::TransitionCondition *>::add(a2, &v18);
              }
              while ((re::OPackReader::next(*a1, v13) & 1) != 0);
            }
          }
          char v17 = re::OPackReader::next(*a1, v11);
          uint64_t result = 1;
          if ((v17 & 1) == 0) {
            return result;
          }
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const re::Message *a2)
{
  unint64_t v4 = *this;
  char v21 = -19;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v21, (char *)1);
  uint64_t v5 = *this;
  char v22 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v22, (char *)1);
  re::ConsensusWriter::write(this, (uint64_t)a2);
  uint64_t v6 = *this;
  char v23 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v23, (char *)1);
  re::OPackWriter::writeData(*this, *((re::zerocopy::WriteStream **)a2 + 9), *((void *)a2 + 7));
  uint64_t v7 = *this;
  char v24 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v24, (char *)1);
  re::ConsensusWriter::write(this, (const re::Message *)((char *)a2 + 80));
  int v8 = *this;
  char v25 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v25, (char *)1);
  re::OPackWriter::writeInteger(*this, *((unsigned __int8 *)a2 + 304));
  uint64_t v9 = *this;
  char v26 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v26, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 39));
  uint64_t v10 = *this;
  char v27 = 13;
  re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v27, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 40));
  uint64_t v11 = *this;
  char v28 = 14;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v28, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 41));
  uint64_t v12 = *this;
  char v29 = 15;
  re::zerocopy::writeAll(*v12, (re::zerocopy::WriteStream *)&v29, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 42));
  uint64_t v13 = *this;
  char v30 = 16;
  re::zerocopy::writeAll(*v13, (re::zerocopy::WriteStream *)&v30, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 43));
  uint64_t v14 = *this;
  char v31 = 17;
  re::zerocopy::writeAll(*v14, (re::zerocopy::WriteStream *)&v31, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 44));
  uint64_t v15 = *this;
  char v32 = 18;
  re::zerocopy::writeAll(*v15, (re::zerocopy::WriteStream *)&v32, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 45));
  uint64_t v16 = *this;
  char v33 = 19;
  re::zerocopy::writeAll(*v16, (re::zerocopy::WriteStream *)&v33, (char *)1);
  re::OPackWriter::writeInteger(*this, *((void *)a2 + 46));
  char v17 = *this;
  char v34 = 20;
  re::zerocopy::writeAll(*v17, (re::zerocopy::WriteStream *)&v34, (char *)1);
  uint64_t v18 = *this;
  if (*((unsigned char *)a2 + 376)) {
    char v19 = 1;
  }
  else {
    char v19 = 2;
  }
  char v35 = v19;
  return re::zerocopy::writeAll(*v18, (re::zerocopy::WriteStream *)&v35, (char *)1);
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const re::Snapshot *a2)
{
  unint64_t v4 = *this;
  char v8 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v8, (char *)1);
  uint64_t v5 = *this;
  char v9 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v9, (char *)1);
  re::OPackWriter::writeData(*this, *((re::zerocopy::WriteStream **)a2 + 4), *((void *)a2 + 2));
  uint64_t v6 = *this;
  char v10 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v10, (char *)1);
  return re::ConsensusWriter::write(this, (unint64_t *)a2 + 5);
}

uint64_t re::ConsensusReader::read(re::OPackReader **this, __n128 *a2)
{
  unint64_t v4 = *this;
  uint64_t result = re::OPackReader::next(*this, (uint64_t)a2);
  if (result)
  {
    if (*((unsigned char *)v4 + 196) == 13)
    {
      int v8 = re::OPackReader::next(*this, v6);
      uint64_t result = 1;
      if (v8)
      {
        char v9 = a2 + 5;
        char v10 = &a2[2].n128_u64[1];
        uint64_t v11 = &a2[7].n128_i8[8];
        uint64_t v12 = &a2[18].n128_i8[8];
        uint64_t v13 = a2 + 18;
        while (1)
        {
          uint64_t v14 = *this;
          if (*((unsigned char *)*this + 184) == 5) {
            return 1;
          }
          if (*((unsigned char *)v14 + 196) != 6) {
            return 0;
          }
          switch(*((unsigned char *)v14 + 224))
          {
            case 0:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 12) {
                return 0;
              }
              if (!re::OPackReader::next(*this, v15)) {
                goto LABEL_110;
              }
              unsigned __int8 v41 = v12;
              long long v42 = v11;
              long long v40 = v13;
              do
              {
                if (*((unsigned char *)*this + 184) == 3) {
                  break;
                }
                uint64_t v48 = 0;
                long long v46 = 0u;
                long long v47 = 0u;
                long long v44 = 0u;
                long long v45 = 0u;
                memset(v43, 0, sizeof(v43));
                re::DynamicArray<re::Entry>::add(a2, v43);
                if (*((void *)&v44 + 1))
                {
                  uint64_t v17 = *((void *)&v46 + 1);
                  if (*((void *)&v46 + 1)) {
                    (*(void (**)(void))(**((void **)&v44 + 1) + 40))();
                  }
                  *((void *)&v46 + 1) = 0;
                  long long v45 = 0uLL;
                  *((void *)&v44 + 1) = 0;
                  LODWORD(v46) = v46 + 1;
                }
                if (v43[0].n128_u64[0])
                {
                  uint64_t v17 = v44;
                  if ((void)v44) {
                    (*(void (**)(void))(*(void *)v43[0].n128_u64[0] + 40))();
                  }
                }
                uint64_t v18 = *this;
                *((unsigned char *)v18 + 2) = 1;
                unint64_t v19 = a2[2].n128_u64[0];
                unint64_t v20 = a2[1].n128_u64[0];
                uint64_t result = re::OPackReader::next(v18, v17);
                if (!result) {
                  return result;
                }
                if (*((unsigned char *)v18 + 196) != 13) {
                  return 0;
                }
                if (re::OPackReader::next(*this, v21))
                {
                  uint64_t v23 = v19 + 104 * (v20 - 1);
                  do
                  {
                    char v24 = *this;
                    if (*((unsigned char *)*this + 184) == 5) {
                      break;
                    }
                    if (*((unsigned char *)v24 + 196) != 6) {
                      return 0;
                    }
                    switch(*((unsigned char *)v24 + 224))
                    {
                      case 0:
                        uint64_t result = re::OPackReader::next(*this, v22);
                        if (!result) {
                          return result;
                        }
                        if (*((unsigned char *)v24 + 196) != 11) {
                          return 0;
                        }
                        re::DynamicArray<BOOL>::resize(v23, *((void *)*this + 27));
                        char v25 = (char *)*((void *)*this + 26);
                        size_t v26 = *((void *)*this + 27);
                        char v27 = (void *)v23;
                        goto LABEL_33;
                      case 1:
                        uint64_t result = re::OPackReader::next(*this, v22);
                        if (!result) {
                          return result;
                        }
                        if (*((unsigned char *)v24 + 196) != 11) {
                          return 0;
                        }
                        re::DynamicArray<BOOL>::resize(v23 + 40, *((void *)*this + 27));
                        char v25 = (char *)*((void *)*this + 26);
                        size_t v26 = *((void *)*this + 27);
                        char v27 = (void *)(v23 + 40);
LABEL_33:
                        re::DynamicArray<REFrameAnalysisBottleneck>::copy(v27, 0, v25, v26);
                        break;
                      case 2:
                        uint64_t result = re::OPackReader::next(*this, v22);
                        if (!result) {
                          return result;
                        }
                        if (*((unsigned char *)v24 + 196) != 6) {
                          return 0;
                        }
                        *(unsigned char *)(v23 + 8re::InputManager::notify(8, 0, 0, 0) = *((void *)v24 + 28);
                        break;
                      case 3:
                        uint64_t result = re::OPackReader::next(*this, v22);
                        if (!result) {
                          return result;
                        }
                        if (*((unsigned char *)v24 + 196) != 6) {
                          return 0;
                        }
                        *(void *)(v23 + 88) = *((void *)v24 + 28);
                        break;
                      case 4:
                        uint64_t result = re::OPackReader::next(*this, v22);
                        if (!result) {
                          return result;
                        }
                        if (*((unsigned char *)v24 + 196) != 6) {
                          return 0;
                        }
                        *(void *)(v23 + 96) = *((void *)v24 + 28);
                        break;
                      default:
                        return 0;
                    }
                  }
                  while ((re::OPackReader::next(*this, v28) & 1) != 0);
                }
                uint64_t v12 = v41;
                uint64_t v11 = v42;
                uint64_t v13 = v40;
              }
              while ((re::OPackReader::next(*this, v22) & 1) != 0);
              goto LABEL_110;
            case 1:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 11) {
                return 0;
              }
              re::DynamicArray<BOOL>::resize((uint64_t)v10, *((void *)*this + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy(v10, 0, *((char **)*this + 26), *((void *)*this + 27));
              goto LABEL_110;
            case 2:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 13) {
                return 0;
              }
              if (!re::OPackReader::next(*this, v29)) {
                goto LABEL_110;
              }
              break;
            case 3:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[19].n128_u8[0] = *((void *)v14 + 28);
              goto LABEL_110;
            case 4:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[19].n128_u64[1] = *((void *)v14 + 28);
              goto LABEL_110;
            case 5:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[20].n128_u64[0] = *((void *)v14 + 28);
              goto LABEL_110;
            case 6:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[20].n128_u64[1] = *((void *)v14 + 28);
              goto LABEL_110;
            case 7:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[21].n128_u64[0] = *((void *)v14 + 28);
              goto LABEL_110;
            case 8:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[21].n128_u64[1] = *((void *)v14 + 28);
              goto LABEL_110;
            case 9:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[22].n128_u64[0] = *((void *)v14 + 28);
              goto LABEL_110;
            case 0xA:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[22].n128_u64[1] = *((void *)v14 + 28);
              goto LABEL_110;
            case 0xB:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 6) {
                return 0;
              }
              a2[23].n128_u64[0] = *((void *)v14 + 28);
              goto LABEL_110;
            case 0xC:
              uint64_t result = re::OPackReader::next(*this, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v14 + 196) != 2) {
                return 0;
              }
              a2[23].n128_u8[8] = *((unsigned char *)*this + 224);
              goto LABEL_110;
            default:
              return 0;
          }
          do
          {
            char v30 = *this;
            if (*((unsigned char *)*this + 184) == 5) {
              break;
            }
            if (*((unsigned char *)v30 + 196) != 6) {
              return 0;
            }
            if (*((unsigned char *)v30 + 224) == 1)
            {
              uint64_t result = re::OPackReader::next(*this, v16);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v30 + 196) != 13) {
                return 0;
              }
              if (re::OPackReader::next(*this, v32))
              {
                do
                {
                  char v33 = *this;
                  if (*((unsigned char *)*this + 184) == 5) {
                    break;
                  }
                  if (*((unsigned char *)v33 + 196) != 6) {
                    return 0;
                  }
                  switch(*((unsigned char *)v33 + 224))
                  {
                    case 0:
                      char v34 = this;
                      char v35 = (unint64_t *)v11;
                      goto LABEL_67;
                    case 1:
                      char v34 = this;
                      char v35 = &a2[12].n128_u64[1];
LABEL_67:
                      if ((re::ConsensusReader::read(v34, v35) & 1) == 0) {
                        return 0;
                      }
                      continue;
                    case 2:
                      uint64_t result = re::OPackReader::next(*this, v31);
                      if (!result) {
                        return result;
                      }
                      int v37 = *((unsigned __int8 *)v33 + 196);
                      long long v38 = &a2[17].n128_u64[1];
                      break;
                    case 3:
                      uint64_t result = re::OPackReader::next(*this, v31);
                      if (!result) {
                        return result;
                      }
                      int v37 = *((unsigned __int8 *)v33 + 196);
                      long long v38 = (unint64_t *)v13;
                      break;
                    case 4:
                      uint64_t result = re::OPackReader::next(*this, v31);
                      if (!result) {
                        return result;
                      }
                      int v37 = *((unsigned __int8 *)v33 + 196);
                      long long v38 = (unint64_t *)v12;
                      break;
                    default:
                      return 0;
                  }
                  if (v37 != 6) {
                    return 0;
                  }
                  *long long v38 = *((void *)v33 + 28);
                }
                while ((re::OPackReader::next(*this, v36) & 1) != 0);
              }
            }
            else
            {
              if (*((unsigned char *)v30 + 224)) {
                return 0;
              }
              uint64_t result = re::OPackReader::next(*this, v16);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v30 + 196) != 11) {
                return 0;
              }
              re::DynamicArray<BOOL>::resize((uint64_t)v9, *((void *)*this + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy(v9, 0, *((char **)*this + 26), *((void *)*this + 27));
            }
          }
          while ((re::OPackReader::next(*this, v31) & 1) != 0);
LABEL_110:
          char v39 = re::OPackReader::next(*this, v16);
          uint64_t result = 1;
          if ((v39 & 1) == 0) {
            return result;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::ConsensusReader::read(re::OPackReader **a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  uint64_t result = re::OPackReader::next(*a1, a2);
  if (result)
  {
    if (*((unsigned char *)v4 + 196) == 13)
    {
      if (re::OPackReader::next(*a1, v6))
      {
        while (1)
        {
          int v8 = *a1;
          if (*((unsigned char *)*a1 + 184) == 5) {
            break;
          }
          if (*((unsigned char *)v8 + 196) != 6) {
            return 0;
          }
          switch(*((unsigned char *)v8 + 224))
          {
            case 0:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 11) {
                return 0;
              }
              re::DynamicArray<BOOL>::resize(a2, *((void *)*a1 + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy((void *)a2, 0, *((char **)*a1 + 26), *((void *)*a1 + 27));
              break;
            case 1:
              if ((re::ConsensusReader::read(a1, (void *)(a2 + 40)) & 1) == 0) {
                return 0;
              }
              break;
            case 2:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 6) {
                return 0;
              }
              *(unsigned char *)(a2 + 12re::InputManager::notify(8, 0, 0, 0) = *((void *)v8 + 28);
              break;
            case 3:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 6) {
                return 0;
              }
              *(void *)(a2 + 128) = *((void *)v8 + 28);
              break;
            case 4:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 6) {
                return 0;
              }
              *(void *)(a2 + 136) = *((void *)v8 + 28);
              break;
            case 5:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 6) {
                return 0;
              }
              *(void *)(a2 + 144) = *((void *)v8 + 28);
              break;
            case 6:
              uint64_t result = re::OPackReader::next(*a1, v7);
              if (!result) {
                return result;
              }
              if (*((unsigned char *)v8 + 196) != 2) {
                return 0;
              }
              *(unsigned char *)(a2 + 152) = *((unsigned char *)*a1 + 224);
              break;
            default:
              return 0;
          }
          char v10 = re::OPackReader::next(*a1, v9);
          uint64_t result = 1;
          if ((v10 & 1) == 0) {
            return result;
          }
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_anonymous_namespace_ *re::Generic6DOFConstraint::Generic6DOFConstraint(_anonymous_namespace_ *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  uint64_t v4 = 0;
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = "";
  *((void *)a1 + 5) = a2;
  *((void *)a1 + 6) = 0;
  *(void *)a1 = &unk_26E7163A8;
  *((void *)a1 + 7) = 0xBF8000003F800000;
  *((void *)a1 + 8) = 0xBF8000003F800000;
  *((void *)a1 + 9) = 0xBF8000003F800000;
  *((void *)a1 + 1re::InputManager::notify(8, 0, 0, 0) = 0xBF8000003F800000;
  *((void *)a1 + 11) = 0xBF8000003F800000;
  *((void *)a1 + 12) = 0xBF8000003F800000;
  do
  {
    uint64_t v5 = (void *)((char *)a1 + v4);
    *((unsigned char *)v5 + 128) = 0;
    v5[17] = 0;
    *((_DWORD *)v5 + 33) = 0;
    v4 += 16;
  }
  while (v4 != 48);
  for (uint64_t i = 0; i != 48; i += 16)
  {
    uint64_t v7 = (void *)((char *)a1 + i);
    *((unsigned char *)v7 + 176) = 0;
    v7[23] = 0;
    *((_DWORD *)v7 + 45) = 0;
  }
  for (uint64_t j = 0; j != 60; j += 20)
  {
    uint64_t v9 = (char *)a1 + j;
    v9[224] = 0;
    *((_DWORD *)v9 + 6re::InputManager::notify(8, 0, 0, 0) = 0;
    *(void *)(v9 + 228) = 0;
    v9[236] = 0;
  }
  for (uint64_t k = 0; k != 60; k += 20)
  {
    uint64_t v11 = (char *)a1 + k;
    v11[284] = 0;
    *((_DWORD *)v11 + 75) = 0;
    *((void *)v11 + 36) = 0;
    v11[296] = 0;
  }
  *((void *)a1 + 13) = 0;
  *((void *)a1 + 14) = 0;
  *((void *)a1 + 15) = 0;
  return a1;
}

uint64_t re::Generic6DOFConstraint::setLinearLimit(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 8 * (int)a2 + 56) = *a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 56);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularLimit(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 8 * (int)a2 + 8re::InputManager::notify(8, 0, 0, 0) = *a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 56);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearRestitution(uint64_t a1, uint64_t a2, float a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(float *)(a1 + 4 * (int)a2 + 104) = a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 64);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularRestitution(uint64_t a1, uint64_t a2, float a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(float *)(a1 + 4 * (int)a2 + 116) = a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 64);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearSpring(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_OWORD *)(a1 + 16 * (int)a2 + 128) = *a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 72);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularSpring(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_OWORD *)(a1 + 16 * (int)a2 + 176) = *a3;
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 72);
    return v3();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearMotor(uint64_t a1, uint64_t a2, long long *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = a1 + 20 * (int)a2;
    long long v4 = *a3;
    *(_DWORD *)(v3 + 24re::InputManager::notify(8, 0, 0, 0) = *((_DWORD *)a3 + 4);
    *(_OWORD *)(v3 + 224) = v4;
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)a1 + 80);
    return v5();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularMotor(uint64_t a1, uint64_t a2, long long *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = a1 + 20 * (int)a2;
    long long v4 = *a3;
    *(_DWORD *)(v3 + 30re::InputManager::notify(8, 0, 0, 0) = *((_DWORD *)a3 + 4);
    *(_OWORD *)(v3 + 284) = v4;
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)a1 + 80);
    return v5();
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::type(re::Generic6DOFConstraint *this)
{
  return 6;
}

uint64_t re::Constraint::localAnchorPoseA(re::Constraint *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 32))();
}

uint64_t re::Constraint::localAnchorPoseB(re::Constraint *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 40))();
}

double re::HingeJoint::HingeJoint(_anonymous_namespace_ *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = "";
  *((void *)a1 + 5) = a2;
  *((void *)a1 + 6) = 0;
  *(void *)a1 = &unk_26E716428;
  double result = -0.00781250185;
  *((void *)a1 + 7) = 0xBF8000003F800000;
  return result;
}

uint64_t re::HingeJoint::setAngularLimit(uint64_t a1, double a2, float a3)
{
  *(_DWORD *)(a1 + 56) = LODWORD(a2);
  *(float *)(a1 + 6re::InputManager::notify(8, 0, 0, 0) = a3;
  if (*(float *)&a2 <= a3)
  {
    *((float *)&a2 + 1) = a3;
    float32x2_t v3 = (float32x2_t)vdup_n_s32(0x40C90FDBu);
    float32x2_t v4 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&a2, v3), (int8x8_t)v3, *(int8x8_t *)&a2);
    float32x2_t v5 = (float32x2_t)vdup_n_s32(0xC0C90FDB);
    *(int8x8_t *)(a1 + 56) = vbsl_s8((int8x8_t)vcgt_f32(v5, v4), (int8x8_t)v5, (int8x8_t)v4);
  }
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t re::HingeJoint::type(re::HingeJoint *this)
{
  return 3;
}

uint64_t re::Gravity::didEnable(float32x4_t *this)
{
  uint64_t result = this->i64[1];
  if (result)
  {
    v3.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)result + 72))(result);
    v3.i64[1] = v4;
    float32x4_t v5 = vaddq_f32(this[2], v3);
    return (*(uint64_t (**)(uint64_t, float32x4_t *))(*(void *)this->i64[1] + 80))(this->i64[1], &v5);
  }
  return result;
}

uint64_t re::Gravity::didDisable(float32x4_t *this)
{
  uint64_t result = this->i64[1];
  if (result)
  {
    v3.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)result + 72))(result);
    v3.i64[1] = v4;
    float32x4_t v5 = vsubq_f32(v3, this[2]);
    return (*(uint64_t (**)(uint64_t, float32x4_t *))(*(void *)this->i64[1] + 80))(this->i64[1], &v5);
  }
  return result;
}

uint64_t re::Gravity::didAddToSimulation(uint64_t this)
{
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v1 = this;
    v2.i64[0] = (*(uint64_t (**)(void))(**(void **)(this + 8) + 72))(*(void *)(this + 8));
    v2.i64[1] = v3;
    float32x4_t v4 = vaddq_f32(*(float32x4_t *)(v1 + 32), v2);
    return (*(uint64_t (**)(void, float32x4_t *))(**(void **)(v1 + 8) + 80))(*(void *)(v1 + 8), &v4);
  }
  return this;
}

uint64_t re::Gravity::willRemoveFromSimulation(uint64_t this)
{
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v1 = this;
    v2.i64[0] = (*(uint64_t (**)(void))(**(void **)(this + 8) + 72))(*(void *)(this + 8));
    v2.i64[1] = v3;
    float32x4_t v4 = vsubq_f32(v2, *(float32x4_t *)(v1 + 32));
    return (*(uint64_t (**)(void, float32x4_t *))(**(void **)(v1 + 8) + 80))(*(void *)(v1 + 8), &v4);
  }
  return this;
}

uint64_t re::Gravity::setAcceleration(uint64_t result, _OWORD *a2)
{
  float32x4_t v2 = *(float32x4_t *)(result + 32);
  *(_OWORD *)(result + 32) = *a2;
  if (*(unsigned char *)(result + 16))
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(result + 8);
    if (result)
    {
      float32x4_t v6 = v2;
      v4.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)result + 72))(result);
      v4.i64[1] = v5;
      float32x4_t v7 = vaddq_f32(*(float32x4_t *)(v3 + 32), vsubq_f32(v4, v6));
      return (*(uint64_t (**)(void, float32x4_t *))(**(void **)(v3 + 8) + 80))(*(void *)(v3 + 8), &v7);
    }
  }
  return result;
}

void re::Gravity::~Gravity(re::Gravity *this)
{
}

uint64_t re::Gravity::type(re::Gravity *this)
{
  return 1;
}

re::PhysXFixedJoint *re::PhysXFixedJoint::PhysXFixedJoint(re::PhysXFixedJoint *this, physx::PxFixedJoint *a2, uint64_t a3)
{
  *(void *)this = &unk_26E7164F0;
  float32x4_t v6 = (char *)this + 56;
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = "";
  *((void *)this + 5) = v6;
  *(void *)this = &unk_26E7164F0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = &unk_26E717308;
  *((void *)this + 8) = a2;
  *((void *)a2 + 2) = this;
  (*(void (**)(physx::PxFixedJoint *, uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 16, 1);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 128))(*((void *)this + 8), 8, a3);
  return this;
}

void re::PhysXFixedJoint::~PhysXFixedJoint(re::PhysXFixedJoint *this)
{
  *(void *)this = &unk_26E7164F0;
  float32x4_t v2 = (void (***)(void))*((void *)this + 8);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXFixedJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  *(void *)this = &unk_26E7164F0;
  float32x4_t v2 = (void (***)(void))*((void *)this + 8);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXFixedJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::FixedJoint::type(re::FixedJoint *this)
{
  return 1;
}

uint64_t re::PhysXSliderJoint::PhysXSliderJoint(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_26E716550;
  double v8 = re::SliderJoint::SliderJoint((_anonymous_namespace_ *)a1, a1 + 64);
  *uint64_t v9 = &unk_26E716550;
  unsigned char v9[8] = &unk_26E717308;
  v9[9] = a2;
  a2[2] = v9;
  (*(void (**)(void *, uint64_t, uint64_t, double))(*a2 + 128))(a2, 16, 1, v8);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 128))(*(void *)(a1 + 72), 8, a4);
  *(void *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = a3;
  return a1;
}

uint64_t re::PhysXSliderJoint::updateLimits(re::PhysXSliderJoint *this)
{
  uint64_t v2 = *((void *)this + 9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v2 + 280))(v2, 2, *((float *)this + 14) <= *((float *)this + 15));
  float v5 = *((float *)this + 14);
  float v4 = *((float *)this + 15);
  if (v5 <= v4)
  {
    float32x4_t v6 = (float *)*((void *)this + 10);
    v9[0] = 0;
    v9[1] = 0;
    float v11 = v4;
    float v12 = v5;
    float v7 = *v6;
    float v8 = (float)(v5 * -0.49) + (float)(v4 * 0.49);
    if ((float)(*v6 * 0.01) < v8) {
      float v8 = *v6 * 0.01;
    }
    float v10 = v8;
    *((float *)v9 + 1) = v7 + v7;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 256))(v2, v9);
  }
  return result;
}

void re::PhysXSliderJoint::~PhysXSliderJoint(re::PhysXSliderJoint *this)
{
  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXSliderJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXSliderJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SliderJoint::type(re::SliderJoint *this)
{
  return 4;
}

void re::PhysicsJointCollection::~PhysicsJointCollection(BOOL this)
{
  uint64_t v1 = this;
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(void *)(this + 32))
  {
    uint64_t v2 = *re::physicsLogObjects((re *)this);
    this = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      uint64_t v3 = *(void *)(v1 + 32);
      int v6 = 67109120;
      int v7 = v3;
      _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "~PhysicsJointCollection(): %d joints left in the collection", (uint8_t *)&v6, 8u);
    }
  }
  if (*(_DWORD *)(v1 + 84))
  {
    float v4 = *re::physicsLogObjects((re *)this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(v1 + 84);
      int v6 = 67109120;
      int v7 = v5;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "~PhysicsJointCollection(): %d deferred to be deleted joints left in the collection", (uint8_t *)&v6, 8u);
    }
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(v1 + 56));
  re::DynamicArray<unsigned long>::deinit(v1 + 16);
}

void re::PhysicsJointCollection::~PhysicsJointCollection(re::PhysicsJointCollection *this)
{
  re::PhysicsJointCollection::~PhysicsJointCollection((BOOL)this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysicsJointCollection::operator[](uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 32) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 48) + 8 * a2);
}

void re::PhysicsJointCollection::add(re::PhysicsJointCollection *this, re::Constraint *a2)
{
  int v7 = a2;
  re::DynamicArray<re::TransitionCondition *>::add((void *)this + 2, &v7);
  uint64_t v3 = v7;
  *((void *)v7 + 6) = *((void *)this + 1);
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  (*(void (**)(void))(**((void **)v3 + 5) + 64))(*((void *)v3 + 5));
  int v5 = (re::RigidBody *)(*(uint64_t (**)(void))(**((void **)v7 + 5) + 16))(*((void *)v7 + 5));
  if (v5) {
    re::RigidBody::setAttachedJointCount(v5, *((_DWORD *)v5 + 77) + 1);
  }
  int v6 = (re::RigidBody *)(*(uint64_t (**)(void))(**((void **)v7 + 5) + 24))(*((void *)v7 + 5));
  if (v6) {
    re::RigidBody::setAttachedJointCount(v6, *((_DWORD *)v6 + 77) + 1);
  }
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
}

uint64_t re::PhysicsJointCollection::deleteJoint(uint64_t this, re::Constraint *a2, int a3)
{
  uint64_t v9 = a2;
  if (a2)
  {
    uint64_t v3 = this;
    if (a3)
    {
      re::DynamicArray<unsigned long long>::remove(this + 16, &v9);
      return re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::add(v3 + 56, (uint64_t *)&v9);
    }
    else
    {
      if (*((void *)a2 + 6))
      {
        float v10 = a2;
        re::DynamicArray<re::Allocator const*>::removeStable((void *)(this + 16), &v10);
      }
      if (physx::shdfnd::g_isLockingEnabled) {
        int v5 = 1;
      }
      else {
        int v5 = physx::shdfnd::g_alwaysUseLocking;
      }
      if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
        physx::shdfnd::g_isLockingEnabled = 0;
      }
      (*(void (**)(void, void))(**((void **)a2 + 5) + 72))(*((void *)a2 + 5), *(void *)(v3 + 8));
      int v6 = (re::RigidBody *)(*(uint64_t (**)(void))(**((void **)a2 + 5) + 16))(*((void *)a2 + 5));
      if (v6) {
        re::RigidBody::setAttachedJointCount(v6, *((_DWORD *)v6 + 77) - 1);
      }
      int v7 = (re::RigidBody *)(*(uint64_t (**)(void))(**((void **)a2 + 5) + 24))(*((void *)a2 + 5));
      if (v7) {
        re::RigidBody::setAttachedJointCount(v7, *((_DWORD *)v7 + 77) - 1);
      }
      uint64_t v8 = re::globalAllocators(v7)[2];
      (**(void (***)(re::Constraint *))a2)(a2);
      this = (*(uint64_t (**)(uint64_t, re::Constraint *))(*(void *)v8 + 40))(v8, a2);
      if (physx::shdfnd::g_isLockingEnabled != v5) {
        physx::shdfnd::g_isLockingEnabled = v5;
      }
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::PhysicsJointCollection::deleteDeferredDeletedJoints(re::PhysicsJointCollection *this)
{
  uint64_t v2 = *((unsigned int *)this + 22);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 9) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 22);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      re::PhysicsJointCollection::deleteJoint((uint64_t)this, *(re::Constraint **)(*((void *)this + 9) + 24 * v6 + 16), 0);
      unsigned int v7 = *((_DWORD *)this + 22);
      if (v7 <= (int)v3 + 1) {
        int v8 = v3 + 1;
      }
      else {
        int v8 = *((_DWORD *)this + 22);
      }
      int v9 = v3;
      while (1)
      {
        uint64_t v6 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)this + 9) + 24 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v7 != v3);
  }
  re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::clear((uint64_t)this + 56);
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_12, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = v8;
  }
}

const re::RigidBody *re::PhysicsJointCollection::deleteJointsReferencingRigidBody(const re::RigidBody *this, const re::RigidBody *a2)
{
  if (*((int *)a2 + 77) >= 1)
  {
    uint64_t v2 = (uint64_t)this;
    if ((int)*((void *)this + 4) >= 1)
    {
      unint64_t v4 = *((void *)this + 4) + 1;
      do
      {
        unint64_t v5 = (v4 - 2);
        if (*(void *)(v2 + 32) <= v5)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_12:
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v6 = *(re::Constraint **)(*(void *)(v2 + 48) + 8 * v5);
        if ((const re::RigidBody *)(*(uint64_t (**)(void *))(**((void **)v6 + 5) + 16))(*((void **)v6 + 5)) == a2) {
          goto LABEL_8;
        }
        if (*(void *)(v2 + 32) <= v5) {
          goto LABEL_12;
        }
        uint64_t v7 = *(void *)(*(void *)(*(void *)(v2 + 48) + 8 * v5) + 40);
        this = (const re::RigidBody *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
        if (this == a2) {
LABEL_8:
        }
          this = (const re::RigidBody *)re::PhysicsJointCollection::deleteJoint(v2, v6, 0);
        --v4;
      }
      while (v4 > 1);
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)uint64_t v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_12, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

float re::PhysicsMaterial::createGenericMaterial(re::PhysicsMaterial *this, re::Allocator *a2)
{
  uint64_t v3 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 24, 8);
  if (v3)
  {
    float result = *((float *)this + 4);
    *(void *)uint64_t v3 = &unk_26E7165E8;
    *(void *)(v3 + 8) = *((void *)this + 1);
    *(float *)(v3 + 16) = result;
  }
  return result;
}

void *re::allocInfo_PhysicsMaterial(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99008, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99008))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99030, "PhysicsMaterial");
    __cxa_guard_release(&qword_26AF99008);
  }
  return &unk_26AF99030;
}

void re::initInfo_PhysicsMaterial(re *this, re::IntrospectionBase *a2)
{
  v20[0] = 0x6D3D3F22840C60DCLL;
  v20[1] = "PhysicsMaterial";
  re::StringID::destroyString((re::StringID *)v20);
  *((_OWORD *)this + 2) = v21;
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_424, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&_MergedGlobals_424);
    if (v4)
    {
      long long v5 = re::introspectionAllocator(v4);
      long long v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "m_restitution";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x800000001;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99010 = v8;
      signed int v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "m_staticFriction";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0xC00000002;
      *(_DWORD *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99018 = v12;
      uint64_t v13 = re::introspectionAllocator((re *)v12);
      unint64_t v14 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 24, 8);
      *(_DWORD *)unint64_t v14 = 5;
      *((void *)v14 + 1) = "m_friction";
      *((void *)v14 + 2) = "m_staticFriction";
      qword_26AF99020 = (uint64_t)v14;
      unint64_t v15 = re::introspectionAllocator(v14);
      uint64_t v17 = re::introspect_float((re *)1, v16);
      uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "m_dynamicFriction";
      *(void *)(v18 + 16) = v17;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0x1000000003;
      *(_DWORD *)(v18 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF99028 = v18;
      __cxa_guard_release(&_MergedGlobals_424);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF99010;
  *((void *)this + 9) = re::internal::defaultConstruct<re::PhysicsMaterial>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::PhysicsMaterial>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::PhysicsMaterial>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::PhysicsMaterial>;
  re::IntrospectionRegistry::add(this, v3);
  long long v19 = v21;
}

double re::internal::defaultConstruct<re::PhysicsMaterial>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = &unk_26E7165E8;
  double result = 0.0000305175852;
  *(void *)(a3 + 8) = 0x3F0000003DCCCCCDLL;
  *(_DWORD *)(a3 + 16) = -1082130432;
  return result;
}

uint64_t re::internal::defaultDestruct<re::PhysicsMaterial>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::PhysicsMaterial>(uint64_t a1)
{
  *(void *)a1 = &unk_26E7165E8;
  double result = 0.0000305175852;
  *(void *)(a1 + 8) = 0x3F0000003DCCCCCDLL;
  *(_DWORD *)(a1 + 16) = -1082130432;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::PhysicsMaterial>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_PhysicsMaterial(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PhysicsMaterial", (uint64_t (*)(re::internal *))re::allocInfo_PhysicsMaterial, (re::IntrospectionBase *(*)(void))re::initInfo_PhysicsMaterial, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PhysicsMaterial>, this);
}

void re::PhysicsMaterial::~PhysicsMaterial(re::PhysicsMaterial *this)
{
}

uint64_t *re::physicsLogObjects(re *this)
{
  {
    re::physicsLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Physics");
  }
  return &re::physicsLogObjects(void)::logObjects;
}

void *re::LinearSpring::onApply(re::LinearSpring *this)
{
  (*(void (**)(float32x4_t *__return_ptr))(**((void **)this + 3) + 40))(&v38);
  float32x4_t v2 = *((float32x4_t *)this + 3);
  float32x4_t v3 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL);
  float32x4_t v4 = vnegq_f32((float32x4_t)v39);
  float32x4_t v5 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL), v4), v2, v3);
  int32x4_t v6 = (int32x4_t)vaddq_f32(v5, v5);
  float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  int32x4_t v8 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), v4), v7, v3);
  float32x4_t v35 = vaddq_f32(v38, vaddq_f32(vaddq_f32(v2, vmulq_laneq_f32(v7, (float32x4_t)v39, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL)));
  float32x4_t v40 = v35;
  double result = (*(void *(**)(float32x4_t *__return_ptr))(**((void **)this + 4) + 40))(&v38);
  float32x4_t v10 = *((float32x4_t *)this + 4);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL);
  float32x4_t v12 = vnegq_f32((float32x4_t)v39);
  float32x4_t v13 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL), v12), v10, v11);
  int32x4_t v14 = (int32x4_t)vaddq_f32(v13, v13);
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL);
  int32x4_t v16 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), v12), v15, v11);
  float32x4_t v37 = vaddq_f32(v38, vaddq_f32(vaddq_f32(v10, vmulq_laneq_f32(v15, (float32x4_t)v39, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL)));
  float32x4_t v17 = vsubq_f32(v35, v37);
  float32x4_t v18 = vmulq_f32(v17, v17);
  int32x2_t v19 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).u64[0];
  *(float *)v19.i32 = sqrtf(*(float *)v19.i32);
  if (*(float *)v19.i32 < 0.000001) {
    return result;
  }
  float v20 = *((float *)this + 20);
  float v21 = *(float *)v19.i32 - v20;
  *((_DWORD *)this + 22) = 0;
  if (*(float *)v19.i32 > v20)
  {
    float v22 = *((float *)this + 25);
    if (v22 > 0.000001)
    {
      float v23 = v21 / v22;
      goto LABEL_9;
    }
  }
  if (*(float *)v19.i32 < v20)
  {
    float v24 = *((float *)this + 24);
    if (v24 > 0.000001)
    {
      float v23 = (float)(v20 - *(float *)v19.i32) / v24;
LABEL_9:
      *((float *)this + 22) = v23;
      if (v23 > 1.0)
      {
        if (*((unsigned char *)this + 16))
        {
          *((unsigned char *)this + 16) = 0;
          return (void *)(*(uint64_t (**)(re::LinearSpring *))(*(void *)this + 32))(this);
        }
        return result;
      }
    }
  }
  double result = (void *)*((void *)this + 3);
  int v25 = *((_DWORD *)result + 52);
  float v26 = 0.0;
  if (v25 == 2) {
    float v26 = *((float *)result + 48);
  }
  uint64_t v27 = *((void *)this + 4);
  int v28 = *(_DWORD *)(v27 + 208);
  if (v28 == 2)
  {
    float v29 = *(float *)(v27 + 192);
    float v30 = v26 + v29;
    if ((float)(v26 + v29) == 0.0) {
      return result;
    }
    BOOL v31 = v29 == 0.0;
    float v32 = v29 / v30;
    if (v31) {
      float v32 = 1.0;
    }
  }
  else
  {
    float v30 = v26 + 0.0;
    if ((float)(v26 + 0.0) == 0.0) {
      return result;
    }
    float v32 = 1.0;
  }
  float32x4_t v33 = vmulq_n_f32(vdivq_f32(vmulq_n_f32(v17, v21), (float32x4_t)vdupq_lane_s32(v19, 0)), -*((float *)this + 21));
  float32x4_t v34 = vmulq_n_f32(v33, v32);
  float32x4_t v38 = v34;
  v34.f32[0] = v26 / v30;
  if (v26 == 0.0) {
    v34.f32[0] = 1.0;
  }
  float32x4_t v36 = vmulq_f32(v33, vnegq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0)));
  if (v25 == 2)
  {
    double result = (void *)(*(uint64_t (**)(void *, float32x4_t *, float32x4_t *, void))(*result + 376))(result, &v38, &v40, 0);
    uint64_t v27 = *((void *)this + 4);
    int v28 = *(_DWORD *)(v27 + 208);
  }
  if (v28 == 2) {
    return (void *)(*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, void))(*(void *)v27 + 376))(v27, &v36, &v37, 0);
  }
  return result;
}

void re::LinearSpring::~LinearSpring(re::LinearSpring *this)
{
}

uint64_t re::LinearSpring::type(re::LinearSpring *this)
{
  return 5;
}

double re::PhysXRigidBody::PhysXRigidBody(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, int a5)
{
  *(void *)a1 = &unk_26E6DD048;
  long long v5 = a4[1];
  *(_OWORD *)(a1 + 16) = *a4;
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)a1 = &unk_26E717060;
  *(void *)(a1 + 64) = a3;
  *(void *)(a1 + 72) = 0;
  long long v6 = *a4;
  long long v7 = a4[1];
  long long v8 = a4[3];
  *(_OWORD *)(a1 + 112) = a4[2];
  *(_OWORD *)(a1 + 128) = v8;
  *(_OWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = v6;
  *(_OWORD *)(a1 + 96) = v7;
  long long v9 = *a4;
  long long v10 = a4[1];
  long long v11 = a4[3];
  *(_OWORD *)(a1 + 176) = a4[2];
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = v11;
  *(_OWORD *)(a1 + 144) = v9;
  *(_OWORD *)(a1 + 16re::InputManager::notify(8, 0, 0, 0) = v10;
  *(_DWORD *)(a1 + 208) = a5;
  *(void *)(a1 + 212) = 0x100000006;
  *(_DWORD *)(a1 + 308) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 236) = 0u;
  *(_OWORD *)(a1 + 22re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(void *)(a1 + 297) = 0;
  *(void *)a1 = &unk_26E716690;
  *(void *)(a1 + re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312) = 0x3B23D70A3F800000;
  *(unsigned char *)(a1 + 32re::InputManager::notify(8, 0, 0, 0) = 1;
  *(void *)(a1 + 324) = 0x3D4CCCCD3CA3D70ALL;
  *(_OWORD *)(a1 + 40re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352) = 0u;
  *(void *)(a1 + 432) = a2;
  *(unsigned char *)(a1 + 44re::InputManager::notify(8, 0, 0, 0) = 0;
  return result;
}

uint64_t re::PhysXRigidBody::updateUnderlyingRigidBody(uint64_t this, __n128 a2)
{
  float32x4_t v2 = *(_WORD **)(*(void *)(this + 72) + 24);
  if (v2 && v2[4] == 5)
  {
    float32x4_t v3 = (float *)this;
    a2.n128_u32[0] = *(_DWORD *)(this + 324);
    if (a2.n128_f32[0] < 0.0) {
      a2.n128_f32[0] = 0.0;
    }
    (*(void (**)(void, __n128))(*(void *)v2 + 280))(*(void *)(*(void *)(this + 72) + 24), a2);
    v4.n128_f32[0] = v3[82] * 5.0;
    if (v4.n128_f32[0] < 0.0) {
      v4.n128_f32[0] = 0.0;
    }
    (*(void (**)(_WORD *, __n128))(*(void *)v2 + 296))(v2, v4);
    re::PhysXRigidBody::updateSleepThreshold((re::PhysXRigidBody *)v3);
    return re::PhysXRigidBody::updateCCDSettings((uint64_t)v3);
  }
  return this;
}

_WORD *re::PhysXRigidBody::updateSleepThreshold(re::PhysXRigidBody *this)
{
  double result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result && result[4] == 5 && *((unsigned char *)this + 320))
  {
    float v3 = *((float *)this + 82);
    if (v3 > *((float *)this + 81)) {
      float v3 = *((float *)this + 81);
    }
    if (v3 > 1.0) {
      float v3 = 1.0;
    }
    if (v3 < 0.0) {
      float v3 = 0.0;
    }
    return (_WORD *)(*(uint64_t (**)(float))(*(void *)result + 520))((float)(*((float *)this + 78)
                                                                                         * *((float *)this + 79)) * v3);
  }
  return result;
}

uint64_t re::PhysXRigidBody::updateCCDSettings(uint64_t this)
{
  uint64_t v1 = *(_WORD **)(*(void *)(this + 72) + 24);
  if (v1 && v1[4] == 5)
  {
    float32x4_t v2 = *(void (**)(void, uint64_t, uint64_t))(*(void *)v1 + 416);
    if (*(unsigned char *)(this + 304))
    {
      v2(*(void *)(*(void *)(this + 72) + 24), 4, 1);
      float v3 = *(uint64_t (**)(_WORD *, __n128))(*(void *)v1 + 440);
      v4.n128_u32[0] = 1041865114;
      return v3(v1, v4);
    }
    else
    {
      uint64_t v5 = *(void *)(*(void *)(this + 72) + 24);
      return ((uint64_t (*)(uint64_t, uint64_t, void))v2)(v5, 4, 0);
    }
  }
  return this;
}

uint64_t re::PhysXRigidBody::setCollisionObject(re::PhysXRigidBody *this, re::CollisionObject *a2)
{
  *((void *)this + 9) = a2;
  (*(void (**)(re::PhysXRigidBody *))(*(void *)this + 432))(this);
  return re::PhysXRigidBody::updateUnderlyingRigidBody((uint64_t)this, v3);
}

void re::PhysXRigidBody::~PhysXRigidBody(re::PhysXRigidBody *this)
{
  float32x4_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 54);
    (**v2)(*((void *)this + 9));
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v3 + 40))(v3, v2);
  }
  __n128 v4 = (void (***)(void))*((void *)this + 8);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 54);
    (**v4)(*((void *)this + 8));
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v5 + 40))(v5, v4);
  }
  *(void *)this = &unk_26E717060;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
}

{
  uint64_t vars8;

  re::PhysXRigidBody::~PhysXRigidBody(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RigidBody::shape(re::RigidBody *this)
{
  return *((void *)this + 8);
}

{
  return *((void *)this + 8);
}

uint64_t re::PhysXRigidBody::changeUnderlyingType(re::PhysXRigidBody *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 9) + 24);
  BOOL v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2) == 0;
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)v2 + 152))(v6, v2);
  uint64_t UnderlyingRigidBody = re::PhysXPhysicsFactory::createUnderlyingRigidBody(re::PhysicsFactory::m_defaultFactory, re::PhysicsFactory::m_defaultAllocator, v2, (uint64_t *)this + 18, v3);
  (**(void (***)(uint64_t))v2)(v2);
  (*(void (**)(void, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), UnderlyingRigidBody);
  (*(void (**)(void, void *, uint64_t))(**(void **)(*((void *)this + 9) + 24) + 160))(*(void *)(*((void *)this + 9) + 24), v6, 1);
  return re::PhysXRigidBody::setSolverIterations((uint64_t)this, (unsigned int *)this + 53);
}

uint64_t re::PhysXRigidBody::setSolverIterations(uint64_t result, unsigned int *a2)
{
  if (*(_DWORD *)(result + 212) != *a2 || *(_DWORD *)(result + 216) != a2[1])
  {
    *(void *)(result + 212) = *(void *)a2;
    double result = *(void *)(*(void *)(result + 72) + 24);
    if (result)
    {
      if (*(_WORD *)(result + 8) == 5) {
        return (*(uint64_t (**)(uint64_t, void, void))(*(void *)result + 608))(result, *a2, a2[1]);
      }
    }
  }
  return result;
}

uint64_t re::PhysXRigidBody::logRigidBodyState(re::PhysXRigidBody *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 9) + 24))();
}

__n128 re::PhysXRigidBody::onMotionTypeChanged(__n128 *this, int a2)
{
  uint64_t v4 = *(void *)(this[4].n128_u64[1] + 24);
  if (v4)
  {
    if (*(_WORD *)(v4 + 8) == 5) {
      uint64_t v5 = *(void *)(this[4].n128_u64[1] + 24);
    }
    else {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  if ((a2 - 1) >= 2)
  {
    if (a2) {
      return result;
    }
    if (v5) {
      re::PhysXRigidBody::changeUnderlyingType((re::PhysXRigidBody *)this);
    }
  }
  else
  {
    if (!v5)
    {
      re::PhysXRigidBody::changeUnderlyingType((re::PhysXRigidBody *)this);
      uint64_t v6 = *(void *)(this[4].n128_u64[1] + 24);
      if (v6)
      {
        if (*(_WORD *)(v6 + 8) == 5) {
          uint64_t v5 = *(void *)(this[4].n128_u64[1] + 24);
        }
        else {
          uint64_t v5 = 0;
        }
      }
      else
      {
        uint64_t v5 = 0;
      }
    }
    long long v7 = *(void (**)(uint64_t, uint64_t, void))(*(void *)v5 + 416);
    if (a2 == 2)
    {
      v7(v5, 1, 0);
      (*(void (**)(uint64_t, __n128 *, uint64_t))(*(void *)v5 + 320))(v5, this + 21, 1);
      v8.n128_f64[0] = (*(double (**)(uint64_t, __n128 *, uint64_t))(*(void *)v5 + 336))(v5, this + 22, 1);
      re::PhysXRigidBody::updateUnderlyingRigidBody((uint64_t)this, v8);
    }
    else
    {
      v7(v5, 4, 0);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 416))(v5, 1, 1);
    }
  }
  this[21].n128_u64[0] = 0;
  this[21].n128_u64[1] = 0;
  __n128 result = this[21];
  this[22] = result;
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationX(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)(var1 & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationY(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)((var1 >> 1) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationZ(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)((var1 >> 2) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *re::PhysXRigidBody::setLockTranslationX(void *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      uint64_t v4 = this;
      this = re::PhysXRigidBody::lockTranslationX((re::PhysXRigidBody *)this);
      if (this != a2)
      {
        this = (void *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560))(v2, 1, a2);
        if ((a2 & 1) == 0)
        {
          return re::PhysXRigidBody::wakeUp(v4);
        }
      }
    }
  }
  return this;
}

void *re::PhysXRigidBody::wakeUp(void *this)
{
  uint64_t v1 = *(_WORD **)(this[9] + 24);
  if (v1 && v1[4] == 5)
  {
    this = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v1 + 432))(&v2, *(void *)(this[9] + 24));
    if ((v2 & 1) == 0) {
      return (void *)(*(uint64_t (**)(_WORD *))(*(void *)v1 + 592))(v1);
    }
  }
  return this;
}

void *re::PhysXRigidBody::setLockTranslationY(void *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      uint64_t v4 = this;
      this = re::PhysXRigidBody::lockTranslationY((re::PhysXRigidBody *)this);
      if (this != a2)
      {
        this = (void *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560))(v2, 2, a2);
        if ((a2 & 1) == 0)
        {
          return re::PhysXRigidBody::wakeUp(v4);
        }
      }
    }
  }
  return this;
}

void *re::PhysXRigidBody::setLockTranslationZ(void *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      uint64_t v4 = this;
      this = re::PhysXRigidBody::lockTranslationZ((re::PhysXRigidBody *)this);
      if (this != a2)
      {
        this = (void *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560))(v2, 4, a2);
        if ((a2 & 1) == 0)
        {
          return re::PhysXRigidBody::wakeUp(v4);
        }
      }
    }
  }
  return this;
}

_WORD *re::PhysXRigidBody::lockRotationX(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)((var1 >> 3) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockRotationY(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)((var1 >> 4) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockRotationZ(re::PhysXRigidBody *this)
{
  __n128 result = *(_WORD **)(*((void *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)result + 552))(&var1);
      return (_WORD *)((var1 >> 5) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

re::PhysXRigidBody *re::PhysXRigidBody::setLockRotationX(re::PhysXRigidBody *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      this = (re::PhysXRigidBody *)re::PhysXRigidBody::lockRotationX(this);
      if (this != a2)
      {
        uint64_t v4 = *(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560);
        return (re::PhysXRigidBody *)v4(v2, 8, a2);
      }
    }
  }
  return this;
}

re::PhysXRigidBody *re::PhysXRigidBody::setLockRotationY(re::PhysXRigidBody *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      this = (re::PhysXRigidBody *)re::PhysXRigidBody::lockRotationY(this);
      if (this != a2)
      {
        uint64_t v4 = *(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560);
        return (re::PhysXRigidBody *)v4(v2, 16, a2);
      }
    }
  }
  return this;
}

re::PhysXRigidBody *re::PhysXRigidBody::setLockRotationZ(re::PhysXRigidBody *this, uint64_t a2)
{
  uint64_t v2 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      this = (re::PhysXRigidBody *)re::PhysXRigidBody::lockRotationZ(this);
      if (this != a2)
      {
        uint64_t v4 = *(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(void *)v2 + 560);
        return (re::PhysXRigidBody *)v4(v2, 32, a2);
      }
    }
  }
  return this;
}

uint64_t re::PhysXRigidBody::setPoseInternal(uint64_t a1, float32x4_t *a2)
{
  _Q0 = a2[1];
  _Q1 = vmulq_f32(_Q0, _Q0);
  _S2 = a2[1].i64[1];
  __asm { FMLA            S1, S2, V0.S[2] }
  _S2 = _Q0.i32[3];
  __asm { FMLA            S1, S2, V0.S[3] }
  _Q1.f32[0] = sqrtf(_Q1.f32[0]);
  __int32 v11 = a2->i32[2];
  float32x4_t v17 = vdivq_f32(_Q0, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 0));
  uint64_t v18 = a2->i64[0];
  __int32 v19 = v11;
  (*(void (**)(float *__return_ptr))(**(void **)(*(void *)(a1 + 72) + 24) + 152))(v15);
  re::internal::nvphysx::fromPhysX((uint64_t)v15, v16);
  re::internal::nvphysx::fromPhysX((uint64_t)&v17, v15);
  uint64_t result = re::areAlmostEqual<float>(v15, v16);
  int v13 = result;
  int32x4_t v14 = *(_WORD **)(*(void *)(a1 + 72) + 24);
  if (v14
    && v14[4] == 5
    && (uint64_t result = (uint64_t)(*(void *(**)(float *__return_ptr, _WORD *))(*(void *)v14 + 432))(v15, v14),
        (LOBYTE(v15[0]) & 1) != 0))
  {
    if (!v13
      || (uint64_t result = (*(uint64_t (**)(_WORD *, float *))(*(void *)v14 + 504))(v14, v15),
          (result | v13 ^ 1) == 1))
    {
      uint64_t result = (*(uint64_t (**)(_WORD *, float32x4_t *))(*(void *)v14 + 496))(v14, &v17);
    }
    *(unsigned char *)(a1 + 44re::InputManager::notify(8, 0, 0, 0) = 1;
  }
  else if ((v13 & 1) == 0)
  {
    return (*(uint64_t (**)(void, float32x4_t *, uint64_t))(**(void **)(*(void *)(a1 + 72) + 24) + 160))(*(void *)(*(void *)(a1 + 72) + 24), &v17, 1);
  }
  return result;
}

void *re::PhysXRigidBody::pose@<X0>(re::PhysXRigidBody *this@<X0>, void *a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(**(void **)(*((void *)this + 9) + 24) + 152))(v4);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

void *re::PhysXRigidBody::poseCenterOfMass@<X0>(re::PhysXRigidBody *this@<X0>, void *a2@<X8>)
{
  worldSpaceCenterOfMassPose(v4, *(void *)(*((void *)this + 9) + 24));
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

float worldSpaceCenterOfMassPose(float *a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a2 + 152))(a2);
  if ((*(unsigned int (**)(uint64_t, const char *))(*(void *)a2 + 40))(a2, "PxRigidBody"))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a2 + 224))(&v17, a2);
    float v6 = a1[2];
    float v5 = a1[3];
    float v7 = (float)(v5 * v5) + -0.5;
    float v8 = a1[1];
    float v9 = (float)((float)((float)(v21 + v21) * v8) + (float)(*a1 * (float)(v20 + v20)))
       + (float)(v6 * (float)(v22 + v22));
    float v10 = (float)((float)(v5 * (float)((float)(*a1 * (float)(v21 + v21)) - (float)(v8 * (float)(v20 + v20))))
                + (float)((float)(v22 + v22) * v7))
        + (float)(v6 * v9);
    float v11 = a1[4]
        + (float)((float)((float)(v5 * (float)((float)(v8 * (float)(v22 + v22)) - (float)(v6 * (float)(v21 + v21))))
                        + (float)((float)(v20 + v20) * v7))
                + (float)(*a1 * v9));
    float v12 = a1[5]
        + (float)((float)((float)(v5 * (float)((float)(v6 * (float)(v20 + v20)) - (float)(*a1 * (float)(v22 + v22))))
                        + (float)((float)(v21 + v21) * v7))
                + (float)(v8 * v9));
    float v13 = (float)((float)((float)(v8 * v19) + (float)(v5 * *((float *)&v17 + 1))) + (float)(v6 * *(float *)&v17))
        - (float)(v18 * *a1);
    float v14 = (float)((float)((float)(v6 * v19) + (float)(v5 * v18)) + (float)(*a1 * *((float *)&v17 + 1)))
        - (float)(*(float *)&v17 * v8);
    float v15 = a1[6];
    float v16 = (float)((float)((float)(v5 * v19) - (float)(*a1 * *(float *)&v17)) - (float)(v8 * *((float *)&v17 + 1)))
        - (float)(v6 * v18);
    *a1 = (float)((float)((float)(*a1 * v19) + (float)(v5 * *(float *)&v17)) + (float)(v8 * v18))
        - (float)(*((float *)&v17 + 1) * v6);
    a1[1] = v13;
    a1[2] = v14;
    a1[3] = v16;
    float result = v15 + v10;
    a1[4] = v11;
    a1[5] = v12;
    a1[6] = result;
  }
  return result;
}

uint64_t re::PhysXRigidBody::linearVelocity(re::PhysXRigidBody *this)
{
  uint64_t v1 = *(_WORD **)(*((void *)this + 9) + 24);
  if (!v1 || v1[4] != 5) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr, void))(*(void *)v1 + 432))(&v5, *(void *)(*((void *)this + 9) + 24));
  if ((v5 & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, _WORD *))(*(void *)v1 + 312))(&v4, v1);
    return v4;
  }
  if (!*((unsigned char *)this + 440)) {
    return *((void *)this + 42);
  }
  else {
    return 0;
  }
}

float32x4_t *re::PhysXRigidBody::setLinearVelocity(float32x4_t *result, float32x4_t *a2)
{
  uint64_t v2 = *(_WORD **)(result[4].i64[1] + 24);
  if (v2 && v2[4] == 5)
  {
    uint64_t v4 = result;
    float result = (float32x4_t *)(*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v2 + 432))(&v10, *(void *)(result[4].i64[1] + 24));
    if (v10)
    {
      v4[21] = *a2;
      float32x4_t v7 = vmulq_f32(*a2, *a2);
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]) >= 0.00001)v4[27].i8[8] = 0; {
    }
      }
    else
    {
      float result = (float32x4_t *)(*(void *(**)(uint64_t *__return_ptr, _WORD *))(*(void *)v2 + 312))(&v8, v2);
      v5.i64[0] = v8;
      v5.i32[2] = v9;
      uint32x4_t v6 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*a2, v5));
      v6.i32[3] = v6.i32[2];
      if ((vmaxvq_u32(v6) & 0x80000000) != 0) {
        return (float32x4_t *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t))(*(void *)v2 + 320))(v2, a2, 1);
      }
    }
  }
  return result;
}

uint64_t re::PhysXRigidBody::angularVelocity(re::PhysXRigidBody *this)
{
  uint64_t v1 = *(_WORD **)(*((void *)this + 9) + 24);
  if (!v1 || v1[4] != 5) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr, void))(*(void *)v1 + 432))(&v5, *(void *)(*((void *)this + 9) + 24));
  if ((v5 & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, _WORD *))(*(void *)v1 + 328))(&v4, v1);
    return v4;
  }
  if (!*((unsigned char *)this + 440)) {
    return *((void *)this + 44);
  }
  else {
    return 0;
  }
}

float32x4_t *re::PhysXRigidBody::setAngularVelocity(float32x4_t *result, float32x4_t *a2)
{
  uint64_t v2 = *(_WORD **)(result[4].i64[1] + 24);
  if (v2 && v2[4] == 5)
  {
    uint64_t v4 = result;
    float result = (float32x4_t *)(*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v2 + 432))(&v10, *(void *)(result[4].i64[1] + 24));
    if (v10)
    {
      v4[22] = *a2;
      float32x4_t v7 = vmulq_f32(*a2, *a2);
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]) >= 0.00001)v4[27].i8[8] = 0; {
    }
      }
    else
    {
      float result = (float32x4_t *)(*(void *(**)(uint64_t *__return_ptr, _WORD *))(*(void *)v2 + 328))(&v8, v2);
      v5.i64[0] = v8;
      v5.i32[2] = v9;
      uint32x4_t v6 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*a2, v5));
      v6.i32[3] = v6.i32[2];
      if ((vmaxvq_u32(v6) & 0x80000000) != 0) {
        return (float32x4_t *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t))(*(void *)v2 + 336))(v2, a2, 1);
      }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyLinearImpulse(void *result, float32x4_t *a2)
{
  uint64_t v2 = *(_WORD **)(result[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v2 + 432))(&v5, *(void *)(result[9] + 24));
      if ((v5 & 1) == 0)
      {
        float32x4_t v4 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] >= 0.00000011921)return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(void *)v2 + 376))(v2, a2, 1, 1); {
      }
        }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyForce(void *result, float32x4_t *a2, int a3)
{
  BOOL v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v3 + 432))(&v8, *(void *)(result[9] + 24));
      if ((v8 & 1) == 0)
      {
        float32x4_t v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)
        {
          if ((a3 - 1) < 3) {
            uint64_t v7 = (a3 - 1) + 1;
          }
          else {
            uint64_t v7 = 0;
          }
          return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(void *)v3 + 376))(v3, a2, v7, 1);
        }
      }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyTorque(void *result, float32x4_t *a2, int a3)
{
  BOOL v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v3 + 432))(&v8, *(void *)(result[9] + 24));
      if ((v8 & 1) == 0)
      {
        float32x4_t v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)
        {
          if ((a3 - 1) < 3) {
            uint64_t v7 = (a3 - 1) + 1;
          }
          else {
            uint64_t v7 = 0;
          }
          return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(void *)v3 + 384))(v3, a2, v7, 1);
        }
      }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyAngularImpulse(void *result, float32x4_t *a2)
{
  uint64_t v2 = *(_WORD **)(result[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v2 + 432))(&v5, *(void *)(result[9] + 24));
      if ((v5 & 1) == 0)
      {
        float32x4_t v4 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] >= 0.00000011921)return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(void *)v2 + 384))(v2, a2, 1, 1); {
      }
        }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyImpulse(void *result, float32x4_t *a2, uint64_t a3)
{
  BOOL v3 = *(_WORD **)(result[9] + 24);
  if (v3 && v3[4] == 5)
  {
    float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v3 + 432))(&v6, *(void *)(result[9] + 24));
    if ((v6 & 1) == 0) {
      return (void *)addForce((uint64_t)v3, 1, a3, 1, *a2);
    }
  }
  return result;
}

uint64_t addForce(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t a5)
{
  float32x4_t v7 = vmulq_f32(a5, a5);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0] >= 0.00000011921)
  {
    uint64_t v29 = v5;
    uint64_t v30 = v6;
    uint64_t v11 = result;
    unint64_t v27 = a5.i64[0];
    unsigned __int32 v28 = a5.u32[2];
    worldSpaceCenterOfMassPose((float *)&v23, result);
    _S0 = *(float *)a3 - v25;
    _D1 = vsub_f32(*(float32x2_t *)(a3 + 4), v26);
    v14.i32[0] = vdup_lane_s32((int32x2_t)_D1, 1).u32[0];
    v14.f32[1] = _S0;
    _Q4 = (int8x16_t)a5;
    v16.i32[0] = vextq_s8(_Q4, _Q4, 8uLL).u32[0];
    v16.i32[1] = a5.i32[0];
    float32x2_t v17 = vmla_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(_Q4, _Q4, 4uLL), vneg_f32(v14)), v16, _D1);
    __asm { FMLA            S1, S0, V4.S[1] }
    float32x2_t v23 = v17;
    __int32 v24 = _D1.i32[0];
    (*(void (**)(uint64_t, float32x2_t *, uint64_t, uint64_t))(*(void *)v11 + 384))(v11, &v23, a2, a4);
    return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(void *)v11 + 376))(v11, &v27, a2, a4);
  }
  return result;
}

void *re::PhysXRigidBody::applyForce(void *result, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  float32x4_t v4 = *(_WORD **)(result[9] + 24);
  if (v4 && v4[4] == 5)
  {
    float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v4 + 432))(&v8, *(void *)(result[9] + 24));
    if ((v8 & 1) == 0) {
      return (void *)addForce((uint64_t)v4, 0, a3, a4, *a2);
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyForce(void *result, float32x4_t *a2, uint64_t a3)
{
  BOOL v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v3 + 432))(&v7, *(void *)(result[9] + 24));
      if ((v7 & 1) == 0)
      {
        float32x4_t v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, void, uint64_t))(*(void *)v3 + 376))(v3, a2, 0, a3); {
      }
        }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyTorque(void *result, float32x4_t *a2, uint64_t a3)
{
  BOOL v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      float result = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v3 + 432))(&v7, *(void *)(result[9] + 24));
      if ((v7 & 1) == 0)
      {
        float32x4_t v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)return (void *)(*(uint64_t (**)(_WORD *, float32x4_t *, void, uint64_t))(*(void *)v3 + 384))(v3, a2, 0, a3); {
      }
        }
    }
  }
  return result;
}

void *re::PhysXRigidBody::applyUserForces(float32x4_t *this)
{
  float32x4_t v3 = vaddq_f32(this[15], this[23]);
  re::PhysXRigidBody::applyForce(this, &v3, 1);
  float32x4_t v3 = vaddq_f32(this[16], this[24]);
  re::PhysXRigidBody::applyTorque(this, &v3, 1);
  float32x4_t v3 = vaddq_f32(this[17], this[25]);
  re::PhysXRigidBody::applyLinearImpulse(this, &v3);
  float32x4_t v3 = vaddq_f32(this[18], this[26]);
  return re::PhysXRigidBody::applyAngularImpulse(this, &v3);
}

uint64_t re::PhysXRigidBody::canSleep(re::PhysXRigidBody *this)
{
  return *((unsigned __int8 *)this + 320);
}

_WORD *re::PhysXRigidBody::setCanSleep(_WORD *this, int a2)
{
  if ((*((unsigned char *)this + 320) != 0) != a2)
  {
    *((unsigned char *)this + 32re::InputManager::notify(8, 0, 0, 0) = a2;
    if (a2)
    {
      return re::PhysXRigidBody::updateSleepThreshold((re::PhysXRigidBody *)this);
    }
    else
    {
      this = *(_WORD **)(*((void *)this + 9) + 24);
      if (this)
      {
        if (this[4] == 5) {
          return (_WORD *)(*(uint64_t (**)(double))(*(void *)this + 520))(0.0);
        }
      }
    }
  }
  return this;
}

uint64_t re::PhysXRigidBody::isSleeping(re::PhysXRigidBody *this)
{
  uint64_t v1 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v1
    && v1[4] == 5
    && ((*(void (**)(uint64_t *__return_ptr, void))(*(void *)v1 + 432))(&v3, *(void *)(*((void *)this + 9) + 24)), (v3 & 1) == 0))
  {
    return (*(uint64_t (**)(_WORD *))(*(void *)v1 + 512))(v1);
  }
  else
  {
    return 0;
  }
}

void *re::PhysXRigidBody::sleep(void *this)
{
  uint64_t v1 = *(_WORD **)(this[9] + 24);
  if (v1 && v1[4] == 5)
  {
    this = (*(void *(**)(uint64_t *__return_ptr, void))(*(void *)v1 + 432))(&v2, *(void *)(this[9] + 24));
    if ((v2 & 1) == 0) {
      return (void *)(*(uint64_t (**)(_WORD *))(*(void *)v1 + 600))(v1);
    }
  }
  return this;
}

double re::PhysXRigidBody::clearForces(re::PhysXRigidBody *this)
{
  uint64_t v2 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr, void))(*(void *)v2 + 432))(&v4, *(void *)(*((void *)this + 9) + 24));
      if ((v4 & 1) == 0)
      {
        (*(void (**)(_WORD *, void))(*(void *)v2 + 392))(v2, 0);
        (*(void (**)(_WORD *, void))(*(void *)v2 + 400))(v2, 0);
      }
    }
  }
  double result = 0.0;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  return result;
}

void re::PhysXRigidBody::onScaleChanged(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  re::GeometricObjectBase::scalePose((float32x4_t *)a1, a3, 1);
  re::MassFrame::makeScaledFrame(a1 + 80, a3, (uint64_t)&v12, v5);
  *(_DWORD *)(a1 + re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192) = v15;
  long long v6 = v14;
  long long v7 = v12;
  *(_OWORD *)(a1 + 16re::InputManager::notify(8, 0, 0, 0) = v13;
  *(_OWORD *)(a1 + 176) = v6;
  *(_OWORD *)(a1 + 144) = v7;
  uint64_t v8 = *(_WORD **)(*(void *)(a1 + 72) + 24);
  if (v8 && v8[4] == 5)
  {
    (*(void (**)(_WORD *))(*(void *)v8 + 232))(v8);
    (*(void (**)(_WORD *, long long *))(*(void *)v8 + 256))(v8, &v14);
    long long v9 = v13;
    uint64_t v10 = v12;
    int v11 = DWORD2(v12);
    (*(void (**)(_WORD *, long long *))(*(void *)v8 + 216))(v8, &v9);
    if ((*(uint64_t (**)(_WORD *))(*(void *)v8 + 56))(v8)) {
      (*(void (**)(_WORD *))(*(void *)v8 + 592))(v8);
    }
  }
}

float32x4_t *re::PhysXRigidBody::updateKinematicTargetFromVelocity(float32x4_t *this, float a2)
{
  uint64_t v2 = *(void *)(this[4].i64[1] + 24);
  if (v2)
  {
    uint64_t v3 = this;
    uint64_t v4 = *(_WORD *)(v2 + 8) == 5 ? *(void *)(this[4].i64[1] + 24) : 0;
    if (!this[27].i8[8] && v4 != 0)
    {
      this = (float32x4_t *)(*(void *(**)(int32x4_t *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v41, v4);
      if (v41.i8[0])
      {
        if ((*(unsigned int (**)(uint64_t, int32x4_t *))(*(void *)v4 + 504))(v4, &v41))
        {
          float32x2_t v6 = v42;
          float v7 = v43;
        }
        else
        {
          (*(void (**)(int32x4_t *__return_ptr, uint64_t))(*(void *)v4 + 152))(&v38, v4);
          int32x4_t v41 = v38;
          float32x2_t v6 = v39;
          float v7 = v40;
        }
        float v8 = a2;
        float32x4_t v9 = v3[22];
        float32x4_t v10 = vmulq_n_f32(v3[21], a2);
        float32x2_t v42 = vadd_f32(v6, *(float32x2_t *)v10.f32);
        float v11 = v7 + v10.f32[2];
        float32x4_t v12 = vmulq_f32(v9, v9);
        float v43 = v11;
        float v13 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
        double v14 = a2;
        if ((float)(v13 * a2) > 0.785398163) {
          float v13 = 0.785398163 / v14;
        }
        if (v13 >= 0.001)
        {
          float v16 = v13 * 0.5 * v14;
          float32x4_t v35 = v9;
          float v17 = sinf(v16);
          float32x4_t v9 = v35;
          float v8 = a2;
          float v15 = v17 / v13;
        }
        else
        {
          float v15 = (float)((float)(a2 * a2) * a2) * -0.0208333333 * v13 * v13 + v14 * 0.5;
        }
        int8x16_t v37 = (int8x16_t)vmulq_n_f32(v9, v15);
        float v18 = cosf((float)(v13 * v8) * 0.5);
        float32x4_t v19 = (float32x4_t)v37;
        int8x16_t v20 = v37;
        v19.i32[3] = v37.i32[2];
        float32x4_t v21 = (float32x4_t)vzip1q_s32(v41, v41);
        v21.i32[0] = v41.i32[2];
        int8x16_t v22 = vextq_s8((int8x16_t)v19, (int8x16_t)v21, 0xCuLL);
        v19.f32[3] = -*(float *)v37.i32;
        float32x4_t v23 = vmlaq_n_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vdupq_laneq_s32(v41, 3), (int8x16_t)v41, 4uLL), v19), (float32x4_t)v41, v18);
        float32x4_t v24 = (float32x4_t)vextq_s8(vextq_s8(v20, v20, 0xCuLL), v37, 8uLL);
        v24.f32[3] = -*(float *)&v37.i32[1];
        float32x4_t v25 = vmlaq_f32(v23, v21, v24);
        int8x16_t v26 = vextq_s8(v22, (int8x16_t)vrev64q_s32((int32x4_t)v22), 8uLL);
        float32x4_t v27 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v37, 0xCuLL);
        v27.i32[3] = v41.i32[2];
        _Q1 = vmlsq_f32(v25, v27, (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v26, (int32x4_t)vextq_s8(v26, v26, 0xCuLL)), (int32x4_t)v26));
        _Q0 = vmulq_f32(_Q1, _Q1);
        _S2 = _Q1.i32[2];
        __asm { FMLA            S0, S2, V1.S[2] }
        _S2 = _Q1.i32[3];
        __asm { FMLA            S0, S2, V1.S[3] }
        _Q0.f32[0] = sqrtf(_Q0.f32[0]);
        if (_Q0.f32[0] != 0.0) {
          _Q1 = vdivq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 0));
        }
        int32x4_t v41 = (int32x4_t)_Q1;
        return (float32x4_t *)(*(uint64_t (**)(uint64_t, int32x4_t *))(*(void *)v4 + 496))(v4, &v41);
      }
    }
  }
  return this;
}

float re::PhysXRigidBody::linearDamping(re::PhysXRigidBody *this)
{
  return *((float *)this + 81);
}

float re::PhysXRigidBody::angularDamping(re::PhysXRigidBody *this)
{
  return *((float *)this + 82);
}

void re::PhysXRigidBody::setDamping(re::PhysXRigidBody *this, float a2, float a3)
{
  *((float *)this + 81) = a2;
  *((float *)this + 82) = a3;
  uint64_t v3 = *(_WORD **)(*((void *)this + 9) + 24);
  if (v3 && v3[4] == 5)
  {
    if ((*(float (**)(void))(*(void *)v3 + 288))(*(void *)(*((void *)this + 9) + 24)) != a2)
    {
      v7.n128_u64[0] = 0;
      if (a2 >= 0.0) {
        v7.n128_f32[0] = a2;
      }
      (*(void (**)(_WORD *, __n128))(*(void *)v3 + 280))(v3, v7);
      re::PhysXRigidBody::updateSleepThreshold(this);
    }
    float v8 = a3 * 5.0;
    if (v8 != (*(float (**)(_WORD *))(*(void *)v3 + 304))(v3))
    {
      v9.n128_u64[0] = 0;
      if (v8 >= 0.0) {
        v9.n128_f32[0] = v8;
      }
      (*(void (**)(_WORD *, __n128))(*(void *)v3 + 296))(v3, v9);
      re::PhysXRigidBody::updateSleepThreshold(this);
    }
  }
}

uint64_t re::PhysXRigidBody::material(re::PhysXRigidBody *this, uint64_t a2)
{
  uint64_t v3 = *(void *)(*((void *)this + 9) + 24);
  uint64_t v6 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)v3 + 192))(v3, &v6, 1, 0);
  uint64_t result = v6;
  if (v6)
  {
    uint64_t v5 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v6 + 216))(v6, &v5, 1, a2);
    if (v5) {
      return *(void *)(v5 + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t re::PhysXRigidBody::materialCount(re::PhysXRigidBody *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 9) + 24);
  uint64_t v3 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)v1 + 192))(v1, &v3, 1, 0);
  uint64_t result = v3;
  if (v3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 208))(v3);
  }
  return result;
}

BOOL re::PhysXRigidBody::shouldRemoveFromWorld(uint64_t a1, int a2, int a3)
{
  return !a2 || a3 == 0;
}

void *re::PhysXRigidBody::setGravityEnabled(re::PhysXRigidBody *this, int a2)
{
  uint64_t v4 = *(void *)(*((void *)this + 9) + 24);
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr, uint64_t))(*(void *)v4 + 104))(&v7, v4);
  if (((v7 & 2) == 0) != a2)
  {
    uint64_t v6 = a2 ^ 1u;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 88))(v4, 2, v6);
    if ((v6 & 1) == 0) {
      return re::PhysXRigidBody::wakeUp(this);
    }
  }
  return result;
}

BOOL re::PhysXRigidBody::gravityEnabled(re::PhysXRigidBody *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*((void *)this + 9) + 24) + 104))(&var1);
  return (var1 & 2) == 0;
}

void re::PhysXRigidBody::poseDidChange(re::PhysXRigidBody *this, uint64_t a2)
{
}

uint64_t re::RigidBody::type(re::RigidBody *this)
{
  return 2;
}

re::PhysXHingeJoint *re::PhysXHingeJoint::PhysXHingeJoint(re::PhysXHingeJoint *this, physx::PxRevoluteJoint *a2, uint64_t a3)
{
  *(void *)this = &unk_26E716870;
  double v6 = re::HingeJoint::HingeJoint(this, (uint64_t)this + 64);
  void *v7 = &unk_26E716870;
  unsigned char v7[8] = &unk_26E717308;
  v7[9] = a2;
  *((void *)a2 + 2) = v7;
  (*(void (**)(physx::PxRevoluteJoint *, uint64_t, uint64_t, double))(*(void *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 128))(*((void *)this + 9), 8, a3);
  return this;
}

uint64_t re::PhysXHingeJoint::updateLimits(re::PhysXHingeJoint *this)
{
  uint64_t v2 = *((void *)this + 9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v2 + 328))(v2, 1, *((float *)this + 14) <= *((float *)this + 15));
  float v5 = *((float *)this + 14);
  float v4 = *((float *)this + 15);
  if (v5 <= v4)
  {
    int v9 = *((_DWORD *)this + 15);
    float v10 = v5;
    float v6 = (float)(v4 - v5) * 0.49;
    if (v6 > 0.1) {
      float v6 = 0.1;
    }
    v7[0] = 0x3F00000000000000;
    v7[1] = 0;
    float v8 = v6;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 256))(v2, v7);
  }
  return result;
}

void re::PhysXHingeJoint::~PhysXHingeJoint(re::PhysXHingeJoint *this)
{
  *(void *)this = &unk_26E716870;
  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXHingeJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  *(void *)this = &unk_26E716870;
  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXHingeJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysXPhysicsMaterial::PhysXPhysicsMaterial(uint64_t a1, void *a2)
{
  float v4 = (*(float (**)(void *))(*a2 + 104))(a2);
  float v5 = (*(float (**)(void *))(*a2 + 88))(a2);
  float v6 = (*(float (**)(void *))(*a2 + 72))(a2);
  *(float *)(a1 + 8) = v4;
  *(float *)(a1 + 12) = v5;
  *(float *)(a1 + 16) = v6;
  *(void *)a1 = &unk_26E7168D8;
  *(void *)(a1 + 24) = a2;
  a2[2] = a1;
  return a1;
}

void re::PhysXPhysicsMaterial::~PhysXPhysicsMaterial(re::PhysXPhysicsMaterial *this)
{
}

{
  uint64_t vars8;

  (***((void (****)(void))this + 3))(*((void *)this + 3));
  JUMPOUT(0x237DBCBD0);
}

double re::Explosion::didAddToSimulation(re::Explosion *this)
{
  double result = *(double *)(*((void *)this + 1) + 24) + *((float *)this + 13);
  *((double *)this + 8) = result;
  return result;
}

float32x4_t *re::Explosion::onApply(float32x4_t *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this->i64[1];
  if (*(double *)this[4].i64 <= *(double *)(v2 + 24))
  {
    return (float32x4_t *)re::ForceEffectCollection::remove((re::ForceEffectCollection *)(v2 + 248), (re::ForceEffect *)this);
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 104);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = v2 + 80;
      do
      {
        uint64_t v6 = re::ecs2::ComponentTypeRegistry::operator[](v5, v4);
        this = (float32x4_t *)(*(void *(**)(float32x4_t *__return_ptr))(*(void *)v6 + 208))(v14);
        float32x4_t v7 = vsubq_f32(v14[0], v1[2]);
        float32x4_t v8 = vmulq_f32(v7, v7);
        float v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
        float v10 = v1[3].f32[0] * v1[3].f32[0];
        if (v9 <= v10)
        {
          float32x4_t v11 = (float32x4_t)xmmword_23435FD60;
          if (fabsf(v9) >= 1.0e-10)
          {
            float32x2_t v12 = vrsqrte_f32((float32x2_t)LODWORD(v9));
            float32x2_t v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v12, v12)));
            float32x4_t v11 = vmulq_n_f32(v7, vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v13, v13))).f32[0]);
          }
          v14[0] = vmulq_n_f32(v11, (float)(1.0 - (float)(v9 / v10)) * v1[3].f32[2]);
          this = (float32x4_t *)(*(uint64_t (**)(uint64_t, float32x4_t *, void))(*(void *)v6 + 384))(v6, v14, 0);
        }
        ++v4;
      }
      while (v3 != v4);
    }
  }
  return this;
}

void re::Explosion::~Explosion(re::Explosion *this)
{
}

uint64_t re::Explosion::type(re::Explosion *this)
{
  return 3;
}

BOOL re::ForceEffectCollection::remove(re::ForceEffectCollection *this, re::ForceEffect *a2)
{
  uint64_t v5 = a2;
  if (*((void *)a2 + 1))
  {
    (*(void (**)(re::ForceEffect *))(*(void *)a2 + 48))(a2);
    *((void *)a2 + 1) = 0;
  }
  return re::DynamicArray<unsigned long long>::remove((uint64_t)this + 8, &v5);
}

BOOL re::MassFrame::operator==(float32x4_t *a1, float32x4_t *a2)
{
  uint32x4_t v2 = (uint32x4_t)vceqq_f32(*a1, *a2);
  v2.i32[3] = v2.i32[2];
  if ((vminvq_u32(v2) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vceqq_f32(a1[1], a2[1])) & 0x80000000) != 0
    && (uint32x4_t v3 = (uint32x4_t)vceqq_f32(a1[2], a2[2]), v3.i32[3] = v3.i32[2], (vminvq_u32(v3) & 0x80000000) != 0))
  {
    return a1[3].f32[0] == a2[3].f32[0];
  }
  else
  {
    return 0;
  }
}

unint64_t re::MassFrame::makeFromShapeAndDensity@<X0>(re::MassFrame *this@<X0>, const re::CollisionShape *a2@<X1>, float a3@<S0>, float32x4_t *a4@<X8>)
{
  unint64_t result = (*(uint64_t (**)(re::MassFrame *, const re::CollisionShape *))(*(void *)this + 56))(this, a2);
  if (result)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    a4[1].i64[0] = 0;
    a4[1].i64[1] = 0x3F80000000000000;
    float v9 = 0.0;
    float32x4_t v10 = 0uLL;
  }
  else
  {
    float v19 = 0.0;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    (*(void (**)(re::MassFrame *, float *, long long *, long long *))(*(void *)this + 32))(this, &v19, &v18, &v15);
    float v11 = v19;
    int v20 = v15;
    *(void *)&long long v12 = *(void *)((char *)&v15 + 4);
    *((void *)&v12 + 1) = v16;
    long long v21 = v12;
    int v22 = DWORD2(v16);
    uint64_t v23 = v17;
    int v24 = DWORD2(v17);
    unint64_t result = physx::PxDiagonalize((float *)&v20, a4[1].f32, (float *)&v25);
    float v9 = v11 * a3;
    v13.i64[0] = v25;
    v13.i32[2] = v26;
    float32x4_t v10 = vmulq_n_f32(v13, a3);
    uint64_t v8 = *((void *)&v18 + 1);
    uint64_t v7 = v18;
  }
  a4->i64[0] = v7;
  a4->i64[1] = v8;
  a4[2] = v10;
  a4[3].f32[0] = v9;
  return result;
}

unint64_t re::MassFrame::makeFromShapeAndMass@<X0>(re::MassFrame *this@<X0>, const re::CollisionShape *a2@<X1>, float a3@<S0>, float32x4_t *a4@<X8>)
{
  unint64_t result = (*(uint64_t (**)(re::MassFrame *, const re::CollisionShape *))(*(void *)this + 56))(this, a2);
  if (result)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    a4[1].i64[0] = 0;
    a4[1].i64[1] = 0x3F80000000000000;
    float v10 = 0.0;
    float32x4_t v11 = 0uLL;
  }
  else
  {
    float v20 = 0.0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    (*(void (**)(re::MassFrame *, float *, long long *, long long *))(*(void *)this + 32))(this, &v20, &v19, &v16);
    float v12 = v20;
    float v15 = a3 / v20;
    int v21 = v16;
    *(void *)&long long v13 = *(void *)((char *)&v16 + 4);
    *((void *)&v13 + 1) = v17;
    long long v22 = v13;
    int v23 = DWORD2(v17);
    uint64_t v24 = v18;
    int v25 = DWORD2(v18);
    unint64_t result = physx::PxDiagonalize((float *)&v21, a4[1].f32, (float *)&v26);
    float v10 = v12 * v15;
    v14.i64[0] = v26;
    v14.i32[2] = v27;
    float32x4_t v11 = vmulq_n_f32(v14, v15);
    uint64_t v9 = *((void *)&v19 + 1);
    uint64_t v8 = v19;
  }
  a4->i64[0] = v8;
  a4->i64[1] = v9;
  a4[2] = v11;
  a4[3].f32[0] = v10;
  return result;
}

float32x4_t re::MassFrame::makeScaledFrame@<Q0>(uint64_t a1@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  float v4 = (float)(a2->f32[0] * a2->f32[1]) * a2->f32[2];
  float32x4_t v5 = *(float32x4_t *)(a1 + 32);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  float32x4_t v7 = vmulq_f32(v5, v6);
  float32x4_t v11 = vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1));
  float32x4_t v8 = vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), v11), 0), v5);
  float32x4_t v9 = *a2;
  int32x4_t v10 = (int32x4_t)vmulq_n_f32(vmulq_f32(*a2, vmulq_f32(*a2, v8)), v4);
  *(float32x2_t *)v11.f32 = vadd_f32((float32x2_t)vdup_laneq_s32(v10, 2), (float32x2_t)vrev64_s32(*(int32x2_t *)v10.i8));
  float v12 = vaddv_f32(*(float32x2_t *)v10.i8);
  *(float *)&a4 = v4 * *(float *)(a1 + 48);
  float v13 = 5000.0;
  if (*(float *)&a4 <= 5000.0) {
    float v13 = *(float *)&a4;
  }
  if (v13 < 0.0002) {
    float v13 = 0.0002;
  }
  if (*(float *)&a4 <= 0.0) {
    float v13 = 0.0;
  }
  *(float *)(a3 + 48) = v13;
  v11.f32[2] = v12;
  float32x4_t v14 = vdivq_f32(vmulq_n_f32(v11, v13), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0));
  long long v15 = *(_OWORD *)(a1 + 16);
  float32x4_t result = vmulq_f32(v9, *(float32x4_t *)a1);
  *(float32x4_t *)a3 = result;
  *(_OWORD *)(a3 + 16) = v15;
  *(float32x4_t *)(a3 + 32) = v14;
  return result;
}

void *re::allocInfo_MassFrame(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF990B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF990B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF990D0, "MassFrame");
    __cxa_guard_release(&qword_26AF990B0);
  }
  return &unk_26AF990D0;
}

void re::initInfo_MassFrame(re *this, re::IntrospectionBase *a2)
{
  v16[0] = 0x7C8101421572;
  v16[1] = "MassFrame";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)this + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_425, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&_MergedGlobals_425);
    if (v4)
    {
      float32x4_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_PoseF((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "m_pose";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF990B8 = v7;
      float32x4_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v9 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "m_inertia";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x2000000002;
      *(_DWORD *)(v10 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF990C0 = v10;
      float32x4_t v11 = re::introspectionAllocator((re *)v10);
      float v13 = re::introspect_float((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "m_mass";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x3000000003;
      *(_DWORD *)(v14 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF990C8 = v14;
      __cxa_guard_release(&_MergedGlobals_425);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF990B8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::MassFrame>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::MassFrame>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::MassFrame>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::MassFrame>;
  re::IntrospectionRegistry::add(this, v3);
  long long v15 = v17;
}

int32x4_t re::internal::defaultConstruct<re::MassFrame>(uint64_t a1, uint64_t a2, int32x4_t *a3)
{
  a3->i64[0] = 0;
  a3->i64[1] = 0;
  a3[1].i64[0] = 0;
  a3[1].i64[1] = 0x3F80000000000000;
  int32x4_t result = vdupq_n_s32(0x3DCCCCCDu);
  a3[2] = result;
  a3[3].i32[0] = 1065353216;
  return result;
}

int32x4_t re::internal::defaultConstructV2<re::MassFrame>(int32x4_t *a1)
{
  a1->i64[0] = 0;
  a1->i64[1] = 0;
  a1[1].i64[0] = 0;
  a1[1].i64[1] = 0x3F80000000000000;
  int32x4_t result = vdupq_n_s32(0x3DCCCCCDu);
  a1[2] = result;
  a1[3].i32[0] = 1065353216;
  return result;
}

uint64_t re::introspect_MassFrame(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"MassFrame", (uint64_t (*)(re::internal *))re::allocInfo_MassFrame, (re::IntrospectionBase *(*)(void))re::initInfo_MassFrame, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::MassFrame>, this);
}

uint64_t re::RigidBodyCollection::add(re::RigidBodyCollection *this, re::RigidBody *a2)
{
  float v4 = a2;
  re::DynamicArray<re::TransitionCondition *>::add((void *)this + 1, &v4);
  (*(void (**)(re::RigidBody *, uint64_t))(*(void *)v4 + 96))(v4, *(void *)this + 128);
  uint64_t result = (*(uint64_t (**)(void, re::RigidBody *))(**(void **)this + 120))(*(void *)this, v4);
  *(unsigned char *)(*(void *)this + 24re::InputManager::notify(8, 0, 0, 0) = 1;
  return result;
}

uint64_t re::RigidBodyCollection::remove(re::RigidBody ***this, re::RigidBody *a2)
{
  uint64_t v4 = *((void *)a2 + 9);
  if (((*(uint64_t (**)(re::RigidBody *))(*(void *)a2 + 296))(a2) & 1) != 0 || *((_DWORD *)a2 + 52) != 2)
  {
    for (uint64_t i = *(uint64_t **)(v4 + 80); i; uint64_t i = (uint64_t *)i[v10])
    {
      uint64_t v6 = *i;
      if (*i == v4) {
        uint64_t v6 = i[1];
      }
      uint64_t v7 = *(re::RigidBody **)(v6 + 16);
      int v8 = (*(uint64_t (**)(re::RigidBody *))(*(void *)v7 + 56))(v7);
      BOOL v9 = v7 != a2 && v8 == 2;
      if (v9
        && (*(unsigned int (**)(re::RigidBody *))(*(void *)v7 + 296))(v7)
        && *((_DWORD *)v7 + 52) == 2)
      {
        (*(void (**)(re::RigidBody *))(*(void *)v7 + 312))(v7);
      }
      if (*i == v4) {
        uint64_t v10 = 14;
      }
      else {
        uint64_t v10 = 15;
      }
    }
  }
  uint64_t result = (*((uint64_t (**)(re::RigidBody **, re::RigidBody *))**this + 16))(*this, a2);
  float v12 = this[5];
  unint64_t v13 = (unint64_t)this[3];
  uint64_t v14 = v12;
  if (v13)
  {
    uint64_t v15 = 8 * v13;
    uint64_t v14 = this[5];
    while (*v14 != a2)
    {
      ++v14;
      v15 -= 8;
      if (!v15)
      {
        uint64_t v14 = &v12[v13];
        break;
      }
    }
  }
  unint64_t v16 = v14 - v12;
  if (v16 != v13)
  {
    if (v13 <= v16)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v13 - 1 > v16) {
      v12[v16] = v12[v13 - 1];
    }
    this[3] = (re::RigidBody **)(v13 - 1);
    ++*((_DWORD *)this + 8);
  }
  *((unsigned char *)*this + 24re::InputManager::notify(8, 0, 0, 0) = 1;
  return result;
}

uint64_t re::RigidBodyCollection::setSolverIterations(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result + 48;
  if (*(_DWORD *)(result + 48) != *(_DWORD *)a2 || *(_DWORD *)(result + 52) != *(_DWORD *)(a2 + 4))
  {
    *(void *)(result + 48) = *(void *)a2;
    uint64_t v3 = *(void *)(result + 24);
    if (v3)
    {
      uint64_t v4 = *(uint64_t **)(result + 40);
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *v4++;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 96))(v6, v2);
        v5 -= 8;
      }
      while (v5);
    }
  }
  return result;
}

void *re::PhysXPhysicsFactory::PhysXPhysicsFactory(void *a1, uint64_t a2, __n128 a3, __n128 a4)
{
  *a1 = &unk_26E716988;
  a1[1] = a2;
  uint64_t v5 = (uint64_t)(a1 + 2);
  a3.n128_u32[0] = 1036831949;
  a4.n128_u32[0] = 0.5;
  PhysicsMaterial = (void *)re::PhysXPhysicsFactory::createPhysicsMaterial(*(void *)(a2 + 16), a3, a4, 0.5);
  re::PhysXPhysicsMaterial::PhysXPhysicsMaterial(v5, PhysicsMaterial);
  return a1;
}

uint64_t re::PhysXPhysicsFactory::createPhysicsMaterial(uint64_t a1, __n128 a2, __n128 a3, float a4)
{
  float v4 = 1.0;
  if (a2.n128_f32[0] <= 1.0) {
    float v4 = a2.n128_f32[0];
  }
  if (a2.n128_f32[0] < 0.0) {
    float v4 = 0.0;
  }
  if (a3.n128_f32[0] >= 0.0) {
    a2.n128_f32[0] = a3.n128_f32[0];
  }
  else {
    a2.n128_f32[0] = 0.0;
  }
  if (a4 >= 0.0) {
    a3.n128_f32[0] = a4;
  }
  else {
    a3.n128_f32[0] = 0.0;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t, __n128, __n128, float))(*(void *)a1 + 240))(a1, a2, a3, v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 112))(v5, 4, 1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 136))(v5, 2);
  return v5;
}

void re::PhysXPhysicsFactory::~PhysXPhysicsFactory(re::PhysXPhysicsFactory *this)
{
  *(void *)this = &unk_26E716988;
  (***((void (****)(void))this + 5))(*((void *)this + 5));
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E716988;
  (***((void (****)(void))this + 5))(*((void *)this + 5));
  JUMPOUT(0x237DBCBD0);
}

double re::PhysXPhysicsFactory::createPhysicsSimulation(re::PhysXPhysicsFactory *this, re::Allocator *a2)
{
  uint64_t v2 = (re::PhysicsSimulation *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 984, 8);
  uint64_t v3 = re::PhysicsSimulation::PhysicsSimulation(v2);
  *(void *)uint64_t v3 = &unk_26E717580;
  double result = 0.0;
  *((_OWORD *)v3 + 59) = 0u;
  return result;
}

uint64_t re::PhysXPhysicsFactory::createPhysicsMaterial(re::PhysXPhysicsFactory *this, re::Allocator *a2, __n128 a3, __n128 a4, float a5)
{
  if (a5 < 0.0) {
    a5 = a4.n128_f32[0];
  }
  PhysicsMaterial = (void *)re::PhysXPhysicsFactory::createPhysicsMaterial(*(void *)(*((void *)this + 1) + 16), a3, a4, a5);
  uint64_t v7 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32, 8);
  return re::PhysXPhysicsMaterial::PhysXPhysicsMaterial(v7, PhysicsMaterial);
}

uint64_t re::PhysXPhysicsFactory::defaultMaterial(re::PhysXPhysicsFactory *this)
{
  return (uint64_t)this + 16;
}

uint64_t re::PhysXPhysicsFactory::createUnderlyingRigidBody(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 16);
  if (a5)
  {
    long long v16 = xmmword_23435FBB0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v6 + 176))(v6, &v16);
    (*(void (**)(void))(*(void *)v8 + 256))();
    (*(void (**)(uint64_t, float))(*(void *)v8 + 232))(v8, *((float *)a4 + 12));
    long long v16 = *((_OWORD *)a4 + 1);
    uint64_t v17 = *a4;
    int v18 = *((_DWORD *)a4 + 2);
    (*(void (**)(uint64_t, long long *))(*(void *)v8 + 216))(v8, &v16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 608))(v8, 6, 1);
  }
  else
  {
    long long v16 = xmmword_23435FBB0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v6 + 168))(v6, &v16);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 184))(a3);
  MEMORY[0x270FA5388](v9);
  float v12 = (void (****)(void))((char *)&v16 - v11);
  if (v10 >= 0x200) {
    size_t v13 = 512;
  }
  else {
    size_t v13 = v10;
  }
  bzero((char *)&v16 - v11, v13);
  (*(void (**)(uint64_t, void (****)(void), uint64_t, void))(*(void *)a3 + 192))(a3, v12, v9, 0);
  if (v9)
  {
    uint64_t v9 = v9;
    do
    {
      (**v12)[7]();
      (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)a3 + 176))(a3, *v12, 1);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v8 + 168))(v8, *v12);
      uint64_t v14 = *v12++;
      (**v14)();
      --v9;
    }
    while (v9);
  }
  return v8;
}

uint64_t re::PhysXPhysicsFactory::createRigidBody(re::CollisionFactory **this, re::Allocator *a2, const re::CollisionShape *a3, const re::MassFrame *a4, const re::PhysicsMaterial *const *a5, uint64_t a6)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v11 = re::CollisionFactory::deepCopyShape(this[1], a2, a3);
  uint64_t v12 = *((void *)this[1] + 2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 56))(v11)
    || (float v13 = fabsf(*((float *)a4 + 12)), v13 == INFINITY)
    || v13 < 0.00001)
  {
    long long v27 = xmmword_23435FBB0;
    uint64_t v28 = 0;
    int v29 = 0;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v12 + 168))(v12, &v27);
  }
  else
  {
    long long v27 = xmmword_23435FBB0;
    uint64_t v28 = 0;
    int v29 = 0;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v12 + 176))(v12, &v27);
    (*(void (**)(void))(*(void *)v14 + 256))();
    (*(void (**)(uint64_t, float))(*(void *)v14 + 232))(v14, *((float *)a4 + 12));
    long long v27 = *((_OWORD *)a4 + 1);
    uint64_t v28 = *(void *)a4;
    int v29 = *((_DWORD *)a4 + 2);
    (*(void (**)(uint64_t, long long *))(*(void *)v14 + 216))(v14, &v27);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 608))(v14, 6, 1);
  }
  int v15 = 2 * ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 48))(v14) == 1);
  uint64_t v16 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 448, 16);
  re::PhysXRigidBody::PhysXRigidBody(v16, (uint64_t)a2, v11, a4, v15);
  MEMORY[0x270FA5388](v17);
  float v20 = (char *)&v27 - v19;
  if (v18 >= 0x200) {
    size_t v21 = 512;
  }
  else {
    size_t v21 = v18;
  }
  bzero((char *)&v27 - v19, v21);
  if (a6)
  {
    uint64_t v22 = a6;
    int v23 = v20;
    do
    {
      uint64_t v24 = (uint64_t)*a5++;
      *(void *)int v23 = *(void *)(v24 + 24);
      v23 += 8;
      --v22;
    }
    while (v22);
  }
  uint64_t v25 = (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, uint64_t, uint64_t, char *, uint64_t))(*(void *)this[1] + 184))(this[1], a2, v16, v14, v20, a6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 360))(v16, v25);
  return v16;
}

re::PhysXHingeJoint *re::PhysXPhysicsFactory::createHingeJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v9 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v18 = a4[1];
  uint64_t v19 = a4->i64[0];
  __int32 v20 = a4->i32[2];
  float32x4_t v15 = a6[1];
  uint64_t v16 = a6->i64[0];
  __int32 v17 = a6->i32[2];
  uint64_t v12 = (physx::PxRevoluteJoint *)physx::PxRevoluteJointCreate(v11, v9, &v18, v10, &v15);
  float v13 = (re::PhysXHingeJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 80, 8);
  return re::PhysXHingeJoint::PhysXHingeJoint(v13, v12, a7);
}

re::PhysXFixedJoint *re::PhysXPhysicsFactory::createFixedJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v9 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v18 = a4[1];
  uint64_t v19 = a4->i64[0];
  __int32 v20 = a4->i32[2];
  float32x4_t v15 = a6[1];
  uint64_t v16 = a6->i64[0];
  __int32 v17 = a6->i32[2];
  uint64_t v12 = (physx::PxFixedJoint *)physx::PxFixedJointCreate(v11, v9, &v18, v10, &v15);
  float v13 = (re::PhysXFixedJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
  return re::PhysXFixedJoint::PhysXFixedJoint(v13, v12, a7);
}

uint64_t re::PhysXPhysicsFactory::createSliderJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v10 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v11 = 0;
    goto LABEL_6;
  }
  uint64_t v10 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v11 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v12 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v20 = a4[1];
  uint64_t v21 = a4->i64[0];
  __int32 v22 = a4->i32[2];
  float32x4_t v17 = a6[1];
  uint64_t v18 = a6->i64[0];
  __int32 v19 = a6->i32[2];
  float v13 = physx::PxPrismaticJointCreate(v12, v10, &v20, v11, &v17);
  uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 16) + 40))(*(void *)(*(void *)(a1 + 8) + 16));
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 88, 8);
  return re::PhysXSliderJoint::PhysXSliderJoint(v15, v13, v14, a7);
}

int32x2_t *re::PhysXPhysicsFactory::createBallSocketJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v9 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v18 = a4[1];
  uint64_t v19 = a4->i64[0];
  __int32 v20 = a4->i32[2];
  float32x4_t v15 = a6[1];
  uint64_t v16 = a6->i64[0];
  __int32 v17 = a6->i32[2];
  uint64_t v12 = (physx::PxSphericalJoint *)physx::PxSphericalJointCreate(v11, v9, &v18, v10, &v15);
  float v13 = (int32x2_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 80, 8);
  return re::PhysXBallSocketJoint::PhysXBallSocketJoint(v13, v12, a7);
}

re::PhysXDistanceJoint *re::PhysXPhysicsFactory::createDistanceJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v9 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v18 = a4[1];
  uint64_t v19 = a4->i64[0];
  __int32 v20 = a4->i32[2];
  float32x4_t v15 = a6[1];
  uint64_t v16 = a6->i64[0];
  __int32 v17 = a6->i32[2];
  uint64_t v12 = (physx::PxDistanceJoint *)physx::PxDistanceJointCreate(v11, v9, &v18, v10, &v15);
  float v13 = (re::PhysXDistanceJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 88, 8);
  return re::PhysXDistanceJoint::PhysXDistanceJoint(v13, v12, a7);
}

uint64_t re::PhysXPhysicsFactory::createGeneric6DOFConstraint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v10 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v11 = 0;
    goto LABEL_6;
  }
  uint64_t v10 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v11 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v12 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v20 = a4[1];
  uint64_t v21 = a4->i64[0];
  __int32 v22 = a4->i32[2];
  float32x4_t v17 = a6[1];
  uint64_t v18 = a6->i64[0];
  __int32 v19 = a6->i32[2];
  float v13 = physx::PxD6JointCreate(v12, v10, &v20, v11, &v17);
  uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 16) + 40))(*(void *)(*(void *)(a1 + 8) + 16));
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 368, 8);
  return re::PhysXGeneric6DOFConstraint::PhysXGeneric6DOFConstraint(v15, v13, v14, a7);
}

re::PhysXTwistSwingJoint *re::PhysXPhysicsFactory::createTwistSwingJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  if (!a3)
  {
    uint64_t v9 = 0;
    if (a5) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(*(void *)(a3 + 72) + 24);
  if (!a5) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void *)(*(void *)(a5 + 72) + 24);
LABEL_6:
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 16);
  float32x4_t v18 = a4[1];
  uint64_t v19 = a4->i64[0];
  __int32 v20 = a4->i32[2];
  float32x4_t v15 = a6[1];
  uint64_t v16 = a6->i64[0];
  __int32 v17 = a6->i32[2];
  uint64_t v12 = (physx::PxD6Joint *)physx::PxD6JointCreate(v11, v9, &v18, v10, &v15);
  float v13 = (re::PhysXTwistSwingJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 120, 8);
  return re::PhysXTwistSwingJoint::PhysXTwistSwingJoint(v13, v12, a7);
}

uint64_t re::WiggleForce::WiggleForce(uint64_t a1, uint64_t a2, int a3, char a4, char a5, __n128 a6, float a7, float a8)
{
  *(unsigned char *)(a1 + 16) = 1;
  *(void *)a1 = &unk_26E716A28;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = a2;
  *(__n128 *)(a1 + 128) = a6;
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a2 + 40))(&v20, a2);
  *(_OWORD *)(a1 + 32) = v20;
  *(_OWORD *)(a1 + 48) = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8re::InputManager::notify(8, 0, 0, 0) = _Q0;
  *(float *)(a1 + 96) = a7;
  *(float *)(a1 + 10re::InputManager::notify(8, 0, 0, 0) = a8;
  *(_WORD *)(a1 + 104) = -1;
  *(_DWORD *)(a1 + 106) = 0;
  *(_WORD *)(a1 + 11re::InputManager::notify(8, 0, 0, 0) = 0;
  *(_DWORD *)(a1 + 112) = a3;
  *(unsigned char *)(a1 + 116) = a4;
  *(unsigned char *)(a1 + 117) = a5;
  *(void *)(a1 + 118) = 0;
  *(_WORD *)(a1 + 126) = 0;
  return a1;
}

void re::WiggleForce::onApply(float32x4_t *this, uint64_t a2)
{
  uint64_t v3 = this[1].i64[1];
  if (v3)
  {
    float v4 = (float32x4_t *)v18;
    (*(void (**)(_OWORD *__return_ptr))(*(void *)v3 + 208))(v18);
  }
  else
  {
    float v4 = this + 8;
  }
  float32x4_t v5 = *v4;
  float32x4_t v6 = this[5];
  uint64_t v17[2] = this[4];
  v17[3] = v6;
  float32x4_t v7 = this[7];
  v17[4] = this[6];
  uint64_t v17[5] = v7;
  float32x4_t v8 = this[3];
  v17[0] = this[2];
  v17[1] = v8;
  *(double *)&long long v9 = WGLForceComputeLinearForce(v17, a2, v5);
  long long v16 = v9;
  uint64_t v10 = this->i64[1];
  uint64_t v11 = *(void *)(v10 + 104);
  if (v11)
  {
    unint64_t v12 = 0;
    uint64_t v13 = v10 + 80;
    do
    {
      uint64_t v14 = re::ecs2::ComponentTypeRegistry::operator[](v13, v12);
      if (v14 != this[1].i64[1])
      {
        uint64_t v15 = v14;
        v18[0] = v16;
        (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v14 + 384))(v14, v18, 0);
        if (this[7].i8[5])
        {
          v18[0] = v16;
          (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v15 + 392))(v15, v18, 0);
        }
      }
      ++v12;
    }
    while (v11 != v12);
  }
}

void re::WiggleForce::~WiggleForce(re::WiggleForce *this)
{
}

uint64_t re::WiggleForce::type(re::WiggleForce *this)
{
  return 7;
}

_DWORD *re::Goal::onApply(float32x4_t *this)
{
  double result = (_DWORD *)this[1].i64[1];
  if (result[52] == 2 && this[7].f32[0] >= 0.0)
  {
    (*(void (**)(float32x4_t *__return_ptr))(*(void *)result + 40))(&v23);
    float32x4_t v3 = v23;
    v3.i32[3] = 0;
    float32x4_t v17 = v3;
    float32x4_t v18 = v24;
    float v4 = (const float *)(this[1].i64[1] + 192);
    float32x4_t v5 = this[7];
    _OWORD v22[2] = this[6];
    v22[3] = v5;
    float32x4_t v6 = this[9];
    _OWORD v22[4] = this[8];
    uint64_t v22[5] = v6;
    float32x4_t v7 = this[5];
    v22[0] = this[4];
    v22[1] = v7;
    float32x4_t v8 = vld1q_dup_f32(v4);
    float32x4_t v19 = v8;
    *(double *)v10.i64 = WGLGoalComputeLinearForce((float32x2_t *)v22, v9, v3, *(double *)v24.i64, (float32x4_t)_PromotedConst_0, unk_23440B590);
    uint64_t v11 = this[1].i64[1];
    float32x4_t v21 = vdivq_f32(v10, v19);
    (*(void (**)(void))(*(void *)v11 + 384))();
    float32x4_t v12 = this[7];
    void v20[2] = this[6];
    uint64_t v20[3] = v12;
    float32x4_t v13 = this[9];
    v20[4] = this[8];
    uint64_t v20[5] = v13;
    float32x4_t v14 = this[5];
    v20[0] = this[4];
    v20[1] = v14;
    *(double *)v15.i64 = WGLGoalComputeAngularTorque(v20, v17, v18, (float32x4_t)_PromotedConst_0, unk_23440B590);
    uint64_t v16 = this[1].i64[1];
    float32x4_t v21 = vdivq_f32(v15, v19);
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)v16 + 392))();
  }
  return result;
}

void re::Goal::~Goal(re::Goal *this)
{
}

uint64_t re::Goal::type(re::Goal *this)
{
  return 9;
}

void re::PhysicsErrorCategoryImpl::~PhysicsErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x237DBCBD0);
}

const char *re::PhysicsErrorCategoryImpl::name(re::PhysicsErrorCategoryImpl *this)
{
  return "REPhysics error";
}

void *re::PhysicsErrorCategoryImpl::message@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if (a1 <= 2999)
  {
    int v4 = a1 - 1000;
    float32x4_t v3 = "Invalid physics material";
    switch(v4)
    {
      case 0:
        return std::string::basic_string[abi:nn180100]<0>(a2, v3);
      case 1:
        float32x4_t v3 = "Missing physics material restitution";
        break;
      case 2:
        float32x4_t v3 = "Missing physics material static friction.";
        break;
      case 3:
        float32x4_t v3 = "Missing physics material dynamic friction.";
        break;
      default:
        if ("Invalid physics material" == 2000) {
          float32x4_t v3 = "Invialid physics gravitational force.";
        }
        else {
LABEL_24:
        }
          float32x4_t v3 = "Unknown REPhysics error";
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 3000:
        float32x4_t v3 = "Invalid physics collider.";
        break;
      case 3001:
        float32x4_t v3 = "Missing physics collider relation.";
        break;
      case 3002:
        float32x4_t v3 = "Missing physics collision shape type.";
        break;
      case 3003:
        float32x4_t v3 = "Invalid physics collider relation.";
        break;
      case 3004:
        float32x4_t v3 = "Unsupported physics collision shape type.";
        break;
      case 3005:
        float32x4_t v3 = "Missing physics collision capsule height.";
        break;
      case 3006:
        float32x4_t v3 = "Missing physics collision capsule radius.";
        break;
      case 3007:
        float32x4_t v3 = "Missing physics collision sphere radius.";
        break;
      case 3008:
        float32x4_t v3 = "Missing physics collision cube size.";
        break;
      case 3009:
        float32x4_t v3 = "Missing physics collision shape extent.";
        break;
      default:
        if (a1 == 4000)
        {
          float32x4_t v3 = "Invalid physics rigid body.";
        }
        else
        {
          if (a1 != 4001) {
            goto LABEL_24;
          }
          float32x4_t v3 = "Missing mass on physics rigid body.";
        }
        break;
    }
  }
  return std::string::basic_string[abi:nn180100]<0>(a2, v3);
}

re::PhysXDistanceJoint *re::PhysXDistanceJoint::PhysXDistanceJoint(re::PhysXDistanceJoint *this, physx::PxDistanceJoint *a2, uint64_t a3)
{
  *(void *)this = &unk_26E716B78;
  double v6 = re::DistanceJoint::DistanceJoint((uint64_t)this, (uint64_t)this + 72);
  void *v7 = &unk_26E716B78;
  v7[9] = &unk_26E717308;
  v7[10] = a2;
  *((void *)a2 + 2) = v7;
  (*(void (**)(physx::PxDistanceJoint *, uint64_t, uint64_t, double))(*(void *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 10) + 128))(*((void *)this + 10), 8, a3);
  return this;
}

uint64_t re::PhysXDistanceJoint::updateLimits(re::PhysXDistanceJoint *this)
{
  uint64_t v2 = *((void *)this + 10);
  (*(void (**)(uint64_t, float))(*(void *)v2 + 248))(v2, *((float *)this + 14));
  v3.n128_u32[0] = *((_DWORD *)this + 15);
  int v4 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v2 + 264);
  return v4(v2, v3);
}

uint64_t re::PhysXDistanceJoint::updateTolerance(re::PhysXDistanceJoint *this)
{
  return (*(uint64_t (**)(void, float))(**((void **)this + 10) + 280))(*((void *)this + 10), (float)(*((float *)this + 15) - *((float *)this + 14)) * *((float *)this + 16));
}

void re::PhysXDistanceJoint::~PhysXDistanceJoint(re::PhysXDistanceJoint *this)
{
  uint64_t v2 = (void (***)(void))*((void *)this + 10);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXDistanceJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  uint64_t v2 = (void (***)(void))*((void *)this + 10);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXDistanceJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::DistanceJoint::type(re::DistanceJoint *this)
{
  return 5;
}

void re::Constraint::~Constraint(re::Constraint *this)
{
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::Constraint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::Constraint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ConstraintKernelBase::onAddConstraint(uint64_t a1)
{
  if (*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) + 208) == 2)
  {
    uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 312))(v2);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (*(_DWORD *)(result + 208) == 2)
  {
    int v4 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) + 312);
    return v4();
  }
  return result;
}

uint64_t re::ConstraintKernelBase::onRemoveConstraint(uint64_t a1)
{
  if (*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) + 208) == 2)
  {
    uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 312))(v2);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (*(_DWORD *)(result + 208) == 2)
  {
    int v4 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) + 312);
    return v4();
  }
  return result;
}

uint64_t re::Constraint::type(re::Constraint *this)
{
  return 0;
}

re::PhysicsSimulation *re::PhysicsSimulation::PhysicsSimulation(re::PhysicsSimulation *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  uint64_t v2 = 0;
  *(void *)this = &unk_26E716C70;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 4re::InputManager::notify(8, 0, 0, 0) = 0u;
  *((void *)this + 8) = 0x3C88888900000004;
  *((unsigned char *)this + 72) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((void *)this + 16) = 0x100000006;
  *((void *)this + 17) = &unk_26E7165B8;
  *((void *)this + 18) = this;
  *((void *)this + 2re::InputManager::notify(8, 0, 0, 0) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 44) = 0;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 20re::InputManager::notify(8, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(void *)((char *)this + 228) = 0x7FFFFFFFLL;
  *((unsigned char *)this + 24re::InputManager::notify(8, 0, 0, 0) = 0;
  *((_DWORD *)this + 7re::InputManager::notify(8, 0, 0, 0) = 0;
  *((void *)this + 31) = this;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_DWORD *)this + 8re::InputManager::notify(8, 0, 0, 0) = 0;
  *((void *)this + 41) = 0;
  *((void *)this + 42) = this;
  *((void *)this + 47) = 0;
  *((void *)this + 44) = 0;
  *((void *)this + 45) = 0;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 43) = 0;
  do
  {
    __n128 v3 = (char *)this + v2;
    *((void *)v3 + 52) = 0;
    *((void *)v3 + 49) = 0;
    *((void *)v3 + 5re::InputManager::notify(8, 0, 0, 0) = 0;
    *((void *)v3 + 48) = 0;
    v2 += 40;
    *((_DWORD *)v3 + 102) = 0;
  }
  while (v2 != 320);
  for (uint64_t i = 0; i != 80; i += 40)
  {
    float32x4_t v5 = (char *)this + i;
    *((void *)v5 + 92) = 0;
    *((void *)v5 + 88) = 0;
    *((void *)v5 + 9re::InputManager::notify(8, 0, 0, 0) = 0;
    *((void *)v5 + 89) = 0;
    *((_DWORD *)v5 + 182) = 0;
  }
  for (uint64_t j = 0; j != 80; j += 40)
  {
    float32x4_t v7 = (char *)this + j;
    *((void *)v7 + 102) = 0;
    *((void *)v7 + 98) = 0;
    *((void *)v7 + 10re::InputManager::notify(8, 0, 0, 0) = 0;
    *((void *)v7 + 99) = 0;
    *((_DWORD *)v7 + 202) = 0;
  }
  *((void *)this + 116) = 0;
  *((_DWORD *)this + 234) = 0;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 908) = 0u;
  return this;
}

void re::PhysicsSimulation::~PhysicsSimulation(re::PhysicsSimulation *this)
{
  *(void *)this = &unk_26E716C70;
  uint64_t v2 = (const void *)*((void *)this + 109);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 109) = 0;
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 896);
  for (uint64_t i = 824; i != 744; i -= 40)
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + i);
  do
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + i);
    i -= 40;
  }
  while (i != 664);
  do
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + i);
    i -= 40;
  }
  while (i != 344);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 344);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 296);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 256);
  re::PhysicsJointCollection::~PhysicsJointCollection((BOOL)this + 136);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 88);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

void re::PhysicsSimulation::setParentClockOrTimebase(re::PhysicsSimulation *this, void *cf)
{
  uint64_t v2 = (CMTimebaseRef *)((char *)this + 872);
  __n128 v3 = (const void *)*((void *)this + 109);
  if (cf)
  {
    if (!v3)
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      HostTimeClocuint64_t k = CMClockGetHostTimeClock();
      CMTimebaseCreateWithSourceClock(v5, HostTimeClock, v2);
      CMTimebaseSetRate(*v2, 1.0);
    }
    CFTypeID v7 = CFGetTypeID(cf);
    CFTypeID TypeID = CMClockGetTypeID();
    uint64_t v9 = *v2;
    if (v7 == TypeID)
    {
      CMTimebaseSetSourceClock(v9, (CMClockRef)cf);
    }
    else
    {
      CMTimebaseSetSourceTimebase(v9, (CMTimebaseRef)cf);
    }
  }
  else if (v3)
  {
    CFRelease(v3);
    *uint64_t v2 = 0;
  }
}

void re::PhysicsSimulation::update(re::PhysicsSimulation *this, float a2)
{
  if ((*(uint64_t (**)(re::PhysicsSimulation *))(*(void *)this + 96))(this))
  {
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v18, 7000, (uint64_t)this);
    re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v17);
    if (physx::shdfnd::g_isLockingEnabled) {
      int v5 = 1;
    }
    else {
      int v5 = physx::shdfnd::g_alwaysUseLocking;
    }
    if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
      physx::shdfnd::g_isLockingEnabled = 0;
    }
    double v6 = (OpaqueCMTimebase *)*((void *)this + 109);
    if (v6)
    {
      CMTimebaseGetTime(&time, v6);
      v4.n128_f64[0] = CMTimeGetSeconds(&time);
      a2 = v4.n128_f64[0] - *((double *)this + 110);
      *((void *)this + 11re::InputManager::notify(8, 0, 0, 0) = v4.n128_u64[0];
    }
    v4.n128_f64[0] = *((double *)this + 111) + a2;
    *((void *)this + 111) = v4.n128_u64[0];
    if (*((_DWORD *)this + 234) != 1)
    {
      v4.n128_f64[0] = *((float *)this + 17);
      *((void *)this + 111) = v4.n128_u64[0];
      *((_DWORD *)this + 234) = 1;
    }
    int v7 = 0;
    while (1)
    {
      double v8 = *((double *)this + 111);
      v4.n128_u32[0] = *((_DWORD *)this + 17);
      if (v8 < (float)(v4.n128_f32[0] * 0.95)) {
        break;
      }
      *((double *)this + 111) = v8 - v4.n128_f32[0];
      uint64_t v9 = *((void *)this + 4);
      if (v9)
      {
        (*(void (**)(uint64_t, BOOL, re::PhysicsSimulation *))(*(void *)v9 + 16))(v9, v7 == 0, this);
        v4.n128_u32[0] = *((_DWORD *)this + 17);
      }
      (*(void (**)(re::PhysicsSimulation *, __n128))(*(void *)this + 64))(this, v4);
      (*(void (**)(void))(**((void **)this + 7) + 224))(*((void *)this + 7));
      uint64_t v10 = *((void *)this + 4);
      if (v10) {
        (*(void (**)(uint64_t, re::PhysicsSimulation *, float))(*(void *)v10 + 24))(v10, this, *((float *)this + 17));
      }
      else {
        (*(void (**)(void))(**((void **)this + 7) + 208))(*((void *)this + 7));
      }
      (*(void (**)(void))(**((void **)this + 7) + 136))(*((void *)this + 7));
      if (++v7 >= *((_DWORD *)this + 16))
      {
        *((void *)this + 111) = 0;
        goto LABEL_28;
      }
    }
    if (!v7)
    {
      uint64_t v13 = *((void *)this + 4);
      if (v13) {
        (*(void (**)(uint64_t, re::PhysicsSimulation *, double))(*(void *)v13 + 24))(v13, this, 0.0);
      }
    }
LABEL_28:
    float v14 = *((float *)this + 17) * 0.05;
    if (a2 > v14)
    {
      float v15 = *((double *)this + 111);
      if (fabsf(v15) < v14) {
        *((void *)this + 111) = 0;
      }
    }
    (*(void (**)(re::PhysicsSimulation *))(*(void *)this + 88))(this);
    if (physx::shdfnd::g_isLockingEnabled != v5) {
      physx::shdfnd::g_isLockingEnabled = v5;
    }
    re::ProfilerTimeGuard<(re::ProfilerStatistic)19>::end((uint64_t)v17);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v18);
  }
  else
  {
    *((_DWORD *)this + 234) = 0;
    uint64_t v11 = *((void *)this + 4);
    if (v11)
    {
      float32x4_t v12 = *(void (**)(void))(*(void *)v11 + 32);
      v12();
    }
  }
}

_anonymous_namespace_ *re::PhysicsSimulation::applyForceEffects(re::PhysicsSimulation *this)
{
  uint64_t v2 = *((void *)this + 34);
  v7[0] = *((void *)this + 36);
  v7[1] = v2;
  uint64_t result = re::DynamicArray<re::ForceEffect *>::operator=((re::PhysicsSimulation *)((char *)this + 296), (uint64_t)v7);
  uint64_t v4 = *((void *)this + 39);
  if (v4)
  {
    int v5 = (_anonymous_namespace_ **)*((void *)this + 41);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t result = *v5;
      if (*((unsigned char *)*v5 + 16)) {
        uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)result + 56))(result);
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::ForceEffect *>::operator=(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(void *)this)
  {
    if (v4)
    {
      re::DynamicArray<char const*>::copy(this, 0, *(char **)a2, v4);
      re::DynamicArray<double>::resize((uint64_t)this, *(void *)(a2 + 8));
    }
    else
    {
      *((void *)this + 2) = 0;
      ++*((_DWORD *)this + 6);
    }
  }
  else if (v4)
  {
    re::DynamicArray<float *>::setCapacity(this, v4);
    ++*((_DWORD *)this + 6);
    re::DynamicArray<char const*>::copy(this, 0, *(char **)a2, *(void *)(a2 + 8));
  }
  return this;
}

uint64_t re::PhysicsSimulation::onRigidBodyAdded(re::PhysicsSimulation *this, re::RigidBody *a2)
{
  uint64_t v4 = *(void *)(*((void *)this + 7) + 128);
  *(void *)(*((void *)a2 + 9) + 56) = v4;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 192))(v4);
  uint64_t v6 = *((void *)this + 34);
  if (v6)
  {
    int v7 = (uint64_t *)*((void *)this + 36);
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7++;
      uint64_t result = (*(uint64_t (**)(uint64_t, re::RigidBody *))(*(void *)v9 + 64))(v9, a2);
      v8 -= 8;
    }
    while (v8);
  }
  return result;
}

uint64_t re::PhysicsSimulation::onRigidBodyRemoved(re::PhysicsSimulation *this, re::RigidBody *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  uint64_t v5 = *((void *)this + 7);
  uint64_t v6 = (re::CollisionObject *)*((void *)a2 + 9);
  re::ContactSetCollection::remove((re::ContactSetCollection *)(*(void *)(v5 + 128) + 72), v6);
  uint64_t result = (*(uint64_t (**)(void, re::CollisionObject *))(**(void **)(v5 + 128) + 200))(*(void *)(v5 + 128), v6);
  *((void *)v6 + 7) = 0;
  uint64_t v8 = *((void *)this + 34);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)*((void *)this + 36);
    uint64_t v10 = 8 * v8;
    do
    {
      uint64_t v11 = *v9++;
      uint64_t result = (*(uint64_t (**)(uint64_t, re::RigidBody *))(*(void *)v11 + 72))(v11, a2);
      v10 -= 8;
    }
    while (v10);
  }
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return result;
}

void *re::PhysicsSimulation::addConstraintToDelete(void *this, re::Constraint *a2)
{
  uint64_t v6 = a2;
  if (a2)
  {
    uint64_t v2 = this[116];
    uint64_t v3 = this[114];
    if (v3)
    {
      uint64_t v4 = 8 * v3;
      uint64_t v5 = (re::Constraint **)this[116];
      while (*v5 != a2)
      {
        ++v5;
        v4 -= 8;
        if (!v4)
        {
          uint64_t v5 = (re::Constraint **)(v2 + 8 * v3);
          break;
        }
      }
    }
    else
    {
      uint64_t v5 = (re::Constraint **)this[116];
    }
    if (v3 == ((uint64_t)v5 - v2) >> 3) {
      return re::DynamicArray<re::TransitionCondition *>::add(this + 112, &v6);
    }
  }
  return this;
}

re *re::PhysicsSimulation::deleteConstraintsMarkedForDeletion(re *this)
{
  uint64_t v1 = (uint64_t)this;
  uint64_t v10 = *MEMORY[0x263EF8340];
  if ((int)*((void *)this + 114) >= 1)
  {
    unint64_t v2 = *((void *)this + 114);
    do
    {
      if (*(void *)(v1 + 912) <= (unint64_t)(v2 - 1))
      {
        memset(v9, 0, sizeof(v9));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v3 = *(void (****)(void))(*(void *)(v1 + 928) + 8 * (v2 - 1));
      uint64_t v4 = *(void *)(v1 + 184);
      uint64_t v5 = *(void *)(v1 + 168);
      if (v5)
      {
        uint64_t v6 = 8 * v5;
        int v7 = *(void **)(v1 + 184);
        while ((void (***)(void))*v7 != v3)
        {
          ++v7;
          v6 -= 8;
          if (!v6)
          {
            int v7 = (void *)(v4 + 8 * v5);
            break;
          }
        }
      }
      else
      {
        int v7 = *(void **)(v1 + 184);
      }
      if (v5 != ((uint64_t)v7 - v4) >> 3)
      {
        *(void *)&v9[0] = *(void *)(*(void *)(v1 + 928) + 8 * (v2 - 1));
        re::DynamicArray<re::Allocator const*>::removeStable((void *)(v1 + 152), v9);
        this = re::internal::destroyPersistent<re::PhysicsSimulation>((re *)"deleteConstraintsMarkedForDeletion", 253, v3);
      }
    }
    while (v2-- > 1);
  }
  *(void *)(v1 + 912) = 0;
  ++*(_DWORD *)(v1 + 920);
  return this;
}

uint64_t re::PhysXGeneric6DOFConstraint::PhysXGeneric6DOFConstraint(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_26E716D20;
  uint64_t v8 = re::Generic6DOFConstraint::Generic6DOFConstraint((_anonymous_namespace_ *)a1, a1 + 344);
  *(void *)uint64_t v8 = &unk_26E716D20;
  *((void *)v8 + 43) = &unk_26E717308;
  *((void *)v8 + 44) = a2;
  a2[2] = v8;
  (*(void (**)(void *, uint64_t, uint64_t))(*a2 + 128))(a2, 16, 1);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 352) + 128))(*(void *)(a1 + 352), 8, a4);
  *(void *)(a1 + 36re::InputManager::notify(8, 0, 0, 0) = a3;
  return a1;
}

uint64_t re::PhysXGeneric6DOFConstraint::updateLimits(re::PhysXGeneric6DOFConstraint *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = *((void *)this + 44);
  uint64_t v4 = (char *)this + 128;
  uint64_t v5 = (char *)this + 104;
  while (1)
  {
    int v6 = dword_23440B638[v2];
    int v7 = (float *)re::Generic6DOFConstraint::linearLimit((uint64_t)this, v6);
    uint64_t v9 = v6;
    if (v6 >= 3) {
      break;
    }
    uint64_t v10 = dword_23440B638[v6];
    if (v4[16 * v9])
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 240))(v3, dword_23440B638[v9], 1);
      uint64_t v11 = &v4[16 * v9];
      float v12 = fabsf(*((float *)v11 + 3));
      long long v32 = 0uLL;
      float v33 = 0.0;
      float v34 = v12;
      float v35 = 0.0;
      *((void *)&v32 + 1) = *(void *)(v11 + 4);
      (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v3 + 296))(v3, v10, &v32);
    }
    else
    {
      int v14 = *(_DWORD *)&v5[4 * v9];
      float v15 = (float *)*((void *)this + 45);
      float v16 = *v7;
      float v17 = v7[1];
      uint64_t v18 = 2;
      if (*v7 == v17) {
        int v19 = 2;
      }
      else {
        int v19 = 1;
      }
      if (*v7 > v17) {
        int v19 = 0;
      }
      if (v19)
      {
        char v20 = 0;
        uint64_t v18 = v19 == 1;
      }
      else
      {
        char v20 = 1;
        float v16 = 0.0;
        float v17 = 0.0;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 240))(v3, v10, v18);
      if ((v20 & 1) == 0)
      {
        *((void *)&v32 + 1) = 0;
        float v34 = v17;
        float v35 = v16;
        float v21 = *v15;
        float v22 = *v15 * 0.01;
        if (v22 >= (float)((float)(v16 * -0.49) + (float)(v17 * 0.49))) {
          float v22 = (float)(v16 * -0.49) + (float)(v17 * 0.49);
        }
        float v33 = v22;
        LODWORD(v32) = v14;
        *((float *)&v32 + 1) = v21 + v21;
        (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v3 + 296))(v3, v10, &v32);
      }
    }
    if (++v2 == 3)
    {
      uint64_t v31 = *((void *)this + 10);
      long long v32 = *((_OWORD *)this + 11);
      re::setPxD6JointTwistLimit(v3, (re *)&v31, (uint64_t)&v32, v13, *((float *)this + 29));
      uint64_t v23 = *((void *)this + 12);
      uint64_t v30 = *((void *)this + 11);
      long long v24 = *((_OWORD *)this + 13);
      long long v29 = *((_OWORD *)this + 12);
      uint64_t v28 = v23;
      long long v27 = v24;
      return re::setPxD6JointSwingLimit(v3, (re *)&v30, (uint64_t)&v29, (float *)&v28, (uint64_t)&v27, *((float *)this + 30), *((float *)this + 31));
    }
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, v6, 3);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) Unexpected limit type.", "!\"Unreachable code\"", "convertLimit", 120);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::Generic6DOFConstraint::linearLimit(uint64_t a1, uint64_t a2)
{
  if (a2 < 3) {
    return a1 + 8 * (int)a2 + 56;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, (int)a2, 3, v2, v3);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::setPxD6JointTwistLimit(uint64_t a1, re *this, uint64_t a3, float *a4, float a5)
{
  if (*(unsigned char *)a3)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 3, 1);
    unsigned int v7 = *(_DWORD *)(a3 + 12);
    uint64_t v13 = 0;
    float v15 = 0.0;
    uint64_t v16 = v7;
    uint64_t v14 = *(void *)(a3 + 4);
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 312))(a1, &v13);
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v10 = re::convertLimit(this, (const re::AngularLimit *)((char *)&v12 + 4), (float *)&v12, a4);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 3, v10);
    if (v10 != 2)
    {
      uint64_t v16 = v12;
      float v11 = (float)(*(float *)&v12 - *((float *)&v12 + 1)) * 0.49;
      if (v11 > 0.1) {
        float v11 = 0.1;
      }
      uint64_t v14 = 0;
      float v15 = v11;
      uint64_t v13 = LODWORD(a5) | 0x3F00000000000000;
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 312))(a1, &v13);
    }
  }
  return result;
}

uint64_t re::setPxD6JointSwingLimit(uint64_t a1, re *a2, uint64_t a3, float *a4, uint64_t a5, float a6, float a7)
{
  v38[1] = *MEMORY[0x263EF8340];
  if (*(unsigned char *)a3) {
    BOOL v12 = *(unsigned char *)a5 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    if (*(unsigned char *)a3)
    {
      unsigned int v13 = *(_DWORD *)(a3 + 12);
      *(void *)&long long v34 = 0;
      *(void *)&long long v35 = 0;
      *((void *)&v35 + 1) = v13;
      __int32 v36 = 0;
      uint64_t v14 = *(void *)(a3 + 4);
    }
    else
    {
      if (!*(unsigned char *)a5) {
        goto LABEL_16;
      }
      __int32 v18 = *(_DWORD *)(a5 + 12);
      long long v34 = 0u;
      long long v35 = 0u;
      __int32 v36 = v18;
      uint64_t v14 = *(void *)(a5 + 4);
    }
    *((void *)&v34 + 1) = v14;
    (*(void (**)(uint64_t, long long *))(*(void *)a1 + 344))(a1, &v34);
    goto LABEL_16;
  }
  float v15 = *(float *)(a3 + 12);
  float v16 = *(float *)(a5 + 12);
  *(void *)((char *)&v35 + 4) = __PAIR64__(LODWORD(v16), LODWORD(v15));
  if (v15 < v16) {
    float v16 = v15;
  }
  float v17 = v16 * 0.49;
  if (v17 > 0.1) {
    float v17 = 0.1;
  }
  long long v34 = 0x3F00000000000000uLL;
  *(float *)&long long v35 = v17;
  (*(void (**)(uint64_t, long long *))(*(void *)a1 + 328))(a1, &v34);
LABEL_16:
  uint64_t v19 = re::convertLimit(a2, (const re::AngularLimit *)v38, (float *)&v37, a4);
  uint64_t v21 = re::convertLimit((re *)a4, (const re::AngularLimit *)((char *)v38 + 4), (float *)&v37 + 1, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 4, v19);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 5, v21);
  if (v19 == 2 || v21 == 2)
  {
    if (v19 == 2)
    {
      if (v21 == 2) {
        return result;
      }
      *((void *)&v34 + 1) = 0;
      *(void *)((char *)&v35 + 4) = 0;
      HIDWORD(v35) = HIDWORD(v38[0]);
      __int32 v36 = v37.i32[1];
      float v32 = (float)(v37.f32[1] - *((float *)v38 + 1)) * 0.49;
      if (v32 > 0.1) {
        float v32 = 0.1;
      }
      if (v32 > 0.0) {
        float v32 = 0.0;
      }
      BOOL v12 = v32 == -1.0;
      float v33 = 1.0;
      if (!v12) {
        float v33 = 0.0;
      }
      *(float *)&long long v35 = v33;
    }
    else
    {
      float v26 = (float)(v37.f32[0] - *(float *)v38) * 0.49;
      if (v26 > 0.1) {
        float v26 = 0.1;
      }
      *((void *)&v34 + 1) = 0;
      DWORD1(v35) = v38[0];
      *((void *)&v35 + 1) = v37.u32[0];
      __int32 v36 = 0;
      float v27 = 1.0;
      if (fminf(v26, 0.0) != -1.0) {
        float v27 = 0.0;
      }
      *(float *)&long long v35 = v27;
    }
    DWORD1(v34) = 1056964608;
    if (a6 >= a7) {
      float v31 = a6;
    }
    else {
      float v31 = a7;
    }
    goto LABEL_52;
  }
  if (!v19 || !v21)
  {
    v39.val[1] = v37;
    v39.val[0] = (float32x2_t)v38[0];
    *((void *)&v34 + 1) = 0;
    uint64_t v28 = (float *)&v35 + 1;
    vst2_f32(v28, v39);
    v39.val[0] = vmul_f32(vsub_f32(v39.val[1], v39.val[0]), (float32x2_t)vdup_n_s32(0x3EFAE148u));
    v39.val[1] = (float32x2_t)vdup_n_s32(0x3DCCCCCDu);
    int8x8_t v29 = vbsl_s8((int8x8_t)vcgt_f32(v39.val[0], v39.val[1]), (int8x8_t)v39.val[1], (int8x8_t)v39.val[0]);
    if (*(float *)v29.i32 >= *(float *)&v29.i32[1]) {
      v29.i32[0] = v29.i32[1];
    }
    BOOL v12 = *(float *)v29.i32 == -1.0;
    float v30 = 0.0;
    if (v12) {
      float v30 = 1.0;
    }
    *(float *)&long long v35 = v30;
    DWORD1(v34) = 1056964608;
    if (a6 >= a7) {
      float v31 = a6;
    }
    else {
      float v31 = a7;
    }
LABEL_52:
    *(float *)&long long v34 = v31;
    return (*(uint64_t (**)(uint64_t, long long *))(*(void *)a1 + 344))(a1, &v34);
  }
  float v23 = v37.f32[1];
  *(float32x2_t *)((char *)&v35 + 4) = v37;
  if (v37.f32[0] < v37.f32[1]) {
    float v23 = v37.f32[0];
  }
  float v24 = v23 * 0.49;
  if (v24 > 0.1) {
    float v24 = 0.1;
  }
  *((void *)&v34 + 1) = 0;
  *(float *)&long long v35 = v24;
  DWORD1(v34) = 1056964608;
  if (a6 >= a7) {
    float v25 = a6;
  }
  else {
    float v25 = a7;
  }
  *(float *)&long long v34 = v25;
  return (*(uint64_t (**)(uint64_t, long long *))(*(void *)a1 + 328))(a1, &v34);
}

uint64_t re::PhysXGeneric6DOFConstraint::updateMotor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 352);
  int v4 = *(_DWORD *)(a3 + 8);
  uint64_t v23 = 0x3F80000000000000;
  int v24 = v4;
  int v25 = 0;
  if (a2 >= 6)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unsupported drive axis!", "!\"Unreachable code\"", "physxDriveAxis", 66);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    __n128 v6 = ((__n128 (*)(uint64_t, void, uint64_t *))*(void *)(*(void *)v3 + 360))(v3, dword_23440B668[(int)a2], &v23);
    v6.n128_u32[0] = *(_DWORD *)(a1 + 228);
    v6.n128_u32[1] = *(_DWORD *)(a1 + 248);
    v6.n128_u32[2] = *(_DWORD *)(a1 + 268);
    __n128 v22 = v6;
    v6.n128_u32[0] = *(_DWORD *)(a1 + 288);
    v6.n128_u32[1] = *(_DWORD *)(a1 + 308);
    v6.n128_u32[2] = *(_DWORD *)(a1 + 328);
    __n128 v21 = v6;
    (*(void (**)(uint64_t, __n128 *, __n128 *, uint64_t))(*(void *)v3 + 392))(v3, &v22, &v21, 1);
    float v7 = *(float *)(a1 + 260);
    float v8 = *(float *)(a1 + 280);
    v20[4] = *(float *)(a1 + 240);
    uint64_t v20[5] = v7;
    float32x4_t v20[6] = v8;
    __float2 v9 = __sincosf_stret(*(float *)(a1 + 300) * 0.5);
    float v10 = v9.__sinval * 0.0;
    __float2 v11 = __sincosf_stret(*(float *)(a1 + 320) * 0.5);
    float v12 = v11.__sinval * 0.0;
    __float2 v13 = __sincosf_stret(*(float *)(a1 + 340) * 0.5);
    float v14 = v11.__cosval * (float)(v13.__sinval * 0.0);
    float v15 = (float)((float)(v14 + (float)(v13.__cosval * v12)) + (float)((float)(v13.__sinval * 0.0) * v12))
        - (float)(v11.__sinval * v13.__sinval);
    float v16 = (float)((float)(v14 + (float)(v13.__cosval * v11.__sinval)) + (float)(v13.__sinval * v12))
        - (float)(v12 * (float)(v13.__sinval * 0.0));
    float v17 = (float)((float)((float)(v11.__cosval * v13.__sinval) + (float)(v13.__cosval * v12))
                + (float)((float)(v13.__sinval * 0.0) * v11.__sinval))
        - (float)(v12 * (float)(v13.__sinval * 0.0));
    float v18 = (float)((float)((float)(v13.__cosval * v11.__cosval) - (float)((float)(v13.__sinval * 0.0) * v12))
                - (float)((float)(v13.__sinval * 0.0) * v11.__sinval))
        - (float)(v13.__sinval * v12);
    v20[0] = (float)((float)((float)(v9.__cosval * v15) + (float)(v18 * v9.__sinval)) + (float)(v16 * v10))
           - (float)(v10 * v17);
    v20[1] = (float)((float)((float)(v9.__cosval * v16) + (float)(v18 * v10)) + (float)(v17 * v9.__sinval))
           - (float)(v10 * v15);
    void v20[2] = (float)((float)((float)(v9.__cosval * v17) + (float)(v18 * v10)) + (float)(v15 * v10))
           - (float)(v9.__sinval * v16);
    uint64_t v20[3] = (float)((float)((float)(v18 * v9.__cosval) - (float)(v15 * v9.__sinval)) - (float)(v16 * v10))
           - (float)(v17 * v10);
    return (*(uint64_t (**)(uint64_t, float *, uint64_t))(*(void *)v3 + 376))(v3, v20, 1);
  }
  return result;
}

uint64_t re::convertLimit(re *this, const re::AngularLimit *a2, float *a3, float *a4)
{
  float v4 = *(float *)this;
  float v5 = *((float *)this + 1);
  if (*(float *)this == v5) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  if (*(float *)this > v5) {
    int v6 = 0;
  }
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      if (a2) {
        *(float *)a2 = v4;
      }
      if (!a3) {
        return 1;
      }
      int v7 = *((_DWORD *)this + 1);
      uint64_t v8 = 1;
    }
    else
    {
      if (a2) {
        *(_DWORD *)a2 = 0;
      }
      int v7 = 0;
      uint64_t v8 = 2;
      if (!a3) {
        return v8;
      }
    }
LABEL_20:
    *(_DWORD *)a3 = v7;
    return v8;
  }
  if (a2) {
    *(float *)a2 = v4;
  }
  uint64_t v8 = 0;
  if (a3)
  {
    int v7 = *((_DWORD *)this + 1);
    goto LABEL_20;
  }
  return v8;
}

void re::PhysXGeneric6DOFConstraint::~PhysXGeneric6DOFConstraint(re::PhysXGeneric6DOFConstraint *this)
{
  uint64_t v2 = (void (***)(void))*((void *)this + 44);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXGeneric6DOFConstraint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  uint64_t v2 = (void (***)(void))*((void *)this + 44);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXGeneric6DOFConstraint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

float re::AngularLimit::range(re::AngularLimit *this, float a2, float a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  float v5 = a3 - a2;
  if ((float)(a3 - a2) >= 6.2657)
  {
    int v6 = *re::physicsLogObjects(this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 134218496;
      double v9 = (float)((float)(a2 * 180.0) * 0.31831);
      __int16 v10 = 2048;
      double v11 = (float)((float)(a3 * 180.0) * 0.31831);
      __int16 v12 = 2048;
      double v13 = (float)((float)(v5 * 180.0) * 0.31831);
      _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, "Warning: Range of angular limit is too large (miuint64_t n = %f°, max = %f°, range = %f°). The range needs to be significantly less than 360°. Otherwise, the angular limit might be ineffective.", (uint8_t *)&v8, 0x20u);
    }
  }
  return a2;
}

float re::AngularLimit::symmetricRange(re::AngularLimit *this, float a2)
{
  return re::AngularLimit::range(this, a2 * -0.5, a2 * 0.5);
}

float re::AngularLimit::free(re::AngularLimit *this)
{
  return 1.0;
}

void *re::allocInfo_LinearLimit(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99150, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99150))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99188, "LinearLimit");
    __cxa_guard_release(&qword_26AF99150);
  }
  return &unk_26AF99188;
}

void re::initInfo_LinearLimit(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x1CF05B5D2D046ECLL;
  v14[1] = "LinearLimit";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_426, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&_MergedGlobals_426);
    if (v4)
    {
      float v5 = re::introspectionAllocator(v4);
      int v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "m_min";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99168 = v8;
      double v9 = re::introspectionAllocator((re *)v8);
      double v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "m_max";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99170 = v12;
      __cxa_guard_release(&_MergedGlobals_426);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF99168;
  *((void *)this + 9) = re::internal::defaultConstruct<re::LinearLimit>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::LinearLimit>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::LinearLimit>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::LinearLimit>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

double re::internal::defaultConstruct<re::LinearLimit>(uint64_t a1, uint64_t a2, void *a3)
{
  double result = -0.00781250185;
  *a3 = 0xBF8000003F800000;
  return result;
}

double re::internal::defaultConstructV2<re::LinearLimit>(void *a1)
{
  double result = -0.00781250185;
  *a1 = 0xBF8000003F800000;
  return result;
}

uint64_t re::introspect_LinearLimit(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"LinearLimit", (uint64_t (*)(re::internal *))re::allocInfo_LinearLimit, (re::IntrospectionBase *(*)(void))re::initInfo_LinearLimit, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::LinearLimit>, this);
}

void *re::allocInfo_AngularLimit(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99160, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99160))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99200, "AngularLimit");
    __cxa_guard_release(&qword_26AF99160);
  }
  return &unk_26AF99200;
}

void re::initInfo_AngularLimit(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x306BACEF40AE7E32;
  v14[1] = "AngularLimit";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99158, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&qword_26AF99158);
    if (v4)
    {
      float v5 = re::introspectionAllocator(v4);
      int v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "m_min";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99178 = v8;
      double v9 = re::introspectionAllocator((re *)v8);
      double v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "m_max";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99180 = v12;
      __cxa_guard_release(&qword_26AF99158);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF99178;
  *((void *)this + 9) = re::internal::defaultConstruct<re::AngularLimit>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::AngularLimit>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::AngularLimit>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::AngularLimit>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

double re::internal::defaultConstruct<re::AngularLimit>(uint64_t a1, uint64_t a2, void *a3)
{
  double result = -0.00781250185;
  *a3 = 0xBF8000003F800000;
  return result;
}

double re::internal::defaultConstructV2<re::AngularLimit>(void *a1)
{
  double result = -0.00781250185;
  *a1 = 0xBF8000003F800000;
  return result;
}

uint64_t re::introspect_AngularLimit(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AngularLimit", (uint64_t (*)(re::internal *))re::allocInfo_AngularLimit, (re::IntrospectionBase *(*)(void))re::initInfo_AngularLimit, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AngularLimit>, this);
}

_DWORD *re::DampedSpring::onApply(float32x4_t *this)
{
  uint64_t v2 = this[1].i64[1];
  if (v2)
  {
    (*(void (**)(float32x4_t *__return_ptr))(*(void *)v2 + 40))(&v43);
    float32x4_t v3 = this[3];
    float32x4_t v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL);
    float32x4_t v5 = vnegq_f32((float32x4_t)v44);
    float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), v5), v3, v4);
    int8x16_t v7 = (int8x16_t)vaddq_f32(v6, v6);
    float32x4_t v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), v7, 0xCuLL);
    int8x16_t v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v5), v8, v4);
    __n128 v10 = (__n128)vaddq_f32(v43, vaddq_f32(vaddq_f32(v3, vmulq_laneq_f32(v8, (float32x4_t)v44, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL)));
    float32x4_t v45 = (float32x4_t)v10;
    uint64_t v11 = this[1].i64[1];
    if (v11)
    {
      v10.n128_f64[0] = re::RigidBody::calculateVelocityAtWorldPoint(v11, &v45);
      v14.i64[0] = v12;
      v14.i64[1] = v13;
      goto LABEL_6;
    }
  }
  else
  {
    __n128 v10 = (__n128)this[3];
    float32x4_t v45 = (float32x4_t)v10;
  }
  float32x4_t v14 = 0uLL;
LABEL_6:
  uint64_t v15 = this[2].i64[0];
  if (v15)
  {
    float32x4_t v40 = v14;
    (*(void (**)(float32x4_t *__return_ptr, __n128))(*(void *)v15 + 40))(&v43, v10);
    float32x4_t v16 = this[4];
    float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL);
    float32x4_t v18 = vnegq_f32((float32x4_t)v44);
    float32x4_t v19 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL), v18), v16, v17);
    int8x16_t v20 = (int8x16_t)vaddq_f32(v19, v19);
    float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v20, 0xCuLL);
    int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL), v18), v21, v17);
    float32x4_t v23 = vaddq_f32(v43, vaddq_f32(vaddq_f32(v16, vmulq_laneq_f32(v21, (float32x4_t)v44, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL)));
    float32x4_t v42 = v23;
    uint64_t v24 = this[2].i64[0];
    if (v24)
    {
      float32x4_t v39 = v23;
      re::RigidBody::calculateVelocityAtWorldPoint(v24, &v42);
      float32x4_t v23 = v39;
      v27.i64[0] = v25;
      v27.i64[1] = v26;
    }
    else
    {
      float32x4_t v27 = 0uLL;
    }
    float32x4_t v14 = v40;
  }
  else
  {
    float32x4_t v42 = this[4];
    float32x4_t v27 = 0uLL;
    float32x4_t v23 = v42;
  }
  float32x4_t v28 = vsubq_f32(v23, v45);
  float32x4_t v29 = vmulq_f32(v28, v28);
  LODWORD(v3re::InputManager::notify(8, 0, 0, 0) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
  float v31 = sqrtf(v30);
  if (fabsf(v30) < 1.0e-10)
  {
    float32x4_t v35 = (float32x4_t)xmmword_23435FD60;
  }
  else
  {
    float v32 = v30;
    float32x2_t v33 = vrsqrte_f32((float32x2_t)LODWORD(v30));
    float32x2_t v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)LODWORD(v32), vmul_f32(v33, v33)));
    float32x4_t v35 = vmulq_n_f32(v28, vmul_f32(v34, vrsqrts_f32((float32x2_t)LODWORD(v32), vmul_f32(v34, v34))).f32[0]);
  }
  float32x4_t v36 = vmulq_f32(vsubq_f32(v14, v27), v35);
  float32x4_t v43 = vaddq_f32(vmulq_n_f32(v35, this[5].f32[1] * (float)(v31 - this[5].f32[0])), vmulq_n_f32(v35, (float)-this[5].f32[2]* vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]));
  float32x2_t v37 = (_DWORD *)this[1].i64[1];
  if (v37 && v37[52] == 2) {
    (*(void (**)(_DWORD *, float32x4_t *, float32x4_t *, void))(*(void *)v37 + 376))(v37, &v43, &v45, 0);
  }
  double result = (_DWORD *)this[2].i64[0];
  if (result)
  {
    if (result[52] == 2)
    {
      float32x4_t v41 = vnegq_f32(v43);
      return (_DWORD *)(*(uint64_t (**)(_DWORD *, float32x4_t *, float32x4_t *, void))(*(void *)result
                                                                                                 + 376))(result, &v41, &v42, 0);
    }
  }
  return result;
}

void re::DampedSpring::~DampedSpring(re::DampedSpring *this)
{
}

uint64_t re::DampedSpring::type(re::DampedSpring *this)
{
  return 4;
}

void re::AngularSpring::onApply(re::AngularSpring *this)
{
  (*(void (**)(float32x4_t *__return_ptr))(**((void **)this + 3) + 40))(&v96);
  float32x4_t v2 = *((float32x4_t *)this + 3);
  float32x4_t v3 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v97, v97), (int8x16_t)v97, 0xCuLL);
  float32x4_t v4 = vnegq_f32((float32x4_t)v97);
  float32x4_t v5 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL), v4), v2, v3);
  int8x16_t v6 = (int8x16_t)vaddq_f32(v5, v5);
  float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), v6, 0xCuLL);
  float32x4_t v8 = vaddq_f32(v2, vmulq_laneq_f32(v7, (float32x4_t)v97, 3));
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), v4), v7, v3);
  float32x4_t v93 = vaddq_f32(v8, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL));
  (*(void (**)(float32x4_t *__return_ptr))(**((void **)this + 4) + 40))(&v96);
  float32x4_t v10 = *((float32x4_t *)this + 4);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v97, v97), (int8x16_t)v97, 0xCuLL);
  float32x4_t v12 = vnegq_f32((float32x4_t)v97);
  float32x4_t v13 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL), v12), v10, v11);
  int8x16_t v14 = (int8x16_t)vaddq_f32(v13, v13);
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), v14, 0xCuLL);
  int8x16_t v16 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), v12), v15, v11);
  float32x4_t v17 = vaddq_f32(v96, vaddq_f32(vaddq_f32(v10, vmulq_laneq_f32(v15, (float32x4_t)v97, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), v16, 0xCuLL)));
  float32x4_t v18 = vmulq_f32(v93, v17);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0] >= 0.0)
  {
    float32x4_t v49 = vaddq_f32(v93, v17);
    int32x4_t v50 = (int32x4_t)vmulq_f32(v49, v49);
    v50.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1))).u32[0];
    float32x2_t v51 = vrsqrte_f32((float32x2_t)v50.u32[0]);
    float32x2_t v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v51, v51)));
    float32x4_t v53 = vmulq_n_f32(v49, vmul_f32(v52, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v52, v52))).f32[0]);
    int8x16_t v54 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), vnegq_f32(v93)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL));
    float32x4_t v48 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v54, (int32x4_t)v54), v54, 0xCuLL);
    float32x4_t v55 = vmulq_f32(v93, v53);
    v48.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).u32[0];
  }
  else
  {
    int32x4_t v19 = (int32x4_t)vmulq_f32(v93, v93);
    v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v19, 2), vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1))).u32[0];
    float32x2_t v20 = vrsqrte_f32((float32x2_t)v19.u32[0]);
    float32x2_t v21 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v20, v20)));
    v19.i32[0] = vmul_f32(v21, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v21, v21))).u32[0];
    int32x4_t v22 = (int32x4_t)vmulq_f32(v17, v17);
    v22.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v22, 2), vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v22.i8, 1))).u32[0];
    float32x2_t v23 = vrsqrte_f32((float32x2_t)v22.u32[0]);
    float32x2_t v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v23, v23)));
    float32x4_t v25 = vaddq_f32(vmulq_n_f32(v93, *(float *)v19.i32), vmulq_n_f32(v17, vmul_f32(v24, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v24, v24))).f32[0]));
    float32x4_t v26 = vmulq_f32(v25, v25);
    float v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
    if (v27 <= 1.4211e-14)
    {
      float32x4_t v56 = vabsq_f32(v93);
      float v57 = v56.f32[1];
      float v58 = v56.f32[2];
      if (v56.f32[0] > v56.f32[1] || v56.f32[0] > v56.f32[2])
      {
        float32x4_t v60 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL);
        if (v57 <= v58)
        {
          float32x4_t v61 = vmulq_f32(v93, (float32x4_t)xmmword_23437C090);
          float32x4_t v62 = (float32x4_t)xmmword_23435FD60;
        }
        else
        {
          float32x4_t v61 = vmulq_f32(v93, (float32x4_t)xmmword_23437C0A0);
          float32x4_t v62 = (float32x4_t)xmmword_23435FD80;
        }
      }
      else
      {
        float32x4_t v60 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL);
        float32x4_t v61 = vmulq_f32(v93, (float32x4_t)xmmword_23437C080);
        float32x4_t v62 = (float32x4_t)xmmword_23435FD50;
      }
      float32x4_t v63 = vmlaq_f32(v61, v62, v60);
      float32x4_t v64 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL);
      int32x4_t v65 = (int32x4_t)vmulq_f32(v63, v63);
      v65.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v65.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v65, 2), *(float32x2_t *)v65.i8)).u32[0];
      float32x2_t v66 = vrsqrte_f32((float32x2_t)v65.u32[0]);
      float32x2_t v67 = vmul_f32(v66, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v66, v66)));
      float32x4_t v48 = vmulq_n_f32(v64, vmul_f32(v67, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v67, v67))).f32[0]);
      v48.i32[3] = 0;
    }
    else
    {
      float v28 = v27;
      float32x2_t v29 = vrsqrte_f32((float32x2_t)LODWORD(v27));
      float32x2_t v30 = vmul_f32(v29, vrsqrts_f32((float32x2_t)LODWORD(v28), vmul_f32(v29, v29)));
      float32x4_t v31 = vmulq_n_f32(v25, vmul_f32(v30, vrsqrts_f32((float32x2_t)LODWORD(v28), vmul_f32(v30, v30))).f32[0]);
      float32x4_t v32 = vaddq_f32(v93, v31);
      int32x4_t v33 = (int32x4_t)vmulq_f32(v32, v32);
      v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
      float32x2_t v34 = vrsqrte_f32((float32x2_t)v33.u32[0]);
      float32x2_t v35 = vmul_f32(v34, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v34, v34)));
      float32x4_t v36 = vmulq_n_f32(v32, vmul_f32(v35, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v35, v35))).f32[0]);
      float32x4_t v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL), vnegq_f32(v93)), v36, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL));
      float32x4_t v38 = vmulq_f32(v93, v36);
      float32x4_t v39 = vaddq_f32(v17, v31);
      int32x4_t v40 = (int32x4_t)vmulq_f32(v39, v39);
      v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v40, 2), vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1))).u32[0];
      *(float32x2_t *)v33.i8 = vrsqrte_f32((float32x2_t)v40.u32[0]);
      *(float32x2_t *)v33.i8 = vmul_f32(*(float32x2_t *)v33.i8, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v33.i8)));
      float32x4_t v41 = vmulq_n_f32(v39, vmul_f32(*(float32x2_t *)v33.i8, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v33.i8))).f32[0]);
      int8x16_t v42 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int8x16_t)v41, 0xCuLL), vnegq_f32(v31)), v41, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL));
      float32x4_t v43 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), v42, 0xCuLL);
      float32x4_t v44 = vmulq_f32(v31, v41);
      v43.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).u32[0];
      int8x16_t v45 = (int8x16_t)vnegq_f32(v43);
      int8x16_t v46 = (int8x16_t)vtrn2q_s32((int32x4_t)v43, vtrn1q_s32((int32x4_t)v43, (int32x4_t)v45));
      float32x4_t v47 = (float32x4_t)vrev64q_s32((int32x4_t)v43);
      v47.i32[0] = v45.i32[1];
      v47.i32[3] = v45.i32[2];
      float32x4_t v48 = vaddq_f32(vmlaq_lane_f32(vmulq_n_f32(v43, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]), v47, *(float32x2_t *)v37.f32, 1), vmlaq_laneq_f32(vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)v43, v45, 8uLL), v37.f32[0]), (float32x4_t)vextq_s8(v46, v46, 8uLL), v37, 2));
    }
  }
  float32x4_t v94 = v48;
  float v68 = v48.f32[3];
  float v69 = fabsf(v48.f32[3]);
  if (v69 <= 1.0 || fabsf(v69 + -1.0) < (float)((float)((float)(v69 + 1.0) + 1.0) * 0.00001))
  {
    if (v48.f32[3] > 1.0) {
      float v68 = 1.0;
    }
    if (v68 < -1.0) {
      float v68 = -1.0;
    }
    float v71 = acosf(v68);
    float v70 = v71 + v71;
  }
  else
  {
    float v70 = NAN;
  }
  if (fabsf(v70) >= 0.000001)
  {
    *((_DWORD *)this + 22) = 0;
    float v72 = *((float *)this + 20);
    if (v70 <= v72
      || (float v73 = *((float *)this + 23), v73 <= 0.000001)
      || (float v74 = (float)(v70 - v72) / v73, *((float *)this + 22) = v74, v74 <= 1.0))
    {
      uint64_t v75 = (_DWORD *)*((void *)this + 3);
      int v76 = v75[52];
      float v77 = 0.0;
      int32x2_t v78 = 0;
      if (v76 == 2) {
        v78.i32[0] = v75[48];
      }
      uint64_t v79 = *((void *)this + 4);
      int v80 = *(_DWORD *)(v79 + 208);
      if (v80 == 2) {
        float v77 = *(float *)(v79 + 192);
      }
      float v81 = *(float *)v78.i32 + v77;
      if ((float)(*(float *)v78.i32 + v77) != 0.0)
      {
        float v82 = -(float)(*((float *)this + 21) * (float)(v70 - v72));
        float32x4_t v83 = vmulq_f32(v94, v94);
        LODWORD(v84) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1))).u32[0];
        float32x4_t v85 = 0uLL;
        if (fabsf(v84) >= 1.0e-10)
        {
          float v86 = v84;
          float32x2_t v87 = vrsqrte_f32((float32x2_t)LODWORD(v84));
          float32x2_t v88 = vmul_f32(v87, vrsqrts_f32((float32x2_t)LODWORD(v86), vmul_f32(v87, v87)));
          float32x4_t v85 = vmulq_n_f32(v94, vmul_f32(v88, vrsqrts_f32((float32x2_t)LODWORD(v86), vmul_f32(v88, v88))).f32[0]);
        }
        float32x4_t v89 = vmulq_n_f32(v85, v82);
        float v90 = v77 / v81;
        if (v77 == 0.0) {
          float v90 = 1.0;
        }
        float32x4_t v91 = vmulq_n_f32(v89, v90);
        float v92 = *(float *)v78.i32 / v81;
        if (*(float *)v78.i32 == 0.0) {
          *(float *)v78.i32 = 1.0;
        }
        else {
          *(float *)v78.i32 = v92;
        }
        float32x4_t v95 = vmulq_f32(v89, vnegq_f32((float32x4_t)vdupq_lane_s32(v78, 0)));
        float32x4_t v96 = v91;
        if (v76 == 2)
        {
          (*(void (**)(_DWORD *, float32x4_t *, void))(*(void *)v75 + 392))(v75, &v96, 0);
          uint64_t v79 = *((void *)this + 4);
          int v80 = *(_DWORD *)(v79 + 208);
        }
        if (v80 == 2) {
          (*(void (**)(uint64_t, float32x4_t *, void))(*(void *)v79 + 392))(v79, &v95, 0);
        }
      }
    }
    else if (*((unsigned char *)this + 16))
    {
      *((unsigned char *)this + 16) = 0;
      (*(void (**)(re::AngularSpring *))(*(void *)this + 32))(this);
    }
  }
}

void re::AngularSpring::~AngularSpring(re::AngularSpring *this)
{
}

uint64_t re::AngularSpring::type(re::AngularSpring *this)
{
  return 6;
}

float WGLComputeFalloff(int a1, uint64_t a2, double a3, float a4)
{
  float v6 = *(float *)&a3;
  LODWORD(a3) = 1.0;
  if (v6 > 0.0)
  {
    HIDWORD(v7) = 0;
    LODWORD(a3) = 1.0;
    *(float *)&double v7 = 1.0 - fminf(fmaxf(a4 / v6, 0.0), 1.0);
    switch(a1)
    {
      case 0:
        return *(float *)&a3;
      case 1:
        LODWORD(a3) = LODWORD(v7);
        return *(float *)&a3;
      case 2:
        *(float *)&a3 = *(float *)&v7 * *(float *)&v7;
        return *(float *)&a3;
      case 3:
        float v8 = *(float *)&v7 * *(float *)&v7;
        goto LABEL_10;
      case 4:
        float v9 = *(float *)&v7 * *(float *)&v7;
        goto LABEL_9;
      case 5:
        float v9 = *(float *)&v7 * (float)(*(float *)&v7 * *(float *)&v7);
LABEL_9:
        float v8 = *(float *)&v7 * v9;
LABEL_10:
        *(float *)&a3 = *(float *)&v7 * v8;
        break;
      default:
        re::internal::assertLog((re::internal *)4, a2, a3, v7, "assertion failure: '%s' (%s:line %i) Unexpected falloff type.", "!\"Unreachable code\"", "WGLComputeFalloff", 32, v4, v5);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233DC0380);
    }
  }
  return *(float *)&a3;
}

void *re::PhysicsFactory::init(re::PhysicsFactory *this, re::CollisionFactory *a2)
{
  float32x4_t v3 = re::globalAllocators(this);
  re::PhysicsFactory::m_defaultAllocator = v3[2];
  uint64_t v4 = re::globalAllocators((re *)v3);
  uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 48, 8);
  double result = re::PhysXPhysicsFactory::PhysXPhysicsFactory(v5, (uint64_t)this, v6, v7);
  re::PhysicsFactory::m_defaultFactory = (uint64_t)result;
  return result;
}

re *re::internal::destroyPersistent<re::PhysicsFactory>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

double WGLGoalComputeLinearForce(float32x2_t *a1, uint64_t a2, float32x4_t a3, double a4, float32x4_t a5, float32x4_t a6)
{
  float v6 = a1[6].f32[0];
  double v7 = 0.0;
  if (v6 > 0.0)
  {
    float32x4_t v8 = vmulq_f32(a6, (float32x4_t)xmmword_23440B6C0);
    int8x16_t v9 = (int8x16_t)vnegq_f32(v8);
    int8x16_t v10 = (int8x16_t)vtrn2q_s32((int32x4_t)v8, vtrn1q_s32((int32x4_t)v8, (int32x4_t)v9));
    float32x4_t v11 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v8, v9, 8uLL), *a1, 1), (float32x4_t)vextq_s8(v10, v10, 8uLL), COERCE_FLOAT(*(_OWORD *)a1->f32));
    float32x4_t v12 = (float32x4_t)vrev64q_s32((int32x4_t)v8);
    v12.i32[0] = v9.i32[1];
    v12.i32[3] = v9.i32[2];
    float32x4_t v13 = vmlaq_laneq_f32(v11, v12, *(float32x4_t *)a1->f32, 2);
    int8x16_t v14 = (int8x16_t)vnegq_f32(v13);
    int8x16_t v15 = (int8x16_t)vtrn2q_s32((int32x4_t)v13, vtrn1q_s32((int32x4_t)v13, (int32x4_t)v14));
    float32x4_t v16 = (float32x4_t)vrev64q_s32((int32x4_t)v13);
    v16.i32[0] = v14.i32[1];
    v16.i32[3] = v14.i32[2];
    float32x4_t v19 = vsubq_f32(vaddq_f32(a5, vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v13, a6, 3), v16, a6, 2), vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v13, v14, 8uLL), *(float32x2_t *)a6.f32, 1), (float32x4_t)vextq_s8(v15, v15, 8uLL), a6.f32[0]))), a3);
    a3.i32[0] = a1[7].i32[1];
    float32x4_t v17 = vmulq_f32(v19, v19);
    *(void *)&double v7 = vmulq_n_f32(v19, v6* WGLComputeFalloff(a1[10].i32[1], a2, *(double *)a3.i64, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]))).u64[0];
  }
  return v7;
}

double WGLGoalComputeAngularTorque(float32x4_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float v6 = a1[3].f32[1];
  double v7 = 0.0;
  if (v6 > 0.0)
  {
    float32x4_t v9 = a1[1];
    int8x16_t v10 = (int8x16_t)vnegq_f32(v9);
    int8x16_t v11 = (int8x16_t)vtrn2q_s32((int32x4_t)v9, vtrn1q_s32((int32x4_t)v9, (int32x4_t)v10));
    float32x4_t v12 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v9, v10, 8uLL), *(float32x2_t *)a5.f32, 1), (float32x4_t)vextq_s8(v11, v11, 8uLL), a5.f32[0]);
    float32x4_t v13 = (float32x4_t)vrev64q_s32((int32x4_t)v9);
    v13.i32[0] = v10.i32[1];
    v13.i32[3] = v10.i32[2];
    float32x4_t v14 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v9, a5, 3), v13, a5, 2), v12);
    int8x16_t v15 = (int8x16_t)vmulq_f32(v14, v14);
    *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
    v15.i32[0] = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.i8, 1)).u32[0];
    *(float32x2_t *)v13.f32 = vrecpe_f32((float32x2_t)v15.u32[0]);
    *(float32x2_t *)v13.f32 = vmul_f32(*(float32x2_t *)v13.f32, vrecps_f32((float32x2_t)v15.u32[0], *(float32x2_t *)v13.f32));
    float32x4_t v16 = vmulq_n_f32(vmulq_f32(v14, (float32x4_t)xmmword_23440B6C0), vmul_f32(*(float32x2_t *)v13.f32, vrecps_f32((float32x2_t)v15.u32[0], *(float32x2_t *)v13.f32)).f32[0]);
    int8x16_t v17 = (int8x16_t)vnegq_f32(v16);
    int8x16_t v18 = (int8x16_t)vtrn2q_s32((int32x4_t)v16, vtrn1q_s32((int32x4_t)v16, (int32x4_t)v17));
    float32x4_t v19 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v16, v17, 8uLL), *(float32x2_t *)a3.f32, 1), (float32x4_t)vextq_s8(v18, v18, 8uLL), a3.f32[0]);
    float32x4_t v20 = (float32x4_t)vrev64q_s32((int32x4_t)v16);
    v20.i32[0] = v17.i32[1];
    v20.i32[3] = v17.i32[2];
    float32x4_t v21 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v16, a3, 3), v20, a3, 2), v19);
    int8x16_t v22 = (int8x16_t)vmulq_f32(v21, v21);
    float32x2_t v23 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
    float32x4_t v47 = a5;
    if (vaddv_f32(v23) == 0.0)
    {
      float32x4_t v24 = (float32x4_t)xmmword_23435FBB0;
    }
    else
    {
      unsigned __int32 v25 = vadd_f32(v23, (float32x2_t)vdup_lane_s32((int32x2_t)v23, 1)).u32[0];
      float32x2_t v26 = vrsqrte_f32((float32x2_t)v25);
      float32x2_t v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)v25, vmul_f32(v26, v26)));
      float32x4_t v24 = vmulq_n_f32(v21, vmul_f32(v27, vrsqrts_f32((float32x2_t)v25, vmul_f32(v27, v27))).f32[0]);
    }
    float32x4_t v28 = vmulq_f32(v24, v24);
    float32x4_t v44 = *a1;
    LODWORD(v45) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).u32[0];
    float32x4_t v46 = v24;
    *(float *)&double v30 = atan2f(sqrtf(v45), v24.f32[3]);
    *(float *)&double v30 = *(float *)&v30 + *(float *)&v30;
    double v7 = 0.0;
    if (*(float *)&v30 != 0.0)
    {
      float32x4_t v31 = vmulq_f32(v47, (float32x4_t)xmmword_23440B6C0);
      int8x16_t v32 = (int8x16_t)vnegq_f32(v31);
      int8x16_t v33 = (int8x16_t)vtrn2q_s32((int32x4_t)v31, vtrn1q_s32((int32x4_t)v31, (int32x4_t)v32));
      float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)v31, v32, 8uLL);
      float32x4_t v35 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
      v35.i32[0] = v32.i32[1];
      v35.i32[3] = v32.i32[2];
      float32x4_t v36 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v34, *(float32x2_t *)v44.f32, 1), (float32x4_t)vextq_s8(v33, v33, 8uLL), v44.f32[0]), v35, v44, 2);
      int8x16_t v37 = (int8x16_t)vnegq_f32(v36);
      float32x4_t v38 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      int8x16_t v39 = (int8x16_t)vtrn2q_s32((int32x4_t)v36, vtrn1q_s32((int32x4_t)v36, (int32x4_t)v37));
      v38.i32[0] = v37.i32[1];
      v38.i32[3] = v37.i32[2];
      float32x4_t v40 = vsubq_f32(vaddq_f32(a4, vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v36, v47, 3), v38, v47, 2), vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v36, v37, 8uLL), *(float32x2_t *)v47.f32, 1), (float32x4_t)vextq_s8(v39, v39, 8uLL), v47.f32[0]))), a2);
      *(float32x2_t *)v36.f32 = vrsqrte_f32((float32x2_t)LODWORD(v45));
      *(float32x2_t *)v36.f32 = vmul_f32(*(float32x2_t *)v36.f32, vrsqrts_f32((float32x2_t)LODWORD(v45), vmul_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v36.f32)));
      float32x4_t v51 = vmulq_n_f32(v46, vmul_f32(*(float32x2_t *)v36.f32, vrsqrts_f32((float32x2_t)LODWORD(v45), vmul_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v36.f32))).f32[0]);
      v38.f32[0] = 6.28318531 - *(float *)&v30;
      float v41 = -v38.f32[0];
      if (*(float *)&v30 > 3.14159265) {
        *(float *)&double v30 = v41;
      }
      float v49 = *(float *)&v30;
      LODWORD(v3re::InputManager::notify(8, 0, 0, 0) = a1[3].i32[3];
      float32x4_t v42 = vmulq_f32(v40, v40);
      *(void *)&double v7 = vmulq_n_f32(vmulq_n_f32(v51, v49), v6* WGLComputeFalloff(a1[5].i32[1], v29, v30, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0]))).u64[0];
    }
  }
  return v7;
}

void *re::introspect_MotionType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      int8x16_t v10 = re::introspectionAllocator(v9);
      int8x16_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)int8x16_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Static";
      re::introspect_MotionType(BOOL)::enumAttributes = (uint64_t)v11;
      float32x4_t v12 = re::introspectionAllocator(v11);
      float32x4_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)float32x4_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Kinematic";
      qword_2687A1610 = (uint64_t)v13;
      float32x4_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "Dynamic";
      qword_2687A1618 = v15;
    }
  }
  {
    float32x4_t v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_MotionType(BOOL)::info, "MotionType", 4, 4, 1, 1);
    *(void *)float32x4_t v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::introspect_MotionType(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::introspect_MotionType(BOOL)::isInitialized) {
      return &re::introspect_MotionType(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::introspect_MotionType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::introspect_MotionType(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::introspect_MotionType(BOOL)::isInitialized)
    {
LABEL_9:
      double v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::introspect_MotionType(BOOL)::info;
    }
  }
  re::introspect_MotionType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_MotionType(BOOL)::info, a2);
  v17[0] = 0xF296097B3A860;
  v17[1] = (uint64_t)"MotionType";
  xmmword_2687A1648 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::introspect_MotionType(BOOL)::info;
}

uint64_t *re::introspect_PhysicsJointType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99280, memory_order_acquire) & 1) == 0)
  {
    float32x4_t v31 = (re *)__cxa_guard_acquire(&qword_26AF99280);
    if (v31)
    {
      int8x16_t v32 = re::introspectionAllocator(v31);
      int8x16_t v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)int8x16_t v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Unknown";
      qword_26AF99290 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "FixedJoint";
      qword_26AF99298 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      int8x16_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)int8x16_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "SphericalJoint";
      qword_26AF992A0 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      int8x16_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)int8x16_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "RevoluteJoint";
      qword_26AF992A8 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "PrismaticJoint";
      qword_26AF992B0 = (uint64_t)v41;
      float32x4_t v42 = re::introspectionAllocator(v41);
      float32x4_t v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)float32x4_t v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "DistanceJoint";
      qword_26AF992B8 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      float v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)float v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "CustomJoint";
      qword_26AF992C0 = (uint64_t)v45;
      float32x4_t v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = 7;
      *(void *)(v47 + 16) = "TwistSwingJoint";
      qword_26AF992C8 = v47;
      __cxa_guard_release(&qword_26AF99280);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99288, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99288))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF992D0, "PhysicsJointType", 4, 4, 1, 1);
    qword_26AF992D0 = (uint64_t)&unk_26E715E00;
    qword_26AF99310 = (uint64_t)&re::introspect_PhysicsJointType(BOOL)::enumTable;
    dword_26AF992E0 = 9;
    __cxa_guard_release(&qword_26AF99288);
  }
  if (v2)
  {
    if (_MergedGlobals_427) {
      return &qword_26AF992D0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    char v3 = _MergedGlobals_427;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    if (v3) {
      return &qword_26AF992D0;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_427)
    {
LABEL_34:
      uint64_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF992D0;
    }
  }
  _MergedGlobals_427 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF992D0, a2);
  uint64_t v49 = 0x3A6AA135739A28FALL;
  int32x4_t v50 = "PhysicsJointType";
  v53[0] = 0x607DD0F01DCLL;
  v53[1] = "uint32_t";
  double v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v53);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v53);
    float32x4_t v9 = (unsigned int *)qword_26AF99310;
    v52[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v53, &v49, 1, 1, (uint64_t)v52);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          float32x4_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                int8x16_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v51.int var0 = 2 * v15;
          v51.uint64_t var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v53, v19, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            int8x16_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  unsigned __int32 v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v51.int var0 = 2 * v23;
            v51.uint64_t var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v53, v27, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v53, v28);
    xmmword_26AF992F0 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)&v49);
    if (v2) {
      return &qword_26AF992D0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v53);
  re::internal::assertLog((re::internal *)5, v48, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "PhysicsJointType", v49, v50);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

double re::DistanceJoint::DistanceJoint(uint64_t a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = "";
  *(void *)(a1 + 4re::InputManager::notify(8, 0, 0, 0) = a2;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26E716E90;
  double result = 6.08244611e77;
  *(void *)(a1 + 56) = 0x501502F900000000;
  *(_DWORD *)(a1 + 64) = 1008981770;
  return result;
}

uint64_t re::DistanceJoint::setDistanceRange(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)(a1 + 56) = *a2;
  float v5 = *((float *)&v3 + 1);
  float v4 = *(float *)&v3;
  if (*(float *)&v3 <= *((float *)&v3 + 1))
  {
    if (*(float *)&v3 > 1.0e10) {
      float v4 = 1.0e10;
    }
    if (v4 < 0.0) {
      float v4 = 0.0;
    }
    if (*((float *)&v3 + 1) > 1.0e10) {
      float v5 = 1.0e10;
    }
    if (v5 < 0.0) {
      float v5 = 0.0;
    }
    *(float *)(a1 + 56) = v4;
    *(float *)(a1 + 6re::InputManager::notify(8, 0, 0, 0) = v5;
  }
  if (v4 > v5)
  {
    *(float *)(a1 + 56) = v5;
    *(float *)(a1 + 6re::InputManager::notify(8, 0, 0, 0) = v4;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
  float v6 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 64);
  return v6(a1);
}

void re::introspect_REPhysicsForceMode(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99320, memory_order_acquire) & 1) == 0)
  {
    char v24 = (re *)__cxa_guard_acquire(&qword_26AF99320);
    if (v24)
    {
      unsigned __int32 v25 = re::introspectionAllocator(v24);
      int v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)int v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "REPhysicsForceModeForce";
      qword_26AF993A8 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "REPhysicsForceModeImpulse";
      qword_26AF993B0 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      double v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)double v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "REPhysicsForceModeVelocity";
      qword_26AF993B8 = (uint64_t)v30;
      float32x4_t v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "REPhysicsForceModeAcceleration";
      qword_26AF993C0 = v32;
      __cxa_guard_release(&qword_26AF99320);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99328, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99328))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF99478, "REPhysicsForceMode", 1, 1, 1, 1);
    qword_26AF99478 = (uint64_t)&unk_26E715E00;
    qword_26AF994B8 = (uint64_t)&re::introspect_REPhysicsForceMode(BOOL)::enumTable;
    dword_26AF99488 = 9;
    __cxa_guard_release(&qword_26AF99328);
  }
  if ((_MergedGlobals_428 & 1) == 0)
  {
    _MergedGlobals_428 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF99478, a2);
    uint64_t v34 = 0xD906E491CB7559F4;
    float32x4_t v35 = "REPhysicsForceMode";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    int v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      float v4 = (unsigned int *)qword_26AF994B8;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            float32x4_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  float32x4_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.int var0 = 2 * v10;
            v36.uint64_t var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              int8x16_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    float32x4_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.int var0 = 2 * v18;
              v36.uint64_t var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF99498 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "REPhysicsForceMode", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_TimedForceFalloff(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99330, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99330))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF994C0, "TimedForceFalloff");
    __cxa_guard_release(&qword_26AF99330);
  }
  return &unk_26AF994C0;
}

void re::initInfo_TimedForceFalloff(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x49AF4234DC13BEC0;
  v14[1] = "TimedForceFalloff";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99338, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&qword_26AF99338);
    if (v4)
    {
      float v5 = re::introspectionAllocator(v4);
      double v7 = re::introspect_double((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "duration";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99380 = v8;
      float32x4_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "rate";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99388 = v12;
      __cxa_guard_release(&qword_26AF99338);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF99380;
  *((void *)this + 9) = re::internal::defaultConstruct<re::TimedForceFalloff>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::TimedForceFalloff>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::TimedForceFalloff>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::TimedForceFalloff>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void re::internal::defaultConstruct<re::TimedForceFalloff>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0x3FF0000000000000;
  *(_DWORD *)(a3 + 8) = 1065353216;
}

uint64_t re::internal::defaultConstructV2<re::TimedForceFalloff>(uint64_t result)
{
  *(void *)double result = 0x3FF0000000000000;
  *(_DWORD *)(result + 8) = 1065353216;
  return result;
}

void *re::allocInfo_SpatialForceFalloff(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99348, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99348))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99538, "SpatialForceFalloff");
    __cxa_guard_release(&qword_26AF99348);
  }
  return &unk_26AF99538;
}

void re::initInfo_SpatialForceFalloff(re *this, re::IntrospectionBase *a2)
{
  v18[0] = 0xC60D12D4D665635ALL;
  v18[1] = "SpatialForceFalloff";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99350, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&qword_26AF99350);
    if (v4)
    {
      float v5 = re::introspectionAllocator(v4);
      double v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "radius";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99390 = v8;
      float32x4_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "distanceOffset";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99398 = v12;
      long long v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "rate";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF993A0 = v16;
      __cxa_guard_release(&qword_26AF99350);
    }
  }
  *((void *)this + 2) = 0xC00000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF99390;
  *((void *)this + 9) = re::internal::defaultConstruct<re::SpatialForceFalloff>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::SpatialForceFalloff>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::SpatialForceFalloff>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::SpatialForceFalloff>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

double re::internal::defaultConstruct<re::SpatialForceFalloff>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 1065353216;
  *(void *)a3 = 1065353216;
  *(_DWORD *)(a3 + 8) = 1065353216;
  return result;
}

double re::internal::defaultConstructV2<re::SpatialForceFalloff>(uint64_t a1)
{
  *(void *)&double result = 1065353216;
  *(void *)a1 = 1065353216;
  *(_DWORD *)(a1 + 8) = 1065353216;
  return result;
}

void *re::allocInfo_ForceEffectDefinition(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99360))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF995B0, "ForceEffectDefinition");
    __cxa_guard_release(&qword_26AF99360);
  }
  return &unk_26AF995B0;
}

void re::initInfo_ForceEffectDefinition(re *this, re::IntrospectionBase *a2)
{
  v24[0] = 0xDC17E0035793655ELL;
  v24[1] = "ForceEffectDefinition";
  re::StringID::destroyString((re::StringID *)v24);
  *((_OWORD *)this + 2) = v25;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99368, memory_order_acquire) & 1) == 0)
  {
    float v4 = (re *)__cxa_guard_acquire(&qword_26AF99368);
    if (v4)
    {
      float v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_PoseF((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "pose";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF993C8 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_float((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "strength";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x2000000002;
      *(_DWORD *)(v11 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF993D0 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_uint32_t((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "mask";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x2400000003;
      *(_DWORD *)(v15 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF993D8 = v15;
      uint64_t v16 = (re *)re::introspectionAllocator((re *)v15);
      re::introspect_REPhysicsForceMode(v16, v17);
      uint64_t v18 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "forceMode";
      *(void *)(v18 + 16) = &qword_26AF99478;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0x2800000004;
      *(_DWORD *)(v18 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF993E0 = v18;
      long long v19 = (re *)re::introspectionAllocator((re *)v18);
      re::IntrospectionInfo<re::Optional<re::SpatialForceFalloff>>::get(v19);
      uint64_t v20 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v19 + 32))(v19, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "spatialForceFalloff";
      *(void *)(v20 + 16) = qword_26AF993F8;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x2C00000005;
      *(_DWORD *)(v20 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF993E8 = v20;
      int v21 = (re *)re::introspectionAllocator((re *)v20);
      re::IntrospectionInfo<re::Optional<re::TimedForceFalloff>>::get(v21);
      uint64_t v22 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v22 = 1;
      *(void *)(v22 + 8) = "timedForceFalloff";
      *(void *)(v22 + 16) = &qword_26AF99438;
      *(void *)(v22 + 24) = 0;
      *(void *)(v22 + 32) = 0x4000000006;
      *(_DWORD *)(v22 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
      *(void *)(v22 + 48) = 0;
      *(void *)(v22 + 56) = 0;
      *(_DWORD *)(v22 + 64) = 0;
      qword_26AF993F0 = v22;
      __cxa_guard_release(&qword_26AF99368);
    }
  }
  *((void *)this + 2) = 0xB000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF993C8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ForceEffectDefinition>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 1re::InputManager::notify(8, 0, 0, 0) = re::internal::defaultDestruct<re::ForceEffectDefinition>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ForceEffectDefinition>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ForceEffectDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  long long v23 = v25;
}

void re::IntrospectionInfo<re::Optional<re::SpatialForceFalloff>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99370, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF99370);
    if (a1)
    {
      re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)qword_26AF993F8);
      qword_26AF993F8[0] = (uint64_t)&unk_26E716F60;
      __cxa_guard_release(&qword_26AF99370);
    }
  }
  if ((byte_26AF99319 & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF99358;
    if (qword_26AF99358
      || (uint64_t v1 = re::allocInfo_SpatialForceFalloff(a1),
          qword_26AF99358 = (uint64_t)v1,
          re::initInfo_SpatialForceFalloff((re *)v1, v2),
          (byte_26AF99319 & 1) == 0))
    {
      byte_26AF99319 = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_26AF993F8, 0);
      unk_26AF99408 = 0x100000000DLL;
      unk_26AF99410 = v3;
      unk_26AF99414 = 0;
      unk_26AF99418 = 0;
      qword_26AF99420 = 0xFFFFFFFFLL;
      qword_26AF99428 = (uint64_t)v1;
      unk_26AF99430 = 0;
      qword_26AF993F8[0] = (uint64_t)&unk_26E716F60;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)qword_26AF993F8, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginOptionalType((uint64_t)&v14, v12, 0x10uLL, 4uLL, &v13);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v14, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      unk_26AF99418 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::IntrospectionInfo<re::Optional<re::TimedForceFalloff>>::get(re *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99378, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF99378);
    if (a1)
    {
      re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)&qword_26AF99438);
      qword_26AF99438 = (uint64_t)&unk_26E716FE0;
      __cxa_guard_release(&qword_26AF99378);
    }
  }
  if ((byte_26AF9931A & 1) == 0)
  {
    uint64_t v1 = (void *)qword_26AF99340;
    if (qword_26AF99340
      || (uint64_t v1 = re::allocInfo_TimedForceFalloff(a1),
          qword_26AF99340 = (uint64_t)v1,
          re::initInfo_TimedForceFalloff((re *)v1, v2),
          (byte_26AF9931A & 1) == 0))
    {
      byte_26AF9931A = 1;
      int v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF99438, 0);
      qword_26AF99448 = 0x180000000DLL;
      dword_26AF99450 = v3;
      word_26AF99454 = 0;
      *(void *)&xmmword_26AF99458 = 0;
      *((void *)&xmmword_26AF99458 + 1) = 0xFFFFFFFFLL;
      qword_26AF99468 = (uint64_t)v1;
      unk_26AF99470 = 0;
      qword_26AF99438 = (uint64_t)&unk_26E716FE0;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF99438, (const re::IntrospectionBase *)&v14);
      if (v15) {
        uint64_t v6 = *(const char **)&v16[7];
      }
      else {
        uint64_t v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      long long v11 = *((_OWORD *)v1 + 2);
      uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        uint64_t v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        long long v13 = v11;
        re::TypeBuilder::beginOptionalType((uint64_t)&v14, v12, 0x18uLL, 8uLL, &v13);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v14, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF99458 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

void re::internal::defaultConstruct<re::ForceEffectDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0x3F80000000000000;
  *(void *)(a3 + 32) = -3229614080;
  *(unsigned char *)(a3 + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(unsigned char *)(a3 + 44) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(void *)(a3 + 88) = 0;
  *(unsigned char *)(a3 + 152) = 0;
  *(unsigned char *)(a3 + 168) = 0;
  *(void *)(a3 + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(a3 + 128) = 0;
  *(unsigned char *)(a3 + 136) = 0;
}

uint64_t *re::internal::defaultDestruct<re::ForceEffectDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::unique_ptr<re::ForceEffectFunctionBase,std::function<void ()(re::ForceEffectFunctionBase*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(a3 + 88));
}

uint64_t re::internal::defaultConstructV2<re::ForceEffectDefinition>(uint64_t result)
{
  *(void *)double result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0x3F80000000000000;
  *(void *)(result + 32) = -3229614080;
  *(unsigned char *)(result + 4re::InputManager::notify(8, 0, 0, 0) = 0;
  *(unsigned char *)(result + 44) = 0;
  *(unsigned char *)(result + 64) = 0;
  *(void *)(result + 88) = 0;
  *(unsigned char *)(result + 152) = 0;
  *(unsigned char *)(result + 168) = 0;
  *(void *)(result + 12re::InputManager::notify(8, 0, 0, 0) = 0;
  *(void *)(result + 128) = 0;
  *(unsigned char *)(result + 136) = 0;
  return result;
}

uint64_t *re::internal::defaultDestructV2<re::ForceEffectDefinition>(uint64_t a1)
{
  return std::unique_ptr<re::ForceEffectFunctionBase,std::function<void ()(re::ForceEffectFunctionBase*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(a1 + 88));
}

uint64_t re::introspect_ForceEffectDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ForceEffectDefinition", (uint64_t (*)(re::internal *))re::allocInfo_ForceEffectDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_ForceEffectDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ForceEffectDefinition>, this);
}

void *re::ForceEffect::setSimulation(void *this, re::PhysicsSimulation *a2)
{
  int v2 = (re::PhysicsSimulation *)this[1];
  if (v2 != a2)
  {
    float v4 = this;
    if (v2) {
      this = (void *)(*(uint64_t (**)(void *))(*this + 48))(this);
    }
    v4[1] = a2;
    if (a2)
    {
      float v5 = *(uint64_t (**)(void *))(*v4 + 40);
      return (void *)v5(v4);
    }
  }
  return this;
}

uint64_t re::ForceEffectDefinition::advance(uint64_t this, float a2)
{
  if (*(void *)(this + 128) && *(unsigned char *)(this + 136) && *(unsigned char *)(this + 168))
  {
    double v2 = *(double *)(this + 160) + a2;
    if (*(unsigned char *)(this + 64))
    {
      double v3 = *(double *)(this + 144);
      double v4 = *(double *)(this + 72);
      if (v2 - v3 >= v4) {
        double v2 = v3 + v4;
      }
    }
    if (!*(unsigned char *)(this + 152)) {
      *(unsigned char *)(this + 152) = 1;
    }
    *(double *)(this + 16re::InputManager::notify(8, 0, 0, 0) = v2;
  }
  return this;
}

uint64_t re::ForceEffectFunctionRuntime::elementSize(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a2 > 15)
  {
    if (a2 != 16)
    {
      if (a2 == 64) {
        return 48;
      }
      if (a2 != 32) {
        return result;
      }
    }
    return 4;
  }
  switch(a2)
  {
    case 1:
    case 2:
    case 4:
    case 8:
      uint64_t result = 16;
      break;
    default:
      return result;
  }
  return result;
}