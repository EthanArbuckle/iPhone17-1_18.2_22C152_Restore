void re::ForceEffectFunctionRuntime::reserveInputBuffers(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  char v6;
  unint64_t v7;
  BOOL v8;

  if (a2)
  {
    v4 = a2;
    v5 = a1;
    v6 = 0;
    do
    {
      if (v4)
      {
        a1 = re::ForceEffectFunctionRuntime::elementSize(a1, 1 << v6);
        v7 = a1 * a3;
        if (v7 > 16 * *(void *)(v5 + 16)) {
          re::DynamicArray<re::Vector4<float>>::resize(v5, vcvtpd_u64_f64((double)v7 * 0.0625));
        }
      }
      v5 += 40;
      ++v6;
      v8 = v4 > 1;
      v4 >>= 1;
    }
    while (v8);
  }
}

void re::ForceEffectFunctionRuntime::reserveOutputBuffers(re::ForceEffectFunctionRuntime *this, unint64_t a2)
{
  uint64_t v4 = 0;
  size_t v5 = 16 * a2;
  char v6 = 1;
  do
  {
    char v7 = v6;
    if (*((void *)this + 5 * v4 + 42) < a2)
    {
      v8 = (void **)((char *)this + 40 * v4);
      re::DynamicArray<re::Vector3<float>>::resize((uint64_t)(v8 + 40), a2);
      bzero(v8[44], v5);
    }
    char v6 = 0;
    uint64_t v4 = 1;
  }
  while ((v7 & 1) != 0);
  uint64_t v9 = 0;
  char v10 = 1;
  do
  {
    char v11 = v10;
    if (*((void *)this + 5 * v9 + 52) < a2)
    {
      v12 = (void **)((char *)this + 40 * v9);
      re::DynamicArray<re::Vector3<float>>::resize((uint64_t)(v12 + 50), a2);
      bzero(v12[54], v5);
    }
    char v10 = 0;
    uint64_t v9 = 1;
  }
  while ((v11 & 1) != 0);
}

uint64_t re::CustomForceEffectFunction::compute(uint64_t result, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = result;
    result = *(void *)(*(void *)a2 + 40);
    if (result)
    {
      if (*(void *)(v2 + 8)) {
        return (*(uint64_t (**)(void))(*(void *)result + 16))();
      }
    }
  }
  return result;
}

void re::CustomForceEffectFunction::~CustomForceEffectFunction(re::CustomForceEffectFunction *this)
{
}

uint64_t re::CustomForceEffectFunction::type(re::CustomForceEffectFunction *this)
{
  return 11;
}

uint64_t re::CustomForceEffectFunction::userData(re::CustomForceEffectFunction *this)
{
  return *((void *)this + 1);
}

uint64_t re::CustomForceEffectFunction::inputs(re::CustomForceEffectFunction *this)
{
  return *((unsigned int *)this + 4);
}

void *re::IntrospectionOptional<re::SpatialForceFalloff>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::construct(uint64_t a1, unsigned char *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::SpatialForceFalloff>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(void *)(a2 + 4) = 1065353216;
    *(_DWORD *)(a2 + 12) = 1065353216;
  }
  else if (*(unsigned char *)a2)
  {
    *(unsigned char *)a2 = 0;
  }
}

uint64_t re::IntrospectionOptional<re::SpatialForceFalloff>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 4;
}

{
  return a2 + 4;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  int v2 = *a1;
  result = a1 + 4;
  if (!v2) {
    return 0;
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v4 = *a2;
    int v5 = *((_DWORD *)a2 + 2);
    int v2 = (void *)(result + 4);
    if (*(unsigned char *)result)
    {
      uint64_t v3 = *a2;
      *(_DWORD *)(result + 12) = *((_DWORD *)a2 + 2);
      *int v2 = v3;
    }
    else
    {
      *(unsigned char *)result = 1;
      *int v2 = v4;
      *(_DWORD *)(result + 12) = v5;
    }
  }
  else if (*(unsigned char *)result)
  {
    *(unsigned char *)result = 0;
  }
  return result;
}

void *re::IntrospectionOptional<re::TimedForceFalloff>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::TimedForceFalloff>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionOptional<re::TimedForceFalloff>::construct(uint64_t a1, unsigned char *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::TimedForceFalloff>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

void re::IntrospectionOptional<re::TimedForceFalloff>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (!*(unsigned char *)a2) {
      *(unsigned char *)a2 = 1;
    }
    *(void *)(a2 + 8) = 0x3FF0000000000000;
    *(_DWORD *)(a2 + 16) = 1065353216;
  }
  else if (*(unsigned char *)a2)
  {
    *(unsigned char *)a2 = 0;
  }
}

uint64_t re::IntrospectionOptional<re::TimedForceFalloff>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

{
  return a2 + 8;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  int v2 = *a1;
  result = a1 + 8;
  if (!v2) {
    return 0;
  }
  return result;
}

__n128 re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t a1, __n128 *a2)
{
  if (a2)
  {
    __n128 result = *a2;
    __n128 v5 = *a2;
    uint64_t v3 = (__n128 *)(a1 + 8);
    if (*(unsigned char *)a1)
    {
      unint64_t v4 = a2->n128_u64[0];
      *(_DWORD *)(a1 + 16) = a2->n128_u32[2];
      v3->n128_u64[0] = v4;
    }
    else
    {
      *(unsigned char *)a1 = 1;
      __n128 result = v5;
      *uint64_t v3 = v5;
    }
  }
  else if (*(unsigned char *)a1)
  {
    *(unsigned char *)a1 = 0;
  }
  return result;
}

void *re::allocInfo_PhysicsSolverIterations(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_429, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_429))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99648, "PhysicsSolverIterations");
    __cxa_guard_release(&_MergedGlobals_429);
  }
  return &unk_26AF99648;
}

void re::initInfo_PhysicsSolverIterations(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xAE83321A565603E0;
  v14[1] = "PhysicsSolverIterations";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99630, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99630);
    if (v4)
    {
      __n128 v5 = re::introspectionAllocator(v4);
      char v7 = re::introspect_uint32_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "positionIterations";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99638 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "velocityIterations";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99640 = v12;
      __cxa_guard_release(&qword_26AF99630);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF99638;
  *((void *)this + 9) = re::internal::defaultConstruct<re::PhysicsSolverIterations>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::PhysicsSolverIterations>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::PhysicsSolverIterations>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::PhysicsSolverIterations>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

double re::internal::defaultConstruct<re::PhysicsSolverIterations>(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)&double result = 0x100000006;
  *a3 = 0x100000006;
  return result;
}

double re::internal::defaultConstructV2<re::PhysicsSolverIterations>(void *a1)
{
  *(void *)&double result = 0x100000006;
  *a1 = 0x100000006;
  return result;
}

uint64_t re::introspect_PhysicsSolverIterations(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PhysicsSolverIterations", (uint64_t (*)(re::internal *))re::allocInfo_PhysicsSolverIterations, (re::IntrospectionBase *(*)(void))re::initInfo_PhysicsSolverIterations, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PhysicsSolverIterations>, this);
}

void re::RigidBody::setMotionType(uint64_t a1, unsigned int a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  unint64_t v4 = (re *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
  if (v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a2;
  }
  if (v5 == 2)
  {
    float v6 = fabsf(*(float *)(a1 + 192));
    if (v6 < 0.00001 || v6 == INFINITY) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
  }
  if (v5 != a2)
  {
    uint64_t v8 = *re::physicsLogObjects(v4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = "static";
      if (a2 == 1) {
        char v10 = "kinematic";
      }
      else {
        char v10 = "static";
      }
      if (a2 == 2) {
        char v10 = "dynamic";
      }
      if (v5 == 1) {
        uint64_t v9 = "kinematic";
      }
      if (v5 == 2) {
        uint64_t v9 = "dynamic";
      }
      int v15 = 136315394;
      v16 = v10;
      __int16 v17 = 2080;
      v18 = v9;
      _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "Physics body motion type \"%s\" was requested but is not supported for all of its colliders.  Dynamic motion is not supported for some colliders, such as ARKit mesh colliders.  Motion type \"%s\" will be used instead.", (uint8_t *)&v15, 0x16u);
    }
  }
  if (*(_DWORD *)(a1 + 208) != v5)
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 56);
    if (v11 && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 424))(a1))
    {
      uint64_t v12 = *(re::CollisionObject **)(a1 + 72);
      re::ContactSetCollection::remove((re::ContactSetCollection *)(*(void *)(v11 + 128) + 72), v12);
      (*(void (**)(void, re::CollisionObject *))(**(void **)(v11 + 128) + 200))(*(void *)(v11 + 128), v12);
      *((void *)v12 + 7) = 0;
    }
    *(_DWORD *)(a1 + 208) = v5;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 104))(a1, v5);
    uint64_t v13 = *(void *)(a1 + 72);
    if (*(void *)(v13 + 56) != v11)
    {
      uint64_t v14 = *(void *)(v11 + 128);
      *(void *)(v13 + 56) = v14;
      (*(void (**)(uint64_t))(*(void *)v14 + 192))(v14);
      if (v5 == 2) {
        (*(void (**)(uint64_t))(*(void *)a1 + 312))(a1);
      }
    }
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
  }
}

float32x4_t re::RigidBody::pose@<Q0>(float32x4_t *this@<X0>, float32x4_t *a2@<X8>)
{
  (*(void (**)(float32x4_t *__return_ptr))(this->i64[0] + 208))(&v30);
  float32x4_t v4 = this[9];
  _Q1 = this[10];
  int32x4_t v6 = (int32x4_t)vnegq_f32(_Q1);
  int32x4_t v7 = (int32x4_t)vnegq_f32(v4);
  float32x4_t v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  float32x4_t v9 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v7, v7), (int8x16_t)v7, 0xCuLL), _Q1), v8, v4);
  int32x4_t v10 = (int32x4_t)vaddq_f32(v9, v9);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL);
  int32x4_t v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), _Q1), v11, v8);
  float32x4_t v13 = vaddq_f32(vsubq_f32(vmulq_laneq_f32(v11, _Q1, 3), v4), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL));
  _Q3 = (int32x4_t)v31;
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), v31, 0xCuLL);
  float32x4_t v16 = vnegq_f32((float32x4_t)v31);
  float32x4_t v17 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL), v16), v13, v15);
  int32x4_t v18 = (int32x4_t)vaddq_f32(v17, v17);
  float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL);
  float32x4_t v20 = vaddq_f32(v13, vmulq_laneq_f32(v19, (float32x4_t)v31, 3));
  _Q17 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), v16), v19, v15);
  float32x4_t v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q17, _Q17), (int8x16_t)_Q17, 0xCuLL);
  _Q17.i32[0] = _Q1.i32[3];
  int32x4_t v23 = (int32x4_t)vmlsq_f32(vmulq_f32(v8, v16), v15, _Q1);
  float32x4_t v24 = vmlaq_laneq_f32(vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL), _Q1, (float32x4_t)v31, 3), (float32x4_t)v31, _Q1, 3);
  __asm { FMLA            S1, S17, V3.S[3] }
  v24.i32[3] = _Q1.i32[0];
  float32x4_t result = vaddq_f32(v30, vaddq_f32(v20, v22));
  *a2 = result;
  a2[1] = v24;
  return result;
}

double re::RigidBody::calculateVelocityAtWorldPoint(uint64_t a1, float32x4_t *a2)
{
  v4.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 216))(a1);
  v4.i64[1] = v5;
  float32x4_t v12 = v4;
  v6.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 232))(a1);
  v6.i64[1] = v7;
  float32x4_t v11 = v6;
  (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(void *)a1 + 208))(v13, a1);
  float32x4_t v8 = vsubq_f32(*a2, v13[0]);
  int32x4_t v9 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), vnegq_f32(v11)), v8, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL));
  *(void *)&double result = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL), v12).u64[0];
  return result;
}

double re::RigidBody::calculateVelocityAtLocalPoint(uint64_t a1, int32x4_t *a2)
{
  (*(void (**)(float32x4_t *__return_ptr))(*(void *)a1 + 40))(&v11);
  float32x4_t v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL);
  float32x4_t v5 = vnegq_f32((float32x4_t)v12);
  float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*a2, *a2), *(int8x16_t *)a2, 0xCuLL), v5), *(float32x4_t *)a2, v4);
  int8x16_t v7 = (int8x16_t)vaddq_f32(v6, v6);
  float32x4_t v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), v7, 0xCuLL);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v5), v8, v4);
  float32x4_t v13 = vaddq_f32(v11, vaddq_f32(vaddq_f32(*(float32x4_t *)a2, vmulq_laneq_f32(v8, (float32x4_t)v12, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL)));
  return re::RigidBody::calculateVelocityAtWorldPoint(a1, &v13);
}

uint64_t re::RigidBody::setCollisionObject(re::RigidBody *this, re::CollisionObject *a2)
{
  *((void *)this + 9) = a2;
  return (*(uint64_t (**)(void))(*(void *)this + 432))();
}

void re::RigidBody::setAttachedJointCount(re::RigidBody *this, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a2 < 0)
  {
    float32x4_t v5 = *re::physicsLogObjects(this);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    int v4 = 0;
    if (v6)
    {
      v7[0] = 67109120;
      v7[1] = a2;
      _os_log_impl(&dword_233120000, v5, OS_LOG_TYPE_DEFAULT, "RigidBody::setAttachedJointCount(cnt=%d): Negative reference count attempted to be set", (uint8_t *)v7, 8u);
      int v4 = 0;
    }
  }
  else
  {
    int v4 = a2;
  }
  *((_DWORD *)this + 77) = v4;
}

void re::RigidBody::poseDidChange(re::RigidBody *this, uint64_t a2)
{
}

uint64_t re::RigidBody::setSolverIterations(uint64_t result, void *a2)
{
  *(void *)(result + 212) = *a2;
  return result;
}

uint64_t re::Damping::didEnable(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  if (v1) {
    return updateRigidBodies(v1 + 80, *(float *)(this + 20), *(float *)(this + 24));
  }
  return this;
}

uint64_t updateRigidBodies(uint64_t result, float a2, float a3)
{
  uint64_t v3 = *(void *)(result + 24);
  if (v3)
  {
    uint64_t v6 = result;
    for (unint64_t i = 0; i != v3; ++i)
    {
      uint64_t v8 = re::ecs2::ComponentTypeRegistry::operator[](v6, i);
      float v9 = (*(float (**)(uint64_t))(*(void *)v8 + 320))(v8) + a2;
      v10.n128_f32[0] = (*(float (**)(uint64_t))(*(void *)v8 + 328))(v8) + a3;
      double result = (*(uint64_t (**)(uint64_t, float, __n128))(*(void *)v8 + 336))(v8, v9, v10);
    }
  }
  return result;
}

uint64_t re::Damping::didDisable(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  if (v1) {
    return updateRigidBodies(v1 + 80, -*(float *)(this + 20), -*(float *)(this + 24));
  }
  return this;
}

uint64_t re::Damping::didAddToSimulation(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    return updateRigidBodies(*(void *)(this + 8) + 80, *(float *)(this + 20), *(float *)(this + 24));
  }
  return this;
}

uint64_t re::Damping::willRemoveFromSimulation(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    return updateRigidBodies(*(void *)(this + 8) + 80, -*(float *)(this + 20), -*(float *)(this + 24));
  }
  return this;
}

uint64_t re::Damping::onRigidBodyAdded(uint64_t this, re::RigidBody *a2)
{
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v3 = this;
    float v4 = (*(float (**)(re::RigidBody *))(*(void *)a2 + 320))(a2) + *(float *)(this + 20);
    v5.n128_f32[0] = (*(float (**)(re::RigidBody *))(*(void *)a2 + 328))(a2) + *(float *)(v3 + 24);
    uint64_t v6 = *(uint64_t (**)(re::RigidBody *, __n128, __n128))(*(void *)a2 + 336);
    v7.n128_f32[0] = v4;
    return v6(a2, v7, v5);
  }
  return this;
}

uint64_t re::Damping::onRigidBodyRemoved(uint64_t this, re::RigidBody *a2)
{
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v3 = this;
    float v4 = (*(float (**)(re::RigidBody *))(*(void *)a2 + 320))(a2) - *(float *)(this + 20);
    v5.n128_f32[0] = (*(float (**)(re::RigidBody *))(*(void *)a2 + 328))(a2) - *(float *)(v3 + 24);
    uint64_t v6 = *(uint64_t (**)(re::RigidBody *, __n128, __n128))(*(void *)a2 + 336);
    v7.n128_f32[0] = v4;
    return v6(a2, v7, v5);
  }
  return this;
}

uint64_t re::Damping::setLinearDamping(uint64_t this, float a2)
{
  float v2 = *(float *)(this + 20);
  *(float *)(this + 20) = a2;
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 8);
    if (v4)
    {
      updateRigidBodies(v4 + 80, -v2, 0.0);
      uint64_t v5 = *(void *)(v3 + 8) + 80;
      float v6 = *(float *)(v3 + 20);
      return updateRigidBodies(v5, v6, 0.0);
    }
  }
  return this;
}

uint64_t re::Damping::setAngularDamping(uint64_t this, float a2)
{
  float v2 = *(float *)(this + 24);
  *(float *)(this + 24) = a2;
  if (*(unsigned char *)(this + 16))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 8);
    if (v4)
    {
      updateRigidBodies(v4 + 80, 0.0, -v2);
      uint64_t v5 = *(void *)(v3 + 8) + 80;
      float v6 = *(float *)(v3 + 24);
      return updateRigidBodies(v5, 0.0, v6);
    }
  }
  return this;
}

void re::Damping::~Damping(re::Damping *this)
{
}

uint64_t re::Damping::type(re::Damping *this)
{
  return 2;
}

int32x2_t re::BallSocketJoint::BallSocketJoint(int32x2_t *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  a1[3] = 0;
  a1[4] = (int32x2_t)"";
  a1[5] = (int32x2_t)a2;
  a1[6] = 0;
  *a1 = (int32x2_t)&unk_26E7172B8;
  int32x2_t result = vdup_n_s32(0x3FC90FDBu);
  a1[7] = result;
  return result;
}

uint64_t re::BallSocketJoint::type(re::BallSocketJoint *this)
{
  return 2;
}

uint64_t re::PhysXConstraintKernel::setCollisionEnabled(re::PhysXConstraintKernel *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 1) + 128))(*((void *)this + 1), 8, a2);
}

void re::PhysXConstraintKernel::~PhysXConstraintKernel(re::PhysXConstraintKernel *this)
{
  uint64_t v1 = (void (***)(void))*((void *)this + 1);
  if (v1) {
    (**v1)(v1);
  }
}

{
  void (***v1)(void);
  uint64_t vars8;

  uint64_t v1 = (void (***)(void))*((void *)this + 1);
  if (v1) {
    (**v1)(v1);
  }
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysXConstraintKernel::bodyA(re::PhysXConstraintKernel *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  (*(void (**)(void, uint64_t *, uint64_t *))(**((void **)this + 1) + 56))(*((void *)this + 1), &v3, &v2);
  if (v3) {
    return *(void *)(*(void *)(v3 + 16) + 16);
  }
  else {
    return 0;
  }
}

uint64_t re::PhysXConstraintKernel::bodyB(re::PhysXConstraintKernel *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  (*(void (**)(void, uint64_t *, uint64_t *))(**((void **)this + 1) + 56))(*((void *)this + 1), &v3, &v2);
  if (v2) {
    return *(void *)(*(void *)(v2 + 16) + 16);
  }
  else {
    return 0;
  }
}

void *re::PhysXConstraintKernel::localAnchorPoseA@<X0>(re::PhysXConstraintKernel *this@<X0>, void *a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(**((void **)this + 1) + 72))(v4);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

void *re::PhysXConstraintKernel::localAnchorPoseB@<X0>(re::PhysXConstraintKernel *this@<X0>, void *a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(**((void **)this + 1) + 72))(v4);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

uint64_t re::PhysXConstraintKernel::collisionEnabled(re::PhysXConstraintKernel *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 136))(&var2);
  return ((unsigned __int16)var2 >> 3) & 1;
}

float re::internal::WGL_noise(unsigned int a1, __n128 a2)
{
  float v3 = fmodf(fabsf(a2.n128_f32[0]), 1.0) * 512.0;
  float v4 = fmodf(fabsf(a2.n128_f32[1]), 1.0) * 512.0;
  float v5 = fmodf(fabsf(a2.n128_f32[2]), 1.0) * 512.0;
  int32x2_t v6 = vdup_n_s32(a1);
  float v7 = 0.0;
  float v8 = 64.0;
  int32x2_t v9 = vdup_n_s32(0x3D73u);
  int32x2_t v10 = vdup_n_s32(0xC0AE5u);
  int32x2_t v11 = vdup_n_s32(0x5208DD0Du);
  float32x2_t v12 = (float32x2_t)vdup_n_s32(0x30800000u);
  __asm
  {
    FMOV            V17.2D, #1.0
    FMOV            V18.2D, #0.5
  }
  float v19 = 0.0;
  do
  {
    int v20 = (int)(float)(v3 / v8);
    float v21 = (float)(v3 / v8) - (float)v20;
    int v22 = v20 & 0x1FF;
    int v23 = ((_WORD)v20 - 1) & 0x1FF;
    int v24 = 57 * ((int)(float)(v4 / v8) & 0x1FF);
    int v25 = 57 * (((unsigned __int16)(int)(float)(v4 / v8) - 1) & 0x1FF);
    v26.i32[0] = (int)(float)(v5 / v8);
    v26.i32[1] = v26.i32[0] - 1;
    int32x2_t v27 = vmul_s32((int32x2_t)vand_s8(v26, (int8x8_t)0x100000001), v6);
    int32x2_t v28 = vadd_s32(vdup_n_s32(v24 + v23), v27);
    int32x2_t v29 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v28, 0xDuLL), (int8x8_t)v28);
    int32x2_t v30 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v29, v29), v9), v29);
    int32x2_t v31 = vadd_s32(vdup_n_s32(v24 + v22), v27);
    int32x2_t v32 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v31, 0xDuLL), (int8x8_t)v31);
    int32x2_t v33 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v32, v32), v9), v32);
    int32x2_t v34 = vadd_s32(vdup_n_s32(v25 + v23), v27);
    int32x2_t v35 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v34, 0xDuLL), (int8x8_t)v34);
    int32x2_t v36 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v35, v35), v9), v35);
    int32x2_t v37 = vadd_s32(vdup_n_s32(v25 + v22), v27);
    int32x2_t v38 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v37, 0xDuLL), (int8x8_t)v37);
    int32x2_t v39 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v38, v38), v9), v38);
    float32x2_t v40 = vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(void *)&v30 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18));
    float32x2_t v41 = vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(void *)&v36 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18));
    float32x2_t v42 = vmla_n_f32(v41, vsub_f32(vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(void *)&v39 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18)), v41), v21);
    float32x2_t v43 = vmla_n_f32(v42, vsub_f32(vmla_n_f32(v40, vsub_f32(vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(void *)&v33 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18)), v40), v21), v42), (float)(v4 / v8) - (float)(int)(float)(v4 / v8));
    float v19 = v19
        + (float)((float)(v43.f32[1]
                        + (float)((float)((float)(v5 / v8) - (float)(int)(float)(v5 / v8))
                                * (float)(v43.f32[0] - v43.f32[1])))
                * v8);
    float v7 = v7 + v8;
    float v8 = v8 * 0.5;
  }
  while (v8 >= 1.0);
  return v19 / v7;
}

double WGLForceComputeLinearForce(float32x4_t *a1, uint64_t a2, float32x4_t a3)
{
  double v3 = 0.0;
  if (!a1[5].i8[6])
  {
    float32x4_t v5 = vsubq_f32(*a1, a3);
    int v6 = a1[5].i32[0];
    if (v6 || a1[5].i8[4])
    {
      float32x4_t v7 = vmulq_f32(v5, v5);
      float v8 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]);
    }
    else
    {
      float v8 = 0.0;
    }
    float v9 = a1[4].f32[0];
    switch(a1[4].i32[3])
    {
      case 0:
        a3.f32[0] = v8;
        goto LABEL_10;
      case 1:
        float32x4_t v10 = a1[1];
        goto LABEL_15;
      case 2:
        a3 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[1], (int32x4_t)a1[1]), (int8x16_t)a1[1], 0xCuLL), vnegq_f32(v5)), a1[1], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL));
        float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a3, (int32x4_t)a3), (int8x16_t)a3, 0xCuLL);
        if (!a1[5].i8[4]) {
          goto LABEL_18;
        }
        float32x4_t v11 = vmulq_f32(a3, a3);
        float32x4_t v12 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v11);
        a3 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1);
        goto LABEL_17;
      case 3:
        __n128 v27 = (__n128)vmlaq_f32(a1[2], a1[1], a3);
        *(float *)&uint64_t v13 = re::internal::WGL_noise(0x106u, v27);
        v25.i64[0] = v13;
        float v24 = re::internal::WGL_noise(0x410u, v27);
        float v14 = re::internal::WGL_noise(0x26u, v27);
        float32x4_t v15 = v25;
        v15.f32[1] = v24;
        v15.f32[2] = v14;
        a3.i64[0] = 0x4000000040000000;
        a3.i64[1] = 0x4000000040000000;
        __asm { FMOV            V2.4S, #-1.0 }
        float32x4_t v10 = vmlaq_f32(_Q2, a3, v15);
LABEL_15:
        float32x4_t v26 = v10;
        if (!a1[5].i8[4]) {
          goto LABEL_18;
        }
        float32x4_t v20 = vmulq_f32(v10, v10);
        float32x4_t v12 = vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1));
        a3 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2);
LABEL_17:
        a3.i64[0] = vaddq_f32(a3, v12).u64[0];
        a3.f32[0] = sqrtf(a3.f32[0]);
        break;
      case 4:
      case 5:
        a3.i32[1] = 0;
        float32x4_t v26 = 0u;
LABEL_18:
        a3.i32[0] = 1.0;
        break;
      default:
        a3.i32[0] = 1.0;
LABEL_10:
        float32x4_t v26 = v5;
        break;
    }
    if (a3.f32[0] == 0.0 || a1[5].i8[4] == 0) {
      float v22 = 1.0;
    }
    else {
      float v22 = a3.f32[0];
    }
    a3.i32[0] = a1[4].i32[1];
    *(void *)&double v3 = vmulq_f32(a1[3], vmulq_n_f32(v26, WGLComputeFalloff(v6, a2, *(double *)a3.i64, v8) * (float)(v9 / v22))).u64[0];
  }
  return v3;
}

double re::SliderJoint::SliderJoint(_anonymous_namespace_ *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = "";
  *((void *)a1 + 5) = a2;
  *((void *)a1 + 6) = 0;
  *(void *)a1 = &unk_26E717380;
  double result = -0.00781250185;
  *((void *)a1 + 7) = 0xBF8000003F800000;
  return result;
}

int32x2_t *re::PhysXBallSocketJoint::PhysXBallSocketJoint(int32x2_t *this, physx::PxSphericalJoint *a2, uint64_t a3)
{
  *this = (int32x2_t)&unk_26E7173D0;
  *(int32x2_t *)&double v6 = re::BallSocketJoint::BallSocketJoint(this, (uint64_t)&this[8]);
  *float32x4_t v7 = &unk_26E7173D0;
  v7[8] = &unk_26E717308;
  v7[9] = a2;
  *((void *)a2 + 2) = v7;
  (*(void (**)(physx::PxSphericalJoint *, uint64_t, uint64_t, double))(*(void *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)&this[9] + 128))(*(void *)&this[9], 8, a3);
  return this;
}

uint64_t re::PhysXBallSocketJoint::updateLimits(re::PhysXBallSocketJoint *this)
{
  uint64_t v2 = *((void *)this + 9);
  BOOL v3 = *((float *)this + 14) >= 0.0 && *((float *)this + 15) >= 0.0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, BOOL))(*(void *)v2 + 280))(*((void *)this + 9), 2, v3);
  float v5 = *((float *)this + 14);
  if (v5 >= 0.0)
  {
    float v6 = *((float *)this + 15);
    if (v6 >= 0.0)
    {
      int v10 = *((_DWORD *)this + 14);
      float v11 = v6;
      if (v5 < v6) {
        float v6 = v5;
      }
      float v7 = v6 * 0.49;
      if (v7 > 0.1) {
        float v7 = 0.1;
      }
      v8[0] = 0x3F00000000000000;
      v8[1] = 0;
      float v9 = v7;
      return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 248))(v2, v8);
    }
  }
  return result;
}

void re::PhysXBallSocketJoint::~PhysXBallSocketJoint(re::PhysXBallSocketJoint *this)
{
  *(void *)this = &unk_26E7173D0;
  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXBallSocketJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  *(void *)this = &unk_26E7173D0;
  uint64_t v2 = (void (***)(void))*((void *)this + 9);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXBallSocketJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

re::PhysXTwistSwingJoint *re::PhysXTwistSwingJoint::PhysXTwistSwingJoint(re::PhysXTwistSwingJoint *this, physx::PxD6Joint *a2, uint64_t a3)
{
  *(void *)this = &unk_26E717438;
  double v6 = re::TwistSwingJoint::TwistSwingJoint(this, (uint64_t)this + 80);
  *float v7 = &unk_26E717438;
  v7[10] = &unk_26E717308;
  v7[11] = a2;
  *((void *)a2 + 2) = v7;
  (*(void (**)(physx::PxD6Joint *, uint64_t, uint64_t, double))(*(void *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 11) + 128))(*((void *)this + 11), 8, a3);
  *((void *)this + 12) = 0xBF8000003F800000;
  *((void *)this + 13) = 0xBF8000003F800000;
  *((void *)this + 14) = 0xBF8000003F800000;
  return this;
}

uint64_t re::PhysXTwistSwingJoint::updateLimits(re::PhysXTwistSwingJoint *this, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4 = *((void *)this + 11);
  v10[0] = 0;
  uint64_t v12 = 0;
  int v11 = 0;
  uint64_t v5 = *((void *)this + 7);
  uint64_t v8 = *((void *)this + 8);
  uint64_t v9 = v5;
  uint64_t v7 = *((void *)this + 9);
  re::setPxD6JointTwistLimit(v4, (re *)&v9, (uint64_t)v10, a4, 0.0);
  return re::setPxD6JointSwingLimit(v4, (re *)&v8, (uint64_t)v10, (float *)&v7, (uint64_t)v10, 0.0, 0.0);
}

void re::PhysXTwistSwingJoint::~PhysXTwistSwingJoint(re::PhysXTwistSwingJoint *this)
{
  uint64_t v2 = (void (***)(void))*((void *)this + 11);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXTwistSwingJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(void);
  uint64_t vars8;

  uint64_t v2 = (void (***)(void))*((void *)this + 11);
  if (v2) {
    (**v2)(v2);
  }
  *(void *)this = &unk_26E716C00;
  re::StringID::destroyString((re::PhysXTwistSwingJoint *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::TwistSwingJoint::type(re::TwistSwingJoint *this)
{
  return 7;
}

re *re::RadialRepulsionForce::onApply(re *this)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  float v1 = fmaxf(fmaxf(*((float *)this + 12), *((float *)this + 14)), *((float *)this + 13));
  if (v1 > 0.0)
  {
    uint64_t v2 = this;
    float v3 = fmaxf(fmaxf(*((float *)this + 8), *((float *)this + 10)), *((float *)this + 9));
    uint64_t v4 = *(void ***)(*(void *)(*((void *)this + 3) + 72) + 56);
    double v6 = re::globalAllocators(this);
    uint64_t v7 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, float))(*(void *)v5 + 112))(v5, v6[2], v1 + v3);
    uint64_t v9 = re::globalAllocators(v7)[2];
    int v10 = (re *)(*(void *(**)(long long *__return_ptr))(**((void **)v2 + 3) + 40))(&v79);
    int v11 = re::globalAllocators(v10);
    uint64_t v12 = (void (***)(void))(*(uint64_t (**)(uint64_t, uint64_t, re *, long long *, void, uint64_t))(*(void *)v8 + 168))(v8, v9, v7, &v79, 0, v11[2]);
    uint64_t v13 = (*(uint64_t (**)(void *))(*v4[16] + 176))(v4[16]);
    if (v13)
    {
      uint64_t v14 = v13;
      for (uint64_t i = 0; i != v14; ++i)
      {
        uint64_t v16 = (*(uint64_t (**)(void *, uint64_t))(*v4[16] + 184))(v4[16], i);
        if (v16 != *(void *)(*((void *)v2 + 3) + 72))
        {
          uint64_t v17 = v16;
          int32x4_t v18 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)(v16 + 16) + 56))(*(void *)(v16 + 16));
          if (v18 == 2)
          {
            int v84 = 0;
            long long v82 = 0u;
            long long v83 = 0u;
            long long v79 = 0u;
            memset(v80, 0, 28);
            v81[0] = 0;
            *(_DWORD *)((char *)v81 + 7) = 0;
            uint64_t v85 = 0;
            uint64_t v86 = 0;
            long long v79 = 0uLL;
            re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v80, 0);
            ++DWORD2(v80[1]);
            ((void (*)(void **, void (***)(void), uint64_t, long long *))(*v4)[13])(v4, v12, v17, &v79);
            if (*(void *)&v80[1])
            {
              float v19 = (float32x4_t *)v81[0];
              uint64_t v20 = 80 * *(void *)&v80[1];
              float v21 = (float *)(v81[0] + 64);
              uint64_t v22 = 80 * *(void *)&v80[1];
              while (*v21 > 0.0)
              {
                float32x4_t v23 = vmulq_f32(*(float32x4_t *)(v21 - 4), *(float32x4_t *)(v21 - 4));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0] != 0.0)break; {
                v21 += 20;
                }
                v22 -= 80;
                if (!v22) {
                  goto LABEL_37;
                }
              }
              float v24 = 0.0;
              float32x4_t v25 = 0uLL;
              do
              {
                if (v24 < (float)-v19[4].f32[0])
                {
                  float32x4_t v26 = v19 + 1;
                  if ((void (***)(void))v79 != v12) {
                    float32x4_t v26 = v19;
                  }
                  float32x4_t v25 = *v26;
                  float v24 = -v19[4].f32[0];
                }
                v19 += 5;
                v20 -= 80;
              }
              while (v20);
              if (v24 > 0.0)
              {
                float32x4_t v71 = v25;
                float v73 = v24;
                __n128 v27 = *(_OWORD **)(v17 + 16);
                v28.i64[0] = (*(uint64_t (**)(_OWORD *))(*(void *)v27 + 216))(v27);
                v28.i64[1] = v29;
                float32x4_t v74 = v28;
                uint64_t v30 = (*(uint64_t (**)(void))(**((void **)v2 + 3) + 216))(*((void *)v2 + 3));
                float32x4_t v77 = 0uLL;
                *(void *)&long long v78 = 0;
                *((void *)&v78 + 1) = 0x3F80000000000000;
                float32x4_t v32 = vmulq_f32(v74, v74);
                LODWORD(v33) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).u32[0];
                if (fabsf(v33) >= 1.0e-10)
                {
                  v40.i64[0] = v30;
                  v40.i64[1] = v31;
                  float v69 = v33;
                  float32x4_t v70 = v40;
                  float v41 = v73 / v1;
                  if ((float)(v73 / v1) > 1.0) {
                    float v41 = 1.0;
                  }
                  if (v41 < 0.0) {
                    float v41 = 0.0;
                  }
                  float v68 = v41;
                  (*(void (**)(float32x4_t *__return_ptr, _OWORD *))(*(void *)v27 + 40))(&v75, v27);
                  long long v42 = v76;
                  long long v78 = v76;
                  float32x4_t v43 = vsubq_f32(v75, v71);
                  int32x4_t v44 = (int32x4_t)vmulq_f32(v43, v43);
                  v44.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v44, 2), vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v44.i8, 1))).u32[0];
                  float32x2_t v45 = vrsqrte_f32((float32x2_t)v44.u32[0]);
                  float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v45, v45)));
                  float32x4_t v72 = vmulq_n_f32(v43, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v46, v46))).f32[0]);
                  float32x4_t v77 = vaddq_f32(v75, vmulq_n_f32(v72, v73));
                  v27[1] = v77;
                  v27[2] = v42;
                  (*(void (**)(_OWORD *, float32x4_t *))(*(void *)v27 + 64))(v27, &v77);
                  float32x4_t v47 = v70;
                  float32x4_t v48 = vmulq_f32(v47, v47);
                  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).f32[0]) >= 1.0e-10)
                  {
                    float32x4_t v49 = v74;
                    float32x4_t v59 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v74, 0xCuLL);
                    float32x4_t v60 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v70, (int32x4_t)v70), (int8x16_t)v70, 0xCuLL), vnegq_f32(v74)), v70, v59);
                    float32x4_t v61 = vmulq_f32(v60, v60);
                    float v54 = v69;
                    if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 2), v61)).f32[0]) < 1.0e-10)
                    {
                      float32x4_t v62 = vmlaq_f32(vmulq_f32(v74, (float32x4_t)xmmword_23437C0A0), (float32x4_t)xmmword_23435FD80, v59);
                      float32x4_t v63 = vmulq_f32(v62, v62);
                      if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), v63)).f32[0]) < 1.0e-10)float32x4_t v62 = vmlaq_f32(vmulq_f32(v74, (float32x4_t)xmmword_23437C090), (float32x4_t)xmmword_23435FD60, v59); {
                      float32x4_t v47 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL);
                      }
                    }
                    float v57 = 1.0 - v68;
                    float32x4_t v58 = vmulq_n_f32(v47, v68);
                  }
                  else
                  {
                    float32x4_t v49 = v74;
                    float32x4_t v50 = v72;
                    float32x4_t v51 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v72, 0xCuLL);
                    float32x4_t v52 = vmlaq_f32(vmulq_f32(v51, vnegq_f32(v74)), v72, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v74, 0xCuLL));
                    float32x4_t v53 = vmulq_f32(v52, v52);
                    float v54 = v69;
                    if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 2), v53)).f32[0]) < 1.0e-10)
                    {
                      float32x4_t v55 = vmlaq_f32(vmulq_f32(v72, (float32x4_t)xmmword_23437C0A0), (float32x4_t)xmmword_23435FD80, v51);
                      float32x4_t v56 = vmulq_f32(v55, v55);
                      if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2), v56)).f32[0]) < 1.0e-10)float32x4_t v55 = vmlaq_f32(vmulq_f32(v72, (float32x4_t)xmmword_23437C090), (float32x4_t)xmmword_23435FD60, v51); {
                      float32x4_t v50 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), (int8x16_t)v55, 0xCuLL);
                      }
                    }
                    float v57 = 1.0 - v68;
                    float32x4_t v58 = vmulq_n_f32(vnegq_f32(v50), v68);
                  }
                  float32x4_t v64 = vmlaq_n_f32(v58, v49, v57);
                  int32x4_t v65 = (int32x4_t)vmulq_f32(v64, v64);
                  v65.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v65, 2), vadd_f32(*(float32x2_t *)v65.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v65.i8, 1))).u32[0];
                  float32x2_t v66 = vrsqrte_f32((float32x2_t)v65.u32[0]);
                  float32x2_t v67 = vmul_f32(v66, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v66, v66)));
                  float32x4_t v75 = vmulq_n_f32(vmulq_n_f32(v64, vmul_f32(v67, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v67, v67))).f32[0]), sqrtf(v54));
                  (*(void (**)(_OWORD *, float32x4_t *))(*(void *)v27 + 224))(v27, &v75);
                }
                else
                {
                  (*(void (**)(float32x4_t *__return_ptr))(**((void **)v2 + 3) + 40))(&v75);
                  long long v34 = v76;
                  long long v78 = v76;
                  float32x4_t v35 = vsubq_f32(v71, v75);
                  int32x4_t v36 = (int32x4_t)vmulq_f32(v35, v35);
                  v36.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1))).u32[0];
                  float32x2_t v37 = vrsqrte_f32((float32x2_t)v36.u32[0]);
                  float32x2_t v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v37, v37)));
                  float32x4_t v77 = vaddq_f32(v75, vmulq_n_f32(vmulq_n_f32(v35, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v38, v38))).f32[0]), v73));
                  int32x2_t v39 = (_OWORD *)*((void *)v2 + 3);
                  v39[1] = v77;
                  v39[2] = v34;
                  (*(void (**)(_OWORD *, float32x4_t *))(*(void *)v39 + 64))(v39, &v77);
                }
              }
            }
LABEL_37:
            re::ContactSet::~ContactSet((re::ContactSet *)&v79);
          }
        }
      }
    }
    return re::internal::destroyPersistent<re::CollisionObject>((re *)"onApply", 129, v12);
  }
  return this;
}

re *re::internal::destroyPersistent<re::CollisionObject>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::RadialRepulsionForce::~RadialRepulsionForce(re::RadialRepulsionForce *this)
{
}

uint64_t re::RadialRepulsionForce::type(re::RadialRepulsionForce *this)
{
  return 8;
}

double re::TwistSwingJoint::TwistSwingJoint(_anonymous_namespace_ *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = "";
  *((void *)a1 + 5) = a2;
  *((void *)a1 + 6) = 0;
  *(void *)a1 = &unk_26E717530;
  double result = -0.00781250185;
  *((void *)a1 + 7) = 0xBF8000003F800000;
  *((void *)a1 + 8) = 0xBF8000003F800000;
  *((void *)a1 + 9) = 0xBF8000003F800000;
  return result;
}

uint64_t re::TwistSwingJoint::setAngularLimit(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 8 * (int)a2 + 56) = *a3;
    float v3 = *(uint64_t (**)(void))(*(void *)a1 + 56);
    return v3();
  }
  return result;
}

void re::PhysXPhysicsSimulation::~PhysXPhysicsSimulation(re::PhysXPhysicsSimulation *this)
{
  *(void *)this = &unk_26E717580;
  re::PhysXPhysicsSimulation::deinit(this);
  re::PhysicsSimulation::~PhysicsSimulation(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E717580;
  re::PhysXPhysicsSimulation::deinit(this);
  re::PhysicsSimulation::~PhysicsSimulation(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysXPhysicsSimulation::init(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v11[0] = a5;
  v11[1] = a6;
  a1[118] = a2;
  a1[119] = a3;
  a1[7] = v9;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)v9 + 16))(v9, a3, a4, a1, 0);
  *(void *)(a1[7] + 136) = a1;
  (*(void (**)(void *, void *))(*a1 + 80))(a1, v11);
  a1[121] = *(void *)(a1[7] + 144);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a3 + 32))(a3, 0x100000, 0);
  a1[122] = result;
  return result;
}

uint64_t re::PhysXPhysicsSimulation::deinit(re::PhysXPhysicsSimulation *this)
{
  uint64_t result = (*(uint64_t (**)(re::PhysXPhysicsSimulation *))(*(void *)this + 32))(this);
  if (result)
  {
    (*(void (**)(void, void))(**((void **)this + 119) + 40))(*((void *)this + 119), *((void *)this + 122));
    uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 7) + 24))(*((void *)this + 7));
    float v3 = (void (***)(void))*((void *)this + 7);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 119);
      (**v3)(*((void *)this + 7));
      uint64_t result = (*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40))(v4, v3);
    }
    *((void *)this + 121) = 0;
    *((void *)this + 119) = 0;
  }
  return result;
}

BOOL re::PhysXPhysicsSimulation::hasDynamics(re::PhysXPhysicsSimulation *this)
{
  uint64_t v1 = *((void *)this + 7);
  return *(void *)(v1 + 152) && *(void *)(v1 + 400) != 0;
}

BOOL re::PhysXPhysicsSimulation::needsPeriodicUpdates(re::PhysXPhysicsSimulation *this)
{
  uint64_t v1 = *((void *)this + 7);
  if (!*(void *)(v1 + 152)) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 13);
  if (!v3) {
    return *(_DWORD *)(v1 + 100) != 0;
  }
  uint64_t v4 = (void *)*((void *)this + 15);
  uint64_t v5 = 8 * v3;
  while (((*(uint64_t (**)(void))(*(void *)*v4 + 296))(*v4) & 1) != 0)
  {
    ++v4;
    v5 -= 8;
    if (!v5)
    {
      uint64_t v1 = *((void *)this + 7);
      return *(_DWORD *)(v1 + 100) != 0;
    }
  }
  return 1;
}

double re::PhysXPhysicsSimulation::advance(re::PhysXPhysicsSimulation *this, float a2)
{
  uint64_t v4 = *((void *)this + 7);
  uint64_t v5 = *(void *)(v4 + 152);
  int v6 = *((unsigned __int8 *)this + 72);
  *(unsigned char *)(v4 + 389) = v6;
  if (v6 && (physx::shdfnd::g_alwaysUseLocking & 1) == 0) {
    physx::shdfnd::g_alwaysUseLocking = 1;
  }
  uint64_t v7 = *(void *)(v4 + 168);
  if (v7) {
    *(unsigned char *)(v7 + 16) = *(unsigned char *)(v4 + 388) | v6;
  }
  uint64_t v8 = *((void *)this + 13);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)*((void *)this + 15);
    uint64_t v10 = 8 * v8;
    long long v11 = 0uLL;
    while (1)
    {
      uint64_t v12 = *v9;
      long long v13 = *(_OWORD *)(*v9 + 256);
      *(_OWORD *)(v12 + 368) = *(_OWORD *)(*v9 + 240);
      *(_OWORD *)(v12 + 384) = v13;
      long long v14 = *(_OWORD *)(v12 + 288);
      *(_OWORD *)(v12 + 400) = *(_OWORD *)(v12 + 272);
      *(_OWORD *)(v12 + 416) = v14;
      *(_OWORD *)(v12 + 272) = v11;
      *(_OWORD *)(v12 + 288) = v11;
      *(_OWORD *)(v12 + 240) = v11;
      *(_OWORD *)(v12 + 256) = v11;
      int v15 = *(_DWORD *)(v12 + 208);
      if (v15 == 2) {
        break;
      }
      if (v15 == 1)
      {
        re::PhysXRigidBody::updateKinematicTargetFromVelocity((float32x4_t *)v12, a2);
LABEL_12:
        long long v11 = 0uLL;
      }
      *(_OWORD *)(v12 + 272) = v11;
      *(_OWORD *)(v12 + 288) = v11;
      *(_OWORD *)(v12 + 240) = v11;
      *(_OWORD *)(v12 + 256) = v11;
      ++v9;
      v10 -= 8;
      if (!v10) {
        goto LABEL_14;
      }
    }
    re::PhysXRigidBody::applyUserForces((float32x4_t *)v12);
    goto LABEL_12;
  }
LABEL_14:
  re::PhysicsSimulation::applyForceEffects(this);
  uint64_t v16 = *((void *)this + 45);
  if (v16)
  {
    uint64_t v17 = (uint64_t *)*((void *)this + 47);
    uint64_t v18 = 8 * v16;
    do
    {
      uint64_t v19 = *v17++;
      (*(void (**)(re::PhysXPhysicsSimulation *, uint64_t, char *, float))(*(void *)this + 112))(this, v19, (char *)this + 384, a2);
      v18 -= 8;
    }
    while (v18);
  }
  (*(void (**)(uint64_t, void, void, uint64_t, uint64_t, float))(*(void *)v5 + 400))(v5, 0, *((void *)this + 122), 0x100000, 1, a2);
  uint64_t v20 = *((void *)this + 13);
  if (v20)
  {
    float v21 = (uint64_t *)*((void *)this + 15);
    uint64_t v22 = 8 * v20;
    do
    {
      uint64_t v23 = *v21++;
      (*(void (**)(uint64_t))(*(void *)v23 + 368))(v23);
      v22 -= 8;
    }
    while (v22);
  }
  double result = *((double *)this + 3) + a2;
  *((double *)this + 3) = result;
  return result;
}

int64x2_t re::PhysXPhysicsSimulation::collectStats(re::PhysXPhysicsSimulation *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 7) + 152);
  physx::PxSimulationStatistics::PxSimulationStatistics((uint64_t)&v78);
  (*(void (**)(uint64_t, unsigned int *))(*(void *)v2 + 592))(v2, &v78);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v3 = re::internal::enableSignposts(0, 0);
  if (v3) {
    uint64_t v3 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v3);
  if (isStatisticCollectionEnabled)
  {
    uint64_t isStatisticCollectionEnabled = re::profilerThreadContext((re *)isStatisticCollectionEnabled);
    uint64_t v5 = *(int64x2_t **)(isStatisticCollectionEnabled + 152);
    if (v5)
    {
      unint64_t v6 = (v82 + v81 + v83);
      unint64_t v7 = v5[268].u64[0];
      if (v7 >= v6) {
        unint64_t v7 = (v82 + v81 + v83);
      }
      v5[268].i64[0] = v7;
      unint64_t v8 = v5[268].u64[1];
      if (v8 <= v6) {
        unint64_t v8 = v6;
      }
      v5[268].i64[1] = v8;
      int64x2_t v9 = vdupq_n_s64(1uLL);
      v9.i64[0] = v6;
      v5[269] = vaddq_s64(v5[269], v9);
      *(unsigned char *)(isStatisticCollectionEnabled + 184) = 0;
    }
  }
  uint64_t v10 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
  if (v10)
  {
    uint64_t v10 = re::profilerThreadContext((re *)v10);
    long long v11 = *(int64x2_t **)(v10 + 152);
    if (v11)
    {
      unint64_t v12 = (v80 + v79);
      unint64_t v13 = v11[272].u64[0];
      if (v13 >= v12) {
        unint64_t v13 = (v80 + v79);
      }
      v11[272].i64[0] = v13;
      unint64_t v14 = v11[272].u64[1];
      if (v14 <= v12) {
        unint64_t v14 = v12;
      }
      v11[272].i64[1] = v14;
      int64x2_t v15 = vdupq_n_s64(1uLL);
      v15.i64[0] = v12;
      v11[273] = vaddq_s64(v11[273], v15);
      *(unsigned char *)(v10 + 184) = 0;
    }
  }
  uint64_t v16 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v10);
  if (v16)
  {
    uint64_t v16 = re::profilerThreadContext((re *)v16);
    uint64_t v17 = *(int64x2_t **)(v16 + 152);
    if (v17)
    {
      unint64_t v18 = *((void *)this + 34);
      unint64_t v19 = v17[288].u64[0];
      if (v19 >= v18) {
        unint64_t v19 = *((void *)this + 34);
      }
      v17[288].i64[0] = v19;
      unint64_t v20 = v17[288].u64[1];
      if (v20 <= v18) {
        unint64_t v20 = v18;
      }
      v17[288].i64[1] = v20;
      int64x2_t v21 = vdupq_n_s64(1uLL);
      v21.i64[0] = v18;
      v17[289] = vaddq_s64(v17[289], v21);
      *(unsigned char *)(v16 + 184) = 0;
    }
  }
  uint64_t v22 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v16);
  if (v22)
  {
    uint64_t v23 = re::profilerThreadContext(v22);
    uint64_t v22 = (re *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 7) + 128) + 176))(*(void *)(*((void *)this + 7) + 128));
    float v24 = *(int64x2_t **)(v23 + 152);
    if (v24)
    {
      float32x4_t v25 = (re *)v24[276].i64[0];
      if (v25 >= v22) {
        float32x4_t v25 = v22;
      }
      v24[276].i64[0] = (uint64_t)v25;
      float32x4_t v26 = (re *)v24[276].i64[1];
      if (v26 <= v22) {
        float32x4_t v26 = v22;
      }
      v24[276].i64[1] = (uint64_t)v26;
      int64x2_t v27 = vdupq_n_s64(1uLL);
      v27.i64[0] = (uint64_t)v22;
      v24[277] = vaddq_s64(v24[277], v27);
      *(unsigned char *)(v23 + 184) = 0;
    }
  }
  uint64_t v28 = re::ProfilerConfig::isStatisticCollectionEnabled(v22);
  if (v28)
  {
    uint64_t v28 = re::profilerThreadContext((re *)v28);
    uint64_t v29 = *(int64x2_t **)(v28 + 152);
    if (v29)
    {
      unint64_t v30 = v90;
      unint64_t v31 = v29[280].u64[0];
      if (v31 >= v90) {
        unint64_t v31 = v90;
      }
      v29[280].i64[0] = v31;
      unint64_t v32 = v29[280].u64[1];
      if (v32 <= v30) {
        unint64_t v32 = v30;
      }
      v29[280].i64[1] = v32;
      int64x2_t v33 = vdupq_n_s64(1uLL);
      v33.i64[0] = v30;
      v29[281] = vaddq_s64(v29[281], v33);
      *(unsigned char *)(v28 + 184) = 0;
    }
  }
  uint64_t v34 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v28);
  if (v34)
  {
    uint64_t v34 = re::profilerThreadContext((re *)v34);
    float32x4_t v35 = *(int64x2_t **)(v34 + 152);
    if (v35)
    {
      unint64_t v36 = v78;
      unint64_t v37 = v35[284].u64[0];
      if (v37 >= v78) {
        unint64_t v37 = v78;
      }
      v35[284].i64[0] = v37;
      unint64_t v38 = v35[284].u64[1];
      if (v38 <= v36) {
        unint64_t v38 = v36;
      }
      v35[284].i64[1] = v38;
      int64x2_t v39 = vdupq_n_s64(1uLL);
      v39.i64[0] = v36;
      v35[285] = vaddq_s64(v35[285], v39);
      *(unsigned char *)(v34 + 184) = 0;
    }
  }
  uint64_t v40 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v34);
  if (v40)
  {
    uint64_t v40 = re::profilerThreadContext((re *)v40);
    float v41 = *(int64x2_t **)(v40 + 152);
    if (v41)
    {
      unint64_t v42 = v84;
      unint64_t v43 = v41[292].u64[0];
      if (v43 >= v84) {
        unint64_t v43 = v84;
      }
      v41[292].i64[0] = v43;
      unint64_t v44 = v41[292].u64[1];
      if (v44 <= v42) {
        unint64_t v44 = v42;
      }
      v41[292].i64[1] = v44;
      int64x2_t v45 = vdupq_n_s64(1uLL);
      v45.i64[0] = v42;
      v41[293] = vaddq_s64(v41[293], v45);
      *(unsigned char *)(v40 + 184) = 0;
    }
  }
  uint64_t v46 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v40);
  if (v46)
  {
    uint64_t v46 = re::profilerThreadContext((re *)v46);
    float32x4_t v47 = *(int64x2_t **)(v46 + 152);
    if (v47)
    {
      unint64_t v48 = v85;
      unint64_t v49 = v47[296].u64[0];
      if (v49 >= v85) {
        unint64_t v49 = v85;
      }
      v47[296].i64[0] = v49;
      unint64_t v50 = v47[296].u64[1];
      if (v50 <= v48) {
        unint64_t v50 = v48;
      }
      v47[296].i64[1] = v50;
      int64x2_t v51 = vdupq_n_s64(1uLL);
      v51.i64[0] = v48;
      v47[297] = vaddq_s64(v47[297], v51);
      *(unsigned char *)(v46 + 184) = 0;
    }
  }
  uint64_t v52 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v46);
  if (v52)
  {
    uint64_t v52 = re::profilerThreadContext((re *)v52);
    float32x4_t v53 = *(int64x2_t **)(v52 + 152);
    if (v53)
    {
      unint64_t v54 = v86;
      unint64_t v55 = v53[300].u64[0];
      if (v55 >= v86) {
        unint64_t v55 = v86;
      }
      v53[300].i64[0] = v55;
      unint64_t v56 = v53[300].u64[1];
      if (v56 <= v54) {
        unint64_t v56 = v54;
      }
      v53[300].i64[1] = v56;
      int64x2_t v57 = vdupq_n_s64(1uLL);
      v57.i64[0] = v54;
      v53[301] = vaddq_s64(v53[301], v57);
      *(unsigned char *)(v52 + 184) = 0;
    }
  }
  uint64_t v58 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v52);
  if (v58)
  {
    uint64_t v58 = re::profilerThreadContext((re *)v58);
    float32x4_t v59 = *(int64x2_t **)(v58 + 152);
    if (v59)
    {
      unint64_t v60 = v87;
      unint64_t v61 = v59[304].u64[0];
      if (v61 >= v87) {
        unint64_t v61 = v87;
      }
      v59[304].i64[0] = v61;
      unint64_t v62 = v59[304].u64[1];
      if (v62 <= v60) {
        unint64_t v62 = v60;
      }
      v59[304].i64[1] = v62;
      int64x2_t v63 = vdupq_n_s64(1uLL);
      v63.i64[0] = v60;
      v59[305] = vaddq_s64(v59[305], v63);
      *(unsigned char *)(v58 + 184) = 0;
    }
  }
  uint64_t v64 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v58);
  if (v64)
  {
    uint64_t v64 = re::profilerThreadContext((re *)v64);
    int32x4_t v65 = *(int64x2_t **)(v64 + 152);
    if (v65)
    {
      unint64_t v66 = v89;
      unint64_t v67 = v65[308].u64[0];
      if (v67 >= v89) {
        unint64_t v67 = v89;
      }
      v65[308].i64[0] = v67;
      unint64_t v68 = v65[308].u64[1];
      if (v68 <= v66) {
        unint64_t v68 = v66;
      }
      v65[308].i64[1] = v68;
      int64x2_t v69 = vdupq_n_s64(1uLL);
      v69.i64[0] = v66;
      v65[309] = vaddq_s64(v65[309], v69);
      *(unsigned char *)(v64 + 184) = 0;
    }
  }
  float32x4_t v70 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v64);
  if (v70)
  {
    uint64_t v72 = re::profilerThreadContext(v70);
    float v73 = *(int64x2_t **)(v72 + 152);
    if (v73)
    {
      unint64_t v74 = v88;
      unint64_t v75 = v73[312].u64[0];
      if (v75 >= v88) {
        unint64_t v75 = v88;
      }
      v73[312].i64[0] = v75;
      unint64_t v76 = v73[312].u64[1];
      if (v76 <= v74) {
        unint64_t v76 = v74;
      }
      v73[312].i64[1] = v76;
      int64x2_t v77 = vdupq_n_s64(1uLL);
      v77.i64[0] = v74;
      int64x2_t result = vaddq_s64(v73[313], v77);
      v73[313] = result;
      *(unsigned char *)(v72 + 184) = 0;
    }
  }
  return result;
}

uint64_t re::PhysXPhysicsSimulation::gravity(re::PhysXPhysicsSimulation *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*((void *)this + 7) + 152) + 488))(&v2);
  return v2;
}

void *re::PhysXPhysicsSimulation::setGravity(void *a1, float32x4_t *a2)
{
  int64x2_t result = (void *)(*(uint64_t (**)(void *))(*a1 + 72))(a1);
  if (a2->f32[0] != *(float *)&result
    && vabds_f32(a2->f32[0], *(float *)&result) >= (float)((float)((float)(fabsf(a2->f32[0]) + fabsf(*(float *)&result))
                                                                 + 1.0)
                                                         * 0.00001)
    || (float v6 = a2->f32[1], v6 != *((float *)&result + 1))
    && vabds_f32(v6, *((float *)&result + 1)) >= (float)((float)((float)(fabsf(*((float *)&result + 1)) + fabsf(v6))
                                                               + 1.0)
                                                       * 0.00001)
    || (float v7 = a2->f32[2], v7 != v5)
    && vabds_f32(v7, v5) >= (float)((float)((float)(fabsf(v5) + fabsf(v7)) + 1.0) * 0.00001))
  {
    if (physx::shdfnd::g_isLockingEnabled) {
      int v8 = 1;
    }
    else {
      int v8 = physx::shdfnd::g_alwaysUseLocking;
    }
    if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
      physx::shdfnd::g_isLockingEnabled = 0;
    }
    float32x4_t v9 = vmulq_f32(*a2, *a2);
    float v10 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
    uint64_t v11 = *(void *)(a1[7] + 152);
    (*(void (**)(uint64_t, float32x4_t *))(*(void *)v11 + 480))(v11, a2);
    v12.n128_f32[0] = v10 * 0.2;
    int64x2_t result = (void *)(*(uint64_t (**)(uint64_t, __n128))(*(void *)v11 + 496))(v11, v12);
    uint64_t v13 = a1[13];
    if (v13)
    {
      float32x4_t v14 = vmulq_f32(*a2, *a2);
      unsigned __int32 v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u32[0];
      int64x2_t v15 = (re::PhysXRigidBody **)a1[15];
      uint64_t v16 = 8 * v13;
      do
      {
        uint64_t v17 = *v15++;
        *((_DWORD *)v17 + 78) = v18;
        re::PhysXRigidBody::updateSleepThreshold(v17);
        int64x2_t result = re::PhysXRigidBody::wakeUp(v17);
        v16 -= 8;
      }
      while (v16);
    }
    if (physx::shdfnd::g_isLockingEnabled != v8) {
      physx::shdfnd::g_isLockingEnabled = v8;
    }
  }
  return result;
}

void *re::PhysXPhysicsSimulation::onRigidBodyAdded(re::PhysXPhysicsSimulation *this, re::RigidBody *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  re::PhysicsSimulation::onRigidBodyAdded(this, a2);
  v5.i64[0] = (*(uint64_t (**)(re::PhysXPhysicsSimulation *))(*(void *)this + 72))(this);
  v5.i64[1] = v6;
  float32x4_t v7 = vmulq_f32(v5, v5);
  *((_DWORD *)a2 + 78) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u32[0];
  re::PhysXRigidBody::updateSleepThreshold(a2);
  int64x2_t result = re::PhysXRigidBody::wakeUp(a2);
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return result;
}

uint64_t re::PhysXPhysicsSimulation::applyForceEffect(uint64_t this, float32x4_t *a2, re::ForceEffectFunctionRuntime *a3, float a4)
{
  uint64_t v212 = *MEMORY[0x263EF8340];
  if (!a2[10].i8[8]) {
    return this;
  }
  uint64_t v7 = this;
  re::ForceEffectDefinition::advance((uint64_t)a2, a4);
  if (!a2[8].i64[0])
  {
    int v8 = a2 + 4;
    uint64_t v13 = (double *)&a2[4].i64[1];
    double v10 = 0.0;
    goto LABEL_17;
  }
  int v8 = a2 + 4;
  double v9 = *(double *)a2[9].i64;
  double v10 = *(double *)a2[10].i64 - v9;
  double v11 = 0.0;
  if (a2[8].i8[8]) {
    double v12 = *(double *)a2[10].i64 - v9;
  }
  else {
    double v12 = 0.0;
  }
  uint64_t v13 = (double *)&a2[4].i64[1];
  if (v12 < *(double *)&a2[4].i64[1] || a2[4].i8[0] == 0)
  {
    double v11 = v12;
LABEL_16:
    double v10 = v11;
    goto LABEL_17;
  }
  if (!a2[8].i8[8]) {
    goto LABEL_16;
  }
  a2[8].i8[8] = 0;
  if (a2[9].i8[8]) {
    a2[9].i8[8] = 0;
  }
  a2[10].i8[8] = 0;
LABEL_17:
  v202 = 0;
  unint64_t v200 = 0;
  v199[0] = 0;
  v199[1] = 0;
  int v201 = 0;
  if (a2[2].i8[12])
  {
    float v15 = a2[3].f32[0];
    float v16 = a2[3].f32[1];
    float v17 = a2[3].f32[2];
    v185.i32[0] = 0;
    v185.f32[1] = v15;
    *(float32x4_t *)v204 = a2[1];
    *(void *)&v204[16] = a2->i64[0];
    *(_DWORD *)&v204[24] = a2->i32[2];
    re::PhysXCollisionWorld::overlap(*(void *)(v7 + 56), (uint64_t)&v185, (uint64_t)v204, a2[2].i32[1], (uint64_t)&v186);
    if (v187.i64[0])
    {
      uint64_t v18 = v188.i64[0];
      uint64_t v19 = 8 * v187.i64[0];
      do
      {
        if (*(unsigned char *)(*(void *)v18 + 8))
        {
          uint64_t v20 = *(void *)(*(void *)v18 + 16);
          v184.i64[0] = v20;
          if (v20)
          {
            if (*(_DWORD *)(v20 + 208) == 2 && *(float *)(v20 + 192) > 0.0)
            {
              (*(void (**)(float32x4_t *__return_ptr))(*(void *)v20 + 40))(&v207);
              if (v15 <= v16) {
                goto LABEL_31;
              }
              float32x4_t v21 = vsubq_f32(v207, *a2);
              float32x4_t v22 = vmulq_f32(v21, v21);
              float v23 = (float)(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0])- v16)/ (float)(v15 - v16);
              if (v23 > 1.0) {
                float v23 = 1.0;
              }
              float v24 = v23 >= 0.0 ? 1.0 - v23 : 1.0;
              if (powf(v24, v17) > 0.00000001) {
LABEL_31:
              }
                re::DynamicArray<re::TransitionCondition *>::add(v199, &v184);
            }
          }
        }
        v18 += 8;
        v19 -= 8;
      }
      while (v19);
    }
    if (v186.i64[0] && v188.i64[0]) {
      (*(void (**)(void))(*(void *)v186.i64[0] + 40))();
    }
  }
  else
  {
    uint64_t v25 = *(void *)(v7 + 104);
    if (v25)
    {
      for (unint64_t i = 0; i != v25; ++i)
      {
        v186.i64[0] = 0;
        uint64_t v27 = re::ecs2::ComponentTypeRegistry::operator[](v7 + 80, i);
        v186.i64[0] = v27;
        if (*(_DWORD *)(v27 + 208) == 2)
        {
          uint64_t v28 = *(void *)(v27 + 72);
          if (v28)
          {
            if ((a2[2].i32[1] & *(_DWORD *)(v28 + 32)) != 0 && *(float *)(v27 + 192) > 0.0) {
              re::DynamicArray<re::TransitionCondition *>::add(v199, &v186);
            }
          }
        }
      }
    }
  }
  if (v200)
  {
    uint64_t v29 = a2[5].i64[1];
    if (v29)
    {
      uint64_t v168 = v7;
      v170 = v13;
      unsigned int v30 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 40))(v29);
      char v31 = v30;
      re::ForceEffectFunctionRuntime::reserveInputBuffers((uint64_t)a3, v30, v200);
      unint64_t v32 = a3;
      if ((v31 & 0x10) != 0) {
        uint64_t v33 = *((void *)a3 + 24);
      }
      else {
        uint64_t v33 = 0;
      }
      uint64_t v34 = (_DWORD *)*((void *)v32 + 29);
      if ((v31 & 0x20) == 0) {
        uint64_t v34 = 0;
      }
      v171 = v34;
      if ((v31 & 2) != 0) {
        uint64_t v35 = *((void *)v32 + 9);
      }
      else {
        uint64_t v35 = 0;
      }
      if (v31) {
        uint64_t v36 = *((void *)v32 + 4);
      }
      else {
        uint64_t v36 = 0;
      }
      if ((v31 & 4) != 0) {
        uint64_t v37 = *((void *)v32 + 14);
      }
      else {
        uint64_t v37 = 0;
      }
      if ((v31 & 8) != 0) {
        uint64_t v38 = *((void *)v32 + 19);
      }
      else {
        uint64_t v38 = 0;
      }
      v169 = (int *)v32;
      uint64_t v39 = *((void *)v32 + 34);
      if ((v31 & 0x40) == 0) {
        uint64_t v39 = 0;
      }
      uint64_t v175 = v39;
      if (v36 | v35) {
        BOOL v40 = 0;
      }
      else {
        BOOL v40 = v37 == 0;
      }
      if (v40 && v38 == 0)
      {
        float32x4_t v44 = (float32x4_t)xmmword_23435FBB0;
        float32x4_t v52 = 0uLL;
      }
      else
      {
        float32x4_t v42 = a2[1];
        int8x16_t v43 = (int8x16_t)vnegq_f32(v42);
        float32x4_t v44 = (float32x4_t)v43;
        v44.i32[3] = v42.i32[3];
        float32x4_t v45 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v43, 0xCuLL);
        int8x16_t v46 = (int8x16_t)vnegq_f32(*a2);
        float32x4_t v47 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), v46, 0xCuLL), v42), v45, *a2);
        int8x16_t v48 = (int8x16_t)vaddq_f32(v47, v47);
        float32x4_t v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL);
        float32x4_t v50 = vsubq_f32(vmulq_laneq_f32(v49, v42, 3), *a2);
        int8x16_t v51 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL), v42), v49, v45);
        float32x4_t v52 = vaddq_f32(v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), v51, 0xCuLL));
      }
      float32x4_t v180 = v52;
      uint64_t v53 = v200;
      if (v33) {
        BOOL v54 = v200 == 0;
      }
      else {
        BOOL v54 = 1;
      }
      unint64_t v55 = (unint64_t)v171;
      float32x4_t v183 = v44;
      if (!v54)
      {
        unint64_t v56 = 0;
        do
        {
          (*(void (**)(float32x4_t *__return_ptr))(*(void *)v202[v56] + 40))(&v186);
          float32x4_t v57 = vsubq_f32(v186, *a2);
          float32x4_t v58 = vmulq_f32(v57, v57);
          *(float *)(v33 + 4 * v56++) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).f32[0]);
          uint64_t v53 = v200;
        }
        while (v56 < v200);
        float32x4_t v44 = v183;
      }
      if (v171)
      {
        if (!v53)
        {
          BOOL v92 = v175 != 0;
LABEL_114:
          long long v197 = 0u;
          long long v198 = 0u;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v191 = 0u;
          long long v192 = 0u;
          long long v189 = 0u;
          long long v190 = 0u;
          float32x4_t v188 = 0u;
          v186.i64[0] = v168;
          v186.f32[2] = a4;
          *(double *)v187.i64 = v10;
          v187.i64[1] = v53;
          if (v36)
          {
            *(void *)&long long v189 = v36;
            *((void *)&v189 + 1) = v53;
          }
          if (v35)
          {
            *(void *)&long long v190 = v35;
            *((void *)&v190 + 1) = v53;
          }
          if (v37)
          {
            *(void *)&long long v191 = v37;
            *((void *)&v191 + 1) = v53;
          }
          if (v38)
          {
            *(void *)&long long v192 = v38;
            *((void *)&v192 + 1) = v53;
          }
          if (v33)
          {
            v188.i64[0] = v33;
            v188.i64[1] = v53;
          }
          if (v55)
          {
            *(void *)&long long v193 = v55;
            *((void *)&v193 + 1) = v53;
          }
          if (v92)
          {
            *(void *)&long long v194 = v175;
            *((void *)&v194 + 1) = v53;
          }
          re::ForceEffectFunctionRuntime::reserveOutputBuffers((re::ForceEffectFunctionRuntime *)v169, v53);
          uint64_t v127 = 5 * v169[120];
          *(void *)&long long v195 = *(void *)&v169[-10 * v169[120] + 98];
          *((void *)&v195 + 1) = v187.i64[1];
          uint64_t v128 = 5 * v169[121];
          *(void *)&long long v196 = *(void *)&v169[-10 * v169[121] + 118];
          *((void *)&v196 + 1) = v187.i64[1];
          *(void *)&long long v197 = *(void *)&v169[2 * v127 + 88];
          *((void *)&v197 + 1) = v187.i64[1];
          *(void *)&long long v198 = *(void *)&v169[2 * v128 + 108];
          *((void *)&v198 + 1) = v187.i64[1];
          (*(void (**)(uint64_t, float32x4_t *, int *))(*(void *)a2[5].i64[1] + 24))(a2[5].i64[1], &v186, v169);
          if (a2[2].i8[12] && v200)
          {
            unint64_t v130 = 0;
            float v132 = a2[3].f32[1];
            float v131 = a2[3].f32[2];
            float v133 = a2[3].f32[0];
            while (1)
            {
              (*(void (**)(float32x4_t *__return_ptr))(*(void *)v202[v130] + 40))(&v207);
              float v134 = 1.0;
              if (v133 > v132)
              {
                float32x4_t v135 = vsubq_f32(v207, *a2);
                float32x4_t v136 = vmulq_f32(v135, v135);
                float v137 = (float)(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v136, 2), vaddq_f32(v136, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.f32, 1))).f32[0])- v132)/ (float)(v133 - v132);
                if (v137 > 1.0) {
                  float v137 = 1.0;
                }
                if (v137 >= 0.0) {
                  float v138 = 1.0 - v137;
                }
                else {
                  float v138 = 1.0;
                }
                float v134 = powf(v138, v131);
              }
              uint64_t v139 = *((void *)&v197 + 1);
              if (*((void *)&v197 + 1) <= v130) {
                break;
              }
              *(float32x4_t *)(v197 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v197 + 16 * v130), v134);
              uint64_t v140 = *((void *)&v198 + 1);
              if (*((void *)&v198 + 1) <= v130) {
                goto LABEL_169;
              }
              *(float32x4_t *)(v198 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v198 + 16 * v130), v134);
              if (++v130 >= v200) {
                goto LABEL_141;
              }
            }
LABEL_168:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v139);
            _os_crash();
            __break(1u);
LABEL_169:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v140);
            _os_crash();
            __break(1u);
          }
LABEL_141:
          float v141 = 1.0;
          if (v8->i8[0])
          {
            float v142 = *v170;
            if (v142 > 0.0)
            {
              float v143 = v10;
              float v144 = v143 / v142;
              if (v144 > 1.0) {
                float v144 = 1.0;
              }
              if (v144 >= 0.0) {
                float v145 = 1.0 - v144;
              }
              else {
                float v145 = 1.0;
              }
              float v141 = powf(v145, a2[5].f32[0]);
            }
          }
          if (v200)
          {
            unint64_t v130 = 0;
            while (*((void *)&v197 + 1) > v130)
            {
              float v146 = v141 * a2[2].f32[0];
              *(float32x4_t *)(v197 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v197 + 16 * v130), v146);
              uint64_t v147 = *((void *)&v197 + 1);
              if (*((void *)&v197 + 1) <= v130) {
                goto LABEL_163;
              }
              uint64_t v148 = *((void *)&v198 + 1);
              float32x4_t v149 = *(float32x4_t *)(v197 + 16 * v130);
              float32x4_t v150 = a2[1];
              float32x4_t v151 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v150, (int32x4_t)v150), (int8x16_t)v150, 0xCuLL);
              float32x4_t v152 = vnegq_f32(v150);
              float32x4_t v153 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v149, (int32x4_t)v149), (int8x16_t)v149, 0xCuLL), v152), v149, v151);
              int8x16_t v154 = (int8x16_t)vaddq_f32(v153, v153);
              float32x4_t v155 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v154, (int32x4_t)v154), v154, 0xCuLL);
              float32x4_t v156 = vaddq_f32(v149, vmulq_laneq_f32(v155, v150, 3));
              int8x16_t v157 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v155, (int32x4_t)v155), (int8x16_t)v155, 0xCuLL), v152), v155, v151);
              float32x4_t v185 = vaddq_f32(v156, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v157, (int32x4_t)v157), v157, 0xCuLL));
              if (*((void *)&v198 + 1) <= v130) {
                goto LABEL_164;
              }
              *(float32x4_t *)(v198 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v198 + 16 * v130), v146);
              uint64_t v158 = *((void *)&v198 + 1);
              if (*((void *)&v198 + 1) <= v130) {
                goto LABEL_165;
              }
              float32x4_t v159 = a2[1];
              float32x4_t v160 = *(float32x4_t *)(v198 + 16 * v130);
              float32x4_t v161 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v159, (int32x4_t)v159), (int8x16_t)v159, 0xCuLL);
              float32x4_t v162 = vnegq_f32(v159);
              float32x4_t v163 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v160, (int32x4_t)v160), (int8x16_t)v160, 0xCuLL), v162), v160, v161);
              int8x16_t v164 = (int8x16_t)vaddq_f32(v163, v163);
              float32x4_t v165 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v164, (int32x4_t)v164), v164, 0xCuLL);
              float32x4_t v166 = vaddq_f32(v160, vmulq_laneq_f32(v165, v159, 3));
              int8x16_t v167 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v165, (int32x4_t)v165), (int8x16_t)v165, 0xCuLL), v162), v165, v161);
              float32x4_t v184 = vaddq_f32(v166, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v167, (int32x4_t)v167), v167, 0xCuLL));
              unint64_t v55 = v200;
              if (v200 <= v130) {
                goto LABEL_166;
              }
              (*(void (**)(uint64_t, float32x4_t *, void))(*(void *)v202[v130] + 408))(v202[v130], &v185, a2[2].u8[8]);
              unint64_t v55 = v200;
              if (v200 <= v130) {
                goto LABEL_167;
              }
              (*(void (**)(uint64_t, float32x4_t *, void))(*(void *)v202[v130] + 416))(v202[v130], &v184, a2[2].u8[8]);
              if (++v130 >= v200) {
                goto LABEL_158;
              }
            }
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, *((void *)&v197 + 1));
            _os_crash();
            __break(1u);
LABEL_163:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v147);
            _os_crash();
            __break(1u);
LABEL_164:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v148);
            _os_crash();
            __break(1u);
LABEL_165:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v158);
            _os_crash();
            __break(1u);
LABEL_166:
            uint64_t v203 = 0;
            long long v210 = 0u;
            long long v211 = 0u;
            int32x4_t v208 = 0u;
            int32x4_t v209 = 0u;
            float32x4_t v207 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v204 = 136315906;
            *(void *)&v204[4] = "operator[]";
            *(_WORD *)&v204[12] = 1024;
            *(_DWORD *)&v204[14] = 789;
            *(_WORD *)&v204[18] = 2048;
            *(void *)&v204[20] = v130;
            __int16 v205 = 2048;
            unint64_t v206 = v55;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_167:
            uint64_t v203 = 0;
            long long v210 = 0u;
            long long v211 = 0u;
            int32x4_t v208 = 0u;
            int32x4_t v209 = 0u;
            float32x4_t v207 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v204 = 136315906;
            *(void *)&v204[4] = "operator[]";
            *(_WORD *)&v204[12] = 1024;
            *(_DWORD *)&v204[14] = 789;
            *(_WORD *)&v204[18] = 2048;
            *(void *)&v204[20] = v130;
            __int16 v205 = 2048;
            unint64_t v206 = v55;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_168;
          }
          goto LABEL_158;
        }
        float32x4_t v59 = v202;
        unint64_t v60 = v171;
        do
        {
          uint64_t v61 = *v59++;
          *v60++ = *(_DWORD *)(v61 + 192);
          --v53;
        }
        while (v53);
        uint64_t v53 = v200;
      }
      if (v53) {
        BOOL v62 = (v36 | v35) != 0;
      }
      else {
        BOOL v62 = 0;
      }
      if (v62)
      {
        unint64_t v63 = 0;
        float32x4_t v181 = vnegq_f32(v44);
        float32x4_t v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        float32x4_t v178 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3);
        _S9 = v44.i32[3];
        do
        {
          (*(void (**)(float32x4_t *__return_ptr))(*(void *)v202[v63] + 40))(&v186);
          float32x4_t v44 = v183;
          _Q0 = (float32x4_t)v187;
          if (v36)
          {
            float32x4_t v66 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v186, (int32x4_t)v186), (int8x16_t)v186, 0xCuLL), v181), v186, v182);
            int8x16_t v67 = (int8x16_t)vaddq_f32(v66, v66);
            float32x4_t v68 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v67, (int32x4_t)v67), v67, 0xCuLL);
            int8x16_t v69 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), (int8x16_t)v68, 0xCuLL), v181), v68, v182);
            *(float32x4_t *)(v36 + 16 * v63) = vaddq_f32(v180, vaddq_f32(vaddq_f32(v186, vmulq_laneq_f32(v68, v183, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), v69, 0xCuLL)));
          }
          if (v35)
          {
            int8x16_t v70 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL), v181), _Q0, v182);
            float32x4_t v71 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v70, (int32x4_t)v70), v70, 0xCuLL), _Q0, v178), v183, _Q0, 3);
            __asm { FMLA            S2, S9, V0.S[3] }
            v71.i32[3] = _S2;
            *(float32x4_t *)(v35 + 16 * v63) = v71;
          }
          ++v63;
          uint64_t v53 = v200;
        }
        while (v63 < v200);
      }
      if (v37 && v53)
      {
        unint64_t v76 = 0;
        float32x4_t v181 = vnegq_f32(v44);
        float32x4_t v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        do
        {
          uint64_t v77 = (*(uint64_t (**)(uint64_t))(*(void *)v202[v76] + 216))(v202[v76]);
          float32x4_t v44 = v183;
          v78.i64[0] = v77;
          v78.i64[1] = v79;
          float32x4_t v80 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v78, v78), (int8x16_t)v78, 0xCuLL), v181), (float32x4_t)v78, v182);
          int8x16_t v81 = (int8x16_t)vaddq_f32(v80, v80);
          float32x4_t v82 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), v81, 0xCuLL);
          int8x16_t v83 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL), v181), v82, v182);
          *(float32x4_t *)(v37 + 16 * v76++) = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v82, v183, 3), (float32x4_t)v78), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), v83, 0xCuLL));
          uint64_t v53 = v200;
        }
        while (v76 < v200);
      }
      if (v38 && v53)
      {
        unint64_t v84 = 0;
        float32x4_t v181 = vnegq_f32(v44);
        float32x4_t v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        do
        {
          uint64_t v85 = (*(uint64_t (**)(uint64_t))(*(void *)v202[v84] + 232))(v202[v84]);
          float32x4_t v44 = v183;
          v86.i64[0] = v85;
          v86.i64[1] = v87;
          float32x4_t v88 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v86, v86), (int8x16_t)v86, 0xCuLL), v181), (float32x4_t)v86, v182);
          int8x16_t v89 = (int8x16_t)vaddq_f32(v88, v88);
          float32x4_t v90 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), v89, 0xCuLL);
          int8x16_t v91 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL), v181), v90, v182);
          *(float32x4_t *)(v38 + 16 * v84++) = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v90, v183, 3), (float32x4_t)v86), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v91, (int32x4_t)v91), v91, 0xCuLL));
          uint64_t v53 = v200;
        }
        while (v84 < v200);
      }
      BOOL v92 = v175 != 0;
      if (v175 && v53)
      {
        unint64_t v93 = 0;
        float32x4_t v173 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3);
        float32x4_t v174 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        float32x4_t v172 = vnegq_f32(v44);
        _S9 = v44.i32[3];
        do
        {
          uint64_t v95 = v202[v93];
          float32x4_t v179 = (float32x4_t)*(_OWORD *)(v95 + 176);
          LODWORD(v96) = 0;
          HIDWORD(v96) = HIDWORD(*(void *)(v95 + 176));
          int32x4_t v177 = (int32x4_t)v96;
          v97.i64[0] = 0;
          v97.i64[1] = *(void *)(v95 + 184);
          int32x4_t v176 = v97;
          (*(void (**)(float32x4_t *__return_ptr))(*(void *)v95 + 40))(&v186);
          uint64_t v98 = 0;
          _Q0 = (int32x4_t)v187;
          int8x16_t v99 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), v187, 0xCuLL), v172), (float32x4_t)v187, v174);
          float32x4_t v111 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v99, (int32x4_t)v99), v99, 0xCuLL), (float32x4_t)v187, v173), v183, (float32x4_t)v187, 3);
          _Q2 = (int32x4_t)vmulq_f32(v183, (float32x4_t)v187);
          int32x4_t v108 = vdupq_lane_s32(*(int32x2_t *)_Q2.i8, 1);
          int32x4_t v112 = vdupq_laneq_s32(_Q2, 2);
          __asm { FMLA            S2, S9, V0.S[3] }
          float v101 = (float)(v111.f32[0] + v111.f32[0]) * v111.f32[0];
          float v102 = vmuls_lane_f32(v111.f32[1] + v111.f32[1], *(float32x2_t *)v111.f32, 1);
          float v103 = vmuls_lane_f32(v111.f32[2] + v111.f32[2], v111, 2);
          float v104 = vmuls_lane_f32(v111.f32[0] + v111.f32[0], *(float32x2_t *)v111.f32, 1);
          float v105 = vmuls_lane_f32(v111.f32[0] + v111.f32[0], v111, 2);
          float v106 = vmuls_lane_f32(v111.f32[1] + v111.f32[1], v111, 2);
          float v107 = *(float *)_Q2.i32 * (float)(v111.f32[0] + v111.f32[0]);
          *(float *)v108.i32 = *(float *)_Q2.i32 * (float)(v111.f32[1] + v111.f32[1]);
          v111.f32[0] = *(float *)_Q2.i32 * (float)(v111.f32[2] + v111.f32[2]);
          *(float *)_Q0.i32 = 1.0 - (float)(v102 + v103);
          *(float *)&_Q0.i32[1] = v104 + v111.f32[0];
          float32x4_t v110 = (float32x4_t)_Q0;
          v110.f32[2] = v105 - *(float *)v108.i32;
          v111.f32[0] = v104 - v111.f32[0];
          v111.f32[1] = 1.0 - (float)(v101 + v103);
          *(float *)v112.i32 = v105 + *(float *)v108.i32;
          *(float *)&v112.i32[1] = v106 - v107;
          float32x4_t v113 = (float32x4_t)v112;
          v113.f32[2] = 1.0 - (float)(v101 + v102);
          float32x4_t v207 = v179;
          int32x4_t v208 = v177;
          int32x4_t v209 = v176;
          float32x4_t v114 = v111;
          do
          {
            v114.f32[2] = v106 + v107;
            *(float32x4_t *)((char *)&v186 + v98 * 4) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v110, COERCE_FLOAT(*(_OWORD *)((char *)&v207 + v98 * 4))), v114, *(float32x2_t *)&v207.f32[v98], 1), v113, *(float32x4_t *)((char *)&v207 + v98 * 4), 2);
            v98 += 4;
          }
          while (v98 != 12);
          uint64_t v115 = 0;
          float32x4_t v116 = v186;
          float32x4_t v117 = (float32x4_t)v187;
          float32x4_t v118 = v188;
          int32x4_t v119 = vzip1q_s32(_Q0, v112);
          int32x4_t v120 = vzip1q_s32(v119, (int32x4_t)v111);
          v120.i32[3] = v180.i32[3];
          int32x4_t v121 = vzip2q_s32(v119, vdupq_lane_s32(*(int32x2_t *)v111.f32, 1));
          v121.i32[3] = v181.i32[3];
          *(float *)v108.i32 = v106 + v107;
          int32x4_t v122 = vzip1q_s32(vzip2q_s32((int32x4_t)v110, (int32x4_t)v113), v108);
          v122.i32[3] = v182.i32[3];
          float32x4_t v207 = (float32x4_t)v120;
          int32x4_t v208 = v121;
          int32x4_t v209 = v122;
          do
          {
            *(float32x4_t *)((char *)&v186 + v115 * 4) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v116, COERCE_FLOAT(*(_OWORD *)((char *)&v207 + v115 * 4))), v117, *(float32x2_t *)&v207.f32[v115], 1), v118, *(float32x4_t *)((char *)&v207 + v115 * 4), 2);
            v115 += 4;
          }
          while (v115 != 12);
          __int32 v123 = v186.i32[2];
          int8x16_t v124 = v187;
          float32x4_t v125 = v188;
          uint64_t v126 = v175 + 48 * v93;
          *(void *)uint64_t v126 = v186.i64[0];
          *(_DWORD *)(v126 + 8) = v123;
          *(void *)(v126 + 16) = v124.i64[0];
          *(_DWORD *)(v126 + 24) = v124.i32[2];
          *(void *)(v126 + 32) = v125.i64[0];
          *(_DWORD *)(v126 + 40) = v125.i32[2];
          ++v93;
          uint64_t v53 = v200;
        }
        while (v93 < v200);
        BOOL v92 = 1;
        unint64_t v55 = (unint64_t)v171;
      }
      goto LABEL_114;
    }
  }
LABEL_158:
  this = v199[0];
  if (v199[0])
  {
    if (v202) {
      return (*(uint64_t (**)(void))(*(void *)v199[0] + 40))();
    }
  }
  return this;
}

BOOL re::PhysXPhysicsSimulation::isInitialized(re::PhysXPhysicsSimulation *this)
{
  return *((void *)this + 119) != 0;
}

uint64_t re::PhysXPhysicsSimulation::services(re::PhysXPhysicsSimulation *this)
{
  return *((void *)this + 118);
}

uint64_t physx::PxSimulationStatistics::PxSimulationStatistics(uint64_t this)
{
  uint64_t v1 = 0;
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(_OWORD *)(this + 52) = 0u;
  *(_OWORD *)(this + 68) = 0u;
  *(_OWORD *)(this + 84) = 0u;
  uint64_t v2 = this;
  *(_OWORD *)(this + 100) = 0u;
  do
  {
    uint64_t v3 = 0;
    uint64_t v4 = this + 28 * v1;
    *(void *)(v4 + 124) = 0;
    *(void *)(v4 + 116) = 0;
    *(_DWORD *)(v4 + 140) = 0;
    *(void *)(v4 + 132) = 0;
    *(void *)(v4 + 320) = 0;
    *(void *)(v4 + 328) = 0;
    *(void *)(v4 + 312) = 0;
    *(_DWORD *)(v4 + 336) = 0;
    do
    {
      uint64_t v5 = v2 + v3;
      *(_DWORD *)(v5 + 508) = 0;
      *(_DWORD *)(v5 + 704) = 0;
      v3 += 4;
    }
    while (v3 != 28);
    ++v1;
    v2 += 28;
  }
  while (v1 != 7);
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(void *)(this + 40) = 0;
  return this;
}

void re::AssetDeduplication::deduplicate(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v99 = *MEMORY[0x263EF8340];
  unsigned int v89 = 0;
  long long v5 = 0uLL;
  long long v87 = 0u;
  long long v88 = 0u;
  uint64_t v90 = 0x7FFFFFFFLL;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint64_t v7 = *(void *)a1;
    uint64_t v8 = 24 * v6;
    do
    {
      v7 += 24;
      v8 -= 24;
    }
    while (v8);
    unsigned int v9 = v89;
    long long v5 = 0uLL;
  }
  else
  {
    unsigned int v9 = 0;
  }
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = v5;
  *(_OWORD *)(a3 + 16) = v5;
  *(void *)(a3 + 36) = 0x7FFFFFFFLL;
  unsigned int v85 = 0;
  long long v83 = v5;
  long long v84 = v5;
  uint64_t v86 = 0x7FFFFFFFLL;
  v82[1] = 0;
  v82[2] = 0;
  v82[0] = *(void *)(a2 + 1040);
  uint64_t v10 = 0;
  if (v9)
  {
    double v11 = (int *)(v88 + 8);
    while (1)
    {
      int v12 = *v11;
      v11 += 10;
      if (v12 < 0) {
        break;
      }
      if (v9 == ++v10)
      {
        LODWORD(v10) = v9;
        break;
      }
    }
  }
  if (v9 == v10)
  {
    unsigned int v13 = 0;
LABEL_64:
    LODWORD(v36) = 0;
    goto LABEL_65;
  }
  uint64_t v14 = v10;
  uint64_t v15 = v88;
  do
  {
    uint64_t v16 = v15 + 40 * v14;
    uint64_t v19 = *(void *)(v16 + 24);
    uint64_t v18 = v16 + 24;
    uint64_t v17 = v19;
    if (v19)
    {
      uint64_t v20 = *(uint64_t **)(v17 + 264);
      float32x4_t v21 = re::TextureAsset::assetType((re::TextureAsset *)a1);
      if (v20 == v21) {
        goto LABEL_20;
      }
    }
    else
    {
      float32x4_t v21 = re::TextureAsset::assetType((re::TextureAsset *)a1);
    }
    if (*(void *)v18)
    {
      uint64_t v22 = *(void *)(*(void *)v18 + 264);
      a1 = (uint64_t)re::MeshAsset::assetType((re::MeshAsset *)v21);
      if (v22 == a1)
      {
LABEL_20:
        float v23 = (re::AssetHandle *)(v18 - 8);
        uint64_t v98 = 0;
        memset(buf, 0, sizeof(buf));
        LODWORD(v97) = 0;
        v81[0] = &unk_26E7147E8;
        v81[1] = buf;
        v78[0] = v82;
        memset(&v78[1], 0, 24);
        int v79 = 2;
        __int16 v80 = 256;
        __n128 v24 = re::AssetUtilities::saveAssetHandleToStream(v23, (uint64_t)v81, (uint64_t)v78, (uint64_t)v75);
        if (!v75[0] && (void)v76)
        {
          if (BYTE8(v76)) {
            (*(void (**)(__n128))(*(void *)v76 + 40))(v24);
          }
          long long v76 = 0u;
          long long v77 = 0u;
        }
        if (*(void *)&buf[16])
        {
          MurmurHash3_x64_128(v98, *(int *)&buf[16], 0, &v91);
          unint64_t v25 = (v92 + (v91 << 6) + (v91 >> 2) - 0x61C8864680B583E9) ^ v91;
        }
        else
        {
          unint64_t v25 = 0;
        }
        unint64_t v74 = v25;
        uint64_t v26 = v83;
        unint64_t v27 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
        unint64_t v28 = v27 ^ (v27 >> 31);
        if ((void)v83)
        {
          uint64_t v29 = *(unsigned int *)(*((void *)&v83 + 1) + 4 * (v28 % DWORD2(v84)));
          if (v29 != 0x7FFFFFFF)
          {
            if (*(void *)(v84 + (v29 << 6) + 16) == v25) {
              goto LABEL_41;
            }
            while (1)
            {
              uint64_t v29 = *(_DWORD *)(v84 + (v29 << 6) + 8) & 0x7FFFFFFF;
              if (v29 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v84 + (v29 << 6) + 16) == v25) {
                goto LABEL_38;
              }
            }
          }
          uint64_t v95 = 0;
          uint64_t v92 = 0;
          uint64_t v93 = 0;
          unint64_t v91 = 0;
          int v94 = 0;
          unint64_t v30 = v28 % DWORD2(v84);
          uint64_t v31 = *(unsigned int *)(*((void *)&v83 + 1) + 4 * v30);
          if (v31 != 0x7FFFFFFF)
          {
            while (*(void *)(v84 + (v31 << 6) + 16) != v25)
            {
              uint64_t v31 = *(_DWORD *)(v84 + (v31 << 6) + 8) & 0x7FFFFFFF;
              if (v31 == 0x7FFFFFFF) {
                goto LABEL_36;
              }
            }
            goto LABEL_37;
          }
        }
        else
        {
          LODWORD(v30) = 0;
          uint64_t v95 = 0;
          uint64_t v92 = 0;
          uint64_t v93 = 0;
          unint64_t v91 = 0;
          int v94 = 0;
        }
LABEL_36:
        re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove((uint64_t)&v83, v30, v28, &v74, (uint64_t)&v91);
        ++HIDWORD(v86);
        uint64_t v26 = v83;
LABEL_37:
        re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v91);
LABEL_38:
        if (!v26)
        {
          uint64_t v32 = v84;
          goto LABEL_44;
        }
LABEL_41:
        uint64_t v32 = v84;
        uint64_t v33 = *(unsigned int *)(*((void *)&v83 + 1) + 4 * (v28 % DWORD2(v84)));
        if (v33 != 0x7FFFFFFF)
        {
          while (*(void *)(v84 + (v33 << 6) + 16) != v25)
          {
            uint64_t v33 = *(_DWORD *)(v84 + (v33 << 6) + 8) & 0x7FFFFFFF;
            if (v33 == 0x7FFFFFFF) {
              goto LABEL_44;
            }
          }
          goto LABEL_45;
        }
LABEL_44:
        uint64_t v33 = 0x7FFFFFFFLL;
LABEL_45:
        re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)(v32 + (v33 << 6) + 24), v23);
        a1 = *(void *)buf;
        if (*(void *)buf && v98) {
          a1 = (*(uint64_t (**)(void))(**(void **)buf + 40))(*(void *)buf);
        }
      }
    }
    else
    {
      a1 = (uint64_t)re::MeshAsset::assetType((re::MeshAsset *)v21);
    }
    uint64_t v15 = v88;
    if (v89 <= (int)v10 + 1) {
      unsigned int v34 = v10 + 1;
    }
    else {
      unsigned int v34 = v89;
    }
    while (1)
    {
      uint64_t v14 = (v10 + 1);
      if (v34 - 1 == v10) {
        break;
      }
      LODWORD(v10) = v10 + 1;
      unsigned int v35 = v14;
      if ((*(_DWORD *)(v88 + 40 * v14 + 8) & 0x80000000) != 0) {
        goto LABEL_58;
      }
    }
    unsigned int v35 = v34;
LABEL_58:
    LODWORD(v10) = v35;
  }
  while (v9 != v35);
  unsigned int v13 = v85;
  if (!v85) {
    goto LABEL_64;
  }
  uint64_t v36 = 0;
  uint64_t v37 = (int *)(v84 + 8);
  while (1)
  {
    int v38 = *v37;
    v37 += 16;
    if (v38 < 0) {
      break;
    }
    if (v85 == ++v36)
    {
      LODWORD(v36) = v85;
      break;
    }
  }
LABEL_65:
  if (v13 != v36)
  {
    uint64_t v39 = v36;
    uint64_t v40 = v84;
    unsigned int v73 = v13;
    while (1)
    {
      uint64_t v41 = v40 + (v39 << 6);
      unint64_t v44 = *(void *)(v41 + 40);
      int8x16_t v43 = (unint64_t *)(v41 + 40);
      unint64_t v42 = v44;
      float32x4_t v45 = (re::AssetHandle *)v43[2];
      if (v44 < 2) {
        break;
      }
      float32x4_t v47 = (re::AssetHandle *)((char *)v45 + 24);
      uint64_t v48 = 24 * v42 - 24;
      do
      {
        float32x4_t v49 = re::AssetHandle::assetInfo(v47);
        if (v49[13]) {
          float32x4_t v50 = (char *)v49[14];
        }
        else {
          float32x4_t v50 = (char *)v49 + 105;
        }
        a1 = (uint64_t)re::AssetHandle::assetInfo(v45);
        unint64_t v51 = *(void *)(a1 + 112);
        if ((*(unsigned char *)(a1 + 104) & 1) == 0) {
          unint64_t v51 = a1 + 105;
        }
        if ((unint64_t)v50 < v51) {
          float32x4_t v45 = v47;
        }
        float32x4_t v47 = (re::AssetHandle *)((char *)v47 + 24);
        v48 -= 24;
      }
      while (v48);
      int8x16_t v46 = (re::AssetHandle *)v43[2];
      unint64_t v42 = *v43;
      if (*v43) {
        goto LABEL_80;
      }
LABEL_91:
      if (v73 <= (int)v36 + 1) {
        unsigned int v61 = v36 + 1;
      }
      else {
        unsigned int v61 = v73;
      }
      while (1)
      {
        uint64_t v39 = (v36 + 1);
        if (v61 - 1 == v36) {
          break;
        }
        LODWORD(v36) = v36 + 1;
        unsigned int v62 = v39;
        if ((*(_DWORD *)(v40 + (v39 << 6) + 8) & 0x80000000) != 0) {
          goto LABEL_98;
        }
      }
      unsigned int v62 = v61;
LABEL_98:
      LODWORD(v36) = v62;
      if (v73 == v62) {
        goto LABEL_99;
      }
    }
    int8x16_t v46 = (re::AssetHandle *)v43[2];
    if (!v42) {
      goto LABEL_91;
    }
LABEL_80:
    float32x4_t v52 = v43 - 3;
    uint64_t v53 = 24 * v42;
    do
    {
      BOOL v54 = (re *)re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, v46, v45);
      unint64_t v55 = *re::pipelineLogObjects(v54);
      a1 = os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG);
      if (a1)
      {
        unint64_t v56 = *v52;
        float32x4_t v57 = re::AssetHandle::assetInfo(v46);
        if (v57[17]) {
          float32x4_t v58 = (char *)v57[18];
        }
        else {
          float32x4_t v58 = (char *)v57 + 137;
        }
        float32x4_t v59 = re::AssetHandle::assetInfo(v45);
        if (v59[17]) {
          unint64_t v60 = (char *)v59[18];
        }
        else {
          unint64_t v60 = (char *)v59 + 137;
        }
        *(_DWORD *)buf = 134218498;
        *(void *)&buf[4] = v56;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v58;
        *(_WORD *)&buf[22] = 2080;
        int32x4_t v97 = v60;
        _os_log_debug_impl(&dword_233120000, v55, OS_LOG_TYPE_DEBUG, "AssetDeduplication: Computed hash %zu (matching '%s') for asset '%s'", buf, 0x20u);
      }
      int8x16_t v46 = (re::AssetHandle *)((char *)v46 + 24);
      v53 -= 24;
    }
    while (v53);
    goto LABEL_91;
  }
LABEL_99:
  uint64_t v63 = *(unsigned int *)(a3 + 32);
  if (v63)
  {
    uint64_t v64 = 0;
    int32x4_t v65 = (int *)(*(void *)(a3 + 16) + 8);
    while (1)
    {
      int v66 = *v65;
      v65 += 16;
      if (v66 < 0) {
        break;
      }
      if (v63 == ++v64)
      {
        LODWORD(v64) = *(_DWORD *)(a3 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v64) = 0;
  }
  if (v63 == v64)
  {
    uint64_t v67 = 0;
  }
  else
  {
    uint64_t v67 = 0;
    uint64_t v68 = v64;
    uint64_t v69 = *(void *)(a3 + 16);
    do
    {
      if (*(void *)(v69 + (v68 << 6) + 24) != *(void *)(v69 + (v68 << 6) + 48)) {
        ++v67;
      }
      if (v63 <= (int)v64 + 1) {
        int v70 = v64 + 1;
      }
      else {
        int v70 = *(_DWORD *)(a3 + 32);
      }
      int v71 = v64;
      while (1)
      {
        uint64_t v68 = (v71 + 1);
        if (v70 - 1 == v71) {
          break;
        }
        ++v71;
        LODWORD(v64) = v68;
        if ((*(_DWORD *)(v69 + (v68 << 6) + 8) & 0x80000000) != 0) {
          goto LABEL_118;
        }
      }
      LODWORD(v64) = v70;
LABEL_118:
      ;
    }
    while (v63 != v64);
  }
  uint64_t v72 = *re::pipelineLogObjects((re *)a1);
  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134218240;
    *(void *)&buf[4] = v67;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = HIDWORD(v88);
    _os_log_debug_impl(&dword_233120000, v72, OS_LOG_TYPE_DEBUG, "AssetDeduplication: Deduplicated %li assets out of %u", buf, 0x12u);
  }
  re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)&v83);
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v87);
}

uint64_t re::anonymous namespace'::gatherDependencies(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(result + 8))
  {
    long long v5 = (re::AssetHandle *)result;
    int64x2_t result = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a3, result);
    if ((result & 1) == 0)
    {
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, v5);
      (*(void (**)(void *__return_ptr, uint64_t, re::AssetHandle *))(*(void *)a2 + 280))(v8, a2, v5);
      if (v9)
      {
        uint64_t v6 = v10;
        uint64_t v7 = 24 * v9;
        do
        {
          v6 += 24;
          v7 -= 24;
        }
        while (v7);
      }
      return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v8);
    }
  }
  return result;
}

void re::AssetDeduplication::remap(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 36) = 0x7FFFFFFFLL;
  uint64_t v6 = *(unsigned int *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 18;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if (v6 != v7)
  {
    uint64_t v10 = v7;
    uint64_t v11 = *(void *)(a2 + 16);
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)v33, (const re::AssetHandle *)(v11 + 72 * v10 + 16));
      re::AssetHandle::AssetHandle((re::AssetHandle *)v31, (const re::AssetHandle *)v33);
      if (!re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(a1, (uint64_t)v33))goto LABEL_20; {
      if (*(void *)a1)
      }
      {
        if (v34) {
          uint64_t v12 = *(void *)(v34 + 664);
        }
        else {
          uint64_t v12 = 0;
        }
        unint64_t v14 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) >> 27));
        unint64_t v15 = (v12 ^ (v14 >> 31) ^ v14) % *(unsigned int *)(a1 + 24);
        uint64_t v13 = *(void *)(a1 + 16);
        uint64_t v16 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v15);
        if (v16 != 0x7FFFFFFF)
        {
          do
          {
            uint64_t v17 = v13 + (v16 << 6);
            if (*(void *)(v17 + 24) == v34) {
              goto LABEL_19;
            }
            uint64_t v16 = *(_DWORD *)(v17 + 8) & 0x7FFFFFFF;
          }
          while (v16 != 0x7FFFFFFF);
        }
      }
      else
      {
        uint64_t v13 = *(void *)(a1 + 16);
      }
      uint64_t v16 = 0x7FFFFFFFLL;
LABEL_19:
      re::AssetHandle::operator=((uint64_t)v31, (uint64_t *)(v13 + (v16 << 6) + 40));
LABEL_20:
      BOOL v18 = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(a2, (uint64_t)v31);
      if (v18)
      {
        if (*(void *)a2)
        {
          if (v32) {
            uint64_t v19 = *(void *)(v32 + 664);
          }
          else {
            uint64_t v19 = 0;
          }
          unint64_t v26 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) >> 27));
          unint64_t v27 = (v19 ^ (v26 >> 31) ^ v26) % *(unsigned int *)(a2 + 24);
          uint64_t v25 = *(void *)(a2 + 16);
          uint64_t v28 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * v27);
          if (v28 != 0x7FFFFFFF)
          {
            while (*(void *)(v25 + 72 * v28 + 24) != v32)
            {
              uint64_t v28 = *(_DWORD *)(v25 + 72 * v28 + 8) & 0x7FFFFFFF;
              if (v28 == 0x7FFFFFFF) {
                goto LABEL_37;
              }
            }
            goto LABEL_38;
          }
        }
        else
        {
          uint64_t v25 = *(void *)(a2 + 16);
        }
LABEL_37:
        uint64_t v28 = 0x7FFFFFFFLL;
LABEL_38:
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, (re::AssetHandle *)v33, (const re::DynamicString *)(v25 + 72 * v28 + 40));
        goto LABEL_39;
      }
      uint64_t v20 = *re::pipelineLogObjects((re *)v18);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        float32x4_t v21 = re::AssetHandle::assetInfo((re::AssetHandle *)v33);
        if (v21[17]) {
          uint64_t v22 = (char *)v21[18];
        }
        else {
          uint64_t v22 = (char *)v21 + 137;
        }
        float v23 = re::AssetHandle::assetInfo((re::AssetHandle *)v31);
        if (v23[17]) {
          __n128 v24 = (char *)v23[18];
        }
        else {
          __n128 v24 = (char *)v23 + 137;
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v36 = v22;
        __int16 v37 = 2080;
        int v38 = v24;
        _os_log_debug_impl(&dword_233120000, v20, OS_LOG_TYPE_DEBUG, "Found a duplicate asset '%s' (equal to '%s') that is not remapped. Leaving it unchanged.", buf, 0x16u);
      }
LABEL_39:
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v31);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v33);
      uint64_t v11 = *(void *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v7 + 1)) {
        int v29 = v7 + 1;
      }
      else {
        int v29 = *(_DWORD *)(a2 + 32);
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v29 - 1 == v7) {
          break;
        }
        LODWORD(v7) = v7 + 1;
        int v30 = v10;
        if ((*(_DWORD *)(v11 + 72 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_46;
        }
      }
      int v30 = v29;
LABEL_46:
      LODWORD(v7) = v30;
    }
    while (v6 != v30);
  }
}

double re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<re::AssetHandle>::deinit(v6 + 24);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(void *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v28, v13, v12);
          long long v15 = *(_OWORD *)v28;
          *(_OWORD *)uint64_t v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v28[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v28[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21, v21 + 8);
              }
              v21 += 64;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + (v9 << 6) + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + (v9 << 6) + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v9 << 6)) = a3;
  *(void *)(*(void *)(a1 + 16) + (v9 << 6) + 16) = *a4;
  uint64_t v25 = *(void *)(a1 + 16) + (v9 << 6);
  *(void *)(v25 + 56) = 0;
  *(_DWORD *)(v25 + 48) = 0;
  *(void *)(v25 + 32) = 0;
  *(void *)(v25 + 40) = 0;
  *(void *)(v25 + 24) = 0;
  *(void *)(v25 + 24) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(v25 + 32) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  uint64_t v26 = *(void *)(v25 + 40);
  *(void *)(v25 + 40) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v26;
  uint64_t v27 = *(void *)(v25 + 56);
  *(void *)(v25 + 56) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v27;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v25 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void ___ZN2re35pipelineHighFrequencyLoggingEnabledEv_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"enablePipelineHFLogs", a2, (char *)v5);
  if (LOBYTE(v5[0])) {
    unsigned __int8 v3 = BYTE1(v5[0]);
  }
  else {
    unsigned __int8 v3 = 0;
  }
  re::pipelineLogObjects(v2);
  uint64_t v4 = re::pipelineLogObjects(void)::logObjects;
  if (os_log_type_enabled((os_log_t)re::pipelineLogObjects(void)::logObjects, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "enablePipelineHFLogs=%d.", (uint8_t *)v5, 8u);
  }
  re::pipelineHighFrequencyLoggingEnabled(void)::shouldLog = v3;
}

uint64_t *re::pipelineLogObjects(re *this)
{
  {
    re::pipelineLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Pipeline");
  }
  return &re::pipelineLogObjects(void)::logObjects;
}

uint64_t re::readZipArchiveEntry@<X0>(re *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v9 = *re::pipelineLogObjects(this);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = this;
    _os_log_debug_impl(&dword_233120000, v9, OS_LOG_TYPE_DEBUG, "Reading archived file '%s' from archive '%s'", buf, 0x16u);
  }
  uint64_t v30 = archive_read_new();
  if (!v30)
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) archive_read_new() returned null", "ar.get()", "readZipArchiveEntry", 69);
    _os_crash();
    __break(1u);
  }
  int support_format_zip_seekable = archive_read_support_format_zip_seekable();
  if (!support_format_zip_seekable)
  {
    int support_format_zip_seekable = archive_read_open_filename();
    if (!support_format_zip_seekable)
    {
      uint64_t v29 = 0;
      while (1)
      {
        next_header = (re *)archive_read_next_header();
        if (next_header)
        {
          int v15 = (int)next_header;
          if (next_header == 1)
          {
            uint64_t v20 = *re::pipelineLogObjects(next_header);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              *(void *)&uint8_t buf[4] = a2;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = this;
              _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "No such file '%s' in archive '%s'", buf, 0x16u);
            }
            uint64_t v21 = (re::WrappedError *)*MEMORY[0x263EFFC60];
            uint64_t v22 = 2;
            goto LABEL_26;
          }
          if (v15 != -20)
          {
            id v23 = *(id *)buf;
            *(unsigned char *)a4 = 0;
            *(void *)(a4 + 8) = v23;
            goto LABEL_8;
          }
        }
        uint64_t v16 = (const char *)archive_entry_pathname();
        if (!strcmp(v16, a2))
        {
          is_set = (re *)archive_entry_size_is_set();
          if (is_set)
          {
            unint64_t v18 = archive_entry_size();
            *(void *)&buf[16] = 0;
            uint64_t v32 = 0;
            *(void *)buf = a3;
            *(void *)&buf[8] = 0;
            re::DynamicString::setCapacity(buf, v18 + 1);
            re::DynamicString::resize(buf, v18, 0);
            uint64_t data = archive_read_data();
            if (data == v18)
            {
              re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)buf);
              *(unsigned char *)a4 = 1;
              *(void *)(a4 + 8) = v26;
              *(void *)(a4 + 32) = v28;
              *(_OWORD *)(a4 + 16) = v27;
            }
            else
            {
              uint64_t v25 = v26;
              uint64_t v26 = 0;
              *(unsigned char *)a4 = 0;
              *(void *)(a4 + 8) = v25;
            }
            if (*(void *)buf && (buf[8] & 1) != 0) {
              (*(void (**)(void))(**(void **)buf + 40))();
            }
            return archive_read_free();
          }
          signed int v24 = *re::pipelineLogObjects(is_set);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Archive read error: entry size unexpectedly not set", buf, 2u);
          }
          uint64_t v21 = (re::WrappedError *)*MEMORY[0x263EFFC60];
          uint64_t v22 = 79;
LABEL_26:
          re::WrappedError::make(v21, (const __CFString *)v22, 0, buf);
          goto LABEL_7;
        }
      }
    }
  }
LABEL_7:
  uint64_t v12 = *(void *)buf;
  *(void *)buf = 0;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = v12;
LABEL_8:

  return archive_read_free();
}

void re::anonymous namespace'::makeArchiveError(void *a1, uint64_t a2, int a3)
{
  *(void *)&v15[7] = *MEMORY[0x263EF8340];
  long long v5 = (re *)archive_errno();
  int v6 = (int)v5;
  if (a3 <= -21)
  {
    if (a3 == -30)
    {
      int v7 = *re::pipelineLogObjects(v5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v12 = 67109378;
        int v13 = v6;
        __int16 v14 = 2082;
        *(void *)int v15 = archive_error_string();
        uint64_t v8 = "Archive read error (fatal) %d: %{public}s";
        goto LABEL_14;
      }
      goto LABEL_18;
    }
    if (a3 == -25)
    {
      int v7 = *re::pipelineLogObjects(v5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v12 = 67109378;
        int v13 = v6;
        __int16 v14 = 2082;
        *(void *)int v15 = archive_error_string();
        uint64_t v8 = "Archive read error %d: %{public}s";
LABEL_14:
        uint64_t v9 = v7;
        uint32_t v10 = 18;
LABEL_17:
        _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v12, v10);
        goto LABEL_18;
      }
      goto LABEL_18;
    }
LABEL_15:
    int v11 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = 67109634;
      int v13 = a3;
      __int16 v14 = 1024;
      *(_DWORD *)int v15 = v6;
      v15[2] = 2082;
      *(void *)&v15[3] = archive_error_string();
      uint64_t v8 = "Archive read unexpected result %d, errno %d: %{public}s";
      uint64_t v9 = v11;
      uint32_t v10 = 24;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  if (a3 == -20)
  {
    int v7 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v12 = 67109378;
      int v13 = v6;
      __int16 v14 = 2082;
      *(void *)int v15 = archive_error_string();
      uint64_t v8 = "Archive read error (partial) %d: %{public}s";
      goto LABEL_14;
    }
    goto LABEL_18;
  }
  if (a3 != -10) {
    goto LABEL_15;
  }
  int v7 = *re::pipelineLogObjects(v5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v12 = 67109378;
    int v13 = v6;
    __int16 v14 = 2082;
    *(void *)int v15 = archive_error_string();
    uint64_t v8 = "Archive read error (retryable) %d: %{public}s";
    goto LABEL_14;
  }
LABEL_18:
  re::WrappedError::make((re::WrappedError *)*MEMORY[0x263EFFC60], (const __CFString *)v6, 0, a1);
}

double re::ZipArchiveGetDefaultLayerMTimeFromArchive()
{
  uint64_t v13 = 0;
  while (!archive_read_next_header())
  {
    uint64_t v1 = (char *)archive_entry_pathname();
    std::string::basic_string[abi:nn180100]<0>(&__str, v1);
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    else {
      p_str = &__str;
    }
    uint64_t v4 = (char *)&p_str[-1].__r_.__value_.__r.__words[2] + 7;
    while (size)
    {
      int v5 = v4[size--];
      if (v5 == 46) {
        goto LABEL_11;
      }
    }
    std::string::size_type size = -1;
LABEL_11:
    std::string::basic_string(&__p, &__str, size + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_ == 3)
      {
        if (*(_WORD *)__p.__r_.__value_.__l.__data_ != 29557 || *(unsigned char *)(__p.__r_.__value_.__r.__words[0] + 2) != 100)
        {
LABEL_31:
          char v7 = 1;
LABEL_33:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_34;
        }
        goto LABEL_32;
      }
      if (__p.__r_.__value_.__l.__size_ != 4) {
        goto LABEL_31;
      }
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (*(_DWORD *)__p.__r_.__value_.__l.__data_ != 1667527541) {
        goto LABEL_19;
      }
    }
    else
    {
      if (HIBYTE(__p.__r_.__value_.__r.__words[2]) == 3)
      {
        if (LOWORD(__p.__r_.__value_.__l.__data_) != 29557 || __p.__r_.__value_.__s.__data_[2] != 100)
        {
LABEL_26:
          char v7 = 1;
          goto LABEL_34;
        }
        goto LABEL_32;
      }
      if (HIBYTE(__p.__r_.__value_.__r.__words[2]) != 4) {
        goto LABEL_26;
      }
      if (LODWORD(__p.__r_.__value_.__l.__data_) != 1667527541)
      {
        p_p = &__p;
LABEL_19:
        if (LODWORD(p_p->__r_.__value_.__l.__data_) != 1633973109)
        {
          char v7 = 1;
          if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
            goto LABEL_33;
          }
          goto LABEL_34;
        }
      }
    }
LABEL_32:
    char v7 = 0;
    double v0 = (double)archive_entry_mtime();
    if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_33;
    }
LABEL_34:
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__str.__r_.__value_.__l.__data_);
      if ((v7 & 1) == 0) {
        return v0;
      }
    }
    else if ((v7 & 1) == 0)
    {
      return v0;
    }
  }
  return 0.0;
}

double re::ZipArchiveGetDefaultLayerMTime(re *this, char *a2, __CFError **a3)
{
  if (!archive_read_new()) {
    return 0.0;
  }
  archive_read_support_format_zip();
  if (archive_read_open_filename())
  {
    double DefaultLayerMTimeFromArchive = 0.0;
    if (a2)
    {
      CFStringRef v5 = (const __CFString *)*MEMORY[0x263EFFC60];
      int v6 = archive_errno();
      *(void *)a2 = CFErrorCreate(0, v5, v6, 0);
    }
  }
  else
  {
    double DefaultLayerMTimeFromArchive = re::ZipArchiveGetDefaultLayerMTimeFromArchive();
  }
  archive_read_free();
  return DefaultLayerMTimeFromArchive;
}

uint64_t re::AssetCompilerRegistry::registerAssetCompiler(uint64_t a1, uint64_t *a2)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  CFStringRef v5 = (_anonymous_namespace_ *)(*(void *(**)(uint64_t *__return_ptr))(*(void *)*a2 + 32))(&v40);
  unint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 >= v6)
  {
    unint64_t v8 = v7 + 1;
    if (v6 < v7 + 1)
    {
      if (*(void *)(a1 + 8))
      {
        uint64_t v9 = 2 * v6;
        BOOL v10 = v6 == 0;
        unint64_t v11 = 8;
        if (!v10) {
          unint64_t v11 = v9;
        }
        if (v11 <= v8) {
          unint64_t v12 = v8;
        }
        else {
          unint64_t v12 = v11;
        }
        re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity((void *)(a1 + 8), v12);
      }
      else
      {
        re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity((void *)(a1 + 8), v8);
        ++*(_DWORD *)(a1 + 32);
      }
    }
    unint64_t v7 = *(void *)(a1 + 24);
  }
  uint64_t v13 = (void *)(*(void *)(a1 + 40) + 40 * v7);
  uint64_t v14 = *a2;
  *a2 = 0;
  *uint64_t v13 = v14;
  int v15 = (_anonymous_namespace_ *)std::__function::__value_func<void ()(re::AssetCompiler *)>::__value_func[abi:nn180100]((uint64_t)(v13 + 1), (uint64_t)(a2 + 1));
  uint64_t v16 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v16 + 1;
  ++*(_DWORD *)(a1 + 32);
  uint64_t v39 = v16;
  if (v41)
  {
    unint64_t v17 = 0;
    while (1)
    {
      unint64_t v18 = *(const char **)(v42 + 8 * v17);
      BOOL v19 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1 + 48, (uint64_t)buf);
      uint64_t v20 = *(_anonymous_namespace_ **)buf;
      if (*(void *)buf && (buf[8] & 1) != 0) {
        uint64_t v20 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[16]);
      }
      if (!v19)
      {
        unint64_t v21 = v41;
        if (v41 <= v17) {
          goto LABEL_54;
        }
        uint64_t v26 = *(const char **)(v42 + 8 * v17);
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>(a1 + 48, (re::DynamicString *)buf, &v39);
        int v15 = *(_anonymous_namespace_ **)buf;
        if (!*(void *)buf || (buf[8] & 1) == 0) {
          goto LABEL_43;
        }
        long long v27 = *(unsigned char **)&buf[16];
        goto LABEL_42;
      }
      unint64_t v21 = v41;
      if (v41 <= v17)
      {
        uint64_t v33 = 0;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int8x16_t v46 = 136315906;
        *(void *)&v46[4] = "operator[]";
        __int16 v47 = 1024;
        int v48 = 797;
        __int16 v49 = 2048;
        unint64_t v50 = v17;
        __int16 v51 = 2048;
        unint64_t v52 = v21;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_54:
        *(void *)int8x16_t v46 = 0;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v44 = 136315906;
        v45[0] = "operator[]";
        v45[1] = 0x8000000031D0400;
        v45[2] = v17;
        LOWORD(v45[3]) = 2048;
        *(void *)((char *)&v45[3] + 2) = v21;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_55:
        uint64_t v43 = 0;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int8x16_t v46 = 136315906;
        *(void *)&v46[4] = "operator[]";
        __int16 v47 = 1024;
        int v48 = 789;
        __int16 v49 = 2048;
        unint64_t v50 = v21;
        __int16 v51 = 2048;
        unint64_t v52 = v2;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_56:
        *(void *)int8x16_t v46 = 0;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v44 = 136315906;
        v45[0] = "operator[]";
        v45[1] = 0x8000000031D0400;
        v45[2] = v17;
        LOWORD(v45[3]) = 2048;
        *(void *)((char *)&v45[3] + 2) = v2;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v22 = *(const char **)(v42 + 8 * v17);
      unint64_t v23 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v33);
      if (!*(void *)(a1 + 48)) {
        break;
      }
      uint64_t v24 = *(void *)(a1 + 64);
      uint64_t v25 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * (v23 % *(unsigned int *)(a1 + 72)));
      if (v25 == 0x7FFFFFFF) {
        goto LABEL_29;
      }
      while (!re::DynamicString::operator==(v24 + 56 * v25 + 16, (uint64_t)&v33))
      {
        uint64_t v25 = *(_DWORD *)(v24 + 56 * v25 + 8) & 0x7FFFFFFF;
        if (v25 == 0x7FFFFFFF) {
          goto LABEL_29;
        }
      }
LABEL_30:
      unint64_t v21 = *(void *)(v24 + 56 * v25 + 48);
      unint64_t v2 = *(void *)(a1 + 24);
      if (v2 <= v21) {
        goto LABEL_55;
      }
      (*(void (**)(int *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 40 * v21) + 16))(&v44);
      re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)v45 + 4));
      if (*(void *)((char *)v45 + 4))
      {
        if ((v45[1] & 0x100000000) != 0) {
          (*(void (**)(void))(**(void **)((char *)v45 + 4) + 40))();
        }
        memset((char *)v45 + 4, 0, 32);
      }
      uint64_t v28 = v33;
      if (v33 && (v34 & 1) != 0) {
        uint64_t v28 = (re *)(*(uint64_t (**)(void))(*(void *)v33 + 40))();
      }
      uint64_t v29 = *re::pipelineLogObjects(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        unint64_t v2 = v41;
        if (v41 <= v17) {
          goto LABEL_56;
        }
        uint64_t v30 = *(void *)(v42 + 8 * v17);
        uint64_t v31 = v37;
        if (v36) {
          uint64_t v31 = v38;
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v30;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v31;
        _os_log_error_impl(&dword_233120000, v29, OS_LOG_TYPE_ERROR, "This extension %s is already registered for assets of type %s", buf, 0x16u);
      }
      int v15 = v35;
      if (v35 && (v36 & 1) != 0)
      {
        long long v27 = v38;
LABEL_42:
        int v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, unsigned char *))(*(void *)v15 + 40))(v15, v27);
      }
LABEL_43:
      if (v41 <= ++v17) {
        goto LABEL_49;
      }
    }
    uint64_t v24 = *(void *)(a1 + 64);
LABEL_29:
    uint64_t v25 = 0x7FFFFFFFLL;
    goto LABEL_30;
  }
LABEL_49:
  uint64_t result = v40;
  if (v40)
  {
    if (v42) {
      return (*(uint64_t (**)(void))(*(void *)v40 + 40))();
    }
  }
  return result;
}

uint64_t re::AssetCompilerRegistry::getCompilerForExtension(re::AssetCompilerRegistry *this, char *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  char v3 = *a2;
  uint64_t v4 = __s;
  if (*a2)
  {
    uint64_t v5 = 0;
    do
    {
      if ((v3 - 65) < 0x1Au) {
        v3 += 32;
      }
      __s[v5] = v3;
      uint64_t v6 = v5 + 1;
      char v3 = a2[v5 + 1];
      if (v3) {
        BOOL v7 = v5 == 30;
      }
      else {
        BOOL v7 = 1;
      }
      ++v5;
    }
    while (!v7);
    uint64_t v4 = &__s[v6];
  }
  *uint64_t v4 = 0;
  unint64_t v8 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 48, (uint64_t)v21);
  if (*(void *)&v21[0] && (BYTE8(v21[0]) & 1) != 0) {
    (*(void (**)(void))(**(void **)&v21[0] + 40))();
  }
  if (!v8) {
    return 0;
  }
  unint64_t v9 = *v8;
  unint64_t v10 = *((void *)this + 3);
  if (v10 <= v9)
  {
    memset(v21, 0, sizeof(v21));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v13 = 136315906;
    uint64_t v14 = "operator[]";
    __int16 v15 = 1024;
    int v16 = 797;
    __int16 v17 = 2048;
    unint64_t v18 = v9;
    __int16 v19 = 2048;
    unint64_t v20 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*((void *)this + 5) + 40 * v9);
}

uint64_t *re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::clear(uint64_t *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    uint64_t result = (uint64_t *)result[4];
    uint64_t v3 = 40 * v2;
    do
    {
      uint64_t result = std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>::~unique_ptr[abi:nn180100](result)
             + 5;
      v3 -= 40;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

void *re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            BOOL v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      BOOL v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = (uint64_t)(v7 + 1);
        uint64_t v11 = 40 * v9;
        unint64_t v12 = (uint64_t *)v5[4];
        do
        {
          uint64_t v13 = *v8;
          *unint64_t v12 = 0;
          v12 += 5;
          *(void *)(v10 - 8) = v13;
          std::__function::__value_func<void ()(re::AssetCompiler *)>::__value_func[abi:nn180100](v10, (uint64_t)(v8 + 1));
          std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>::~unique_ptr[abi:nn180100](v8);
          v10 += 40;
          unint64_t v8 = v12;
          v11 -= 40;
        }
        while (v11);
        unint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::allocInfo_AssetCompilerService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_430, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_430))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF996C8, "AssetCompilerService");
    __cxa_guard_release(&_MergedGlobals_430);
  }
  return &unk_26AF996C8;
}

void re::initInfo_AssetCompilerService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x5FF8D78549D7284CLL;
  v5[1] = "AssetCompilerService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_AssetCompilerService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_AssetCompilerService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetCompilerService", (uint64_t (*)(re::internal *))re::allocInfo_AssetCompilerService, (re::IntrospectionBase *(*)(void))re::initInfo_AssetCompilerService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetCompilerService>, this);
}

uint64_t re::UniqueNameGenerator::uniqueName@<X0>(re::UniqueNameGenerator *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, re::StringID *a4@<X8>)
{
  if (a2 && *a2) {
    a3 = a2;
  }
  for (unint64_t i = (_DWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this, (uint64_t)&v15);
        i;
        unint64_t i = (_DWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this, (uint64_t)&v15))
  {
    uint64_t v8 = (*i + 1);
    *unint64_t i = v8;
    if (v16) {
      uint64_t v9 = v18;
    }
    else {
      uint64_t v9 = v17;
    }
    re::DynamicString::format((re::DynamicString *)"%s[%u]", (re::DynamicString *)&v13, v9, v8);
    re::DynamicString::operator=((re::DynamicString *)&v15, (re::DynamicString *)&v13);
    if (v13 && (v14 & 1) != 0) {
      (*(void (**)(void))(*(void *)v13 + 40))();
    }
  }
  LODWORD(v13) = 0;
  uint64_t v10 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,unsigned int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned int &>((uint64_t)this, (re::DynamicString *)&v15, &v13);
  if (v16) {
    uint64_t v11 = v18;
  }
  else {
    uint64_t v11 = v17;
  }
  *(void *)a4 = 0;
  *((void *)a4 + 1) = "";
  uint64_t result = v15;
  if (v15)
  {
    if (v16) {
      return (*(uint64_t (**)(void))(*(void *)v15 + 40))();
    }
  }
  return result;
}

void re::usdkit::Resource::makeWithPath(re::usdkit::Resource *this@<X0>, void *a2@<X8>)
{
  long long v4 = (void *)MEMORY[0x263F83EF8];
  id v6 = [NSString stringWithUTF8String:this];
  id v5 = [v4 resourceWithPath:v6];
  *a2 = v5;
}

void re::usdkit::Resource::makeMappedData(id *this@<X0>, void *a2@<X8>)
{
  id v3 = *this;
  long long v4 = [v3 dataNoCopy];
  if (v4)
  {
    uint64_t v10 = MEMORY[0x263EF8330];
    uint64_t v11 = 3221225472;
    unint64_t v12 = ___ZNK2re6usdkit8Resource14makeMappedDataEv_block_invoke;
    uint64_t v13 = &unk_264BE8260;
    id v14 = v3;
    id v5 = v4;
    id v15 = v5;
    id v6 = _Block_copy(&v10);
    id v7 = objc_alloc(MEMORY[0x263EFF8F8]);
    id v8 = v5;
    id v9 = (id)objc_msgSend(v7, "initWithBytesNoCopy:length:deallocator:", objc_msgSend(v8, "bytes", v10, v11, v12, v13), objc_msgSend(v8, "length"), v6);
  }
  else
  {
    id v9 = 0;
  }
  *a2 = v9;
}

re::FrameProfiler *re::FrameProfiler::FrameProfiler(re::FrameProfiler *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_26E717680;
  *((_DWORD *)this + 3) = 0;
  *((_WORD *)this + 8) = 1;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *(void *)((char *)this + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  uint64_t v2 = (char *)this + 72;
  *(void *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((void *)this + 19) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 44) = 545;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 10;
  *((_DWORD *)this + 50) = 1;
  *((_WORD *)this + 102) = 0;
  *((unsigned char *)this + 206) = 0;
  *((void *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 32) = 0;
  *((unsigned char *)this + 264) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((unsigned char *)this + 288) = 0;
  *((unsigned char *)this + 296) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *(_OWORD *)((char *)this + 364) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *(void *)((char *)this + 380) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 106) = 0;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(void *)((char *)this + 428) = 0x7FFFFFFFLL;
  LODWORD(v9[0]) = 0;
  memset(v8, 0, sizeof(v8));
  *(void *)((char *)v9 + 4) = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v2, (uint64_t *)v8);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v8);
  v9[0] = 0;
  memset((char *)v8 + 8, 0, 20);
  re::DynamicArray<float *>::setCapacity(v8, 0xFuLL);
  uint64_t v5 = *((void *)this + 15);
  if (v5 && *(void *)&v8[0] && v5 != *(void *)&v8[0])
  {
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    uint64_t result = (re::FrameProfiler *)_os_crash();
    __break(1u);
  }
  else
  {
    *((void *)this + 15) = *(void *)&v8[0];
    *((_OWORD *)this + 8) = *(_OWORD *)((char *)v8 + 8);
    uint64_t v6 = *((void *)this + 19);
    *((void *)this + 19) = v9[0];
    ++*((_DWORD *)this + 36);
    if (v5)
    {
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      }
    }
    return this;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
    }
  }
  return a1;
}

void re::FrameProfiler::~FrameProfiler(re::FrameProfiler *this)
{
  re::FrameProfiler::deinit(this);
  uint64_t v3 = *((void *)this + 17);
  if (v3)
  {
    uint64_t v4 = (re::FrameCustomStats **)*((void *)this + 19);
    uint64_t v5 = 8 * v3;
    do
    {
      uint64_t v6 = *v4++;
      *((unsigned char *)v6 + 64) = 0;
      uint64_t v7 = re::globalAllocators(v2)[2];
      re::FrameCustomStats::~FrameCustomStats(v6);
      uint64_t v2 = (re *)(*(uint64_t (**)(uint64_t, re::FrameCustomStats *))(*(void *)v7 + 40))(v7, v6);
      v5 -= 8;
    }
    while (v5);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 120);
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 49);
  v8.n128_f64[0] = re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 43);
  uint64_t v9 = *((void *)this + 38);
  if (v9)
  {
    uint64_t v10 = (re::DynamicString *)*((void *)this + 42);
    if (v10)
    {
      uint64_t v11 = *((void *)this + 40);
      if (v11)
      {
        uint64_t v12 = 48 * v11;
        do
        {
          v8.n128_f64[0] = re::DynamicString::deinit(v10);
          uint64_t v10 = (re::DynamicString *)((char *)v10 + 48);
          v12 -= 48;
        }
        while (v12);
        uint64_t v9 = *((void *)this + 38);
        uint64_t v10 = (re::DynamicString *)*((void *)this + 42);
      }
      (*(void (**)(uint64_t, re::DynamicString *, __n128))(*(void *)v9 + 40))(v9, v10, v8);
    }
    *((void *)this + 42) = 0;
    *((void *)this + 39) = 0;
    *((void *)this + 40) = 0;
    *((void *)this + 38) = 0;
    ++*((_DWORD *)this + 82);
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 120);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 3);
}

{
  uint64_t vars8;

  re::FrameProfiler::~FrameProfiler(this);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameProfiler::deinit(re::FrameProfiler *this)
{
  if (*((unsigned char *)this + 206))
  {
    uint64_t v2 = (uint64_t *)((char *)this + 24);
    uint64_t v3 = *((unsigned int *)this + 14);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = (int *)(*((void *)this + 5) + 8);
      while (1)
      {
        int v6 = *v5;
        v5 += 6;
        if (v6 < 0) {
          break;
        }
        if (v3 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 14);
          break;
        }
      }
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if (v3 != v4)
    {
      uint64_t v7 = v4;
      do
      {
        uint64_t v8 = *(void *)(*((void *)this + 5) + 24 * v7 + 16);
        *(unsigned char *)(v8 + 64) = 0;
        re::internal::destroyPersistent<re::FrameStats>((re *)"deinit", 94, (void (***)(void))v8);
        if (*((_DWORD *)this + 14) <= (v4 + 1)) {
          int v9 = v4 + 1;
        }
        else {
          int v9 = *((_DWORD *)this + 14);
        }
        int v10 = v4;
        while (1)
        {
          uint64_t v7 = (v10 + 1);
          if (v9 - 1 == v10) {
            break;
          }
          ++v10;
          LODWORD(v4) = v7;
          if ((*(_DWORD *)(*((void *)this + 5) + 24 * v7 + 8) & 0x80000000) != 0) {
            goto LABEL_18;
          }
        }
        LODWORD(v4) = v9;
LABEL_18:
        ;
      }
      while (v3 != v4);
    }
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
    re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 43);
    *((unsigned char *)this + 206) = 0;
  }
}

void re::FrameProfiler::init(re::FrameProfiler *this)
{
  if (*((unsigned char *)this + 206)) {
    return;
  }
  *((_DWORD *)this + 49) = 0;
  uint64_t v2 = (_anonymous_namespace_ *)std::thread::hardware_concurrency();
  *((_DWORD *)this + 50) = v2;
  memset(v193, 0, 36);
  *(void *)&v193[36] = 0x7FFFFFFFLL;
  uint64_t v3 = (unint64_t *)((char *)this + 24);
  if ((char *)this + 24 != v193)
  {
    uint64_t v4 = *(void *)v193;
    if (!*v3 || *v3 == *(void *)v193)
    {
      *(void *)long long v193 = *v3;
      uint64_t v23 = *(void *)&v193[8];
      uint64_t v24 = *(void *)&v193[16];
      long long v25 = *((_OWORD *)this + 2);
      long long v26 = *((_OWORD *)this + 3);
      *((void *)this + 3) = v4;
      *((void *)this + 4) = v23;
      *((void *)this + 5) = v24;
      *(_OWORD *)&v193[8] = v25;
      *((_OWORD *)this + 3) = *(_OWORD *)&v193[24];
      *(_OWORD *)&v193[24] = v26;
    }
    else
    {
      if (*((_DWORD *)this + 13))
      {
        uint64_t v5 = *((unsigned int *)this + 12);
        if (v5) {
          memset_pattern16(*((void **)this + 4), &unk_2343655D0, 4 * v5);
        }
        uint64_t v6 = *((unsigned int *)this + 14);
        if (v6)
        {
          uint64_t v7 = 0;
          uint64_t v8 = 24 * v6;
          do
          {
            uint64_t v9 = *((void *)this + 5) + v7;
            int v10 = *(_DWORD *)(v9 + 8);
            if (v10 < 0) {
              *(_DWORD *)(v9 + 8) = v10 & 0x7FFFFFFF;
            }
            v7 += 24;
          }
          while (v8 != v7);
        }
        *((_DWORD *)this + 13) = 0;
        *((_DWORD *)this + 14) = 0;
        int v11 = *((_DWORD *)this + 16) + 1;
        *((_DWORD *)this + 15) = 0x7FFFFFFF;
        *((_DWORD *)this + 16) = v11;
      }
      if (v4)
      {
        if (*((_DWORD *)this + 12) < *(_DWORD *)&v193[28]) {
          re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, *(unsigned int *)&v193[28]);
        }
        unint64_t v12 = *(unsigned int *)&v193[32];
        if (*(_DWORD *)&v193[32])
        {
          uint64_t v13 = 0;
          unint64_t v14 = 0;
          do
          {
            id v15 = (uint64_t *)(*(void *)&v193[16] + v13);
            if ((*(_DWORD *)(*(void *)&v193[16] + v13 + 8) & 0x80000000) != 0)
            {
              unint64_t v16 = *v15;
              unint64_t v17 = *((unsigned int *)this + 12);
              unint64_t v18 = *v15 % v17;
              uint64_t v19 = *((unsigned int *)this + 15);
              if (v19 == 0x7FFFFFFF)
              {
                uint64_t v19 = *((unsigned int *)this + 14);
                int v20 = v19;
                if (v19 == v17)
                {
                  re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
                  unint64_t v18 = v16 % *((unsigned int *)this + 12);
                  int v20 = *((_DWORD *)this + 14);
                }
                *((_DWORD *)this + 14) = v20 + 1;
                uint64_t v21 = *((void *)this + 5);
                int v22 = *(_DWORD *)(v21 + 24 * v19 + 8);
              }
              else
              {
                uint64_t v21 = *((void *)this + 5);
                int v22 = *(_DWORD *)(v21 + 24 * v19 + 8);
                *((_DWORD *)this + 15) = v22 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v21 + 24 * v19 + 8) = v22 | 0x80000000;
              *(_DWORD *)(*((void *)this + 5) + 24 * v19 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v19 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v18);
              *(void *)(*((void *)this + 5) + 24 * v19) = v16;
              *(_DWORD *)(*((void *)this + 5) + 24 * v19 + 12) = *((_DWORD *)v15 + 3);
              *(void *)(*((void *)this + 5) + 24 * v19 + 16) = v15[2];
              *(_DWORD *)(*((void *)this + 4) + 4 * v18) = v19;
              ++*((_DWORD *)this + 13);
              unint64_t v12 = *(unsigned int *)&v193[32];
            }
            ++v14;
            v13 += 24;
          }
          while (v14 < v12);
        }
        ++*((_DWORD *)this + 16);
      }
    }
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v193);
  uint64_t v28 = re::globalAllocators(v27);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[2] + 32))(v28[2], 72, 8);
  uint64_t v30 = v29;
  *(_OWORD *)(v29 + 8) = 0u;
  *(_OWORD *)(v29 + 24) = 0u;
  *(_OWORD *)(v29 + 40) = 0u;
  *(_OWORD *)(v29 + 56) = 0u;
  *(_DWORD *)(v29 + 8) = 10;
  *(_OWORD *)(v29 + 16) = 0u;
  *(_OWORD *)(v29 + 32) = 0u;
  *(void *)(v29 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v29 + 64) = 0;
  *(void *)uint64_t v29 = &unk_26E717790;
  unint64_t v31 = *v3;
  if (*v3)
  {
    unint64_t v31 = 0x5692161D100B05E5uLL % *((unsigned int *)this + 12);
    uint64_t v32 = *(unsigned int *)(*((void *)this + 4) + 4 * v31);
    if (v32 != 0x7FFFFFFF)
    {
      uint64_t v179 = *((void *)this + 5);
      if (*(_DWORD *)(v179 + 24 * v32 + 12) == 1) {
        goto LABEL_37;
      }
      while (1)
      {
        LODWORD(v32) = *(_DWORD *)(v179 + 24 * v32 + 8) & 0x7FFFFFFF;
        if (v32 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v179 + 24 * v32 + 12) == 1) {
          goto LABEL_37;
        }
      }
    }
  }
  uint64_t v33 = *((unsigned int *)this + 15);
  if (v33 == 0x7FFFFFFF)
  {
    uint64_t v33 = *((unsigned int *)this + 14);
    int v34 = v33;
    if (v33 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v31) = 0x5692161D100B05E5uLL % *((unsigned int *)this + 12);
      int v34 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v34 + 1;
    uint64_t v35 = *((void *)this + 5);
    int v36 = *(_DWORD *)(v35 + 24 * v33 + 8);
  }
  else
  {
    uint64_t v35 = *((void *)this + 5);
    int v36 = *(_DWORD *)(v35 + 24 * v33 + 8);
    *((_DWORD *)this + 15) = v36 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v35 + 24 * v33 + 8) = v36 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v33 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v33 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v31);
  *(void *)(*((void *)this + 5) + 24 * v33) = 0x5692161D100B05E5;
  *(_DWORD *)(*((void *)this + 5) + 24 * v33 + 12) = 1;
  *(void *)(*((void *)this + 5) + 24 * v33 + 16) = v30;
  *(_DWORD *)(*((void *)this + 4) + 4 * v31) = v33;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_37:
  __int16 v37 = re::globalAllocators((re *)v29);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37[2] + 32))(v37[2], 72, 8);
  uint64_t v39 = v38;
  *(_OWORD *)(v38 + 8) = 0u;
  *(_OWORD *)(v38 + 24) = 0u;
  *(_OWORD *)(v38 + 40) = 0u;
  *(_OWORD *)(v38 + 56) = 0u;
  *(_DWORD *)(v38 + 8) = 10;
  *(_OWORD *)(v38 + 16) = 0u;
  *(_OWORD *)(v38 + 32) = 0u;
  *(void *)(v38 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v38 + 64) = 0;
  *(void *)uint64_t v38 = &unk_26E7177D8;
  unint64_t v40 = *v3;
  if (*v3)
  {
    unint64_t v40 = 0xDBD238973A2B148ALL % *((unsigned int *)this + 12);
    uint64_t v41 = *(unsigned int *)(*((void *)this + 4) + 4 * v40);
    if (v41 != 0x7FFFFFFF)
    {
      uint64_t v180 = *((void *)this + 5);
      if (*(_DWORD *)(v180 + 24 * v41 + 12) == 2) {
        goto LABEL_45;
      }
      while (1)
      {
        LODWORD(v41) = *(_DWORD *)(v180 + 24 * v41 + 8) & 0x7FFFFFFF;
        if (v41 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v180 + 24 * v41 + 12) == 2) {
          goto LABEL_45;
        }
      }
    }
  }
  uint64_t v42 = *((unsigned int *)this + 15);
  if (v42 == 0x7FFFFFFF)
  {
    uint64_t v42 = *((unsigned int *)this + 14);
    int v43 = v42;
    if (v42 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v40) = 0xDBD238973A2B148ALL % *((unsigned int *)this + 12);
      int v43 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v43 + 1;
    uint64_t v44 = *((void *)this + 5);
    int v45 = *(_DWORD *)(v44 + 24 * v42 + 8);
  }
  else
  {
    uint64_t v44 = *((void *)this + 5);
    int v45 = *(_DWORD *)(v44 + 24 * v42 + 8);
    *((_DWORD *)this + 15) = v45 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v44 + 24 * v42 + 8) = v45 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v42 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v42 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v40);
  *(void *)(*((void *)this + 5) + 24 * v42) = 0xDBD238973A2B148ALL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v42 + 12) = 2;
  *(void *)(*((void *)this + 5) + 24 * v42 + 16) = v39;
  *(_DWORD *)(*((void *)this + 4) + 4 * v40) = v42;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_45:
  int8x16_t v46 = re::globalAllocators((re *)v38);
  uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v46[2] + 32))(v46[2], 72, 8);
  uint64_t v48 = v47;
  *(_OWORD *)(v47 + 8) = 0u;
  *(_OWORD *)(v47 + 24) = 0u;
  *(_OWORD *)(v47 + 40) = 0u;
  *(_OWORD *)(v47 + 56) = 0u;
  *(_DWORD *)(v47 + 8) = 10;
  *(_OWORD *)(v47 + 16) = 0u;
  *(_OWORD *)(v47 + 32) = 0u;
  *(void *)(v47 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v47 + 64) = 0;
  *(void *)uint64_t v47 = &unk_26E717820;
  unint64_t v49 = *v3;
  if (*v3)
  {
    unint64_t v49 = 0xB7A4712C74562914 % *((unsigned int *)this + 12);
    uint64_t v50 = *(unsigned int *)(*((void *)this + 4) + 4 * v49);
    if (v50 != 0x7FFFFFFF)
    {
      uint64_t v181 = *((void *)this + 5);
      if (*(_DWORD *)(v181 + 24 * v50 + 12) == 4) {
        goto LABEL_53;
      }
      while (1)
      {
        LODWORD(v50) = *(_DWORD *)(v181 + 24 * v50 + 8) & 0x7FFFFFFF;
        if (v50 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v181 + 24 * v50 + 12) == 4) {
          goto LABEL_53;
        }
      }
    }
  }
  uint64_t v51 = *((unsigned int *)this + 15);
  if (v51 == 0x7FFFFFFF)
  {
    uint64_t v51 = *((unsigned int *)this + 14);
    int v52 = v51;
    if (v51 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v49) = 0xB7A4712C74562914 % *((unsigned int *)this + 12);
      int v52 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v52 + 1;
    uint64_t v53 = *((void *)this + 5);
    int v54 = *(_DWORD *)(v53 + 24 * v51 + 8);
  }
  else
  {
    uint64_t v53 = *((void *)this + 5);
    int v54 = *(_DWORD *)(v53 + 24 * v51 + 8);
    *((_DWORD *)this + 15) = v54 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v53 + 24 * v51 + 8) = v54 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v51 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v51 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v49);
  *(void *)(*((void *)this + 5) + 24 * v51) = 0xB7A4712C74562914;
  *(_DWORD *)(*((void *)this + 5) + 24 * v51 + 12) = 4;
  *(void *)(*((void *)this + 5) + 24 * v51 + 16) = v48;
  *(_DWORD *)(*((void *)this + 4) + 4 * v49) = v51;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_53:
  long long v55 = re::globalAllocators((re *)v47);
  uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v55[2] + 32))(v55[2], 72, 8);
  uint64_t v57 = v56;
  *(_OWORD *)(v56 + 8) = 0u;
  *(_OWORD *)(v56 + 24) = 0u;
  *(_OWORD *)(v56 + 40) = 0u;
  *(_OWORD *)(v56 + 56) = 0u;
  *(_DWORD *)(v56 + 8) = 10;
  *(_OWORD *)(v56 + 16) = 0u;
  *(_OWORD *)(v56 + 32) = 0u;
  *(void *)(v56 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v56 + 64) = 0;
  *(void *)uint64_t v56 = &unk_26E717868;
  unint64_t v58 = *v3;
  if (*v3)
  {
    unint64_t v58 = 0xD56B1FBB9CEBA9E8 % *((unsigned int *)this + 12);
    uint64_t v59 = *(unsigned int *)(*((void *)this + 4) + 4 * v58);
    if (v59 != 0x7FFFFFFF)
    {
      uint64_t v182 = *((void *)this + 5);
      if (*(_DWORD *)(v182 + 24 * v59 + 12) == 8) {
        goto LABEL_61;
      }
      while (1)
      {
        LODWORD(v59) = *(_DWORD *)(v182 + 24 * v59 + 8) & 0x7FFFFFFF;
        if (v59 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v182 + 24 * v59 + 12) == 8) {
          goto LABEL_61;
        }
      }
    }
  }
  uint64_t v60 = *((unsigned int *)this + 15);
  if (v60 == 0x7FFFFFFF)
  {
    uint64_t v60 = *((unsigned int *)this + 14);
    int v61 = v60;
    if (v60 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v58) = 0xD56B1FBB9CEBA9E8 % *((unsigned int *)this + 12);
      int v61 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v61 + 1;
    uint64_t v62 = *((void *)this + 5);
    int v63 = *(_DWORD *)(v62 + 24 * v60 + 8);
  }
  else
  {
    uint64_t v62 = *((void *)this + 5);
    int v63 = *(_DWORD *)(v62 + 24 * v60 + 8);
    *((_DWORD *)this + 15) = v63 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v62 + 24 * v60 + 8) = v63 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v60 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v60 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v58);
  *(void *)(*((void *)this + 5) + 24 * v60) = 0xD56B1FBB9CEBA9E8;
  *(_DWORD *)(*((void *)this + 5) + 24 * v60 + 12) = 8;
  *(void *)(*((void *)this + 5) + 24 * v60 + 16) = v57;
  *(_DWORD *)(*((void *)this + 4) + 4 * v58) = v60;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_61:
  uint64_t v64 = re::globalAllocators((re *)v56);
  uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v64[2] + 32))(v64[2], 72, 8);
  uint64_t v66 = v65;
  *(_OWORD *)(v65 + 8) = 0u;
  *(_OWORD *)(v65 + 24) = 0u;
  *(_OWORD *)(v65 + 40) = 0u;
  *(_OWORD *)(v65 + 56) = 0u;
  *(_DWORD *)(v65 + 8) = 10;
  *(_OWORD *)(v65 + 16) = 0u;
  *(_OWORD *)(v65 + 32) = 0u;
  *(void *)(v65 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v65 + 64) = 0;
  *(void *)uint64_t v65 = &unk_26E7178B0;
  unint64_t v67 = *v3;
  if (*v3)
  {
    unint64_t v67 = 0xD9844BCECCA4A8BDLL % *((unsigned int *)this + 12);
    uint64_t v68 = *(unsigned int *)(*((void *)this + 4) + 4 * v67);
    if (v68 != 0x7FFFFFFF)
    {
      uint64_t v183 = *((void *)this + 5);
      if (*(_DWORD *)(v183 + 24 * v68 + 12) == 16) {
        goto LABEL_69;
      }
      while (1)
      {
        LODWORD(v68) = *(_DWORD *)(v183 + 24 * v68 + 8) & 0x7FFFFFFF;
        if (v68 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v183 + 24 * v68 + 12) == 16) {
          goto LABEL_69;
        }
      }
    }
  }
  uint64_t v69 = *((unsigned int *)this + 15);
  if (v69 == 0x7FFFFFFF)
  {
    uint64_t v69 = *((unsigned int *)this + 14);
    int v70 = v69;
    if (v69 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v67) = 0xD9844BCECCA4A8BDLL % *((unsigned int *)this + 12);
      int v70 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v70 + 1;
    uint64_t v71 = *((void *)this + 5);
    int v72 = *(_DWORD *)(v71 + 24 * v69 + 8);
  }
  else
  {
    uint64_t v71 = *((void *)this + 5);
    int v72 = *(_DWORD *)(v71 + 24 * v69 + 8);
    *((_DWORD *)this + 15) = v72 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v71 + 24 * v69 + 8) = v72 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v69 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v69 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v67);
  *(void *)(*((void *)this + 5) + 24 * v69) = 0xD9844BCECCA4A8BDLL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v69 + 12) = 16;
  *(void *)(*((void *)this + 5) + 24 * v69 + 16) = v66;
  *(_DWORD *)(*((void *)this + 4) + 4 * v67) = v69;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_69:
  unsigned int v73 = re::globalAllocators((re *)v65);
  uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v73[2] + 32))(v73[2], 72, 8);
  uint64_t v75 = v74;
  *(_OWORD *)(v74 + 8) = 0u;
  *(_OWORD *)(v74 + 24) = 0u;
  *(_OWORD *)(v74 + 40) = 0u;
  *(_OWORD *)(v74 + 56) = 0u;
  *(_DWORD *)(v74 + 8) = 10;
  *(_OWORD *)(v74 + 16) = 0u;
  *(_OWORD *)(v74 + 32) = 0u;
  *(void *)(v74 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v74 + 64) = 0;
  *(void *)uint64_t v74 = &unk_26E7178F8;
  unint64_t v76 = *v3;
  if (*v3)
  {
    unint64_t v76 = 0xADFB1EBB497FAD45 % *((unsigned int *)this + 12);
    uint64_t v77 = *(unsigned int *)(*((void *)this + 4) + 4 * v76);
    if (v77 != 0x7FFFFFFF)
    {
      uint64_t v184 = *((void *)this + 5);
      if (*(_DWORD *)(v184 + 24 * v77 + 12) == 32) {
        goto LABEL_77;
      }
      while (1)
      {
        LODWORD(v77) = *(_DWORD *)(v184 + 24 * v77 + 8) & 0x7FFFFFFF;
        if (v77 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v184 + 24 * v77 + 12) == 32) {
          goto LABEL_77;
        }
      }
    }
  }
  uint64_t v78 = *((unsigned int *)this + 15);
  if (v78 == 0x7FFFFFFF)
  {
    uint64_t v78 = *((unsigned int *)this + 14);
    int v79 = v78;
    if (v78 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v76) = 0xADFB1EBB497FAD45 % *((unsigned int *)this + 12);
      int v79 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v79 + 1;
    uint64_t v80 = *((void *)this + 5);
    int v81 = *(_DWORD *)(v80 + 24 * v78 + 8);
  }
  else
  {
    uint64_t v80 = *((void *)this + 5);
    int v81 = *(_DWORD *)(v80 + 24 * v78 + 8);
    *((_DWORD *)this + 15) = v81 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v80 + 24 * v78 + 8) = v81 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v78 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v78 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v76);
  *(void *)(*((void *)this + 5) + 24 * v78) = 0xADFB1EBB497FAD45;
  *(_DWORD *)(*((void *)this + 5) + 24 * v78 + 12) = 32;
  *(void *)(*((void *)this + 5) + 24 * v78 + 16) = v75;
  *(_DWORD *)(*((void *)this + 4) + 4 * v76) = v78;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_77:
  float32x4_t v82 = re::globalAllocators((re *)v74);
  uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v82[2] + 32))(v82[2], 72, 8);
  uint64_t v84 = v83;
  *(_OWORD *)(v83 + 8) = 0u;
  *(_OWORD *)(v83 + 24) = 0u;
  *(_OWORD *)(v83 + 40) = 0u;
  *(_OWORD *)(v83 + 56) = 0u;
  *(_DWORD *)(v83 + 8) = 10;
  *(_OWORD *)(v83 + 16) = 0u;
  *(_OWORD *)(v83 + 32) = 0u;
  *(void *)(v83 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v83 + 64) = 0;
  *(void *)uint64_t v83 = &unk_26E717940;
  unint64_t v85 = *v3;
  if (*v3)
  {
    unint64_t v85 = 0x8AA449CE2D0CA1D3 % *((unsigned int *)this + 12);
    uint64_t v86 = *(unsigned int *)(*((void *)this + 4) + 4 * v85);
    if (v86 != 0x7FFFFFFF)
    {
      uint64_t v185 = *((void *)this + 5);
      if (*(_DWORD *)(v185 + 24 * v86 + 12) == 64) {
        goto LABEL_85;
      }
      while (1)
      {
        LODWORD(v86) = *(_DWORD *)(v185 + 24 * v86 + 8) & 0x7FFFFFFF;
        if (v86 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v185 + 24 * v86 + 12) == 64) {
          goto LABEL_85;
        }
      }
    }
  }
  uint64_t v87 = *((unsigned int *)this + 15);
  if (v87 == 0x7FFFFFFF)
  {
    uint64_t v87 = *((unsigned int *)this + 14);
    int v88 = v87;
    if (v87 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v85) = 0x8AA449CE2D0CA1D3 % *((unsigned int *)this + 12);
      int v88 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v88 + 1;
    uint64_t v89 = *((void *)this + 5);
    int v90 = *(_DWORD *)(v89 + 24 * v87 + 8);
  }
  else
  {
    uint64_t v89 = *((void *)this + 5);
    int v90 = *(_DWORD *)(v89 + 24 * v87 + 8);
    *((_DWORD *)this + 15) = v90 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v89 + 24 * v87 + 8) = v90 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v87 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v87 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v85);
  *(void *)(*((void *)this + 5) + 24 * v87) = 0x8AA449CE2D0CA1D3;
  *(_DWORD *)(*((void *)this + 5) + 24 * v87 + 12) = 64;
  *(void *)(*((void *)this + 5) + 24 * v87 + 16) = v84;
  *(_DWORD *)(*((void *)this + 4) + 4 * v85) = v87;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_85:
  unint64_t v91 = re::globalAllocators((re *)v83);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v91[2] + 32))(v91[2], 72, 8);
  uint64_t v93 = v92;
  *(_OWORD *)(v92 + 8) = 0u;
  *(_OWORD *)(v92 + 24) = 0u;
  *(_OWORD *)(v92 + 40) = 0u;
  *(_OWORD *)(v92 + 56) = 0u;
  *(_DWORD *)(v92 + 8) = 10;
  *(_OWORD *)(v92 + 16) = 0u;
  *(_OWORD *)(v92 + 32) = 0u;
  *(void *)(v92 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v92 + 64) = 0;
  *(void *)uint64_t v92 = &unk_26E717988;
  unint64_t v94 = *v3;
  if (*v3)
  {
    unint64_t v94 = 0xAF26563F2EC4C8E6 % *((unsigned int *)this + 12);
    uint64_t v95 = *(unsigned int *)(*((void *)this + 4) + 4 * v94);
    if (v95 != 0x7FFFFFFF)
    {
      uint64_t v186 = *((void *)this + 5);
      if (*(_DWORD *)(v186 + 24 * v95 + 12) == 128) {
        goto LABEL_93;
      }
      while (1)
      {
        LODWORD(v95) = *(_DWORD *)(v186 + 24 * v95 + 8) & 0x7FFFFFFF;
        if (v95 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v186 + 24 * v95 + 12) == 128) {
          goto LABEL_93;
        }
      }
    }
  }
  uint64_t v96 = *((unsigned int *)this + 15);
  if (v96 == 0x7FFFFFFF)
  {
    uint64_t v96 = *((unsigned int *)this + 14);
    int v97 = v96;
    if (v96 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v94) = 0xAF26563F2EC4C8E6 % *((unsigned int *)this + 12);
      int v97 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v97 + 1;
    uint64_t v98 = *((void *)this + 5);
    int v99 = *(_DWORD *)(v98 + 24 * v96 + 8);
  }
  else
  {
    uint64_t v98 = *((void *)this + 5);
    int v99 = *(_DWORD *)(v98 + 24 * v96 + 8);
    *((_DWORD *)this + 15) = v99 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v98 + 24 * v96 + 8) = v99 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v96 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v96 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v94);
  *(void *)(*((void *)this + 5) + 24 * v96) = 0xAF26563F2EC4C8E6;
  *(_DWORD *)(*((void *)this + 5) + 24 * v96 + 12) = 128;
  *(void *)(*((void *)this + 5) + 24 * v96 + 16) = v93;
  *(_DWORD *)(*((void *)this + 4) + 4 * v94) = v96;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_93:
  v100 = re::globalAllocators((re *)v92);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v100[2] + 32))(v100[2], 72, 8);
  uint64_t v102 = v101;
  *(_OWORD *)(v101 + 8) = 0u;
  *(_OWORD *)(v101 + 24) = 0u;
  *(_OWORD *)(v101 + 40) = 0u;
  *(_OWORD *)(v101 + 56) = 0u;
  *(_DWORD *)(v101 + 8) = 10;
  *(_OWORD *)(v101 + 16) = 0u;
  *(_OWORD *)(v101 + 32) = 0u;
  *(void *)(v101 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v101 + 64) = 0;
  *(void *)uint64_t v101 = &unk_26E7179D0;
  unint64_t v103 = *v3;
  if (*v3)
  {
    unint64_t v103 = 0xF82A6F1D1144170DLL % *((unsigned int *)this + 12);
    uint64_t v104 = *(unsigned int *)(*((void *)this + 4) + 4 * v103);
    if (v104 != 0x7FFFFFFF)
    {
      uint64_t v187 = *((void *)this + 5);
      if (*(_DWORD *)(v187 + 24 * v104 + 12) == 256) {
        goto LABEL_101;
      }
      while (1)
      {
        LODWORD(v104) = *(_DWORD *)(v187 + 24 * v104 + 8) & 0x7FFFFFFF;
        if (v104 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v187 + 24 * v104 + 12) == 256) {
          goto LABEL_101;
        }
      }
    }
  }
  uint64_t v105 = *((unsigned int *)this + 15);
  if (v105 == 0x7FFFFFFF)
  {
    uint64_t v105 = *((unsigned int *)this + 14);
    int v106 = v105;
    if (v105 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v103) = 0xF82A6F1D1144170DLL % *((unsigned int *)this + 12);
      int v106 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v106 + 1;
    uint64_t v107 = *((void *)this + 5);
    int v108 = *(_DWORD *)(v107 + 24 * v105 + 8);
  }
  else
  {
    uint64_t v107 = *((void *)this + 5);
    int v108 = *(_DWORD *)(v107 + 24 * v105 + 8);
    *((_DWORD *)this + 15) = v108 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v107 + 24 * v105 + 8) = v108 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v105 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v105 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v103);
  *(void *)(*((void *)this + 5) + 24 * v105) = 0xF82A6F1D1144170DLL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v105 + 12) = 256;
  *(void *)(*((void *)this + 5) + 24 * v105 + 16) = v102;
  *(_DWORD *)(*((void *)this + 4) + 4 * v103) = v105;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_101:
  v109 = re::globalAllocators((re *)v101);
  float32x4_t v110 = (re::FrameMemoryStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v109[2] + 32))(v109[2], 80, 8);
  float32x4_t v111 = re::FrameMemoryStats::FrameMemoryStats(v110);
  unint64_t v112 = *v3;
  if (*v3)
  {
    unint64_t v112 = 0x852527F5DF18EBBALL % *((unsigned int *)this + 12);
    uint64_t v113 = *(unsigned int *)(*((void *)this + 4) + 4 * v112);
    if (v113 != 0x7FFFFFFF)
    {
      uint64_t v188 = *((void *)this + 5);
      if (*(_DWORD *)(v188 + 24 * v113 + 12) == 512) {
        goto LABEL_109;
      }
      while (1)
      {
        LODWORD(v113) = *(_DWORD *)(v188 + 24 * v113 + 8) & 0x7FFFFFFF;
        if (v113 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v188 + 24 * v113 + 12) == 512) {
          goto LABEL_109;
        }
      }
    }
  }
  uint64_t v114 = *((unsigned int *)this + 15);
  if (v114 == 0x7FFFFFFF)
  {
    uint64_t v114 = *((unsigned int *)this + 14);
    int v115 = v114;
    if (v114 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v112) = 0x852527F5DF18EBBALL % *((unsigned int *)this + 12);
      int v115 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v115 + 1;
    uint64_t v116 = *((void *)this + 5);
    int v117 = *(_DWORD *)(v116 + 24 * v114 + 8);
  }
  else
  {
    uint64_t v116 = *((void *)this + 5);
    int v117 = *(_DWORD *)(v116 + 24 * v114 + 8);
    *((_DWORD *)this + 15) = v117 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v116 + 24 * v114 + 8) = v117 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v114 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v114 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v112);
  *(void *)(*((void *)this + 5) + 24 * v114) = 0x852527F5DF18EBBALL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v114 + 12) = 512;
  *(void *)(*((void *)this + 5) + 24 * v114 + 16) = v110;
  *(_DWORD *)(*((void *)this + 4) + 4 * v112) = v114;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_109:
  float32x4_t v118 = re::globalAllocators(v111);
  uint64_t v119 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v118[2] + 32))(v118[2], 96, 8);
  uint64_t v120 = v119;
  *(_OWORD *)(v119 + 8) = 0u;
  *(_OWORD *)(v119 + 40) = 0u;
  *(_OWORD *)(v119 + 24) = 0u;
  *(_OWORD *)(v119 + 56) = 0u;
  *(_OWORD *)(v119 + 72) = 0u;
  *(void *)(v119 + 88) = 0;
  *(_DWORD *)(v119 + 8) = 10;
  *(void *)(v119 + 48) = 0x7FFFFFFF00000000;
  *(_OWORD *)(v119 + 16) = 0u;
  *(_OWORD *)(v119 + 32) = 0u;
  *(unsigned char *)(v119 + 64) = 0;
  *(void *)uint64_t v119 = &unk_26E717A30;
  *(void *)(v119 + 68) = 0;
  *(void *)(v119 + 76) = 0;
  *(void *)(v119 + 84) = 0;
  unint64_t v121 = *v3;
  if (*v3)
  {
    unint64_t v121 = 0x706C8D494A7C5235uLL % *((unsigned int *)this + 12);
    uint64_t v122 = *(unsigned int *)(*((void *)this + 4) + 4 * v121);
    if (v122 != 0x7FFFFFFF)
    {
      uint64_t v189 = *((void *)this + 5);
      if (*(_DWORD *)(v189 + 24 * v122 + 12) == 1024) {
        goto LABEL_117;
      }
      while (1)
      {
        LODWORD(v122) = *(_DWORD *)(v189 + 24 * v122 + 8) & 0x7FFFFFFF;
        if (v122 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v189 + 24 * v122 + 12) == 1024) {
          goto LABEL_117;
        }
      }
    }
  }
  uint64_t v123 = *((unsigned int *)this + 15);
  if (v123 == 0x7FFFFFFF)
  {
    uint64_t v123 = *((unsigned int *)this + 14);
    int v124 = v123;
    if (v123 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v121) = 0x706C8D494A7C5235uLL % *((unsigned int *)this + 12);
      int v124 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v124 + 1;
    uint64_t v125 = *((void *)this + 5);
    int v126 = *(_DWORD *)(v125 + 24 * v123 + 8);
  }
  else
  {
    uint64_t v125 = *((void *)this + 5);
    int v126 = *(_DWORD *)(v125 + 24 * v123 + 8);
    *((_DWORD *)this + 15) = v126 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v125 + 24 * v123 + 8) = v126 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v123 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v123 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v121);
  *(void *)(*((void *)this + 5) + 24 * v123) = 0x706C8D494A7C5235;
  *(_DWORD *)(*((void *)this + 5) + 24 * v123 + 12) = 1024;
  *(void *)(*((void *)this + 5) + 24 * v123 + 16) = v120;
  *(_DWORD *)(*((void *)this + 4) + 4 * v121) = v123;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_117:
  uint64_t v127 = re::globalAllocators((re *)v119);
  uint64_t v128 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v127[2] + 32))(v127[2], 72, 8);
  uint64_t v129 = v128;
  *(_OWORD *)(v128 + 8) = 0u;
  *(_OWORD *)(v128 + 24) = 0u;
  *(_OWORD *)(v128 + 40) = 0u;
  *(_OWORD *)(v128 + 56) = 0u;
  *(_DWORD *)(v128 + 8) = 10;
  *(_OWORD *)(v128 + 16) = 0u;
  *(_OWORD *)(v128 + 32) = 0u;
  *(void *)(v128 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v128 + 64) = 0;
  *(void *)uint64_t v128 = &unk_26E717A78;
  unint64_t v130 = *v3;
  if (*v3)
  {
    unint64_t v130 = 0xE0D91A9294F8A46ALL % *((unsigned int *)this + 12);
    uint64_t v131 = *(unsigned int *)(*((void *)this + 4) + 4 * v130);
    if (v131 != 0x7FFFFFFF)
    {
      uint64_t v190 = *((void *)this + 5);
      if (*(_DWORD *)(v190 + 24 * v131 + 12) == 2048) {
        goto LABEL_125;
      }
      while (1)
      {
        LODWORD(v131) = *(_DWORD *)(v190 + 24 * v131 + 8) & 0x7FFFFFFF;
        if (v131 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v190 + 24 * v131 + 12) == 2048) {
          goto LABEL_125;
        }
      }
    }
  }
  uint64_t v132 = *((unsigned int *)this + 15);
  if (v132 == 0x7FFFFFFF)
  {
    uint64_t v132 = *((unsigned int *)this + 14);
    int v133 = v132;
    if (v132 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v130) = 0xE0D91A9294F8A46ALL % *((unsigned int *)this + 12);
      int v133 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v133 + 1;
    uint64_t v134 = *((void *)this + 5);
    int v135 = *(_DWORD *)(v134 + 24 * v132 + 8);
  }
  else
  {
    uint64_t v134 = *((void *)this + 5);
    int v135 = *(_DWORD *)(v134 + 24 * v132 + 8);
    *((_DWORD *)this + 15) = v135 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v134 + 24 * v132 + 8) = v135 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v132 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v132 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v130);
  *(void *)(*((void *)this + 5) + 24 * v132) = 0xE0D91A9294F8A46ALL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v132 + 12) = 2048;
  *(void *)(*((void *)this + 5) + 24 * v132 + 16) = v129;
  *(_DWORD *)(*((void *)this + 4) + 4 * v130) = v132;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_125:
  float32x4_t v136 = re::globalAllocators((re *)v128);
  float v137 = (re::FrameCustomStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v136[2] + 32))(v136[2], 168, 8);
  re::FrameCustomStats::FrameCustomStats(v137);
  unint64_t v138 = *v3;
  if (*v3)
  {
    unint64_t v139 = 0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12);
    uint64_t v140 = *((void *)this + 4);
    uint64_t v141 = *(unsigned int *)(v140 + 4 * v139);
    if (v141 != 0x7FFFFFFF)
    {
      uint64_t v142 = *((void *)this + 5);
      if (*(_DWORD *)(v142 + 24 * v141 + 12) == 0x2000) {
        goto LABEL_139;
      }
      while (1)
      {
        LODWORD(v141) = *(_DWORD *)(v142 + 24 * v141 + 8) & 0x7FFFFFFF;
        if (v141 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v142 + 24 * v141 + 12) == 0x2000) {
          goto LABEL_138;
        }
      }
    }
  }
  else
  {
    LODWORD(v139) = 0;
  }
  uint64_t v143 = *((unsigned int *)this + 15);
  if (v143 == 0x7FFFFFFF)
  {
    uint64_t v143 = *((unsigned int *)this + 14);
    int v144 = v143;
    if (v143 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v139) = 0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12);
      int v144 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v144 + 1;
    uint64_t v145 = *((void *)this + 5);
    int v146 = *(_DWORD *)(v145 + 24 * v143 + 8);
  }
  else
  {
    uint64_t v145 = *((void *)this + 5);
    int v146 = *(_DWORD *)(v145 + 24 * v143 + 8);
    *((_DWORD *)this + 15) = v146 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v145 + 24 * v143 + 8) = v146 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v143 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v143 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v139);
  *(void *)(*((void *)this + 5) + 24 * v143) = 0xF6E8F5E9060644CLL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v143 + 12) = 0x2000;
  *(void *)(*((void *)this + 5) + 24 * v143 + 16) = v137;
  uint64_t v140 = *((void *)this + 4);
  *(_DWORD *)(v140 + 4 * v139) = v143;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
  unint64_t v138 = *((void *)this + 3);
LABEL_138:
  if (!v138) {
    goto LABEL_145;
  }
LABEL_139:
  uint64_t v147 = *(unsigned int *)(v140 + 4 * (0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12)));
  LODWORD(v148) = 0x7FFFFFFF;
  if (v147 != 0x7FFFFFFF)
  {
    uint64_t v149 = *((void *)this + 5);
    LODWORD(v148) = v147;
    if (*(_DWORD *)(v149 + 24 * v147 + 12) != 0x2000)
    {
      uint64_t v148 = v147;
      while (1)
      {
        LODWORD(v148) = *(_DWORD *)(v149 + 24 * v148 + 8) & 0x7FFFFFFF;
        if (v148 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v149 + 24 * v148 + 12) == 0x2000) {
          goto LABEL_146;
        }
      }
LABEL_145:
      LODWORD(v148) = 0x7FFFFFFF;
    }
  }
LABEL_146:
  Line = (re *)re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*((void *)this + 5) + 24 * v148 + 16), "Custom Stats");
  float32x4_t v151 = re::globalAllocators(Line);
  uint64_t v152 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v151[2] + 32))(v151[2], 72, 8);
  uint64_t v153 = v152;
  *(_OWORD *)(v152 + 8) = 0u;
  *(_OWORD *)(v152 + 24) = 0u;
  *(_OWORD *)(v152 + 40) = 0u;
  *(_OWORD *)(v152 + 56) = 0u;
  *(_DWORD *)(v152 + 8) = 10;
  *(_OWORD *)(v152 + 16) = 0u;
  *(_OWORD *)(v152 + 32) = 0u;
  *(void *)(v152 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v152 + 64) = 0;
  *(void *)uint64_t v152 = &unk_26E717AD8;
  unint64_t v154 = *((void *)this + 3);
  if (v154)
  {
    unint64_t v154 = 0xB3AD687957F6D73DLL % *((unsigned int *)this + 12);
    uint64_t v155 = *(unsigned int *)(*((void *)this + 4) + 4 * v154);
    if (v155 != 0x7FFFFFFF)
    {
      uint64_t v191 = *((void *)this + 5);
      if (*(_DWORD *)(v191 + 24 * v155 + 12) == 0x4000) {
        goto LABEL_154;
      }
      while (1)
      {
        LODWORD(v155) = *(_DWORD *)(v191 + 24 * v155 + 8) & 0x7FFFFFFF;
        if (v155 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v191 + 24 * v155 + 12) == 0x4000) {
          goto LABEL_154;
        }
      }
    }
  }
  uint64_t v156 = *((unsigned int *)this + 15);
  if (v156 == 0x7FFFFFFF)
  {
    uint64_t v156 = *((unsigned int *)this + 14);
    int v157 = v156;
    if (v156 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v154) = 0xB3AD687957F6D73DLL % *((unsigned int *)this + 12);
      int v157 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v157 + 1;
    uint64_t v158 = *((void *)this + 5);
    int v159 = *(_DWORD *)(v158 + 24 * v156 + 8);
  }
  else
  {
    uint64_t v158 = *((void *)this + 5);
    int v159 = *(_DWORD *)(v158 + 24 * v156 + 8);
    *((_DWORD *)this + 15) = v159 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v158 + 24 * v156 + 8) = v159 | 0x80000000;
  *(_DWORD *)(*((void *)this + 5) + 24 * v156 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v156 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v154);
  *(void *)(*((void *)this + 5) + 24 * v156) = 0xB3AD687957F6D73DLL;
  *(_DWORD *)(*((void *)this + 5) + 24 * v156 + 12) = 0x4000;
  *(void *)(*((void *)this + 5) + 24 * v156 + 16) = v153;
  *(_DWORD *)(*((void *)this + 4) + 4 * v154) = v156;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_154:
  float32x4_t v160 = re::globalAllocators((re *)v152);
  uint64_t v161 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v160[2] + 32))(v160[2], 72, 8);
  uint64_t v162 = v161;
  *(_OWORD *)(v161 + 8) = 0u;
  *(_OWORD *)(v161 + 24) = 0u;
  *(_OWORD *)(v161 + 40) = 0u;
  *(_OWORD *)(v161 + 56) = 0u;
  *(_DWORD *)(v161 + 8) = 10;
  *(_OWORD *)(v161 + 16) = 0u;
  *(_OWORD *)(v161 + 32) = 0u;
  *(void *)(v161 + 48) = 0x7FFFFFFF00000000;
  *(unsigned char *)(v161 + 64) = 0;
  *(void *)uint64_t v161 = &unk_26E717B20;
  unint64_t v163 = *v3;
  if (!*v3
    || (unint64_t v163 = 0x323B8D7CFCE64AAAuLL % *((unsigned int *)this + 12),
        uint64_t v164 = *(unsigned int *)(*((void *)this + 4) + 4 * v163),
        v164 == 0x7FFFFFFF))
  {
LABEL_156:
    uint64_t v165 = *((unsigned int *)this + 15);
    if (v165 == 0x7FFFFFFF)
    {
      uint64_t v165 = *((unsigned int *)this + 14);
      int v166 = v165;
      if (v165 == *((_DWORD *)this + 12))
      {
        re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
        LODWORD(v163) = 0x323B8D7CFCE64AAAuLL % *((unsigned int *)this + 12);
        int v166 = *((_DWORD *)this + 14);
      }
      *((_DWORD *)this + 14) = v166 + 1;
      uint64_t v167 = *((void *)this + 5);
      int v168 = *(_DWORD *)(v167 + 24 * v165 + 8);
    }
    else
    {
      uint64_t v167 = *((void *)this + 5);
      int v168 = *(_DWORD *)(v167 + 24 * v165 + 8);
      *((_DWORD *)this + 15) = v168 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v167 + 24 * v165 + 8) = v168 | 0x80000000;
    *(_DWORD *)(*((void *)this + 5) + 24 * v165 + 8) = *(_DWORD *)(*((void *)this + 5) + 24 * v165 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 4) + 4 * v163);
    *(void *)(*((void *)this + 5) + 24 * v165) = 0x323B8D7CFCE64AAALL;
    *(_DWORD *)(*((void *)this + 5) + 24 * v165 + 12) = 0x20000;
    *(void *)(*((void *)this + 5) + 24 * v165 + 16) = v162;
    *(_DWORD *)(*((void *)this + 4) + 4 * v163) = v165;
    ++*((_DWORD *)this + 13);
    ++*((_DWORD *)this + 16);
    goto LABEL_162;
  }
  uint64_t v192 = *((void *)this + 5);
  while (*(_DWORD *)(v192 + 24 * v164 + 12) != 0x20000)
  {
    LODWORD(v164) = *(_DWORD *)(v192 + 24 * v164 + 8) & 0x7FFFFFFF;
    if (v164 == 0x7FFFFFFF) {
      goto LABEL_156;
    }
  }
LABEL_162:
  uint64_t v169 = *((unsigned int *)this + 14);
  if (v169)
  {
    uint64_t v170 = 0;
    v171 = (int *)(*((void *)this + 5) + 8);
    while (1)
    {
      int v172 = *v171;
      v171 += 6;
      if (v172 < 0) {
        break;
      }
      if (v169 == ++v170)
      {
        LODWORD(v170) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v170) = 0;
  }
  if (v169 != v170)
  {
    uint64_t v173 = v170;
    do
    {
      uint64_t v161 = re::FrameStats::init(*(re::FrameStats **)(*((void *)this + 5) + 24 * v173 + 16), *((_DWORD *)this + 50), *((_DWORD *)this + 48));
      if (*((_DWORD *)this + 14) <= (v170 + 1)) {
        int v174 = v170 + 1;
      }
      else {
        int v174 = *((_DWORD *)this + 14);
      }
      int v175 = v170;
      while (1)
      {
        uint64_t v173 = (v175 + 1);
        if (v174 - 1 == v175) {
          break;
        }
        ++v175;
        LODWORD(v170) = v173;
        if ((*(_DWORD *)(*((void *)this + 5) + 24 * v173 + 8) & 0x80000000) != 0) {
          goto LABEL_178;
        }
      }
      LODWORD(v170) = v174;
LABEL_178:
      ;
    }
    while (v169 != v170);
  }
  memset(v193, 0, 36);
  *(void *)&v193[36] = 0x7FFFFFFFLL;
  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=((uint64_t)this + 344, (uint64_t *)v193);
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v193);
  memset(v193, 0, 36);
  *(void *)&v193[36] = 0x7FFFFFFFLL;
  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=((uint64_t)this + 392, (uint64_t *)v193);
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v193);
  unsigned int v177 = 0;
  do
  {
    char v195 = v177;
    *(_OWORD *)long long v193 = 0xFF7FFFFF7F7FFFFFLL;
    *(void *)&v193[16] = 0;
    *(_OWORD *)&v193[24] = xmmword_23440B890;
    *(_OWORD *)&v193[40] = xmmword_23440B8A0;
    uint64_t v194 = 0;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew((uint64_t)this + 344, &v195, (re::FrameStats::CollectedStatistics *)v193);
    *(_OWORD *)long long v193 = 0xFF7FFFFF7F7FFFFFLL;
    *(void *)&v193[16] = 0;
    *(_OWORD *)&v193[24] = xmmword_23440B890;
    *(_OWORD *)&v193[40] = xmmword_23440B8A0;
    uint64_t v194 = 0;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew((uint64_t)this + 392, &v195, (re::FrameStats::CollectedStatistics *)v193);
  }
  while (v177++ < 0x9C);
  *((unsigned char *)this + 206) = 1;
  re::FrameProfiler::setEngineInitializedTimestamp(this, *((void *)this + 26));
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew(uint64_t a1, unsigned char *a2, re::FrameStats::CollectedStatistics *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v6) ^ ((0xBF58476D1CE4E5B9 * v6) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 80 * v13;
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(unsigned __int8 *)(v11 + 80 * v10 + 12) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 80 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 80 * v10;
  return v12 + 16;
}

void re::FrameProfiler::setEngineInitializedTimestamp(re::FrameProfiler *this, unint64_t a2)
{
  if (*((unsigned char *)this + 206))
  {
    unsigned int v4 = 0x7FFFFFFF;
    if (*((void *)this + 3))
    {
      unsigned int v5 = *(_DWORD *)(*((void *)this + 4) + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)));
      if (v5 != 0x7FFFFFFF)
      {
        uint64_t v6 = *((void *)this + 5);
        unsigned int v4 = *(_DWORD *)(*((void *)this + 4) + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)));
        if (*(_DWORD *)(v6 + 24 * v5 + 12) != 1024)
        {
          while (1)
          {
            unsigned int v4 = *(_DWORD *)(v6
                           + 24
                           * *(unsigned int *)(*((void *)this + 4)
                                             + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)))
                           + 8) & 0x7FFFFFFF;
            if (v4 == 0x7FFFFFFF) {
              break;
            }
            if (*(_DWORD *)(v6 + 24 * v4 + 12) == 1024) {
              goto LABEL_9;
            }
          }
          unsigned int v4 = 0x7FFFFFFF;
        }
      }
    }
LABEL_9:
    re::FrameThermalStats::setEngineInitializedTimestamp(*(re::FrameThermalStats **)(*((void *)this + 5) + 24 * v4 + 16), a2);
  }
  *((void *)this + 26) = a2;
}

re *re::internal::destroyPersistent<re::FrameStats>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    unsigned int v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::FrameProfiler::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(unsigned char *)(a1 + 206) || !*(unsigned char *)(a1 + 204)) {
    return;
  }
  unint64_t v7 = *(void **)a4;
  unint64_t v8 = *(void **)(a4 + 8);
  if (*(void **)a4 == v8) {
    goto LABEL_17;
  }
  do
  {
    uint64_t v9 = 0;
    uint64_t v10 = *v7 + 64;
    do
    {
      uint64_t v11 = (unint64_t *)(v10 + (v9 << 6));
      unint64_t v12 = v11[3];
      if (v12)
      {
        unint64_t v13 = v11[2];
        if (v13)
        {
          if (*(void *)(a1 + 344))
          {
            unint64_t v14 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v9) ^ ((0xBF58476D1CE4E5B9 * v9) >> 27));
            unint64_t v15 = (v14 ^ (v14 >> 31)) % *(unsigned int *)(a1 + 368);
            uint64_t v16 = *(void *)(a1 + 360);
            uint64_t v17 = *(unsigned int *)(*(void *)(a1 + 352) + 4 * v15);
            if (v17 != 0x7FFFFFFF)
            {
              while (v9 != *(unsigned __int8 *)(v16 + 80 * v17 + 12))
              {
                uint64_t v17 = *(_DWORD *)(v16 + 80 * v17 + 8) & 0x7FFFFFFF;
                if (v17 == 0x7FFFFFFF) {
                  goto LABEL_13;
                }
              }
              goto LABEL_14;
            }
          }
          else
          {
            uint64_t v16 = *(void *)(a1 + 360);
          }
LABEL_13:
          LODWORD(v17) = 0x7FFFFFFF;
LABEL_14:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v16 + 80 * v17 + 16), (float)v13, (float)v12, (float)*v11, (float)*(unint64_t *)(v10 + (v9 << 6) + 8));
        }
      }
      ++v9;
    }
    while (v9 != 157);
    ++v7;
  }
  while (v7 != v8);
LABEL_17:
  unint64_t v18 = *(void **)a5;
  int v34 = *(void **)(a5 + 8);
  if (*(void **)a5 != v34)
  {
    while (1)
    {
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v35 = v18;
      uint64_t v21 = *v18;
      do
      {
        if (*(void *)(v21 + 8 * v20)) {
          BOOL v22 = v19 > 0x1F;
        }
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          v36[v19++] = v20;
        }
        ++v20;
      }
      while (v20 != 32);
      if (v19) {
        break;
      }
LABEL_41:
      unint64_t v18 = v35 + 1;
      if (v35 + 1 == v34) {
        return;
      }
    }
    uint64_t v23 = 0;
    while (1)
    {
      uint64_t v24 = (unsigned __int16)v36[v23];
      if (*(void *)(a1 + 168) == v24) {
        break;
      }
LABEL_40:
      if (++v23 == v19) {
        goto LABEL_41;
      }
    }
    uint64_t v25 = 0;
    uint64_t v26 = *(void *)(v21 + 8 * v24) + 64;
    while (2)
    {
      long long v27 = (unint64_t *)(v26 + (v25 << 6));
      unint64_t v28 = v27[3];
      if (!v28) {
        goto LABEL_39;
      }
      unint64_t v29 = v27[2];
      if (!v29) {
        goto LABEL_39;
      }
      if (*(void *)(a1 + 392))
      {
        unint64_t v30 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v25) ^ ((0xBF58476D1CE4E5B9 * v25) >> 27));
        unint64_t v31 = (v30 ^ (v30 >> 31)) % *(unsigned int *)(a1 + 416);
        uint64_t v32 = *(void *)(a1 + 408);
        uint64_t v33 = *(unsigned int *)(*(void *)(a1 + 400) + 4 * v31);
        if (v33 != 0x7FFFFFFF)
        {
          while (v25 != *(unsigned __int8 *)(v32 + 80 * v33 + 12))
          {
            uint64_t v33 = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
            if (v33 == 0x7FFFFFFF) {
              goto LABEL_37;
            }
          }
LABEL_38:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v32 + 80 * v33 + 16), (float)v29, (float)v28, (float)*v27, (float)*(unint64_t *)(v26 + (v25 << 6) + 8));
LABEL_39:
          if (++v25 == 157) {
            goto LABEL_40;
          }
          continue;
        }
      }
      else
      {
        uint64_t v32 = *(void *)(a1 + 408);
      }
      break;
    }
LABEL_37:
    LODWORD(v33) = 0x7FFFFFFF;
    goto LABEL_38;
  }
}

void re::FrameProfiler::setOverlayEnabled(re::FrameProfiler *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 224);
  os_unfair_lock_lock((os_unfair_lock_t)this + 56);
  re::Defaults::intValue((re::Defaults *)"statisticsOverlayEnabled", v5, (uint64_t)v8);
  if (!v8[0])
  {
    if (!a2) {
      goto LABEL_7;
    }
LABEL_10:
    if (!*((unsigned char *)this + 206)) {
      re::FrameProfiler::init(this);
    }
    uint64_t v7 = 1;
    goto LABEL_13;
  }
  if (v9) {
    char v6 = a2;
  }
  else {
    char v6 = 0;
  }
  if (v9 == 1 || (v6 & 1) != 0) {
    goto LABEL_10;
  }
LABEL_7:
  if (*((unsigned char *)this + 206))
  {
    re::FrameProfiler::deinit(this);
    uint64_t v7 = 0;
LABEL_13:
    re::ProfilerManager::setProcessorEnabled<re::FrameProfiler,void>(*((void *)this + 23), v7);
    goto LABEL_15;
  }
  LOBYTE(v7) = 0;
LABEL_15:
  *((unsigned char *)this + 204) = v7;
  os_unfair_lock_unlock(v4);
}

void re::FrameProfiler::checkUserDefaultsForStatisticsOptions(re::FrameProfiler *this, const char *a2)
{
  re::Defaults::intValue((re::Defaults *)"showFrameTimeStatistics", a2, (uint64_t)v55);
  re::Defaults::intValue((re::Defaults *)"showAnimationStatistics", v3, (uint64_t)v53);
  re::Defaults::intValue((re::Defaults *)"showAssetPipelineStatistics", v4, (uint64_t)v51);
  re::Defaults::intValue((re::Defaults *)"showAudioStatistics", v5, (uint64_t)v49);
  re::Defaults::intValue((re::Defaults *)"showECSStatistics", v6, (uint64_t)v47);
  re::Defaults::intValue((re::Defaults *)"showMeshStatistics", v7, (uint64_t)v45);
  re::Defaults::intValue((re::Defaults *)"showNetworkStatistics", v8, (uint64_t)v43);
  re::Defaults::intValue((re::Defaults *)"showPhysicsStatistics", v9, (uint64_t)v41);
  re::Defaults::intValue((re::Defaults *)"showRenderingStatistics", v10, (uint64_t)v39);
  re::Defaults::intValue((re::Defaults *)"showMemoryStatistics", v11, (uint64_t)v37);
  re::Defaults::intValue((re::Defaults *)"showThermalStatistics", v12, (uint64_t)v35);
  re::Defaults::intValue((re::Defaults *)"showSceneUnderstandingStatistics", v13, (uint64_t)v33);
  re::Defaults::intValue((re::Defaults *)"showCustomStatistics", v14, (uint64_t)v31);
  re::Defaults::intValue((re::Defaults *)"showAttributionStatistics", v15, (uint64_t)v29);
  re::Defaults::intValue((re::Defaults *)"showVFXStatistics", v16, (uint64_t)v27);
  re::Defaults::intValue((re::Defaults *)"showAllStatistics", v17, (uint64_t)v25);
  re::Defaults::intValue((re::Defaults *)"showMTLCounterAPIStatistics", v18, (uint64_t)v23);
  if (v55[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFE | (v56 != 0);
  }
  if (v53[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFD | (2 * (v54 != 0));
  }
  if (v51[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFB | (4 * (v52 != 0));
  }
  if (v49[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFF7 | (8 * (v50 != 0));
  }
  if (v47[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFEF | (16 * (v48 != 0));
  }
  if (v45[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFDF | (32 * (v46 != 0));
  }
  if (v43[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFBF | ((v44 != 0) << 6);
  }
  if (v41[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFF7F | ((v42 != 0) << 7);
  }
  if (v39[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFEFF | ((v40 != 0) << 8);
  }
  if (v37[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFDFF | ((v38 != 0) << 9);
  }
  if (v35[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFBFF | ((v36 != 0) << 10);
  }
  if (v33[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFF7FF | ((v34 != 0) << 11);
  }
  if (v31[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFDFFF | ((v32 != 0) << 13);
  }
  if (v29[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFBFFF | ((v30 != 0) << 14);
  }
  if (v27[0]) {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFDFFFF | ((v28 != 0) << 17);
  }
  if (v25[0])
  {
    if (v26) {
      int v20 = -1;
    }
    else {
      int v20 = 0;
    }
    *((_DWORD *)this + 44) = v20;
  }
  if (v23[0])
  {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFEFFF | ((v24 != 0) << 12);
  }
  else
  {
    uint64_t v21 = *re::foundationProfilingLogObjects(v19);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v22 = 0;
      _os_log_impl(&dword_233120000, v21, OS_LOG_TYPE_DEFAULT, "MTLCounter API disabled. Enable with 'defaults write -g com.apple.re.showMTLCounterAPIStatistics 1'", v22, 2u);
    }
  }
}

uint64_t re::FrameProfiler::totalNumberOfFlags(re::FrameProfiler *this, int a2)
{
  uint64_t v3 = *((unsigned int *)this + 14);
  if (v3)
  {
    uint64_t v4 = 0;
    unsigned int v5 = (int *)(*((void *)this + 5) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 6;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 == v4) {
    return 0;
  }
  LODWORD(result) = 0;
  uint64_t v8 = v4;
  uint64_t v9 = *((void *)this + 5);
  do
  {
    if ((*(_DWORD *)(v9 + 24 * v8 + 12) & a2) != 0) {
      uint64_t result = (result + 1);
    }
    else {
      uint64_t result = result;
    }
    if (v3 <= (int)v4 + 1) {
      int v10 = v4 + 1;
    }
    else {
      int v10 = v3;
    }
    int v11 = v4;
    while (1)
    {
      uint64_t v8 = (v11 + 1);
      if (v10 - 1 == v11) {
        break;
      }
      ++v11;
      LODWORD(v4) = v8;
      if ((*(_DWORD *)(v9 + 24 * v8 + 8) & 0x80000000) != 0) {
        goto LABEL_21;
      }
    }
    LODWORD(v4) = v10;
LABEL_21:
    ;
  }
  while (v3 != v4);
  return result;
}

uint64_t re::FrameProfiler::setProfilerUpdateInterval(uint64_t this, float a2)
{
  if (*(unsigned char *)(this + 206))
  {
    uint64_t v2 = *(unsigned int *)(this + 56);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = (int *)(*(void *)(this + 40) + 8);
      while (1)
      {
        int v5 = *v4;
        v4 += 6;
        if (v5 < 0) {
          break;
        }
        if (v2 == ++v3)
        {
          LODWORD(v3) = *(_DWORD *)(this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v3) = 0;
    }
    if (v2 == v3)
    {
      int v6 = (int)a2;
    }
    else
    {
      uint64_t v7 = v3;
      int v6 = (int)a2;
      do
      {
        *(_DWORD *)(*(void *)(*(void *)(this + 40) + 24 * v7 + 16) + 8) = v6;
        if (v2 <= (int)v3 + 1) {
          int v8 = v3 + 1;
        }
        else {
          int v8 = v2;
        }
        int v9 = v3;
        while (1)
        {
          uint64_t v7 = (v9 + 1);
          if (v8 - 1 == v9) {
            break;
          }
          ++v9;
          LODWORD(v3) = v7;
          if ((*(_DWORD *)(*(void *)(this + 40) + 24 * v7 + 8) & 0x80000000) != 0) {
            goto LABEL_19;
          }
        }
        LODWORD(v3) = v8;
LABEL_19:
        ;
      }
      while (v2 != v3);
    }
    *(_DWORD *)(this + 192) = v6;
  }
  return this;
}

void re::FrameProfiler::checkUserDefaults(re::FrameProfiler *this, const char *a2)
{
  re::Defaults::intValue((re::Defaults *)"statisticsOverlayEnabled", a2, (uint64_t)v4);
  if (v4[0]) {
    re::FrameProfiler::setOverlayEnabled(this, 1);
  }
  re::FrameProfiler::checkUserDefaultsForStatisticsOptions(this, v3);
}

float re::FrameProfiler::totalFrameTime(re::FrameProfiler *this)
{
  if (*((unsigned char *)this + 206))
  {
    unsigned int v1 = 0x7FFFFFFF;
    if (*((void *)this + 43))
    {
      unsigned int v2 = *(_DWORD *)(*((void *)this + 44) + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)));
      if (v2 != 0x7FFFFFFF)
      {
        uint64_t v3 = *((void *)this + 45);
        unsigned int v1 = *(_DWORD *)(*((void *)this + 44) + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)));
        if (*(unsigned char *)(v3 + 80 * v2 + 12) != 1)
        {
          while (1)
          {
            unsigned int v1 = *(_DWORD *)(v3
                           + 80
                           * *(unsigned int *)(*((void *)this + 44)
                                             + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)))
                           + 8) & 0x7FFFFFFF;
            if (v1 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v3 + 80 * v1 + 12) == 1) {
              goto LABEL_11;
            }
          }
          unsigned int v1 = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    float v6 = *(float *)(*((void *)this + 45) + 80 * v1 + 48);
    int v7 = *((_DWORD *)this + 48);
    double v8 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v11 = NAN;
        return v11 / 1000000.0;
      }
      LODWORD(v9) = info.numer;
      LODWORD(v10) = info.denom;
      double v8 = (double)v9 / (double)v10;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v8;
    }
    double v11 = v8 * (double)(unint64_t)(float)(v6 / (float)v7);
    return v11 / 1000000.0;
  }
  uint64_t v4 = *re::foundationProfilingLogObjects(this);
  float v5 = -1.0;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v13 = 0;
    _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "totalFrameTime returns an accurate value only while statistics overlay is enabled", v13, 2u);
  }
  return v5;
}

float re::FrameThermalStats::setEngineInitializedTimestamp(re::FrameThermalStats *this, unint64_t a2)
{
  double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
    goto LABEL_5;
  }
  if (!mach_timebase_info(&info))
  {
    LODWORD(v5) = info.numer;
    LODWORD(v6) = info.denom;
    double v4 = (double)v5 / (double)v6;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
LABEL_5:
    double v7 = v4 * (double)a2;
    goto LABEL_6;
  }
  double v7 = NAN;
LABEL_6:
  float result = v7 / 1000000.0;
  *((float *)this + 21) = result;
  return result;
}

uint64_t re::FrameProfiler::frameUpdateFinished(re::FrameProfiler *this)
{
  if (!*((unsigned char *)this + 206)) {
    return 0;
  }
  int v2 = *((_DWORD *)this + 48);
  int v3 = *((_DWORD *)this + 49) + 1;
  *((_DWORD *)this + 49) = v3;
  if (v3 != v2) {
    return 0;
  }
  uint64_t v4 = *((unsigned int *)this + 94);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*((void *)this + 45) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 20;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 94);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v9 = v5;
    do
    {
      uint64_t v10 = *((void *)this + 45) + 80 * v9;
      *(_OWORD *)(v10 + 40) = *(_OWORD *)(v10 + 16);
      *(_DWORD *)(v10 + 56) = *(_DWORD *)(v10 + 32);
      *(_OWORD *)(v10 + 16) = xmmword_23440B8B0;
      *(_DWORD *)(v10 + 32) = 0;
      if (v4 <= (int)v5 + 1) {
        int v11 = v5 + 1;
      }
      else {
        int v11 = v4;
      }
      int v12 = v5;
      while (1)
      {
        uint64_t v9 = (v12 + 1);
        if (v11 - 1 == v12) {
          break;
        }
        ++v12;
        LODWORD(v5) = v9;
        if ((*(_DWORD *)(*((void *)this + 45) + 80 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_20;
        }
      }
      LODWORD(v5) = v11;
LABEL_20:
      ;
    }
    while (v4 != v5);
  }
  uint64_t v13 = *((unsigned int *)this + 106);
  if (v13)
  {
    uint64_t v14 = 0;
    unint64_t v15 = (int *)(*((void *)this + 51) + 8);
    while (1)
    {
      int v16 = *v15;
      v15 += 20;
      if (v16 < 0) {
        break;
      }
      if (v13 == ++v14)
      {
        LODWORD(v14) = *((_DWORD *)this + 106);
        break;
      }
    }
  }
  else
  {
    LODWORD(v14) = 0;
  }
  if (v13 != v14)
  {
    uint64_t v17 = v14;
    do
    {
      uint64_t v18 = *((void *)this + 51) + 80 * v17;
      *(_OWORD *)(v18 + 40) = *(_OWORD *)(v18 + 16);
      *(_DWORD *)(v18 + 56) = *(_DWORD *)(v18 + 32);
      *(_OWORD *)(v18 + 16) = xmmword_23440B8B0;
      *(_DWORD *)(v18 + 32) = 0;
      if (v13 <= (int)v14 + 1) {
        int v19 = v14 + 1;
      }
      else {
        int v19 = v13;
      }
      int v20 = v14;
      while (1)
      {
        uint64_t v17 = (v20 + 1);
        if (v19 - 1 == v20) {
          break;
        }
        ++v20;
        LODWORD(v14) = v17;
        if ((*(_DWORD *)(*((void *)this + 51) + 80 * v17 + 8) & 0x80000000) != 0) {
          goto LABEL_37;
        }
      }
      LODWORD(v14) = v19;
LABEL_37:
      ;
    }
    while (v13 != v14);
  }
  *((_DWORD *)this + 49) = 0;
  uint64_t v21 = *((void *)this + 40);
  *((void *)this + 40) = 0;
  if (v21)
  {
    BOOL v22 = (re::DynamicString *)*((void *)this + 42);
    uint64_t v23 = 48 * v21;
    do
    {
      re::DynamicString::deinit(v22);
      BOOL v22 = (re::DynamicString *)((char *)v22 + 48);
      v23 -= 48;
    }
    while (v23);
  }
  ++*((_DWORD *)this + 82);
  os_unfair_lock_lock((os_unfair_lock_t)this + 56);
  uint64_t v24 = *((void *)this + 17);
  if (v24)
  {
    uint64_t v25 = (void *)*((void *)this + 19);
    int v26 = &v25[v24];
    do
    {
      uint64_t v27 = *v25;
      if (*(unsigned char *)(*v25 + 160))
      {
        (*(void (**)(void, uint64_t, char *, char *))(*(void *)v27 + 24))(*v25, v27 + 16, (char *)this + 344, (char *)this + 392);
        uint64_t v28 = *(unsigned int *)(v27 + 48);
        if (v28)
        {
          uint64_t v29 = 0;
          int v30 = (int *)(*(void *)(v27 + 32) + 8);
          while (1)
          {
            int v31 = *v30;
            v30 += 16;
            if (v31 < 0) {
              break;
            }
            if (v28 == ++v29)
            {
              LODWORD(v29) = *(_DWORD *)(v27 + 48);
              break;
            }
          }
        }
        else
        {
          LODWORD(v29) = 0;
        }
        if (v28 != v29)
        {
          uint64_t v32 = v29;
          uint64_t v33 = *(void *)(v27 + 32);
          do
          {
            re::DynamicArray<re::FrameStatisticsOutput>::add((uint64_t)this + 304, (re::DynamicString *)(v33 + (v32 << 6) + 16));
            uint64_t v33 = *(void *)(v27 + 32);
            if (*(_DWORD *)(v27 + 48) <= (v29 + 1)) {
              int v34 = v29 + 1;
            }
            else {
              int v34 = *(_DWORD *)(v27 + 48);
            }
            int v35 = v29;
            while (1)
            {
              uint64_t v32 = (v35 + 1);
              if (v34 - 1 == v35) {
                break;
              }
              ++v35;
              LODWORD(v29) = v32;
              if ((*(_DWORD *)(v33 + (v32 << 6) + 8) & 0x80000000) != 0) {
                goto LABEL_60;
              }
            }
            LODWORD(v29) = v34;
LABEL_60:
            ;
          }
          while (v28 != v29);
        }
      }
      ++v25;
    }
    while (v25 != v26);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 56);
  uint64_t v36 = *((unsigned int *)this + 14);
  if (v36)
  {
    uint64_t v37 = 0;
    int v38 = (int *)(*((void *)this + 5) + 8);
    while (1)
    {
      int v39 = *v38;
      v38 += 6;
      if (v39 < 0) {
        break;
      }
      if (v36 == ++v37)
      {
        LODWORD(v37) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v37) = 0;
  }
  if (v36 != v37)
  {
    uint64_t v40 = v37;
    do
    {
      uint64_t v41 = *((void *)this + 5);
      if ((*((_DWORD *)this + 44) & *(_DWORD *)(v41 + 24 * v40 + 12)) != 0)
      {
        uint64_t v42 = *(void *)(v41 + 24 * v40 + 16);
        (*(void (**)(uint64_t, uint64_t, char *, char *))(*(void *)v42 + 24))(v42, v42 + 16, (char *)this + 344, (char *)this + 392);
        uint64_t v43 = *(unsigned int *)(v42 + 48);
        if (v43)
        {
          uint64_t v44 = 0;
          int v45 = (int *)(*(void *)(v42 + 32) + 8);
          while (1)
          {
            int v46 = *v45;
            v45 += 16;
            if (v46 < 0) {
              break;
            }
            if (v43 == ++v44)
            {
              LODWORD(v44) = *(_DWORD *)(v42 + 48);
              break;
            }
          }
        }
        else
        {
          LODWORD(v44) = 0;
        }
        if (v43 != v44)
        {
          uint64_t v47 = v44;
          uint64_t v48 = *(void *)(v42 + 32);
          do
          {
            re::DynamicArray<re::FrameStatisticsOutput>::add((uint64_t)this + 304, (re::DynamicString *)(v48 + (v47 << 6) + 16));
            uint64_t v48 = *(void *)(v42 + 32);
            if (*(_DWORD *)(v42 + 48) <= (v44 + 1)) {
              int v49 = v44 + 1;
            }
            else {
              int v49 = *(_DWORD *)(v42 + 48);
            }
            int v50 = v44;
            while (1)
            {
              uint64_t v47 = (v50 + 1);
              if (v49 - 1 == v50) {
                break;
              }
              ++v50;
              LODWORD(v44) = v47;
              if ((*(_DWORD *)(v48 + (v47 << 6) + 8) & 0x80000000) != 0) {
                goto LABEL_87;
              }
            }
            LODWORD(v44) = v49;
LABEL_87:
            ;
          }
          while (v43 != v44);
        }
      }
      if (*((_DWORD *)this + 14) <= (v37 + 1)) {
        int v51 = v37 + 1;
      }
      else {
        int v51 = *((_DWORD *)this + 14);
      }
      while (1)
      {
        uint64_t v40 = (v37 + 1);
        if (v51 - 1 == v37) {
          break;
        }
        LODWORD(v37) = v37 + 1;
        int v52 = v40;
        if ((*(_DWORD *)(*((void *)this + 5) + 24 * v40 + 8) & 0x80000000) != 0) {
          goto LABEL_95;
        }
      }
      int v52 = v51;
LABEL_95:
      LODWORD(v37) = v52;
    }
    while (v36 != v52);
  }
  return 1;
}

re::DynamicString *re::DynamicArray<re::FrameStatisticsOutput>::add(uint64_t a1, re::DynamicString *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::FrameStatisticsOutput>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::FrameStatisticsOutput>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  float result = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 32) + 48 * v5), a2);
  uint64_t v12 = *((void *)a2 + 4);
  *((_DWORD *)result + 10) = *((_DWORD *)a2 + 10);
  *((void *)result + 4) = v12;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::FrameProfiler::addCustomFrameStats(os_unfair_lock_s *this, const char *a2, float a3)
{
  if (BYTE2(this[51]._os_unfair_lock_opaque))
  {
    unint64_t v6 = this + 56;
    os_unfair_lock_lock(this + 56);
    unsigned int v7 = 0x7FFFFFFF;
    if (*(void *)&this[6]._os_unfair_lock_opaque)
    {
      unsigned int v8 = *(_DWORD *)(*(void *)&this[8]._os_unfair_lock_opaque
                     + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
      if (v8 != 0x7FFFFFFF)
      {
        uint64_t v9 = *(void *)&this[10]._os_unfair_lock_opaque;
        unsigned int v7 = *(_DWORD *)(*(void *)&this[8]._os_unfair_lock_opaque
                       + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
        if (*(_DWORD *)(v9 + 24 * v8 + 12) != 0x2000)
        {
          while (1)
          {
            unsigned int v7 = *(_DWORD *)(v9
                           + 24
                           * *(unsigned int *)(*(void *)&this[8]._os_unfair_lock_opaque
                                             + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque))
                           + 8) & 0x7FFFFFFF;
            if (v7 == 0x7FFFFFFF) {
              break;
            }
            if (*(_DWORD *)(v9 + 24 * v7 + 12) == 0x2000) {
              goto LABEL_10;
            }
          }
          unsigned int v7 = 0x7FFFFFFF;
        }
      }
    }
LABEL_10:
    unint64_t Stat = re::FrameCustomStats::addOrGetStat(*(re::FrameCustomStats **)(*(void *)&this[10]._os_unfair_lock_opaque + 24 * v7 + 16), a2);
    if (*(void *)&this[6]._os_unfair_lock_opaque)
    {
      uint64_t v11 = *(void *)&this[10]._os_unfair_lock_opaque;
      uint64_t v12 = *(unsigned int *)(*(void *)&this[8]._os_unfair_lock_opaque
                            + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
      unsigned int v13 = 0x7FFFFFFF;
      if (v12 != 0x7FFFFFFF)
      {
        if (*(_DWORD *)(v11 + 24 * v12 + 12) == 0x2000)
        {
LABEL_15:
          unsigned int v13 = v12;
        }
        else
        {
          while (1)
          {
            LODWORD(v12) = *(_DWORD *)(v11 + 24 * v12 + 8) & 0x7FFFFFFF;
            unsigned int v13 = 0x7FFFFFFF;
            if (v12 == 0x7FFFFFFF) {
              break;
            }
            if (*(_DWORD *)(v11 + 24 * v12 + 12) == 0x2000) {
              goto LABEL_15;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v11 = *(void *)&this[10]._os_unfair_lock_opaque;
      unsigned int v13 = 0x7FFFFFFF;
    }
    uint64_t v14 = *(void *)(v11 + 24 * v13 + 16);
    if (*(void *)(v14 + 136) > Stat) {
      re::FrameStats::CollectedStatistics::addValue((re::FrameStats::CollectedStatistics *)(*(void *)(v14 + 152) + 104 * Stat + 36), a3);
    }
    os_unfair_lock_unlock(v6);
  }
}

uint64_t re::FrameProfiler::addOrGetCustomStatClass(os_unfair_lock_s *this, const char *a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  unint64_t v4 = this + 56;
  os_unfair_lock_lock(this + 56);
  unint64_t v6 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)v29);
  unsigned int v7 = *(re **)&v29[0];
  if (*(void *)&v29[0] && (BYTE8(v29[0]) & 1) != 0) {
    unsigned int v7 = (re *)(*(uint64_t (**)(void))(**(void **)&v29[0] + 40))();
  }
  if (v6)
  {
    uint64_t v8 = *v6;
  }
  else
  {
    uint64_t v9 = re::globalAllocators(v7);
    unint64_t v10 = (re::FrameCustomStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9[2] + 32))(v9[2], 168, 8);
    uint64_t v11 = re::FrameCustomStats::FrameCustomStats(v10);
    unint64_t v12 = *(void *)&this[32]._os_unfair_lock_opaque;
    unint64_t v13 = *(void *)&this[34]._os_unfair_lock_opaque;
    if (v13 >= v12)
    {
      unint64_t v14 = v13 + 1;
      if (v12 < v13 + 1)
      {
        if (*(void *)&this[30]._os_unfair_lock_opaque)
        {
          uint64_t v15 = 2 * v12;
          BOOL v16 = v12 == 0;
          unint64_t v17 = 8;
          if (!v16) {
            unint64_t v17 = v15;
          }
          if (v17 <= v14) {
            unint64_t v18 = v14;
          }
          else {
            unint64_t v18 = v17;
          }
          uint64_t v11 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(&this[30]._os_unfair_lock_opaque, v18);
        }
        else
        {
          uint64_t v11 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(&this[30]._os_unfair_lock_opaque, v14);
          ++this[36]._os_unfair_lock_opaque;
        }
      }
      unint64_t v13 = *(void *)&this[34]._os_unfair_lock_opaque;
    }
    *(void *)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * v13) = v10;
    *(void *)&this[34]._os_unfair_lock_opaque = v13 + 1;
    ++this[36]._os_unfair_lock_opaque;
    *(void *)BOOL v22 = *(void *)&this[34]._os_unfair_lock_opaque - 1;
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)&this[18], (re::DynamicString *)v29, v22);
    if (*(void *)&v29[0] && (BYTE8(v29[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v29[0] + 40))();
    }
    uint64_t v19 = *(void *)&this[34]._os_unfair_lock_opaque;
    uint64_t v20 = v19 - 1;
    if (!v19)
    {
      memset(v29, 0, sizeof(v29));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)BOOL v22 = 136315906;
      *(void *)&v22[4] = "operator[]";
      __int16 v23 = 1024;
      int v24 = 789;
      __int16 v25 = 2048;
      uint64_t v26 = v20;
      __int16 v27 = 2048;
      uint64_t v28 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * v20), a2);
    uint64_t v8 = *(void *)&this[34]._os_unfair_lock_opaque - 1;
  }
  os_unfair_lock_unlock(v4);
  return v8;
}

void re::FrameProfiler::setCustomStatClassEnabled(os_unfair_lock_s *this, unint64_t a2, char a3)
{
  unint64_t v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(void *)&this[34]._os_unfair_lock_opaque > a2) {
    *(unsigned char *)(*(void *)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2) + 160) = a3;
  }
  os_unfair_lock_unlock(v6);
}

uint64_t re::FrameProfiler::addOrGetStatLine(os_unfair_lock_s *this, unint64_t a2, const char *a3)
{
  unint64_t v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(void *)&this[34]._os_unfair_lock_opaque <= a2) {
    uint64_t Stat = 0;
  }
  else {
    uint64_t Stat = re::FrameCustomStats::addOrGetStat(*(re::FrameCustomStats **)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3);
  }
  os_unfair_lock_unlock(v6);
  return Stat;
}

void re::FrameProfiler::logStat(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, float a4)
{
  if (BYTE2(this[51]._os_unfair_lock_opaque))
  {
    uint64_t v8 = this + 56;
    os_unfair_lock_lock(this + 56);
    if (*(void *)&this[34]._os_unfair_lock_opaque > a2)
    {
      uint64_t v9 = *(void *)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2);
      if (*(void *)(v9 + 136) > a3) {
        re::FrameStats::CollectedStatistics::addValue((re::FrameStats::CollectedStatistics *)(*(void *)(v9 + 152) + 104 * a3 + 36), a4);
      }
    }
    os_unfair_lock_unlock(v8);
  }
}

uint64_t re::FrameProfiler::addOrGetLine(os_unfair_lock_s *this, unint64_t a2, const char *a3)
{
  unint64_t v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(void *)&this[34]._os_unfair_lock_opaque <= a2) {
    uint64_t Line = 0;
  }
  else {
    uint64_t Line = re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3);
  }
  os_unfair_lock_unlock(v6);
  return Line;
}

void re::FrameProfiler::updateText(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, const char *a4)
{
  uint64_t v8 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(void *)&this[34]._os_unfair_lock_opaque > a2) {
    re::FrameCustomStats::updateText(*(void **)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3, a4);
  }
  os_unfair_lock_unlock(v8);
}

void re::FrameProfiler::setCustomStatOrLineEnabled(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v8 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(void *)&this[34]._os_unfair_lock_opaque > a2)
  {
    uint64_t v9 = *(void *)(*(void *)&this[38]._os_unfair_lock_opaque + 8 * a2);
    if (*(void *)(v9 + 136) > a3) {
      *(unsigned char *)(*(void *)(v9 + 152) + 104 * a3 + 32) = a4;
    }
  }
  os_unfair_lock_unlock(v8);
}

re::DynamicString *re::FrameProfiler::getStatisticOutputForOption(re::FrameProfiler *this, unsigned int a2, int a3)
{
  LODWORD(v4) = 0x7FFFFFFF;
  if (*((void *)this + 3))
  {
    unint64_t v5 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
    uint64_t v6 = *(unsigned int *)(*((void *)this + 4)
                         + 4
                         * (((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31))
                          % *((unsigned int *)this + 12)));
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *((void *)this + 5);
      LODWORD(v4) = v6;
      if (*(_DWORD *)(v7 + 24 * v6 + 12) != a2)
      {
        uint64_t v4 = v6;
        while (1)
        {
          LODWORD(v4) = *(_DWORD *)(v7 + 24 * v4 + 8) & 0x7FFFFFFF;
          if (v4 == 0x7FFFFFFF) {
            break;
          }
          if (*(_DWORD *)(v7 + 24 * v4 + 12) == a2) {
            goto LABEL_9;
          }
        }
        LODWORD(v4) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  uint64_t v8 = *(void *)(*((void *)this + 5) + 24 * v4 + 16);
  (*(void (**)(uint64_t, uint64_t, char *, char *))(*(void *)v8 + 24))(v8, v8 + 16, (char *)this + 344, (char *)this + 392);
  LODWORD(v9) = 0x7FFFFFFF;
  if (*(void *)(v8 + 16))
  {
    uint64_t v10 = **(unsigned int **)(v8 + 24);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(v8 + 32);
      if (*(_DWORD *)(v11 + (v10 << 6) + 12))
      {
        uint64_t v9 = **(unsigned int **)(v8 + 24);
        while (1)
        {
          uint64_t v9 = *(_DWORD *)(v11 + (v9 << 6) + 8) & 0x7FFFFFFF;
          if (v9 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v11 + (v9 << 6) + 12)) {
            goto LABEL_18;
          }
        }
        LODWORD(v9) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v9) = **(_DWORD **)(v8 + 24);
      }
    }
  }
LABEL_18:
  uint64_t v12 = *(void *)(v8 + 32);
  unint64_t v13 = (re::DynamicString *)(v12 + ((unint64_t)v9 << 6) + 16);
  if (*(_DWORD *)(v8 + 44) != 1 && a3 != 0)
  {
    uint64_t v15 = *(unsigned int *)(v8 + 48);
    if (v15)
    {
      uint64_t v16 = 0;
      unint64_t v17 = (int *)(v12 + 8);
      while (1)
      {
        int v18 = *v17;
        v17 += 16;
        if (v18 < 0) {
          break;
        }
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(v8 + 48);
          break;
        }
      }
    }
    else
    {
      LODWORD(v16) = 0;
    }
    if (v15 != v16)
    {
      uint64_t v19 = v16;
      unsigned int v20 = *(_DWORD *)(v8 + 48);
      do
      {
        uint64_t v21 = v12 + (v19 << 6);
        if (*(_DWORD *)(v21 + 12))
        {
          if (*(unsigned char *)(v21 + 24)) {
            BOOL v22 = *(const char **)(v21 + 32);
          }
          else {
            BOOL v22 = (const char *)(v21 + 25);
          }
          size_t v23 = strlen(v22);
          re::DynamicString::append(v13, v22, v23);
          unsigned int v20 = *(_DWORD *)(v8 + 48);
          uint64_t v12 = *(void *)(v8 + 32);
        }
        if (v20 <= (int)v16 + 1) {
          unsigned int v24 = v16 + 1;
        }
        else {
          unsigned int v24 = v20;
        }
        while (1)
        {
          uint64_t v19 = (v16 + 1);
          if (v24 - 1 == v16) {
            break;
          }
          LODWORD(v16) = v16 + 1;
          unsigned int v25 = v19;
          if ((*(_DWORD *)(v12 + (v19 << 6) + 8) & 0x80000000) != 0) {
            goto LABEL_42;
          }
        }
        unsigned int v25 = v24;
LABEL_42:
        LODWORD(v16) = v25;
      }
      while (v15 != v25);
    }
  }
  return v13;
}

void *re::allocInfo_FrameProfiler(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_431, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_431))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99748, "FrameProfiler");
    __cxa_guard_release(&_MergedGlobals_431);
  }
  return &unk_26AF99748;
}

void re::initInfo_FrameProfiler(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x4D07016EB3F258ACLL;
  v5[1] = "FrameProfiler";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x1B800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_FrameProfiler(re::IntrospectionBase *)::structureAttributes;
  *((void *)this + 9) = re::internal::defaultConstruct<re::FrameProfiler>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::FrameProfiler>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::FrameProfiler>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::FrameProfiler>;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

re::FrameProfiler *re::internal::defaultConstruct<re::FrameProfiler>(int a1, int a2, re::FrameProfiler *this)
{
  return re::FrameProfiler::FrameProfiler(this);
}

void re::internal::defaultDestruct<re::FrameProfiler>(int a1, int a2, re::FrameProfiler *this)
{
}

uint64_t re::introspect_FrameProfiler(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"FrameProfiler", (uint64_t (*)(re::internal *))re::allocInfo_FrameProfiler, (re::IntrospectionBase *(*)(void))re::initInfo_FrameProfiler, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FrameProfiler>, this);
}

uint64_t re::FrameProfiler::willNeedEvents(re::FrameProfiler *this)
{
  return 0;
}

uint64_t re::FrameProfiler::willNeedStatistics(re::FrameProfiler *this)
{
  return 1;
}

uint64_t re::FrameProfiler::willNeedAttributions(re::FrameProfiler *this)
{
  return 1;
}

uint64_t re::FrameProfiler::willNeedMemoryStatistics(re::FrameProfiler *this)
{
  return 0;
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, re::DynamicString *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v10 << 6)) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + (v10 << 6);
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 16), a5);
  uint64_t v15 = *((void *)a5 + 4);
  *(_DWORD *)(v14 + 56) = *((_DWORD *)a5 + 10);
  *(void *)(v14 + 48) = v15;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (_DWORD *)(*(void *)&v13[16] + v10 + 12), *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 64;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + (v9 << 6) + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v9 << 6)) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 12) = *a4;
  uint64_t v13 = *(void *)(a1 + 16) + (v9 << 6);
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(void *)(v13 + 40) = *(void *)(a5 + 24);
  uint64_t v14 = *(void *)(a5 + 8);
  *(void *)(v13 + 16) = *(void *)a5;
  *(void *)a5 = 0;
  uint64_t v15 = *(void *)(a5 + 16);
  *(void *)(a5 + 24) = 0;
  uint64_t v17 = *(void *)(v13 + 24);
  uint64_t v16 = *(void *)(v13 + 32);
  *(void *)(v13 + 24) = v14;
  *(void *)(v13 + 32) = v15;
  *(void *)(a5 + 8) = v17;
  *(void *)(a5 + 16) = v16;
  uint64_t v18 = *(void *)(a5 + 32);
  *(_DWORD *)(v13 + 56) = *(_DWORD *)(a5 + 40);
  *(void *)(v13 + 48) = v18;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(uint64_t a1, unsigned int *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = *a2;
  unint64_t v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + (v4 << 6) + 12) == v2) {
    return 1;
  }
  do
  {
    uint64_t v4 = *(_DWORD *)(v6 + (v4 << 6) + 8) & 0x7FFFFFFF;
    BOOL result = v4 != 0x7FFFFFFF;
  }
  while (v4 != 0x7FFFFFFF && *(_DWORD *)(v6 + (v4 << 6) + 12) != v2);
  return result;
}

void re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)size_t v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 2);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 24 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 24 * v18) = v15;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18 + 12) = *((_DWORD *)v14 - 1);
            *(void *)(*(void *)(a1 + 16) + 24 * v18 + 16) = *v14;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 3;
        }
        while (v11 < v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 80 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 80;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (unsigned char *)(v8 + 12), (re::FrameStats::CollectedStatistics *)(v8 + 16));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 80;
    }
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (unsigned char *)(*(void *)&v13[16] + v10 + 12), (re::FrameStats::CollectedStatistics *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, unsigned char *a4, re::FrameStats::CollectedStatistics *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 80 * v10) = a3;
  *(unsigned char *)(*(void *)(a1 + 16) + 80 * v10 + 12) = *a4;
  re::FrameStats::CollectedStatistics::CollectedStatistics((re::FrameStats::CollectedStatistics *)(*(void *)(a1 + 16) + 80 * v10 + 16), a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void *re::DynamicArray<re::FrameStatisticsOutput>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      BOOL result = (void *)*result;
      if (!*v5)
      {
        BOOL result = (void *)re::DynamicArray<re::FrameStatisticsOutput>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          BOOL result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            unsigned int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        BOOL result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unsigned int v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 48 * v9;
        int v11 = v7;
        do
        {
          *(_OWORD *)int v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *int v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          void v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          uint64_t v16 = *(void *)(v8 + 32);
          *((_DWORD *)v11 + 10) = *(_DWORD *)(v8 + 40);
          v11[4] = v16;
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 48;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      BOOL result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::FrameStats::init(re::FrameStats *this, int a2, int a3)
{
  uint64_t v3 = this;
  *((_DWORD *)this + 2) = a3;
  *((unsigned char *)this + 64) = 1;
  *(_DWORD *)uint64_t v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  *(void *)&v9[4] = 0x7FFFFFFFLL;
  uint64_t v3 = (re::FrameStats *)((char *)v3 + 16);
  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::operator=((uint64_t)v3, (uint64_t *)&v7);
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v7);
  *((void *)&v7 + 1) = 0;
  long long v8 = 0uLL;
  re::DynamicString::setCapacity(&v7, 0);
  *(void *)uint64_t v9 = 0x2800000006;
  *(_DWORD *)&v9[8] = 1;
  int v6 = 0;
  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>((uint64_t)v3, &v6, (re::DynamicString *)&v7);
  uint64_t result = v7;
  if ((void)v7)
  {
    if (BYTE8(v7)) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1);
    }
  }
  return a1;
}

unint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(uint64_t a1, _DWORD *a2, re::DynamicString *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    unint64_t v12 = *(void *)(a1 + 16) + ((unint64_t)v13 << 6);
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(_DWORD *)(v11 + (v10 << 6) + 12) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  unint64_t v12 = v11 + (v10 << 6);
  return v12 + 16;
}

float re::FrameStats::CollectedStatistics::addValue(re::FrameStats::CollectedStatistics *this, float a2)
{
  if (*(float *)this > a2) {
    *(float *)this = a2;
  }
  if (*((float *)this + 1) < a2) {
    *((float *)this + 1) = a2;
  }
  float v2 = *((float *)this + 2) + a2;
  float v3 = *((float *)this + 3) + 1.0;
  *((float *)this + 2) = v2;
  *((float *)this + 3) = v3;
  *((float *)this + 4) = v2 / v3;
  *((float *)this + 5) = a2;
  if (*((float *)this + 11) > a2) {
    *((float *)this + 11) = a2;
  }
  if (*((float *)this + 12) < a2) {
    *((float *)this + 12) = a2;
  }
  float v4 = *((float *)this + 13) + a2;
  float v5 = *((float *)this + 14) + 1.0;
  *((float *)this + 13) = v4;
  *((float *)this + 14) = v5;
  float result = v4 / v5;
  *((float *)this + 15) = result;
  return result;
}

float re::FrameStats::CollectedStatistics::addGroupValues(re::FrameStats::CollectedStatistics *this, float a2, float a3, float a4, float a5)
{
  if (*(float *)this > a4) {
    *(float *)this = a4;
  }
  if (*((float *)this + 1) < a5) {
    *((float *)this + 1) = a5;
  }
  float v5 = *((float *)this + 2) + a2;
  float v6 = *((float *)this + 3) + a3;
  *((float *)this + 2) = v5;
  *((float *)this + 3) = v6;
  *((float *)this + 4) = v5 / v6;
  if (*((float *)this + 11) > a4) {
    *((float *)this + 11) = a4;
  }
  if (*((float *)this + 12) < a5) {
    *((float *)this + 12) = a5;
  }
  float v7 = *((float *)this + 13) + a2;
  float v8 = *((float *)this + 14) + a3;
  *((float *)this + 13) = v7;
  *((float *)this + 14) = v8;
  float result = v7 / v8;
  *((float *)this + 15) = result;
  return result;
}

float re::FrameStats::CollectedStatistics::CollectedStatistics(re::FrameStats::CollectedStatistics *this, const re::FrameStats::CollectedStatistics *a2)
{
  *(void *)this = 0xFF7FFFFF7F7FFFFFLL;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = xmmword_23440B890;
  *(_OWORD *)((char *)this + 40) = xmmword_23440B8A0;
  *((void *)this + 7) = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 44) = *(_OWORD *)((char *)a2 + 44);
  float result = *((float *)a2 + 15);
  *((float *)this + 15) = result;
  return result;
}

uint64_t re::FrameTimeStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 1)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 1) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  double v395 = v22;
  if (*(void *)a3)
  {
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDBD238973A2B148ALL % *(unsigned int *)(a3 + 24)));
    unsigned int v25 = 0x7FFFFFFF;
    if (v24 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v23 + 80 * v24 + 12) == 2)
      {
LABEL_30:
        unsigned int v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          unsigned int v25 = 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v23 + 80 * v24 + 12) == 2) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a3 + 16);
    unsigned int v25 = 0x7FFFFFFF;
  }
  float v26 = *(float *)(v23 + 80 * v25 + 48);
  int v27 = *(_DWORD *)(a1 + 8);
  double v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    double v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v28;
  }
  double v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  if (*(void *)a3)
  {
    uint64_t v32 = *(void *)(a3 + 16);
    uint64_t v33 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x1E535EEDE31428F0uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v34 = 0x7FFFFFFF;
    if (v33 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v32 + 80 * v33 + 12) == 3)
      {
LABEL_42:
        unsigned int v34 = v33;
      }
      else
      {
        while (1)
        {
          LODWORD(v33) = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
          unsigned int v34 = 0x7FFFFFFF;
          if (v33 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v32 + 80 * v33 + 12) == 3) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v32 = *(void *)(a3 + 16);
    unsigned int v34 = 0x7FFFFFFF;
  }
  float v35 = *(float *)(v32 + 80 * v34 + 48);
  int v36 = *(_DWORD *)(a1 + 8);
  double v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info.numer;
    LODWORD(v39) = info.denom;
    double v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v37;
  }
  double v40 = v37 * (double)(unint64_t)(float)(v35 / (float)v36);
LABEL_49:
  if (*(void *)a3)
  {
    uint64_t v41 = *(void *)(a3 + 16);
    uint64_t v42 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xB7A4712C74562914 % *(unsigned int *)(a3 + 24)));
    unsigned int v43 = 0x7FFFFFFF;
    if (v42 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v41 + 80 * v42 + 12) == 4)
      {
LABEL_54:
        unsigned int v43 = v42;
      }
      else
      {
        while (1)
        {
          LODWORD(v42) = *(_DWORD *)(v41 + 80 * v42 + 8) & 0x7FFFFFFF;
          unsigned int v43 = 0x7FFFFFFF;
          if (v42 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v41 + 80 * v42 + 12) == 4) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v41 = *(void *)(a3 + 16);
    unsigned int v43 = 0x7FFFFFFF;
  }
  float v44 = *(float *)(v41 + 80 * v43 + 48);
  int v45 = *(_DWORD *)(a1 + 8);
  double v46 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v49 = NAN;
      goto LABEL_61;
    }
    LODWORD(v47) = info.numer;
    LODWORD(v48) = info.denom;
    double v46 = (double)v47 / (double)v48;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v46;
  }
  double v49 = v46 * (double)(unint64_t)(float)(v44 / (float)v45);
LABEL_61:
  if (*(void *)a3)
  {
    uint64_t v50 = *(void *)(a3 + 16);
    uint64_t v51 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xB6BF613DBEBB45DCLL % *(unsigned int *)(a3 + 24)));
    unsigned int v52 = 0x7FFFFFFF;
    if (v51 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v50 + 80 * v51 + 12) == 5)
      {
LABEL_66:
        unsigned int v52 = v51;
      }
      else
      {
        while (1)
        {
          LODWORD(v51) = *(_DWORD *)(v50 + 80 * v51 + 8) & 0x7FFFFFFF;
          unsigned int v52 = 0x7FFFFFFF;
          if (v51 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v50 + 80 * v51 + 12) == 5) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v50 = *(void *)(a3 + 16);
    unsigned int v52 = 0x7FFFFFFF;
  }
  float v53 = *(float *)(v50 + 80 * v52 + 48);
  int v54 = *(_DWORD *)(a1 + 8);
  double v55 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v399 = NAN;
      goto LABEL_73;
    }
    LODWORD(v56) = info.numer;
    LODWORD(v57) = info.denom;
    double v55 = (double)v56 / (double)v57;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v55;
  }
  double v399 = v55 * (double)(unint64_t)(float)(v53 / (float)v54);
LABEL_73:
  if (*(void *)a3)
  {
    uint64_t v58 = *(void *)(a3 + 16);
    uint64_t v59 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD17707977078336CLL % *(unsigned int *)(a3 + 24)));
    unsigned int v60 = 0x7FFFFFFF;
    if (v59 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v58 + 80 * v59 + 12) == 6)
      {
LABEL_78:
        unsigned int v60 = v59;
      }
      else
      {
        while (1)
        {
          LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
          unsigned int v60 = 0x7FFFFFFF;
          if (v59 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v58 + 80 * v59 + 12) == 6) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v58 = *(void *)(a3 + 16);
    unsigned int v60 = 0x7FFFFFFF;
  }
  float v61 = *(float *)(v58 + 80 * v60 + 48);
  int v62 = *(_DWORD *)(a1 + 8);
  double v63 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v379 = NAN;
      goto LABEL_85;
    }
    LODWORD(v64) = info.numer;
    LODWORD(v65) = info.denom;
    double v63 = (double)v64 / (double)v65;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v63;
  }
  double v379 = v63 * (double)(unint64_t)(float)(v61 / (float)v62);
LABEL_85:
  if (*(void *)a3)
  {
    uint64_t v66 = *(void *)(a3 + 16);
    uint64_t v67 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x12AE30237B17DF14uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v68 = 0x7FFFFFFF;
    if (v67 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v66 + 80 * v67 + 12) == 7)
      {
LABEL_90:
        unsigned int v68 = v67;
      }
      else
      {
        while (1)
        {
          LODWORD(v67) = *(_DWORD *)(v66 + 80 * v67 + 8) & 0x7FFFFFFF;
          unsigned int v68 = 0x7FFFFFFF;
          if (v67 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v66 + 80 * v67 + 12) == 7) {
            goto LABEL_90;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v66 = *(void *)(a3 + 16);
    unsigned int v68 = 0x7FFFFFFF;
  }
  float v69 = *(float *)(v66 + 80 * v68 + 48);
  int v70 = *(_DWORD *)(a1 + 8);
  double v71 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v397 = NAN;
      goto LABEL_97;
    }
    LODWORD(v72) = info.numer;
    LODWORD(v73) = info.denom;
    double v71 = (double)v72 / (double)v73;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v71;
  }
  double v397 = v71 * (double)(unint64_t)(float)(v69 / (float)v70);
LABEL_97:
  if (*(void *)a3)
  {
    uint64_t v74 = *(void *)(a3 + 16);
    uint64_t v75 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a3 + 24)));
    unsigned int v76 = 0x7FFFFFFF;
    if (v75 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v74 + 80 * v75 + 12) == 9)
      {
LABEL_102:
        unsigned int v76 = v75;
      }
      else
      {
        while (1)
        {
          LODWORD(v75) = *(_DWORD *)(v74 + 80 * v75 + 8) & 0x7FFFFFFF;
          unsigned int v76 = 0x7FFFFFFF;
          if (v75 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v74 + 80 * v75 + 12) == 9) {
            goto LABEL_102;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v74 = *(void *)(a3 + 16);
    unsigned int v76 = 0x7FFFFFFF;
  }
  float v77 = *(float *)(v74 + 80 * v76 + 48);
  int v78 = *(_DWORD *)(a1 + 8);
  double v79 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v82 = NAN;
      goto LABEL_109;
    }
    LODWORD(v80) = info.numer;
    LODWORD(v81) = info.denom;
    double v79 = (double)v80 / (double)v81;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v79;
  }
  double v82 = v79 * (double)(unint64_t)(float)(v77 / (float)v78);
LABEL_109:
  double v392 = v82;
  if (*(void *)a3)
  {
    uint64_t v83 = *(void *)(a3 + 16);
    uint64_t v84 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v85 = 0x7FFFFFFF;
    if (v84 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v83 + 80 * v84 + 12) == 10)
      {
LABEL_114:
        unsigned int v85 = v84;
      }
      else
      {
        while (1)
        {
          LODWORD(v84) = *(_DWORD *)(v83 + 80 * v84 + 8) & 0x7FFFFFFF;
          unsigned int v85 = 0x7FFFFFFF;
          if (v84 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v83 + 80 * v84 + 12) == 10) {
            goto LABEL_114;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v83 = *(void *)(a3 + 16);
    unsigned int v85 = 0x7FFFFFFF;
  }
  float v86 = *(float *)(v83 + 80 * v85 + 48);
  int v87 = *(_DWORD *)(a1 + 8);
  double v88 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v91 = NAN;
      goto LABEL_121;
    }
    LODWORD(v89) = info.numer;
    LODWORD(v90) = info.denom;
    double v88 = (double)v89 / (double)v90;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v88;
  }
  double v91 = v88 * (double)(unint64_t)(float)(v86 / (float)v87);
LABEL_121:
  double v385 = v91;
  if (*(void *)a3)
  {
    uint64_t v92 = *(void *)(a3 + 16);
    uint64_t v93 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a3 + 24)));
    unsigned int v94 = 0x7FFFFFFF;
    if (v93 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v92 + 80 * v93 + 12) == 8)
      {
LABEL_126:
        unsigned int v94 = v93;
      }
      else
      {
        while (1)
        {
          LODWORD(v93) = *(_DWORD *)(v92 + 80 * v93 + 8) & 0x7FFFFFFF;
          unsigned int v94 = 0x7FFFFFFF;
          if (v93 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v92 + 80 * v93 + 12) == 8) {
            goto LABEL_126;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v92 = *(void *)(a3 + 16);
    unsigned int v94 = 0x7FFFFFFF;
  }
  float v95 = *(float *)(v92 + 80 * v94 + 48);
  int v96 = *(_DWORD *)(a1 + 8);
  double v97 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v100 = NAN;
      goto LABEL_133;
    }
    LODWORD(v98) = info.numer;
    LODWORD(v99) = info.denom;
    double v97 = (double)v98 / (double)v99;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v97;
  }
  double v100 = v97 * (double)(unint64_t)(float)(v95 / (float)v96);
LABEL_133:
  if (*(void *)a3)
  {
    uint64_t v101 = *(void *)(a3 + 16);
    uint64_t v102 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v103 = 0x7FFFFFFF;
    if (v102 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v101 + 80 * v102 + 12) == 11)
      {
LABEL_138:
        unsigned int v103 = v102;
      }
      else
      {
        while (1)
        {
          LODWORD(v102) = *(_DWORD *)(v101 + 80 * v102 + 8) & 0x7FFFFFFF;
          unsigned int v103 = 0x7FFFFFFF;
          if (v102 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v101 + 80 * v102 + 12) == 11) {
            goto LABEL_138;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v101 = *(void *)(a3 + 16);
    unsigned int v103 = 0x7FFFFFFF;
  }
  float v104 = *(float *)(v101 + 80 * v103 + 48);
  int v105 = *(_DWORD *)(a1 + 8);
  double v106 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v378 = NAN;
      goto LABEL_145;
    }
    LODWORD(v107) = info.numer;
    LODWORD(v108) = info.denom;
    double v106 = (double)v107 / (double)v108;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v106;
  }
  double v378 = v106 * (double)(unint64_t)(float)(v104 / (float)v105);
LABEL_145:
  if (*(void *)a3)
  {
    uint64_t v109 = *(void *)(a3 + 16);
    uint64_t v110 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v111 = 0x7FFFFFFF;
    if (v110 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v109 + 80 * v110 + 12) == 12)
      {
LABEL_150:
        unsigned int v111 = v110;
      }
      else
      {
        while (1)
        {
          LODWORD(v110) = *(_DWORD *)(v109 + 80 * v110 + 8) & 0x7FFFFFFF;
          unsigned int v111 = 0x7FFFFFFF;
          if (v110 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v109 + 80 * v110 + 12) == 12) {
            goto LABEL_150;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v109 = *(void *)(a3 + 16);
    unsigned int v111 = 0x7FFFFFFF;
  }
  float v112 = *(float *)(v109 + 80 * v111 + 48);
  int v113 = *(_DWORD *)(a1 + 8);
  double v114 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v376 = NAN;
      goto LABEL_157;
    }
    LODWORD(v115) = info.numer;
    LODWORD(v116) = info.denom;
    double v114 = (double)v115 / (double)v116;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v114;
  }
  double v376 = v114 * (double)(unint64_t)(float)(v112 / (float)v113);
LABEL_157:
  if (*(void *)a3)
  {
    uint64_t v117 = *(void *)(a3 + 16);
    uint64_t v118 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
    unsigned int v119 = 0x7FFFFFFF;
    if (v118 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v117 + 80 * v118 + 12) == 13)
      {
LABEL_162:
        unsigned int v119 = v118;
      }
      else
      {
        while (1)
        {
          LODWORD(v118) = *(_DWORD *)(v117 + 80 * v118 + 8) & 0x7FFFFFFF;
          unsigned int v119 = 0x7FFFFFFF;
          if (v118 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v117 + 80 * v118 + 12) == 13) {
            goto LABEL_162;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v117 = *(void *)(a3 + 16);
    unsigned int v119 = 0x7FFFFFFF;
  }
  float v120 = *(float *)(v117 + 80 * v119 + 48);
  int v121 = *(_DWORD *)(a1 + 8);
  double v122 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v125 = NAN;
      goto LABEL_169;
    }
    LODWORD(v123) = info.numer;
    LODWORD(v124) = info.denom;
    double v122 = (double)v123 / (double)v124;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v122;
  }
  double v125 = v122 * (double)(unint64_t)(float)(v120 / (float)v121);
LABEL_169:
  double v390 = v125;
  if (*(void *)a3)
  {
    uint64_t v126 = *(void *)(a3 + 16);
    uint64_t v127 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v128 = 0x7FFFFFFF;
    if (v127 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v126 + 80 * v127 + 12) == 14)
      {
LABEL_174:
        unsigned int v128 = v127;
      }
      else
      {
        while (1)
        {
          LODWORD(v127) = *(_DWORD *)(v126 + 80 * v127 + 8) & 0x7FFFFFFF;
          unsigned int v128 = 0x7FFFFFFF;
          if (v127 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v126 + 80 * v127 + 12) == 14) {
            goto LABEL_174;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v126 = *(void *)(a3 + 16);
    unsigned int v128 = 0x7FFFFFFF;
  }
  float v129 = *(float *)(v126 + 80 * v128 + 48);
  int v130 = *(_DWORD *)(a1 + 8);
  double v131 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v134 = NAN;
      goto LABEL_181;
    }
    LODWORD(v132) = info.numer;
    LODWORD(v133) = info.denom;
    double v131 = (double)v132 / (double)v133;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v131;
  }
  double v134 = v131 * (double)(unint64_t)(float)(v129 / (float)v130);
LABEL_181:
  if (*(void *)a3)
  {
    uint64_t v135 = *(void *)(a3 + 16);
    uint64_t v136 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v137 = 0x7FFFFFFF;
    if (v136 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v135 + 80 * v136 + 12) == 15)
      {
LABEL_186:
        unsigned int v137 = v136;
      }
      else
      {
        while (1)
        {
          LODWORD(v136) = *(_DWORD *)(v135 + 80 * v136 + 8) & 0x7FFFFFFF;
          unsigned int v137 = 0x7FFFFFFF;
          if (v136 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v135 + 80 * v136 + 12) == 15) {
            goto LABEL_186;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v135 = *(void *)(a3 + 16);
    unsigned int v137 = 0x7FFFFFFF;
  }
  float v138 = *(float *)(v135 + 80 * v137 + 48);
  int v139 = *(_DWORD *)(a1 + 8);
  double v140 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v380 = NAN;
      goto LABEL_193;
    }
    LODWORD(v141) = info.numer;
    LODWORD(v142) = info.denom;
    double v140 = (double)v141 / (double)v142;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v140;
  }
  double v380 = v140 * (double)(unint64_t)(float)(v138 / (float)v139);
LABEL_193:
  if (*(void *)a3)
  {
    uint64_t v143 = *(void *)(a3 + 16);
    uint64_t v144 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a3 + 24)));
    unsigned int v145 = 0x7FFFFFFF;
    if (v144 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v143 + 80 * v144 + 12) == 16)
      {
LABEL_198:
        unsigned int v145 = v144;
      }
      else
      {
        while (1)
        {
          LODWORD(v144) = *(_DWORD *)(v143 + 80 * v144 + 8) & 0x7FFFFFFF;
          unsigned int v145 = 0x7FFFFFFF;
          if (v144 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v143 + 80 * v144 + 12) == 16) {
            goto LABEL_198;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v143 = *(void *)(a3 + 16);
    unsigned int v145 = 0x7FFFFFFF;
  }
  float v146 = *(float *)(v143 + 80 * v145 + 48);
  int v147 = *(_DWORD *)(a1 + 8);
  double v148 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v151 = NAN;
      goto LABEL_205;
    }
    LODWORD(v149) = info.numer;
    LODWORD(v150) = info.denom;
    double v148 = (double)v149 / (double)v150;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v148;
  }
  double v151 = v148 * (double)(unint64_t)(float)(v146 / (float)v147);
LABEL_205:
  double v382 = v151;
  if (*(void *)a3)
  {
    uint64_t v152 = *(void *)(a3 + 16);
    uint64_t v153 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v154 = 0x7FFFFFFF;
    if (v153 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v152 + 80 * v153 + 12) == 17)
      {
LABEL_210:
        unsigned int v154 = v153;
      }
      else
      {
        while (1)
        {
          LODWORD(v153) = *(_DWORD *)(v152 + 80 * v153 + 8) & 0x7FFFFFFF;
          unsigned int v154 = 0x7FFFFFFF;
          if (v153 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v152 + 80 * v153 + 12) == 17) {
            goto LABEL_210;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v152 = *(void *)(a3 + 16);
    unsigned int v154 = 0x7FFFFFFF;
  }
  float v155 = *(float *)(v152 + 80 * v154 + 48);
  int v156 = *(_DWORD *)(a1 + 8);
  double v157 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v160 = NAN;
      goto LABEL_217;
    }
    LODWORD(v158) = info.numer;
    LODWORD(v159) = info.denom;
    double v157 = (double)v158 / (double)v159;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v157;
  }
  double v160 = v157 * (double)(unint64_t)(float)(v155 / (float)v156);
LABEL_217:
  double v383 = v160;
  if (*(void *)a3)
  {
    uint64_t v161 = *(void *)(a3 + 16);
    uint64_t v162 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
    unsigned int v163 = 0x7FFFFFFF;
    if (v162 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v161 + 80 * v162 + 12) == 19)
      {
LABEL_222:
        unsigned int v163 = v162;
      }
      else
      {
        while (1)
        {
          LODWORD(v162) = *(_DWORD *)(v161 + 80 * v162 + 8) & 0x7FFFFFFF;
          unsigned int v163 = 0x7FFFFFFF;
          if (v162 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v161 + 80 * v162 + 12) == 19) {
            goto LABEL_222;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v161 = *(void *)(a3 + 16);
    unsigned int v163 = 0x7FFFFFFF;
  }
  float v164 = *(float *)(v161 + 80 * v163 + 48);
  int v165 = *(_DWORD *)(a1 + 8);
  double v166 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v375 = NAN;
      goto LABEL_229;
    }
    LODWORD(v167) = info.numer;
    LODWORD(v168) = info.denom;
    double v166 = (double)v167 / (double)v168;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v166;
  }
  double v375 = v166 * (double)(unint64_t)(float)(v164 / (float)v165);
LABEL_229:
  if (*(void *)a3)
  {
    uint64_t v169 = *(void *)(a3 + 16);
    uint64_t v170 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v171 = 0x7FFFFFFF;
    if (v170 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v169 + 80 * v170 + 12) == 20)
      {
LABEL_234:
        unsigned int v171 = v170;
      }
      else
      {
        while (1)
        {
          LODWORD(v170) = *(_DWORD *)(v169 + 80 * v170 + 8) & 0x7FFFFFFF;
          unsigned int v171 = 0x7FFFFFFF;
          if (v170 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v169 + 80 * v170 + 12) == 20) {
            goto LABEL_234;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v169 = *(void *)(a3 + 16);
    unsigned int v171 = 0x7FFFFFFF;
  }
  float v172 = *(float *)(v169 + 80 * v171 + 48);
  int v173 = *(_DWORD *)(a1 + 8);
  double v174 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v177 = NAN;
      goto LABEL_241;
    }
    LODWORD(v175) = info.numer;
    LODWORD(v176) = info.denom;
    double v174 = (double)v175 / (double)v176;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v174;
  }
  double v177 = v174 * (double)(unint64_t)(float)(v172 / (float)v173);
LABEL_241:
  double v381 = v177;
  if (*(void *)a3)
  {
    uint64_t v178 = *(void *)(a3 + 16);
    uint64_t v179 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
    unsigned int v180 = 0x7FFFFFFF;
    if (v179 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v178 + 80 * v179 + 12) == 21)
      {
LABEL_246:
        unsigned int v180 = v179;
      }
      else
      {
        while (1)
        {
          LODWORD(v179) = *(_DWORD *)(v178 + 80 * v179 + 8) & 0x7FFFFFFF;
          unsigned int v180 = 0x7FFFFFFF;
          if (v179 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v178 + 80 * v179 + 12) == 21) {
            goto LABEL_246;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v178 = *(void *)(a3 + 16);
    unsigned int v180 = 0x7FFFFFFF;
  }
  float v181 = *(float *)(v178 + 80 * v180 + 48);
  int v182 = *(_DWORD *)(a1 + 8);
  double v183 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v377 = NAN;
      goto LABEL_253;
    }
    LODWORD(v184) = info.numer;
    LODWORD(v185) = info.denom;
    double v183 = (double)v184 / (double)v185;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v183;
  }
  double v377 = v183 * (double)(unint64_t)(float)(v181 / (float)v182);
LABEL_253:
  if (*(void *)a3)
  {
    uint64_t v186 = *(void *)(a3 + 16);
    uint64_t v187 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v188 = 0x7FFFFFFF;
    if (v187 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v186 + 80 * v187 + 12) == 23)
      {
LABEL_258:
        unsigned int v188 = v187;
      }
      else
      {
        while (1)
        {
          LODWORD(v187) = *(_DWORD *)(v186 + 80 * v187 + 8) & 0x7FFFFFFF;
          unsigned int v188 = 0x7FFFFFFF;
          if (v187 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v186 + 80 * v187 + 12) == 23) {
            goto LABEL_258;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v186 = *(void *)(a3 + 16);
    unsigned int v188 = 0x7FFFFFFF;
  }
  float v189 = *(float *)(v186 + 80 * v188 + 48);
  int v190 = *(_DWORD *)(a1 + 8);
  double v191 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v374 = NAN;
      goto LABEL_265;
    }
    LODWORD(v192) = info.numer;
    LODWORD(v193) = info.denom;
    double v191 = (double)v192 / (double)v193;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v191;
  }
  double v374 = v191 * (double)(unint64_t)(float)(v189 / (float)v190);
LABEL_265:
  double v389 = v134;
  if (*(void *)a3)
  {
    uint64_t v194 = *(void *)(a3 + 16);
    uint64_t v195 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a3 + 24)));
    unsigned int v196 = 0x7FFFFFFF;
    double v197 = v100;
    double v198 = v49;
    if (v195 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v194 + 80 * v195 + 12) == 22)
      {
LABEL_270:
        unsigned int v196 = v195;
      }
      else
      {
        while (1)
        {
          LODWORD(v195) = *(_DWORD *)(v194 + 80 * v195 + 8) & 0x7FFFFFFF;
          unsigned int v196 = 0x7FFFFFFF;
          if (v195 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v194 + 80 * v195 + 12) == 22) {
            goto LABEL_270;
          }
        }
      }
    }
  }
  else
  {
    double v197 = v100;
    double v198 = v49;
    uint64_t v194 = *(void *)(a3 + 16);
    unsigned int v196 = 0x7FFFFFFF;
  }
  double v199 = v31 / 1000000.0;
  float v200 = *(float *)(v194 + 80 * v196 + 48);
  int v201 = *(_DWORD *)(a1 + 8);
  double v202 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v391 = NAN;
      goto LABEL_277;
    }
    LODWORD(v203) = info.numer;
    LODWORD(v204) = info.denom;
    double v202 = (double)v203 / (double)v204;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v202;
  }
  double v391 = v202 * (double)(unint64_t)(float)(v200 / (float)v201);
LABEL_277:
  if (*(void *)a3)
  {
    uint64_t v207 = *(void *)(a3 + 16);
    uint64_t v208 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v209 = 0x7FFFFFFF;
    if (v208 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v207 + 80 * v208 + 12) == 91)
      {
LABEL_282:
        unsigned int v209 = v208;
      }
      else
      {
        while (1)
        {
          LODWORD(v208) = *(_DWORD *)(v207 + 80 * v208 + 8) & 0x7FFFFFFF;
          unsigned int v209 = 0x7FFFFFFF;
          if (v208 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v207 + 80 * v208 + 12) == 91) {
            goto LABEL_282;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v207 = *(void *)(a3 + 16);
    unsigned int v209 = 0x7FFFFFFF;
  }
  float v205 = v199;
  float v206 = v40 / 1000000.0;
  float v211 = v205 + v206;
  float v212 = *(float *)(v207 + 80 * v209 + 48);
  int v213 = *(_DWORD *)(a1 + 8);
  double v214 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v217 = NAN;
      goto LABEL_289;
    }
    LODWORD(v215) = info.numer;
    LODWORD(v216) = info.denom;
    double v214 = (double)v215 / (double)v216;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v214;
  }
  double v217 = v214 * (double)(unint64_t)(float)(v212 / (float)v213);
LABEL_289:
  if (*(void *)a3)
  {
    uint64_t v219 = *(void *)(a3 + 16);
    uint64_t v220 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a3 + 24)));
    unsigned int v221 = 0x7FFFFFFF;
    if (v220 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v219 + 80 * v220 + 12) == 92)
      {
LABEL_294:
        unsigned int v221 = v220;
      }
      else
      {
        while (1)
        {
          LODWORD(v220) = *(_DWORD *)(v219 + 80 * v220 + 8) & 0x7FFFFFFF;
          unsigned int v221 = 0x7FFFFFFF;
          if (v220 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v219 + 80 * v220 + 12) == 92) {
            goto LABEL_294;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v219 = *(void *)(a3 + 16);
    unsigned int v221 = 0x7FFFFFFF;
  }
  float v218 = v399 / 1000000.0;
  float v210 = v198 / 1000000.0;
  float v223 = (float)(v211 + v210) + v218;
  float v224 = *(float *)(v219 + 80 * v221 + 48);
  int v225 = *(_DWORD *)(a1 + 8);
  double v226 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v229 = NAN;
      goto LABEL_301;
    }
    LODWORD(v227) = info.numer;
    LODWORD(v228) = info.denom;
    double v226 = (double)v227 / (double)v228;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v226;
  }
  double v229 = v226 * (double)(unint64_t)(float)(v224 / (float)v225);
LABEL_301:
  float v230 = v397 / 1000000.0;
  float v222 = v379 / 1000000.0;
  float v231 = v223 + v222;
  double v232 = v229 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v233 = *(void *)(a3 + 16);
    uint64_t v234 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a3 + 24)));
    unsigned int v235 = 0x7FFFFFFF;
    if (v234 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v233 + 80 * v234 + 12) == 93)
      {
LABEL_306:
        unsigned int v235 = v234;
      }
      else
      {
        while (1)
        {
          LODWORD(v234) = *(_DWORD *)(v233 + 80 * v234 + 8) & 0x7FFFFFFF;
          unsigned int v235 = 0x7FFFFFFF;
          if (v234 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v233 + 80 * v234 + 12) == 93) {
            goto LABEL_306;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v233 = *(void *)(a3 + 16);
    unsigned int v235 = 0x7FFFFFFF;
  }
  float v236 = v385 / 1000000.0;
  float v237 = v197 / 1000000.0;
  float v400 = v237;
  float v238 = v378 / 1000000.0;
  float v239 = v376 / 1000000.0;
  float v240 = v374 / 1000000.0;
  float v398 = v240;
  float v241 = v395 / 1000000.0;
  float v242 = v231 + v230;
  float v243 = v217 / 1000000.0;
  float v244 = v232;
  float v245 = *(float *)(v233 + 80 * v235 + 48);
  int v246 = *(_DWORD *)(a1 + 8);
  double v247 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    float v386 = v385 / 1000000.0;
    float v248 = v231 + v230;
    if (mach_timebase_info(&info))
    {
      double v251 = NAN;
      float v242 = v248;
      double v252 = v392;
      float v236 = v386;
      goto LABEL_313;
    }
    LODWORD(v249) = info.numer;
    LODWORD(v250) = info.denom;
    double v247 = (double)v249 / (double)v250;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v247;
    float v242 = v248;
    float v236 = v386;
  }
  double v251 = v247 * (double)(unint64_t)(float)(v245 / (float)v246);
  double v252 = v392;
LABEL_313:
  double v253 = v252 / 1000000.0;
  float v254 = v251 / 1000000.0;
  float v396 = v242;
  float v387 = (float)(v243 + v244) + v254;
  float v255 = v242 + v387;
  float v256 = (float)(v238 + v239) + v398;
  float v257 = 0.0;
  if (v400 <= 0.0) {
    float v257 = (float)(v238 + v239) + v398;
  }
  float v393 = v257;
  float v258 = v236;
  if (v400 > 0.0) {
    float v256 = v236;
  }
  float v259 = v255 - v256;
  if (v241 > 0.0) {
    double v260 = (float)(1000.0 / v241);
  }
  else {
    double v260 = 0.0;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Frame Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "FPS : %.2f    Main Thread : %.2f\n", v260, v259);
  if (v400 > 0.0) {
    re::DynamicString::appendf((re::DynamicString *)v11, "Render Thread : %.2f\n", (float)((float)((float)(v400 - v238) - v239) - v398));
  }
  float v261 = v253;
  re::DynamicString::appendf((re::DynamicString *)v11, "Main Thread Breakdown (ms)\n");
  if (*(void *)a3)
  {
    uint64_t v262 = *(void *)(a3 + 16);
    uint64_t v263 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v264 = 0x7FFFFFFF;
    if (v263 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v262 + 80 * v263 + 12) == 122)
      {
LABEL_327:
        unsigned int v264 = v263;
      }
      else
      {
        while (1)
        {
          LODWORD(v263) = *(_DWORD *)(v262 + 80 * v263 + 8) & 0x7FFFFFFF;
          unsigned int v264 = 0x7FFFFFFF;
          if (v263 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v262 + 80 * v263 + 12) == 122) {
            goto LABEL_327;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v262 = *(void *)(a3 + 16);
    unsigned int v264 = 0x7FFFFFFF;
  }
  float v265 = *(float *)(v262 + 80 * v264 + 48);
  int v266 = *(_DWORD *)(a1 + 8);
  double v267 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v270 = NAN;
      goto LABEL_334;
    }
    LODWORD(v268) = info.numer;
    LODWORD(v269) = info.denom;
    double v267 = (double)v268 / (double)v269;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v267;
  }
  double v270 = v267 * (double)(unint64_t)(float)(v265 / (float)v266);
LABEL_334:
  if (*(void *)a3)
  {
    uint64_t v271 = *(void *)(a3 + 16);
    uint64_t v272 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    unsigned int v273 = 0x7FFFFFFF;
    if (v272 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v271 + 80 * v272 + 12) == 129)
      {
LABEL_339:
        unsigned int v273 = v272;
      }
      else
      {
        while (1)
        {
          LODWORD(v272) = *(_DWORD *)(v271 + 80 * v272 + 8) & 0x7FFFFFFF;
          unsigned int v273 = 0x7FFFFFFF;
          if (v272 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v271 + 80 * v272 + 12) == 129) {
            goto LABEL_339;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v271 = *(void *)(a3 + 16);
    unsigned int v273 = 0x7FFFFFFF;
  }
  float v274 = (float)((float)(v261 - v258) + v387) - v393;
  float v275 = *(float *)(v271 + 80 * v273 + 48);
  int v276 = *(_DWORD *)(a1 + 8);
  double v277 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v280 = NAN;
      goto LABEL_346;
    }
    LODWORD(v278) = info.numer;
    LODWORD(v279) = info.denom;
    double v277 = (double)v278 / (double)v279;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v277;
  }
  double v280 = v277 * (double)(unint64_t)(float)(v275 / (float)v276);
LABEL_346:
  double v281 = v270 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v282 = *(void *)(a3 + 16);
    uint64_t v283 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    unsigned int v284 = 0x7FFFFFFF;
    if (v283 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v282 + 80 * v283 + 12) == 128)
      {
LABEL_351:
        unsigned int v284 = v283;
      }
      else
      {
        while (1)
        {
          LODWORD(v283) = *(_DWORD *)(v282 + 80 * v283 + 8) & 0x7FFFFFFF;
          unsigned int v284 = 0x7FFFFFFF;
          if (v283 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v282 + 80 * v283 + 12) == 128) {
            goto LABEL_351;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v282 = *(void *)(a3 + 16);
    unsigned int v284 = 0x7FFFFFFF;
  }
  double v285 = v375 / 1000000.0;
  double v286 = v281 + v274;
  float v287 = *(float *)(v282 + 80 * v284 + 48);
  int v288 = *(_DWORD *)(a1 + 8);
  double v289 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v290 = v280 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v293 = NAN;
      goto LABEL_358;
    }
    LODWORD(v291) = info.numer;
    LODWORD(v292) = info.denom;
    double v289 = (double)v291 / (double)v292;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v289;
  }
  double v293 = v289 * (double)(unint64_t)(float)(v287 / (float)v288);
LABEL_358:
  double v295 = v293 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v296 = *(void *)(a3 + 16);
    uint64_t v297 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v298 = 0x7FFFFFFF;
    if (v297 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v296 + 80 * v297 + 12) == 121)
      {
LABEL_363:
        unsigned int v298 = v297;
      }
      else
      {
        while (1)
        {
          LODWORD(v297) = *(_DWORD *)(v296 + 80 * v297 + 8) & 0x7FFFFFFF;
          unsigned int v298 = 0x7FFFFFFF;
          if (v297 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v296 + 80 * v297 + 12) == 121) {
            goto LABEL_363;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v296 = *(void *)(a3 + 16);
    unsigned int v298 = 0x7FFFFFFF;
  }
  double v300 = v286 + v290 + v295;
  float v388 = v285;
  float v294 = v285;
  double v301 = v294;
  float v302 = *(float *)(v296 + 80 * v298 + 48);
  int v303 = *(_DWORD *)(a1 + 8);
  double v304 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v307 = NAN;
      goto LABEL_370;
    }
    LODWORD(v305) = info.numer;
    LODWORD(v306) = info.denom;
    double v304 = (double)v305 / (double)v306;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v304;
  }
  double v307 = v304 * (double)(unint64_t)(float)(v302 / (float)v303);
LABEL_370:
  float v299 = v382 / 1000000.0;
  double v308 = v299;
  re::DynamicString::appendf((re::DynamicString *)v11, "Rendering : %.2f    Physics : %.2f\n", v300, v307 / 1000000.0 + v301);
  if (*(void *)a3)
  {
    uint64_t v309 = *(void *)(a3 + 16);
    uint64_t v310 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    unsigned int v311 = 0x7FFFFFFF;
    if (v310 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v309 + 80 * v310 + 12) == 123)
      {
LABEL_375:
        unsigned int v311 = v310;
      }
      else
      {
        while (1)
        {
          LODWORD(v310) = *(_DWORD *)(v309 + 80 * v310 + 8) & 0x7FFFFFFF;
          unsigned int v311 = 0x7FFFFFFF;
          if (v310 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v309 + 80 * v310 + 12) == 123) {
            goto LABEL_375;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v309 = *(void *)(a3 + 16);
    unsigned int v311 = 0x7FFFFFFF;
  }
  double v312 = v383 / 1000000.0 + v308;
  float v313 = *(float *)(v309 + 80 * v311 + 48);
  int v314 = *(_DWORD *)(a1 + 8);
  double v315 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v318 = NAN;
      goto LABEL_382;
    }
    LODWORD(v316) = info.numer;
    LODWORD(v317) = info.denom;
    double v315 = (double)v316 / (double)v317;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v315;
  }
  double v318 = v315 * (double)(unint64_t)(float)(v313 / (float)v314);
LABEL_382:
  if (*(void *)a3)
  {
    uint64_t v320 = *(void *)(a3 + 16);
    uint64_t v321 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v322 = 0x7FFFFFFF;
    if (v321 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v320 + 80 * v321 + 12) == 124)
      {
LABEL_387:
        unsigned int v322 = v321;
      }
      else
      {
        while (1)
        {
          LODWORD(v321) = *(_DWORD *)(v320 + 80 * v321 + 8) & 0x7FFFFFFF;
          unsigned int v322 = 0x7FFFFFFF;
          if (v321 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v320 + 80 * v321 + 12) == 124) {
            goto LABEL_387;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v320 = *(void *)(a3 + 16);
    unsigned int v322 = 0x7FFFFFFF;
  }
  double v323 = v381 / 1000000.0;
  float v384 = v312;
  float v319 = v312;
  double v324 = v319;
  float v325 = *(float *)(v320 + 80 * v322 + 48);
  int v326 = *(_DWORD *)(a1 + 8);
  double v327 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v328 = v318 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v331 = NAN;
      goto LABEL_394;
    }
    LODWORD(v329) = info.numer;
    LODWORD(v330) = info.denom;
    double v327 = (double)v329 / (double)v330;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v327;
  }
  double v331 = v327 * (double)(unint64_t)(float)(v325 / (float)v326);
LABEL_394:
  double v333 = v331 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v334 = *(void *)(a3 + 16);
    uint64_t v335 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v336 = 0x7FFFFFFF;
    float v337 = v261;
    if (v335 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v334 + 80 * v335 + 12) == 125)
      {
LABEL_399:
        unsigned int v336 = v335;
      }
      else
      {
        while (1)
        {
          LODWORD(v335) = *(_DWORD *)(v334 + 80 * v335 + 8) & 0x7FFFFFFF;
          unsigned int v336 = 0x7FFFFFFF;
          if (v335 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v334 + 80 * v335 + 12) == 125) {
            goto LABEL_399;
          }
        }
      }
    }
  }
  else
  {
    float v337 = v261;
    uint64_t v334 = *(void *)(a3 + 16);
    unsigned int v336 = 0x7FFFFFFF;
  }
  double v338 = v328 + v324 + v333;
  float v394 = v323;
  float v332 = v323;
  double v339 = v332;
  float v340 = *(float *)(v334 + 80 * v336 + 48);
  int v341 = *(_DWORD *)(a1 + 8);
  double v342 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v345 = NAN;
      goto LABEL_406;
    }
    LODWORD(v343) = info.numer;
    LODWORD(v344) = info.denom;
    double v342 = (double)v343 / (double)v344;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v342;
  }
  double v345 = v342 * (double)(unint64_t)(float)(v340 / (float)v341);
LABEL_406:
  float v346 = v377 / 1000000.0;
  float v347 = v391 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Network : %.2f    Animation : %.2f\n", v338, v345 / 1000000.0 + v339);
  if (*(void *)a3)
  {
    uint64_t v348 = *(void *)(a3 + 16);
    uint64_t v349 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v350 = 0x7FFFFFFF;
    if (v349 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v348 + 80 * v349 + 12) == 120)
      {
LABEL_411:
        unsigned int v350 = v349;
      }
      else
      {
        while (1)
        {
          LODWORD(v349) = *(_DWORD *)(v348 + 80 * v349 + 8) & 0x7FFFFFFF;
          unsigned int v350 = 0x7FFFFFFF;
          if (v349 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v348 + 80 * v349 + 12) == 120) {
            goto LABEL_411;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v348 = *(void *)(a3 + 16);
    unsigned int v350 = 0x7FFFFFFF;
  }
  float v351 = *(float *)(v348 + 80 * v350 + 48);
  int v352 = *(_DWORD *)(a1 + 8);
  double v353 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v356 = NAN;
      goto LABEL_418;
    }
    LODWORD(v354) = info.numer;
    LODWORD(v355) = info.denom;
    double v353 = (double)v354 / (double)v355;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v353;
  }
  double v356 = v353 * (double)(unint64_t)(float)(v351 / (float)v352);
LABEL_418:
  re::DynamicString::appendf((re::DynamicString *)v11, "Assets : %.2f    Audio : %.2f\n", v346, v356 / 1000000.0 + v347);
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 1;
  if (*(void *)a3)
  {
    uint64_t v357 = *(void *)(a3 + 16);
    uint64_t v358 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFFCB5C99F6AA8871 % *(unsigned int *)(a3 + 24)));
    unsigned int v359 = 0x7FFFFFFF;
    if (v358 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v357 + 80 * v358 + 12) == 18)
      {
LABEL_423:
        unsigned int v359 = v358;
      }
      else
      {
        while (1)
        {
          LODWORD(v358) = *(_DWORD *)(v357 + 80 * v358 + 8) & 0x7FFFFFFF;
          unsigned int v359 = 0x7FFFFFFF;
          if (v358 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v357 + 80 * v358 + 12) == 18) {
            goto LABEL_423;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v357 = *(void *)(a3 + 16);
    unsigned int v359 = 0x7FFFFFFF;
  }
  float v360 = *(float *)(v357 + 80 * v359 + 48);
  int v361 = *(_DWORD *)(a1 + 8);
  double v362 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v365 = NAN;
      goto LABEL_430;
    }
    LODWORD(v363) = info.numer;
    LODWORD(v364) = info.denom;
    double v362 = (double)v363 / (double)v364;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v362;
  }
  double v365 = v362 * (double)(unint64_t)(float)(v360 / (float)v361);
LABEL_430:
  float v366 = v390 / 1000000.0;
  float v367 = v389 / 1000000.0;
  float v368 = v366 + v367;
  float v369 = v380 / 1000000.0;
  float v370 = (float)((float)((float)((float)((float)((float)(v396 - (float)(v368 + v369)) - v384) - v388) - v394) - v346)
               - v347)
       - v337;
  float v371 = 0.0;
  if (v400 <= 0.0) {
    float v371 = v398;
  }
  float v372 = v365 / 1000000.0;
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v11, "Update Callback : %.2f    Others : %.2f\n", v372, (float)((float)(v370 - v371) - v372));
  *(_DWORD *)(v8 + (v9 << 6) + 48) = 7;
  return result;
}

double re::FrameAnimationStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Animation Stats\n");
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 125)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 125) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Animations CPU Time (ms) : %.2f\n", v22 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v25 = 0x7FFFFFFF;
    if (v24 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v23 + 80 * v24 + 12) == 20)
      {
LABEL_30:
        unsigned int v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          unsigned int v25 = 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v23 + 80 * v24 + 12) == 20) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a3 + 16);
    unsigned int v25 = 0x7FFFFFFF;
  }
  float v26 = *(float *)(v23 + 80 * v25 + 48);
  int v27 = *(_DWORD *)(a1 + 8);
  double v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    double v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v28;
  }
  double v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animation Manager CPU Time (ms) : %.2f\n", v31 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v32 = *(void *)(a3 + 16);
    uint64_t v33 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x786DD0AB972D849AuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v34 = 0x7FFFFFFF;
    if (v33 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v32 + 80 * v33 + 12) == 115)
      {
LABEL_42:
        unsigned int v34 = v33;
      }
      else
      {
        while (1)
        {
          LODWORD(v33) = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
          unsigned int v34 = 0x7FFFFFFF;
          if (v33 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v32 + 80 * v33 + 12) == 115) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v32 = *(void *)(a3 + 16);
    unsigned int v34 = 0x7FFFFFFF;
  }
  float v35 = *(float *)(v32 + 80 * v34 + 48);
  int v36 = *(_DWORD *)(a1 + 8);
  double v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info.numer;
    LODWORD(v39) = info.denom;
    double v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v37;
  }
  double v40 = v37 * (double)(unint64_t)(float)(v35 / (float)v36);
LABEL_49:
  re::DynamicString::appendf((re::DynamicString *)v11, "Deform Processing CPU Time (ms) : %.2f\n", v40 / 1000000.0);
  if (!*(void *)a3)
  {
    uint64_t v42 = *(void *)(a3 + 16);
    float v45 = (float)*(int *)(a1 + 8);
    float v46 = *(float *)(v42 + 0x27FFFFFFE0) / v45;
    unsigned int v47 = 0x7FFFFFFF;
    goto LABEL_63;
  }
  unint64_t v41 = *(unsigned int *)(a3 + 24);
  uint64_t v43 = *(void *)(a3 + 8);
  uint64_t v42 = *(void *)(a3 + 16);
  uint64_t v44 = *(unsigned int *)(v43 + 4 * (0x33CFFC116CF4F2F0 % v41));
  if (v44 == 0x7FFFFFFF)
  {
    LODWORD(v44) = 0x7FFFFFFF;
LABEL_54:
    uint64_t v48 = v42 + 80 * v44;
    goto LABEL_58;
  }
  if (*(unsigned char *)(v42 + 80 * v44 + 12) == 116) {
    goto LABEL_54;
  }
  do
    LODWORD(v44) = *(_DWORD *)(v42 + 80 * v44 + 8) & 0x7FFFFFFF;
  while (v44 != 0x7FFFFFFF && *(unsigned char *)(v42 + 80 * v44 + 12) != 116);
  uint64_t v48 = v42 + 80 * v44;
LABEL_58:
  float v45 = (float)*(int *)(a1 + 8);
  float v46 = *(float *)(v48 + 48) / v45;
  uint64_t v49 = *(unsigned int *)(v43 + 4 * (0xEF08A61A384AADEELL % v41));
  unsigned int v47 = 0x7FFFFFFF;
  if (v49 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v42 + 80 * v49 + 12) == 117)
    {
LABEL_62:
      unsigned int v47 = v49;
    }
    else
    {
      while (1)
      {
        LODWORD(v49) = *(_DWORD *)(v42 + 80 * v49 + 8) & 0x7FFFFFFF;
        unsigned int v47 = 0x7FFFFFFF;
        if (v49 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v42 + 80 * v49 + 12) == 117) {
          goto LABEL_62;
        }
      }
    }
  }
LABEL_63:
  re::DynamicString::appendf((re::DynamicString *)v11, "Active Deformations : %.0f, Total Joints : %.0f\n", v46, (float)(*(float *)(v42 + 80 * v47 + 48) / v45));
  re::DynamicString::appendf((re::DynamicString *)v11, "Component Counts\n");
  if (!*(void *)a3)
  {
    uint64_t v51 = *(void *)(a3 + 16);
    float v54 = *(float *)(v51 + 0x27FFFFFFE0);
    float v55 = (float)*(int *)(a1 + 8);
    float v56 = v54 / v55;
    unsigned int v57 = 0x7FFFFFFF;
    goto LABEL_83;
  }
  unint64_t v50 = *(unsigned int *)(a3 + 24);
  uint64_t v52 = *(void *)(a3 + 8);
  uint64_t v51 = *(void *)(a3 + 16);
  uint64_t v53 = *(unsigned int *)(v52 + 4 * (0x8607C7321697C49DLL % v50));
  if (v53 == 0x7FFFFFFF)
  {
    LODWORD(v53) = 0x7FFFFFFF;
  }
  else if (*(unsigned char *)(v51 + 80 * v53 + 12) != 107)
  {
    do
      LODWORD(v53) = *(_DWORD *)(v51 + 80 * v53 + 8) & 0x7FFFFFFF;
    while (v53 != 0x7FFFFFFF && *(unsigned char *)(v51 + 80 * v53 + 12) != 107);
    uint64_t v58 = v51 + 80 * v53;
    goto LABEL_72;
  }
  uint64_t v58 = v51 + 80 * v53;
LABEL_72:
  float v55 = (float)*(int *)(a1 + 8);
  float v56 = *(float *)(v58 + 48) / v55;
  unsigned int v59 = *(_DWORD *)(v52 + 4 * (0x581D666DC9C63F77 % v50));
  unsigned int v57 = 0x7FFFFFFF;
  unsigned int v60 = 0x7FFFFFFF;
  if (v59 != 0x7FFFFFFF)
  {
    unsigned int v60 = *(_DWORD *)(v52 + 4 * (0x581D666DC9C63F77 % v50));
    if (*(unsigned char *)(v51 + 80 * v59 + 12) != 111)
    {
      while (1)
      {
        unsigned int v60 = *(_DWORD *)(v51 + 80 * *(unsigned int *)(v52 + 4 * (0x581D666DC9C63F77 % v50)) + 8) & 0x7FFFFFFF;
        if (v60 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v51 + 80 * v60 + 12) == 111) {
          goto LABEL_78;
        }
      }
      unsigned int v60 = 0x7FFFFFFF;
    }
  }
LABEL_78:
  float v54 = *(float *)(v51 + 80 * v60 + 48);
  uint64_t v61 = *(unsigned int *)(v52 + 4 * (0x30AF74B32E05F342 % v50));
  if (v61 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v51 + 80 * v61 + 12) == 109)
    {
LABEL_82:
      unsigned int v57 = v61;
    }
    else
    {
      while (1)
      {
        LODWORD(v61) = *(_DWORD *)(v51 + 80 * v61 + 8) & 0x7FFFFFFF;
        unsigned int v57 = 0x7FFFFFFF;
        if (v61 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v51 + 80 * v61 + 12) == 109) {
          goto LABEL_82;
        }
      }
    }
  }
LABEL_83:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animations : %.0f, Blend Shapes : %.0f, Rigs : %.0f\n", v56, (float)(v54 / v55), (float)(*(float *)(v51 + 80 * v57 + 48) / v55));
  if (!*(void *)a3)
  {
    uint64_t v63 = *(void *)(a3 + 16);
    float v66 = (float)*(int *)(a1 + 8);
    float v67 = *(float *)(v63 + 0x27FFFFFFE0) / v66;
    unsigned int v68 = 0x7FFFFFFF;
    goto LABEL_95;
  }
  unint64_t v62 = *(unsigned int *)(a3 + 24);
  uint64_t v64 = *(void *)(a3 + 8);
  uint64_t v63 = *(void *)(a3 + 16);
  uint64_t v65 = *(unsigned int *)(v64 + 4 * (0xF2BAED4A618B76B9 % v62));
  if (v65 == 0x7FFFFFFF) {
    goto LABEL_85;
  }
  if (*(unsigned char *)(v63 + 80 * v65 + 12) != 108)
  {
    while (1)
    {
      LODWORD(v65) = *(_DWORD *)(v63 + 80 * v65 + 8) & 0x7FFFFFFF;
      if (v65 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned char *)(v63 + 80 * v65 + 12) == 108) {
        goto LABEL_90;
      }
    }
LABEL_85:
    LODWORD(v65) = 0x7FFFFFFF;
  }
LABEL_90:
  float v66 = (float)*(int *)(a1 + 8);
  float v67 = *(float *)(v63 + 80 * v65 + 48) / v66;
  uint64_t v69 = *(unsigned int *)(v64 + 4 * (0xE2D92833383B377ELL % v62));
  unsigned int v68 = 0x7FFFFFFF;
  if (v69 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v63 + 80 * v69 + 12) == 113)
    {
LABEL_94:
      unsigned int v68 = v69;
    }
    else
    {
      while (1)
      {
        LODWORD(v69) = *(_DWORD *)(v63 + 80 * v69 + 8) & 0x7FFFFFFF;
        unsigned int v68 = 0x7FFFFFFF;
        if (v69 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v63 + 80 * v69 + 12) == 113) {
          goto LABEL_94;
        }
      }
    }
  }
LABEL_95:
  re::DynamicString::appendf((re::DynamicString *)v11, "Skeletal Poses : %.0f, Mesh Offsets : %.0f\n", v67, (float)(*(float *)(v63 + 80 * v68 + 48) / v66));
  if (*(void *)a3)
  {
    unint64_t v70 = *(unsigned int *)(a3 + 24);
    uint64_t v72 = *(void *)(a3 + 8);
    uint64_t v71 = *(void *)(a3 + 16);
    unsigned int v73 = *(_DWORD *)(v72 + 4 * (0x1801EBC20183EB48 % v70));
    unsigned int v74 = 0x7FFFFFFF;
    unsigned int v75 = 0x7FFFFFFF;
    if (v73 != 0x7FFFFFFF)
    {
      unsigned int v75 = *(_DWORD *)(v72 + 4 * (0x1801EBC20183EB48 % v70));
      if (*(unsigned char *)(v71 + 80 * v73 + 12) != 112)
      {
        while (1)
        {
          unsigned int v75 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0x1801EBC20183EB48 % v70)) + 8) & 0x7FFFFFFF;
          if (v75 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v71 + 80 * v75 + 12) == 112) {
            goto LABEL_103;
          }
        }
        unsigned int v75 = 0x7FFFFFFF;
      }
    }
LABEL_103:
    float v76 = *(float *)(v71 + 80 * v75 + 48);
    int v77 = *(_DWORD *)(a1 + 8);
    uint64_t v78 = *(unsigned int *)(v72 + 4 * (0xCA4B25A23588FF96 % v70));
    if (v78 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v71 + 80 * v78 + 12) == 110)
      {
LABEL_107:
        unsigned int v74 = v78;
      }
      else
      {
        while (1)
        {
          LODWORD(v78) = *(_DWORD *)(v71 + 80 * v78 + 8) & 0x7FFFFFFF;
          unsigned int v74 = 0x7FFFFFFF;
          if (v78 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v71 + 80 * v78 + 12) == 110) {
            goto LABEL_107;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v71 = *(void *)(a3 + 16);
    float v76 = *(float *)(v71 + 0x27FFFFFFE0);
    int v77 = *(_DWORD *)(a1 + 8);
    unsigned int v74 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Mesh Smooths : %.0f, Mesh Deformations : %.0f\n", (float)(v76 / (float)v77), (float)(*(float *)(v71 + 80 * v74 + 48) / (float)v77));
  uint64_t v79 = v8 + (v9 << 6);
  *(void *)&double result = 0x2D00000009;
  *(void *)(v79 + 48) = 0x2D00000009;
  *(_DWORD *)(v79 + 56) = 2;
  return result;
}

double re::FrameAssetStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Pipeline Stats\n");
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 21)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 21) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "AssetManager Update Time (ms) : %.2f\n", v22 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Registration App Lifetime Times (sec)\n");
  if (*(void *)a3)
  {
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v25 = 0x7FFFFFFF;
    if (v24 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v23 + 80 * v24 + 12) == 61)
      {
LABEL_30:
        unsigned int v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          unsigned int v25 = 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v23 + 80 * v24 + 12) == 61) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a3 + 16);
    unsigned int v25 = 0x7FFFFFFF;
  }
  float v26 = *(float *)(v23 + 80 * v25 + 68);
  double v27 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v30 = NAN;
      goto LABEL_37;
    }
    LODWORD(v28) = info.numer;
    LODWORD(v29) = info.denom;
    double v27 = (double)v28 / (double)v29;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v27;
  }
  double v30 = v27 * (double)(unint64_t)v26;
LABEL_37:
  if (*(void *)a3)
  {
    uint64_t v31 = *(void *)(a3 + 16);
    uint64_t v32 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v33 = 0x7FFFFFFF;
    if (v32 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v31 + 80 * v32 + 12) == 61)
      {
LABEL_42:
        unsigned int v33 = v32;
      }
      else
      {
        while (1)
        {
          LODWORD(v32) = *(_DWORD *)(v31 + 80 * v32 + 8) & 0x7FFFFFFF;
          unsigned int v33 = 0x7FFFFFFF;
          if (v32 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v31 + 80 * v32 + 12) == 61) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v31 = *(void *)(a3 + 16);
    unsigned int v33 = 0x7FFFFFFF;
  }
  float v34 = *(float *)(v31 + 80 * v33 + 64);
  double v35 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v38 = NAN;
      goto LABEL_49;
    }
    LODWORD(v36) = info.numer;
    LODWORD(v37) = info.denom;
    double v35 = (double)v36 / (double)v37;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v35;
  }
  double v38 = v35 * (double)(unint64_t)v34;
LABEL_49:
  if (*(void *)a3)
  {
    uint64_t v39 = *(void *)(a3 + 16);
    uint64_t v40 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v41 = 0x7FFFFFFF;
    if (v40 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v39 + 80 * v40 + 12) == 61)
      {
LABEL_54:
        unsigned int v41 = v40;
      }
      else
      {
        while (1)
        {
          LODWORD(v40) = *(_DWORD *)(v39 + 80 * v40 + 8) & 0x7FFFFFFF;
          unsigned int v41 = 0x7FFFFFFF;
          if (v40 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v39 + 80 * v40 + 12) == 61) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v39 = *(void *)(a3 + 16);
    unsigned int v41 = 0x7FFFFFFF;
  }
  float v42 = *(float *)(v39 + 80 * v41 + 60);
  double v43 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v46 = NAN;
      goto LABEL_61;
    }
    LODWORD(v44) = info.numer;
    LODWORD(v45) = info.denom;
    double v43 = (double)v44 / (double)v45;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v43;
  }
  double v46 = v43 * (double)(unint64_t)v42;
LABEL_61:
  double v47 = v46 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v48 = *(void *)(a3 + 16);
    uint64_t v49 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v50 = 0x7FFFFFFF;
    if (v49 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v48 + 80 * v49 + 12) == 61)
      {
LABEL_66:
        unsigned int v50 = v49;
      }
      else
      {
        while (1)
        {
          LODWORD(v49) = *(_DWORD *)(v48 + 80 * v49 + 8) & 0x7FFFFFFF;
          unsigned int v50 = 0x7FFFFFFF;
          if (v49 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v48 + 80 * v49 + 12) == 61) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v48 = *(void *)(a3 + 16);
    unsigned int v50 = 0x7FFFFFFF;
  }
  float v51 = *(float *)(v48 + 80 * v50 + 76);
  double v52 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v53 = v47 / 1000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v56 = NAN;
      goto LABEL_73;
    }
    LODWORD(v54) = info.numer;
    LODWORD(v55) = info.denom;
    double v52 = (double)v54 / (double)v55;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v52;
  }
  double v56 = v52 * (double)(unint64_t)v51;
LABEL_73:
  re::DynamicString::appendf((re::DynamicString *)v11, "Total : %.2f, Max : %.2f, Min : %.2f, Mean : %.2f\n", v30 / 1000000.0 / 1000.0, v38 / 1000000.0 / 1000.0, v53, v56 / 1000000.0 / 1000.0);
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Load App Lifetime Times (sec)\n");
  if (*(void *)a3)
  {
    uint64_t v57 = *(void *)(a3 + 16);
    uint64_t v58 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    unsigned int v59 = 0x7FFFFFFF;
    if (v58 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v57 + 80 * v58 + 12) == 59)
      {
LABEL_78:
        unsigned int v59 = v58;
      }
      else
      {
        while (1)
        {
          LODWORD(v58) = *(_DWORD *)(v57 + 80 * v58 + 8) & 0x7FFFFFFF;
          unsigned int v59 = 0x7FFFFFFF;
          if (v58 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v57 + 80 * v58 + 12) == 59) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v57 = *(void *)(a3 + 16);
    unsigned int v59 = 0x7FFFFFFF;
  }
  float v60 = *(float *)(v57 + 80 * v59 + 48);
  double v61 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v64 = NAN;
      goto LABEL_85;
    }
    LODWORD(v62) = info.numer;
    LODWORD(v63) = info.denom;
    double v61 = (double)v62 / (double)v63;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v61;
  }
  double v64 = v61 * (double)(unint64_t)(float)(v60 / 1000.0);
LABEL_85:
  if (*(void *)a3)
  {
    uint64_t v65 = *(void *)(a3 + 16);
    uint64_t v66 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    unsigned int v67 = 0x7FFFFFFF;
    if (v66 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v65 + 80 * v66 + 12) == 59)
      {
LABEL_90:
        unsigned int v67 = v66;
      }
      else
      {
        while (1)
        {
          LODWORD(v66) = *(_DWORD *)(v65 + 80 * v66 + 8) & 0x7FFFFFFF;
          unsigned int v67 = 0x7FFFFFFF;
          if (v66 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v65 + 80 * v66 + 12) == 59) {
            goto LABEL_90;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v65 = *(void *)(a3 + 16);
    unsigned int v67 = 0x7FFFFFFF;
  }
  float v68 = *(float *)(v65 + 80 * v67 + 44);
  double v69 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v72 = NAN;
      goto LABEL_97;
    }
    LODWORD(v70) = info.numer;
    LODWORD(v71) = info.denom;
    double v69 = (double)v70 / (double)v71;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v69;
  }
  double v72 = v69 * (double)(unint64_t)(float)(v68 / 1000.0);
LABEL_97:
  if (*(void *)a3)
  {
    uint64_t v73 = *(void *)(a3 + 16);
    uint64_t v74 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    unsigned int v75 = 0x7FFFFFFF;
    if (v74 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v73 + 80 * v74 + 12) == 59)
      {
LABEL_102:
        unsigned int v75 = v74;
      }
      else
      {
        while (1)
        {
          LODWORD(v74) = *(_DWORD *)(v73 + 80 * v74 + 8) & 0x7FFFFFFF;
          unsigned int v75 = 0x7FFFFFFF;
          if (v74 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v73 + 80 * v74 + 12) == 59) {
            goto LABEL_102;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v73 = *(void *)(a3 + 16);
    unsigned int v75 = 0x7FFFFFFF;
  }
  float v76 = *(float *)(v73 + 80 * v75 + 40);
  double v77 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v80 = NAN;
      goto LABEL_109;
    }
    LODWORD(v78) = info.numer;
    LODWORD(v79) = info.denom;
    double v77 = (double)v78 / (double)v79;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v77;
  }
  double v80 = v77 * (double)(unint64_t)(float)(v76 / 1000.0);
LABEL_109:
  if (*(void *)a3)
  {
    uint64_t v81 = *(void *)(a3 + 16);
    uint64_t v82 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    unsigned int v83 = 0x7FFFFFFF;
    if (v82 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v81 + 80 * v82 + 12) == 59)
      {
LABEL_114:
        unsigned int v83 = v82;
      }
      else
      {
        while (1)
        {
          LODWORD(v82) = *(_DWORD *)(v81 + 80 * v82 + 8) & 0x7FFFFFFF;
          unsigned int v83 = 0x7FFFFFFF;
          if (v82 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v81 + 80 * v82 + 12) == 59) {
            goto LABEL_114;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v81 = *(void *)(a3 + 16);
    unsigned int v83 = 0x7FFFFFFF;
  }
  double v84 = v64 / 1000000.0;
  double v85 = v72 / 1000000.0;
  float v86 = *(float *)(v81 + 80 * v83 + 56);
  double v87 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v88 = v80 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v91 = NAN;
      goto LABEL_121;
    }
    LODWORD(v89) = info.numer;
    LODWORD(v90) = info.denom;
    double v87 = (double)v89 / (double)v90;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v87;
  }
  double v91 = v87 * (double)(unint64_t)(float)(v86 / 1000.0);
LABEL_121:
  re::DynamicString::appendf((re::DynamicString *)v11, "Total : %.2f, Max : %.2f, Min : %.2f, Mean : %.2f\n", v84, v85, v88, v91 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v92 = *(void *)(a3 + 16);
    uint64_t v93 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x99E7FE09B67A7978 % *(unsigned int *)(a3 + 24)));
    unsigned int v94 = 0x7FFFFFFF;
    if (v93 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v92 + 80 * v93 + 12) == 58)
      {
LABEL_126:
        unsigned int v94 = v93;
      }
      else
      {
        while (1)
        {
          LODWORD(v93) = *(_DWORD *)(v92 + 80 * v93 + 8) & 0x7FFFFFFF;
          unsigned int v94 = 0x7FFFFFFF;
          if (v93 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v92 + 80 * v93 + 12) == 58) {
            goto LABEL_126;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v92 = *(void *)(a3 + 16);
    unsigned int v94 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Total Assets : %.0f\n", (float)(*(float *)(v92 + 80 * v94 + 48) / (float)*(int *)(a1 + 8)));
  if (!*(void *)a3)
  {
    uint64_t v96 = *(void *)(a3 + 16);
    float v99 = (float)*(int *)(a1 + 8);
    float v100 = *(float *)(v96 + 0x27FFFFFFE0) / v99;
    unsigned int v101 = 0x7FFFFFFF;
    goto LABEL_142;
  }
  unint64_t v95 = *(unsigned int *)(a3 + 24);
  uint64_t v97 = *(void *)(a3 + 8);
  uint64_t v96 = *(void *)(a3 + 16);
  uint64_t v98 = *(unsigned int *)(v97 + 4 * (0x58EFD731A91FB004 % v95));
  if (v98 == 0x7FFFFFFF)
  {
    LODWORD(v98) = 0x7FFFFFFF;
LABEL_133:
    uint64_t v102 = v96 + 80 * v98;
    goto LABEL_137;
  }
  if (*(unsigned char *)(v96 + 80 * v98 + 12) == 56) {
    goto LABEL_133;
  }
  do
    LODWORD(v98) = *(_DWORD *)(v96 + 80 * v98 + 8) & 0x7FFFFFFF;
  while (v98 != 0x7FFFFFFF && *(unsigned char *)(v96 + 80 * v98 + 12) != 56);
  uint64_t v102 = v96 + 80 * v98;
LABEL_137:
  float v99 = (float)*(int *)(a1 + 8);
  float v100 = *(float *)(v102 + 48) / v99;
  uint64_t v103 = *(unsigned int *)(v97 + 4 * (0x9ABD6DF5738C0A9BLL % v95));
  unsigned int v101 = 0x7FFFFFFF;
  if (v103 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v96 + 80 * v103 + 12) == 55)
    {
LABEL_141:
      unsigned int v101 = v103;
    }
    else
    {
      while (1)
      {
        LODWORD(v103) = *(_DWORD *)(v96 + 80 * v103 + 8) & 0x7FFFFFFF;
        unsigned int v101 = 0x7FFFFFFF;
        if (v103 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v96 + 80 * v103 + 12) == 55) {
          goto LABEL_141;
        }
      }
    }
  }
LABEL_142:
  re::DynamicString::appendf((re::DynamicString *)v11, "Loaded : %.0f, Loading : %.0f\n", v100, (float)(*(float *)(v96 + 80 * v101 + 48) / v99));
  if (!*(void *)a3)
  {
    uint64_t v105 = *(void *)(a3 + 16);
    float v108 = (float)*(int *)(a1 + 8);
    float v109 = *(float *)(v105 + 0x27FFFFFFE0) / v108;
    unsigned int v110 = 0x7FFFFFFF;
    goto LABEL_156;
  }
  unint64_t v104 = *(unsigned int *)(a3 + 24);
  uint64_t v106 = *(void *)(a3 + 8);
  uint64_t v105 = *(void *)(a3 + 16);
  uint64_t v107 = *(unsigned int *)(v106 + 4 * (0x6231EAB2525BA011 % v104));
  if (v107 == 0x7FFFFFFF)
  {
    LODWORD(v107) = 0x7FFFFFFF;
LABEL_147:
    uint64_t v111 = v105 + 80 * v107;
    goto LABEL_151;
  }
  if (*(unsigned char *)(v105 + 80 * v107 + 12) == 57) {
    goto LABEL_147;
  }
  do
    LODWORD(v107) = *(_DWORD *)(v105 + 80 * v107 + 8) & 0x7FFFFFFF;
  while (v107 != 0x7FFFFFFF && *(unsigned char *)(v105 + 80 * v107 + 12) != 57);
  uint64_t v111 = v105 + 80 * v107;
LABEL_151:
  float v108 = (float)*(int *)(a1 + 8);
  float v109 = *(float *)(v111 + 48) / v108;
  uint64_t v112 = *(unsigned int *)(v106 + 4 * (0xF95D76A430C5BB5CLL % v104));
  unsigned int v110 = 0x7FFFFFFF;
  if (v112 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v105 + 80 * v112 + 12) == 54)
    {
LABEL_155:
      unsigned int v110 = v112;
    }
    else
    {
      while (1)
      {
        LODWORD(v112) = *(_DWORD *)(v105 + 80 * v112 + 8) & 0x7FFFFFFF;
        unsigned int v110 = 0x7FFFFFFF;
        if (v112 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v105 + 80 * v112 + 12) == 54) {
          goto LABEL_155;
        }
      }
    }
  }
LABEL_156:
  re::DynamicString::appendf((re::DynamicString *)v11, "Failed Loads: %.0f, Unloaded : %.0f\n", v109, (float)(*(float *)(v105 + 80 * v110 + 48) / v108));
  if (!*(void *)a3)
  {
    uint64_t v114 = *(void *)(a3 + 16);
    float v117 = (float)*(int *)(a1 + 8);
    float v118 = *(float *)(v114 + 0x27FFFFFFE0) / v117;
    unsigned int v119 = 0x7FFFFFFF;
    goto LABEL_168;
  }
  unint64_t v113 = *(unsigned int *)(a3 + 24);
  uint64_t v115 = *(void *)(a3 + 8);
  uint64_t v114 = *(void *)(a3 + 16);
  uint64_t v116 = *(unsigned int *)(v115 + 4 * (0x3CEE781815CE206BLL % v113));
  if (v116 == 0x7FFFFFFF) {
    goto LABEL_158;
  }
  if (*(unsigned char *)(v114 + 80 * v116 + 12) != 62)
  {
    while (1)
    {
      LODWORD(v116) = *(_DWORD *)(v114 + 80 * v116 + 8) & 0x7FFFFFFF;
      if (v116 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned char *)(v114 + 80 * v116 + 12) == 62) {
        goto LABEL_163;
      }
    }
LABEL_158:
    LODWORD(v116) = 0x7FFFFFFF;
  }
LABEL_163:
  float v117 = (float)*(int *)(a1 + 8);
  float v118 = *(float *)(v114 + 80 * v116 + 48) / v117;
  uint64_t v120 = *(unsigned int *)(v115 + 4 * (0xE1BAA47D01408015 % v113));
  unsigned int v119 = 0x7FFFFFFF;
  if (v120 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v114 + 80 * v120 + 12) == 63)
    {
LABEL_167:
      unsigned int v119 = v120;
    }
    else
    {
      while (1)
      {
        LODWORD(v120) = *(_DWORD *)(v114 + 80 * v120 + 8) & 0x7FFFFFFF;
        unsigned int v119 = 0x7FFFFFFF;
        if (v120 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v114 + 80 * v120 + 12) == 63) {
          goto LABEL_167;
        }
      }
    }
  }
LABEL_168:
  double v121 = v118;
  if (v136) {
    double v122 = v138;
  }
  else {
    double v122 = v137;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Mesh Info: %.0f mesh(es) @ %s\n", v121, v122);
  if (*(void *)&info && (v136 & 1) != 0) {
    (*(void (**)(void))(**(void **)&info + 40))();
  }
  if (!*(void *)a3)
  {
    uint64_t v124 = *(void *)(a3 + 16);
    float v127 = *(float *)(v124 + 0x27FFFFFFE0);
    int v128 = *(_DWORD *)(a1 + 8);
    unsigned int v129 = 0x7FFFFFFF;
    goto LABEL_186;
  }
  unint64_t v123 = *(unsigned int *)(a3 + 24);
  uint64_t v125 = *(void *)(a3 + 8);
  uint64_t v124 = *(void *)(a3 + 16);
  uint64_t v126 = *(unsigned int *)(v125 + 4 * (0x8AA449CE2D0CA1D3 % v123));
  if (v126 == 0x7FFFFFFF) {
    goto LABEL_176;
  }
  if (*(unsigned char *)(v124 + 80 * v126 + 12) != 64)
  {
    while (1)
    {
      LODWORD(v126) = *(_DWORD *)(v124 + 80 * v126 + 8) & 0x7FFFFFFF;
      if (v126 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned char *)(v124 + 80 * v126 + 12) == 64) {
        goto LABEL_181;
      }
    }
LABEL_176:
    LODWORD(v126) = 0x7FFFFFFF;
  }
LABEL_181:
  float v127 = *(float *)(v124 + 80 * v126 + 48);
  int v128 = *(_DWORD *)(a1 + 8);
  uint64_t v130 = *(unsigned int *)(v125 + 4 * (0x6B18769D9C324EABLL % v123));
  unsigned int v129 = 0x7FFFFFFF;
  if (v130 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v124 + 80 * v130 + 12) == 65)
    {
LABEL_185:
      unsigned int v129 = v130;
    }
    else
    {
      while (1)
      {
        LODWORD(v130) = *(_DWORD *)(v124 + 80 * v130 + 8) & 0x7FFFFFFF;
        unsigned int v129 = 0x7FFFFFFF;
        if (v130 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v124 + 80 * v130 + 12) == 65) {
          goto LABEL_185;
        }
      }
    }
  }
LABEL_186:
  double v131 = (float)(v127 / (float)v128);
  if (v136) {
    unint64_t v132 = v138;
  }
  else {
    unint64_t v132 = v137;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Texture Info: %.0f texture(s) @ %s\n", v131, v132);
  if (*(void *)&info && (v136 & 1) != 0) {
    (*(void (**)(void))(**(void **)&info + 40))();
  }
  uint64_t v133 = v8 + (v9 << 6);
  *(void *)&double result = 0x3C0000000BLL;
  *(void *)(v133 + 48) = 0x3C0000000BLL;
  *(_DWORD *)(v133 + 56) = 4;
  return result;
}

uint64_t anonymous namespace'::getFormattedBytes(_anonymous_namespace_ *this, float a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    float v3 = a2 * 0.00097656;
    if ((float)(a2 * 0.00097656) < 1.0) {
      break;
    }
    ++v2;
    a2 = a2 * 0.00097656;
    if (v2 == 5)
    {
      double v4 = v3;
      uint64_t v5 = "TB";
      return re::DynamicString::format((re::DynamicString *)"%.2f %s", this, *(void *)&v4, v5);
    }
  }
  double v4 = a2;
  uint64_t v5 = off_264BE8280[v2];
  return re::DynamicString::format((re::DynamicString *)"%.2f %s", this, *(void *)&v4, v5);
}

uint64_t re::FrameAudioStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Stats\n");
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 120)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 120) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio ECS Work (ms) : %.2f\n", v22 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a3 + 24)));
    unsigned int v25 = 0x7FFFFFFF;
    if (v24 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v23 + 80 * v24 + 12) == 22)
      {
LABEL_30:
        unsigned int v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          unsigned int v25 = 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v23 + 80 * v24 + 12) == 22) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a3 + 16);
    unsigned int v25 = 0x7FFFFFFF;
  }
  float v26 = *(float *)(v23 + 80 * v25 + 48);
  int v27 = *(_DWORD *)(a1 + 8);
  double v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    double v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v28;
  }
  double v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Pre/Post Frame Update (ms) : %.2f\n", v31 / 1000000.0);
  if (!*(void *)a3)
  {
    uint64_t v33 = *(void *)(a3 + 16);
    float v36 = *(float *)(v33 + 0x27FFFFFFE0);
    float v37 = (float)*(int *)(a1 + 8);
    float v38 = v36 / v37;
    unsigned int v39 = 0x7FFFFFFF;
    goto LABEL_57;
  }
  unint64_t v32 = *(unsigned int *)(a3 + 24);
  uint64_t v34 = *(void *)(a3 + 8);
  uint64_t v33 = *(void *)(a3 + 16);
  uint64_t v35 = *(unsigned int *)(v34 + 4 * (0x2427CEE8D2E4A800 % v32));
  if (v35 == 0x7FFFFFFF)
  {
    LODWORD(v35) = 0x7FFFFFFF;
  }
  else if (*(unsigned __int8 *)(v33 + 80 * v35 + 12) != 143)
  {
    do
      LODWORD(v35) = *(_DWORD *)(v33 + 80 * v35 + 8) & 0x7FFFFFFF;
    while (v35 != 0x7FFFFFFF && *(unsigned __int8 *)(v33 + 80 * v35 + 12) != 143);
    uint64_t v40 = v33 + 80 * v35;
    goto LABEL_46;
  }
  uint64_t v40 = v33 + 80 * v35;
LABEL_46:
  float v37 = (float)*(int *)(a1 + 8);
  float v38 = *(float *)(v40 + 48) / v37;
  unsigned int v41 = *(_DWORD *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32));
  unsigned int v39 = 0x7FFFFFFF;
  unsigned int v42 = 0x7FFFFFFF;
  if (v41 != 0x7FFFFFFF)
  {
    unsigned int v42 = *(_DWORD *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32));
    if (*(unsigned __int8 *)(v33 + 80 * v41 + 12) != 140)
    {
      while (1)
      {
        unsigned int v42 = *(_DWORD *)(v33 + 80 * *(unsigned int *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32)) + 8) & 0x7FFFFFFF;
        if (v42 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v33 + 80 * v42 + 12) == 140) {
          goto LABEL_52;
        }
      }
      unsigned int v42 = 0x7FFFFFFF;
    }
  }
LABEL_52:
  float v36 = *(float *)(v33 + 80 * v42 + 48);
  uint64_t v43 = *(unsigned int *)(v34 + 4 * (0xFB7C0C284AF128D0 % v32));
  if (v43 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v33 + 80 * v43 + 12) == 147)
    {
LABEL_56:
      unsigned int v39 = v43;
    }
    else
    {
      while (1)
      {
        LODWORD(v43) = *(_DWORD *)(v33 + 80 * v43 + 8) & 0x7FFFFFFF;
        unsigned int v39 = 0x7FFFFFFF;
        if (v43 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v33 + 80 * v43 + 12) == 147) {
          goto LABEL_56;
        }
      }
    }
  }
LABEL_57:
  re::DynamicString::appendf((re::DynamicString *)v11, "Players : %.0f, Listeners: %.0f, Timebases: %.0f\n", v38, (float)(v36 / v37), (float)(*(float *)(v33 + 80 * v39 + 48) / v37));
  if (!*(void *)a3)
  {
    uint64_t v45 = *(void *)(a3 + 16);
    float v48 = (float)*(int *)(a1 + 8);
    float v49 = *(float *)(v45 + 0x27FFFFFFE0) / v48;
    unsigned int v50 = 0x7FFFFFFF;
    goto LABEL_71;
  }
  unint64_t v44 = *(unsigned int *)(a3 + 24);
  uint64_t v46 = *(void *)(a3 + 8);
  uint64_t v45 = *(void *)(a3 + 16);
  uint64_t v47 = *(unsigned int *)(v46 + 4 * (0xD8013BA0973C70B4 % v44));
  if (v47 == 0x7FFFFFFF)
  {
    LODWORD(v47) = 0x7FFFFFFF;
LABEL_62:
    uint64_t v51 = v45 + 80 * v47;
    goto LABEL_66;
  }
  if (*(unsigned __int8 *)(v45 + 80 * v47 + 12) == 145) {
    goto LABEL_62;
  }
  do
    LODWORD(v47) = *(_DWORD *)(v45 + 80 * v47 + 8) & 0x7FFFFFFF;
  while (v47 != 0x7FFFFFFF && *(unsigned __int8 *)(v45 + 80 * v47 + 12) != 145);
  uint64_t v51 = v45 + 80 * v47;
LABEL_66:
  float v48 = (float)*(int *)(a1 + 8);
  float v49 = *(float *)(v51 + 48) / v48;
  uint64_t v52 = *(unsigned int *)(v46 + 4 * (0xC1726A6640A7C667 % v44));
  unsigned int v50 = 0x7FFFFFFF;
  if (v52 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v45 + 80 * v52 + 12) == 141)
    {
LABEL_70:
      unsigned int v50 = v52;
    }
    else
    {
      while (1)
      {
        LODWORD(v52) = *(_DWORD *)(v45 + 80 * v52 + 8) & 0x7FFFFFFF;
        unsigned int v50 = 0x7FFFFFFF;
        if (v52 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v45 + 80 * v52 + 12) == 141) {
          goto LABEL_70;
        }
      }
    }
  }
LABEL_71:
  re::DynamicString::appendf((re::DynamicString *)v11, "Voices : %.0f, Generators : %.0f\n", v49, (float)(*(float *)(v45 + 80 * v50 + 48) / v48));
  if (!*(void *)a3)
  {
    uint64_t v54 = *(void *)(a3 + 16);
    float v57 = (float)*(int *)(a1 + 8);
    float v58 = *(float *)(v54 + 0x27FFFFFFE0) / v57;
    unsigned int v59 = 0x7FFFFFFF;
    goto LABEL_83;
  }
  unint64_t v53 = *(unsigned int *)(a3 + 24);
  uint64_t v55 = *(void *)(a3 + 8);
  uint64_t v54 = *(void *)(a3 + 16);
  uint64_t v56 = *(unsigned int *)(v55 + 4 * (0x97DCC30D0B60AE52 % v53));
  if (v56 == 0x7FFFFFFF) {
    goto LABEL_73;
  }
  if (*(unsigned __int8 *)(v54 + 80 * v56 + 12) != 142)
  {
    while (1)
    {
      LODWORD(v56) = *(_DWORD *)(v54 + 80 * v56 + 8) & 0x7FFFFFFF;
      if (v56 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned __int8 *)(v54 + 80 * v56 + 12) == 142) {
        goto LABEL_78;
      }
    }
LABEL_73:
    LODWORD(v56) = 0x7FFFFFFF;
  }
LABEL_78:
  float v57 = (float)*(int *)(a1 + 8);
  float v58 = *(float *)(v54 + 80 * v56 + 48) / v57;
  uint64_t v60 = *(unsigned int *)(v55 + 4 * (0x4A1AC66DC58909F5 % v53));
  unsigned int v59 = 0x7FFFFFFF;
  if (v60 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v54 + 80 * v60 + 12) == 146)
    {
LABEL_82:
      unsigned int v59 = v60;
    }
    else
    {
      while (1)
      {
        LODWORD(v60) = *(_DWORD *)(v54 + 80 * v60 + 8) & 0x7FFFFFFF;
        unsigned int v59 = 0x7FFFFFFF;
        if (v60 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v54 + 80 * v60 + 12) == 146) {
          goto LABEL_82;
        }
      }
    }
  }
LABEL_83:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animations: %.0f, Acoustic Meshes : %.0f\n", v58, (float)(*(float *)(v54 + 80 * v59 + 48) / v57));
  if (*(void *)a3)
  {
    uint64_t v61 = *(void *)(a3 + 16);
    uint64_t v62 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x30C19CE02862B3C8uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v63 = 0x7FFFFFFF;
    if (v62 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v61 + 80 * v62 + 12) == 144)
      {
LABEL_88:
        unsigned int v63 = v62;
      }
      else
      {
        while (1)
        {
          LODWORD(v62) = *(_DWORD *)(v61 + 80 * v62 + 8) & 0x7FFFFFFF;
          unsigned int v63 = 0x7FFFFFFF;
          if (v62 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v61 + 80 * v62 + 12) == 144) {
            goto LABEL_88;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v61 = *(void *)(a3 + 16);
    unsigned int v63 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Files: <T.B.D> %.0f\n", (float)(*(float *)(v61 + 80 * v63 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    uint64_t v64 = *(void *)(a3 + 16);
    uint64_t v65 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x83D7EAD9103E6A46 % *(unsigned int *)(a3 + 24)));
    unsigned int v66 = 0x7FFFFFFF;
    if (v65 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v64 + 80 * v65 + 12) == 148)
      {
LABEL_95:
        unsigned int v66 = v65;
      }
      else
      {
        while (1)
        {
          LODWORD(v65) = *(_DWORD *)(v64 + 80 * v65 + 8) & 0x7FFFFFFF;
          unsigned int v66 = 0x7FFFFFFF;
          if (v65 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v64 + 80 * v65 + 12) == 148) {
            goto LABEL_95;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v64 = *(void *)(a3 + 16);
    unsigned int v66 = 0x7FFFFFFF;
  }
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v11, "AR Spatial Scene Classification %.0f\n", (float)(*(float *)(v64 + 80 * v66 + 48) / (float)*(int *)(a1 + 8)));
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 8;
  return result;
}

uint64_t re::FrameECSStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 13)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 13) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v131 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v131 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  if (*(void *)a3)
  {
    uint64_t v22 = *(void *)(a3 + 16);
    uint64_t v23 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v24 = 0x7FFFFFFF;
    if (v23 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v22 + 80 * v23 + 12) == 14)
      {
LABEL_30:
        unsigned int v24 = v23;
      }
      else
      {
        while (1)
        {
          LODWORD(v23) = *(_DWORD *)(v22 + 80 * v23 + 8) & 0x7FFFFFFF;
          unsigned int v24 = 0x7FFFFFFF;
          if (v23 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v22 + 80 * v23 + 12) == 14) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a3 + 16);
    unsigned int v24 = 0x7FFFFFFF;
  }
  float v25 = *(float *)(v22 + 80 * v24 + 48);
  int v26 = *(_DWORD *)(a1 + 8);
  double v27 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v30 = NAN;
      goto LABEL_37;
    }
    LODWORD(v28) = info.numer;
    LODWORD(v29) = info.denom;
    double v27 = (double)v28 / (double)v29;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v27;
  }
  double v30 = v27 * (double)(unint64_t)(float)(v25 / (float)v26);
LABEL_37:
  if (*(void *)a3)
  {
    uint64_t v31 = *(void *)(a3 + 16);
    uint64_t v32 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v33 = 0x7FFFFFFF;
    if (v32 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v31 + 80 * v32 + 12) == 15)
      {
LABEL_42:
        unsigned int v33 = v32;
      }
      else
      {
        while (1)
        {
          LODWORD(v32) = *(_DWORD *)(v31 + 80 * v32 + 8) & 0x7FFFFFFF;
          unsigned int v33 = 0x7FFFFFFF;
          if (v32 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v31 + 80 * v32 + 12) == 15) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v31 = *(void *)(a3 + 16);
    unsigned int v33 = 0x7FFFFFFF;
  }
  float v34 = *(float *)(v31 + 80 * v33 + 48);
  int v35 = *(_DWORD *)(a1 + 8);
  double v36 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v133 = NAN;
      goto LABEL_49;
    }
    LODWORD(v37) = info.numer;
    LODWORD(v38) = info.denom;
    double v36 = (double)v37 / (double)v38;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v36;
  }
  double v133 = v36 * (double)(unint64_t)(float)(v34 / (float)v35);
LABEL_49:
  if (*(void *)a3)
  {
    uint64_t v39 = *(void *)(a3 + 16);
    uint64_t v40 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xA09D66D4686AD125 % *(unsigned int *)(a3 + 24)));
    unsigned int v41 = 0x7FFFFFFF;
    if (v40 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v39 + 80 * v40 + 12) == 127)
      {
LABEL_54:
        unsigned int v41 = v40;
      }
      else
      {
        while (1)
        {
          LODWORD(v40) = *(_DWORD *)(v39 + 80 * v40 + 8) & 0x7FFFFFFF;
          unsigned int v41 = 0x7FFFFFFF;
          if (v40 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v39 + 80 * v40 + 12) == 127) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v39 = *(void *)(a3 + 16);
    unsigned int v41 = 0x7FFFFFFF;
  }
  float v42 = *(float *)(v39 + 80 * v41 + 48);
  int v43 = *(_DWORD *)(a1 + 8);
  double v44 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v129 = NAN;
      goto LABEL_61;
    }
    LODWORD(v45) = info.numer;
    LODWORD(v46) = info.denom;
    double v44 = (double)v45 / (double)v46;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v44;
  }
  double v129 = v44 * (double)(unint64_t)(float)(v42 / (float)v43);
LABEL_61:
  if (*(void *)a3)
  {
    uint64_t v47 = *(void *)(a3 + 16);
    uint64_t v48 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v49 = 0x7FFFFFFF;
    if (v48 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v47 + 80 * v48 + 12) == 120)
      {
LABEL_66:
        unsigned int v49 = v48;
      }
      else
      {
        while (1)
        {
          LODWORD(v48) = *(_DWORD *)(v47 + 80 * v48 + 8) & 0x7FFFFFFF;
          unsigned int v49 = 0x7FFFFFFF;
          if (v48 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v47 + 80 * v48 + 12) == 120) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v47 = *(void *)(a3 + 16);
    unsigned int v49 = 0x7FFFFFFF;
  }
  float v50 = *(float *)(v47 + 80 * v49 + 48);
  int v51 = *(_DWORD *)(a1 + 8);
  double v52 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v128 = NAN;
      goto LABEL_73;
    }
    LODWORD(v53) = info.numer;
    LODWORD(v54) = info.denom;
    double v52 = (double)v53 / (double)v54;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v52;
  }
  double v128 = v52 * (double)(unint64_t)(float)(v50 / (float)v51);
LABEL_73:
  if (*(void *)a3)
  {
    uint64_t v55 = *(void *)(a3 + 16);
    uint64_t v56 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v57 = 0x7FFFFFFF;
    if (v56 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v55 + 80 * v56 + 12) == 121)
      {
LABEL_78:
        unsigned int v57 = v56;
      }
      else
      {
        while (1)
        {
          LODWORD(v56) = *(_DWORD *)(v55 + 80 * v56 + 8) & 0x7FFFFFFF;
          unsigned int v57 = 0x7FFFFFFF;
          if (v56 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v55 + 80 * v56 + 12) == 121) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v55 = *(void *)(a3 + 16);
    unsigned int v57 = 0x7FFFFFFF;
  }
  float v58 = *(float *)(v55 + 80 * v57 + 48);
  int v59 = *(_DWORD *)(a1 + 8);
  double v60 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v63 = NAN;
      goto LABEL_85;
    }
    LODWORD(v61) = info.numer;
    LODWORD(v62) = info.denom;
    double v60 = (double)v61 / (double)v62;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v60;
  }
  double v63 = v60 * (double)(unint64_t)(float)(v58 / (float)v59);
LABEL_85:
  if (*(void *)a3)
  {
    uint64_t v64 = *(void *)(a3 + 16);
    uint64_t v65 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    unsigned int v66 = 0x7FFFFFFF;
    if (v65 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v64 + 80 * v65 + 12) == 123)
      {
LABEL_90:
        unsigned int v66 = v65;
      }
      else
      {
        while (1)
        {
          LODWORD(v65) = *(_DWORD *)(v64 + 80 * v65 + 8) & 0x7FFFFFFF;
          unsigned int v66 = 0x7FFFFFFF;
          if (v65 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v64 + 80 * v65 + 12) == 123) {
            goto LABEL_90;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v64 = *(void *)(a3 + 16);
    unsigned int v66 = 0x7FFFFFFF;
  }
  float v67 = *(float *)(v64 + 80 * v66 + 48);
  int v68 = *(_DWORD *)(a1 + 8);
  double v69 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v72 = NAN;
      goto LABEL_97;
    }
    LODWORD(v70) = info.numer;
    LODWORD(v71) = info.denom;
    double v69 = (double)v70 / (double)v71;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v69;
  }
  double v72 = v69 * (double)(unint64_t)(float)(v67 / (float)v68);
LABEL_97:
  if (*(void *)a3)
  {
    uint64_t v73 = *(void *)(a3 + 16);
    uint64_t v74 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v75 = 0x7FFFFFFF;
    if (v74 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v73 + 80 * v74 + 12) == 124)
      {
LABEL_102:
        unsigned int v75 = v74;
      }
      else
      {
        while (1)
        {
          LODWORD(v74) = *(_DWORD *)(v73 + 80 * v74 + 8) & 0x7FFFFFFF;
          unsigned int v75 = 0x7FFFFFFF;
          if (v74 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v73 + 80 * v74 + 12) == 124) {
            goto LABEL_102;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v73 = *(void *)(a3 + 16);
    unsigned int v75 = 0x7FFFFFFF;
  }
  float v76 = *(float *)(v73 + 80 * v75 + 48);
  int v77 = *(_DWORD *)(a1 + 8);
  double v78 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v81 = NAN;
      goto LABEL_109;
    }
    LODWORD(v79) = info.numer;
    LODWORD(v80) = info.denom;
    double v78 = (double)v79 / (double)v80;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v78;
  }
  double v81 = v78 * (double)(unint64_t)(float)(v76 / (float)v77);
LABEL_109:
  if (*(void *)a3)
  {
    uint64_t v82 = *(void *)(a3 + 16);
    uint64_t v83 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v84 = 0x7FFFFFFF;
    if (v83 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v82 + 80 * v83 + 12) == 122)
      {
LABEL_114:
        unsigned int v84 = v83;
      }
      else
      {
        while (1)
        {
          LODWORD(v83) = *(_DWORD *)(v82 + 80 * v83 + 8) & 0x7FFFFFFF;
          unsigned int v84 = 0x7FFFFFFF;
          if (v83 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v82 + 80 * v83 + 12) == 122) {
            goto LABEL_114;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v82 = *(void *)(a3 + 16);
    unsigned int v84 = 0x7FFFFFFF;
  }
  float v85 = *(float *)(v82 + 80 * v84 + 48);
  int v86 = *(_DWORD *)(a1 + 8);
  double v87 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v90 = NAN;
      goto LABEL_121;
    }
    LODWORD(v88) = info.numer;
    LODWORD(v89) = info.denom;
    double v87 = (double)v88 / (double)v89;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v87;
  }
  double v90 = v87 * (double)(unint64_t)(float)(v85 / (float)v86);
LABEL_121:
  if (*(void *)a3)
  {
    uint64_t v91 = *(void *)(a3 + 16);
    uint64_t v92 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v93 = 0x7FFFFFFF;
    if (v92 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v91 + 80 * v92 + 12) == 125)
      {
LABEL_126:
        unsigned int v93 = v92;
      }
      else
      {
        while (1)
        {
          LODWORD(v92) = *(_DWORD *)(v91 + 80 * v92 + 8) & 0x7FFFFFFF;
          unsigned int v93 = 0x7FFFFFFF;
          if (v92 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v91 + 80 * v92 + 12) == 125) {
            goto LABEL_126;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v91 = *(void *)(a3 + 16);
    unsigned int v93 = 0x7FFFFFFF;
  }
  float v94 = *(float *)(v91 + 80 * v93 + 48);
  int v95 = *(_DWORD *)(a1 + 8);
  double v96 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v99 = NAN;
      goto LABEL_133;
    }
    LODWORD(v97) = info.numer;
    LODWORD(v98) = info.denom;
    double v96 = (double)v97 / (double)v98;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v96;
  }
  double v99 = v96 * (double)(unint64_t)(float)(v94 / (float)v95);
LABEL_133:
  if (*(void *)a3)
  {
    uint64_t v100 = *(void *)(a3 + 16);
    uint64_t v101 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x584592B4271786AAuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v102 = 0x7FFFFFFF;
    if (v101 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v100 + 80 * v101 + 12) == 126)
      {
LABEL_138:
        unsigned int v102 = v101;
      }
      else
      {
        while (1)
        {
          LODWORD(v101) = *(_DWORD *)(v100 + 80 * v101 + 8) & 0x7FFFFFFF;
          unsigned int v102 = 0x7FFFFFFF;
          if (v101 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v100 + 80 * v101 + 12) == 126) {
            goto LABEL_138;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v100 = *(void *)(a3 + 16);
    unsigned int v102 = 0x7FFFFFFF;
  }
  float v103 = *(float *)(v100 + 80 * v102 + 48);
  int v104 = *(_DWORD *)(a1 + 8);
  double v105 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v108 = NAN;
      goto LABEL_145;
    }
    LODWORD(v106) = info.numer;
    LODWORD(v107) = info.denom;
    double v105 = (double)v106 / (double)v107;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v105;
  }
  double v108 = v105 * (double)(unint64_t)(float)(v103 / (float)v104);
LABEL_145:
  double v109 = v30;
  double v110 = v133;
  double v111 = v129;
  if (*(void *)a3)
  {
    uint64_t v112 = *(void *)(a3 + 16);
    uint64_t v113 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x17B1332CD96C043DuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v114 = 0x7FFFFFFF;
    if (v113 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v112 + 80 * v113 + 12) == 118)
      {
LABEL_150:
        unsigned int v114 = v113;
      }
      else
      {
        while (1)
        {
          LODWORD(v113) = *(_DWORD *)(v112 + 80 * v113 + 8) & 0x7FFFFFFF;
          unsigned int v114 = 0x7FFFFFFF;
          if (v113 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v112 + 80 * v113 + 12) == 118) {
            goto LABEL_150;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v112 = *(void *)(a3 + 16);
    unsigned int v114 = 0x7FFFFFFF;
  }
  float v115 = v108 / 1000000.0;
  float v130 = v115;
  float v116 = v99 / 1000000.0;
  float v117 = v90 / 1000000.0;
  float v118 = v72 / 1000000.0;
  float v119 = v81 / 1000000.0 + v118;
  float v120 = v63 / 1000000.0;
  float v121 = v128 / 1000000.0;
  float v122 = v111 / 1000000.0;
  float v134 = v122;
  float v123 = v110 / 1000000.0;
  float v124 = v109 / 1000000.0;
  float v125 = v131 / 1000000.0;
  float v132 = (float)((float)((float)((float)((float)((float)((float)((float)(v125 + v124) + v123) - v122) - v121) - v120)
                               - v119)
                       - v117)
               - v116)
       - v115;
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Stats - Total Entities : %.0f\n", (float)(*(float *)(v112 + 80 * v114 + 48) / (float)*(int *)(a1 + 8)));
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Phases CPU Frame Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "Prepare: %.2f\n", v125);
  re::DynamicString::appendf((re::DynamicString *)v11, "Simulate: %.2f   Commit: %.2f\n", v124, v123);
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Frame Times per Module (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "Rendering : %.2f    Physics : %.2f\n", v117, v120);
  re::DynamicString::appendf((re::DynamicString *)v11, "Network : %.2f    Animation : %.2f\n", v119, v116);
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio : %.2f    Custom Systems : %.2f\n", v121, v130);
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v11, "User Callback : %.2f    Others : %.2f\n", v134, v132);
  uint64_t v127 = v8 + (v9 << 6);
  *(_DWORD *)(v127 + 48) = 10;
  *(_DWORD *)(v127 + 56) = 16;
  return result;
}

uint64_t re::FrameMeshStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Scene Mesh Stats\n");
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 34)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 34) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  uint64_t v17 = *(void *)(a3 + 16);
  float v18 = (float)*(int *)(a1 + 8);
  double v19 = (float)(*(float *)(v17 + 80 * v14 + 48) / v18);
  unsigned int v20 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v21 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)));
    if (v21 != 0x7FFFFFFF)
    {
      unsigned int v20 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v17 + 80 * v21 + 12) != 35)
      {
        while (1)
        {
          unsigned int v20 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v20 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v17 + 80 * v20 + 12) == 35) {
            goto LABEL_27;
          }
        }
        unsigned int v20 = 0x7FFFFFFF;
      }
    }
  }
LABEL_27:
  re::DynamicString::appendf((re::DynamicString *)v11, "Meshes : %.0f    Draw Calls : %.0f\n", v19, (float)(*(float *)(v17 + 80 * v20 + 48) / v18));
  if (*(void *)a3)
  {
    uint64_t v22 = *(void *)(a3 + 16);
    uint64_t v23 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFF96B931ED5510E2 % *(unsigned int *)(a3 + 24)));
    unsigned int v24 = 0x7FFFFFFF;
    if (v23 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v22 + 80 * v23 + 12) == 36)
      {
LABEL_32:
        unsigned int v24 = v23;
      }
      else
      {
        while (1)
        {
          LODWORD(v23) = *(_DWORD *)(v22 + 80 * v23 + 8) & 0x7FFFFFFF;
          unsigned int v24 = 0x7FFFFFFF;
          if (v23 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v22 + 80 * v23 + 12) == 36) {
            goto LABEL_32;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a3 + 16);
    unsigned int v24 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Triangles Submitted: %.0f\n", (float)(*(float *)(v22 + 80 * v24 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    uint64_t v25 = *(void *)(a3 + 16);
    uint64_t v26 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x499EF488EF760E18uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v27 = 0x7FFFFFFF;
    if (v26 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v25 + 80 * v26 + 12) == 37)
      {
LABEL_39:
        unsigned int v27 = v26;
      }
      else
      {
        while (1)
        {
          LODWORD(v26) = *(_DWORD *)(v25 + 80 * v26 + 8) & 0x7FFFFFFF;
          unsigned int v27 = 0x7FFFFFFF;
          if (v26 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v25 + 80 * v26 + 12) == 37) {
            goto LABEL_39;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v25 = *(void *)(a3 + 16);
    unsigned int v27 = 0x7FFFFFFF;
  }
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v11, "Vertices Submitted: %.0f\n", (float)(*(float *)(v25 + 80 * v27 + 48) / (float)*(int *)(a1 + 8)));
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 32;
  return result;
}

double re::FrameNetworkStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::append((re::DynamicString *)v11, "Frame Network Stats\n", 0x14uLL);
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 48)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 48) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  re::DynamicString::appendf((re::DynamicString *)v11, "Network Components : %.0f\n", (float)(*(float *)(*(void *)(a3 + 16) + 80 * v14 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    uint64_t v17 = *(void *)(a3 + 16);
    uint64_t v18 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a3 + 24)));
    unsigned int v19 = 0x7FFFFFFF;
    if (v18 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v17 + 80 * v18 + 12) == 16)
      {
LABEL_25:
        unsigned int v19 = v18;
      }
      else
      {
        while (1)
        {
          LODWORD(v18) = *(_DWORD *)(v17 + 80 * v18 + 8) & 0x7FFFFFFF;
          unsigned int v19 = 0x7FFFFFFF;
          if (v18 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v17 + 80 * v18 + 12) == 16) {
            goto LABEL_25;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v17 = *(void *)(a3 + 16);
    unsigned int v19 = 0x7FFFFFFF;
  }
  float v20 = *(float *)(v17 + 80 * v19 + 48);
  int v21 = *(_DWORD *)(a1 + 8);
  double v22 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v25 = NAN;
      goto LABEL_32;
    }
    LODWORD(v23) = info.numer;
    LODWORD(v24) = info.denom;
    double v22 = (double)v23 / (double)v24;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v22;
  }
  double v25 = v22 * (double)(unint64_t)(float)(v20 / (float)v21);
LABEL_32:
  if (*(void *)a3)
  {
    uint64_t v26 = *(void *)(a3 + 16);
    uint64_t v27 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v28 = 0x7FFFFFFF;
    if (v27 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v26 + 80 * v27 + 12) == 17)
      {
LABEL_37:
        unsigned int v28 = v27;
      }
      else
      {
        while (1)
        {
          LODWORD(v27) = *(_DWORD *)(v26 + 80 * v27 + 8) & 0x7FFFFFFF;
          unsigned int v28 = 0x7FFFFFFF;
          if (v27 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v26 + 80 * v27 + 12) == 17) {
            goto LABEL_37;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v26 = *(void *)(a3 + 16);
    unsigned int v28 = 0x7FFFFFFF;
  }
  float v29 = *(float *)(v26 + 80 * v28 + 48);
  int v30 = *(_DWORD *)(a1 + 8);
  double v31 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v32 = v25 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v35 = NAN;
      goto LABEL_44;
    }
    LODWORD(v33) = info.numer;
    LODWORD(v34) = info.denom;
    double v31 = (double)v33 / (double)v34;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v31;
  }
  double v35 = v31 * (double)(unint64_t)(float)(v29 / (float)v30);
LABEL_44:
  re::DynamicString::appendf((re::DynamicString *)v11, "PreFrame (ms): %.2f    PostFrame (ms): %.2f\n", v32, v35 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v36 = *(void *)(a3 + 16);
    uint64_t v37 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    unsigned int v38 = 0x7FFFFFFF;
    if (v37 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v36 + 80 * v37 + 12) == 123)
      {
LABEL_49:
        unsigned int v38 = v37;
      }
      else
      {
        while (1)
        {
          LODWORD(v37) = *(_DWORD *)(v36 + 80 * v37 + 8) & 0x7FFFFFFF;
          unsigned int v38 = 0x7FFFFFFF;
          if (v37 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v36 + 80 * v37 + 12) == 123) {
            goto LABEL_49;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v36 = *(void *)(a3 + 16);
    unsigned int v38 = 0x7FFFFFFF;
  }
  float v39 = *(float *)(v36 + 80 * v38 + 48);
  int v40 = *(_DWORD *)(a1 + 8);
  double v41 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v44 = NAN;
      goto LABEL_56;
    }
    LODWORD(v42) = info.numer;
    LODWORD(v43) = info.denom;
    double v41 = (double)v42 / (double)v43;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v41;
  }
  double v44 = v41 * (double)(unint64_t)(float)(v39 / (float)v40);
LABEL_56:
  if (*(void *)a3)
  {
    uint64_t v45 = *(void *)(a3 + 16);
    uint64_t v46 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v47 = 0x7FFFFFFF;
    if (v46 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v45 + 80 * v46 + 12) == 124)
      {
LABEL_61:
        unsigned int v47 = v46;
      }
      else
      {
        while (1)
        {
          LODWORD(v46) = *(_DWORD *)(v45 + 80 * v46 + 8) & 0x7FFFFFFF;
          unsigned int v47 = 0x7FFFFFFF;
          if (v46 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v45 + 80 * v46 + 12) == 124) {
            goto LABEL_61;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v45 = *(void *)(a3 + 16);
    unsigned int v47 = 0x7FFFFFFF;
  }
  float v48 = *(float *)(v45 + 80 * v47 + 48);
  int v49 = *(_DWORD *)(a1 + 8);
  double v50 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v51 = v44 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v54 = NAN;
      goto LABEL_68;
    }
    LODWORD(v52) = info.numer;
    LODWORD(v53) = info.denom;
    double v50 = (double)v52 / (double)v53;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v50;
  }
  double v54 = v50 * (double)(unint64_t)(float)(v48 / (float)v49);
LABEL_68:
  re::DynamicString::appendf((re::DynamicString *)v11, "SendSystem (ms): %.2f    ReceiveSystem (ms): %.2f\n", v51, v54 / 1000000.0);
  re::DynamicString::append((re::DynamicString *)v11, "Network Session Stats\n", 0x16uLL);
  re::DynamicString::append((re::DynamicString *)v11, "Sent/Received\n", 0xEuLL);
  if (*(void *)a3)
  {
    uint64_t v55 = *(void *)(a3 + 16);
    uint64_t v56 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xB74FD707F0B39325 % *(unsigned int *)(a3 + 24)));
    unsigned int v57 = 0x7FFFFFFF;
    if (v56 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v55 + 80 * v56 + 12) == 40)
      {
LABEL_73:
        unsigned int v57 = v56;
      }
      else
      {
        while (1)
        {
          LODWORD(v56) = *(_DWORD *)(v55 + 80 * v56 + 8) & 0x7FFFFFFF;
          unsigned int v57 = 0x7FFFFFFF;
          if (v56 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v55 + 80 * v56 + 12) == 40) {
            goto LABEL_73;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v55 = *(void *)(a3 + 16);
    unsigned int v57 = 0x7FFFFFFF;
  }
  float v58 = (float)*(int *)(a1 + 8);
  double v59 = (float)(*(float *)(v55 + 80 * v57 + 48) / v58) * 0.0009765625;
  unsigned int v60 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v61 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)));
    if (v61 != 0x7FFFFFFF)
    {
      unsigned int v60 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v55 + 80 * v61 + 12) != 41)
      {
        while (1)
        {
          unsigned int v60 = *(_DWORD *)(v55
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v60 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v55 + 80 * v60 + 12) == 41) {
            goto LABEL_82;
          }
        }
        unsigned int v60 = 0x7FFFFFFF;
      }
    }
  }
LABEL_82:
  re::DynamicString::appendf((re::DynamicString *)v11, "Data [KB]: %.2f/%.2f\n", v59, (float)(*(float *)(v55 + 80 * v60 + 48) / v58) * 0.0009765625);
  if (!*(void *)a3)
  {
    uint64_t v63 = *(void *)(a3 + 16);
    float v66 = (float)*(int *)(a1 + 8);
    float v67 = *(float *)(v63 + 0x27FFFFFFE0) / v66;
    unsigned int v68 = 0x7FFFFFFF;
    goto LABEL_96;
  }
  unint64_t v62 = *(unsigned int *)(a3 + 24);
  uint64_t v64 = *(void *)(a3 + 8);
  uint64_t v63 = *(void *)(a3 + 16);
  uint64_t v65 = *(unsigned int *)(v64 + 4 * (0xA759EA27D4727622 % v62));
  if (v65 == 0x7FFFFFFF)
  {
    LODWORD(v65) = 0x7FFFFFFF;
LABEL_87:
    uint64_t v69 = v63 + 80 * v65;
    goto LABEL_91;
  }
  if (*(unsigned char *)(v63 + 80 * v65 + 12) == 42) {
    goto LABEL_87;
  }
  do
    LODWORD(v65) = *(_DWORD *)(v63 + 80 * v65 + 8) & 0x7FFFFFFF;
  while (v65 != 0x7FFFFFFF && *(unsigned char *)(v63 + 80 * v65 + 12) != 42);
  uint64_t v69 = v63 + 80 * v65;
LABEL_91:
  float v66 = (float)*(int *)(a1 + 8);
  float v67 = *(float *)(v69 + 48) / v66;
  uint64_t v70 = *(unsigned int *)(v64 + 4 * (0x4F0A61D9C798D8CALL % v62));
  unsigned int v68 = 0x7FFFFFFF;
  if (v70 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v63 + 80 * v70 + 12) == 43)
    {
LABEL_95:
      unsigned int v68 = v70;
    }
    else
    {
      while (1)
      {
        LODWORD(v70) = *(_DWORD *)(v63 + 80 * v70 + 8) & 0x7FFFFFFF;
        unsigned int v68 = 0x7FFFFFFF;
        if (v70 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v63 + 80 * v70 + 12) == 43) {
          goto LABEL_95;
        }
      }
    }
  }
LABEL_96:
  re::DynamicString::appendf((re::DynamicString *)v11, "Packets: %.0f/%.0f\n", v67, (float)(*(float *)(v63 + 80 * v68 + 48) / v66));
  if (!*(void *)a3)
  {
    uint64_t v72 = *(void *)(a3 + 16);
    float v75 = (float)*(int *)(a1 + 8);
    float v76 = *(float *)(v72 + 0x27FFFFFFE0) / v75;
    unsigned int v77 = 0x7FFFFFFF;
    goto LABEL_110;
  }
  unint64_t v71 = *(unsigned int *)(a3 + 24);
  uint64_t v73 = *(void *)(a3 + 8);
  uint64_t v72 = *(void *)(a3 + 16);
  uint64_t v74 = *(unsigned int *)(v73 + 4 * (0xFB2BF4996809BAF7 % v71));
  if (v74 == 0x7FFFFFFF)
  {
    LODWORD(v74) = 0x7FFFFFFF;
LABEL_101:
    uint64_t v78 = v72 + 80 * v74;
    goto LABEL_105;
  }
  if (*(unsigned char *)(v72 + 80 * v74 + 12) == 44) {
    goto LABEL_101;
  }
  do
    LODWORD(v74) = *(_DWORD *)(v72 + 80 * v74 + 8) & 0x7FFFFFFF;
  while (v74 != 0x7FFFFFFF && *(unsigned char *)(v72 + 80 * v74 + 12) != 44);
  uint64_t v78 = v72 + 80 * v74;
LABEL_105:
  float v75 = (float)*(int *)(a1 + 8);
  float v76 = *(float *)(v78 + 48) / v75;
  uint64_t v79 = *(unsigned int *)(v73 + 4 * (0xBDBFB556329AEE83 % v71));
  unsigned int v77 = 0x7FFFFFFF;
  if (v79 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v72 + 80 * v79 + 12) == 45)
    {
LABEL_109:
      unsigned int v77 = v79;
    }
    else
    {
      while (1)
      {
        LODWORD(v79) = *(_DWORD *)(v72 + 80 * v79 + 8) & 0x7FFFFFFF;
        unsigned int v77 = 0x7FFFFFFF;
        if (v79 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v72 + 80 * v79 + 12) == 45) {
          goto LABEL_109;
        }
      }
    }
  }
LABEL_110:
  re::DynamicString::appendf((re::DynamicString *)v11, "Components: %.0f/%.0f\n", v76, (float)(*(float *)(v72 + 80 * v77 + 48) / v75));
  if (!*(void *)a3)
  {
    uint64_t v81 = *(void *)(a3 + 16);
    float v84 = (float)*(int *)(a1 + 8);
    float v85 = *(float *)(v81 + 0x27FFFFFFE0) / v84;
    unsigned int v86 = 0x7FFFFFFF;
    goto LABEL_124;
  }
  unint64_t v80 = *(unsigned int *)(a3 + 24);
  uint64_t v82 = *(void *)(a3 + 8);
  uint64_t v81 = *(void *)(a3 + 16);
  uint64_t v83 = *(unsigned int *)(v82 + 4 * (0x6F14AEC17CB2794BLL % v80));
  if (v83 == 0x7FFFFFFF)
  {
    LODWORD(v83) = 0x7FFFFFFF;
LABEL_115:
    uint64_t v87 = v81 + 80 * v83;
    goto LABEL_119;
  }
  if (*(unsigned char *)(v81 + 80 * v83 + 12) == 46) {
    goto LABEL_115;
  }
  do
    LODWORD(v83) = *(_DWORD *)(v81 + 80 * v83 + 8) & 0x7FFFFFFF;
  while (v83 != 0x7FFFFFFF && *(unsigned char *)(v81 + 80 * v83 + 12) != 46);
  uint64_t v87 = v81 + 80 * v83;
LABEL_119:
  float v84 = (float)*(int *)(a1 + 8);
  float v85 = *(float *)(v87 + 48) / v84;
  uint64_t v88 = *(unsigned int *)(v82 + 4 * (0x5A9FF51BA33ADC1CLL % v80));
  unsigned int v86 = 0x7FFFFFFF;
  if (v88 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v81 + 80 * v88 + 12) == 47)
    {
LABEL_123:
      unsigned int v86 = v88;
    }
    else
    {
      while (1)
      {
        LODWORD(v88) = *(_DWORD *)(v81 + 80 * v88 + 8) & 0x7FFFFFFF;
        unsigned int v86 = 0x7FFFFFFF;
        if (v88 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v81 + 80 * v88 + 12) == 47) {
          goto LABEL_123;
        }
      }
    }
  }
LABEL_124:
  re::DynamicString::appendf((re::DynamicString *)v11, "Entities: %.0f/%.0f\n", v85, (float)(*(float *)(v81 + 80 * v86 + 48) / v84));
  if (*(void *)a3)
  {
    uint64_t v89 = *(void *)(a3 + 16);
    uint64_t v90 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x5B64875D6615936EuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v91 = 0x7FFFFFFF;
    if (v90 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v89 + 80 * v90 + 12) == 38)
      {
LABEL_129:
        unsigned int v91 = v90;
      }
      else
      {
        while (1)
        {
          LODWORD(v90) = *(_DWORD *)(v89 + 80 * v90 + 8) & 0x7FFFFFFF;
          unsigned int v91 = 0x7FFFFFFF;
          if (v90 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v89 + 80 * v90 + 12) == 38) {
            goto LABEL_129;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v89 = *(void *)(a3 + 16);
    unsigned int v91 = 0x7FFFFFFF;
  }
  float v92 = *(float *)(v89 + 80 * v91 + 48);
  int v93 = *(_DWORD *)(a1 + 8);
  double v94 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v97 = NAN;
      goto LABEL_136;
    }
    LODWORD(v95) = info.numer;
    LODWORD(v96) = info.denom;
    double v94 = (double)v95 / (double)v96;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v94;
  }
  double v97 = v94 * (double)(unint64_t)(float)(v92 / (float)v93);
LABEL_136:
  double v98 = v97 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v99 = *(void *)(a3 + 16);
    uint64_t v100 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x271C93C147C4CD83uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v101 = 0x7FFFFFFF;
    if (v100 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v99 + 80 * v100 + 12) == 39)
      {
LABEL_141:
        unsigned int v101 = v100;
      }
      else
      {
        while (1)
        {
          LODWORD(v100) = *(_DWORD *)(v99 + 80 * v100 + 8) & 0x7FFFFFFF;
          unsigned int v101 = 0x7FFFFFFF;
          if (v100 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v99 + 80 * v100 + 12) == 39) {
            goto LABEL_141;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v99 = *(void *)(a3 + 16);
    unsigned int v101 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "RTT [ms]: %.2f    PacketLoss: %.2f\n", v98, (float)(*(float *)(v99 + 80 * v101 + 48) / (float)*(int *)(a1 + 8)));
  re::DynamicString::append((re::DynamicString *)v11, "SyncPacket Stats\n", 0x11uLL);
  if (*(void *)a3)
  {
    uint64_t v102 = *(void *)(a3 + 16);
    uint64_t v103 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x622570C6C262C8DFuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v104 = 0x7FFFFFFF;
    if (v103 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v102 + 80 * v103 + 12) == 49)
      {
LABEL_148:
        unsigned int v104 = v103;
      }
      else
      {
        while (1)
        {
          LODWORD(v103) = *(_DWORD *)(v102 + 80 * v103 + 8) & 0x7FFFFFFF;
          unsigned int v104 = 0x7FFFFFFF;
          if (v103 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v102 + 80 * v103 + 12) == 49) {
            goto LABEL_148;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v102 = *(void *)(a3 + 16);
    unsigned int v104 = 0x7FFFFFFF;
  }
  float v105 = *(float *)(v102 + 80 * v104 + 48);
  int v106 = *(_DWORD *)(a1 + 8);
  double v107 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v110 = NAN;
      goto LABEL_155;
    }
    LODWORD(v108) = info.numer;
    LODWORD(v109) = info.denom;
    double v107 = (double)v108 / (double)v109;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v107;
  }
  double v110 = v107 * (double)(unint64_t)(float)(v105 / (float)v106);
LABEL_155:
  double v111 = v110 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v112 = *(void *)(a3 + 16);
    uint64_t v113 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xCB9EBFBDFE40F3F9 % *(unsigned int *)(a3 + 24)));
    unsigned int v114 = 0x7FFFFFFF;
    if (v113 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v112 + 80 * v113 + 12) == 51)
      {
LABEL_160:
        unsigned int v114 = v113;
      }
      else
      {
        while (1)
        {
          LODWORD(v113) = *(_DWORD *)(v112 + 80 * v113 + 8) & 0x7FFFFFFF;
          unsigned int v114 = 0x7FFFFFFF;
          if (v113 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v112 + 80 * v113 + 12) == 51) {
            goto LABEL_160;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v112 = *(void *)(a3 + 16);
    unsigned int v114 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "RTT [ms]: %.2f    Packet Loss [1s]: %.2f\n", v111, (float)(*(float *)(v112 + 80 * v114 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    uint64_t v115 = *(void *)(a3 + 16);
    uint64_t v116 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x4930C821C1606730uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v117 = 0x7FFFFFFF;
    if (v116 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v115 + 80 * v116 + 12) == 50)
      {
LABEL_167:
        unsigned int v117 = v116;
      }
      else
      {
        while (1)
        {
          LODWORD(v116) = *(_DWORD *)(v115 + 80 * v116 + 8) & 0x7FFFFFFF;
          unsigned int v117 = 0x7FFFFFFF;
          if (v116 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v115 + 80 * v116 + 12) == 50) {
            goto LABEL_167;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v115 = *(void *)(a3 + 16);
    unsigned int v117 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Packet Loss [avg]: %.2f\n", (float)(*(float *)(v115 + 80 * v117 + 48) / (float)*(int *)(a1 + 8)));
  uint64_t v118 = mach_absolute_time();
  double v119 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v122 = NAN;
      goto LABEL_174;
    }
    LODWORD(v120) = info.numer;
    LODWORD(v121) = info.denom;
    double v119 = (double)v120 / (double)v121;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v119;
  }
  double v122 = v119 * (double)v118;
LABEL_174:
  double v123 = v122 / 1000000000.0;
  if (*(void *)a3)
  {
    uint64_t v124 = *(void *)(a3 + 16);
    uint64_t v125 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x6616B7C1A5E48C27uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v126 = 0x7FFFFFFF;
    if (v125 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v124 + 80 * v125 + 12) == 52)
      {
LABEL_179:
        unsigned int v126 = v125;
      }
      else
      {
        while (1)
        {
          LODWORD(v125) = *(_DWORD *)(v124 + 80 * v125 + 8) & 0x7FFFFFFF;
          unsigned int v126 = 0x7FFFFFFF;
          if (v125 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v124 + 80 * v125 + 12) == 52) {
            goto LABEL_179;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v124 = *(void *)(a3 + 16);
    unsigned int v126 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Hand Tap Latency [ms]: %.2f", (v123 - *(float *)(v124 + 80 * v126 + 36)) * 1000.0);
  double v127 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v130 = NAN;
      goto LABEL_186;
    }
    LODWORD(v128) = info.numer;
    LODWORD(v129) = info.denom;
    double v127 = (double)v128 / (double)v129;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v127;
  }
  double v130 = v127 * (double)v118;
LABEL_186:
  if (*(void *)a3)
  {
    uint64_t v131 = *(void *)(a3 + 16);
    uint64_t v132 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x632FD669A7AB1BD4uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v133 = 0x7FFFFFFF;
    if (v132 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v131 + 80 * v132 + 12) == 53)
      {
LABEL_191:
        unsigned int v133 = v132;
      }
      else
      {
        while (1)
        {
          LODWORD(v132) = *(_DWORD *)(v131 + 80 * v132 + 8) & 0x7FFFFFFF;
          unsigned int v133 = 0x7FFFFFFF;
          if (v132 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v131 + 80 * v132 + 12) == 53) {
            goto LABEL_191;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v131 = *(void *)(a3 + 16);
    unsigned int v133 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Direct Gaze Latency [ms]: %.2f", (v130 / 1000000000.0 - *(float *)(v131 + 80 * v133 + 36)) * 1000.0);
  uint64_t v134 = v8 + (v9 << 6);
  *(void *)&double result = 0x2D00000010;
  *(void *)(v134 + 48) = 0x2D00000010;
  *(_DWORD *)(v134 + 56) = 64;
  return result;
}

double re::FramePhysicsStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    unsigned int v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    unsigned int v13 = (char *)v11 + 9;
  }
  *unsigned int v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics Stats\n");
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v16 + 80 * v15 + 12) != 19)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v16 + 80 * v14 + 12) == 19) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "PhysX Update Time (ms) : %.2f\n", v22 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    unsigned int v25 = 0x7FFFFFFF;
    if (v24 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v23 + 80 * v24 + 12) == 121)
      {
LABEL_30:
        unsigned int v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          unsigned int v25 = 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v23 + 80 * v24 + 12) == 121) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a3 + 16);
    unsigned int v25 = 0x7FFFFFFF;
  }
  float v26 = *(float *)(v23 + 80 * v25 + 48);
  int v27 = *(_DWORD *)(a1 + 8);
  double v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    double v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v28;
  }
  double v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics ECS Work (ms) : %.2f\n", v31 / 1000000.0);
  if (!*(void *)a3)
  {
    uint64_t v33 = *(void *)(a3 + 16);
    float v36 = (float)*(int *)(a1 + 8);
    float v37 = *(float *)(v33 + 0x27FFFFFFE0) / v36;
    unsigned int v38 = 0x7FFFFFFF;
    goto LABEL_51;
  }
  unint64_t v32 = *(unsigned int *)(a3 + 24);
  uint64_t v34 = *(void *)(a3 + 8);
  uint64_t v33 = *(void *)(a3 + 16);
  uint64_t v35 = *(unsigned int *)(v34 + 4 * (0xA46B02245B9F3AF4 % v32));
  if (v35 == 0x7FFFFFFF)
  {
    LODWORD(v35) = 0x7FFFFFFF;
LABEL_42:
    uint64_t v39 = v33 + 80 * v35;
    goto LABEL_46;
  }
  if (*(unsigned char *)(v33 + 80 * v35 + 12) == 67) {
    goto LABEL_42;
  }
  do
    LODWORD(v35) = *(_DWORD *)(v33 + 80 * v35 + 8) & 0x7FFFFFFF;
  while (v35 != 0x7FFFFFFF && *(unsigned char *)(v33 + 80 * v35 + 12) != 67);
  uint64_t v39 = v33 + 80 * v35;
LABEL_46:
  float v36 = (float)*(int *)(a1 + 8);
  float v37 = *(float *)(v39 + 48) / v36;
  uint64_t v40 = *(unsigned int *)(v34 + 4 * (0xCF4A7B3C48D45C4FLL % v32));
  unsigned int v38 = 0x7FFFFFFF;
  if (v40 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v33 + 80 * v40 + 12) == 66)
    {
LABEL_50:
      unsigned int v38 = v40;
    }
    else
    {
      while (1)
      {
        LODWORD(v40) = *(_DWORD *)(v33 + 80 * v40 + 8) & 0x7FFFFFFF;
        unsigned int v38 = 0x7FFFFFFF;
        if (v40 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v33 + 80 * v40 + 12) == 66) {
          goto LABEL_50;
        }
      }
    }
  }
LABEL_51:
  re::DynamicString::appendf((re::DynamicString *)v11, "Active Rigid Bodies : %.0f    Rigid Bodies : %.0f\n", v37, (float)(*(float *)(v33 + 80 * v38 + 48) / v36));
  if (!*(void *)a3)
  {
    uint64_t v42 = *(void *)(a3 + 16);
    float v45 = (float)*(int *)(a1 + 8);
    float v46 = *(float *)(v42 + 0x27FFFFFFE0) / v45;
    unsigned int v47 = 0x7FFFFFFF;
    goto LABEL_65;
  }
  unint64_t v41 = *(unsigned int *)(a3 + 24);
  uint64_t v43 = *(void *)(a3 + 8);
  uint64_t v42 = *(void *)(a3 + 16);
  uint64_t v44 = *(unsigned int *)(v43 + 4 * (0x21C2DD3F1FDB3325 % v41));
  if (v44 == 0x7FFFFFFF)
  {
    LODWORD(v44) = 0x7FFFFFFF;
LABEL_56:
    uint64_t v48 = v42 + 80 * v44;
    goto LABEL_60;
  }
  if (*(unsigned char *)(v42 + 80 * v44 + 12) == 68) {
    goto LABEL_56;
  }
  do
    LODWORD(v44) = *(_DWORD *)(v42 + 80 * v44 + 8) & 0x7FFFFFFF;
  while (v44 != 0x7FFFFFFF && *(unsigned char *)(v42 + 80 * v44 + 12) != 68);
  uint64_t v48 = v42 + 80 * v44;
LABEL_60:
  float v45 = (float)*(int *)(a1 + 8);
  float v46 = *(float *)(v48 + 48) / v45;
  uint64_t v49 = *(unsigned int *)(v43 + 4 * (0x41956A36DBC51080 % v41));
  unsigned int v47 = 0x7FFFFFFF;
  if (v49 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v42 + 80 * v49 + 12) == 69)
    {
LABEL_64:
      unsigned int v47 = v49;
    }
    else
    {
      while (1)
      {
        LODWORD(v49) = *(_DWORD *)(v42 + 80 * v49 + 8) & 0x7FFFFFFF;
        unsigned int v47 = 0x7FFFFFFF;
        if (v49 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v42 + 80 * v49 + 12) == 69) {
          goto LABEL_64;
        }
      }
    }
  }
LABEL_65:
  re::DynamicString::appendf((re::DynamicString *)v11, "Collision Objects : %.0f    Contacts : %.0f\n", v46, (float)(*(float *)(v42 + 80 * v47 + 48) / v45));
  if (!*(void *)a3)
  {
    uint64_t v51 = *(void *)(a3 + 16);
    float v54 = (float)*(int *)(a1 + 8);
    float v55 = *(float *)(v51 + 0x27FFFFFFE0) / v54;
    unsigned int v56 = 0x7FFFFFFF;
    goto LABEL_79;
  }
  unint64_t v50 = *(unsigned int *)(a3 + 24);
  uint64_t v52 = *(void *)(a3 + 8);
  uint64_t v51 = *(void *)(a3 + 16);
  uint64_t v53 = *(unsigned int *)(v52 + 4 * (0x4BEE618685B05729 % v50));
  if (v53 == 0x7FFFFFFF)
  {
    LODWORD(v53) = 0x7FFFFFFF;
LABEL_70:
    uint64_t v57 = v51 + 80 * v53;
    goto LABEL_74;
  }
  if (*(unsigned char *)(v51 + 80 * v53 + 12) == 71) {
    goto LABEL_70;
  }
  do
    LODWORD(v53) = *(_DWORD *)(v51 + 80 * v53 + 8) & 0x7FFFFFFF;
  while (v53 != 0x7FFFFFFF && *(unsigned char *)(v51 + 80 * v53 + 12) != 71);
  uint64_t v57 = v51 + 80 * v53;
LABEL_74:
  float v54 = (float)*(int *)(a1 + 8);
  float v55 = *(float *)(v57 + 48) / v54;
  uint64_t v58 = *(unsigned int *)(v52 + 4 * (0x87CF9DF80D80457CLL % v50));
  unsigned int v56 = 0x7FFFFFFF;
  if (v58 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v51 + 80 * v58 + 12) == 70)
    {
LABEL_78:
      unsigned int v56 = v58;
    }
    else
    {
      while (1)
      {
        LODWORD(v58) = *(_DWORD *)(v51 + 80 * v58 + 8) & 0x7FFFFFFF;
        unsigned int v56 = 0x7FFFFFFF;
        if (v58 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v51 + 80 * v58 + 12) == 70) {
          goto LABEL_78;
        }
      }
    }
  }
LABEL_79:
  re::DynamicString::appendf((re::DynamicString *)v11, "Force Effects : %.0f    Active Constraints : %.0f\n", v55, (float)(*(float *)(v51 + 80 * v56 + 48) / v54));
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics Shapes\n");
  if (!*(void *)a3)
  {
    uint64_t v60 = *(void *)(a3 + 16);
    float v63 = *(float *)(v60 + 0x27FFFFFFE0);
    float v64 = (float)*(int *)(a1 + 8);
    float v65 = v63 / v64;
    unsigned int v66 = 0x7FFFFFFF;
    goto LABEL_97;
  }
  unint64_t v59 = *(unsigned int *)(a3 + 24);
  uint64_t v61 = *(void *)(a3 + 8);
  uint64_t v60 = *(void *)(a3 + 16);
  uint64_t v62 = *(unsigned int *)(v61 + 4 * (0x654FAFC0EE6F9A84 % v59));
  if (v62 == 0x7FFFFFFF) {
    goto LABEL_81;
  }
  if (*(unsigned char *)(v60 + 80 * v62 + 12) != 72)
  {
    while (1)
    {
      LODWORD(v62) = *(_DWORD *)(v60 + 80 * v62 + 8) & 0x7FFFFFFF;
      if (v62 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned char *)(v60 + 80 * v62 + 12) == 72) {
        goto LABEL_86;
      }
    }
LABEL_81:
    LODWORD(v62) = 0x7FFFFFFF;
  }
LABEL_86:
  float v64 = (float)*(int *)(a1 + 8);
  float v65 = *(float *)(v60 + 80 * v62 + 48) / v64;
  unsigned int v67 = *(_DWORD *)(v61 + 4 * (0xA7941FA8506D86F0 % v59));
  unsigned int v66 = 0x7FFFFFFF;
  unsigned int v68 = 0x7FFFFFFF;
  if (v67 != 0x7FFFFFFF)
  {
    unsigned int v68 = *(_DWORD *)(v61 + 4 * (0xA7941FA8506D86F0 % v59));
    if (*(unsigned char *)(v60 + 80 * v67 + 12) != 73)
    {
      while (1)
      {
        unsigned int v68 = *(_DWORD *)(v60 + 80 * *(unsigned int *)(v61 + 4 * (0xA7941FA8506D86F0 % v59)) + 8) & 0x7FFFFFFF;
        if (v68 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v60 + 80 * v68 + 12) == 73) {
          goto LABEL_92;
        }
      }
      unsigned int v68 = 0x7FFFFFFF;
    }
  }
LABEL_92:
  float v63 = *(float *)(v60 + 80 * v68 + 48);
  uint64_t v69 = *(unsigned int *)(v61 + 4 * (0xC1EBF56D881F3523 % v59));
  if (v69 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v60 + 80 * v69 + 12) == 74)
    {
LABEL_96:
      unsigned int v66 = v69;
    }
    else
    {
      while (1)
      {
        LODWORD(v69) = *(_DWORD *)(v60 + 80 * v69 + 8) & 0x7FFFFFFF;
        unsigned int v66 = 0x7FFFFFFF;
        if (v69 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v60 + 80 * v69 + 12) == 74) {
          goto LABEL_96;
        }
      }
    }
  }
LABEL_97:
  re::DynamicString::appendf((re::DynamicString *)v11, "Spheres : %.0f, Planes : %.0f, Capsules : %.0f\n", v65, (float)(v63 / v64), (float)(*(float *)(v60 + 80 * v66 + 48) / v64));
  if (*(void *)a3)
  {
    unint64_t v70 = *(unsigned int *)(a3 + 24);
    uint64_t v72 = *(void *)(a3 + 8);
    uint64_t v71 = *(void *)(a3 + 16);
    unsigned int v73 = *(_DWORD *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70));
    unsigned int v74 = 0x7FFFFFFF;
    unsigned int v75 = 0x7FFFFFFF;
    if (v73 != 0x7FFFFFFF)
    {
      unsigned int v75 = *(_DWORD *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70));
      if (*(unsigned char *)(v71 + 80 * v73 + 12) != 75)
      {
        while (1)
        {
          unsigned int v75 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70)) + 8) & 0x7FFFFFFF;
          if (v75 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v71 + 80 * v75 + 12) == 75) {
            goto LABEL_105;
          }
        }
        unsigned int v75 = 0x7FFFFFFF;
      }
    }
LABEL_105:
    uint64_t v80 = v71 + 80 * v75;
    int v76 = *(_DWORD *)(a1 + 8);
    unsigned int v81 = *(_DWORD *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70));
    if (v81 != 0x7FFFFFFF)
    {
      unsigned int v74 = *(_DWORD *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70));
      if (*(unsigned char *)(v71 + 80 * v81 + 12) != 76)
      {
        while (1)
        {
          unsigned int v74 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70)) + 8) & 0x7FFFFFFF;
          if (v74 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v71 + 80 * v74 + 12) == 76) {
            goto LABEL_111;
          }
        }
        unsigned int v74 = 0x7FFFFFFF;
      }
    }
LABEL_111:
    float v77 = *(float *)(v80 + 48);
    float v79 = *(float *)(v71 + 80 * v74 + 48);
    uint64_t v82 = *(unsigned int *)(v72 + 4 * (0x2CFA56B4A2AF9298 % v70));
    unsigned int v78 = 0x7FFFFFFF;
    if (v82 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v71 + 80 * v82 + 12) == 77)
      {
LABEL_115:
        unsigned int v78 = v82;
      }
      else
      {
        while (1)
        {
          LODWORD(v82) = *(_DWORD *)(v71 + 80 * v82 + 8) & 0x7FFFFFFF;
          unsigned int v78 = 0x7FFFFFFF;
          if (v82 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v71 + 80 * v82 + 12) == 77) {
            goto LABEL_115;
          }
        }
      }
    }
  }
  else
  {
    int v76 = *(_DWORD *)(a1 + 8);
    uint64_t v71 = *(void *)(a3 + 16);
    float v77 = *(float *)(v71 + 0x27FFFFFFE0);
    unsigned int v78 = 0x7FFFFFFF;
    float v79 = v77;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Boxes : %.0f, Triangles : %.0f, Convexes : %.0f\n", (float)(v77 / (float)v76), (float)(v79 / (float)v76), (float)(*(float *)(v71 + 80 * v78 + 48) / (float)v76));
  uint64_t v83 = v8 + (v9 << 6);
  *(void *)&double result = 0x320000000ALL;
  *(void *)(v83 + 48) = 0x320000000ALL;
  *(_DWORD *)(v83 + 56) = 128;
  return result;
}

double re::FrameRenderingStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v6) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v7 = **(unsigned int **)(a2 + 8);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        uint64_t v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v10 = v6;
  uint64_t v11 = v9 + ((unint64_t)v6 << 6);
  uint64_t v12 = (void *)(v11 + 16);
  uint64_t v13 = *(void *)(v11 + 24);
  if (v13)
  {
    v12[1] = 1;
    unsigned int v14 = (unsigned char *)v12[2];
  }
  else
  {
    *((unsigned char *)v12 + 8) = v13 & 1;
    unsigned int v14 = (char *)v12 + 9;
  }
  *unsigned int v14 = 0;
  unsigned int v15 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v16 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      uint64_t v17 = *(void *)(a3 + 16);
      unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v17 + 80 * v16 + 12) != 1)
      {
        while (1)
        {
          unsigned int v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v17 + 80 * v15 + 12) == 1) {
            goto LABEL_20;
          }
        }
        unsigned int v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  uint64_t v300 = v10;
  uint64_t v301 = v9;
  float v18 = *(float *)(*(void *)(a3 + 16) + 80 * v15 + 48);
  int v19 = *(_DWORD *)(a1 + 8);
  double v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info[0].numer;
    LODWORD(v22) = info[0].denom;
    double v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v20;
  }
  double v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  double v305 = v23;
  if (*(void *)a3)
  {
    uint64_t v24 = *(void *)(a3 + 16);
    uint64_t v25 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a3 + 24)));
    unsigned int v26 = 0x7FFFFFFF;
    if (v25 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v24 + 80 * v25 + 12) == 9)
      {
LABEL_30:
        unsigned int v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          unsigned int v26 = 0x7FFFFFFF;
          if (v25 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v24 + 80 * v25 + 12) == 9) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a3 + 16);
    unsigned int v26 = 0x7FFFFFFF;
  }
  float v27 = *(float *)(v24 + 80 * v26 + 48);
  int v28 = *(_DWORD *)(a1 + 8);
  double v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info[0].numer;
    LODWORD(v31) = info[0].denom;
    double v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v29;
  }
  double v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  if (*(void *)a3)
  {
    uint64_t v33 = *(void *)(a3 + 16);
    uint64_t v34 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v35 = 0x7FFFFFFF;
    if (v34 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v33 + 80 * v34 + 12) == 10)
      {
LABEL_42:
        unsigned int v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          unsigned int v35 = 0x7FFFFFFF;
          if (v34 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v33 + 80 * v34 + 12) == 10) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v33 = *(void *)(a3 + 16);
    unsigned int v35 = 0x7FFFFFFF;
  }
  float v36 = *(float *)(v33 + 80 * v35 + 48);
  int v37 = *(_DWORD *)(a1 + 8);
  double v38 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v41 = NAN;
      goto LABEL_49;
    }
    LODWORD(v39) = info[0].numer;
    LODWORD(v40) = info[0].denom;
    double v38 = (double)v39 / (double)v40;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v38;
  }
  double v41 = v38 * (double)(unint64_t)(float)(v36 / (float)v37);
LABEL_49:
  if (*(void *)a3)
  {
    uint64_t v42 = *(void *)(a3 + 16);
    uint64_t v43 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a3 + 24)));
    unsigned int v44 = 0x7FFFFFFF;
    if (v43 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v42 + 80 * v43 + 12) == 8)
      {
LABEL_54:
        unsigned int v44 = v43;
      }
      else
      {
        while (1)
        {
          LODWORD(v43) = *(_DWORD *)(v42 + 80 * v43 + 8) & 0x7FFFFFFF;
          unsigned int v44 = 0x7FFFFFFF;
          if (v43 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v42 + 80 * v43 + 12) == 8) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v42 = *(void *)(a3 + 16);
    unsigned int v44 = 0x7FFFFFFF;
  }
  float v45 = *(float *)(v42 + 80 * v44 + 48);
  int v46 = *(_DWORD *)(a1 + 8);
  double v47 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v50 = NAN;
      goto LABEL_61;
    }
    LODWORD(v48) = info[0].numer;
    LODWORD(v49) = info[0].denom;
    double v47 = (double)v48 / (double)v49;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v47;
  }
  double v50 = v47 * (double)(unint64_t)(float)(v45 / (float)v46);
LABEL_61:
  double v309 = v50;
  if (*(void *)a3)
  {
    uint64_t v51 = *(void *)(a3 + 16);
    uint64_t v52 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v53 = 0x7FFFFFFF;
    if (v52 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v51 + 80 * v52 + 12) == 11)
      {
LABEL_66:
        unsigned int v53 = v52;
      }
      else
      {
        while (1)
        {
          LODWORD(v52) = *(_DWORD *)(v51 + 80 * v52 + 8) & 0x7FFFFFFF;
          unsigned int v53 = 0x7FFFFFFF;
          if (v52 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v51 + 80 * v52 + 12) == 11) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v51 = *(void *)(a3 + 16);
    unsigned int v53 = 0x7FFFFFFF;
  }
  float v54 = *(float *)(v51 + 80 * v53 + 48);
  int v55 = *(_DWORD *)(a1 + 8);
  double v56 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v59 = NAN;
      goto LABEL_73;
    }
    LODWORD(v57) = info[0].numer;
    LODWORD(v58) = info[0].denom;
    double v56 = (double)v57 / (double)v58;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v56;
  }
  double v59 = v56 * (double)(unint64_t)(float)(v54 / (float)v55);
LABEL_73:
  double v307 = v59;
  if (*(void *)a3)
  {
    uint64_t v60 = *(void *)(a3 + 16);
    uint64_t v61 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v62 = 0x7FFFFFFF;
    if (v61 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v60 + 80 * v61 + 12) == 12)
      {
LABEL_78:
        unsigned int v62 = v61;
      }
      else
      {
        while (1)
        {
          LODWORD(v61) = *(_DWORD *)(v60 + 80 * v61 + 8) & 0x7FFFFFFF;
          unsigned int v62 = 0x7FFFFFFF;
          if (v61 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v60 + 80 * v61 + 12) == 12) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v60 = *(void *)(a3 + 16);
    unsigned int v62 = 0x7FFFFFFF;
  }
  float v63 = *(float *)(v60 + 80 * v62 + 48);
  int v64 = *(_DWORD *)(a1 + 8);
  double v65 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v68 = NAN;
      goto LABEL_85;
    }
    LODWORD(v66) = info[0].numer;
    LODWORD(v67) = info[0].denom;
    double v65 = (double)v66 / (double)v67;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v65;
  }
  double v68 = v65 * (double)(unint64_t)(float)(v63 / (float)v64);
LABEL_85:
  if (*(void *)a3)
  {
    uint64_t v69 = *(void *)(a3 + 16);
    uint64_t v70 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v71 = 0x7FFFFFFF;
    if (v70 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v69 + 80 * v70 + 12) == 23)
      {
LABEL_90:
        unsigned int v71 = v70;
      }
      else
      {
        while (1)
        {
          LODWORD(v70) = *(_DWORD *)(v69 + 80 * v70 + 8) & 0x7FFFFFFF;
          unsigned int v71 = 0x7FFFFFFF;
          if (v70 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v69 + 80 * v70 + 12) == 23) {
            goto LABEL_90;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v69 = *(void *)(a3 + 16);
    unsigned int v71 = 0x7FFFFFFF;
  }
  float v72 = *(float *)(v69 + 80 * v71 + 48);
  int v73 = *(_DWORD *)(a1 + 8);
  double v74 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v77 = NAN;
      goto LABEL_97;
    }
    LODWORD(v75) = info[0].numer;
    LODWORD(v76) = info[0].denom;
    double v74 = (double)v75 / (double)v76;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v74;
  }
  double v77 = v74 * (double)(unint64_t)(float)(v72 / (float)v73);
LABEL_97:
  if (*(void *)a3)
  {
    uint64_t v78 = *(void *)(a3 + 16);
    uint64_t v79 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xCFF0446243756E89 % *(unsigned int *)(a3 + 24)));
    unsigned int v80 = 0x7FFFFFFF;
    if (v79 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v78 + 80 * v79 + 12) == 79)
      {
LABEL_102:
        unsigned int v80 = v79;
      }
      else
      {
        while (1)
        {
          LODWORD(v79) = *(_DWORD *)(v78 + 80 * v79 + 8) & 0x7FFFFFFF;
          unsigned int v80 = 0x7FFFFFFF;
          if (v79 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v78 + 80 * v79 + 12) == 79) {
            goto LABEL_102;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v78 = *(void *)(a3 + 16);
    unsigned int v80 = 0x7FFFFFFF;
  }
  float v81 = *(float *)(v78 + 80 * v80 + 48);
  int v82 = *(_DWORD *)(a1 + 8);
  double v83 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v86 = NAN;
      goto LABEL_109;
    }
    LODWORD(v84) = info[0].numer;
    LODWORD(v85) = info[0].denom;
    double v83 = (double)v84 / (double)v85;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v83;
  }
  double v86 = v83 * (double)(unint64_t)(float)(v81 / (float)v82);
LABEL_109:
  double v303 = v86;
  if (*(void *)a3)
  {
    uint64_t v87 = *(void *)(a3 + 16);
    uint64_t v88 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v89 = 0x7FFFFFFF;
    if (v88 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v87 + 80 * v88 + 12) == 122)
      {
LABEL_114:
        unsigned int v89 = v88;
      }
      else
      {
        while (1)
        {
          LODWORD(v88) = *(_DWORD *)(v87 + 80 * v88 + 8) & 0x7FFFFFFF;
          unsigned int v89 = 0x7FFFFFFF;
          if (v88 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v87 + 80 * v88 + 12) == 122) {
            goto LABEL_114;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v87 = *(void *)(a3 + 16);
    unsigned int v89 = 0x7FFFFFFF;
  }
  float v90 = *(float *)(v87 + 80 * v89 + 48);
  int v91 = *(_DWORD *)(a1 + 8);
  double v92 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v95 = NAN;
      goto LABEL_121;
    }
    LODWORD(v93) = info[0].numer;
    LODWORD(v94) = info[0].denom;
    double v92 = (double)v93 / (double)v94;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v92;
  }
  double v95 = v92 * (double)(unint64_t)(float)(v90 / (float)v91);
LABEL_121:
  double v302 = v95;
  if (*(void *)a3)
  {
    uint64_t v96 = *(void *)(a3 + 16);
    uint64_t v97 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v98 = 0x7FFFFFFF;
    if (v97 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v96 + 80 * v97 + 12) == 91)
      {
LABEL_126:
        unsigned int v98 = v97;
      }
      else
      {
        while (1)
        {
          LODWORD(v97) = *(_DWORD *)(v96 + 80 * v97 + 8) & 0x7FFFFFFF;
          unsigned int v98 = 0x7FFFFFFF;
          if (v97 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v96 + 80 * v97 + 12) == 91) {
            goto LABEL_126;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v96 = *(void *)(a3 + 16);
    unsigned int v98 = 0x7FFFFFFF;
  }
  float v99 = *(float *)(v96 + 80 * v98 + 48);
  int v100 = *(_DWORD *)(a1 + 8);
  double v101 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v104 = NAN;
      goto LABEL_133;
    }
    LODWORD(v102) = info[0].numer;
    LODWORD(v103) = info[0].denom;
    double v101 = (double)v102 / (double)v103;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v101;
  }
  double v104 = v101 * (double)(unint64_t)(float)(v99 / (float)v100);
LABEL_133:
  if (*(void *)a3)
  {
    uint64_t v105 = *(void *)(a3 + 16);
    uint64_t v106 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a3 + 24)));
    unsigned int v107 = 0x7FFFFFFF;
    if (v106 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v105 + 80 * v106 + 12) == 92)
      {
LABEL_138:
        unsigned int v107 = v106;
      }
      else
      {
        while (1)
        {
          LODWORD(v106) = *(_DWORD *)(v105 + 80 * v106 + 8) & 0x7FFFFFFF;
          unsigned int v107 = 0x7FFFFFFF;
          if (v106 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v105 + 80 * v106 + 12) == 92) {
            goto LABEL_138;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v105 = *(void *)(a3 + 16);
    unsigned int v107 = 0x7FFFFFFF;
  }
  double v108 = v32 / 1000000.0;
  float v109 = *(float *)(v105 + 80 * v107 + 48);
  int v110 = *(_DWORD *)(a1 + 8);
  double v111 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v112 = v41 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v115 = NAN;
      goto LABEL_145;
    }
    LODWORD(v113) = info[0].numer;
    LODWORD(v114) = info[0].denom;
    double v111 = (double)v113 / (double)v114;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v111;
  }
  double v115 = v111 * (double)(unint64_t)(float)(v109 / (float)v110);
LABEL_145:
  double v116 = v307 / 1000000.0;
  double v117 = v77 / 1000000.0;
  double v120 = v115 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v121 = *(void *)(a3 + 16);
    uint64_t v122 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a3 + 24)));
    unsigned int v123 = 0x7FFFFFFF;
    if (v122 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v121 + 80 * v122 + 12) == 93)
      {
LABEL_150:
        unsigned int v123 = v122;
      }
      else
      {
        while (1)
        {
          LODWORD(v122) = *(_DWORD *)(v121 + 80 * v122 + 8) & 0x7FFFFFFF;
          unsigned int v123 = 0x7FFFFFFF;
          if (v122 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v121 + 80 * v122 + 12) == 93) {
            goto LABEL_150;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v121 = *(void *)(a3 + 16);
    unsigned int v123 = 0x7FFFFFFF;
  }
  float v124 = v309 / 1000000.0;
  float v308 = v124;
  float v125 = v116;
  float v310 = v125;
  float v126 = v68 / 1000000.0;
  float v127 = v117;
  float v299 = v112;
  float v118 = v108;
  float v119 = v112;
  float v128 = v118 - v119;
  float v129 = v104 / 1000000.0;
  float v130 = v120;
  float v131 = *(float *)(v121 + 80 * v123 + 48);
  int v132 = *(_DWORD *)(a1 + 8);
  double v133 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v134 = v305 / 1000000.0;
  float v306 = v127;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v137 = NAN;
      float v127 = v306;
      goto LABEL_157;
    }
    LODWORD(v135) = info[0].numer;
    LODWORD(v136) = info[0].denom;
    double v133 = (double)v135 / (double)v136;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v133;
    float v127 = v306;
  }
  double v137 = v133 * (double)(unint64_t)(float)(v131 / (float)v132);
LABEL_157:
  float v138 = v134;
  float v139 = v137 / 1000000.0;
  float v140 = v128 + (float)((float)(v129 + v130) + v139);
  float v141 = v126;
  float v142 = (float)(v310 + v126) + v127;
  float v143 = 0.0;
  if (v308 <= 0.0) {
    float v143 = v142;
  }
  if (*(void *)a3)
  {
    uint64_t v144 = *(void *)(a3 + 16);
    uint64_t v145 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD59EEF30DB86CAB8 % *(unsigned int *)(a3 + 24)));
    unsigned int v146 = 0x7FFFFFFF;
    if (v145 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v144 + 80 * v145 + 12) == 24)
      {
LABEL_164:
        unsigned int v146 = v145;
      }
      else
      {
        while (1)
        {
          LODWORD(v145) = *(_DWORD *)(v144 + 80 * v145 + 8) & 0x7FFFFFFF;
          unsigned int v146 = 0x7FFFFFFF;
          if (v145 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v144 + 80 * v145 + 12) == 24) {
            goto LABEL_164;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v144 = *(void *)(a3 + 16);
    unsigned int v146 = 0x7FFFFFFF;
  }
  float v147 = v140 - v143;
  float v148 = (float)*(int *)(a1 + 8);
  BOOL v149 = v138 <= 0.0;
  double v150 = (float)(1000.0 / v138);
  if (v149) {
    double v151 = 0.0;
  }
  else {
    double v151 = v150;
  }
  float v152 = (float)(*(float *)(v144 + 80 * v146 + 48) / v148) / 1000000.0;
  if (*(void *)a3)
  {
    unint64_t v153 = *(unsigned int *)(a3 + 24);
    uint64_t v154 = *(void *)(a3 + 8);
    unsigned int v155 = *(_DWORD *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153));
    unsigned int v156 = 0x7FFFFFFF;
    unsigned int v157 = 0x7FFFFFFF;
    if (v155 != 0x7FFFFFFF)
    {
      unsigned int v157 = *(_DWORD *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153));
      if (*(unsigned char *)(v144 + 80 * v155 + 12) != 29)
      {
        while (1)
        {
          unsigned int v157 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153)) + 8) & 0x7FFFFFFF;
          if (v157 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v144 + 80 * v157 + 12) == 29) {
            goto LABEL_177;
          }
        }
        unsigned int v157 = 0x7FFFFFFF;
      }
    }
LABEL_177:
    unsigned int v162 = *(_DWORD *)(v154 + 4 * (0x724EA9269D42A72 % v153));
    if (v162 != 0x7FFFFFFF)
    {
      unsigned int v156 = *(_DWORD *)(v154 + 4 * (0x724EA9269D42A72 % v153));
      if (*(unsigned char *)(v144 + 80 * v162 + 12) != 30)
      {
        while (1)
        {
          unsigned int v156 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x724EA9269D42A72 % v153)) + 8) & 0x7FFFFFFF;
          if (v156 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v144 + 80 * v156 + 12) == 30) {
            goto LABEL_183;
          }
        }
        unsigned int v156 = 0x7FFFFFFF;
      }
    }
LABEL_183:
    uint64_t v163 = v144 + 80 * v157;
    uint64_t v164 = v144 + 80 * v156;
    unsigned int v165 = *(_DWORD *)(v154 + 4 * (0x540F172E046EF165 % v153));
    unsigned int v159 = 0x7FFFFFFF;
    unsigned int v166 = 0x7FFFFFFF;
    if (v165 != 0x7FFFFFFF)
    {
      unsigned int v166 = *(_DWORD *)(v154 + 4 * (0x540F172E046EF165 % v153));
      if (*(unsigned char *)(v144 + 80 * v165 + 12) != 31)
      {
        while (1)
        {
          unsigned int v166 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x540F172E046EF165 % v153)) + 8) & 0x7FFFFFFF;
          if (v166 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v144 + 80 * v166 + 12) == 31) {
            goto LABEL_189;
          }
        }
        unsigned int v166 = 0x7FFFFFFF;
      }
    }
LABEL_189:
    float v160 = *(float *)(v163 + 48);
    float v161 = *(float *)(v164 + 48);
    float v158 = *(float *)(v144 + 80 * v166 + 48);
    uint64_t v167 = *(unsigned int *)(v154 + 4 * (0xADFB1EBB497FAD45 % v153));
    if (v167 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v144 + 80 * v167 + 12) == 32)
      {
LABEL_193:
        unsigned int v159 = v167;
      }
      else
      {
        while (1)
        {
          LODWORD(v167) = *(_DWORD *)(v144 + 80 * v167 + 8) & 0x7FFFFFFF;
          unsigned int v159 = 0x7FFFFFFF;
          if (v167 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v144 + 80 * v167 + 12) == 32) {
            goto LABEL_193;
          }
        }
      }
    }
  }
  else
  {
    float v158 = *(float *)(v144 + 0x27FFFFFFE0);
    unsigned int v159 = 0x7FFFFFFF;
    float v160 = v158;
    float v161 = v158;
  }
  unint64_t v168 = (unint64_t)(float)((float)(v161 / v148) / 1000000.0);
  unint64_t v169 = (unint64_t)(float)((float)(v160 / v148) / 1000000.0);
  unint64_t v170 = (unint64_t)(float)((float)(v158 / v148) / 1000000.0);
  unint64_t v171 = (unint64_t)(float)((float)(*(float *)(v144 + 80 * v159 + 48) / v148) / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Frame Render GPU Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v12, "FPS : %.2f    GPU : %.2f\n", v151, v152);
  re::DynamicString::appendf((re::DynamicString *)v12, "Vtx : %.2f    Frg : %.2f\nRenderGraph compute : %0.2f\nDeformer compute : %0.2f\n", (double)v169 / 1000000.0, (double)v168 / 1000000.0, (double)v170 / 1000000.0, (double)v171 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Frame Render CPU Times (ms)\n");
  double v172 = v147;
  if (v308 <= 0.0)
  {
    if (*(void *)a3)
    {
      uint64_t v177 = *(void *)(a3 + 16);
      uint64_t v178 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
      unsigned int v179 = 0x7FFFFFFF;
      float v180 = v302 / 1000000.0;
      float v181 = v303 / 1000000.0;
      if (v178 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v177 + 80 * v178 + 12) == 122)
        {
LABEL_206:
          unsigned int v179 = v178;
        }
        else
        {
          while (1)
          {
            LODWORD(v178) = *(_DWORD *)(v177 + 80 * v178 + 8) & 0x7FFFFFFF;
            unsigned int v179 = 0x7FFFFFFF;
            if (v178 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v177 + 80 * v178 + 12) == 122) {
              goto LABEL_206;
            }
          }
        }
      }
    }
    else
    {
      float v180 = v302 / 1000000.0;
      float v181 = v303 / 1000000.0;
      uint64_t v177 = *(void *)(a3 + 16);
      unsigned int v179 = 0x7FFFFFFF;
    }
    float v188 = *(float *)(v177 + 80 * v179 + 48);
    int v189 = *(_DWORD *)(a1 + 8);
    double v190 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v193 = NAN;
        goto LABEL_229;
      }
      LODWORD(v191) = info[0].numer;
      LODWORD(v192) = info[0].denom;
      double v190 = (double)v191 / (double)v192;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v190;
    }
    double v193 = v190 * (double)(unint64_t)(float)(v188 / (float)v189);
LABEL_229:
    if (*(void *)a3)
    {
      uint64_t v204 = *(void *)(a3 + 16);
      uint64_t v205 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
      unsigned int v206 = 0x7FFFFFFF;
      if (v205 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v204 + 80 * v205 + 12) == 129)
        {
LABEL_234:
          unsigned int v206 = v205;
        }
        else
        {
          while (1)
          {
            LODWORD(v205) = *(_DWORD *)(v204 + 80 * v205 + 8) & 0x7FFFFFFF;
            unsigned int v206 = 0x7FFFFFFF;
            if (v205 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v204 + 80 * v205 + 12) == 129) {
              goto LABEL_234;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v204 = *(void *)(a3 + 16);
      unsigned int v206 = 0x7FFFFFFF;
    }
    float v207 = *(float *)(v204 + 80 * v206 + 48);
    int v208 = *(_DWORD *)(a1 + 8);
    double v209 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v210 = v193 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v213 = NAN;
        goto LABEL_253;
      }
      LODWORD(v211) = info[0].numer;
      LODWORD(v212) = info[0].denom;
      double v209 = (double)v211 / (double)v212;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v209;
    }
    double v213 = v209 * (double)(unint64_t)(float)(v207 / (float)v208);
LABEL_253:
    double v225 = v213 / 1000000.0;
    if (*(void *)a3)
    {
      uint64_t v226 = *(void *)(a3 + 16);
      uint64_t v227 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
      unsigned int v228 = 0x7FFFFFFF;
      if (v227 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v226 + 80 * v227 + 12) == 128)
        {
LABEL_258:
          unsigned int v228 = v227;
        }
        else
        {
          while (1)
          {
            LODWORD(v227) = *(_DWORD *)(v226 + 80 * v227 + 8) & 0x7FFFFFFF;
            unsigned int v228 = 0x7FFFFFFF;
            if (v227 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v226 + 80 * v227 + 12) == 128) {
              goto LABEL_258;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v226 = *(void *)(a3 + 16);
      unsigned int v228 = 0x7FFFFFFF;
    }
    double v229 = v210 + v172 + v225;
    float v230 = *(float *)(v226 + 80 * v228 + 48);
    int v231 = *(_DWORD *)(a1 + 8);
    double v232 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v235 = NAN;
LABEL_268:
        uint64_t v237 = v300;
        uint64_t v236 = v301;
        re::DynamicString::appendf((re::DynamicString *)v12, "MainThread Render : %.2f\n", v229 + v235 / 1000000.0);
        re::DynamicString::appendf((re::DynamicString *)v12, "EncodeDrawCalls : %.2f    ECS Render : %.2f\n", v181, v180);
        re::DynamicString::appendf((re::DynamicString *)v12, "Drawables Wait : %.2f    GPU Wait : %.2f\n", v310, v141);
        int v238 = 10;
        goto LABEL_269;
      }
      LODWORD(v233) = info[0].numer;
      LODWORD(v234) = info[0].denom;
      double v232 = (double)v233 / (double)v234;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v232;
    }
    double v235 = v232 * (double)(unint64_t)(float)(v230 / (float)v231);
    goto LABEL_268;
  }
  if (*(void *)a3)
  {
    uint64_t v173 = *(void *)(a3 + 16);
    uint64_t v174 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    unsigned int v175 = 0x7FFFFFFF;
    float v176 = v303 / 1000000.0;
    if (v174 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v173 + 80 * v174 + 12) == 122)
      {
LABEL_200:
        unsigned int v175 = v174;
      }
      else
      {
        while (1)
        {
          LODWORD(v174) = *(_DWORD *)(v173 + 80 * v174 + 8) & 0x7FFFFFFF;
          unsigned int v175 = 0x7FFFFFFF;
          if (v174 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v173 + 80 * v174 + 12) == 122) {
            goto LABEL_200;
          }
        }
      }
    }
  }
  else
  {
    float v176 = v303 / 1000000.0;
    uint64_t v173 = *(void *)(a3 + 16);
    unsigned int v175 = 0x7FFFFFFF;
  }
  float v182 = *(float *)(v173 + 80 * v175 + 48);
  int v183 = *(_DWORD *)(a1 + 8);
  double v184 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v187 = NAN;
      goto LABEL_217;
    }
    LODWORD(v185) = info[0].numer;
    LODWORD(v186) = info[0].denom;
    double v184 = (double)v185 / (double)v186;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v184;
  }
  double v187 = v184 * (double)(unint64_t)(float)(v182 / (float)v183);
LABEL_217:
  if (*(void *)a3)
  {
    uint64_t v194 = *(void *)(a3 + 16);
    uint64_t v195 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    unsigned int v196 = 0x7FFFFFFF;
    if (v195 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v194 + 80 * v195 + 12) == 129)
      {
LABEL_222:
        unsigned int v196 = v195;
      }
      else
      {
        while (1)
        {
          LODWORD(v195) = *(_DWORD *)(v194 + 80 * v195 + 8) & 0x7FFFFFFF;
          unsigned int v196 = 0x7FFFFFFF;
          if (v195 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v194 + 80 * v195 + 12) == 129) {
            goto LABEL_222;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v194 = *(void *)(a3 + 16);
    unsigned int v196 = 0x7FFFFFFF;
  }
  float v197 = *(float *)(v194 + 80 * v196 + 48);
  int v198 = *(_DWORD *)(a1 + 8);
  double v199 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v200 = v187 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v203 = NAN;
      goto LABEL_241;
    }
    LODWORD(v201) = info[0].numer;
    LODWORD(v202) = info[0].denom;
    double v199 = (double)v201 / (double)v202;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v199;
  }
  double v203 = v199 * (double)(unint64_t)(float)(v197 / (float)v198);
LABEL_241:
  double v214 = v203 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v215 = *(void *)(a3 + 16);
    uint64_t v216 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    unsigned int v217 = 0x7FFFFFFF;
    if (v216 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v215 + 80 * v216 + 12) == 128)
      {
LABEL_246:
        unsigned int v217 = v216;
      }
      else
      {
        while (1)
        {
          LODWORD(v216) = *(_DWORD *)(v215 + 80 * v216 + 8) & 0x7FFFFFFF;
          unsigned int v217 = 0x7FFFFFFF;
          if (v216 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v215 + 80 * v216 + 12) == 128) {
            goto LABEL_246;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v215 = *(void *)(a3 + 16);
    unsigned int v217 = 0x7FFFFFFF;
  }
  double v218 = v200 + v172 + v214;
  float v219 = *(float *)(v215 + 80 * v217 + 48);
  int v220 = *(_DWORD *)(a1 + 8);
  double v221 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
    goto LABEL_264;
  }
  if (!mach_timebase_info(info))
  {
    LODWORD(v222) = info[0].numer;
    LODWORD(v223) = info[0].denom;
    double v221 = (double)v222 / (double)v223;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v221;
LABEL_264:
    double v224 = v221 * (double)(unint64_t)(float)(v219 / (float)v220);
    goto LABEL_265;
  }
  double v224 = NAN;
LABEL_265:
  uint64_t v237 = v300;
  uint64_t v236 = v301;
  re::DynamicString::appendf((re::DynamicString *)v12, "RenderThread : %.2f    MainThread Render : %.2f\n", (float)((float)((float)(v308 - v310) - v126) - v306), v218 + v224 / 1000000.0);
  float v304 = v302 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v12, "EncodeDrawCalls : %.2f    ECS Render : %.2f\n", v176, v304);
  re::DynamicString::appendf((re::DynamicString *)v12, "Drawables Wait : %.2f    GPU Wait : %.2f\n", v310, v126);
  re::DynamicString::appendf((re::DynamicString *)v12, "Render Thread Sync Latency: %.2f\n", v299);
  int v238 = 11;
LABEL_269:
  uint64_t v239 = v236 + (v237 << 6);
  *(_DWORD *)(v239 + 48) = v238;
  *(void *)(v239 + 52) = 0x10000000032;
  info[0].numer = 1;
  BOOL v240 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(a2, (unsigned int *)info);
  if (!v240)
  {
    *(_OWORD *)&info[0].numer = 0u;
    long long v313 = 0u;
    re::DynamicString::setCapacity(info, 0);
    uint64_t v314 = 0x2800000006;
    int v315 = 1;
    int v311 = 1;
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(a2, &v311, (re::DynamicString *)info);
    if (info[0])
    {
      if (info[1].numer) {
        (*(void (**)(void))(**(void **)info + 40))();
      }
    }
  }
  if (*(void *)a2)
  {
    uint64_t v241 = *(void *)(a2 + 16);
    for (uint64_t i = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a2 + 24)));
          ;
          uint64_t i = *(_DWORD *)(v241 + (i << 6) + 8) & 0x7FFFFFFF)
    {
      unsigned int v243 = 0x7FFFFFFF;
      if (i == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v241 + (i << 6) + 12) == 1)
      {
        unsigned int v243 = i;
        break;
      }
    }
  }
  else
  {
    uint64_t v241 = *(void *)(a2 + 16);
    unsigned int v243 = 0x7FFFFFFF;
  }
  uint64_t v244 = v243;
  uint64_t v245 = v241 + ((unint64_t)v243 << 6);
  int v246 = (void *)(v245 + 16);
  uint64_t v247 = *(void *)(v245 + 24);
  if (v247)
  {
    v246[1] = 1;
    float v248 = (unsigned char *)v246[2];
  }
  else
  {
    *((unsigned char *)v246 + 8) = v247 & 1;
    float v248 = (char *)v246 + 9;
  }
  *float v248 = 0;
  re::DynamicString::appendf((re::DynamicString *)v246, "Metal Heap Allocation Stats Per Frame [MB]\n");
  if (!*(void *)a3)
  {
    uint64_t v250 = *(void *)(a3 + 16);
    float v253 = (float)*(int *)(a1 + 8);
    float v254 = *(float *)(v250 + 0x27FFFFFFE0) / v253;
    unsigned int v255 = 0x7FFFFFFF;
    goto LABEL_297;
  }
  unint64_t v249 = *(unsigned int *)(a3 + 24);
  uint64_t v251 = *(void *)(a3 + 8);
  uint64_t v250 = *(void *)(a3 + 16);
  uint64_t v252 = *(unsigned int *)(v251 + 4 * (0x87D70AD2CA29B0ALL % v249));
  if (v252 == 0x7FFFFFFF)
  {
    LODWORD(v252) = 0x7FFFFFFF;
LABEL_288:
    uint64_t v256 = v250 + 80 * v252;
    goto LABEL_292;
  }
  if (*(unsigned char *)(v250 + 80 * v252 + 12) == 80) {
    goto LABEL_288;
  }
  do
    LODWORD(v252) = *(_DWORD *)(v250 + 80 * v252 + 8) & 0x7FFFFFFF;
  while (v252 != 0x7FFFFFFF && *(unsigned char *)(v250 + 80 * v252 + 12) != 80);
  uint64_t v256 = v250 + 80 * v252;
LABEL_292:
  float v253 = (float)*(int *)(a1 + 8);
  float v254 = *(float *)(v256 + 48) / v253;
  uint64_t v257 = *(unsigned int *)(v251 + 4 * (0x8B37E5E0A757936CLL % v249));
  unsigned int v255 = 0x7FFFFFFF;
  if (v257 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v250 + 80 * v257 + 12) == 81)
    {
LABEL_296:
      unsigned int v255 = v257;
    }
    else
    {
      while (1)
      {
        LODWORD(v257) = *(_DWORD *)(v250 + 80 * v257 + 8) & 0x7FFFFFFF;
        unsigned int v255 = 0x7FFFFFFF;
        if (v257 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v250 + 80 * v257 + 12) == 81) {
          goto LABEL_296;
        }
      }
    }
  }
LABEL_297:
  re::DynamicString::appendf((re::DynamicString *)v246, "Heaps : %.0f, Heap Memory [MB]: %.2f\n", v254, (float)((float)((float)(*(float *)(v250 + 80 * v255 + 48) / v253) * 0.00097656) * 0.00097656));
  if (!*(void *)a3)
  {
    uint64_t v259 = *(void *)(a3 + 16);
    float v262 = (float)*(int *)(a1 + 8);
    float v263 = *(float *)(v259 + 0x27FFFFFFE0) / v262;
    unsigned int v264 = 0x7FFFFFFF;
    goto LABEL_311;
  }
  unint64_t v258 = *(unsigned int *)(a3 + 24);
  uint64_t v260 = *(void *)(a3 + 8);
  uint64_t v259 = *(void *)(a3 + 16);
  uint64_t v261 = *(unsigned int *)(v260 + 4 * (0x33C617428BBAA70BLL % v258));
  if (v261 == 0x7FFFFFFF)
  {
    LODWORD(v261) = 0x7FFFFFFF;
LABEL_302:
    uint64_t v265 = v259 + 80 * v261;
    goto LABEL_306;
  }
  if (*(unsigned char *)(v259 + 80 * v261 + 12) == 82) {
    goto LABEL_302;
  }
  do
    LODWORD(v261) = *(_DWORD *)(v259 + 80 * v261 + 8) & 0x7FFFFFFF;
  while (v261 != 0x7FFFFFFF && *(unsigned char *)(v259 + 80 * v261 + 12) != 82);
  uint64_t v265 = v259 + 80 * v261;
LABEL_306:
  float v262 = (float)*(int *)(a1 + 8);
  float v263 = *(float *)(v265 + 48) / v262;
  uint64_t v266 = *(unsigned int *)(v260 + 4 * (0x45F79258E41B3AE0 % v258));
  unsigned int v264 = 0x7FFFFFFF;
  if (v266 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v259 + 80 * v266 + 12) == 83)
    {
LABEL_310:
      unsigned int v264 = v266;
    }
    else
    {
      while (1)
      {
        LODWORD(v266) = *(_DWORD *)(v259 + 80 * v266 + 8) & 0x7FFFFFFF;
        unsigned int v264 = 0x7FFFFFFF;
        if (v266 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v259 + 80 * v266 + 12) == 83) {
          goto LABEL_310;
        }
      }
    }
  }
LABEL_311:
  re::DynamicString::appendf((re::DynamicString *)v246, "Protected Heaps : %.0f, Heap Memory [MB]: %.2f\n", v263, (float)((float)((float)(*(float *)(v259 + 80 * v264 + 48) / v262) * 0.00097656) * 0.00097656));
  if (*(void *)a3)
  {
    uint64_t v267 = *(void *)(a3 + 16);
    uint64_t v268 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAA2D7708F2A6F456 % *(unsigned int *)(a3 + 24)));
    unsigned int v269 = 0x7FFFFFFF;
    if (v268 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v267 + 80 * v268 + 12) == 90)
      {
LABEL_316:
        unsigned int v269 = v268;
      }
      else
      {
        while (1)
        {
          LODWORD(v268) = *(_DWORD *)(v267 + 80 * v268 + 8) & 0x7FFFFFFF;
          unsigned int v269 = 0x7FFFFFFF;
          if (v268 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v267 + 80 * v268 + 12) == 90) {
            goto LABEL_316;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v267 = *(void *)(a3 + 16);
    unsigned int v269 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Peak Frame Memory : %.2f\n", (float)((float)((float)(*(float *)(v267 + 80 * v269 + 48) / (float)*(int *)(a1 + 8)) * 0.00097656) * 0.00097656));
  if (*(void *)a3)
  {
    uint64_t v270 = *(void *)(a3 + 16);
    uint64_t v271 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAA2D7708F2A6F456 % *(unsigned int *)(a3 + 24)));
    unsigned int v272 = 0x7FFFFFFF;
    if (v271 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v270 + 80 * v271 + 12) == 90)
      {
LABEL_323:
        unsigned int v272 = v271;
      }
      else
      {
        while (1)
        {
          LODWORD(v271) = *(_DWORD *)(v270 + 80 * v271 + 8) & 0x7FFFFFFF;
          unsigned int v272 = 0x7FFFFFFF;
          if (v271 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v270 + 80 * v271 + 12) == 90) {
            goto LABEL_323;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v270 = *(void *)(a3 + 16);
    unsigned int v272 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Max of all Peaks : %.2f\n", (float)((float)(*(float *)(v270 + 80 * v272 + 64) * 0.00097656) * 0.00097656));
  if (!*(void *)a3)
  {
    uint64_t v274 = *(void *)(a3 + 16);
    float v277 = (float)*(int *)(a1 + 8);
    float v278 = *(float *)(v274 + 0x27FFFFFFE0) / v277;
    unsigned int v279 = 0x7FFFFFFF;
    goto LABEL_339;
  }
  unint64_t v273 = *(unsigned int *)(a3 + 24);
  uint64_t v275 = *(void *)(a3 + 8);
  uint64_t v274 = *(void *)(a3 + 16);
  uint64_t v276 = *(unsigned int *)(v275 + 4 * (0xE3841E098FBC6AD9 % v273));
  if (v276 == 0x7FFFFFFF)
  {
    LODWORD(v276) = 0x7FFFFFFF;
LABEL_330:
    uint64_t v280 = v274 + 80 * v276;
    goto LABEL_334;
  }
  if (*(unsigned char *)(v274 + 80 * v276 + 12) == 84) {
    goto LABEL_330;
  }
  do
    LODWORD(v276) = *(_DWORD *)(v274 + 80 * v276 + 8) & 0x7FFFFFFF;
  while (v276 != 0x7FFFFFFF && *(unsigned char *)(v274 + 80 * v276 + 12) != 84);
  uint64_t v280 = v274 + 80 * v276;
LABEL_334:
  float v277 = (float)*(int *)(a1 + 8);
  float v278 = *(float *)(v280 + 48) / v277;
  uint64_t v281 = *(unsigned int *)(v275 + 4 * (0x8505BE27DEF25DA7 % v273));
  unsigned int v279 = 0x7FFFFFFF;
  if (v281 != 0x7FFFFFFF)
  {
    if (*(unsigned char *)(v274 + 80 * v281 + 12) == 85)
    {
LABEL_338:
      unsigned int v279 = v281;
    }
    else
    {
      while (1)
      {
        LODWORD(v281) = *(_DWORD *)(v274 + 80 * v281 + 8) & 0x7FFFFFFF;
        unsigned int v279 = 0x7FFFFFFF;
        if (v281 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned char *)(v274 + 80 * v281 + 12) == 85) {
          goto LABEL_338;
        }
      }
    }
  }
LABEL_339:
  re::DynamicString::appendf((re::DynamicString *)v246, "Textures: %.0f, Memoryless Textures: %.0f\n", v278, (float)(*(float *)(v274 + 80 * v279 + 48) / v277));
  if (*(void *)a3)
  {
    uint64_t v282 = *(void *)(a3 + 16);
    uint64_t v283 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xCF15A836B33FD539 % *(unsigned int *)(a3 + 24)));
    unsigned int v284 = 0x7FFFFFFF;
    if (v283 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v282 + 80 * v283 + 12) == 87)
      {
LABEL_344:
        unsigned int v284 = v283;
      }
      else
      {
        while (1)
        {
          LODWORD(v283) = *(_DWORD *)(v282 + 80 * v283 + 8) & 0x7FFFFFFF;
          unsigned int v284 = 0x7FFFFFFF;
          if (v283 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v282 + 80 * v283 + 12) == 87) {
            goto LABEL_344;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v282 = *(void *)(a3 + 16);
    unsigned int v284 = 0x7FFFFFFF;
  }
  double v285 = (float)((float)((float)(*(float *)(v282 + 80 * v284 + 48) / (float)*(int *)(a1 + 8)) * 0.00097656)
               * 0.00097656);
  unsigned int v286 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v287 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)));
    if (v287 != 0x7FFFFFFF)
    {
      unsigned int v286 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)));
      if (*(unsigned char *)(v282 + 80 * v287 + 12) != 88)
      {
        while (1)
        {
          unsigned int v286 = *(_DWORD *)(v282
                           + 80
                           * *(unsigned int *)(*(void *)(a3 + 8)
                                             + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)))
                           + 8) & 0x7FFFFFFF;
          if (v286 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v282 + 80 * v286 + 12) == 88) {
            goto LABEL_353;
          }
        }
        unsigned int v286 = 0x7FFFFFFF;
      }
    }
  }
LABEL_353:
  re::DynamicString::appendf((re::DynamicString *)v246, "Texture Memory: %.2f, Largest Texture: %.2f\n", v285, (float)((float)(*(float *)(v282 + 80 * v286 + 44) * 0.00097656) * 0.00097656));
  if (*(void *)a3)
  {
    unint64_t v288 = *(unsigned int *)(a3 + 24);
    uint64_t v290 = *(void *)(a3 + 8);
    uint64_t v289 = *(void *)(a3 + 16);
    unsigned int v291 = *(_DWORD *)(v290 + 4 * (0x9E14C3B38F31B195 % v288));
    unsigned int v292 = 0x7FFFFFFF;
    unsigned int v293 = 0x7FFFFFFF;
    if (v291 != 0x7FFFFFFF)
    {
      unsigned int v293 = *(_DWORD *)(v290 + 4 * (0x9E14C3B38F31B195 % v288));
      if (*(unsigned char *)(v289 + 80 * v291 + 12) != 86)
      {
        while (1)
        {
          unsigned int v293 = *(_DWORD *)(v289 + 80 * *(unsigned int *)(v290 + 4 * (0x9E14C3B38F31B195 % v288)) + 8) & 0x7FFFFFFF;
          if (v293 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v289 + 80 * v293 + 12) == 86) {
            goto LABEL_361;
          }
        }
        unsigned int v293 = 0x7FFFFFFF;
      }
    }
LABEL_361:
    float v294 = *(float *)(v289 + 80 * v293 + 48);
    int v295 = *(_DWORD *)(a1 + 8);
    uint64_t v296 = *(unsigned int *)(v290 + 4 * (0x1D3169FBB198C267 % v288));
    if (v296 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v289 + 80 * v296 + 12) == 89)
      {
LABEL_365:
        unsigned int v292 = v296;
      }
      else
      {
        while (1)
        {
          LODWORD(v296) = *(_DWORD *)(v289 + 80 * v296 + 8) & 0x7FFFFFFF;
          unsigned int v292 = 0x7FFFFFFF;
          if (v296 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v289 + 80 * v296 + 12) == 89) {
            goto LABEL_365;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v289 = *(void *)(a3 + 16);
    float v294 = *(float *)(v289 + 0x27FFFFFFE0);
    int v295 = *(_DWORD *)(a1 + 8);
    unsigned int v292 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Buffers : %.0f, Total Buffer Memory : %.2f\n", (float)(v294 / (float)v295), (float)((float)((float)(*(float *)(v289 + 80 * v292 + 48) / (float)v295) * 0.00097656) * 0.00097656));
  uint64_t v297 = v241 + (v244 << 6);
  *(void *)&double result = 0x3200000007;
  *(void *)(v297 + 48) = 0x3200000007;
  *(_DWORD *)(v297 + 56) = 256;
  return result;
}

re::FrameMemoryStats *re::FrameMemoryStats::FrameMemoryStats(re::FrameMemoryStats *this)
{
  *((_DWORD *)this + 2) = 10;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(void *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((unsigned char *)this + 64) = 0;
  *(void *)this = &unk_26E717720;
  *((void *)this + 9) = 0;
  getpid();
  memorystatus_control();
  *((void *)this + 9) = 0;
  return this;
}

uint64_t re::FrameMemoryStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2)
{
  LODWORD(v3) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v4 = **(unsigned int **)(a2 + 8);
    if (v4 != 0x7FFFFFFF)
    {
      uint64_t v5 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v5 + (v4 << 6) + 12))
      {
        uint64_t v3 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
          if (v3 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v5 + (v3 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v3) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = v3;
  uint64_t v8 = v6 + ((unint64_t)v3 << 6);
  uint64_t v9 = (void *)(v8 + 16);
  uint64_t v10 = *(void *)(v8 + 24);
  if (v10)
  {
    v9[1] = 1;
    uint64_t v11 = (unsigned char *)v9[2];
  }
  else
  {
    *((unsigned char *)v9 + 8) = v10 & 1;
    uint64_t v11 = (char *)v9 + 9;
  }
  *uint64_t v11 = 0;
  re::DynamicString::append((re::DynamicString *)v9, "Process Memory Usage [MB]\n", 0x1AuLL);
  mach_msg_type_number_t task_info_outCnt = 93;
  task_info(*MEMORY[0x263EF8960], 0x16u, task_info_out, &task_info_outCnt);
  re::DynamicString::appendf((re::DynamicString *)v9, "Dirty Memory Footprint : %.2f\n", (float)((float)((float)v15 * 0.00097656) * 0.00097656));
  re::DynamicString::appendf((re::DynamicString *)v9, "Peak Dirty Memory Footprint : %.2f\n", (float)((float)((float)v16 * 0.00097656) * 0.00097656));
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v9, "Memory Limit : %.2f\n", (float)((float)((float)*(unint64_t *)(a1 + 72) * 0.00097656) * 0.00097656));
  *(_DWORD *)(v6 + (v7 << 6) + 56) = 512;
  return result;
}

uint64_t re::FrameThermalStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2)
{
  LODWORD(v3) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v4 = **(unsigned int **)(a2 + 8);
    if (v4 != 0x7FFFFFFF)
    {
      uint64_t v5 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v5 + (v4 << 6) + 12))
      {
        uint64_t v3 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
          if (v3 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v5 + (v3 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v3) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = v3;
  uint64_t v8 = v6 + ((unint64_t)v3 << 6);
  uint64_t v9 = (void *)(v8 + 16);
  uint64_t v10 = *(void *)(v8 + 24);
  if (v10)
  {
    v9[1] = 1;
    uint64_t v11 = (unsigned char *)v9[2];
  }
  else
  {
    *((unsigned char *)v9 + 8) = v10 & 1;
    uint64_t v11 = (char *)v9 + 9;
  }
  *uint64_t v11 = 0;
  re::DynamicString::append((re::DynamicString *)v9, "App Thermal Info\n", 0x11uLL);
  uint64_t v12 = [MEMORY[0x263F08AB0] processInfo];
  uint64_t v13 = [v12 thermalState];

  switch(v13)
  {
    case 2:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Serious\n");
      if (*(unsigned __int16 *)(a1 + 90) > 2u)
      {
LABEL_39:
        __int16 v35 = 3;
        goto LABEL_48;
      }
      uint64_t v19 = mach_absolute_time();
      double v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          double v23 = NAN;
LABEL_38:
          float v36 = v23 / 1000000.0;
          *(float *)(a1 + 76) = v36;
          ++*(_WORD *)(a1 + 88);
          goto LABEL_39;
        }
        LODWORD(v21) = info.numer;
        LODWORD(v22) = info.denom;
        double v20 = (double)v21 / (double)v22;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v20;
      }
      double v23 = v20 * (double)v19;
      goto LABEL_38;
    case 1:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Fair\n");
      if (*(unsigned __int16 *)(a1 + 90) < 3u)
      {
LABEL_43:
        __int16 v35 = 2;
        goto LABEL_48;
      }
      uint64_t v24 = mach_absolute_time();
      double v25 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          double v28 = NAN;
LABEL_42:
          float v37 = v28 / 1000000.0;
          *(float *)(a1 + 80) = v37;
          goto LABEL_43;
        }
        LODWORD(v26) = info.numer;
        LODWORD(v27) = info.denom;
        double v25 = (double)v26 / (double)v27;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v25;
      }
      double v28 = v25 * (double)v24;
      goto LABEL_42;
    case 0:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Nominal\n");
      if (*(unsigned __int16 *)(a1 + 90) < 3u)
      {
LABEL_35:
        __int16 v35 = 1;
        goto LABEL_48;
      }
      uint64_t v14 = mach_absolute_time();
      double v15 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          double v18 = NAN;
LABEL_34:
          float v34 = v18 / 1000000.0;
          *(float *)(a1 + 80) = v34;
          goto LABEL_35;
        }
        LODWORD(v16) = info.numer;
        LODWORD(v17) = info.denom;
        double v15 = (double)v16 / (double)v17;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v15;
      }
      double v18 = v15 * (double)v14;
      goto LABEL_34;
  }
  re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Critical\n");
  if (*(unsigned __int16 *)(a1 + 90) > 2u) {
    goto LABEL_47;
  }
  uint64_t v29 = mach_absolute_time();
  double v30 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
    goto LABEL_45;
  }
  if (!mach_timebase_info(&info))
  {
    LODWORD(v31) = info.numer;
    LODWORD(v32) = info.denom;
    double v30 = (double)v31 / (double)v32;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v30;
LABEL_45:
    double v33 = v30 * (double)v29;
    goto LABEL_46;
  }
  double v33 = NAN;
LABEL_46:
  float v38 = v33 / 1000000.0;
  *(float *)(a1 + 76) = v38;
  ++*(_WORD *)(a1 + 88);
LABEL_47:
  __int16 v35 = 4;
LABEL_48:
  *(_WORD *)(a1 + 90) = v35;
  uint64_t v39 = mach_absolute_time();
  double v40 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v43 = NAN;
      goto LABEL_53;
    }
    LODWORD(v41) = info.numer;
    LODWORD(v42) = info.denom;
    double v40 = (double)v41 / (double)v42;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v40;
  }
  double v43 = v40 * (double)v39;
LABEL_53:
  float v44 = v43 / 1000000.0 - *(float *)(a1 + 84);
  *(float *)(a1 + 68) = v44;
  re::DynamicString::appendf((re::DynamicString *)v9, "Time Since App Launch : %.2f sec\n", (float)(v44 / 1000.0));
  if (*(unsigned __int16 *)(a1 + 90) > 2u) {
    uint64_t result = re::DynamicString::appendf((re::DynamicString *)v9, "Thermally Throttled in %.2f sec\n");
  }
  else {
    uint64_t result = re::DynamicString::appendf((re::DynamicString *)v9, "Not Thermally Throttled\n");
  }
  *(_DWORD *)(v6 + (v7 << 6) + 56) = 1024;
  return result;
}

double re::FrameSceneUnderstandingStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v6) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v7 = **(unsigned int **)(a2 + 8);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        uint64_t v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v10 = v6;
  uint64_t v11 = v9 + ((unint64_t)v6 << 6);
  uint64_t v12 = (void *)(v11 + 16);
  uint64_t v13 = *(void *)(v11 + 24);
  if (v13)
  {
    v12[1] = 1;
    uint64_t v14 = (unsigned char *)v12[2];
  }
  else
  {
    *((unsigned char *)v12 + 8) = v13 & 1;
    uint64_t v14 = (char *)v12 + 9;
  }
  *uint64_t v14 = 0;
  re::DynamicString::appendf((re::DynamicString *)v12, "Scene Understanding Metrics (Profiler Pass)\n");
  unsigned int v15 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v16 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      uint64_t v17 = *(void *)(a3 + 16);
      unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned __int8 *)(v17 + 80 * v16 + 12) != 128)
      {
        while (1)
        {
          unsigned int v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v17 + 80 * v15 + 12) == 128) {
            goto LABEL_20;
          }
        }
        unsigned int v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v18 = *(float *)(*(void *)(a3 + 16) + 80 * v15 + 48);
  int v19 = *(_DWORD *)(a1 + 8);
  double v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info[0].numer;
    LODWORD(v22) = info[0].denom;
    double v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v20;
  }
  double v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v12, "SUProcessingSystem Update (ms): %.2f\n", v23 / 1000000.0);
  if (*(void *)a3)
  {
    uint64_t v24 = *(void *)(a3 + 16);
    uint64_t v25 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    unsigned int v26 = 0x7FFFFFFF;
    if (v25 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 129)
      {
LABEL_30:
        unsigned int v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          unsigned int v26 = 0x7FFFFFFF;
          if (v25 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 129) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a3 + 16);
    unsigned int v26 = 0x7FFFFFFF;
  }
  float v27 = *(float *)(v24 + 80 * v26 + 48);
  int v28 = *(_DWORD *)(a1 + 8);
  double v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info[0].numer;
    LODWORD(v31) = info[0].denom;
    double v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v29;
  }
  double v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v12, "SUMeshSystem Update (ms): %.2f\n", v32 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics Chunk Creation (ms)\n");
  if (*(void *)a3)
  {
    uint64_t v33 = *(void *)(a3 + 16);
    uint64_t v34 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v35 = 0x7FFFFFFF;
    if (v34 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v33 + 80 * v34 + 12) == 133)
      {
LABEL_42:
        unsigned int v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          unsigned int v35 = 0x7FFFFFFF;
          if (v34 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v33 + 80 * v34 + 12) == 133) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v33 = *(void *)(a3 + 16);
    unsigned int v35 = 0x7FFFFFFF;
  }
  float v36 = *(float *)(v33 + 80 * v35 + 56);
  double v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info[0].numer;
    LODWORD(v39) = info[0].denom;
    double v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v37;
  }
  double v40 = v37 * (double)(unint64_t)v36;
LABEL_49:
  if (*(void *)a3)
  {
    uint64_t v41 = *(void *)(a3 + 16);
    uint64_t v42 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v43 = 0x7FFFFFFF;
    if (v42 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v41 + 80 * v42 + 12) == 133)
      {
LABEL_54:
        unsigned int v43 = v42;
      }
      else
      {
        while (1)
        {
          LODWORD(v42) = *(_DWORD *)(v41 + 80 * v42 + 8) & 0x7FFFFFFF;
          unsigned int v43 = 0x7FFFFFFF;
          if (v42 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v41 + 80 * v42 + 12) == 133) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v41 = *(void *)(a3 + 16);
    unsigned int v43 = 0x7FFFFFFF;
  }
  float v44 = *(float *)(v41 + 80 * v43 + 44);
  double v45 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v46 = v40 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v49 = NAN;
      goto LABEL_61;
    }
    LODWORD(v47) = info[0].numer;
    LODWORD(v48) = info[0].denom;
    double v45 = (double)v47 / (double)v48;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v45;
  }
  double v49 = v45 * (double)(unint64_t)v44;
LABEL_61:
  re::DynamicString::appendf((re::DynamicString *)v12, "Avg : %.3f, Max : %.3f\n", v46, v49 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics Chunk Update (ms)\n");
  if (*(void *)a3)
  {
    uint64_t v50 = *(void *)(a3 + 16);
    uint64_t v51 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    unsigned int v52 = 0x7FFFFFFF;
    if (v51 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v50 + 80 * v51 + 12) == 134)
      {
LABEL_66:
        unsigned int v52 = v51;
      }
      else
      {
        while (1)
        {
          LODWORD(v51) = *(_DWORD *)(v50 + 80 * v51 + 8) & 0x7FFFFFFF;
          unsigned int v52 = 0x7FFFFFFF;
          if (v51 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v50 + 80 * v51 + 12) == 134) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v50 = *(void *)(a3 + 16);
    unsigned int v52 = 0x7FFFFFFF;
  }
  float v53 = *(float *)(v50 + 80 * v52 + 56);
  double v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v57 = NAN;
      goto LABEL_73;
    }
    LODWORD(v55) = info[0].numer;
    LODWORD(v56) = info[0].denom;
    double v54 = (double)v55 / (double)v56;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v54;
  }
  double v57 = v54 * (double)(unint64_t)v53;
LABEL_73:
  if (*(void *)a3)
  {
    uint64_t v58 = *(void *)(a3 + 16);
    uint64_t v59 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    unsigned int v60 = 0x7FFFFFFF;
    if (v59 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v58 + 80 * v59 + 12) == 134)
      {
LABEL_78:
        unsigned int v60 = v59;
      }
      else
      {
        while (1)
        {
          LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
          unsigned int v60 = 0x7FFFFFFF;
          if (v59 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v58 + 80 * v59 + 12) == 134) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v58 = *(void *)(a3 + 16);
    unsigned int v60 = 0x7FFFFFFF;
  }
  float v61 = *(float *)(v58 + 80 * v60 + 44);
  double v62 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v63 = v57 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v66 = NAN;
      goto LABEL_85;
    }
    LODWORD(v64) = info[0].numer;
    LODWORD(v65) = info[0].denom;
    double v62 = (double)v64 / (double)v65;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v62;
  }
  double v66 = v62 * (double)(unint64_t)v61;
LABEL_85:
  re::DynamicString::appendf((re::DynamicString *)v12, "Avg : %.3f, Max : %.3f\n", v63, v66 / 1000000.0);
  if (*(void *)a3)
  {
    unint64_t v67 = *(unsigned int *)(a3 + 24);
    uint64_t v69 = *(void *)(a3 + 8);
    uint64_t v68 = *(void *)(a3 + 16);
    uint64_t v70 = *(unsigned int *)(v69 + 4 * (0x3E784199B71EA792 % v67));
    if (v70 == 0x7FFFFFFF)
    {
      LODWORD(v70) = 0x7FFFFFFF;
    }
    else if (*(unsigned __int8 *)(v68 + 80 * v70 + 12) != 136)
    {
      do
        LODWORD(v70) = *(_DWORD *)(v68 + 80 * v70 + 8) & 0x7FFFFFFF;
      while (v70 != 0x7FFFFFFF && *(unsigned __int8 *)(v68 + 80 * v70 + 12) != 136);
    }
    float v74 = *(float *)(v68 + 80 * v70 + 48);
    unsigned int v75 = *(_DWORD *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67));
    unsigned int v76 = 0x7FFFFFFF;
    if (v75 != 0x7FFFFFFF)
    {
      unsigned int v76 = *(_DWORD *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67));
      if (*(unsigned __int8 *)(v68 + 80 * v75 + 12) != 138)
      {
        while (1)
        {
          unsigned int v76 = *(_DWORD *)(v68 + 80 * *(unsigned int *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67)) + 8) & 0x7FFFFFFF;
          if (v76 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v68 + 80 * v76 + 12) == 138) {
            goto LABEL_98;
          }
        }
        unsigned int v76 = 0x7FFFFFFF;
      }
    }
LABEL_98:
    unsigned int v77 = *(_DWORD *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67));
    unsigned int v73 = 0x7FFFFFFF;
    unsigned int v78 = 0x7FFFFFFF;
    if (v77 != 0x7FFFFFFF)
    {
      unsigned int v78 = *(_DWORD *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67));
      if (*(unsigned __int8 *)(v68 + 80 * v77 + 12) != 137)
      {
        while (1)
        {
          unsigned int v78 = *(_DWORD *)(v68 + 80 * *(unsigned int *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67)) + 8) & 0x7FFFFFFF;
          if (v78 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v68 + 80 * v78 + 12) == 137) {
            goto LABEL_104;
          }
        }
        unsigned int v78 = 0x7FFFFFFF;
      }
    }
LABEL_104:
    float v72 = v74 - *(float *)(v68 + 80 * v76 + 48);
    float v71 = *(float *)(v68 + 80 * v78 + 48);
    uint64_t v79 = *(unsigned int *)(v69 + 4 * (0x5CB85FD265949FD2 % v67));
    if (v79 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v68 + 80 * v79 + 12) == 139)
      {
LABEL_108:
        unsigned int v73 = v79;
      }
      else
      {
        while (1)
        {
          LODWORD(v79) = *(_DWORD *)(v68 + 80 * v79 + 8) & 0x7FFFFFFF;
          unsigned int v73 = 0x7FFFFFFF;
          if (v79 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v68 + 80 * v79 + 12) == 139) {
            goto LABEL_108;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v68 = *(void *)(a3 + 16);
    float v71 = *(float *)(v68 + 0x27FFFFFFE0);
    float v72 = v71 - v71;
    unsigned int v73 = 0x7FFFFFFF;
  }
  float v80 = v71 - *(float *)(v68 + 80 * v73 + 48);
  double v81 = v72;
  if (v81 < 0.0) {
    double v81 = 0.0;
  }
  double v82 = v80;
  if (v82 < 0.0) {
    double v82 = 0.0;
  }
  re::DynamicString::appendf((re::DynamicString *)v12, "SU Vertices: %.2f, SU Triangles: %.2f\n", v81, v82);
  uint64_t v83 = v9 + (v10 << 6);
  *(_DWORD *)(v83 + 56) = 2048;
  *(void *)(v83 + 48) = 0x2D00000008;
  info[0].numer = 1;
  BOOL v84 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(a2, (unsigned int *)info);
  if (!v84)
  {
    *(_OWORD *)&info[0].numer = 0u;
    long long v179 = 0u;
    re::DynamicString::setCapacity(info, 0);
    uint64_t v180 = 0x2800000006;
    int v181 = 1;
    int v177 = 1;
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(a2, &v177, (re::DynamicString *)info);
    if (info[0])
    {
      if (info[1].numer) {
        (*(void (**)(void))(**(void **)info + 40))();
      }
    }
  }
  if (*(void *)a2)
  {
    uint64_t v85 = *(void *)(a2 + 16);
    for (uint64_t i = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a2 + 24)));
          ;
          uint64_t i = *(_DWORD *)(v85 + (i << 6) + 8) & 0x7FFFFFFF)
    {
      unsigned int v87 = 0x7FFFFFFF;
      if (i == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v85 + (i << 6) + 12) == 1)
      {
        unsigned int v87 = i;
        break;
      }
    }
  }
  else
  {
    uint64_t v85 = *(void *)(a2 + 16);
    unsigned int v87 = 0x7FFFFFFF;
  }
  uint64_t v88 = v87;
  uint64_t v89 = v85 + ((unint64_t)v87 << 6);
  float v90 = (void *)(v89 + 16);
  uint64_t v91 = *(void *)(v89 + 24);
  if (v91)
  {
    v90[1] = 1;
    double v92 = (unsigned char *)v90[2];
  }
  else
  {
    *((unsigned char *)v90 + 8) = v91 & 1;
    double v92 = (char *)v90 + 9;
  }
  *double v92 = 0;
  re::DynamicString::appendf((re::DynamicString *)v90, "Scene Understanding Metrics (App Lifetime)\n");
  re::DynamicString::appendf((re::DynamicString *)v90, "SUProcessingSystem Update (s)\n");
  if (*(void *)a3)
  {
    uint64_t v93 = *(void *)(a3 + 16);
    uint64_t v94 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    unsigned int v95 = 0x7FFFFFFF;
    if (v94 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v93 + 80 * v94 + 12) == 128)
      {
LABEL_132:
        unsigned int v95 = v94;
      }
      else
      {
        while (1)
        {
          LODWORD(v94) = *(_DWORD *)(v93 + 80 * v94 + 8) & 0x7FFFFFFF;
          unsigned int v95 = 0x7FFFFFFF;
          if (v94 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v93 + 80 * v94 + 12) == 128) {
            goto LABEL_132;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v93 = *(void *)(a3 + 16);
    unsigned int v95 = 0x7FFFFFFF;
  }
  float v96 = *(float *)(v93 + 80 * v95 + 76);
  double v97 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v100 = NAN;
      goto LABEL_139;
    }
    LODWORD(v98) = info[0].numer;
    LODWORD(v99) = info[0].denom;
    double v97 = (double)v98 / (double)v99;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v97;
  }
  double v100 = v97 * (double)(unint64_t)(float)(v96 / 1000.0);
LABEL_139:
  if (*(void *)a3)
  {
    uint64_t v101 = *(void *)(a3 + 16);
    uint64_t v102 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    unsigned int v103 = 0x7FFFFFFF;
    if (v102 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v101 + 80 * v102 + 12) == 128)
      {
LABEL_144:
        unsigned int v103 = v102;
      }
      else
      {
        while (1)
        {
          LODWORD(v102) = *(_DWORD *)(v101 + 80 * v102 + 8) & 0x7FFFFFFF;
          unsigned int v103 = 0x7FFFFFFF;
          if (v102 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v101 + 80 * v102 + 12) == 128) {
            goto LABEL_144;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v101 = *(void *)(a3 + 16);
    unsigned int v103 = 0x7FFFFFFF;
  }
  float v104 = *(float *)(v101 + 80 * v103 + 64);
  double v105 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v106 = v100 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v109 = NAN;
      goto LABEL_151;
    }
    LODWORD(v107) = info[0].numer;
    LODWORD(v108) = info[0].denom;
    double v105 = (double)v107 / (double)v108;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v105;
  }
  double v109 = v105 * (double)(unint64_t)(float)(v104 / 1000.0);
LABEL_151:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v106, v109 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "SUMeshSystem Update (s)\n");
  if (*(void *)a3)
  {
    uint64_t v110 = *(void *)(a3 + 16);
    uint64_t v111 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    unsigned int v112 = 0x7FFFFFFF;
    if (v111 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v110 + 80 * v111 + 12) == 129)
      {
LABEL_156:
        unsigned int v112 = v111;
      }
      else
      {
        while (1)
        {
          LODWORD(v111) = *(_DWORD *)(v110 + 80 * v111 + 8) & 0x7FFFFFFF;
          unsigned int v112 = 0x7FFFFFFF;
          if (v111 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v110 + 80 * v111 + 12) == 129) {
            goto LABEL_156;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v110 = *(void *)(a3 + 16);
    unsigned int v112 = 0x7FFFFFFF;
  }
  float v113 = *(float *)(v110 + 80 * v112 + 76);
  double v114 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v117 = NAN;
      goto LABEL_163;
    }
    LODWORD(v115) = info[0].numer;
    LODWORD(v116) = info[0].denom;
    double v114 = (double)v115 / (double)v116;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v114;
  }
  double v117 = v114 * (double)(unint64_t)(float)(v113 / 1000.0);
LABEL_163:
  if (*(void *)a3)
  {
    uint64_t v118 = *(void *)(a3 + 16);
    uint64_t v119 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    unsigned int v120 = 0x7FFFFFFF;
    if (v119 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v118 + 80 * v119 + 12) == 129)
      {
LABEL_168:
        unsigned int v120 = v119;
      }
      else
      {
        while (1)
        {
          LODWORD(v119) = *(_DWORD *)(v118 + 80 * v119 + 8) & 0x7FFFFFFF;
          unsigned int v120 = 0x7FFFFFFF;
          if (v119 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v118 + 80 * v119 + 12) == 129) {
            goto LABEL_168;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v118 = *(void *)(a3 + 16);
    unsigned int v120 = 0x7FFFFFFF;
  }
  float v121 = *(float *)(v118 + 80 * v120 + 64);
  double v122 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v123 = v117 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v126 = NAN;
      goto LABEL_175;
    }
    LODWORD(v124) = info[0].numer;
    LODWORD(v125) = info[0].denom;
    double v122 = (double)v124 / (double)v125;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v122;
  }
  double v126 = v122 * (double)(unint64_t)(float)(v121 / 1000.0);
LABEL_175:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v123, v126 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "Physics Chunk Creation (s)\n");
  if (*(void *)a3)
  {
    uint64_t v127 = *(void *)(a3 + 16);
    uint64_t v128 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v129 = 0x7FFFFFFF;
    if (v128 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v127 + 80 * v128 + 12) == 133)
      {
LABEL_180:
        unsigned int v129 = v128;
      }
      else
      {
        while (1)
        {
          LODWORD(v128) = *(_DWORD *)(v127 + 80 * v128 + 8) & 0x7FFFFFFF;
          unsigned int v129 = 0x7FFFFFFF;
          if (v128 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v127 + 80 * v128 + 12) == 133) {
            goto LABEL_180;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v127 = *(void *)(a3 + 16);
    unsigned int v129 = 0x7FFFFFFF;
  }
  float v130 = *(float *)(v127 + 80 * v129 + 76);
  double v131 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v134 = NAN;
      goto LABEL_187;
    }
    LODWORD(v132) = info[0].numer;
    LODWORD(v133) = info[0].denom;
    double v131 = (double)v132 / (double)v133;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v131;
  }
  double v134 = v131 * (double)(unint64_t)(float)(v130 / 1000.0);
LABEL_187:
  if (*(void *)a3)
  {
    uint64_t v135 = *(void *)(a3 + 16);
    uint64_t v136 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v137 = 0x7FFFFFFF;
    if (v136 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v135 + 80 * v136 + 12) == 133)
      {
LABEL_192:
        unsigned int v137 = v136;
      }
      else
      {
        while (1)
        {
          LODWORD(v136) = *(_DWORD *)(v135 + 80 * v136 + 8) & 0x7FFFFFFF;
          unsigned int v137 = 0x7FFFFFFF;
          if (v136 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v135 + 80 * v136 + 12) == 133) {
            goto LABEL_192;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v135 = *(void *)(a3 + 16);
    unsigned int v137 = 0x7FFFFFFF;
  }
  float v138 = *(float *)(v135 + 80 * v137 + 64);
  double v139 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v140 = v134 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v143 = NAN;
      goto LABEL_199;
    }
    LODWORD(v141) = info[0].numer;
    LODWORD(v142) = info[0].denom;
    double v139 = (double)v141 / (double)v142;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v139;
  }
  double v143 = v139 * (double)(unint64_t)(float)(v138 / 1000.0);
LABEL_199:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v140, v143 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "Physics Chunk Update (s)\n");
  if (*(void *)a3)
  {
    uint64_t v144 = *(void *)(a3 + 16);
    uint64_t v145 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    unsigned int v146 = 0x7FFFFFFF;
    if (v145 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v144 + 80 * v145 + 12) == 134)
      {
LABEL_204:
        unsigned int v146 = v145;
      }
      else
      {
        while (1)
        {
          LODWORD(v145) = *(_DWORD *)(v144 + 80 * v145 + 8) & 0x7FFFFFFF;
          unsigned int v146 = 0x7FFFFFFF;
          if (v145 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v144 + 80 * v145 + 12) == 134) {
            goto LABEL_204;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v144 = *(void *)(a3 + 16);
    unsigned int v146 = 0x7FFFFFFF;
  }
  float v147 = *(float *)(v144 + 80 * v146 + 76);
  double v148 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v151 = NAN;
      goto LABEL_211;
    }
    LODWORD(v149) = info[0].numer;
    LODWORD(v150) = info[0].denom;
    double v148 = (double)v149 / (double)v150;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v148;
  }
  double v151 = v148 * (double)(unint64_t)(float)(v147 / 1000.0);
LABEL_211:
  if (*(void *)a3)
  {
    uint64_t v152 = *(void *)(a3 + 16);
    uint64_t v153 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    unsigned int v154 = 0x7FFFFFFF;
    if (v153 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v152 + 80 * v153 + 12) == 134)
      {
LABEL_216:
        unsigned int v154 = v153;
      }
      else
      {
        while (1)
        {
          LODWORD(v153) = *(_DWORD *)(v152 + 80 * v153 + 8) & 0x7FFFFFFF;
          unsigned int v154 = 0x7FFFFFFF;
          if (v153 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v152 + 80 * v153 + 12) == 134) {
            goto LABEL_216;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v152 = *(void *)(a3 + 16);
    unsigned int v154 = 0x7FFFFFFF;
  }
  float v155 = *(float *)(v152 + 80 * v154 + 64);
  double v156 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  double v157 = v151 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      double v160 = NAN;
      goto LABEL_223;
    }
    LODWORD(v158) = info[0].numer;
    LODWORD(v159) = info[0].denom;
    double v156 = (double)v158 / (double)v159;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v156;
  }
  double v160 = v156 * (double)(unint64_t)(float)(v155 / 1000.0);
LABEL_223:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v157, v160 / 1000000.0);
  if (!*(void *)a3)
  {
    uint64_t v162 = *(void *)(a3 + 16);
    float v165 = *(float *)(v162 + 0x27FFFFFFF4);
    float v166 = v165 - v165;
    unsigned int v167 = 0x7FFFFFFF;
    goto LABEL_247;
  }
  unint64_t v161 = *(unsigned int *)(a3 + 24);
  uint64_t v163 = *(void *)(a3 + 8);
  uint64_t v162 = *(void *)(a3 + 16);
  uint64_t v164 = *(unsigned int *)(v163 + 4 * (0x3E784199B71EA792 % v161));
  if (v164 == 0x7FFFFFFF) {
    goto LABEL_225;
  }
  if (*(unsigned __int8 *)(v162 + 80 * v164 + 12) != 136)
  {
    while (1)
    {
      LODWORD(v164) = *(_DWORD *)(v162 + 80 * v164 + 8) & 0x7FFFFFFF;
      if (v164 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned __int8 *)(v162 + 80 * v164 + 12) == 136) {
        goto LABEL_230;
      }
    }
LABEL_225:
    LODWORD(v164) = 0x7FFFFFFF;
  }
LABEL_230:
  uint64_t v168 = v162 + 80 * v164;
  unsigned int v169 = *(_DWORD *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161));
  unsigned int v170 = 0x7FFFFFFF;
  if (v169 != 0x7FFFFFFF)
  {
    unsigned int v170 = *(_DWORD *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161));
    if (*(unsigned __int8 *)(v162 + 80 * v169 + 12) != 138)
    {
      while (1)
      {
        unsigned int v170 = *(_DWORD *)(v162 + 80 * *(unsigned int *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161)) + 8) & 0x7FFFFFFF;
        if (v170 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v162 + 80 * v170 + 12) == 138) {
          goto LABEL_236;
        }
      }
      unsigned int v170 = 0x7FFFFFFF;
    }
  }
LABEL_236:
  float v171 = *(float *)(v162 + 80 * v170 + 68);
  unsigned int v172 = *(_DWORD *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161));
  unsigned int v167 = 0x7FFFFFFF;
  unsigned int v173 = 0x7FFFFFFF;
  if (v172 != 0x7FFFFFFF)
  {
    unsigned int v173 = *(_DWORD *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161));
    if (*(unsigned __int8 *)(v162 + 80 * v172 + 12) != 137)
    {
      while (1)
      {
        unsigned int v173 = *(_DWORD *)(v162 + 80 * *(unsigned int *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161)) + 8) & 0x7FFFFFFF;
        if (v173 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v162 + 80 * v173 + 12) == 137) {
          goto LABEL_242;
        }
      }
      unsigned int v173 = 0x7FFFFFFF;
    }
  }
LABEL_242:
  float v166 = *(float *)(v168 + 68) - v171;
  float v165 = *(float *)(v162 + 80 * v173 + 68);
  uint64_t v174 = *(unsigned int *)(v163 + 4 * (0x5CB85FD265949FD2 % v161));
  if (v174 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v162 + 80 * v174 + 12) == 139)
    {
LABEL_246:
      unsigned int v167 = v174;
    }
    else
    {
      while (1)
      {
        LODWORD(v174) = *(_DWORD *)(v162 + 80 * v174 + 8) & 0x7FFFFFFF;
        unsigned int v167 = 0x7FFFFFFF;
        if (v174 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v162 + 80 * v174 + 12) == 139) {
          goto LABEL_246;
        }
      }
    }
  }
LABEL_247:
  re::DynamicString::appendf((re::DynamicString *)v90, "SU Vertices : %.2f, SU Triangles: %.2f\n", v166, (float)(v165 - *(float *)(v162 + 80 * v167 + 68)));
  uint64_t v175 = v85 + (v88 << 6);
  *(_DWORD *)(v175 + 56) = 2048;
  *(void *)&double result = 0x2D0000000ALL;
  *(void *)(v175 + 48) = 0x2D0000000ALL;
  return result;
}

re::FrameCustomStats *re::FrameCustomStats::FrameCustomStats(re::FrameCustomStats *this)
{
  *((_DWORD *)this + 2) = 10;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(void *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((unsigned char *)this + 64) = 0;
  *(void *)this = &unk_26E717750;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  uint64_t v2 = (char *)this + 72;
  *(void *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((void *)this + 19) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 15) = 0;
  uint64_t v3 = (char *)this + 120;
  *((unsigned char *)this + 160) = 1;
  LODWORD(v8[0]) = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  *(void *)((char *)v8 + 4) = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v2, (uint64_t *)&v6);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v6);
  v8[0] = 0;
  *((void *)&v6 + 1) = 0;
  *(void *)&long long v7 = 0;
  DWORD2(v7) = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(&v6, 0xFuLL);
  ++DWORD2(v7);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v3, (uint64_t)&v6);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)&v6);
  return this;
}

void re::FrameCustomStats::~FrameCustomStats(re::FrameCustomStats *this)
{
  uint64_t v2 = (uint64_t *)((char *)this + 72);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)this + 120);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)this + 120);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v2);
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  re::FrameCustomStats::~FrameCustomStats(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::DynamicArray<re::CustomStatsLineInfo>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 104 * v4;
        do
        {
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 104);
          v5 -= 104;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::FrameCustomStats::addOrGetStat(re::FrameCustomStats *this, const char *a2)
{
  uint64_t v4 = (char *)this + 72;
  uint64_t v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v4, (uint64_t)&v10);
  long long v6 = v10;
  if (v10 && (v11 & 1) != 0) {
    long long v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
  }
  if (v5) {
    return *(void *)v5;
  }
  __int16 v12 = 257;
  unint64_t v13 = 0xFF7FFFFF7F7FFFFFLL;
  uint64_t v15 = 0;
  uint64_t v14 = 0;
  long long v16 = xmmword_23440B890;
  long long v17 = xmmword_23440B8A0;
  int v18 = 0;
  int v19 = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::add((re::FrameCustomStats *)((char *)this + 120), (uint64_t)&v10);
  uint64_t v8 = v10;
  if (v10 && (v11 & 1) != 0) {
    uint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
  }
  uint64_t v9 = *((void *)this + 17) - 1;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)v4, (re::DynamicString *)&v10, &v9);
  if (v10)
  {
    if (v11) {
      (*(void (**)(void))(*(void *)v10 + 40))();
    }
  }
  return *((void *)this + 17) - 1;
}

void re::DynamicArray<re::CustomStatsLineInfo>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::CustomStatsLineInfo>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 104 * v4;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v7 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v9 = *(void *)(v5 + 8);
  uint64_t v8 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v6;
  *(void *)(v5 + 16) = v7;
  *(void *)(a2 + 8) = v9;
  *(void *)(a2 + 16) = v8;
  *(_WORD *)(v5 + 32) = *(_WORD *)(a2 + 32);
  re::FrameStats::CollectedStatistics::CollectedStatistics((re::FrameStats::CollectedStatistics *)(v5 + 36), (const re::FrameStats::CollectedStatistics *)(a2 + 36));
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
}

uint64_t re::FrameCustomStats::addOrGetLine(re::FrameCustomStats *this, const char *a2)
{
  unint64_t v4 = (char *)this + 72;
  uint64_t v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v4, (uint64_t)&v10);
  uint64_t v6 = v10;
  if (v10 && (v11 & 1) != 0) {
    uint64_t v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
  }
  if (v5) {
    return *(void *)v5;
  }
  __int16 v12 = 1;
  unint64_t v13 = 0xFF7FFFFF7F7FFFFFLL;
  uint64_t v15 = 0;
  uint64_t v14 = 0;
  long long v16 = xmmword_23440B890;
  long long v17 = xmmword_23440B8A0;
  int v18 = 0;
  int v19 = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::add((re::FrameCustomStats *)((char *)this + 120), (uint64_t)&v10);
  uint64_t v8 = v10;
  if (v10 && (v11 & 1) != 0) {
    uint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
  }
  uint64_t v9 = *((void *)this + 17) - 1;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)v4, (re::DynamicString *)&v10, &v9);
  if (v10)
  {
    if (v11) {
      (*(void (**)(void))(*(void *)v10 + 40))();
    }
  }
  return *((void *)this + 17) - 1;
}

void *re::FrameCustomStats::updateText(void *this, unint64_t a2, const char *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (this[17] > a2)
  {
    uint64_t v5 = this;
    unint64_t v6 = v5[17];
    if (v6 <= a2)
    {
      uint64_t v9 = 0;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v18 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v10 = 136315906;
      char v11 = "operator[]";
      __int16 v12 = 1024;
      int v13 = 789;
      __int16 v14 = 2048;
      unint64_t v15 = a2;
      __int16 v16 = 2048;
      unint64_t v17 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::DynamicString::operator=((re::DynamicString *)(v5[19] + 104 * a2), (re::DynamicString *)&v7);
    this = v7;
    if (v7)
    {
      if (v8) {
        return (void *)(*(uint64_t (**)(void))(*v7 + 40))();
      }
    }
  }
  return this;
}

uint64_t re::FrameCustomStats::dumpStatisticsInternal(uint64_t result, uint64_t a2)
{
  LODWORD(v2) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v3 = **(unsigned int **)(a2 + 8);
    if (v3 != 0x7FFFFFFF)
    {
      uint64_t v4 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v4 + (v3 << 6) + 12))
      {
        uint64_t v2 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v2 = *(_DWORD *)(v4 + (v2 << 6) + 8) & 0x7FFFFFFF;
          if (v2 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v4 + (v2 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v2) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v2) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = v2;
  uint64_t v7 = v5 + ((unint64_t)v2 << 6);
  char v8 = (void *)(v7 + 16);
  uint64_t v9 = *(void *)(v7 + 24);
  if (v9)
  {
    v8[1] = 1;
    int v10 = (unsigned char *)v8[2];
  }
  else
  {
    *((unsigned char *)v8 + 8) = v9 & 1;
    int v10 = (char *)v8 + 9;
  }
  *int v10 = 0;
  uint64_t v11 = *(void *)(result + 136);
  if (v11)
  {
    uint64_t v18 = v6;
    uint64_t v19 = v5;
    uint64_t v12 = 0;
    uint64_t v13 = *(void *)(result + 152);
    do
    {
      uint64_t v14 = v13 + v12;
      *(_OWORD *)(v14 + 60) = *(_OWORD *)(v13 + v12 + 36);
      *(_DWORD *)(v14 + 76) = *(_DWORD *)(v13 + v12 + 52);
      *(_OWORD *)(v14 + 36) = xmmword_23440B8B0;
      *(_DWORD *)(v14 + 52) = 0;
      if (*(unsigned char *)(v13 + v12 + 32))
      {
        if (*(unsigned char *)(v14 + 33))
        {
          if (*(void *)(v14 + 8)) {
            unint64_t v15 = *(const char **)(v13 + v12 + 16);
          }
          else {
            unint64_t v15 = (const char *)(v13 + v12 + 9);
          }
          uint64_t result = re::DynamicString::appendf((re::DynamicString *)v8, "\n%.15s: ", v15);
          if (*(float *)(v14 + 72) != 0.0) {
            uint64_t result = re::DynamicString::appendf((re::DynamicString *)v8, "%.2f, Min/Max[%.2f-%.2f],", *(float *)(v14 + 76), *(float *)(v14 + 60), *(float *)(v14 + 64));
          }
          if (*(float *)(v13 + v12 + 92) != 0.0) {
            uint64_t result = re::DynamicString::appendf((re::DynamicString *)v8, "LT Min/Max[%.2f-%.2f]");
          }
        }
        else
        {
          uint64_t result = re::DynamicString::appendf((re::DynamicString *)v8, "\n%.70s");
        }
      }
      v12 += 104;
    }
    while (104 * v11 != v12);
    uint64_t v6 = v18;
    uint64_t v5 = v19;
  }
  uint64_t v16 = v5 + (v6 << 6);
  *(void *)(v16 + 52) = 0x20000000003CLL;
  if (v11 <= 0xB) {
    int v17 = 11;
  }
  else {
    int v17 = v11;
  }
  *(_DWORD *)(v16 + 48) = v17;
  return result;
}

uint64_t re::FrameAttributionStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  LODWORD(v6) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v7 = **(unsigned int **)(a2 + 8);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        uint64_t v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v10 = v6;
  uint64_t v11 = v9 + ((unint64_t)v6 << 6);
  uint64_t v12 = (void *)(v11 + 16);
  uint64_t v13 = *(void *)(v11 + 24);
  if (v13)
  {
    v12[1] = 1;
    uint64_t v14 = (unsigned char *)v12[2];
  }
  else
  {
    *((unsigned char *)v12 + 8) = v13 & 1;
    uint64_t v14 = (char *)v12 + 9;
  }
  *uint64_t v14 = 0;
  re::DynamicString::appendf((re::DynamicString *)v12, "Attribution Statistics\n");
  unsigned int v15 = 0x7FFFFFFF;
  if (*(void *)a4)
  {
    unsigned int v16 = *(_DWORD *)(*(void *)(a4 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      uint64_t v17 = *(void *)(a4 + 16);
      unsigned int v15 = *(_DWORD *)(*(void *)(a4 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)));
      if (*(unsigned char *)(v17 + 80 * v16 + 12) != 122)
      {
        while (1)
        {
          unsigned int v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(void *)(a4 + 8)
                                            + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v17 + 80 * v15 + 12) == 122) {
            goto LABEL_20;
          }
        }
        unsigned int v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v18 = *(float *)(*(void *)(a4 + 16) + 80 * v15 + 48);
  int v19 = *(_DWORD *)(a1 + 8);
  double v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info.numer;
    LODWORD(v22) = info.denom;
    double v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v20;
  }
  double v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  if (*(void *)a4)
  {
    uint64_t v24 = *(void *)(a4 + 16);
    uint64_t v25 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a4 + 24)));
    unsigned int v26 = 0x7FFFFFFF;
    if (v25 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v24 + 80 * v25 + 12) == 120)
      {
LABEL_30:
        unsigned int v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          unsigned int v26 = 0x7FFFFFFF;
          if (v25 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v24 + 80 * v25 + 12) == 120) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a4 + 16);
    unsigned int v26 = 0x7FFFFFFF;
  }
  float v27 = *(float *)(v24 + 80 * v26 + 48);
  int v28 = *(_DWORD *)(a1 + 8);
  double v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info.numer;
    LODWORD(v31) = info.denom;
    double v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v29;
  }
  double v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  if (*(void *)a4)
  {
    uint64_t v33 = *(void *)(a4 + 16);
    uint64_t v34 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a4 + 24)));
    unsigned int v35 = 0x7FFFFFFF;
    if (v34 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v33 + 80 * v34 + 12) == 125)
      {
LABEL_42:
        unsigned int v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          unsigned int v35 = 0x7FFFFFFF;
          if (v34 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v33 + 80 * v34 + 12) == 125) {
            goto LABEL_42;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v33 = *(void *)(a4 + 16);
    unsigned int v35 = 0x7FFFFFFF;
  }
  float v36 = *(float *)(v33 + 80 * v35 + 48);
  int v37 = *(_DWORD *)(a1 + 8);
  double v38 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v41 = NAN;
      goto LABEL_49;
    }
    LODWORD(v39) = info.numer;
    LODWORD(v40) = info.denom;
    double v38 = (double)v39 / (double)v40;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v38;
  }
  double v41 = v38 * (double)(unint64_t)(float)(v36 / (float)v37);
LABEL_49:
  if (*(void *)a4)
  {
    uint64_t v42 = *(void *)(a4 + 16);
    uint64_t v43 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a4 + 24)));
    unsigned int v44 = 0x7FFFFFFF;
    if (v43 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v42 + 80 * v43 + 12) == 121)
      {
LABEL_54:
        unsigned int v44 = v43;
      }
      else
      {
        while (1)
        {
          LODWORD(v43) = *(_DWORD *)(v42 + 80 * v43 + 8) & 0x7FFFFFFF;
          unsigned int v44 = 0x7FFFFFFF;
          if (v43 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v42 + 80 * v43 + 12) == 121) {
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v42 = *(void *)(a4 + 16);
    unsigned int v44 = 0x7FFFFFFF;
  }
  float v45 = *(float *)(v42 + 80 * v44 + 48);
  int v46 = *(_DWORD *)(a1 + 8);
  double v47 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v50 = NAN;
      goto LABEL_61;
    }
    LODWORD(v48) = info.numer;
    LODWORD(v49) = info.denom;
    double v47 = (double)v48 / (double)v49;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v47;
  }
  double v50 = v47 * (double)(unint64_t)(float)(v45 / (float)v46);
LABEL_61:
  if (*(void *)a4)
  {
    uint64_t v51 = *(void *)(a4 + 16);
    uint64_t v52 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a4 + 24)));
    unsigned int v53 = 0x7FFFFFFF;
    if (v52 != 0x7FFFFFFF)
    {
      if (*(unsigned char *)(v51 + 80 * v52 + 12) == 124)
      {
LABEL_66:
        unsigned int v53 = v52;
      }
      else
      {
        while (1)
        {
          LODWORD(v52) = *(_DWORD *)(v51 + 80 * v52 + 8) & 0x7FFFFFFF;
          unsigned int v53 = 0x7FFFFFFF;
          if (v52 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned char *)(v51 + 80 * v52 + 12) == 124) {
            goto LABEL_66;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v51 = *(void *)(a4 + 16);
    unsigned int v53 = 0x7FFFFFFF;
  }
  float v54 = *(float *)(v51 + 80 * v53 + 48);
  int v55 = *(_DWORD *)(a1 + 8);
  double v56 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v59 = NAN;
      goto LABEL_73;
    }
    LODWORD(v57) = info.numer;
    LODWORD(v58) = info.denom;
    double v56 = (double)v57 / (double)v58;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v56;
  }
  double v59 = v56 * (double)(unint64_t)(float)(v54 / (float)v55);
LABEL_73:
  if (*(void *)a4)
  {
    uint64_t v60 = *(void *)(a4 + 16);
    uint64_t v61 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (0xE2E7890052504D85 % *(unsigned int *)(a4 + 24)));
    unsigned int v62 = 0x7FFFFFFF;
    if (v61 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v60 + 80 * v61 + 12) == 131)
      {
LABEL_78:
        unsigned int v62 = v61;
      }
      else
      {
        while (1)
        {
          LODWORD(v61) = *(_DWORD *)(v60 + 80 * v61 + 8) & 0x7FFFFFFF;
          unsigned int v62 = 0x7FFFFFFF;
          if (v61 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v60 + 80 * v61 + 12) == 131) {
            goto LABEL_78;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v60 = *(void *)(a4 + 16);
    unsigned int v62 = 0x7FFFFFFF;
  }
  float v63 = *(float *)(v60 + 80 * v62 + 48);
  int v64 = *(_DWORD *)(a1 + 8);
  double v65 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
    goto LABEL_84;
  }
  if (!mach_timebase_info(&info))
  {
    LODWORD(v66) = info.numer;
    LODWORD(v67) = info.denom;
    double v65 = (double)v66 / (double)v67;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v65;
LABEL_84:
    double v68 = v65 * (double)(unint64_t)(float)(v63 / (float)v64);
    goto LABEL_85;
  }
  double v68 = NAN;
LABEL_85:
  float v69 = v59 / 1000000.0;
  float v70 = v50 / 1000000.0;
  float v71 = v41 / 1000000.0;
  float v72 = v32 / 1000000.0;
  float v73 = v23 / 1000000.0;
  float v74 = v68 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v12, "CPU Time %.2f\n", (float)((float)((float)((float)((float)(v73 + v72) + v71) + v70) + v69) + v74));
  re::DynamicString::appendf((re::DynamicString *)v12, "Animation %.2f\n", v71);
  re::DynamicString::appendf((re::DynamicString *)v12, "Audio %.2f\n", v72);
  re::DynamicString::appendf((re::DynamicString *)v12, "Rendering %.2f\n", v73);
  re::DynamicString::appendf((re::DynamicString *)v12, "Network %.2f\n", v69);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics %.2f\n", v70);
  uint64_t result = re::DynamicString::appendf((re::DynamicString *)v12, "Misc %.2f\n", v74);
  *(_DWORD *)(v9 + (v10 << 6) + 48) = 8;
  return result;
}

double re::FrameVFXStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v5) = 0x7FFFFFFF;
  if (*(void *)a2)
  {
    uint64_t v6 = **(unsigned int **)(a2 + 8);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        uint64_t v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          uint64_t v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12)) {
            goto LABEL_10;
          }
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = v8 + ((unint64_t)v5 << 6);
  uint64_t v11 = (void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  if (v12)
  {
    v11[1] = 1;
    uint64_t v13 = (unsigned char *)v11[2];
  }
  else
  {
    *((unsigned char *)v11 + 8) = v12 & 1;
    uint64_t v13 = (char *)v11 + 9;
  }
  *uint64_t v13 = 0;
  re::DynamicString::append((re::DynamicString *)v11, "VFX Stats\n", 0xAuLL);
  unsigned int v14 = 0x7FFFFFFF;
  if (*(void *)a3)
  {
    unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a3 + 16);
      unsigned int v14 = *(_DWORD *)(*(void *)(a3 + 8) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned __int8 *)(v16 + 80 * v15 + 12) != 130)
      {
        while (1)
        {
          unsigned int v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(void *)(a3 + 8)
                                            + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v16 + 80 * v14 + 12) == 130) {
            goto LABEL_20;
          }
        }
        unsigned int v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  float v17 = *(float *)(*(void *)(a3 + 16) + 80 * v14 + 48);
  int v18 = *(_DWORD *)(a1 + 8);
  double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
  }
  double v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  double v23 = v22 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v24 = *(void *)(a3 + 16);
    uint64_t v25 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xD732B4173198B1FuLL % *(unsigned int *)(a3 + 24)));
    unsigned int v26 = 0x7FFFFFFF;
    if (v25 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 149)
      {
LABEL_30:
        unsigned int v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          unsigned int v26 = 0x7FFFFFFF;
          if (v25 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 149) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a3 + 16);
    unsigned int v26 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX ECS (ms): %.2f    VFX Scene Components: %.0f\n", v23, (float)(*(float *)(v24 + 80 * v26 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    uint64_t v27 = *(void *)(a3 + 16);
    uint64_t v28 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0x3465840D39B46BB3uLL % *(unsigned int *)(a3 + 24)));
    unsigned int v29 = 0x7FFFFFFF;
    if (v28 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v27 + 80 * v28 + 12) == 150)
      {
LABEL_37:
        unsigned int v29 = v28;
      }
      else
      {
        while (1)
        {
          LODWORD(v28) = *(_DWORD *)(v27 + 80 * v28 + 8) & 0x7FFFFFFF;
          unsigned int v29 = 0x7FFFFFFF;
          if (v28 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v27 + 80 * v28 + 12) == 150) {
            goto LABEL_37;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v27 = *(void *)(a3 + 16);
    unsigned int v29 = 0x7FFFFFFF;
  }
  float v30 = *(float *)(v27 + 80 * v29 + 48);
  int v31 = *(_DWORD *)(a1 + 8);
  double v32 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v35 = NAN;
      goto LABEL_44;
    }
    LODWORD(v33) = info.numer;
    LODWORD(v34) = info.denom;
    double v32 = (double)v33 / (double)v34;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v32;
  }
  double v35 = v32 * (double)(unint64_t)(float)(v30 / (float)v31);
LABEL_44:
  double v36 = v35 / 1000000.0;
  if (*(void *)a3)
  {
    uint64_t v37 = *(void *)(a3 + 16);
    uint64_t v38 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (0xB3CC71E5DDF6EBC3 % *(unsigned int *)(a3 + 24)));
    unsigned int v39 = 0x7FFFFFFF;
    if (v38 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v37 + 80 * v38 + 12) == 151)
      {
LABEL_49:
        unsigned int v39 = v38;
      }
      else
      {
        while (1)
        {
          LODWORD(v38) = *(_DWORD *)(v37 + 80 * v38 + 8) & 0x7FFFFFFF;
          unsigned int v39 = 0x7FFFFFFF;
          if (v38 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v37 + 80 * v38 + 12) == 151) {
            goto LABEL_49;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v37 = *(void *)(a3 + 16);
    unsigned int v39 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX Render Node (ms): %.2f    VFX Draw Calls : %.0f\n", v36, (float)(*(float *)(v37 + 80 * v39 + 48) / (float)*(int *)(a1 + 8)));
  if (*(void *)a3)
  {
    unint64_t v40 = *(unsigned int *)(a3 + 24);
    uint64_t v42 = *(void *)(a3 + 8);
    uint64_t v41 = *(void *)(a3 + 16);
    unsigned int v43 = *(_DWORD *)(v42 + 4 * (0x76FE0174DADB77ALL % v40));
    unsigned int v44 = 0x7FFFFFFF;
    unsigned int v45 = 0x7FFFFFFF;
    if (v43 != 0x7FFFFFFF)
    {
      unsigned int v45 = *(_DWORD *)(v42 + 4 * (0x76FE0174DADB77ALL % v40));
      if (*(unsigned __int8 *)(v41 + 80 * v43 + 12) != 152)
      {
        while (1)
        {
          unsigned int v45 = *(_DWORD *)(v41 + 80 * *(unsigned int *)(v42 + 4 * (0x76FE0174DADB77ALL % v40)) + 8) & 0x7FFFFFFF;
          if (v45 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v41 + 80 * v45 + 12) == 152) {
            goto LABEL_59;
          }
        }
        unsigned int v45 = 0x7FFFFFFF;
      }
    }
LABEL_59:
    float v46 = *(float *)(v41 + 80 * v45 + 48);
    int v47 = *(_DWORD *)(a1 + 8);
    uint64_t v48 = *(unsigned int *)(v42 + 4 * (0x4B73DAB7CD5C5CDDLL % v40));
    if (v48 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v41 + 80 * v48 + 12) == 153)
      {
LABEL_63:
        unsigned int v44 = v48;
      }
      else
      {
        while (1)
        {
          LODWORD(v48) = *(_DWORD *)(v41 + 80 * v48 + 8) & 0x7FFFFFFF;
          unsigned int v44 = 0x7FFFFFFF;
          if (v48 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int8 *)(v41 + 80 * v48 + 12) == 153) {
            goto LABEL_63;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v41 = *(void *)(a3 + 16);
    float v46 = *(float *)(v41 + 0x27FFFFFFE0);
    int v47 = *(_DWORD *)(a1 + 8);
    unsigned int v44 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX Vert Count: %.0f    VFX Tri Count : %.0f\n", (float)(v46 / (float)v47), (float)(*(float *)(v41 + 80 * v44 + 48) / (float)v47));
  *(void *)&double result = 0x2000000000032;
  *(void *)(v8 + (v9 << 6) + 52) = 0x2000000000032;
  return result;
}

uint64_t re::FrameStats::reservedIndexCount(re::FrameStats *this)
{
  return 1;
}

void re::FrameTimeStats::~FrameTimeStats(re::FrameTimeStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameAnimationStats::~FrameAnimationStats(re::FrameAnimationStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameAssetStats::~FrameAssetStats(re::FrameAssetStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameAudioStats::~FrameAudioStats(re::FrameAudioStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameECSStats::~FrameECSStats(re::FrameECSStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameMeshStats::~FrameMeshStats(re::FrameMeshStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameNetworkStats::~FrameNetworkStats(re::FrameNetworkStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FramePhysicsStats::~FramePhysicsStats(re::FramePhysicsStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameRenderingStats::~FrameRenderingStats(re::FrameRenderingStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::FrameRenderingStats::reservedIndexCount(re::FrameRenderingStats *this)
{
  return 2;
}

void re::FrameMemoryStats::~FrameMemoryStats(re::FrameMemoryStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameThermalStats::~FrameThermalStats(re::FrameThermalStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameSceneUnderstandingStats::~FrameSceneUnderstandingStats(re::FrameSceneUnderstandingStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameAttributionStats::~FrameAttributionStats(re::FrameAttributionStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::FrameVFXStats::~FrameVFXStats(re::FrameVFXStats *this)
{
  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7176F0;
  *((unsigned char *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_165, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        ++v4;
        v5 += 64;
      }
      while (v4 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (_DWORD *)(v8 + 12), (re::DynamicString *)(v8 + 16));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 64;
    }
  }
}

void *re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x68uLL))
        {
          uint64_t v2 = 104 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 104 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      int v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = (char *)(v8 + 104 * v9);
        uint64_t v11 = (re::FrameStats::CollectedStatistics *)((char *)v7 + 36);
        uint64_t v12 = (const re::FrameStats::CollectedStatistics *)(v8 + 36);
        do
        {
          *(_OWORD *)((char *)v11 - 20) = 0u;
          *(_OWORD *)((char *)v11 - 36) = 0u;
          *(void *)((char *)v11 - 36) = *(void *)((char *)v12 - 36);
          *(void *)((char *)v12 - 36) = 0;
          uint64_t v13 = *(void *)((char *)v11 - 20);
          *(void *)((char *)v11 - 20) = *(void *)((char *)v12 - 20);
          *(void *)((char *)v12 - 20) = v13;
          *(void *)((char *)v11 - 12) = *(void *)((char *)v12 - 12);
          *(void *)((char *)v12 - 12) = 0;
          uint64_t v14 = *(void *)((char *)v11 - 28);
          *(void *)((char *)v11 - 28) = *(void *)((char *)v12 - 28);
          *(void *)((char *)v12 - 28) = v14;
          *((_WORD *)v11 - 2) = *((_WORD *)v12 - 2);
          re::FrameStats::CollectedStatistics::CollectedStatistics(v11, v12);
          re::DynamicString::deinit((const re::FrameStats::CollectedStatistics *)((char *)v12 - 36));
          uint64_t v11 = (re::FrameStats::CollectedStatistics *)((char *)v11 + 104);
          unsigned int v15 = (char *)v12 + 68;
          uint64_t v12 = (const re::FrameStats::CollectedStatistics *)((char *)v12 + 104);
        }
        while (v15 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::CustomStatsLineInfo>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unsigned int v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::profilerThreadContext(re *this)
{
  if ((*(unsigned char *)v2 & 1) == 0)
  {
    re::ProfilerThreadContext::ProfilerThreadContext(v2);
    unsigned int v4 = (void *)re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
    _tlv_atexit((void (__cdecl *)(void *))re::ProfilerThreadContext::~ProfilerThreadContext, v4);
  }
  return re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
}

void re::ProfilerThreadContext::~ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  unint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + 13) = v3;
    operator delete(v3);
  }
  unsigned int v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
}

void re::ProfilerThreadContext::ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  unsigned int v1 = re::profilerThreadContext(void)::context;
  uint64_t v2 = re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
  *(unsigned char *)uint64_t v2 = 0;
  *(void *)(v2 + 64) = atomic_fetch_add(&re::ProfilerThreadContext::s_threadId, 1uLL);
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(unsigned char *)(v2 + 184) = 0;
  unint64_t v3 = pthread_self();
  if (pthread_getname_np(v3, (char *)v2, 0x40uLL)) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = *(unsigned char *)v2 == 0;
  }
  if (v4)
  {
    pthread_t v16 = pthread_self();
    uint64_t v5 = (char *)v1(&re::profilerThreadContext(void)::context);
    snprintf(v5, 0x40uLL, "Thread %p", v16);
  }
  uint64_t v6 = v1(&re::profilerThreadContext(void)::context);
  *(void *)(v6 + 176) = 0;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 160) = 0u;
  unint64_t v7 = *(void *)(v6 + 96);
  if (*(void *)(v6 + 112) - v7 <= 0x1F)
  {
    uint64_t v8 = *(char **)(v1(&re::profilerThreadContext(void)::context) + 104);
    uint64_t v9 = operator new(0x20uLL);
    if (v8 != (char *)v7)
    {
      uint64_t v10 = &v8[~v7];
      do
      {
        char v11 = *--v8;
        (v10--)[(void)v9] = v11;
      }
      while (v8 != (char *)v7);
    }
    uint64_t v12 = (void *)v1(&re::profilerThreadContext(void)::context);
    v12[12] = v14;
    v12[13] = v13;
    v12[14] = v15;
    if (v7)
    {
      operator delete((void *)v7);
    }
  }
}

void re::ProfilerThreadContext::begin(re::ProfilerThreadContext *this, re::ProfilerManager *a2, int a3)
{
  *((unsigned char *)this + 184) = 1;
  uint64_t v6 = re::ProfilerManager::acquireEventStream(a2, a3);
  unint64_t v7 = re::ProfilerManager::acquireStatistics(a2, a3);
  uint64_t v8 = re::ProfilerManager::acquireAttributions(a2, a3);
  uint64_t v9 = re::ProfilerManager::acquireVisualizer(a2);
  uint64_t v10 = re::ProfilerManager::acquireMemoryStatistics(a2, a3);
  char v11 = v10;
  uint64_t v13 = (char *)*((void *)this + 10);
  unint64_t v12 = *((void *)this + 11);
  if ((unint64_t)v13 >= v12)
  {
    uint64_t v15 = (char *)*((void *)this + 9);
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v15) >> 4) + 1;
    if (v16 > 0x555555555555555) {
      abort();
    }
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)v15) >> 4);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v18 = 0x555555555555555;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      double v19 = (char *)operator new(48 * v18);
    }
    else
    {
      double v19 = 0;
    }
    unint64_t v20 = &v19[16 * ((v13 - v15) >> 4)];
    *(void *)unint64_t v20 = a2;
    *((void *)v20 + 1) = v6;
    *((void *)v20 + 2) = v7;
    *((void *)v20 + 3) = v8;
    *((void *)v20 + 4) = v9;
    *((void *)v20 + 5) = v11;
    uint64_t v14 = v20 + 48;
    if (v13 != v15)
    {
      do
      {
        long long v21 = *((_OWORD *)v13 - 3);
        long long v22 = *((_OWORD *)v13 - 1);
        *((_OWORD *)v20 - 2) = *((_OWORD *)v13 - 2);
        *((_OWORD *)v20 - 1) = v22;
        *((_OWORD *)v20 - 3) = v21;
        v20 -= 48;
        v13 -= 48;
      }
      while (v13 != v15);
      uint64_t v13 = (char *)*((void *)this + 9);
    }
    *((void *)this + 9) = v20;
    *((void *)this + 10) = v14;
    *((void *)this + 11) = &v19[48 * v18];
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(void *)uint64_t v13 = a2;
    *((void *)v13 + 1) = v6;
    *((void *)v13 + 2) = v7;
    *((void *)v13 + 3) = v8;
    uint64_t v14 = v13 + 48;
    *((void *)v13 + 4) = v9;
    *((void *)v13 + 5) = v10;
  }
  *((void *)this + 10) = v14;
  *((void *)this + 18) = v6;
  *((void *)this + 19) = v7;
  *((void *)this + 20) = v8;
  *((void *)this + 21) = v9;
  *((void *)this + 22) = v11;
  *((unsigned char *)this + 184) = 0;
}

void re::ProfilerThreadContext::end(re::ProfilerThreadContext *this)
{
  *((unsigned char *)this + 184) = 1;
  uint64_t v2 = *((void *)this + 10);
  if (*((void *)this + 9) == v2)
  {
    uint64_t v10 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v11 = 0;
      _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "Unbalanced calls to ProfilerThreadContext begin and end.", v11, 2u);
    }
    goto LABEL_16;
  }
  unint64_t v3 = *(void **)(v2 - 40);
  if (v3) {
    re::ProfilerManager::submit(*(void *)(v2 - 48), v3);
  }
  BOOL v4 = *(void **)(v2 - 32);
  if (v4) {
    re::ProfilerManager::submit(*(void *)(v2 - 48), v4);
  }
  uint64_t v5 = *(re::ProfilerAttributions **)(v2 - 24);
  if (v5) {
    re::ProfilerManager::submit(*(os_unfair_lock_s **)(v2 - 48), v5);
  }
  uint64_t v6 = *(void **)(v2 - 16);
  if (v6) {
    re::ProfilerManager::submit(*(void *)(v2 - 48), v6);
  }
  unint64_t v7 = *(void **)(v2 - 8);
  if (v7) {
    re::ProfilerManager::submit(*(void *)(v2 - 48), v7);
  }
  uint64_t v9 = *((void *)this + 9);
  uint64_t v8 = *((void *)this + 10);
  *((void *)this + 10) = v8 - 48;
  if (v9 == v8 - 48)
  {
LABEL_16:
    *((void *)this + 22) = 0;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
    goto LABEL_17;
  }
  *((_OWORD *)this + 9) = *(_OWORD *)(v8 - 88);
  *((_OWORD *)this + 10) = *(_OWORD *)(v8 - 72);
  *((void *)this + 22) = *(void *)(v8 - 56);
LABEL_17:
  *((unsigned char *)this + 184) = 0;
}

uint64_t re::ProfilerConfig::isStatisticCollectionEnabled(re::ProfilerConfig *this)
{
  unsigned int v1 = &dword_2687A1000;
  {
    unsigned int v1 = &dword_2687A1000;
    if (v3)
    {
      re::Defaults::BOOLValue((re::Defaults *)"profiler.statisticcollection.enable", v4, v6);
      char v5 = v6[1];
      if (!v6[0]) {
        char v5 = 1;
      }
      re::ProfilerConfig::isStatisticCollectionEnabled(void)::enabled = v5;
      unsigned int v1 = &dword_2687A1000;
    }
  }
  return *((unsigned __int8 *)v1 + 1696);
}

uint64_t re::internal::PerfStats::beginStatisticsCollection(integer_t *this)
{
  if (*((unsigned char *)this + 913))
  {
    return puts("Starting perf stats already collected");
  }
  else
  {
    re::internal::enableMemoryStatsCollection((re::internal *)this);
    pid_t v3 = getpid();
    this[229] = proc_pid_rusage(v3, 4, (rusage_info_t *)this) == 0;
    integer_t v4 = this[233];
    if (v4 == 31 || v4 == 4)
    {
      mach_msg_type_number_t host_info64_outCnt = 38;
      host_t v6 = MEMORY[0x237DBD840]();
      if (host_statistics64(v6, 4, this + 148, &host_info64_outCnt))
      {
        printf("failed to get statistics. error %d", 1);
        int v7 = 0;
      }
      else
      {
        int v7 = 1;
      }
      this[231] = v7;
    }
    uint64_t result = mach_absolute_time();
    *((void *)this + 112) = result;
    *((unsigned char *)this + 913) = 1;
  }
  return result;
}

void re::internal::PerfStats::endStatisticsCollection(re::internal::PerfStats *this, int a2)
{
  if (*((unsigned char *)this + 914))
  {
    puts("Ending perf stats already collected");
  }
  else
  {
    *((void *)this + 113) = mach_absolute_time();
    pid_t v4 = getpid();
    char v5 = (re::internal *)proc_pid_rusage(v4, 4, (rusage_info_t *)this + 37);
    *((_DWORD *)this + 230) = v5 == 0;
    int v6 = *((_DWORD *)this + 233);
    if (v6 == 31 || v6 == 4)
    {
      mach_msg_type_number_t host_info64_outCnt = 38;
      host_t v8 = MEMORY[0x237DBD840]();
      char v5 = (re::internal *)host_statistics64(v8, 4, (host_info64_t)this + 186, &host_info64_outCnt);
      if (v5)
      {
        char v5 = (re::internal *)printf("failed to get statistics. error %d", 1);
        int v9 = 0;
      }
      else
      {
        int v9 = 1;
      }
      *((_DWORD *)this + 232) = v9;
    }
    re::internal::disableMemoryStatsCollection(v5);
    *((void *)this + 120) = v10;
    *((void *)this + 121) = v11;
    *((void *)this + 122) = v12;
    *((void *)this + 123) = v13;
    *((void *)this + 124) = v14;
    *((void *)this + 125) = v15;
    *((void *)this + 126) = v16;
    *((void *)this + 127) = v17;
    *((void *)this + 128) = v18;
    *((void *)this + 129) = v19;
    *((unsigned char *)this + 914) = 1;
    if (*((_DWORD *)this + 229) && *((_DWORD *)this + 230))
    {
      if (a2) {
        re::internal::PerfStats::printStatistics(this, *((_DWORD *)this + 233));
      }
      if (*((unsigned char *)this + 912)) {
        re::internal::PerfStats::dumpToJson((uint64_t)this, *((_DWORD *)this + 233));
      }
    }
  }
}

re::internal::PerfStats *re::internal::PerfStats::printStatistics(re::internal::PerfStats *this, int a2)
{
  uint64_t v2 = this;
  switch(a2)
  {
    case 1:
      return (re::internal::PerfStats *)re::internal::PerfStats::printCPUStatistics(this);
    case 2:
      goto LABEL_13;
    case 3:
      re::internal::PerfStats::printCPUStatistics(this);
LABEL_13:
      return (re::internal::PerfStats *)re::internal::PerfStats::printMemoryStatistics(v2);
    case 4:
      return (re::internal::PerfStats *)re::internal::PerfStats::printVMPagingStatistics((const char **)this);
    case 5:
    case 6:
    case 7:
      return this;
    case 8:
      return (re::internal::PerfStats *)re::internal::PerfStats::printQoSStatistics((const char **)this);
    default:
      if (a2 == 16) {
        goto LABEL_8;
      }
      if (a2 == 31)
      {
        re::internal::PerfStats::printCPUStatistics(this);
        re::internal::PerfStats::printQoSStatistics((const char **)v2);
        re::internal::PerfStats::printMemoryStatistics(v2);
        re::internal::PerfStats::printVMPagingStatistics((const char **)v2);
LABEL_8:
        return (re::internal::PerfStats *)re::internal::PerfStats::printDiskStatistics((const char **)v2);
      }
      return this;
  }
}

uint64_t re::internal::PerfStats::dumpToJson(uint64_t a1, int a2)
{
  v29[19] = *MEMORY[0x263EF8340];
  uint64_t v4 = MEMORY[0x263F8C310] + 24;
  uint64_t v5 = MEMORY[0x263F8C310] + 64;
  v29[0] = MEMORY[0x263F8C310] + 64;
  int v6 = (uint64_t *)MEMORY[0x263F8C2B0];
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B0] + 16);
  uint64_t v27 = *(void *)(MEMORY[0x263F8C2B0] + 8);
  *(void *)((char *)&v28[-1] + *(void *)(v27 - 24)) = v7;
  host_t v8 = (std::ios_base *)((char *)&v28[-1] + *(void *)(v27 - 24));
  std::ios_base::init(v8, v28);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v27 = v4;
  v29[0] = v5;
  MEMORY[0x237DBC6A0](v28);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)&v28[-1] + *(void *)(v27 - 24)), *(_DWORD *)((char *)&v28[3] + *(void *)(v27 - 24)) | 4);
  }
  if (v28[15])
  {
    puts("\nResults file opened....");
    uint64_t v9 = MEMORY[0x263F8C308] + 24;
    uint64_t v10 = MEMORY[0x263F8C308] + 64;
    v26[0] = MEMORY[0x263F8C308] + 64;
    uint64_t v11 = *(void *)(MEMORY[0x263F8C2A8] + 16);
    v24[0] = *(void *)(MEMORY[0x263F8C2A8] + 8);
    *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = v11;
    v24[1] = 0;
    unint64_t v12 = (std::ios_base *)((char *)v24 + *(void *)(v24[0] - 24));
    std::ios_base::init(v12, v25);
    v12[1].__vftable = 0;
    v12[1].__fmtflags_ = -1;
    v24[0] = v9;
    v26[0] = v10;
    MEMORY[0x237DBC6A0](v25);
    if (!std::filebuf::open()) {
      std::ios_base::clear((std::ios_base *)((char *)v24 + *(void *)(v24[0] - 24)), *(_DWORD *)&v25[*(void *)(v24[0] - 24) + 16] | 4);
    }
    std::istream::get();
    if ((*(_DWORD *)&v25[*(void *)(v24[0] - 24) + 16] & 2) != 0) {
      unint64_t v13 = "[\n";
    }
    else {
      unint64_t v13 = ",\n";
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)v13, 2);
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)((char *)v24 + *(void *)(v24[0] - 24)), *(_DWORD *)&v25[*(void *)(v24[0] - 24) + 16] | 4);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"{\n", 2);
    unint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"\t\"ModuleName\" : \"", 17);
    size_t v15 = strlen(*(const char **)(a1 + 936));
    unint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, *(void *)(a1 + 936), v15);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"\",\n", 3);
    unint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"\t\"TestName\" : \"", 15);
    size_t v18 = strlen(*(const char **)(a1 + 944));
    unint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, *(void *)(a1 + 944), v18);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"\",\n", 3);
    int v6 = (uint64_t *)MEMORY[0x263F8C2B0];
    unint64_t v20 = (void *)MEMORY[0x263F8C2A8];
    switch(a2)
    {
      case 1:
        re::internal::PerfStats::addCPUStatisticsToJson(a1, &v27);
        goto LABEL_21;
      case 2:
        goto LABEL_19;
      case 3:
        re::internal::PerfStats::addCPUStatisticsToJson(a1, &v27);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)",\n", 2);
LABEL_19:
        re::internal::PerfStats::addMemoryStatisticsToJson(a1, &v27);
        goto LABEL_21;
      case 4:
      case 5:
      case 6:
      case 7:
        goto LABEL_21;
      case 8:
        re::internal::PerfStats::addQoSStatisticsToJson(a1, &v27);
        goto LABEL_21;
      default:
        int v6 = (uint64_t *)MEMORY[0x263F8C2B0];
        unint64_t v20 = (void *)MEMORY[0x263F8C2A8];
        if (a2 == 16) {
          goto LABEL_17;
        }
        if (a2 == 31)
        {
          re::internal::PerfStats::addCPUStatisticsToJson(a1, &v27);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)",\n", 2);
          re::internal::PerfStats::addMemoryStatisticsToJson(a1, &v27);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)",\n", 2);
          re::internal::PerfStats::addQoSStatisticsToJson(a1, &v27);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)",\n", 2);
LABEL_17:
          re::internal::PerfStats::addDiskStatisticsToJson(a1, &v27);
        }
LABEL_21:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"\n}", 2);
        long long v21 = getcwd(v23, 0x400uLL);
        printf("\nTrace file output in current working dir: %s\n", v21);
        if (!std::filebuf::close()) {
          std::ios_base::clear((std::ios_base *)((char *)&v28[-1] + *(void *)(v27 - 24)), *(_DWORD *)((char *)&v28[3] + *(void *)(v27 - 24)) | 4);
        }
        v24[0] = *v20;
        *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = v20[3];
        MEMORY[0x237DBC6B0](v25);
        std::istream::~istream();
        MEMORY[0x237DBCB10](v26);
        break;
    }
  }
  else
  {
    puts("\nError in opening results file....");
  }
  uint64_t v27 = *v6;
  *(void *)((char *)&v28[-1] + *(void *)(v27 - 24)) = v6[3];
  MEMORY[0x237DBC6B0](v28);
  std::ostream::~ostream();
  return MEMORY[0x237DBCB10](v29);
}

uint64_t re::internal::PerfStats::printCPUStatistics(re::internal::PerfStats *this)
{
  uint64_t v2 = *((void *)this + 39);
  uint64_t v3 = *((void *)this + 40);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = *((void *)this + 3);
  double v6 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v6 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v9 = NAN;
      goto LABEL_6;
    }
    LODWORD(v7) = info.numer;
    LODWORD(v8) = info.denom;
    double v6 = (double)v7 / (double)v8;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v6;
  }
  double v9 = v6 * (double)(unint64_t)(v3 + v2 - (v4 + v5));
LABEL_6:
  uint64_t v10 = *((void *)this + 113);
  uint64_t v11 = *((void *)this + 112);
  if (v6 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v14 = NAN;
      goto LABEL_11;
    }
    LODWORD(v12) = info.numer;
    LODWORD(v13) = info.denom;
    double v6 = (double)v12 / (double)v13;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v6;
  }
  double v14 = v6 * (double)(unint64_t)(v10 - v11);
LABEL_11:
  float v15 = v9 / 1000000.0;
  float v16 = v14 / 1000000.0;
  else {
    float v17 = 100.0;
  }
  printf("\n-------------------\nModule : %s\n%s CPU Perf Stats\n-------------------\n", *((const char **)this + 117), *((const char **)this + 118));
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printQoSStatistics(const char **this)
{
  printf("\n-------------------\nModule : %s\n%s QoS Perf Stats\n-------------------\n", this[117], this[118]);
  uint64_t v2 = this[57];
  uint64_t v3 = this[20];
  double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v7 = NAN;
      goto LABEL_6;
    }
    LODWORD(v5) = info.numer;
    LODWORD(v6) = info.denom;
    double v4 = (double)v5 / (double)v6;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v7 = v4 * (double)(unint64_t)(v2 - v3);
LABEL_6:
  unint64_t v8 = this[58];
  double v9 = this[21];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v12 = NAN;
      goto LABEL_11;
    }
    LODWORD(v10) = info.numer;
    LODWORD(v11) = info.denom;
    double v4 = (double)v10 / (double)v11;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v12 = v4 * (double)(unint64_t)(v8 - v9);
LABEL_11:
  unint64_t v13 = this[59];
  double v14 = this[22];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v17 = NAN;
      goto LABEL_16;
    }
    LODWORD(v15) = info.numer;
    LODWORD(v16) = info.denom;
    double v4 = (double)v15 / (double)v16;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v17 = v4 * (double)(unint64_t)(v13 - v14);
LABEL_16:
  size_t v18 = this[60];
  unint64_t v19 = this[23];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v22 = NAN;
      goto LABEL_21;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v4 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v22 = v4 * (double)(unint64_t)(v18 - v19);
LABEL_21:
  double v23 = this[61];
  uint64_t v24 = this[24];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v27 = NAN;
      goto LABEL_26;
    }
    LODWORD(v25) = info.numer;
    LODWORD(v26) = info.denom;
    double v4 = (double)v25 / (double)v26;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v27 = v4 * (double)(unint64_t)(v23 - v24);
LABEL_26:
  uint64_t v28 = this[62];
  unsigned int v29 = this[25];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v32 = NAN;
      goto LABEL_31;
    }
    LODWORD(v30) = info.numer;
    LODWORD(v31) = info.denom;
    double v4 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
  }
  double v32 = v4 * (double)(unint64_t)(v28 - v29);
LABEL_31:
  unint64_t v33 = this[63];
  unint64_t v34 = this[26];
  if (v4 >= 0.0)
  {
LABEL_35:
    double v37 = v4 * (double)(unint64_t)(v33 - v34);
    goto LABEL_36;
  }
  if (!mach_timebase_info(&info))
  {
    LODWORD(v35) = info.numer;
    LODWORD(v36) = info.denom;
    double v4 = (double)v35 / (double)v36;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v4;
    goto LABEL_35;
  }
  double v37 = NAN;
LABEL_36:
  printf("QoS Threads CPU Scheduled Time\nDefault QoS Time [ms] : %f\nMaintenance QoS Time [ms] : %f\nBackground QoS Time [ms] : %f\nUtility QoS Time [ms] : %f\nLegacy QoS Time [ms] : %f\nUser Initiated QoS Time [ms] : %f\nUser Interactive QoS Time [ms] : %f\n", v7 / 1000000.0, v12 / 1000000.0, v17 / 1000000.0, v22 / 1000000.0, v27 / 1000000.0, v32 / 1000000.0, v37 / 1000000.0);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printMemoryStatistics(re::internal::PerfStats *this)
{
  unint64_t v2 = *((void *)this + 46);
  unint64_t v3 = *((void *)this + 9);
  unint64_t v4 = v3 - v2;
  BOOL v5 = v2 >= v3;
  unint64_t v6 = v2 - v3;
  if (v5) {
    double v7 = "Increase";
  }
  else {
    double v7 = "Decrease";
  }
  if (!v5) {
    unint64_t v6 = v4;
  }
  float v8 = (double)v6 * 0.0009765625;
  float v9 = (double)(unint64_t)(*((void *)this + 45) - *((void *)this + 8)) * 0.0009765625;
  float v10 = (double)(unint64_t)(*((void *)this + 44) - *((void *)this + 7)) * 0.0009765625;
  printf("\n-------------------\nModule : %s\n%s Memory Perf Stats\n-------------------\n", *((const char **)this + 117), *((const char **)this + 118));
  printf("%s in Current Dirty Memory Footprint [kb] : %f\nPeak Dirty Memory Footprint [kb] : %f\n", v7, v8, (double)*((unint64_t *)this + 67) * 0.0009765625);
  printf("Increase in Current Resident Memory Footprint [kb] : %f\nIncrease in Current Wired Memory Footprint [kb] : %f\n", v9, v10);
  puts("\n-------- Malloc Allocation Stats --------");
  printf("Total Heap Allocations [kb] : %f\nTotal Heap Deallocations [kb] : %f\nPeak Heap Allocations [kb] : %f\n", (double)*((uint64_t *)this + 123) * 0.0009765625, (double)*((uint64_t *)this + 124) * 0.0009765625, (double)*((uint64_t *)this + 125) * 0.0009765625);
  printf("Total Heap Node Allocations: %llu\nTotal Heap Node Deallocations: %llu\n", *((void *)this + 120), *((void *)this + 121));
  printf("Total VM Allocations [kb] : %f\nTotal VM Deallocations [kb] : %f\nPeak VM Allocations [kb] : %f\n", (double)*((uint64_t *)this + 127) * 0.0009765625, (double)*((uint64_t *)this + 128) * 0.0009765625, (double)*((uint64_t *)this + 129) * 0.0009765625);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printVMPagingStatistics(const char **this)
{
  printf("\n-------------------\nModule : %s\n%s Mach Virtual Memory Paging Stats : (page size of %llu bytes)\n-------------------\n", this[117], this[118], *MEMORY[0x263EF8AE0]);
  printf("-----\nPages free at start : %u\nPages free at end : %u\nChange in free pages : %u\n-----\n", *((_DWORD *)this + 148) - *((_DWORD *)this + 171), *((_DWORD *)this + 186) - *((_DWORD *)this + 209), *((_DWORD *)this + 171) - *((_DWORD *)this + 209));
  printf("-----\nPages active at start : %u\nPages active at end : %u\nChange in active pages : %u\n-----\n", *((_DWORD *)this + 149), *((_DWORD *)this + 187), *((_DWORD *)this + 187) - *((_DWORD *)this + 149));
  printf("-----\nPages inactive at start : %u\nPages inactive at end : %u\nChange in inactive page s: %u\n-----\n", *((_DWORD *)this + 150), *((_DWORD *)this + 188), *((_DWORD *)this + 188) - *((_DWORD *)this + 150));
  printf("-----\nPages speculative at start : %u\nPages speculative at end : %u\nChange in speculative pages : %u\n-----\n", *((_DWORD *)this + 171), *((_DWORD *)this + 209), *((_DWORD *)this + 209) - *((_DWORD *)this + 171));
  printf("-----\nPages uncompressed in compressor at start : %llu\nPages uncompressed in compressor  at end : %llu\nChange in uncompressed pages in compressor  : %llu\n-----\n", this[92], this[111], this[111] - this[92]);
  printf("-----\nPages compressed in compressor at start : %u\nPages compressed in compressor at end : %u\nChange in compressed pages in compressor : %u\n-----\n", *((_DWORD *)this + 180), *((_DWORD *)this + 218), *((_DWORD *)this + 218) - *((_DWORD *)this + 180));
  printf("-----\nPages file backed at start : %u\nPages file backed at end : %u\nChange in pages file backed : %u\n-----\n", *((_DWORD *)this + 182), *((_DWORD *)this + 220), *((_DWORD *)this + 220) - *((_DWORD *)this + 182));
  printf("-----\nPages anonymous at start : %u\nPages anonymous at end : %u\nChange in anonymous pages : %u\n-----\n", *((_DWORD *)this + 183), *((_DWORD *)this + 221), *((_DWORD *)this + 221) - *((_DWORD *)this + 183));
  printf("-----\nPages throttled at start : %u\nPages throttled at end : %u\nChange in throttled pages : %u\n-----\n", *((_DWORD *)this + 181), *((_DWORD *)this + 219), *((_DWORD *)this + 219) - *((_DWORD *)this + 181));
  printf("-----\nPages wired down at start : %u\nPages wired down at end : %u\nChange in wired down pages : %u\n-----\n", *((_DWORD *)this + 151), *((_DWORD *)this + 189), *((_DWORD *)this + 189) - *((_DWORD *)this + 151));
  printf("-----\nPages purgeable at start : %u\nPages purgeable at end : %u\nChange in purgeable pages : %u\n-----\n", *((_DWORD *)this + 170), *((_DWORD *)this + 208), *((_DWORD *)this + 208) - *((_DWORD *)this + 170));
  printf("-----\nPage Faults : %llu\n-----\n", this[99] - this[80]);
  printf("-----\nPage CoW faults : %llu\n-----\n", this[100] - this[81]);
  printf("-----\nPages Zero Filled: %llu\n-----\n", this[95] - this[76]);
  printf("-----\nPages Reactivated : %llu\n-----\n", this[96] - this[77]);
  printf("-----\nPages Purged : %llu\n-----\n", this[103] - this[84]);
  printf("-----\nPages Decompressed : %llu\n-----\n", this[105] - this[86]);
  printf("-----\nPages Compressed : %llu\n-----\n", this[106] - this[87]);
  printf("-----\nPage Ins : %llu\n-----\n", this[97] - this[78]);
  printf("-----\nPage Outs : %llu\n-----\n", this[98] - this[79]);
  printf("-----\nPage Swap Ins : %llu\n-----\n", this[107] - this[88]);
  printf("-----\nPage Swap Outs : %llu\n-----\n", this[108] - this[89]);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printDiskStatistics(const char **this)
{
  printf("\n-------------------\nModule : %s\n%s Disk Perf Stats\n-------------------\n", this[117], this[118]);
  printf("Total Bytes Read From Disk : %llu\nTotal Bytes Written To Disk : %llu\n", this[55] - this[18], this[56] - this[19]);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::addCPUStatisticsToJson(uint64_t a1, void *a2)
{
  double v3 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      double v3 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    }
    else
    {
      LODWORD(v4) = info.numer;
      LODWORD(v5) = info.denom;
      double v3 = (double)v4 / (double)v5;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v3;
    }
  }
  if (v3 < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v6) = info.numer;
    LODWORD(v7) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v6 / (double)v7;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUCoresAvailable\" : ", 28);
  float v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"CPUUtil[%]\" : ", 16);
  float v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalAbsoluteTime[ms]\" : ", 27);
  float v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUScheduledTime[ms]\" : ", 31);
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUInstructions\" : ", 26);
  double v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUCycles\" : ", 20);
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addMemoryStatisticsToJson(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakDirtyMemoryFootprint[kb]\" : ", 34);
  double v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"DirtyMemoryIncrease[kb]\" : ", 29);
  unint64_t v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"ResidentMemoryIncrease[kb]\" : ", 32);
  unint64_t v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"WiredMemoryIncrease[kb]\" : ", 29);
  unint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapAllocations[kb]\" : ", 30);
  unint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapDeallocations[kb]\" : ", 32);
  float v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakHeapAllocations[kb]\" : ", 29);
  float v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapNodeAllocations\" : ", 30);
  float v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapNodeDeallocations\" : ", 32);
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalVMAllocations[kb]\" : ", 28);
  double v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalVMDeallocations[kb]\" : ", 30);
  unint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakVMAllocations[kb]\" : ", 27);
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addQoSStatisticsToJson(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-UserInitiated-CPUTime[ms]\" : ", 35);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v3) = info.numer;
    LODWORD(v4) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v3 / (double)v4;
  }
  unint64_t v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-UserInteractive-CPUTime[ms]\" : ", 37);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v6) = info.numer;
    LODWORD(v7) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v6 / (double)v7;
  }
  float v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Default-CPUTime[ms]\" : ", 29);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v9) = info.numer;
    LODWORD(v10) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v9 / (double)v10;
  }
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Background-CPUTime[ms]\" : ", 32);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v12) = info.numer;
    LODWORD(v13) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v12 / (double)v13;
  }
  double v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Utility-CPUTime[ms]\" : ", 29);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v15) = info.numer;
    LODWORD(v16) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v15 / (double)v16;
  }
  double v17 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Maintenance-CPUTime[ms]\" : ", 33);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v18) = info.numer;
    LODWORD(v19) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v18 / (double)v19;
  }
  unint64_t v20 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Legacy-CPUTime[ms]\" : ", 28);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v21) = info.numer;
    LODWORD(v22) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v21 / (double)v22;
  }
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addDiskStatisticsToJson(uint64_t a1, void *a2)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalBytesReadFromDisk[kb]\" : ", 32);
  unint64_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalBytesWrittenToDisk[kb]\" : ", 33);
  return std::ostream::operator<<();
}

void re::ProfilerManager::~ProfilerManager(BOOL this)
{
  unsigned int v1 = (void *)this;
  if (*(void *)(this + 136) != *(void *)(this + 144))
  {
    unint64_t v2 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "ProfilerEventStreams submitted but never processed.", buf, 2u);
    }
  }
  if (v1[28] != v1[29])
  {
    unint64_t v3 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)float v54 = 0;
      _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerStatistics submitted but never processed.", v54, 2u);
    }
  }
  if (v1[39] != v1[40])
  {
    unint64_t v4 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)unsigned int v53 = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "ProfilerAttributions submitted but never processed.", v53, 2u);
    }
  }
  if (v1[48] != v1[49])
  {
    unint64_t v5 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)uint64_t v52 = 0;
      _os_log_impl(&dword_233120000, v5, OS_LOG_TYPE_DEFAULT, "ProfilerVisualizers submitted but never processed.", v52, 2u);
    }
  }
  if (v1[57] != v1[58])
  {
    unint64_t v6 = *re::foundationProfilingLogObjects((re *)this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v51 = 0;
      _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, "ProfilerMemoryStatistics submitted but never processed.", v51, 2u);
    }
  }
  for (unint64_t i = (void *)v1[11]; i; unint64_t i = (void *)*i)
  {
    float v8 = (void *)i[2];
    if (v8)
    {
      uint64_t v9 = v8[9];
      if (v9)
      {
        v8[10] = v9;
        MEMORY[0x237DBCBC0]();
      }
      unint64_t v10 = (void *)v8[5];
      unint64_t v11 = (void *)v8[6];
      if (v10 != v11)
      {
        do
        {
          if (*v10) {
            MEMORY[0x237DBCBC0](*v10, 64);
          }
          ++v10;
        }
        while (v10 != v11);
        unint64_t v10 = (void *)v8[5];
      }
      if (v10)
      {
        v8[6] = v10;
        operator delete(v10);
      }
      unint64_t v12 = (void *)v8[1];
      unint64_t v13 = (void *)v8[2];
      if (v12 != v13)
      {
        do
        {
          if (*v12) {
            MEMORY[0x237DBCBC0](*v12, 64);
          }
          ++v12;
        }
        while (v12 != v13);
        unint64_t v12 = (void *)v8[1];
      }
      if (v12)
      {
        void v8[2] = v12;
        operator delete(v12);
      }
      MEMORY[0x237DBCBD0](v8, 0x10A0C40A52C3342);
    }
  }
  for (j = (void *)v1[22]; j; j = (void *)*j)
  {
    uint64_t v15 = j[2];
    if (v15) {
      MEMORY[0x237DBCBC0](v15, 64);
    }
  }
  for (k = (void *)v1[33]; k; k = (void *)*k)
  {
    double v17 = (re::ProfilerAttributions *)k[2];
    if (v17)
    {
      re::ProfilerAttributions::~ProfilerAttributions(v17);
      MEMORY[0x237DBCBC0]();
    }
  }
  unint64_t v18 = (uint64_t *)v1[42];
  unint64_t v19 = (uint64_t *)v1[43];
  while (v18 != v19)
  {
    uint64_t v20 = *v18;
    if (*v18)
    {
      unint64_t v21 = *(void **)(v20 + 8);
      unint64_t v22 = *(void **)(v20 + 16);
      if (v21 != v22)
      {
        do
        {
          if (*v21) {
            MEMORY[0x237DBCBD0](*v21, 0x1000C40CABF92ADLL);
          }
          ++v21;
        }
        while (v21 != v22);
        unint64_t v21 = *(void **)(v20 + 8);
      }
      if (v21)
      {
        *(void *)(v20 + 16) = v21;
        operator delete(v21);
      }
      MEMORY[0x237DBCBD0](v20, 0x1080C401FB89069);
    }
    ++v18;
  }
  double v23 = (void *)v1[51];
  uint64_t v24 = (void *)v1[52];
  while (v23 != v24)
  {
    if (*v23) {
      MEMORY[0x237DBCBC0](*v23, 64);
    }
    ++v23;
  }
  unint64_t v25 = (void *)v1[62];
  if (v25)
  {
    do
    {
      uint64_t v26 = v25[3];
      if (v26) {
        (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
      }
      unint64_t v25 = (void *)*v25;
    }
    while (v25);
    double v27 = (void *)v1[62];
    if (v27)
    {
      do
      {
        uint64_t v28 = (void *)*v27;
        operator delete(v27);
        double v27 = v28;
      }
      while (v28);
    }
  }
  unsigned int v29 = (void *)v1[60];
  v1[60] = 0;
  if (v29) {
    operator delete(v29);
  }
  unint64_t v30 = (void *)v1[57];
  if (v30)
  {
    v1[58] = v30;
    operator delete(v30);
  }
  unint64_t v31 = (void *)v1[54];
  if (v31)
  {
    v1[55] = v31;
    operator delete(v31);
  }
  double v32 = (void *)v1[51];
  if (v32)
  {
    v1[52] = v32;
    operator delete(v32);
  }
  unint64_t v33 = (void *)v1[48];
  if (v33)
  {
    v1[49] = v33;
    operator delete(v33);
  }
  unint64_t v34 = (void *)v1[45];
  if (v34)
  {
    v1[46] = v34;
    operator delete(v34);
  }
  unint64_t v35 = (void *)v1[42];
  if (v35)
  {
    v1[43] = v35;
    operator delete(v35);
  }
  unint64_t v36 = (void *)v1[39];
  if (v36)
  {
    v1[40] = v36;
    operator delete(v36);
  }
  double v37 = (void *)v1[36];
  if (v37)
  {
    v1[37] = v37;
    operator delete(v37);
  }
  uint64_t v38 = (void *)v1[33];
  if (v38)
  {
    do
    {
      unsigned int v39 = (void *)*v38;
      operator delete(v38);
      uint64_t v38 = v39;
    }
    while (v39);
  }
  unint64_t v40 = (void *)v1[31];
  v1[31] = 0;
  if (v40) {
    operator delete(v40);
  }
  uint64_t v41 = (void *)v1[28];
  if (v41)
  {
    v1[29] = v41;
    operator delete(v41);
  }
  uint64_t v42 = (void *)v1[25];
  if (v42)
  {
    v1[26] = v42;
    operator delete(v42);
  }
  unsigned int v43 = (void *)v1[22];
  if (v43)
  {
    do
    {
      unsigned int v44 = (void *)*v43;
      operator delete(v43);
      unsigned int v43 = v44;
    }
    while (v44);
  }
  unsigned int v45 = (void *)v1[20];
  v1[20] = 0;
  if (v45) {
    operator delete(v45);
  }
  float v46 = (void *)v1[17];
  if (v46)
  {
    v1[18] = v46;
    operator delete(v46);
  }
  int v47 = (void *)v1[14];
  if (v47)
  {
    v1[15] = v47;
    operator delete(v47);
  }
  uint64_t v48 = (void *)v1[11];
  if (v48)
  {
    do
    {
      unint64_t v49 = (void *)*v48;
      operator delete(v48);
      uint64_t v48 = v49;
    }
    while (v49);
  }
  double v50 = (void *)v1[9];
  v1[9] = 0;
  if (v50) {
    operator delete(v50);
  }
}

uint64_t re::ProfilerManager::acquireEventStream(re::ProfilerManager *this, int a2)
{
  unint64_t v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  int v5 = *((unsigned __int8 *)this + 532);
  os_unfair_lock_unlock(v4);
  if (!v5) {
    return 0;
  }
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    uint64_t v6 = *((void *)this + 18);
    if (*((void *)this + 17) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      uint64_t v7 = *(void *)(v6 - 8);
      *((void *)this + 18) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7) {
        return v7;
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  uint64_t v8 = *((void *)this + 15);
  if (*((void *)this + 14) == v8)
  {
    if (*((void *)this + 12) < *((void *)this + 3)) {
      operator new();
    }
    if (atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire) != -1)
    {
      v12[0] = &v10;
      v12[1] = this;
      v12[2] = (char *)this + 24;
      unint64_t v11 = v12;
      std::__call_once((std::once_flag::_State_type *)this + 4, &v11, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireEventStream(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
    }
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = *(void *)(v8 - 8);
    *((void *)this + 15) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v7;
}

unint64_t re::ProfilerManager::acquireStatistics(re::ProfilerManager *this, int a2)
{
  int v5 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  int v6 = *((unsigned __int8 *)this + 533);
  os_unfair_lock_unlock(v5);
  if (!v6) {
    return 0;
  }
  if (!a2) {
    goto LABEL_8;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  uint64_t v7 = *((void *)this + 29);
  if (*((void *)this + 28) == v7)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    goto LABEL_8;
  }
  unint64_t v8 = *(void *)(v7 - 8);
  *((void *)this + 29) = v7 - 8;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
  if (!v8)
  {
LABEL_8:
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    uint64_t v9 = *((void *)this + 26);
    if (*((void *)this + 25) != v9)
    {
      unint64_t v8 = *(void *)(v9 - 8);
      *((void *)this + 26) = v9 - 8;
LABEL_89:
      os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
      return v8;
    }
    unint64_t v10 = *((void *)this + 23);
    if (v10 >= *((void *)this + 3))
    {
      if (atomic_load_explicit((atomic_ullong *volatile)this + 5, memory_order_acquire) != -1)
      {
        v49[0] = &v47;
        v49[1] = this;
        v49[2] = (char *)this + 24;
        uint64_t v48 = v49;
        std::__call_once((std::once_flag::_State_type *)this + 5, &v48, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
      unint64_t v8 = 0;
      goto LABEL_89;
    }
    unint64_t v11 = (unint64_t)operator new(0x2780uLL, (std::align_val_t)0x40uLL);
    unint64_t v8 = v11;
    *(void *)unint64_t v11 = *(void *)this;
    uint64_t v12 = -10048;
    do
    {
      unint64_t v13 = (void *)(v11 + v12);
      v13[1264] = -1;
      v13[1265] = 0;
      v13[1267] = 0;
      v13[1266] = 0;
      v12 += 64;
    }
    while (v12);
    unint64_t v14 = 0x9DDFEA08EB382D69 * (((((v11 >> 6) & 0x7FFFFF) << 9) | 8) ^ HIDWORD(v11));
    unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v11) ^ (v14 >> 47) ^ v14);
    unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    unint64_t v17 = *((void *)this + 21);
    if (v17)
    {
      uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
      v18.i16[0] = vaddlv_u8(v18);
      if (v18.u32[0] > 1uLL)
      {
        unint64_t v2 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
        if (v16 >= v17) {
          unint64_t v2 = v16 % v17;
        }
      }
      else
      {
        unint64_t v2 = (v17 - 1) & v16;
      }
      unint64_t v19 = *(void **)(*((void *)this + 20) + 8 * v2);
      if (v19)
      {
        for (unint64_t i = (void *)*v19; i; unint64_t i = (void *)*i)
        {
          unint64_t v21 = i[1];
          if (v21 == v16)
          {
            if (i[2] == v11) {
              goto LABEL_89;
            }
          }
          else
          {
            if (v18.u32[0] > 1uLL)
            {
              if (v21 >= v17) {
                v21 %= v17;
              }
            }
            else
            {
              v21 &= v17 - 1;
            }
            if (v21 != v2) {
              break;
            }
          }
        }
      }
    }
    unint64_t v22 = operator new(0x18uLL);
    *unint64_t v22 = 0;
    v22[1] = v16;
    v22[2] = v8;
    float v23 = (float)(v10 + 1);
    float v24 = *((float *)this + 48);
    if (v17 && (float)(v24 * (float)v17) >= v23)
    {
LABEL_79:
      uint64_t v41 = *((void *)this + 20);
      uint64_t v42 = *(void **)(v41 + 8 * v2);
      if (v42)
      {
        *unint64_t v22 = *v42;
      }
      else
      {
        uint64_t v43 = *((void *)this + 22);
        *unint64_t v22 = v43;
        *((void *)this + 22) = v22;
        *(void *)(v41 + 8 * v2) = (char *)this + 176;
        if (!v43)
        {
LABEL_88:
          ++*((void *)this + 23);
          goto LABEL_89;
        }
        unint64_t v44 = *(void *)(v43 + 8);
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v44 >= v17) {
            v44 %= v17;
          }
        }
        else
        {
          v44 &= v17 - 1;
        }
        uint64_t v42 = (void *)(*((void *)this + 20) + 8 * v44);
      }
      *uint64_t v42 = v22;
      goto LABEL_88;
    }
    BOOL v25 = 1;
    if (v17 >= 3) {
      BOOL v25 = (v17 & (v17 - 1)) != 0;
    }
    unint64_t v26 = v25 | (2 * v17);
    unint64_t v27 = vcvtps_u32_f32(v23 / v24);
    if (v26 <= v27) {
      int8x8_t prime = (int8x8_t)v27;
    }
    else {
      int8x8_t prime = (int8x8_t)v26;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v17 = *((void *)this + 21);
    }
    if (*(void *)&prime > v17) {
      goto LABEL_45;
    }
    if (*(void *)&prime < v17)
    {
      unint64_t v35 = vcvtps_u32_f32((float)*((unint64_t *)this + 23) / *((float *)this + 48));
      if (v17 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        unint64_t v35 = std::__next_prime(v35);
      }
      else
      {
        uint64_t v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2) {
          unint64_t v35 = v37;
        }
      }
      if (*(void *)&prime <= v35) {
        int8x8_t prime = (int8x8_t)v35;
      }
      if (*(void *)&prime >= v17)
      {
        unint64_t v17 = *((void *)this + 21);
      }
      else
      {
        if (prime)
        {
LABEL_45:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v29 = operator new(8 * *(void *)&prime);
          unint64_t v30 = (void *)*((void *)this + 20);
          *((void *)this + 20) = v29;
          if (v30) {
            operator delete(v30);
          }
          uint64_t v31 = 0;
          *((int8x8_t *)this + 21) = prime;
          do
            *(void *)(*((void *)this + 20) + 8 * v31++) = 0;
          while (*(void *)&prime != v31);
          double v32 = (void *)*((void *)this + 22);
          if (v32)
          {
            unint64_t v33 = v32[1];
            uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
            v34.i16[0] = vaddlv_u8(v34);
            if (v34.u32[0] > 1uLL)
            {
              if (v33 >= *(void *)&prime) {
                v33 %= *(void *)&prime;
              }
            }
            else
            {
              v33 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 20) + 8 * v33) = (char *)this + 176;
            uint64_t v38 = (void *)*v32;
            if (*v32)
            {
              do
              {
                unint64_t v39 = v38[1];
                if (v34.u32[0] > 1uLL)
                {
                  if (v39 >= *(void *)&prime) {
                    v39 %= *(void *)&prime;
                  }
                }
                else
                {
                  v39 &= *(void *)&prime - 1;
                }
                if (v39 != v33)
                {
                  uint64_t v40 = *((void *)this + 20);
                  if (!*(void *)(v40 + 8 * v39))
                  {
                    *(void *)(v40 + 8 * v39) = v32;
                    goto LABEL_70;
                  }
                  *double v32 = *v38;
                  *uint64_t v38 = **(void **)(*((void *)this + 20) + 8 * v39);
                  **(void **)(*((void *)this + 20) + 8 * v39) = v38;
                  uint64_t v38 = v32;
                }
                unint64_t v39 = v33;
LABEL_70:
                double v32 = v38;
                uint64_t v38 = (void *)*v38;
                unint64_t v33 = v39;
              }
              while (v38);
            }
          }
          unint64_t v17 = (unint64_t)prime;
          goto LABEL_74;
        }
        float v46 = (void *)*((void *)this + 20);
        *((void *)this + 20) = 0;
        if (v46) {
          operator delete(v46);
        }
        unint64_t v17 = 0;
        *((void *)this + 21) = 0;
      }
    }
LABEL_74:
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v16 >= v17) {
        unint64_t v2 = v16 % v17;
      }
      else {
        unint64_t v2 = v16;
      }
    }
    else
    {
      unint64_t v2 = (v17 - 1) & v16;
    }
    goto LABEL_79;
  }
  return v8;
}

re::ProfilerAttributions *re::ProfilerManager::acquireAttributions(re::ProfilerManager *this, int a2)
{
  int v5 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  int v6 = *((unsigned __int8 *)this + 534);
  os_unfair_lock_unlock(v5);
  if (!v6) {
    return 0;
  }
  if (!a2) {
    goto LABEL_8;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  uint64_t v7 = *((void *)this + 40);
  if (*((void *)this + 39) == v7)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    goto LABEL_8;
  }
  unint64_t v8 = *(re::ProfilerAttributions **)(v7 - 8);
  *((void *)this + 40) = v7 - 8;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
  if (!v8)
  {
LABEL_8:
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    uint64_t v9 = *((void *)this + 37);
    if (*((void *)this + 36) != v9)
    {
      unint64_t v8 = *(re::ProfilerAttributions **)(v9 - 8);
      *((void *)this + 37) = v9 - 8;
LABEL_87:
      os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
      return v8;
    }
    if (*((void *)this + 34) >= *((void *)this + 3))
    {
      if (atomic_load_explicit((atomic_ullong *volatile)this + 6, memory_order_acquire) != -1)
      {
        v46[0] = &v44;
        v46[1] = this;
        v46[2] = (char *)this + 24;
        unsigned int v45 = v46;
        std::__call_once((std::once_flag::_State_type *)this + 6, &v45, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireAttributions(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
      unint64_t v8 = 0;
      goto LABEL_87;
    }
    unint64_t v8 = (re::ProfilerAttributions *)operator new(0x180uLL, (std::align_val_t)0x40uLL);
    unint64_t v10 = re::ProfilerAttributions::ProfilerAttributions(v8, *(void *)this);
    unint64_t v11 = 0x9DDFEA08EB382D69 * ((((((unint64_t)v8 >> 6) & 0x7FFFFF) << 9) | 8) ^ ((unint64_t)v10 >> 32));
    unint64_t v12 = 0x9DDFEA08EB382D69 * (((unint64_t)v10 >> 32) ^ (v11 >> 47) ^ v11);
    unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
    unint64_t v14 = *((void *)this + 32);
    if (v14)
    {
      uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        unint64_t v2 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
        if (v13 >= v14) {
          unint64_t v2 = v13 % v14;
        }
      }
      else
      {
        unint64_t v2 = v13 & (v14 - 1);
      }
      unint64_t v16 = *(void **)(*((void *)this + 31) + 8 * v2);
      if (v16)
      {
        for (unint64_t i = (void *)*v16; i; unint64_t i = (void *)*i)
        {
          unint64_t v18 = i[1];
          if (v18 == v13)
          {
            if ((re::ProfilerAttributions *)i[2] == v8) {
              goto LABEL_87;
            }
          }
          else
          {
            if (v15.u32[0] > 1uLL)
            {
              if (v18 >= v14) {
                v18 %= v14;
              }
            }
            else
            {
              v18 &= v14 - 1;
            }
            if (v18 != v2) {
              break;
            }
          }
        }
      }
    }
    unint64_t v19 = operator new(0x18uLL);
    *unint64_t v19 = 0;
    v19[1] = v13;
    v19[2] = v8;
    float v20 = (float)(unint64_t)(*((void *)this + 34) + 1);
    float v21 = *((float *)this + 70);
    if (v14 && (float)(v21 * (float)v14) >= v20)
    {
LABEL_77:
      uint64_t v38 = *((void *)this + 31);
      unint64_t v39 = *(void **)(v38 + 8 * v2);
      if (v39)
      {
        *unint64_t v19 = *v39;
      }
      else
      {
        uint64_t v40 = *((void *)this + 33);
        *unint64_t v19 = v40;
        *((void *)this + 33) = v19;
        *(void *)(v38 + 8 * v2) = (char *)this + 264;
        if (!v40)
        {
LABEL_86:
          ++*((void *)this + 34);
          goto LABEL_87;
        }
        unint64_t v41 = *(void *)(v40 + 8);
        if ((v14 & (v14 - 1)) != 0)
        {
          if (v41 >= v14) {
            v41 %= v14;
          }
        }
        else
        {
          v41 &= v14 - 1;
        }
        unint64_t v39 = (void *)(*((void *)this + 31) + 8 * v41);
      }
      *unint64_t v39 = v19;
      goto LABEL_86;
    }
    BOOL v22 = 1;
    if (v14 >= 3) {
      BOOL v22 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v14);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v14 = *((void *)this + 32);
    }
    if (*(void *)&prime > v14) {
      goto LABEL_43;
    }
    if (*(void *)&prime < v14)
    {
      unint64_t v32 = vcvtps_u32_f32((float)*((unint64_t *)this + 34) / *((float *)this + 70));
      if (v14 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v14)
      {
        unint64_t v14 = *((void *)this + 32);
      }
      else
      {
        if (prime)
        {
LABEL_43:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v26 = operator new(8 * *(void *)&prime);
          unint64_t v27 = (void *)*((void *)this + 31);
          *((void *)this + 31) = v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0;
          *((int8x8_t *)this + 32) = prime;
          do
            *(void *)(*((void *)this + 31) + 8 * v28++) = 0;
          while (*(void *)&prime != v28);
          unsigned int v29 = (void *)*((void *)this + 33);
          if (v29)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }
            else
            {
              v30 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 31) + 8 * v30) = (char *)this + 264;
            unint64_t v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }
                else
                {
                  v36 &= *(void *)&prime - 1;
                }
                if (v36 != v30)
                {
                  uint64_t v37 = *((void *)this + 31);
                  if (!*(void *)(v37 + 8 * v36))
                  {
                    *(void *)(v37 + 8 * v36) = v29;
                    goto LABEL_68;
                  }
                  *unsigned int v29 = *v35;
                  *unint64_t v35 = **(void **)(*((void *)this + 31) + 8 * v36);
                  **(void **)(*((void *)this + 31) + 8 * v36) = v35;
                  unint64_t v35 = v29;
                }
                unint64_t v36 = v30;
LABEL_68:
                unsigned int v29 = v35;
                unint64_t v35 = (void *)*v35;
                unint64_t v30 = v36;
              }
              while (v35);
            }
          }
          unint64_t v14 = (unint64_t)prime;
          goto LABEL_72;
        }
        uint64_t v43 = (void *)*((void *)this + 31);
        *((void *)this + 31) = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v14 = 0;
        *((void *)this + 32) = 0;
      }
    }
LABEL_72:
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14) {
        unint64_t v2 = v13 % v14;
      }
      else {
        unint64_t v2 = v13;
      }
    }
    else
    {
      unint64_t v2 = (v14 - 1) & v13;
    }
    goto LABEL_77;
  }
  return v8;
}

uint64_t re::ProfilerManager::acquireVisualizer(re::ProfilerManager *this)
{
  return 0;
}

void *re::ProfilerManager::acquireMemoryStatistics(re::ProfilerManager *this, int a2)
{
  unint64_t v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  int v5 = *((unsigned __int8 *)this + 535);
  os_unfair_lock_unlock(v4);
  if (!v5) {
    return 0;
  }
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    uint64_t v6 = *((void *)this + 58);
    if (*((void *)this + 57) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      uint64_t v7 = *(void **)(v6 - 8);
      *((void *)this + 58) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7) {
        return v7;
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  uint64_t v8 = *((void *)this + 55);
  if (*((void *)this + 54) == v8)
  {
    uint64_t v10 = *((void *)this + 51);
    uint64_t v9 = (void *)*((void *)this + 52);
    unint64_t v11 = ((uint64_t)v9 - v10) >> 3;
    if (v11 >= *((void *)this + 3))
    {
      if (atomic_load_explicit((atomic_ullong *volatile)this + 8, memory_order_acquire) != -1)
      {
        v29[0] = &v27;
        v29[1] = this;
        v29[2] = (char *)this + 24;
        uint64_t v28 = v29;
        std::__call_once((std::once_flag::_State_type *)this + 8, &v28, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireMemoryStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
      uint64_t v7 = 0;
    }
    else
    {
      unint64_t v12 = operator new(0x580uLL, (std::align_val_t)0x40uLL);
      uint64_t v7 = v12;
      uint64_t v13 = 0;
      *unint64_t v12 = *(void *)this;
      do
      {
        unint64_t v14 = &v12[v13];
        v14[8] = -1;
        *(_OWORD *)(v14 + 9) = 0uLL;
        *(_OWORD *)(v14 + 11) = 0uLL;
        *(_OWORD *)(v14 + 13) = 0uLL;
        v13 += 8;
      }
      while (v13 != 160);
      v12[168] = 0;
      unint64_t v15 = *((void *)this + 53);
      if ((unint64_t)v9 >= v15)
      {
        unint64_t v17 = v11 + 1;
        if ((v11 + 1) >> 61) {
          abort();
        }
        uint64_t v18 = v15 - v10;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19) {
          float v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)this + 424, v19);
        }
        else {
          float v20 = 0;
        }
        float v21 = &v20[8 * v11];
        BOOL v22 = &v20[8 * v19];
        *(void *)float v21 = v7;
        unint64_t v16 = v21 + 8;
        unint64_t v24 = (char *)*((void *)this + 51);
        unint64_t v23 = (char *)*((void *)this + 52);
        if (v23 != v24)
        {
          do
          {
            uint64_t v25 = *((void *)v23 - 1);
            v23 -= 8;
            *((void *)v21 - 1) = v25;
            v21 -= 8;
          }
          while (v23 != v24);
          unint64_t v23 = (char *)*((void *)this + 51);
        }
        *((void *)this + 51) = v21;
        *((void *)this + 52) = v16;
        *((void *)this + 53) = v22;
        if (v23) {
          operator delete(v23);
        }
      }
      else
      {
        *uint64_t v9 = v12;
        unint64_t v16 = v9 + 1;
      }
      *((void *)this + 52) = v16;
    }
  }
  else
  {
    uint64_t v7 = *(void **)(v8 - 8);
    *((void *)this + 55) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v7;
}

void re::ProfilerManager::submit(uint64_t a1, void *a2)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "stream", "submit", 308);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (*a2 != *(void *)a1)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "stream->ownerId() == m_identifier", "submit", 309);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(a1 + 152);
  uint64_t v7 = *(void **)(a1 + 144);
  if ((unint64_t)v7 < v6)
  {
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)(a1 + 136);
  uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61) {
LABEL_24:
  }
    abort();
  uint64_t v11 = v6 - v9;
  uint64_t v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
    uint64_t v12 = v10 + 1;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13) {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 152, v13);
  }
  else {
    unint64_t v14 = 0;
  }
  unint64_t v15 = &v14[8 * v10];
  unint64_t v16 = &v14[8 * v13];
  *(void *)unint64_t v15 = a2;
  uint64_t v8 = v15 + 8;
  uint64_t v18 = *(char **)(a1 + 136);
  unint64_t v17 = *(char **)(a1 + 144);
  if (v17 != v18)
  {
    do
    {
      uint64_t v19 = *((void *)v17 - 1);
      v17 -= 8;
      *((void *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    unint64_t v17 = *(char **)(a1 + 136);
  }
  *(void *)(a1 + 136) = v15;
  *(void *)(a1 + 144) = v8;
  *(void *)(a1 + 152) = v16;
  if (v17) {
    operator delete(v17);
  }
LABEL_19:
  *(void *)(a1 + 144) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t vars8;

  unint64_t v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "statistics", "submit", 317);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (*a2 != *(void *)a1)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "statistics->ownerId() == m_identifier", "submit", 318);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v6 = *(void *)(a1 + 240);
  uint64_t v7 = *(void **)(a1 + 232);
  if ((unint64_t)v7 < v6)
  {
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)(a1 + 224);
  uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61) {
LABEL_24:
  }
    abort();
  uint64_t v11 = v6 - v9;
  uint64_t v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
    uint64_t v12 = v10 + 1;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13) {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 240, v13);
  }
  else {
    unint64_t v14 = 0;
  }
  unint64_t v15 = &v14[8 * v10];
  unint64_t v16 = &v14[8 * v13];
  *(void *)unint64_t v15 = a2;
  uint64_t v8 = v15 + 8;
  uint64_t v18 = *(char **)(a1 + 224);
  unint64_t v17 = *(char **)(a1 + 232);
  if (v17 != v18)
  {
    do
    {
      uint64_t v19 = *((void *)v17 - 1);
      v17 -= 8;
      *((void *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    unint64_t v17 = *(char **)(a1 + 224);
  }
  *(void *)(a1 + 224) = v15;
  *(void *)(a1 + 232) = v8;
  *(void *)(a1 + 240) = v16;
  if (v17) {
    operator delete(v17);
  }
LABEL_19:
  *(void *)(a1 + 232) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t vars8;

  unint64_t v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "memoryStatistics", "submit", 335);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (*a2 != *(void *)a1)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "memoryStatistics->ownerId() == m_identifier", "submit", 336);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v7 = *(void **)(a1 + 464);
  unint64_t v6 = *(void *)(a1 + 472);
  if ((unint64_t)v7 < v6)
  {
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)(a1 + 456);
  uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61) {
LABEL_24:
  }
    abort();
  uint64_t v11 = v6 - v9;
  uint64_t v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
    uint64_t v12 = v10 + 1;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13) {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 472, v13);
  }
  else {
    unint64_t v14 = 0;
  }
  unint64_t v15 = &v14[8 * v10];
  unint64_t v16 = &v14[8 * v13];
  *(void *)unint64_t v15 = a2;
  uint64_t v8 = v15 + 8;
  uint64_t v18 = *(char **)(a1 + 456);
  unint64_t v17 = *(char **)(a1 + 464);
  if (v17 != v18)
  {
    do
    {
      uint64_t v19 = *((void *)v17 - 1);
      v17 -= 8;
      *((void *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    unint64_t v17 = *(char **)(a1 + 456);
  }
  *(void *)(a1 + 456) = v15;
  *(void *)(a1 + 464) = v8;
  *(void *)(a1 + 472) = v16;
  if (v17) {
    operator delete(v17);
  }
LABEL_19:
  *(void *)(a1 + 464) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t vars8;

  unint64_t v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "renderer", "submit", 344);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (*a2 != *(void *)a1)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "renderer->ownerId() == m_identifier", "submit", 345);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v7 = *(void **)(a1 + 392);
  unint64_t v6 = *(void *)(a1 + 400);
  if ((unint64_t)v7 < v6)
  {
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)(a1 + 384);
  uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61) {
LABEL_24:
  }
    abort();
  uint64_t v11 = v6 - v9;
  uint64_t v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
    uint64_t v12 = v10 + 1;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13) {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 400, v13);
  }
  else {
    unint64_t v14 = 0;
  }
  unint64_t v15 = &v14[8 * v10];
  unint64_t v16 = &v14[8 * v13];
  *(void *)unint64_t v15 = a2;
  uint64_t v8 = v15 + 8;
  uint64_t v18 = *(char **)(a1 + 384);
  unint64_t v17 = *(char **)(a1 + 392);
  if (v17 != v18)
  {
    do
    {
      uint64_t v19 = *((void *)v17 - 1);
      v17 -= 8;
      *((void *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    unint64_t v17 = *(char **)(a1 + 384);
  }
  *(void *)(a1 + 384) = v15;
  *(void *)(a1 + 392) = v8;
  *(void *)(a1 + 400) = v16;
  if (v17) {
    operator delete(v17);
  }
LABEL_19:
  *(void *)(a1 + 392) = v8;
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::submit(os_unfair_lock_s *this, re::ProfilerAttributions *a2)
{
  unint64_t v4 = this + 3;
  os_unfair_lock_lock(this + 3);
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "attributions", "submit", 326);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  if (*((void *)a2 + 32) != *(void *)&this->_os_unfair_lock_opaque)
  {
LABEL_23:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "attributions->ownerId() == m_identifier", "submit", 327);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v7 = *(void **)&this[80]._os_unfair_lock_opaque;
  unint64_t v6 = *(void *)&this[82]._os_unfair_lock_opaque;
  if ((unint64_t)v7 < v6)
  {
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    goto LABEL_19;
  }
  uint64_t v9 = *(void *)&this[78]._os_unfair_lock_opaque;
  uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61) {
LABEL_24:
  }
    abort();
  uint64_t v11 = v6 - v9;
  uint64_t v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
    uint64_t v12 = v10 + 1;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13) {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&this[82], v13);
  }
  else {
    unint64_t v14 = 0;
  }
  unint64_t v15 = &v14[8 * v10];
  unint64_t v16 = &v14[8 * v13];
  *(void *)unint64_t v15 = a2;
  uint64_t v8 = v15 + 8;
  uint64_t v18 = *(char **)&this[78]._os_unfair_lock_opaque;
  unint64_t v17 = *(char **)&this[80]._os_unfair_lock_opaque;
  if (v17 != v18)
  {
    do
    {
      uint64_t v19 = *((void *)v17 - 1);
      v17 -= 8;
      *((void *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    unint64_t v17 = *(char **)&this[78]._os_unfair_lock_opaque;
  }
  *(void *)&this[78]._os_unfair_lock_opaque = v15;
  *(void *)&this[80]._os_unfair_lock_opaque = v8;
  *(void *)&this[82]._os_unfair_lock_opaque = v16;
  if (v17) {
    operator delete(v17);
  }
LABEL_19:
  *(void *)&this[80]._os_unfair_lock_opaque = v8;
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::process(uint64_t a1, void *a2)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  unsigned int v112 = 0;
  float v113 = 0;
  double v114 = 0;
  unint64_t v6 = *(unsigned char **)(a1 + 136);
  uint64_t v5 = *(unsigned char **)(a1 + 144);
  size_t v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v5 - v6 < 0) {
      goto LABEL_121;
    }
    unsigned int v112 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v114, v7 >> 3);
    double v114 = (char *)v112 + 8 * v8;
    memmove(v112, v6, v7);
    float v113 = (char *)v112 + v7;
  }
  double v109 = 0;
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  uint64_t v10 = *(unsigned char **)(a1 + 224);
  uint64_t v9 = *(unsigned char **)(a1 + 232);
  size_t v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v9 - v10 < 0) {
      goto LABEL_121;
    }
    double v109 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v11 >> 3);
    uint64_t v111 = (char *)v109 + 8 * v12;
    memmove(v109, v10, v11);
    uint64_t v110 = (char *)v109 + v11;
  }
  double v106 = 0;
  unint64_t v107 = 0;
  unint64_t v108 = 0;
  unint64_t v14 = *(unsigned char **)(a1 + 312);
  unint64_t v13 = *(unsigned char **)(a1 + 320);
  size_t v15 = v13 - v14;
  if (v13 != v14)
  {
    if (v13 - v14 < 0) {
      goto LABEL_121;
    }
    double v106 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v108, v15 >> 3);
    unint64_t v108 = (char *)v106 + 8 * v16;
    memmove(v106, v14, v15);
    unint64_t v107 = (re::ProfilerAttributions **)((char *)v106 + v15);
  }
  std::string __p = 0;
  float v104 = 0;
  double v105 = 0;
  uint64_t v18 = *(unsigned char **)(a1 + 456);
  unint64_t v17 = *(unsigned char **)(a1 + 464);
  size_t v19 = v17 - v18;
  if (v17 == v18) {
    goto LABEL_13;
  }
  if (v17 - v18 < 0) {
LABEL_121:
  }
    abort();
  std::string __p = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v105, v19 >> 3);
  double v105 = (char *)__p + 8 * v20;
  memmove(__p, v18, v19);
  float v104 = (char *)__p + v19;
  uint64_t v18 = *(unsigned char **)(a1 + 456);
LABEL_13:
  *(void *)(a1 + 144) = *(void *)(a1 + 136);
  *(void *)(a1 + 232) = *(void *)(a1 + 224);
  *(void *)(a1 + 320) = *(void *)(a1 + 312);
  *(void *)(a1 + 464) = v18;
  os_unfair_lock_unlock(v4);
  if (a2[3])
  {
    float v21 = (re::ProfilerAttributions **)v106;
    BOOL v22 = v107;
    while (v21 != v22)
    {
      unint64_t v23 = *v21++;
      re::ProfilerAttributions::resolveDeferred(v23, a2);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  ++*(_DWORD *)(a1 + 528);
  for (unint64_t i = *(void **)(a1 + 496); i; unint64_t i = (void *)*i)
  {
    uint64_t v25 = (unsigned char *)i[3];
    if (v25[8])
    {
      unsigned int v26 = *(_DWORD *)(a1 + 528);
      if (!(v26 % (*(unsigned int (**)(void))(*(void *)v25 + 56))(i[3]))) {
        (*(void (**)(unsigned char *, void, void **, void **, void **, void **))(*(void *)v25 + 16))(v25, *(void *)(a1 + 520), &v112, &v109, &v106, &__p);
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  char v27 = (uint64_t *)v112;
  uint64_t v28 = (uint64_t *)v113;
  while (v27 != v28)
  {
    uint64_t v29 = *v27++;
    *(_DWORD *)(v29 + 32) = 0;
    *(_DWORD *)(v29 + 64) = 0;
    *(void *)(v29 + 80) = *(void *)(v29 + 72);
  }
  unint64_t v30 = v109;
  uint8x8_t v31 = v110;
  if (v109 != v110)
  {
    do
    {
      uint64_t v32 = *v30 + 64;
      uint64_t v33 = -10048;
      do
      {
        uint64_t v34 = v32 + v33;
        *(_OWORD *)(v34 + 10048) = re::kProfilerCounterEmpty;
        *(_OWORD *)(v34 + 10064) = *(_OWORD *)algn_23440BB10;
        v33 += 64;
      }
      while (v33);
      ++v30;
    }
    while (v30 != v31);
  }
  unint64_t v35 = (re::ProfilerAttributions **)v106;
  unint64_t v36 = v107;
  while (v35 != v36)
  {
    uint64_t v37 = *v35++;
    re::ProfilerAttributions::clear(v37);
  }
  uint64_t v38 = (uint64_t *)__p;
  unint64_t v39 = (uint64_t *)v104;
  if (__p != v104)
  {
    do
    {
      uint64_t v40 = *v38;
      for (uint64_t j = 64; j != 1344; j += 64)
      {
        uint64_t v42 = v40 + j;
        *(_OWORD *)uint64_t v42 = re::kProfilerMemoryCounterEmpty;
        *(_OWORD *)(v42 + 16) = *(_OWORD *)algn_23440BB50;
        *(_OWORD *)(v42 + 32) = xmmword_23440BB60;
        *(void *)(v42 + 48) = 0;
      }
      *(void *)(v40 + 1344) = 0;
      ++v38;
    }
    while (v38 != v39);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  uint64_t v43 = (uint64_t *)v112;
  char v44 = (uint64_t *)v113;
  if (v112 != v113)
  {
    unsigned int v45 = (void *)(a1 + 128);
    float v46 = *(void **)(a1 + 120);
    do
    {
      uint64_t v47 = *v43;
      if ((unint64_t)v46 >= *v45)
      {
        uint64_t v48 = *(void *)(a1 + 112);
        uint64_t v49 = ((uint64_t)v46 - v48) >> 3;
        if ((unint64_t)(v49 + 1) >> 61) {
          goto LABEL_121;
        }
        uint64_t v50 = *v45 - v48;
        uint64_t v51 = v50 >> 2;
        if (v50 >> 2 <= (unint64_t)(v49 + 1)) {
          uint64_t v51 = v49 + 1;
        }
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v52 = v51;
        }
        if (v52) {
          unsigned int v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 128, v52);
        }
        else {
          unsigned int v53 = 0;
        }
        float v54 = &v53[8 * v49];
        *(void *)float v54 = v47;
        float v46 = v54 + 8;
        double v56 = *(char **)(a1 + 112);
        int v55 = *(char **)(a1 + 120);
        if (v55 != v56)
        {
          do
          {
            uint64_t v57 = *((void *)v55 - 1);
            v55 -= 8;
            *((void *)v54 - 1) = v57;
            v54 -= 8;
          }
          while (v55 != v56);
          int v55 = *(char **)(a1 + 112);
        }
        *(void *)(a1 + 112) = v54;
        *(void *)(a1 + 120) = v46;
        *(void *)(a1 + 128) = &v53[8 * v52];
        if (v55) {
          operator delete(v55);
        }
      }
      else
      {
        *v46++ = v47;
      }
      *(void *)(a1 + 120) = v46;
      ++v43;
    }
    while (v43 != v44);
  }
  unint64_t v58 = (uint64_t *)v109;
  double v59 = (uint64_t *)v110;
  if (v109 != v110)
  {
    uint64_t v60 = (void *)(a1 + 216);
    uint64_t v61 = *(void **)(a1 + 208);
    do
    {
      uint64_t v62 = *v58;
      if ((unint64_t)v61 >= *v60)
      {
        uint64_t v63 = *(void *)(a1 + 200);
        uint64_t v64 = ((uint64_t)v61 - v63) >> 3;
        if ((unint64_t)(v64 + 1) >> 61) {
          goto LABEL_121;
        }
        uint64_t v65 = *v60 - v63;
        uint64_t v66 = v65 >> 2;
        if (v65 >> 2 <= (unint64_t)(v64 + 1)) {
          uint64_t v66 = v64 + 1;
        }
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v67 = v66;
        }
        if (v67) {
          double v68 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 216, v67);
        }
        else {
          double v68 = 0;
        }
        float v69 = &v68[8 * v64];
        *(void *)float v69 = v62;
        uint64_t v61 = v69 + 8;
        float v71 = *(char **)(a1 + 200);
        float v70 = *(char **)(a1 + 208);
        if (v70 != v71)
        {
          do
          {
            uint64_t v72 = *((void *)v70 - 1);
            v70 -= 8;
            *((void *)v69 - 1) = v72;
            v69 -= 8;
          }
          while (v70 != v71);
          float v70 = *(char **)(a1 + 200);
        }
        *(void *)(a1 + 200) = v69;
        *(void *)(a1 + 208) = v61;
        *(void *)(a1 + 216) = &v68[8 * v67];
        if (v70) {
          operator delete(v70);
        }
      }
      else
      {
        *v61++ = v62;
      }
      *(void *)(a1 + 208) = v61;
      ++v58;
    }
    while (v58 != v59);
  }
  float v73 = (re::ProfilerAttributions **)v106;
  float v74 = v107;
  if (v106 != v107)
  {
    unsigned int v75 = (void *)(a1 + 304);
    unsigned int v76 = *(re::ProfilerAttributions ***)(a1 + 296);
    do
    {
      unsigned int v77 = *v73;
      if ((unint64_t)v76 >= *v75)
      {
        uint64_t v78 = *(void *)(a1 + 288);
        uint64_t v79 = ((uint64_t)v76 - v78) >> 3;
        if ((unint64_t)(v79 + 1) >> 61) {
          goto LABEL_121;
        }
        uint64_t v80 = *v75 - v78;
        uint64_t v81 = v80 >> 2;
        if (v80 >> 2 <= (unint64_t)(v79 + 1)) {
          uint64_t v81 = v79 + 1;
        }
        if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v82 = v81;
        }
        if (v82) {
          uint64_t v83 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 304, v82);
        }
        else {
          uint64_t v83 = 0;
        }
        BOOL v84 = &v83[8 * v79];
        *(void *)BOOL v84 = v77;
        unsigned int v76 = (re::ProfilerAttributions **)(v84 + 8);
        double v86 = *(char **)(a1 + 288);
        uint64_t v85 = *(char **)(a1 + 296);
        if (v85 != v86)
        {
          do
          {
            uint64_t v87 = *((void *)v85 - 1);
            v85 -= 8;
            *((void *)v84 - 1) = v87;
            v84 -= 8;
          }
          while (v85 != v86);
          uint64_t v85 = *(char **)(a1 + 288);
        }
        *(void *)(a1 + 288) = v84;
        *(void *)(a1 + 296) = v76;
        *(void *)(a1 + 304) = &v83[8 * v82];
        if (v85) {
          operator delete(v85);
        }
      }
      else
      {
        *v76++ = v77;
      }
      *(void *)(a1 + 296) = v76;
      ++v73;
    }
    while (v73 != v74);
  }
  uint64_t v88 = (uint64_t *)__p;
  uint64_t v89 = (uint64_t *)v104;
  if (__p != v104)
  {
    float v90 = (void *)(a1 + 448);
    uint64_t v91 = *(void **)(a1 + 440);
    do
    {
      uint64_t v92 = *v88;
      if ((unint64_t)v91 >= *v90)
      {
        uint64_t v93 = *(void *)(a1 + 432);
        uint64_t v94 = ((uint64_t)v91 - v93) >> 3;
        if ((unint64_t)(v94 + 1) >> 61) {
          goto LABEL_121;
        }
        uint64_t v95 = *v90 - v93;
        uint64_t v96 = v95 >> 2;
        if (v95 >> 2 <= (unint64_t)(v94 + 1)) {
          uint64_t v96 = v94 + 1;
        }
        if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v97 = v96;
        }
        if (v97) {
          unint64_t v98 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 448, v97);
        }
        else {
          unint64_t v98 = 0;
        }
        unint64_t v99 = &v98[8 * v94];
        *(void *)unint64_t v99 = v92;
        uint64_t v91 = v99 + 8;
        uint64_t v101 = *(char **)(a1 + 432);
        double v100 = *(char **)(a1 + 440);
        if (v100 != v101)
        {
          do
          {
            uint64_t v102 = *((void *)v100 - 1);
            v100 -= 8;
            *((void *)v99 - 1) = v102;
            v99 -= 8;
          }
          while (v100 != v101);
          double v100 = *(char **)(a1 + 432);
        }
        *(void *)(a1 + 432) = v99;
        *(void *)(a1 + 440) = v91;
        *(void *)(a1 + 448) = &v98[8 * v97];
        if (v100) {
          operator delete(v100);
        }
      }
      else
      {
        *v91++ = v92;
      }
      *(void *)(a1 + 440) = v91;
      ++v88;
    }
    while (v88 != v89);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
  if (__p)
  {
    float v104 = (char *)__p;
    operator delete(__p);
  }
  if (v106)
  {
    unint64_t v107 = (re::ProfilerAttributions **)v106;
    operator delete(v106);
  }
  if (v109)
  {
    uint64_t v110 = (char *)v109;
    operator delete(v109);
  }
  if (v112)
  {
    float v113 = (char *)v112;
    operator delete(v112);
  }
}

void *re::allocInfo_ProfilerManager(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_432, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_432))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF997C8, "ProfilerManager");
    __cxa_guard_release(&_MergedGlobals_432);
  }
  return &unk_26AF997C8;
}

void re::initInfo_ProfilerManager(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x2B0128137FA56C8;
  v5[1] = "ProfilerManager";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x21800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_ProfilerManager(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_ProfilerManager(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ProfilerManager", (uint64_t (*)(re::internal *))re::allocInfo_ProfilerManager, (re::IntrospectionBase *(*)(void))re::initInfo_ProfilerManager, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ProfilerManager>, this);
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireEventStream(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v1 = **(void **)(*(void *)a1 + 8);
  uint64_t v2 = **(void **)(*(void *)a1 + 16);
  unint64_t v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 134218240;
    uint64_t v5 = v2;
    __int16 v6 = 2048;
    uint64_t v7 = v1;
    _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerEventStream limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v1 = **(void **)(*(void *)a1 + 8);
  uint64_t v2 = **(void **)(*(void *)a1 + 16);
  unint64_t v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 134218240;
    uint64_t v5 = v2;
    __int16 v6 = 2048;
    uint64_t v7 = v1;
    _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerStatistics limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireAttributions(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v1 = **(void **)(*(void *)a1 + 8);
  uint64_t v2 = **(void **)(*(void *)a1 + 16);
  unint64_t v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 134218240;
    uint64_t v5 = v2;
    __int16 v6 = 2048;
    uint64_t v7 = v1;
    _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerAttributions limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireMemoryStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v1 = **(void **)(*(void *)a1 + 8);
  uint64_t v2 = **(void **)(*(void *)a1 + 16);
  unint64_t v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 134218240;
    uint64_t v5 = v2;
    __int16 v6 = 2048;
    uint64_t v7 = v1;
    _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerMemoryStatistics limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

re::ProfilerAttributions *re::ProfilerAttributions::ProfilerAttributions(re::ProfilerAttributions *this, uint64_t a2)
{
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_DWORD *)this + 74) = 1065353216;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((void *)this + 31) = 0;
  *((void *)this + 32) = a2;
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
  *(_DWORD *)((char *)this + 327) = 0;
  *((void *)this + 40) = 0;
  int v4 = operator new(0x2780uLL, (std::align_val_t)0x40uLL);
  *int v4 = a2;
  uint64_t v5 = 0x1FFFFFFFFFFFFB18;
  do
  {
    __int16 v6 = &v4[v5];
    v6[1264] = -1;
    v6[1265] = 0;
    v6[1267] = 0;
    v6[1266] = 0;
    v5 += 8;
  }
  while (v5 * 8);
  *(void *)this = v4;
  return this;
}

void re::ProfilerAttributions::~ProfilerAttributions(re::ProfilerAttributions *this)
{
  for (uint64_t i = 0; i != 256; i += 8)
  {
    uint64_t v3 = *(void *)((char *)this + i);
    if (v3) {
      MEMORY[0x237DBCBC0](v3, 64);
    }
  }
  uint64_t v4 = *((void *)this + 38);
  if (v4)
  {
    *((void *)this + 39) = v4;
    MEMORY[0x237DBCBC0]();
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::~__hash_table((uint64_t)this + 264);
}

void re::ProfilerAttributions::clear(re::ProfilerAttributions *this)
{
  for (uint64_t i = 0; i != 32; ++i)
  {
    uint64_t v3 = *((void *)this + i);
    if (v3)
    {
      uint64_t v4 = v3 + 64;
      uint64_t v5 = -10048;
      do
      {
        uint64_t v6 = v4 + v5;
        *(_OWORD *)(v6 + 10048) = re::kProfilerCounterEmpty;
        *(_OWORD *)(v6 + 10064) = *(_OWORD *)algn_23440BB90;
        v5 += 64;
      }
      while (v5);
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear((uint64_t)this + 264);
  *((void *)this + 39) = *((void *)this + 38);
  *((_WORD *)this + 164) = 0;
  *((unsigned char *)this + 330) = 0;
}

void re::ProfilerAttributions::resolveDeferred(re::ProfilerAttributions *a1, void *a2)
{
  uint64_t v3 = (void *)*((void *)a1 + 35);
  if (v3)
  {
    int64x2_t v17 = vdupq_n_s64(1uLL);
    do
    {
      uint64_t v5 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a2, v3 + 2);
      if (v5)
      {
        if (*((unsigned __int16 *)v5 + 12) >= 0x20u) {
          unsigned int v6 = 0;
        }
        else {
          unsigned int v6 = *((unsigned __int16 *)v5 + 12);
        }
      }
      else
      {
        unsigned int v6 = 0;
      }
      Statistics = (void *)*((void *)a1 + v6);
      uint64_t v8 = v17.i64[1];
      if (!Statistics)
      {
        Statistics = re::ProfilerAttributions::createStatistics(a1, v6);
        uint64_t v8 = v17.i64[1];
      }
      uint64_t v9 = (unsigned __int8 *)v3[3];
      for (uint64_t i = (unsigned __int8 *)v3[4]; v9 != i; v13[1] = vaddq_s64(v13[1], v16))
      {
        unint64_t v11 = *((void *)v9 + 1);
        unsigned int v12 = *v9;
        v9 += 16;
        unint64_t v13 = (int64x2_t *)&Statistics[8 * (unint64_t)v12 + 8];
        unint64_t v14 = v13->i64[0];
        unint64_t v15 = v13->u64[1];
        if (v13->i64[0] >= v11) {
          unint64_t v14 = v11;
        }
        if (v15 <= v11) {
          unint64_t v15 = v11;
        }
        v13->i64[0] = v14;
        v13->i64[1] = v15;
        v16.i64[1] = v8;
        v16.i64[0] = v11;
      }
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear((uint64_t)a1 + 264);
}

void *re::ProfilerAttributions::createStatistics(re::ProfilerAttributions *this, unsigned int a2)
{
  uint64_t result = operator new(0x2780uLL, (std::align_val_t)0x40uLL);
  void *result = *((void *)this + 32);
  uint64_t v5 = 0x1FFFFFFFFFFFFB18;
  do
  {
    unsigned int v6 = &result[v5];
    v6[1264] = -1;
    v6[1265] = 0;
    v6[1267] = 0;
    v6[1266] = 0;
    v5 += 8;
  }
  while (v5 * 8);
  *((void *)this + a2) = result;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t *re::foundationProfilingLogObjects(re *this)
{
  {
    re::foundationProfilingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Profiling");
  }
  return &re::foundationProfilingLogObjects(void)::logObjects;
}

void re::internal::enableMemoryStatsCollection(re::internal *this)
{
  if (_MergedGlobals_433 == 1)
  {
    uint64_t v1 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl(&dword_233120000, v1, OS_LOG_TYPE_DEFAULT, "Malloc allocation statistics already being collected", v4, 2u);
    }
  }
  else
  {
    uint64_t v2 = (size_t (**)(size_t, uint64_t, char *, unint64_t, uint64_t, int))MEMORY[0x263EF8360];
    uint64_t v3 = *MEMORY[0x263EF8360];
    off_26AF99848 = (uint64_t (*)(void, void, void, void, void, void))*MEMORY[0x263EF8978];
    unk_26AF99850 = v3;
    *MEMORY[0x263EF8978] = _objectalloc_logger;
    *uint64_t v2 = _objectalloc_logger;
    _MergedGlobals_433 = 1;
  }
}

size_t _objectalloc_logger(size_t result, uint64_t a2, char *ptr, unint64_t a4, uint64_t a5, int a6)
{
  int v10 = result;
  if (off_26AF99848) {
    uint64_t result = off_26AF99848(result, a2, ptr, a4, a5, (a6 + 1));
  }
  if ((~v10 & 6) != 0)
  {
    if ((v10 & 2) != 0)
    {
      if (a5)
      {
        do
        {
          if ((uint64_t)v18 <= v19) {
            break;
          }
          int64_t v20 = v19;
        }
        while (v20 != v19);
      }
    }
    else if ((v10 & 4) != 0)
    {
      if (ptr)
      {
        uint64_t result = malloc_size(ptr);
        do
        {
          if (v21 <= v22) {
            break;
          }
          int64_t v23 = v22;
        }
        while (v23 != v22);
      }
    }
    else if ((v10 & 0x10) != 0)
    {
      if (a5 && *MEMORY[0x263EF8960] == a2)
      {
        unint64_t v24 = ~*MEMORY[0x263EF8AE8] & (unint64_t)&ptr[*MEMORY[0x263EF8AE8]];
        int64_t v25 = v24
        do
        {
          if (v25 <= v26) {
            break;
          }
          int64_t v27 = v26;
        }
        while (v27 != v26);
      }
    }
    else if ((v10 & 0x20) != 0 && ptr && *MEMORY[0x263EF8960] == a2)
    {
      unint64_t v14 = ~*MEMORY[0x263EF8AE8] & (*MEMORY[0x263EF8AE8] + a4);
      do
      {
        if (v15 <= v16) {
          break;
        }
        int64_t v17 = v16;
      }
      while (v17 != v16);
    }
  }
  else if (a5)
  {
    uint64_t result = malloc_size(ptr);
        + a4
        - result;
    do
    {
      if (v11 <= v12) {
        break;
      }
      int64_t v13 = v12;
    }
    while (v13 != v12);
  }
  return result;
}

void re::internal::disableMemoryStatsCollection(re::internal *this)
{
  if (_MergedGlobals_433)
  {
    uint64_t v1 = unk_26AF99850;
    *MEMORY[0x263EF8978] = off_26AF99848;
    *MEMORY[0x263EF8360] = v1;
    _MergedGlobals_433 = 0;
  }
  else
  {
    uint64_t v2 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "Malloc allocation statistics already disabled", v3, 2u);
    }
  }
}

re::ProfilerFlameChartProcessor *re::ProfilerFlameChartProcessor::ProfilerFlameChartProcessor(re::ProfilerFlameChartProcessor *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_26E717B68;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
  *(_OWORD *)((char *)this + 188) = 0u;
  *(_OWORD *)((char *)this + 204) = 0u;
  *(_OWORD *)((char *)this + 220) = 0u;
  *(_OWORD *)((char *)this + 236) = 0u;
  *(_OWORD *)((char *)this + 252) = 0u;
  *((_DWORD *)this + 95) = 0;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 316) = 0u;
  *(_OWORD *)((char *)this + 332) = 0u;
  *(_OWORD *)((char *)this + 348) = 0u;
  *(_OWORD *)((char *)this + 364) = 0u;
  *((void *)this + 48) = 0x10000001ELL;
  *((_DWORD *)this + 98) = 1;
  *((_OWORD *)this + 25) = xmmword_234378E20;
  *((unsigned char *)this + 416) = 1;
  std::vector<re::ProfilerFlameChartBlock>::resize((uint64_t)this + 16, 0x80uLL);
  std::vector<re::ProfilerFlameChartBlock>::resize((uint64_t)this + 40, 0x80uLL);
  re::ProfilerFlameChartProcessor::mapColorsToCategories(this);
  return this;
}

void std::vector<re::ProfilerFlameChartBlock>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 6);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<re::ProfilerFlameChartBlock>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 320 * a2;
  }
}

double re::ProfilerFlameChartProcessor::mapColorsToCategories(re::ProfilerFlameChartProcessor *this)
{
  for (uint64_t i = 64; i != 384; i += 64)
  {
    unint64_t v2 = (_OWORD *)((char *)this + i);
    v2[2] = xmmword_23440BBD0;
    v2[3] = xmmword_23440BBD0;
    *unint64_t v2 = xmmword_23440BBD0;
    v2[1] = xmmword_23440BBD0;
  }
  *((void *)this + 44) = 0x3F00808100000000;
  *((void *)this + 45) = 0x3F4CCCCD3F008081;
  *((_OWORD *)this + 5) = xmmword_23440BBE0;
  *((_OWORD *)this + 6) = xmmword_23440BC00;
  *((void *)this + 40) = 0x3EDCDCDD3F2AAAABLL;
  *((void *)this + 41) = 0x3F4CCCCD3E20A0A1;
  *((void *)this + 42) = 1056997505;
  *((void *)this + 43) = 0x3F4CCCCD00000000;
  *((_OWORD *)this + 7) = xmmword_23440BBF0;
  *((_OWORD *)this + 8) = xmmword_23440BC10;
  *((_OWORD *)this + 9) = xmmword_23440BC20;
  *((_OWORD *)this + 10) = xmmword_23440BC30;
  *((void *)this + 28) = 0x3F70F0F13E8C8C8DLL;
  *((void *)this + 29) = 0x3F4CCCCD3F70F0F1;
  *((_OWORD *)this + 11) = xmmword_23440BC10;
  *((_OWORD *)this + 12) = xmmword_23440BC40;
  *((_OWORD *)this + 15) = xmmword_23440BC50;
  *((_OWORD *)this + 16) = xmmword_23440BC10;
  *((_OWORD *)this + 13) = xmmword_23440BC60;
  *((_OWORD *)this + 17) = xmmword_23440BC70;
  *((_OWORD *)this + 18) = xmmword_23440BC80;
  *((_OWORD *)this + 19) = xmmword_23440BC90;
  double result = 0.0065870108;
  *((_OWORD *)this + 23) = xmmword_23440BCA0;
  return result;
}

void *re::ProfilerFlameChartProcessor::ProcessBlock(void *result, uint64_t a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, char __dst, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,double a37,double a38,long long a39,uint64_t a40,long long a41,long long a42,long long a43,long long a44,long long a45,long long a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  a53 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v46 = (uint64_t)result;
    uint64_t v47 = 0;
    uint64_t v89 = (uint64_t)result + 32;
    uint64_t v90 = a3;
    do
    {
      uint64_t v48 = a2 + (v47 << 6);
      a37 = 0.0;
      a38 = 0.0;
      a41 = 0u;
      a42 = 0u;
      a43 = 0u;
      a44 = 0u;
      a45 = 0u;
      a46 = 0u;
      a36 = *(void *)v48;
      LOWORD(a39) = *(_WORD *)(v48 + 18);
      *(long long *)((char *)&a39 + 4) = *(_OWORD *)(v46 + 16 * *(unsigned __int8 *)(v48 + 16) + 64);
      uint64_t v49 = (unint64_t *)(v48 + 32);
      uint64_t v50 = *(void *)(v48 + 32);
      uint64_t v53 = *(void *)(v48 + 24);
      uint64_t v51 = (unint64_t *)(v48 + 24);
      uint64_t v52 = v53;
      double v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          double v57 = NAN;
          goto LABEL_8;
        }
        LODWORD(v55) = info.numer;
        LODWORD(v56) = info.denom;
        double v54 = (double)v55 / (double)v56;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v54;
      }
      double v57 = v54 * (double)(unint64_t)(v50 - v52);
LABEL_8:
      double v58 = v57 / 1000000.0;
      *(double *)&a41 = v57 / 1000000.0;
      unint64_t v59 = *v51;
      if (*(void *)(v46 + 400) > *v51 && *(_DWORD *)(v46 + 392) == 1) {
        *(void *)(v46 + 400) = v59;
      }
      unint64_t v60 = *v49;
      if (*(void *)(v46 + 408) < *v49) {
        *(void *)(v46 + 408) = v60;
      }
      uint64_t v61 = 0;
      a37 = (double)v59;
      a38 = (double)v60;
      uint64_t v62 = *(void *)(a2 + (v47 << 6) + 8);
LABEL_14:
      unint64_t v63 = 0;
      uint64_t v64 = v62 + v61;
      while (1)
      {
        int v65 = *(unsigned __int8 *)(v64 + v63);
        if (!*(unsigned char *)(v64 + v63)) {
          break;
        }
        if (v65 == 32)
        {
          v61 += v63 + 1;
          goto LABEL_14;
        }
        if (v65 == 40) {
          break;
        }
        ++v63;
      }
      mach_timebase_info info = 0;
      std::string::reserve((std::string *)&info, 0x78uLL);
      std::string::append((std::string *)&info, "(");
      std::to_string(&var10, (int)v58);
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v66 = &var10;
      }
      else {
        uint64_t v66 = (std::string *)var10.__r_.__value_.__r.__words[0];
      }
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(var10.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = var10.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)&info, (const std::string::value_type *)v66, size);
      if (SHIBYTE(var10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(var10.__r_.__value_.__l.__data_);
      }
      int v68 = (int)(v58 * 100.0) - 100 * (int)v58;
      if (v68 >= 10) {
        float v69 = ".";
      }
      else {
        float v69 = ".0";
      }
      std::string::append((std::string *)&info, v69);
      std::to_string(&var10, v68);
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v70 = &var10;
      }
      else {
        float v70 = (std::string *)var10.__r_.__value_.__r.__words[0];
      }
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v71 = HIBYTE(var10.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v71 = var10.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)&info, (const std::string::value_type *)v70, v71);
      if (SHIBYTE(var10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(var10.__r_.__value_.__l.__data_);
      }
      std::string::append((std::string *)&info, ")");
      if (v63 >= 0x78) {
        size_t v72 = 120;
      }
      else {
        size_t v72 = v63;
      }
      strncpy(&__dst, (const char *)(v62 + v61), v72);
      strncpy(&__dst + v72, (const char *)&info, 1uLL);
      unint64_t v74 = *(void *)(v46 + 24);
      unint64_t v73 = *(void *)(v46 + 32);
      if (v74 >= v73)
      {
        uint64_t v76 = *(void *)(v46 + 16);
        unint64_t v77 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v74 - v76) >> 6);
        unint64_t v78 = v77 + 1;
        if (v77 + 1 > 0xCCCCCCCCCCCCCCLL) {
          abort();
        }
        unint64_t v79 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v73 - v76) >> 6);
        if (2 * v79 > v78) {
          unint64_t v78 = 2 * v79;
        }
        if (v79 >= 0x66666666666666) {
          unint64_t v80 = 0xCCCCCCCCCCCCCCLL;
        }
        else {
          unint64_t v80 = v78;
        }
        if (v80)
        {
          uint64_t v81 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v89, v80);
          uint64_t v83 = v82;
        }
        else
        {
          uint64_t v81 = 0;
          uint64_t v83 = 0;
        }
        uint64_t v84 = a2;
        uint64_t v85 = &v81[320 * v77];
        double result = memcpy(v85, &__dst, 0x140uLL);
        double v86 = *(char **)(v46 + 16);
        uint64_t v87 = *(char **)(v46 + 24);
        uint64_t v88 = v85;
        if (v87 != v86)
        {
          do
          {
            v87 -= 320;
            v88 -= 320;
            double result = memcpy(v88, v87, 0x140uLL);
          }
          while (v87 != v86);
          uint64_t v87 = *(char **)(v46 + 16);
        }
        unsigned int v75 = v85 + 320;
        *(void *)(v46 + 16) = v88;
        *(void *)(v46 + 24) = v85 + 320;
        *(void *)(v46 + 32) = &v81[320 * v83];
        if (v87) {
          double result = (void *)MEMORY[0x237DBCBC0](v87, 64);
        }
        a2 = v84;
      }
      else
      {
        double result = memcpy(*(void **)(v46 + 24), &__dst, 0x140uLL);
        unsigned int v75 = (char *)(v74 + 320);
      }
      *(void *)(v46 + 24) = v75;
      ++v47;
    }
    while (v47 != v90);
  }
  return result;
}

#error "233DE26D8: call analysis failed (funcsize=124)"

char *std::vector<re::ProfilerFlameChartBlock>::reserve(void *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  double result = (char *)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 6) < a2)
  {
    if (a2 >= 0xCCCCCCCCCCCCCDLL) {
      abort();
    }
    uint64_t v5 = (a1[1] - *a1) / 320;
    double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>((uint64_t)result, a2);
    unsigned int v6 = &result[320 * v5];
    uint64_t v8 = &result[320 * v7];
    int v10 = (char *)*a1;
    uint64_t v9 = (char *)a1[1];
    int64_t v11 = v6;
    if (v9 != (char *)*a1)
    {
      do
      {
        v9 -= 320;
        v11 -= 320;
        double result = (char *)memcpy(v11, v9, 0x140uLL);
      }
      while (v9 != v10);
      uint64_t v9 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = v6;
    a1[2] = v8;
    if (v9)
    {
      JUMPOUT(0x237DBCBC0);
    }
  }
  return result;
}

void re::ProfilerFlameChartProcessor::~ProfilerFlameChartProcessor(re::ProfilerFlameChartProcessor *this)
{
  *(void *)this = &unk_26E717B68;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    MEMORY[0x237DBCBC0]();
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    MEMORY[0x237DBCBC0]();
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26E717B68;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    MEMORY[0x237DBCBC0]();
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    MEMORY[0x237DBCBC0]();
  }
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ProfilerFlameChartProcessor::willNeedEvents(re::ProfilerFlameChartProcessor *this)
{
  return 1;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedStatistics(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedAttributions(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedMemoryStatistics(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::updateInterval(re::ProfilerFlameChartProcessor *this)
{
  return *((unsigned int *)this + 96);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCDLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(320 * a2, (std::align_val_t)0x40uLL);
}

char *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>,0>(char *__src, char *a2, uint64_t a3)
{
  uint64_t v3 = __src;
  uint64_t v6 = a3;
  if (__src == a2) {
    return __src;
  }
  uint64_t v4 = a2;
  do
  {
    std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>::operator=[abi:nn180100](&v6, v3);
    v3 += 320;
  }
  while (v3 != v4);
  return v4;
}

uint64_t *std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>::operator=[abi:nn180100](uint64_t *a1, void *__src)
{
  uint64_t v4 = (void *)*a1;
  uint64_t v5 = *(char **)(*a1 + 8);
  uint64_t v6 = *a1;
  unint64_t v9 = *(void *)(v6 + 16);
  uint64_t v7 = v6 + 16;
  unint64_t v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v5[-*v4] >> 6);
    if (v11 + 1 > 0xCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - *v4) >> 6);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x66666666666666) {
      unint64_t v14 = 0xCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      int64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v7, v14);
    }
    else {
      int64_t v15 = 0;
    }
    int64_t v16 = &v15[320 * v11];
    int64_t v17 = &v15[320 * v14];
    memcpy(v16, __src, 0x140uLL);
    int v10 = v16 + 320;
    int64_t v19 = (char *)*v4;
    uint64_t v18 = (char *)v4[1];
    if (v18 != (char *)*v4)
    {
      do
      {
        v18 -= 320;
        v16 -= 320;
        memcpy(v16, v18, 0x140uLL);
      }
      while (v18 != v19);
      uint64_t v18 = (char *)*v4;
    }
    *uint64_t v4 = v16;
    v4[1] = v10;
    v4[2] = v17;
    if (v18) {
      MEMORY[0x237DBCBC0](v18, 64);
    }
  }
  else
  {
    memcpy(v5, __src, 0x140uLL);
    int v10 = v5 + 320;
  }
  v4[1] = v10;
  return a1;
}

void std::vector<re::ProfilerFlameChartBlock>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 6) >= a2)
  {
    if (a2)
    {
      size_t v13 = 320 * ((320 * a2 - 320) / 0x140) + 320;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 6);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 6);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x66666666666666) {
      unint64_t v11 = 0xCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    unint64_t v14 = &v12[320 * v8];
    int64_t v15 = &v12[320 * v11];
    size_t v16 = 320 * ((320 * a2 - 320) / 0x140) + 320;
    bzero(v14, v16);
    int64_t v17 = &v14[v16];
    int64_t v19 = *a1;
    uint64_t v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v18 -= 320;
        v14 -= 320;
        memcpy(v14, v18, 0x140uLL);
      }
      while (v18 != v19);
      uint64_t v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      JUMPOUT(0x237DBCBC0);
    }
  }
}

re::ProfilerMiniHUDProcessor *re::ProfilerMiniHUDProcessor::ProfilerMiniHUDProcessor(re::ProfilerMiniHUDProcessor *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_26E717BD8;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  uint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 9, 0);
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 13, 0);
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 17, 0);
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  uint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 21, 0);
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 25, 0);
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  uint64_t v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 29, 0);
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 33, 0);
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  unint64_t v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 37, 0);
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  unint64_t v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 41, 0);
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  unint64_t v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 45, 0);
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  unint64_t v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 49, 0);
  *((void *)this + 63) = 0;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  size_t v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 60, 0);
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  unint64_t v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 64, 0);
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  int64_t v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 68, 0);
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  size_t v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 72, 0);
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  int64_t v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 76, 0);
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  uint64_t v18 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 80, 0);
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  int64_t v19 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 84, 0);
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  int64_t v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 88, 0);
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  int64_t v21 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 92, 0);
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  int64_t v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 96, 0);
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  re::DynamicString::setCapacity((void *)this + 100, 0);
  *((_OWORD *)this + 52) = xmmword_23440BCE0;
  *((_OWORD *)this + 53) = xmmword_234376D50;
  *((_OWORD *)this + 54) = xmmword_23440BCF0;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  getpid();
  memorystatus_control();
  *((void *)this + 113) = 0;
  return this;
}

void re::ProfilerMiniHUDProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  unint64_t v7 = *(void *)(a1 + 840) + 1;
  *(void *)(a1 + 840) = v7;
  float v8 = 0.0;
  float v9 = 0.0;
  float v10 = 0.0;
  float v11 = 0.0;
  unint64_t v12 = *(void **)a4;
  size_t v13 = *(void **)(a4 + 8);
  float v14 = 0.0;
  float v15 = 0.0;
  float v16 = 0.0;
  float v17 = 0.0;
  float v18 = 0.0;
  float v19 = 0.0;
  if (*(void **)a4 != v13)
  {
    float v20 = 0.0;
    float v21 = 0.0;
    float v22 = 0.0;
    float v23 = 0.0;
    float v24 = 0.0;
    float v25 = 0.0;
    float v26 = 0.0;
    do
    {
      uint64_t v27 = 0;
      uint64_t v28 = (void *)(*v12 + 88);
      do
      {
        if (*v28)
        {
          unint64_t v29 = *(v28 - 1);
          if (v29)
          {
            if (v27 > 0x5Au)
            {
              switch(v27)
              {
                case '[':
                  float v26 = v26 + (float)v29;
                  break;
                case '\\':
                  float v25 = v25 + (float)v29;
                  break;
                case ']':
                  float v24 = v24 + (float)v29;
                  break;
              }
            }
            else
            {
              switch((char)v27)
              {
                case 1:
                  float v17 = v17 + (float)v29;
                  break;
                case 2:
                  float v18 = v18 + (float)v29;
                  break;
                case 3:
                  float v20 = v20 + (float)v29;
                  break;
                case 4:
                  float v21 = v21 + (float)v29;
                  break;
                case 5:
                  float v22 = v22 + (float)v29;
                  break;
                case 6:
                  float v23 = v23 + (float)v29;
                  break;
                case 7:
                  float v19 = v19 + (float)v29;
                  break;
                case 8:
                  float v14 = v14 + (float)v29;
                  break;
                case 9:
                  float v16 = v16 + (float)v29;
                  break;
                case 10:
                  float v15 = v15 + (float)v29;
                  break;
                case 11:
                  float v11 = v11 + (float)v29;
                  break;
                case 12:
                  float v8 = v8 + (float)v29;
                  break;
                case 23:
                  float v9 = v9 + (float)v29;
                  break;
                case 24:
                  float v10 = v10 + (float)v29;
                  break;
                default:
                  break;
              }
            }
          }
        }
        ++v27;
        v28 += 8;
      }
      while (v27 != 157);
      ++v12;
    }
    while (v12 != v13);
    float v18 = v19 + (float)(v23 + (float)(v22 + (float)(v21 + (float)(v20 + v18))));
    float v19 = (float)(v26 + v25) + v24;
  }
  float v30 = (float)((float)(v14 - v11) - v8) - v9;
  float v31 = (float)(v16 - v15) + v19;
  float v32 = v18 + v19;
  float v33 = v9 + (float)(v8 + v11);
  BOOL v34 = v14 <= 0.0;
  if (v14 <= 0.0) {
    float v35 = v33;
  }
  else {
    float v35 = 0.0;
  }
  float v36 = v31 - v35;
  if (v34) {
    float v15 = v33;
  }
  float v37 = *(float *)(a1 + 24);
  *(float *)(a1 + 20) = v17 + *(float *)(a1 + 20);
  *(float *)(a1 + 24) = (float)((float)(v32 - v15) - v36) + v37;
  float v38 = *(float *)(a1 + 32);
  *(float *)(a1 + 28) = v36 + *(float *)(a1 + 28);
  *(float *)(a1 + 32) = fmaxf(v30, 0.0) + v38;
  *(float *)(a1 + 36) = v10 + *(float *)(a1 + 36);
  unint64_t v39 = *a6;
  uint64_t v40 = a6[1];
  if (*a6 == v40)
  {
    uint64_t v42 = 0;
    uint64_t v41 = 0;
    int64x2_t v43 = 0uLL;
    int64x2_t v44 = 0uLL;
  }
  else
  {
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    int64x2_t v43 = 0uLL;
    int64x2_t v44 = 0uLL;
    do
    {
      uint64_t v45 = 0;
      uint64_t v46 = *v39;
      do
      {
        int64x2_t v44 = vaddq_s64(*(int64x2_t *)(v46 + v45 + 96), v44);
        int64x2_t v43 = vaddq_s64(*(int64x2_t *)(v46 + v45 + 80), v43);
        v42 += *(void *)(v46 + v45 + 112);
        v45 += 64;
      }
      while (v45 != 1280);
      v41 += *(void *)(v46 + 1344);
      ++v39;
    }
    while (v39 != v40);
  }
  if (!(v7 % *(void *)(a1 + 832)))
  {
    int64x2_t v112 = v44;
    int64x2_t v113 = v43;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    float v47 = *(float *)(a1 + 20);
    unint64_t v48 = *(void *)(a1 + 832);
    double v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        double v52 = NAN;
        goto LABEL_50;
      }
      LODWORD(v50) = info.numer;
      LODWORD(v51) = info.denom;
      double v49 = (double)v50 / (double)v51;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v49;
    }
    double v52 = v49 * (double)(unint64_t)(float)(v47 / (float)v48);
LABEL_50:
    float v53 = v52 / 1000000.0;
    *(float *)(a1 + 428) = v53;
    float v54 = 1000.0 / v53;
    BOOL v34 = v53 <= 0.0;
    float v55 = 0.0;
    if (!v34) {
      float v55 = v54;
    }
    *(float *)(a1 + 424) = v55;
    float v56 = *(float *)(a1 + 24);
    unint64_t v57 = *(void *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        double v60 = NAN;
        goto LABEL_57;
      }
      LODWORD(v58) = info.numer;
      LODWORD(v59) = info.denom;
      double v49 = (double)v58 / (double)v59;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v49;
    }
    double v60 = v49 * (double)(unint64_t)(float)(v56 / (float)v57);
LABEL_57:
    float v61 = v60 / 1000000.0;
    *(float *)(a1 + 432) = v61;
    float v62 = *(float *)(a1 + 28);
    unint64_t v63 = *(void *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        double v66 = NAN;
        goto LABEL_62;
      }
      LODWORD(v64) = info.numer;
      LODWORD(v65) = info.denom;
      double v49 = (double)v64 / (double)v65;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v49;
    }
    double v66 = v49 * (double)(unint64_t)(float)(v62 / (float)v63);
LABEL_62:
    float v67 = v66 / 1000000.0;
    *(float *)(a1 + 436) = v67;
    float v68 = *(float *)(a1 + 32);
    unint64_t v69 = *(void *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v72 = NAN;
        goto LABEL_67;
      }
      LODWORD(v70) = info.numer;
      LODWORD(v71) = info.denom;
      double v49 = (double)v70 / (double)v71;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v49;
    }
    double v72 = v49 * (double)(unint64_t)(float)(v68 / (float)v69);
LABEL_67:
    float v73 = v72 / 1000000.0;
    *(float *)(a1 + 440) = v73;
    *(float *)(a1 + 444) = *(float *)(a1 + 36) / (float)*(unint64_t *)(a1 + 832);
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 48) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    uint64_t v74 = qword_26879B618;
    mach_msg_type_number_t task_info_outCnt = 93;
    task_info(*MEMORY[0x263EF8960], 0x16u, re::ProfilerMiniHUDProcessor::process(unsigned long long,std::vector<re::ProfilerEventStream *> const&,std::vector<re::ProfilerStatistics *> const&,std::vector<re::ProfilerAttributions *> const&,std::vector<re::ProfilerMemoryStatistics *> const&)::vmInfo, &task_info_outCnt);
    uint64_t v75 = qword_26879B618;
    *(void *)(a1 + 448) = qword_26879B618;
    *(void *)(a1 + 456) = v75 - v74;
    *(void *)(a1 + 472) = *(void *)(a1 + 904);
    uint64_t v76 = *(void *)(a1 + 488);
    if (v76)
    {
      *(void *)(a1 + 488) = 1;
      unint64_t v77 = *(unsigned char **)(a1 + 496);
    }
    else
    {
      *(unsigned char *)(a1 + 488) = v76 & 1;
      unint64_t v77 = (unsigned char *)(a1 + 489);
    }
    *unint64_t v77 = 0;
    uint64_t v78 = *(void *)(a1 + 520);
    if (v78)
    {
      *(void *)(a1 + 520) = 1;
      unint64_t v79 = *(unsigned char **)(a1 + 528);
    }
    else
    {
      *(unsigned char *)(a1 + 520) = v78 & 1;
      unint64_t v79 = (unsigned char *)(a1 + 521);
    }
    *unint64_t v79 = 0;
    uint64_t v80 = *(void *)(a1 + 552);
    if (v80)
    {
      *(void *)(a1 + 552) = 1;
      uint64_t v81 = *(unsigned char **)(a1 + 560);
    }
    else
    {
      *(unsigned char *)(a1 + 552) = v80 & 1;
      uint64_t v81 = (unsigned char *)(a1 + 553);
    }
    *uint64_t v81 = 0;
    uint64_t v82 = *(void *)(a1 + 584);
    if (v82)
    {
      *(void *)(a1 + 584) = 1;
      uint64_t v83 = *(unsigned char **)(a1 + 592);
    }
    else
    {
      *(unsigned char *)(a1 + 584) = v82 & 1;
      uint64_t v83 = (unsigned char *)(a1 + 585);
    }
    *uint64_t v83 = 0;
    uint64_t v84 = *(void *)(a1 + 616);
    if (v84)
    {
      *(void *)(a1 + 616) = 1;
      uint64_t v85 = *(unsigned char **)(a1 + 624);
    }
    else
    {
      *(unsigned char *)(a1 + 616) = v84 & 1;
      uint64_t v85 = (unsigned char *)(a1 + 617);
    }
    *uint64_t v85 = 0;
    uint64_t v86 = *(void *)(a1 + 648);
    if (v86)
    {
      *(void *)(a1 + 648) = 1;
      uint64_t v87 = *(unsigned char **)(a1 + 656);
    }
    else
    {
      *(unsigned char *)(a1 + 648) = v86 & 1;
      uint64_t v87 = (unsigned char *)(a1 + 649);
    }
    *uint64_t v87 = 0;
    uint64_t v88 = *(void *)(a1 + 680);
    if (v88)
    {
      *(void *)(a1 + 680) = 1;
      uint64_t v89 = *(unsigned char **)(a1 + 688);
    }
    else
    {
      *(unsigned char *)(a1 + 680) = v88 & 1;
      uint64_t v89 = (unsigned char *)(a1 + 681);
    }
    *uint64_t v89 = 0;
    uint64_t v90 = *(void *)(a1 + 712);
    if (v90)
    {
      *(void *)(a1 + 712) = 1;
      uint64_t v91 = *(unsigned char **)(a1 + 720);
    }
    else
    {
      *(unsigned char *)(a1 + 712) = v90 & 1;
      uint64_t v91 = (unsigned char *)(a1 + 713);
    }
    *uint64_t v91 = 0;
    uint64_t v92 = *(void *)(a1 + 744);
    if (v92)
    {
      *(void *)(a1 + 744) = 1;
      uint64_t v93 = *(unsigned char **)(a1 + 752);
    }
    else
    {
      *(unsigned char *)(a1 + 744) = v92 & 1;
      uint64_t v93 = (unsigned char *)(a1 + 745);
    }
    *uint64_t v93 = 0;
    uint64_t v94 = *(void *)(a1 + 776);
    if (v94)
    {
      *(void *)(a1 + 776) = 1;
      uint64_t v95 = *(unsigned char **)(a1 + 784);
    }
    else
    {
      *(unsigned char *)(a1 + 776) = v94 & 1;
      uint64_t v95 = (unsigned char *)(a1 + 777);
    }
    uint64_t v96 = (float *)(a1 + 436);
    *uint64_t v95 = 0;
    float v97 = *(float *)(a1 + 432);
    if (*(float *)(a1 + 440) > 0.0)
    {
      float v98 = *v96;
      uint64_t v96 = (float *)(a1 + 440);
      float v97 = v97 + v98;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 480), "Sim: %.2f", v97);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 512), "Ren: %.2f", *v96);
    if (*(float *)(a1 + 444) == 0.0) {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 544), "GPU: Off");
    }
    else {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 544), "GPU: %.2f");
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 576), "FPS: %2.2f", *(float *)(a1 + 424));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 608), "Mem [MB]: %.2f", (double)*(unint64_t *)(a1 + 448) * 0.0009765625 * 0.0009765625);
    unint64_t v99 = v113.i64[0];
    if (!(v113.i64[1] | v41)) {
      goto LABEL_115;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 640), "Allocs: +%llu/-%llu", v113.i64[1], v41);
    *(void *)(a1 + 880) += v113.i64[1] - v41;
    uint64_t v100 = mach_absolute_time();
    uint64_t v101 = v100;
    uint64_t v102 = *(void *)(a1 + 896);
    if (!v102)
    {
      *(void *)(a1 + 896) = v100;
      uint64_t v102 = v100;
    }
    double v103 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    unint64_t v99 = v113.i64[0];
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        double v106 = NAN;
        unint64_t v99 = v113.i64[0];
        goto LABEL_110;
      }
      LODWORD(v104) = info.numer;
      LODWORD(v105) = info.denom;
      double v103 = (double)v104 / (double)v105;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v103;
      unint64_t v99 = v113.i64[0];
    }
    double v106 = v103 * (double)(v101 - v102);
LABEL_110:
    if (v106 / 1000000000.0 >= 1.0)
    {
      uint64_t v107 = *(void *)(a1 + 808);
      if (v107)
      {
        *(void *)(a1 + 808) = 1;
        unint64_t v108 = *(unsigned char **)(a1 + 816);
      }
      else
      {
        *(unsigned char *)(a1 + 808) = v107 & 1;
        unint64_t v108 = (unsigned char *)(a1 + 809);
      }
      *unint64_t v108 = 0;
      *(void *)(a1 + 896) = v101;
      uint64_t v109 = *(void *)(a1 + 880);
      *(void *)(a1 + 888) = v109;
      *(void *)(a1 + 880) = 0;
      *(void *)(a1 + 464) = v109;
      re::DynamicString::appendf((re::DynamicString *)(a1 + 800), "%+lld allocs/sec", v109);
      unint64_t v99 = v113.i64[0];
    }
LABEL_115:
    uint64_t v110 = v112.i64[1];
    if (v112.i64[0])
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 704), "   (S): %llu", v112.i64[0]);
      uint64_t v110 = v112.i64[1];
      unint64_t v99 = v113.i64[0];
    }
    if (v110)
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 736), "   (M): %llu", v110);
      unint64_t v99 = v113.i64[0];
    }
    if (v42)
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 768), "   (L): %llu", v42);
      unint64_t v99 = v113.i64[0];
    }
    if (v99)
    {
      float v111 = (double)v99 * 0.0009765625;
      re::DynamicString::appendf((re::DynamicString *)(a1 + 672), "  Size: %.2fKB", v111);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
  }
}

void re::ProfilerMiniHUDProcessor::~ProfilerMiniHUDProcessor(re::ProfilerMiniHUDProcessor *this)
{
  re::ProfilerMiniHUDProcessor::~ProfilerMiniHUDProcessor(this);
  JUMPOUT(0x237DBCBD0);
}

{
  re::DynamicString *v2;

  *(void *)this = &unk_26E717BD8;
  uint64_t v2 = (re::ProfilerMiniHUDProcessor *)((char *)this + 232);
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 800));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 768));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 736));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 704));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 672));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 640));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 608));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 576));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 544));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 512));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 480));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 392));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 360));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 328));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 296));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 264));
  re::DynamicString::deinit(v2);
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 200));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 168));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 136));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 104));
  re::DynamicString::deinit((re::ProfilerMiniHUDProcessor *)((char *)this + 72));
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedEvents(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedStatistics(re::ProfilerMiniHUDProcessor *this)
{
  return 1;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedAttributions(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedMemoryStatistics(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

float ___ZN2re13ProfilerUtils8timeBaseEv_block_invoke()
{
  mach_timebase_info(&info);
  *(void *)&long long v0 = info.numer;
  *((void *)&v0 + 1) = info.denom;
  float result = *(float *)&info.numer;
  re::ProfilerUtils::s_timeBase = v0;
  return result;
}

re::ProfilerDetailedHUDProcessor *re::ProfilerDetailedHUDProcessor::ProfilerDetailedHUDProcessor(re::ProfilerDetailedHUDProcessor *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_26E717C68;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(void *)((char *)this + 44) = 0;
  *(void *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 4) = 0u;
  uint64_t v2 = (void *)((char *)this + 64);
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 6) = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 12, 0);
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 8) = 0u;
  uint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 16, 0);
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 10) = 0u;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 20, 0);
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 12) = 0u;
  unint64_t v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 24, 0);
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 14) = 0u;
  re::DynamicString::setCapacity((void *)this + 28, 0);
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 32) = 5;
  *((unsigned char *)this + 280) = 0;
  getpid();
  memorystatus_control();
  *((void *)this + 34) = 0;
  return this;
}

void re::ProfilerDetailedHUDProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ++*(void *)(a1 + 264);
  if (!*(unsigned char *)(a1 + 280))
  {
    *(_OWORD *)&info[0].numer = 0u;
    memset(v644, 0, 20);
    *(void *)&v644[20] = 0x7FFFFFFFLL;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=(a1 + 16, (uint64_t *)info);
    re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)info);
    unsigned int v6 = 0;
    do
    {
      char v646 = v6;
      info[0] = (mach_timebase_info)0xFF7FFFFF7F7FFFFFLL;
      info[1] = 0;
      *(void *)v644 = 0;
      *(_OWORD *)&v644[8] = xmmword_23440B890;
      *(_OWORD *)&v644[24] = xmmword_23440B8A0;
      uint64_t v645 = 0;
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew(a1 + 16, &v646, (re::FrameStats::CollectedStatistics *)info);
    }
    while (v6++ < 0x9C);
    *(unsigned char *)(a1 + 280) = 1;
  }
  float v9 = *(void **)a4;
  for (uint64_t i = *(void **)(a4 + 8); v9 != i; ++v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *v9 + 64;
    do
    {
      unint64_t v12 = (unint64_t *)(v11 + (v10 << 6));
      unint64_t v13 = v12[3];
      if (v13)
      {
        unint64_t v14 = v12[2];
        if (v14)
        {
          if (*(void *)(a1 + 16))
          {
            unint64_t v15 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v10) ^ ((0xBF58476D1CE4E5B9 * v10) >> 27));
            unint64_t v16 = (v15 ^ (v15 >> 31)) % *(unsigned int *)(a1 + 40);
            uint64_t v17 = *(void *)(a1 + 32);
            uint64_t v18 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * v16);
            if (v18 != 0x7FFFFFFF)
            {
              while (v10 != *(unsigned __int8 *)(v17 + 80 * v18 + 12))
              {
                uint64_t v18 = *(_DWORD *)(v17 + 80 * v18 + 8) & 0x7FFFFFFF;
                if (v18 == 0x7FFFFFFF) {
                  goto LABEL_16;
                }
              }
              goto LABEL_17;
            }
          }
          else
          {
            uint64_t v17 = *(void *)(a1 + 32);
          }
LABEL_16:
          LODWORD(v18) = 0x7FFFFFFF;
LABEL_17:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v17 + 80 * v18 + 16), (float)v14, (float)v13, (float)*v12, (float)*(unint64_t *)(v11 + (v10 << 6) + 8));
        }
      }
      ++v10;
    }
    while (v10 != 157);
  }
  if (!(*(void *)(a1 + 264) % *(void *)(a1 + 256)))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    uint64_t v19 = *(unsigned int *)(a1 + 48);
    if (v19)
    {
      uint64_t v20 = 0;
      float v21 = (int *)(*(void *)(a1 + 32) + 8);
      while (1)
      {
        int v22 = *v21;
        v21 += 20;
        if (v22 < 0) {
          break;
        }
        if (v19 == ++v20)
        {
          LODWORD(v20) = *(_DWORD *)(a1 + 48);
          break;
        }
      }
    }
    else
    {
      LODWORD(v20) = 0;
    }
    if (v19 != v20)
    {
      uint64_t v23 = v20;
      do
      {
        uint64_t v24 = *(void *)(a1 + 32) + 80 * v23;
        *(_OWORD *)(v24 + 40) = *(_OWORD *)(v24 + 16);
        *(_DWORD *)(v24 + 56) = *(_DWORD *)(v24 + 32);
        *(_OWORD *)(v24 + 16) = xmmword_23440B8B0;
        *(_DWORD *)(v24 + 32) = 0;
        if (v19 <= (int)v20 + 1) {
          int v25 = v20 + 1;
        }
        else {
          int v25 = v19;
        }
        int v26 = v20;
        while (1)
        {
          uint64_t v23 = (v26 + 1);
          if (v25 - 1 == v26) {
            break;
          }
          ++v26;
          LODWORD(v20) = v23;
          if ((*(_DWORD *)(*(void *)(a1 + 32) + 80 * v23 + 8) & 0x80000000) != 0) {
            goto LABEL_37;
          }
        }
        LODWORD(v20) = v25;
LABEL_37:
        ;
      }
      while (v19 != v20);
    }
    uint64_t v27 = *(void *)(a1 + 72);
    if (v27)
    {
      *(void *)(a1 + 72) = 1;
      uint64_t v28 = *(unsigned char **)(a1 + 80);
    }
    else
    {
      *(unsigned char *)(a1 + 72) = v27 & 1;
      uint64_t v28 = (unsigned char *)(a1 + 73);
    }
    *uint64_t v28 = 0;
    uint64_t v29 = *(void *)(a1 + 104);
    if (v29)
    {
      *(void *)(a1 + 104) = 1;
      float v30 = *(unsigned char **)(a1 + 112);
    }
    else
    {
      *(unsigned char *)(a1 + 104) = v29 & 1;
      float v30 = (unsigned char *)(a1 + 105);
    }
    *float v30 = 0;
    unsigned int v31 = 0x7FFFFFFF;
    if (*(void *)(a1 + 16))
    {
      unsigned int v32 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)));
      if (v32 != 0x7FFFFFFF)
      {
        uint64_t v33 = *(void *)(a1 + 32);
        unsigned int v31 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)));
        if (*(unsigned char *)(v33 + 80 * v32 + 12) != 1)
        {
          while (1)
          {
            unsigned int v31 = *(_DWORD *)(v33
                            + 80
                            * *(unsigned int *)(*(void *)(a1 + 24)
                                              + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)))
                            + 8) & 0x7FFFFFFF;
            if (v31 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v33 + 80 * v31 + 12) == 1) {
              goto LABEL_51;
            }
          }
          unsigned int v31 = 0x7FFFFFFF;
        }
      }
    }
LABEL_51:
    float v34 = *(float *)(*(void *)(a1 + 32) + 80 * v31 + 48);
    unint64_t v35 = *(void *)(a1 + 256);
    double v36 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v39 = NAN;
        goto LABEL_56;
      }
      LODWORD(v37) = info[0].numer;
      LODWORD(v38) = info[0].denom;
      double v36 = (double)v37 / (double)v38;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v36;
    }
    double v39 = v36 * (double)(unint64_t)(float)(v34 / (float)v35);
LABEL_56:
    if (*(void *)(a1 + 16))
    {
      uint64_t v40 = *(void *)(a1 + 32);
      uint64_t v41 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xDBD238973A2B148ALL % *(unsigned int *)(a1 + 40)));
      unsigned int v42 = 0x7FFFFFFF;
      if (v41 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v40 + 80 * v41 + 12) == 2)
        {
LABEL_61:
          unsigned int v42 = v41;
        }
        else
        {
          while (1)
          {
            LODWORD(v41) = *(_DWORD *)(v40 + 80 * v41 + 8) & 0x7FFFFFFF;
            unsigned int v42 = 0x7FFFFFFF;
            if (v41 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v40 + 80 * v41 + 12) == 2) {
              goto LABEL_61;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v40 = *(void *)(a1 + 32);
      unsigned int v42 = 0x7FFFFFFF;
    }
    float v43 = *(float *)(v40 + 80 * v42 + 48);
    unint64_t v44 = *(void *)(a1 + 256);
    double v45 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v48 = NAN;
        goto LABEL_68;
      }
      LODWORD(v46) = info[0].numer;
      LODWORD(v47) = info[0].denom;
      double v45 = (double)v46 / (double)v47;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v45;
    }
    double v48 = v45 * (double)(unint64_t)(float)(v43 / (float)v44);
LABEL_68:
    if (*(void *)(a1 + 16))
    {
      uint64_t v49 = *(void *)(a1 + 32);
      uint64_t v50 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x1E535EEDE31428F0uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v51 = 0x7FFFFFFF;
      if (v50 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v49 + 80 * v50 + 12) == 3)
        {
LABEL_73:
          unsigned int v51 = v50;
        }
        else
        {
          while (1)
          {
            LODWORD(v50) = *(_DWORD *)(v49 + 80 * v50 + 8) & 0x7FFFFFFF;
            unsigned int v51 = 0x7FFFFFFF;
            if (v50 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v49 + 80 * v50 + 12) == 3) {
              goto LABEL_73;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v49 = *(void *)(a1 + 32);
      unsigned int v51 = 0x7FFFFFFF;
    }
    float v52 = *(float *)(v49 + 80 * v51 + 48);
    unint64_t v53 = *(void *)(a1 + 256);
    double v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v57 = NAN;
        goto LABEL_80;
      }
      LODWORD(v55) = info[0].numer;
      LODWORD(v56) = info[0].denom;
      double v54 = (double)v55 / (double)v56;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v54;
    }
    double v57 = v54 * (double)(unint64_t)(float)(v52 / (float)v53);
LABEL_80:
    if (*(void *)(a1 + 16))
    {
      uint64_t v58 = *(void *)(a1 + 32);
      uint64_t v59 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xB7A4712C74562914 % *(unsigned int *)(a1 + 40)));
      unsigned int v60 = 0x7FFFFFFF;
      if (v59 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v58 + 80 * v59 + 12) == 4)
        {
LABEL_85:
          unsigned int v60 = v59;
        }
        else
        {
          while (1)
          {
            LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
            unsigned int v60 = 0x7FFFFFFF;
            if (v59 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v58 + 80 * v59 + 12) == 4) {
              goto LABEL_85;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v58 = *(void *)(a1 + 32);
      unsigned int v60 = 0x7FFFFFFF;
    }
    float v61 = *(float *)(v58 + 80 * v60 + 48);
    unint64_t v62 = *(void *)(a1 + 256);
    double v63 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v66 = NAN;
        goto LABEL_92;
      }
      LODWORD(v64) = info[0].numer;
      LODWORD(v65) = info[0].denom;
      double v63 = (double)v64 / (double)v65;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v63;
    }
    double v66 = v63 * (double)(unint64_t)(float)(v61 / (float)v62);
LABEL_92:
    double v641 = v66;
    if (*(void *)(a1 + 16))
    {
      uint64_t v67 = *(void *)(a1 + 32);
      uint64_t v68 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xB6BF613DBEBB45DCLL % *(unsigned int *)(a1 + 40)));
      unsigned int v69 = 0x7FFFFFFF;
      if (v68 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v67 + 80 * v68 + 12) == 5)
        {
LABEL_97:
          unsigned int v69 = v68;
        }
        else
        {
          while (1)
          {
            LODWORD(v68) = *(_DWORD *)(v67 + 80 * v68 + 8) & 0x7FFFFFFF;
            unsigned int v69 = 0x7FFFFFFF;
            if (v68 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v67 + 80 * v68 + 12) == 5) {
              goto LABEL_97;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v67 = *(void *)(a1 + 32);
      unsigned int v69 = 0x7FFFFFFF;
    }
    float v70 = *(float *)(v67 + 80 * v69 + 48);
    unint64_t v71 = *(void *)(a1 + 256);
    double v72 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v75 = NAN;
        goto LABEL_104;
      }
      LODWORD(v73) = info[0].numer;
      LODWORD(v74) = info[0].denom;
      double v72 = (double)v73 / (double)v74;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v72;
    }
    double v75 = v72 * (double)(unint64_t)(float)(v70 / (float)v71);
LABEL_104:
    if (*(void *)(a1 + 16))
    {
      uint64_t v76 = *(void *)(a1 + 32);
      uint64_t v77 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD17707977078336CLL % *(unsigned int *)(a1 + 40)));
      unsigned int v78 = 0x7FFFFFFF;
      if (v77 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v76 + 80 * v77 + 12) == 6)
        {
LABEL_109:
          unsigned int v78 = v77;
        }
        else
        {
          while (1)
          {
            LODWORD(v77) = *(_DWORD *)(v76 + 80 * v77 + 8) & 0x7FFFFFFF;
            unsigned int v78 = 0x7FFFFFFF;
            if (v77 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v76 + 80 * v77 + 12) == 6) {
              goto LABEL_109;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v76 = *(void *)(a1 + 32);
      unsigned int v78 = 0x7FFFFFFF;
    }
    float v79 = *(float *)(v76 + 80 * v78 + 48);
    unint64_t v80 = *(void *)(a1 + 256);
    double v81 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v84 = NAN;
        goto LABEL_116;
      }
      LODWORD(v82) = info[0].numer;
      LODWORD(v83) = info[0].denom;
      double v81 = (double)v82 / (double)v83;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v81;
    }
    double v84 = v81 * (double)(unint64_t)(float)(v79 / (float)v80);
LABEL_116:
    double v639 = v84;
    if (*(void *)(a1 + 16))
    {
      uint64_t v85 = *(void *)(a1 + 32);
      uint64_t v86 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x12AE30237B17DF14uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v87 = 0x7FFFFFFF;
      if (v86 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v85 + 80 * v86 + 12) == 7)
        {
LABEL_121:
          unsigned int v87 = v86;
        }
        else
        {
          while (1)
          {
            LODWORD(v86) = *(_DWORD *)(v85 + 80 * v86 + 8) & 0x7FFFFFFF;
            unsigned int v87 = 0x7FFFFFFF;
            if (v86 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v85 + 80 * v86 + 12) == 7) {
              goto LABEL_121;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v85 = *(void *)(a1 + 32);
      unsigned int v87 = 0x7FFFFFFF;
    }
    float v88 = *(float *)(v85 + 80 * v87 + 48);
    unint64_t v89 = *(void *)(a1 + 256);
    double v90 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v636 = NAN;
        goto LABEL_128;
      }
      LODWORD(v91) = info[0].numer;
      LODWORD(v92) = info[0].denom;
      double v90 = (double)v91 / (double)v92;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v90;
    }
    double v636 = v90 * (double)(unint64_t)(float)(v88 / (float)v89);
LABEL_128:
    if (*(void *)(a1 + 16))
    {
      uint64_t v93 = *(void *)(a1 + 32);
      uint64_t v94 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a1 + 40)));
      unsigned int v95 = 0x7FFFFFFF;
      if (v94 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v93 + 80 * v94 + 12) == 9)
        {
LABEL_133:
          unsigned int v95 = v94;
        }
        else
        {
          while (1)
          {
            LODWORD(v94) = *(_DWORD *)(v93 + 80 * v94 + 8) & 0x7FFFFFFF;
            unsigned int v95 = 0x7FFFFFFF;
            if (v94 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v93 + 80 * v94 + 12) == 9) {
              goto LABEL_133;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v93 = *(void *)(a1 + 32);
      unsigned int v95 = 0x7FFFFFFF;
    }
    float v96 = *(float *)(v93 + 80 * v95 + 48);
    unint64_t v97 = *(void *)(a1 + 256);
    double v98 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v101 = NAN;
        goto LABEL_140;
      }
      LODWORD(v99) = info[0].numer;
      LODWORD(v100) = info[0].denom;
      double v98 = (double)v99 / (double)v100;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v98;
    }
    double v101 = v98 * (double)(unint64_t)(float)(v96 / (float)v97);
LABEL_140:
    double v634 = v101;
    if (*(void *)(a1 + 16))
    {
      uint64_t v102 = *(void *)(a1 + 32);
      uint64_t v103 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v104 = 0x7FFFFFFF;
      if (v103 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v102 + 80 * v103 + 12) == 10)
        {
LABEL_145:
          unsigned int v104 = v103;
        }
        else
        {
          while (1)
          {
            LODWORD(v103) = *(_DWORD *)(v102 + 80 * v103 + 8) & 0x7FFFFFFF;
            unsigned int v104 = 0x7FFFFFFF;
            if (v103 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v102 + 80 * v103 + 12) == 10) {
              goto LABEL_145;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v102 = *(void *)(a1 + 32);
      unsigned int v104 = 0x7FFFFFFF;
    }
    float v105 = *(float *)(v102 + 80 * v104 + 48);
    unint64_t v106 = *(void *)(a1 + 256);
    double v107 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v110 = NAN;
        goto LABEL_152;
      }
      LODWORD(v108) = info[0].numer;
      LODWORD(v109) = info[0].denom;
      double v107 = (double)v108 / (double)v109;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v107;
    }
    double v110 = v107 * (double)(unint64_t)(float)(v105 / (float)v106);
LABEL_152:
    double v621 = v110;
    if (*(void *)(a1 + 16))
    {
      uint64_t v111 = *(void *)(a1 + 32);
      uint64_t v112 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a1 + 40)));
      unsigned int v113 = 0x7FFFFFFF;
      if (v112 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v111 + 80 * v112 + 12) == 8)
        {
LABEL_157:
          unsigned int v113 = v112;
        }
        else
        {
          while (1)
          {
            LODWORD(v112) = *(_DWORD *)(v111 + 80 * v112 + 8) & 0x7FFFFFFF;
            unsigned int v113 = 0x7FFFFFFF;
            if (v112 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v111 + 80 * v112 + 12) == 8) {
              goto LABEL_157;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v111 = *(void *)(a1 + 32);
      unsigned int v113 = 0x7FFFFFFF;
    }
    float v114 = *(float *)(v111 + 80 * v113 + 48);
    unint64_t v115 = *(void *)(a1 + 256);
    double v116 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v119 = NAN;
        goto LABEL_164;
      }
      LODWORD(v117) = info[0].numer;
      LODWORD(v118) = info[0].denom;
      double v116 = (double)v117 / (double)v118;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v116;
    }
    double v119 = v116 * (double)(unint64_t)(float)(v114 / (float)v115);
LABEL_164:
    double v619 = v119;
    if (*(void *)(a1 + 16))
    {
      uint64_t v120 = *(void *)(a1 + 32);
      uint64_t v121 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v122 = 0x7FFFFFFF;
      if (v121 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v120 + 80 * v121 + 12) == 11)
        {
LABEL_169:
          unsigned int v122 = v121;
        }
        else
        {
          while (1)
          {
            LODWORD(v121) = *(_DWORD *)(v120 + 80 * v121 + 8) & 0x7FFFFFFF;
            unsigned int v122 = 0x7FFFFFFF;
            if (v121 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v120 + 80 * v121 + 12) == 11) {
              goto LABEL_169;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v120 = *(void *)(a1 + 32);
      unsigned int v122 = 0x7FFFFFFF;
    }
    float v123 = *(float *)(v120 + 80 * v122 + 48);
    unint64_t v124 = *(void *)(a1 + 256);
    double v125 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v128 = NAN;
        goto LABEL_176;
      }
      LODWORD(v126) = info[0].numer;
      LODWORD(v127) = info[0].denom;
      double v125 = (double)v126 / (double)v127;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v125;
    }
    double v128 = v125 * (double)(unint64_t)(float)(v123 / (float)v124);
LABEL_176:
    if (*(void *)(a1 + 16))
    {
      uint64_t v129 = *(void *)(a1 + 32);
      uint64_t v130 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v131 = 0x7FFFFFFF;
      if (v130 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v129 + 80 * v130 + 12) == 12)
        {
LABEL_181:
          unsigned int v131 = v130;
        }
        else
        {
          while (1)
          {
            LODWORD(v130) = *(_DWORD *)(v129 + 80 * v130 + 8) & 0x7FFFFFFF;
            unsigned int v131 = 0x7FFFFFFF;
            if (v130 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v129 + 80 * v130 + 12) == 12) {
              goto LABEL_181;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v129 = *(void *)(a1 + 32);
      unsigned int v131 = 0x7FFFFFFF;
    }
    float v132 = *(float *)(v129 + 80 * v131 + 48);
    unint64_t v133 = *(void *)(a1 + 256);
    double v134 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v615 = NAN;
        goto LABEL_188;
      }
      LODWORD(v135) = info[0].numer;
      LODWORD(v136) = info[0].denom;
      double v134 = (double)v135 / (double)v136;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v134;
    }
    double v615 = v134 * (double)(unint64_t)(float)(v132 / (float)v133);
LABEL_188:
    if (*(void *)(a1 + 16))
    {
      uint64_t v137 = *(void *)(a1 + 32);
      uint64_t v138 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a1 + 40)));
      unsigned int v139 = 0x7FFFFFFF;
      if (v138 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v137 + 80 * v138 + 12) == 13)
        {
LABEL_193:
          unsigned int v139 = v138;
        }
        else
        {
          while (1)
          {
            LODWORD(v138) = *(_DWORD *)(v137 + 80 * v138 + 8) & 0x7FFFFFFF;
            unsigned int v139 = 0x7FFFFFFF;
            if (v138 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v137 + 80 * v138 + 12) == 13) {
              goto LABEL_193;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v137 = *(void *)(a1 + 32);
      unsigned int v139 = 0x7FFFFFFF;
    }
    float v140 = *(float *)(v137 + 80 * v139 + 48);
    unint64_t v141 = *(void *)(a1 + 256);
    double v142 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v617 = v128;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v145 = NAN;
        goto LABEL_200;
      }
      LODWORD(v143) = info[0].numer;
      LODWORD(v144) = info[0].denom;
      double v142 = (double)v143 / (double)v144;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v142;
    }
    double v145 = v142 * (double)(unint64_t)(float)(v140 / (float)v141);
LABEL_200:
    if (*(void *)(a1 + 16))
    {
      uint64_t v146 = *(void *)(a1 + 32);
      uint64_t v147 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v148 = 0x7FFFFFFF;
      if (v147 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v146 + 80 * v147 + 12) == 14)
        {
LABEL_205:
          unsigned int v148 = v147;
        }
        else
        {
          while (1)
          {
            LODWORD(v147) = *(_DWORD *)(v146 + 80 * v147 + 8) & 0x7FFFFFFF;
            unsigned int v148 = 0x7FFFFFFF;
            if (v147 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v146 + 80 * v147 + 12) == 14) {
              goto LABEL_205;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v146 = *(void *)(a1 + 32);
      unsigned int v148 = 0x7FFFFFFF;
    }
    float v149 = *(float *)(v146 + 80 * v148 + 48);
    unint64_t v150 = *(void *)(a1 + 256);
    double v151 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v629 = NAN;
        goto LABEL_212;
      }
      LODWORD(v152) = info[0].numer;
      LODWORD(v153) = info[0].denom;
      double v151 = (double)v152 / (double)v153;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v151;
    }
    double v629 = v151 * (double)(unint64_t)(float)(v149 / (float)v150);
LABEL_212:
    if (*(void *)(a1 + 16))
    {
      uint64_t v154 = *(void *)(a1 + 32);
      uint64_t v155 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v156 = 0x7FFFFFFF;
      if (v155 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v154 + 80 * v155 + 12) == 15)
        {
LABEL_217:
          unsigned int v156 = v155;
        }
        else
        {
          while (1)
          {
            LODWORD(v155) = *(_DWORD *)(v154 + 80 * v155 + 8) & 0x7FFFFFFF;
            unsigned int v156 = 0x7FFFFFFF;
            if (v155 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v154 + 80 * v155 + 12) == 15) {
              goto LABEL_217;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v154 = *(void *)(a1 + 32);
      unsigned int v156 = 0x7FFFFFFF;
    }
    float v157 = *(float *)(v154 + 80 * v156 + 48);
    unint64_t v158 = *(void *)(a1 + 256);
    double v159 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v628 = NAN;
        goto LABEL_224;
      }
      LODWORD(v160) = info[0].numer;
      LODWORD(v161) = info[0].denom;
      double v159 = (double)v160 / (double)v161;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v159;
    }
    double v628 = v159 * (double)(unint64_t)(float)(v157 / (float)v158);
LABEL_224:
    if (*(void *)(a1 + 16))
    {
      uint64_t v162 = *(void *)(a1 + 32);
      uint64_t v163 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a1 + 40)));
      unsigned int v164 = 0x7FFFFFFF;
      if (v163 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v162 + 80 * v163 + 12) == 16)
        {
LABEL_229:
          unsigned int v164 = v163;
        }
        else
        {
          while (1)
          {
            LODWORD(v163) = *(_DWORD *)(v162 + 80 * v163 + 8) & 0x7FFFFFFF;
            unsigned int v164 = 0x7FFFFFFF;
            if (v163 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v162 + 80 * v163 + 12) == 16) {
              goto LABEL_229;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v162 = *(void *)(a1 + 32);
      unsigned int v164 = 0x7FFFFFFF;
    }
    float v165 = *(float *)(v162 + 80 * v164 + 48);
    unint64_t v166 = *(void *)(a1 + 256);
    double v167 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v170 = NAN;
        goto LABEL_236;
      }
      LODWORD(v168) = info[0].numer;
      LODWORD(v169) = info[0].denom;
      double v167 = (double)v168 / (double)v169;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v167;
    }
    double v170 = v167 * (double)(unint64_t)(float)(v165 / (float)v166);
LABEL_236:
    double v624 = v170;
    if (*(void *)(a1 + 16))
    {
      uint64_t v171 = *(void *)(a1 + 32);
      uint64_t v172 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v173 = 0x7FFFFFFF;
      if (v172 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v171 + 80 * v172 + 12) == 17)
        {
LABEL_241:
          unsigned int v173 = v172;
        }
        else
        {
          while (1)
          {
            LODWORD(v172) = *(_DWORD *)(v171 + 80 * v172 + 8) & 0x7FFFFFFF;
            unsigned int v173 = 0x7FFFFFFF;
            if (v172 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v171 + 80 * v172 + 12) == 17) {
              goto LABEL_241;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v171 = *(void *)(a1 + 32);
      unsigned int v173 = 0x7FFFFFFF;
    }
    float v174 = *(float *)(v171 + 80 * v173 + 48);
    unint64_t v175 = *(void *)(a1 + 256);
    double v176 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v179 = NAN;
        goto LABEL_248;
      }
      LODWORD(v177) = info[0].numer;
      LODWORD(v178) = info[0].denom;
      double v176 = (double)v177 / (double)v178;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v176;
    }
    double v179 = v176 * (double)(unint64_t)(float)(v174 / (float)v175);
LABEL_248:
    double v625 = v179;
    if (*(void *)(a1 + 16))
    {
      uint64_t v180 = *(void *)(a1 + 32);
      uint64_t v181 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a1 + 40)));
      unsigned int v182 = 0x7FFFFFFF;
      if (v181 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v180 + 80 * v181 + 12) == 19)
        {
LABEL_253:
          unsigned int v182 = v181;
        }
        else
        {
          while (1)
          {
            LODWORD(v181) = *(_DWORD *)(v180 + 80 * v181 + 8) & 0x7FFFFFFF;
            unsigned int v182 = 0x7FFFFFFF;
            if (v181 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v180 + 80 * v181 + 12) == 19) {
              goto LABEL_253;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v180 = *(void *)(a1 + 32);
      unsigned int v182 = 0x7FFFFFFF;
    }
    float v183 = *(float *)(v180 + 80 * v182 + 48);
    unint64_t v184 = *(void *)(a1 + 256);
    double v185 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v626 = NAN;
        goto LABEL_260;
      }
      LODWORD(v186) = info[0].numer;
      LODWORD(v187) = info[0].denom;
      double v185 = (double)v186 / (double)v187;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v185;
    }
    double v626 = v185 * (double)(unint64_t)(float)(v183 / (float)v184);
LABEL_260:
    if (*(void *)(a1 + 16))
    {
      uint64_t v188 = *(void *)(a1 + 32);
      uint64_t v189 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v190 = 0x7FFFFFFF;
      if (v189 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v188 + 80 * v189 + 12) == 20)
        {
LABEL_265:
          unsigned int v190 = v189;
        }
        else
        {
          while (1)
          {
            LODWORD(v189) = *(_DWORD *)(v188 + 80 * v189 + 8) & 0x7FFFFFFF;
            unsigned int v190 = 0x7FFFFFFF;
            if (v189 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v188 + 80 * v189 + 12) == 20) {
              goto LABEL_265;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v188 = *(void *)(a1 + 32);
      unsigned int v190 = 0x7FFFFFFF;
    }
    float v191 = *(float *)(v188 + 80 * v190 + 48);
    unint64_t v192 = *(void *)(a1 + 256);
    double v193 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v616 = NAN;
        goto LABEL_272;
      }
      LODWORD(v194) = info[0].numer;
      LODWORD(v195) = info[0].denom;
      double v193 = (double)v194 / (double)v195;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v193;
    }
    double v616 = v193 * (double)(unint64_t)(float)(v191 / (float)v192);
LABEL_272:
    if (*(void *)(a1 + 16))
    {
      uint64_t v196 = *(void *)(a1 + 32);
      uint64_t v197 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a1 + 40)));
      unsigned int v198 = 0x7FFFFFFF;
      if (v197 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v196 + 80 * v197 + 12) == 21)
        {
LABEL_277:
          unsigned int v198 = v197;
        }
        else
        {
          while (1)
          {
            LODWORD(v197) = *(_DWORD *)(v196 + 80 * v197 + 8) & 0x7FFFFFFF;
            unsigned int v198 = 0x7FFFFFFF;
            if (v197 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v196 + 80 * v197 + 12) == 21) {
              goto LABEL_277;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v196 = *(void *)(a1 + 32);
      unsigned int v198 = 0x7FFFFFFF;
    }
    float v199 = *(float *)(v196 + 80 * v198 + 48);
    unint64_t v200 = *(void *)(a1 + 256);
    double v201 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v627 = NAN;
        goto LABEL_284;
      }
      LODWORD(v202) = info[0].numer;
      LODWORD(v203) = info[0].denom;
      double v201 = (double)v202 / (double)v203;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v201;
    }
    double v627 = v201 * (double)(unint64_t)(float)(v199 / (float)v200);
LABEL_284:
    if (*(void *)(a1 + 16))
    {
      uint64_t v204 = *(void *)(a1 + 32);
      uint64_t v205 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v206 = 0x7FFFFFFF;
      if (v205 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v204 + 80 * v205 + 12) == 23)
        {
LABEL_289:
          unsigned int v206 = v205;
        }
        else
        {
          while (1)
          {
            LODWORD(v205) = *(_DWORD *)(v204 + 80 * v205 + 8) & 0x7FFFFFFF;
            unsigned int v206 = 0x7FFFFFFF;
            if (v205 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v204 + 80 * v205 + 12) == 23) {
              goto LABEL_289;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v204 = *(void *)(a1 + 32);
      unsigned int v206 = 0x7FFFFFFF;
    }
    float v207 = *(float *)(v204 + 80 * v206 + 48);
    unint64_t v208 = *(void *)(a1 + 256);
    double v209 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v631 = v39;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v212 = NAN;
        goto LABEL_296;
      }
      LODWORD(v210) = info[0].numer;
      LODWORD(v211) = info[0].denom;
      double v209 = (double)v210 / (double)v211;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v209;
    }
    double v212 = v209 * (double)(unint64_t)(float)(v207 / (float)v208);
LABEL_296:
    if (*(void *)(a1 + 16))
    {
      uint64_t v213 = *(void *)(a1 + 32);
      uint64_t v214 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a1 + 40)));
      unsigned int v215 = 0x7FFFFFFF;
      if (v214 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v213 + 80 * v214 + 12) == 22)
        {
LABEL_301:
          unsigned int v215 = v214;
        }
        else
        {
          while (1)
          {
            LODWORD(v214) = *(_DWORD *)(v213 + 80 * v214 + 8) & 0x7FFFFFFF;
            unsigned int v215 = 0x7FFFFFFF;
            if (v214 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v213 + 80 * v214 + 12) == 22) {
              goto LABEL_301;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v213 = *(void *)(a1 + 32);
      unsigned int v215 = 0x7FFFFFFF;
    }
    float v216 = *(float *)(v213 + 80 * v215 + 48);
    unint64_t v217 = *(void *)(a1 + 256);
    double v218 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v623 = NAN;
        goto LABEL_308;
      }
      LODWORD(v219) = info[0].numer;
      LODWORD(v220) = info[0].denom;
      double v218 = (double)v219 / (double)v220;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v218;
    }
    double v623 = v218 * (double)(unint64_t)(float)(v216 / (float)v217);
LABEL_308:
    if (*(void *)(a1 + 16))
    {
      uint64_t v221 = *(void *)(a1 + 32);
      uint64_t v222 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a1 + 40)));
      unsigned int v223 = 0x7FFFFFFF;
      if (v222 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v221 + 80 * v222 + 12) == 91)
        {
LABEL_313:
          unsigned int v223 = v222;
        }
        else
        {
          while (1)
          {
            LODWORD(v222) = *(_DWORD *)(v221 + 80 * v222 + 8) & 0x7FFFFFFF;
            unsigned int v223 = 0x7FFFFFFF;
            if (v222 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v221 + 80 * v222 + 12) == 91) {
              goto LABEL_313;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v221 = *(void *)(a1 + 32);
      unsigned int v223 = 0x7FFFFFFF;
    }
    float v224 = *(float *)(v221 + 80 * v223 + 48);
    unint64_t v225 = *(void *)(a1 + 256);
    double v226 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v630 = v145;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v229 = NAN;
        goto LABEL_320;
      }
      LODWORD(v227) = info[0].numer;
      LODWORD(v228) = info[0].denom;
      double v226 = (double)v227 / (double)v228;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v226;
    }
    double v229 = v226 * (double)(unint64_t)(float)(v224 / (float)v225);
LABEL_320:
    if (*(void *)(a1 + 16))
    {
      uint64_t v232 = *(void *)(a1 + 32);
      uint64_t v233 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a1 + 40)));
      unsigned int v234 = 0x7FFFFFFF;
      if (v233 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v232 + 80 * v233 + 12) == 92)
        {
LABEL_325:
          unsigned int v234 = v233;
        }
        else
        {
          while (1)
          {
            LODWORD(v233) = *(_DWORD *)(v232 + 80 * v233 + 8) & 0x7FFFFFFF;
            unsigned int v234 = 0x7FFFFFFF;
            if (v233 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v232 + 80 * v233 + 12) == 92) {
              goto LABEL_325;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v232 = *(void *)(a1 + 32);
      unsigned int v234 = 0x7FFFFFFF;
    }
    float v231 = v57 / 1000000.0;
    float v230 = v48 / 1000000.0;
    float v236 = v230 + v231;
    float v237 = *(float *)(v232 + 80 * v234 + 48);
    unint64_t v238 = *(void *)(a1 + 256);
    double v239 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v242 = NAN;
        goto LABEL_332;
      }
      LODWORD(v240) = info[0].numer;
      LODWORD(v241) = info[0].denom;
      double v239 = (double)v240 / (double)v241;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v239;
    }
    double v242 = v239 * (double)(unint64_t)(float)(v237 / (float)v238);
LABEL_332:
    double v244 = v621 / 1000000.0;
    double v245 = v229 / 1000000.0;
    double v246 = v242 / 1000000.0;
    if (*(void *)(a1 + 16))
    {
      uint64_t v247 = *(void *)(a1 + 32);
      uint64_t v248 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a1 + 40)));
      unsigned int v249 = 0x7FFFFFFF;
      if (v248 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v247 + 80 * v248 + 12) == 93)
        {
LABEL_337:
          unsigned int v249 = v248;
        }
        else
        {
          while (1)
          {
            LODWORD(v248) = *(_DWORD *)(v247 + 80 * v248 + 8) & 0x7FFFFFFF;
            unsigned int v249 = 0x7FFFFFFF;
            if (v248 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v247 + 80 * v248 + 12) == 93) {
              goto LABEL_337;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v247 = *(void *)(a1 + 32);
      unsigned int v249 = 0x7FFFFFFF;
    }
    float v250 = v639 / 1000000.0;
    float v243 = v75 / 1000000.0;
    float v235 = v641 / 1000000.0;
    float v251 = (float)(v236 + v235) + v243;
    float v252 = v619 / 1000000.0;
    float v642 = v252;
    float v253 = v617 / 1000000.0;
    float v254 = v244;
    float v255 = v615 / 1000000.0;
    float v256 = v212 / 1000000.0;
    float v640 = v256;
    float v257 = v245;
    float v258 = v246;
    float v259 = *(float *)(v247 + 80 * v249 + 48);
    unint64_t v260 = *(void *)(a1 + 256);
    double v261 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v262 = v636 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      float v637 = v244;
      if (mach_timebase_info(info))
      {
        double v265 = NAN;
        double v267 = v631;
        double v266 = v634;
        float v253 = v617 / 1000000.0;
        float v254 = v637;
        goto LABEL_344;
      }
      LODWORD(v263) = info[0].numer;
      LODWORD(v264) = info[0].denom;
      double v261 = (double)v263 / (double)v264;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v261;
      float v253 = v617 / 1000000.0;
      float v254 = v637;
    }
    double v265 = v261 * (double)(unint64_t)(float)(v259 / (float)v260);
    double v267 = v631;
    double v266 = v634;
LABEL_344:
    float v269 = v265 / 1000000.0;
    float v270 = v257 + v258;
    float v620 = v253;
    float v271 = (float)(v253 + v255) + v640;
    float v272 = 0.0;
    if (v642 > 0.0)
    {
      float v273 = v254;
    }
    else
    {
      float v272 = v271;
      float v273 = v271;
    }
    if (*(void *)(a1 + 16))
    {
      uint64_t v274 = *(void *)(a1 + 32);
      uint64_t v275 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xFFCB5C99F6AA8871 % *(unsigned int *)(a1 + 40)));
      unsigned int v276 = 0x7FFFFFFF;
      if (v275 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v274 + 80 * v275 + 12) == 18)
        {
LABEL_352:
          unsigned int v276 = v275;
        }
        else
        {
          while (1)
          {
            LODWORD(v275) = *(_DWORD *)(v274 + 80 * v275 + 8) & 0x7FFFFFFF;
            unsigned int v276 = 0x7FFFFFFF;
            if (v275 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v274 + 80 * v275 + 12) == 18) {
              goto LABEL_352;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v274 = *(void *)(a1 + 32);
      unsigned int v276 = 0x7FFFFFFF;
    }
    float v277 = v266 / 1000000.0;
    float v268 = v262;
    float v278 = (float)(v251 + v250) + v268;
    float v279 = v270 + v269;
    float v280 = *(float *)(v274 + 80 * v276 + 48);
    unint64_t v281 = *(void *)(a1 + 256);
    double v282 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v283 = v267 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      float v632 = v279;
      float v284 = v277;
      float v285 = v272;
      if (mach_timebase_info(info))
      {
        double v622 = NAN;
        float v272 = v285;
        float v277 = v284;
        float v255 = v615 / 1000000.0;
        float v279 = v632;
        goto LABEL_359;
      }
      LODWORD(v286) = info[0].numer;
      LODWORD(v287) = info[0].denom;
      double v282 = (double)v286 / (double)v287;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v282;
      float v272 = v285;
      float v277 = v284;
      float v255 = v615 / 1000000.0;
      float v279 = v632;
    }
    double v622 = v282 * (double)(unint64_t)(float)(v280 / (float)v281);
LABEL_359:
    float v288 = v283;
    uint64_t v289 = *(void *)(a1 + 16);
    float v618 = v255;
    if (v289)
    {
      uint64_t v290 = *(void *)(a1 + 32);
      uint64_t v291 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD59EEF30DB86CAB8 % *(unsigned int *)(a1 + 40)));
      unsigned int v292 = 0x7FFFFFFF;
      if (v291 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v290 + 80 * v291 + 12) == 24)
        {
LABEL_364:
          unsigned int v292 = v291;
        }
        else
        {
          while (1)
          {
            LODWORD(v291) = *(_DWORD *)(v290 + 80 * v291 + 8) & 0x7FFFFFFF;
            unsigned int v292 = 0x7FFFFFFF;
            if (v291 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v290 + 80 * v291 + 12) == 24) {
              goto LABEL_364;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v290 = *(void *)(a1 + 32);
      unsigned int v292 = 0x7FFFFFFF;
    }
    float v293 = (float)(v277 - v254) + v279;
    float v294 = (float)(v278 + v279) - v273;
    float v295 = *(float *)(v290 + 80 * v292 + 48);
    unint64_t v296 = *(void *)(a1 + 256);
    BOOL v297 = v288 <= 0.0;
    double v298 = (float)(1000.0 / v288);
    if (v297) {
      double v299 = 0.0;
    }
    else {
      double v299 = v298;
    }
    float v638 = v277;
    float v635 = v278;
    if (v289)
    {
      unint64_t v300 = *(unsigned int *)(a1 + 40);
      uint64_t v301 = *(void *)(a1 + 24);
      unsigned int v302 = *(_DWORD *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300));
      unsigned int v303 = 0x7FFFFFFF;
      unsigned int v304 = 0x7FFFFFFF;
      if (v302 != 0x7FFFFFFF)
      {
        unsigned int v304 = *(_DWORD *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300));
        if (*(unsigned char *)(v290 + 80 * v302 + 12) != 29)
        {
          while (1)
          {
            unsigned int v304 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300)) + 8) & 0x7FFFFFFF;
            if (v304 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v290 + 80 * v304 + 12) == 29) {
              goto LABEL_377;
            }
          }
          unsigned int v304 = 0x7FFFFFFF;
        }
      }
LABEL_377:
      unsigned int v309 = *(_DWORD *)(v301 + 4 * (0x724EA9269D42A72 % v300));
      if (v309 != 0x7FFFFFFF)
      {
        unsigned int v303 = *(_DWORD *)(v301 + 4 * (0x724EA9269D42A72 % v300));
        if (*(unsigned char *)(v290 + 80 * v309 + 12) != 30)
        {
          while (1)
          {
            unsigned int v303 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x724EA9269D42A72 % v300)) + 8) & 0x7FFFFFFF;
            if (v303 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v290 + 80 * v303 + 12) == 30) {
              goto LABEL_383;
            }
          }
          unsigned int v303 = 0x7FFFFFFF;
        }
      }
LABEL_383:
      uint64_t v310 = v290 + 80 * v304;
      uint64_t v311 = v290 + 80 * v303;
      unsigned int v312 = *(_DWORD *)(v301 + 4 * (0x540F172E046EF165 % v300));
      unsigned int v306 = 0x7FFFFFFF;
      unsigned int v313 = 0x7FFFFFFF;
      if (v312 != 0x7FFFFFFF)
      {
        unsigned int v313 = *(_DWORD *)(v301 + 4 * (0x540F172E046EF165 % v300));
        if (*(unsigned char *)(v290 + 80 * v312 + 12) != 31)
        {
          while (1)
          {
            unsigned int v313 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x540F172E046EF165 % v300)) + 8) & 0x7FFFFFFF;
            if (v313 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v290 + 80 * v313 + 12) == 31) {
              goto LABEL_389;
            }
          }
          unsigned int v313 = 0x7FFFFFFF;
        }
      }
LABEL_389:
      float v307 = *(float *)(v310 + 48);
      float v308 = *(float *)(v311 + 48);
      float v305 = *(float *)(v290 + 80 * v313 + 48);
      uint64_t v314 = *(unsigned int *)(v301 + 4 * (0xADFB1EBB497FAD45 % v300));
      if (v314 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v290 + 80 * v314 + 12) == 32)
        {
LABEL_393:
          unsigned int v306 = v314;
        }
        else
        {
          while (1)
          {
            LODWORD(v314) = *(_DWORD *)(v290 + 80 * v314 + 8) & 0x7FFFFFFF;
            unsigned int v306 = 0x7FFFFFFF;
            if (v314 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v290 + 80 * v314 + 12) == 32) {
              goto LABEL_393;
            }
          }
        }
      }
    }
    else
    {
      float v305 = *(float *)(v290 + 0x27FFFFFFE0);
      unsigned int v306 = 0x7FFFFFFF;
      float v307 = v305;
      float v308 = v305;
    }
    float v315 = v293 - v272;
    float v316 = *(float *)(v290 + 80 * v306 + 48);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Frame Times (ms)\n");
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "FPS: %.2f    Main Thread: %.2f\n", v299, v294);
    if (v642 > 0.0) {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Render Thread: %.2f\n", (float)((float)((float)(v642 - v620) - v618) - v640));
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "GPU: %.2f\n", (float)((float)(v295 / (float)v296) / 1000000.0));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Vtx: %.2f    Frg: %.2f\nRender Compute: %0.2f\nDeformer Compute: %0.2f\n", (double)(unint64_t)(float)((float)(v307 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v308 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v305 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v316 / (float)v296) / 1000000.0) / 1000000.0);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Engine CPU Breakdown (ms)\n");
    if (*(void *)(a1 + 16))
    {
      uint64_t v317 = *(void *)(a1 + 32);
      uint64_t v318 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a1 + 40)));
      unsigned int v319 = 0x7FFFFFFF;
      if (v318 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v317 + 80 * v318 + 12) == 122)
        {
LABEL_401:
          unsigned int v319 = v318;
        }
        else
        {
          while (1)
          {
            LODWORD(v318) = *(_DWORD *)(v317 + 80 * v318 + 8) & 0x7FFFFFFF;
            unsigned int v319 = 0x7FFFFFFF;
            if (v318 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v317 + 80 * v318 + 12) == 122) {
              goto LABEL_401;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v317 = *(void *)(a1 + 32);
      unsigned int v319 = 0x7FFFFFFF;
    }
    float v320 = *(float *)(v317 + 80 * v319 + 48);
    unint64_t v321 = *(void *)(a1 + 256);
    double v322 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v325 = NAN;
        goto LABEL_408;
      }
      LODWORD(v323) = info[0].numer;
      LODWORD(v324) = info[0].denom;
      double v322 = (double)v323 / (double)v324;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v322;
    }
    double v325 = v322 * (double)(unint64_t)(float)(v320 / (float)v321);
LABEL_408:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "RenderGraph: %.2f    Render ECS: %.2f\n", (float)(v315 + v642), v325 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v326 = *(void *)(a1 + 32);
      uint64_t v327 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x786DD0AB972D849AuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v328 = 0x7FFFFFFF;
      if (v327 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v326 + 80 * v327 + 12) == 115)
        {
LABEL_413:
          unsigned int v328 = v327;
        }
        else
        {
          while (1)
          {
            LODWORD(v327) = *(_DWORD *)(v326 + 80 * v327 + 8) & 0x7FFFFFFF;
            unsigned int v328 = 0x7FFFFFFF;
            if (v327 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v326 + 80 * v327 + 12) == 115) {
              goto LABEL_413;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v326 = *(void *)(a1 + 32);
      unsigned int v328 = 0x7FFFFFFF;
    }
    float v329 = *(float *)(v326 + 80 * v328 + 48);
    unint64_t v330 = *(void *)(a1 + 256);
    double v331 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v334 = NAN;
        goto LABEL_420;
      }
      LODWORD(v332) = info[0].numer;
      LODWORD(v333) = info[0].denom;
      double v331 = (double)v332 / (double)v333;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v331;
    }
    double v334 = v331 * (double)(unint64_t)(float)(v329 / (float)v330);
LABEL_420:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Deformations: %.2f\n", v334 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v335 = *(void *)(a1 + 32);
      uint64_t v336 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x3465840D39B46BB3uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v337 = 0x7FFFFFFF;
      if (v336 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v335 + 80 * v336 + 12) == 150)
        {
LABEL_425:
          unsigned int v337 = v336;
        }
        else
        {
          while (1)
          {
            LODWORD(v336) = *(_DWORD *)(v335 + 80 * v336 + 8) & 0x7FFFFFFF;
            unsigned int v337 = 0x7FFFFFFF;
            if (v336 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v335 + 80 * v336 + 12) == 150) {
              goto LABEL_425;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v335 = *(void *)(a1 + 32);
      unsigned int v337 = 0x7FFFFFFF;
    }
    float v338 = *(float *)(v335 + 80 * v337 + 48);
    unint64_t v339 = *(void *)(a1 + 256);
    double v340 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v343 = NAN;
        goto LABEL_432;
      }
      LODWORD(v341) = info[0].numer;
      LODWORD(v342) = info[0].denom;
      double v340 = (double)v341 / (double)v342;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v340;
    }
    double v343 = v340 * (double)(unint64_t)(float)(v338 / (float)v339);
LABEL_432:
    if (*(void *)(a1 + 16))
    {
      uint64_t v344 = *(void *)(a1 + 32);
      uint64_t v345 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a1 + 40)));
      unsigned int v346 = 0x7FFFFFFF;
      if (v345 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v344 + 80 * v345 + 12) == 130)
        {
LABEL_437:
          unsigned int v346 = v345;
        }
        else
        {
          while (1)
          {
            LODWORD(v345) = *(_DWORD *)(v344 + 80 * v345 + 8) & 0x7FFFFFFF;
            unsigned int v346 = 0x7FFFFFFF;
            if (v345 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v344 + 80 * v345 + 12) == 130) {
              goto LABEL_437;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v344 = *(void *)(a1 + 32);
      unsigned int v346 = 0x7FFFFFFF;
    }
    float v348 = *(float *)(v344 + 80 * v346 + 48);
    unint64_t v349 = *(void *)(a1 + 256);
    double v350 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v351 = v343 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v354 = NAN;
        goto LABEL_444;
      }
      LODWORD(v352) = info[0].numer;
      LODWORD(v353) = info[0].denom;
      double v350 = (double)v352 / (double)v353;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v350;
    }
    double v354 = v350 * (double)(unint64_t)(float)(v348 / (float)v349);
LABEL_444:
    float v347 = v624 / 1000000.0;
    double v355 = v347;
    float v356 = v616 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "VFX RenderNode: %.2f    VFX ECS: %.2f\n", v351, v354 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v357 = *(void *)(a1 + 32);
      uint64_t v358 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v359 = 0x7FFFFFFF;
      if (v358 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v357 + 80 * v358 + 12) == 125)
        {
LABEL_449:
          unsigned int v359 = v358;
        }
        else
        {
          while (1)
          {
            LODWORD(v358) = *(_DWORD *)(v357 + 80 * v358 + 8) & 0x7FFFFFFF;
            unsigned int v359 = 0x7FFFFFFF;
            if (v358 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v357 + 80 * v358 + 12) == 125) {
              goto LABEL_449;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v357 = *(void *)(a1 + 32);
      unsigned int v359 = 0x7FFFFFFF;
    }
    double v360 = v625 / 1000000.0 + v355;
    float v361 = *(float *)(v357 + 80 * v359 + 48);
    unint64_t v362 = *(void *)(a1 + 256);
    double v363 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v366 = NAN;
        goto LABEL_456;
      }
      LODWORD(v364) = info[0].numer;
      LODWORD(v365) = info[0].denom;
      double v363 = (double)v364 / (double)v365;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v363;
    }
    double v366 = v363 * (double)(unint64_t)(float)(v361 / (float)v362);
LABEL_456:
    float v367 = v360;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Animation Update: %.2f    Animation ECS: %.2f\n", v356, v366 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v368 = *(void *)(a1 + 32);
      uint64_t v369 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a1 + 40)));
      unsigned int v370 = 0x7FFFFFFF;
      if (v369 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v368 + 80 * v369 + 12) == 123)
        {
LABEL_461:
          unsigned int v370 = v369;
        }
        else
        {
          while (1)
          {
            LODWORD(v369) = *(_DWORD *)(v368 + 80 * v369 + 8) & 0x7FFFFFFF;
            unsigned int v370 = 0x7FFFFFFF;
            if (v369 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v368 + 80 * v369 + 12) == 123) {
              goto LABEL_461;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v368 = *(void *)(a1 + 32);
      unsigned int v370 = 0x7FFFFFFF;
    }
    float v371 = *(float *)(v368 + 80 * v370 + 48);
    unint64_t v372 = *(void *)(a1 + 256);
    double v373 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v376 = NAN;
        goto LABEL_468;
      }
      LODWORD(v374) = info[0].numer;
      LODWORD(v375) = info[0].denom;
      double v373 = (double)v374 / (double)v375;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v373;
    }
    double v376 = v373 * (double)(unint64_t)(float)(v371 / (float)v372);
LABEL_468:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Network Update: %.2f    Network ECS: %.2f\n", v367, v376 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v378 = *(void *)(a1 + 32);
      uint64_t v379 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a1 + 40)));
      unsigned int v380 = 0x7FFFFFFF;
      if (v379 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v378 + 80 * v379 + 12) == 121)
        {
LABEL_473:
          unsigned int v380 = v379;
        }
        else
        {
          while (1)
          {
            LODWORD(v379) = *(_DWORD *)(v378 + 80 * v379 + 8) & 0x7FFFFFFF;
            unsigned int v380 = 0x7FFFFFFF;
            if (v379 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v378 + 80 * v379 + 12) == 121) {
              goto LABEL_473;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v378 = *(void *)(a1 + 32);
      unsigned int v380 = 0x7FFFFFFF;
    }
    float v381 = *(float *)(v378 + 80 * v380 + 48);
    unint64_t v382 = *(void *)(a1 + 256);
    double v383 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v386 = NAN;
        goto LABEL_480;
      }
      LODWORD(v384) = info[0].numer;
      LODWORD(v385) = info[0].denom;
      double v383 = (double)v384 / (double)v385;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v383;
    }
    double v386 = v383 * (double)(unint64_t)(float)(v381 / (float)v382);
LABEL_480:
    float v377 = v626 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Physics Engine: %.2f    Physics ECS: %.2f\n", v377, v386 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v388 = *(void *)(a1 + 32);
      uint64_t v389 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v390 = 0x7FFFFFFF;
      if (v389 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v388 + 80 * v389 + 12) == 120)
        {
LABEL_485:
          unsigned int v390 = v389;
        }
        else
        {
          while (1)
          {
            LODWORD(v389) = *(_DWORD *)(v388 + 80 * v389 + 8) & 0x7FFFFFFF;
            unsigned int v390 = 0x7FFFFFFF;
            if (v389 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v388 + 80 * v389 + 12) == 120) {
              goto LABEL_485;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v388 = *(void *)(a1 + 32);
      unsigned int v390 = 0x7FFFFFFF;
    }
    float v391 = *(float *)(v388 + 80 * v390 + 48);
    unint64_t v392 = *(void *)(a1 + 256);
    double v393 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v396 = NAN;
        goto LABEL_492;
      }
      LODWORD(v394) = info[0].numer;
      LODWORD(v395) = info[0].denom;
      double v393 = (double)v394 / (double)v395;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v393;
    }
    double v396 = v393 * (double)(unint64_t)(float)(v391 / (float)v392);
LABEL_492:
    float v387 = v623 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Audio Update: %.2f    Audio ECS: %.2f\n", v387, v396 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v397 = *(void *)(a1 + 32);
      uint64_t v398 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a1 + 40)));
      unsigned int v399 = 0x7FFFFFFF;
      if (v398 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v397 + 80 * v398 + 12) == 129)
        {
LABEL_497:
          unsigned int v399 = v398;
        }
        else
        {
          while (1)
          {
            LODWORD(v398) = *(_DWORD *)(v397 + 80 * v398 + 8) & 0x7FFFFFFF;
            unsigned int v399 = 0x7FFFFFFF;
            if (v398 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v397 + 80 * v398 + 12) == 129) {
              goto LABEL_497;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v397 = *(void *)(a1 + 32);
      unsigned int v399 = 0x7FFFFFFF;
    }
    float v400 = *(float *)(v397 + 80 * v399 + 48);
    unint64_t v401 = *(void *)(a1 + 256);
    double v402 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        float v405 = v626 / 1000000.0;
        double v406 = NAN;
        goto LABEL_504;
      }
      LODWORD(v403) = info[0].numer;
      LODWORD(v404) = info[0].denom;
      double v402 = (double)v403 / (double)v404;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v402;
    }
    float v405 = v626 / 1000000.0;
    double v406 = v402 * (double)(unint64_t)(float)(v400 / (float)v401);
LABEL_504:
    float v407 = v627 / 1000000.0;
    if (*(void *)(a1 + 16))
    {
      uint64_t v408 = *(void *)(a1 + 32);
      uint64_t v409 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a1 + 40)));
      unsigned int v410 = 0x7FFFFFFF;
      if (v409 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v408 + 80 * v409 + 12) == 128)
        {
LABEL_509:
          unsigned int v410 = v409;
        }
        else
        {
          while (1)
          {
            LODWORD(v409) = *(_DWORD *)(v408 + 80 * v409 + 8) & 0x7FFFFFFF;
            unsigned int v410 = 0x7FFFFFFF;
            if (v409 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int8 *)(v408 + 80 * v409 + 12) == 128) {
              goto LABEL_509;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v408 = *(void *)(a1 + 32);
      unsigned int v410 = 0x7FFFFFFF;
    }
    float v411 = *(float *)(v408 + 80 * v410 + 48);
    unint64_t v412 = *(void *)(a1 + 256);
    double v413 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    double v414 = v406 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v417 = NAN;
        goto LABEL_516;
      }
      LODWORD(v415) = info[0].numer;
      LODWORD(v416) = info[0].denom;
      double v413 = (double)v415 / (double)v416;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v413;
    }
    double v417 = v413 * (double)(unint64_t)(float)(v411 / (float)v412);
LABEL_516:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Asset Update: %.2f    SU ECS: %.2f\n", v407, v414 + v417 / 1000000.0);
    if (*(void *)(a1 + 16))
    {
      uint64_t v418 = *(void *)(a1 + 32);
      uint64_t v419 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x584592B4271786AAuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v420 = 0x7FFFFFFF;
      if (v419 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v418 + 80 * v419 + 12) == 126)
        {
LABEL_521:
          unsigned int v420 = v419;
        }
        else
        {
          while (1)
          {
            LODWORD(v419) = *(_DWORD *)(v418 + 80 * v419 + 8) & 0x7FFFFFFF;
            unsigned int v420 = 0x7FFFFFFF;
            if (v419 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v418 + 80 * v419 + 12) == 126) {
              goto LABEL_521;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v418 = *(void *)(a1 + 32);
      unsigned int v420 = 0x7FFFFFFF;
    }
    float v421 = *(float *)(v418 + 80 * v420 + 48);
    unint64_t v422 = *(void *)(a1 + 256);
    double v423 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v426 = NAN;
        goto LABEL_528;
      }
      LODWORD(v424) = info[0].numer;
      LODWORD(v425) = info[0].denom;
      double v423 = (double)v424 / (double)v425;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v423;
    }
    double v426 = v423 * (double)(unint64_t)(float)(v421 / (float)v422);
LABEL_528:
    if (*(void *)(a1 + 16))
    {
      uint64_t v427 = *(void *)(a1 + 32);
      uint64_t v428 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xA09D66D4686AD125 % *(unsigned int *)(a1 + 40)));
      unsigned int v429 = 0x7FFFFFFF;
      if (v428 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v427 + 80 * v428 + 12) == 127)
        {
LABEL_533:
          unsigned int v429 = v428;
        }
        else
        {
          while (1)
          {
            LODWORD(v428) = *(_DWORD *)(v427 + 80 * v428 + 8) & 0x7FFFFFFF;
            unsigned int v429 = 0x7FFFFFFF;
            if (v428 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v427 + 80 * v428 + 12) == 127) {
              goto LABEL_533;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v427 = *(void *)(a1 + 32);
      unsigned int v429 = 0x7FFFFFFF;
    }
    float v430 = *(float *)(v427 + 80 * v429 + 48);
    unint64_t v431 = *(void *)(a1 + 256);
    double v432 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        double v435 = NAN;
        goto LABEL_540;
      }
      LODWORD(v433) = info[0].numer;
      LODWORD(v434) = info[0].denom;
      double v432 = (double)v433 / (double)v434;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v432;
    }
    double v435 = v432 * (double)(unint64_t)(float)(v430 / (float)v431);
LABEL_540:
    double v436 = v426 / 1000000.0;
    float v438 = v630 / 1000000.0;
    float v439 = v629 / 1000000.0;
    float v440 = v438 + v439;
    float v441 = v628 / 1000000.0;
    float v633 = v623 / 1000000.0;
    float v442 = (float)((float)((float)((float)((float)((float)(v635 - (float)(v440 + v441)) - v367) - v405) - v356) - v407)
                 - v633)
         - v638;
    float v443 = 0.0;
    if (v642 <= 0.0) {
      float v443 = v640;
    }
    float v444 = v442 - v443;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Custom ECS: %.2f    Callback ECS: %.2f\n", v436, v435 / 1000000.0);
    float v437 = v622 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Update Callback: %.2f    Others: %.2f\n", v437, (float)(v444 - v437));
    uint64_t v445 = *(void *)(a1 + 136);
    if (v445)
    {
      *(void *)(a1 + 136) = 1;
      v446 = *(unsigned char **)(a1 + 144);
    }
    else
    {
      *(unsigned char *)(a1 + 136) = v445 & 1;
      v446 = (unsigned char *)(a1 + 137);
    }
    unsigned char *v446 = 0;
    uint64_t v447 = *(void *)(a1 + 168);
    if (v447)
    {
      *(void *)(a1 + 168) = 1;
      v448 = *(unsigned char **)(a1 + 176);
    }
    else
    {
      *(unsigned char *)(a1 + 168) = v447 & 1;
      v448 = (unsigned char *)(a1 + 169);
    }
    unsigned char *v448 = 0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Scene Draw Stats\n");
    if (*(void *)(a1 + 16))
    {
      uint64_t v449 = *(void *)(a1 + 32);
      uint64_t v450 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a1 + 40)));
      if (v450 == 0x7FFFFFFF || *(unsigned char *)(v449 + 80 * v450 + 12) == 34)
      {
        uint64_t v451 = v449 + 80 * v450;
      }
      else
      {
        do
          LODWORD(v450) = *(_DWORD *)(v449 + 80 * v450 + 8) & 0x7FFFFFFF;
        while (v450 != 0x7FFFFFFF && *(unsigned char *)(v449 + 80 * v450 + 12) != 34);
        uint64_t v451 = v449 + 80 * v450;
      }
      float v452 = (float)*(unint64_t *)(a1 + 256);
      float v453 = *(float *)(v451 + 48) / v452;
      uint64_t v455 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a1 + 40)));
      unsigned int v454 = 0x7FFFFFFF;
      if (v455 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v449 + 80 * v455 + 12) == 35)
        {
LABEL_560:
          unsigned int v454 = v455;
        }
        else
        {
          while (1)
          {
            LODWORD(v455) = *(_DWORD *)(v449 + 80 * v455 + 8) & 0x7FFFFFFF;
            unsigned int v454 = 0x7FFFFFFF;
            if (v455 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v449 + 80 * v455 + 12) == 35) {
              goto LABEL_560;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v449 = *(void *)(a1 + 32);
      float v452 = (float)*(unint64_t *)(a1 + 256);
      float v453 = *(float *)(v449 + 0x27FFFFFFE0) / v452;
      unsigned int v454 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Meshes: %.0f    Draw Calls: %.0f\n", v453, (float)(*(float *)(v449 + 80 * v454 + 48) / v452));
    if (*(void *)(a1 + 16))
    {
      uint64_t v456 = *(void *)(a1 + 32);
      uint64_t v457 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xFF96B931ED5510E2 % *(unsigned int *)(a1 + 40)));
      unsigned int v458 = 0x7FFFFFFF;
      if (v457 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v456 + 80 * v457 + 12) == 36)
        {
LABEL_566:
          unsigned int v458 = v457;
        }
        else
        {
          while (1)
          {
            LODWORD(v457) = *(_DWORD *)(v456 + 80 * v457 + 8) & 0x7FFFFFFF;
            unsigned int v458 = 0x7FFFFFFF;
            if (v457 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v456 + 80 * v457 + 12) == 36) {
              goto LABEL_566;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v456 = *(void *)(a1 + 32);
      unsigned int v458 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Triangles Submitted: %.0f\n", (float)(*(float *)(v456 + 80 * v458 + 48) / (float)*(unint64_t *)(a1 + 256)));
    if (*(void *)(a1 + 16))
    {
      uint64_t v459 = *(void *)(a1 + 32);
      uint64_t v460 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x499EF488EF760E18uLL % *(unsigned int *)(a1 + 40)));
      unsigned int v461 = 0x7FFFFFFF;
      if (v460 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v459 + 80 * v460 + 12) == 37)
        {
LABEL_573:
          unsigned int v461 = v460;
        }
        else
        {
          while (1)
          {
            LODWORD(v460) = *(_DWORD *)(v459 + 80 * v460 + 8) & 0x7FFFFFFF;
            unsigned int v461 = 0x7FFFFFFF;
            if (v460 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v459 + 80 * v460 + 12) == 37) {
              goto LABEL_573;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v459 = *(void *)(a1 + 32);
      unsigned int v461 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Vertices Submitted: %.0f\n", (float)(*(float *)(v459 + 80 * v461 + 48) / (float)*(unint64_t *)(a1 + 256)));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Lighting Stats \n");
    if (!*(void *)(a1 + 16))
    {
      uint64_t v463 = *(void *)(a1 + 32);
      float v466 = (float)*(unint64_t *)(a1 + 256);
      float v467 = *(float *)(v463 + 0x27FFFFFFE0) / v466;
      unsigned int v468 = 0x7FFFFFFF;
      goto LABEL_589;
    }
    unint64_t v462 = *(unsigned int *)(a1 + 40);
    uint64_t v464 = *(void *)(a1 + 24);
    uint64_t v463 = *(void *)(a1 + 32);
    uint64_t v465 = *(unsigned int *)(v464 + 4 * (0xD1F31274AB1CEA5ALL % v462));
    if (v465 == 0x7FFFFFFF)
    {
      LODWORD(v465) = 0x7FFFFFFF;
    }
    else if (*(unsigned char *)(v463 + 80 * v465 + 12) != 95)
    {
      do
        LODWORD(v465) = *(_DWORD *)(v463 + 80 * v465 + 8) & 0x7FFFFFFF;
      while (v465 != 0x7FFFFFFF && *(unsigned char *)(v463 + 80 * v465 + 12) != 95);
      uint64_t v469 = v463 + 80 * v465;
LABEL_584:
      float v466 = (float)*(unint64_t *)(a1 + 256);
      float v467 = *(float *)(v469 + 48) / v466;
      uint64_t v470 = *(unsigned int *)(v464 + 4 * (0xB283085A8C486789 % v462));
      unsigned int v468 = 0x7FFFFFFF;
      if (v470 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v463 + 80 * v470 + 12) == 96)
        {
LABEL_588:
          unsigned int v468 = v470;
        }
        else
        {
          while (1)
          {
            LODWORD(v470) = *(_DWORD *)(v463 + 80 * v470 + 8) & 0x7FFFFFFF;
            unsigned int v468 = 0x7FFFFFFF;
            if (v470 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v463 + 80 * v470 + 12) == 96) {
              goto LABEL_588;
            }
          }
        }
      }
LABEL_589:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Total : %.0f (culled %.0f)\n", v467, (float)(*(float *)(v463 + 80 * v468 + 48) / v466));
      if (!*(void *)(a1 + 16))
      {
        uint64_t v472 = *(void *)(a1 + 32);
        float v475 = *(float *)(v472 + 0x27FFFFFFE0);
        float v476 = (float)*(unint64_t *)(a1 + 256);
        float v477 = v475 / v476;
        unsigned int v478 = 0x7FFFFFFF;
        goto LABEL_609;
      }
      unint64_t v471 = *(unsigned int *)(a1 + 40);
      uint64_t v473 = *(void *)(a1 + 24);
      uint64_t v472 = *(void *)(a1 + 32);
      uint64_t v474 = *(unsigned int *)(v473 + 4 * (0xAEFF7D4B5B72EC99 % v471));
      if (v474 == 0x7FFFFFFF)
      {
        LODWORD(v474) = 0x7FFFFFFF;
      }
      else if (*(unsigned char *)(v472 + 80 * v474 + 12) != 97)
      {
        do
          LODWORD(v474) = *(_DWORD *)(v472 + 80 * v474 + 8) & 0x7FFFFFFF;
        while (v474 != 0x7FFFFFFF && *(unsigned char *)(v472 + 80 * v474 + 12) != 97);
        uint64_t v479 = v472 + 80 * v474;
        goto LABEL_598;
      }
      uint64_t v479 = v472 + 80 * v474;
LABEL_598:
      float v476 = (float)*(unint64_t *)(a1 + 256);
      float v477 = *(float *)(v479 + 48) / v476;
      unsigned int v480 = *(_DWORD *)(v473 + 4 * (0x51B6E610EB969D89 % v471));
      unsigned int v478 = 0x7FFFFFFF;
      unsigned int v481 = 0x7FFFFFFF;
      if (v480 != 0x7FFFFFFF)
      {
        unsigned int v481 = *(_DWORD *)(v473 + 4 * (0x51B6E610EB969D89 % v471));
        if (*(unsigned char *)(v472 + 80 * v480 + 12) != 103)
        {
          while (1)
          {
            unsigned int v481 = *(_DWORD *)(v472 + 80 * *(unsigned int *)(v473 + 4 * (0x51B6E610EB969D89 % v471)) + 8) & 0x7FFFFFFF;
            if (v481 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v472 + 80 * v481 + 12) == 103) {
              goto LABEL_604;
            }
          }
          unsigned int v481 = 0x7FFFFFFF;
        }
      }
LABEL_604:
      float v475 = *(float *)(v472 + 80 * v481 + 48);
      uint64_t v482 = *(unsigned int *)(v473 + 4 * (0xFADB7BDC13722E8ELL % v471));
      if (v482 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v472 + 80 * v482 + 12) == 104)
        {
LABEL_608:
          unsigned int v478 = v482;
        }
        else
        {
          while (1)
          {
            LODWORD(v482) = *(_DWORD *)(v472 + 80 * v482 + 8) & 0x7FFFFFFF;
            unsigned int v478 = 0x7FFFFFFF;
            if (v482 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v472 + 80 * v482 + 12) == 104) {
              goto LABEL_608;
            }
          }
        }
      }
LABEL_609:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Ambient : %.0f, Proxy : %.0f (culled %.0f)\n", v477, (float)(v475 / v476), (float)(*(float *)(v472 + 80 * v478 + 48) / v476));
      if (!*(void *)(a1 + 16))
      {
        uint64_t v484 = *(void *)(a1 + 32);
        float v487 = *(float *)(v484 + 0x27FFFFFFE0);
        float v488 = (float)*(unint64_t *)(a1 + 256);
        float v489 = v487 / v488;
        unsigned int v490 = 0x7FFFFFFF;
        goto LABEL_629;
      }
      unint64_t v483 = *(unsigned int *)(a1 + 40);
      uint64_t v485 = *(void *)(a1 + 24);
      uint64_t v484 = *(void *)(a1 + 32);
      uint64_t v486 = *(unsigned int *)(v485 + 4 * (0x79CE5DC97509C089 % v483));
      if (v486 == 0x7FFFFFFF)
      {
        LODWORD(v486) = 0x7FFFFFFF;
      }
      else if (*(unsigned char *)(v484 + 80 * v486 + 12) != 99)
      {
        do
          LODWORD(v486) = *(_DWORD *)(v484 + 80 * v486 + 8) & 0x7FFFFFFF;
        while (v486 != 0x7FFFFFFF && *(unsigned char *)(v484 + 80 * v486 + 12) != 99);
        uint64_t v491 = v484 + 80 * v486;
        goto LABEL_618;
      }
      uint64_t v491 = v484 + 80 * v486;
LABEL_618:
      float v488 = (float)*(unint64_t *)(a1 + 256);
      float v489 = *(float *)(v491 + 48) / v488;
      unsigned int v492 = *(_DWORD *)(v485 + 4 * (0x2731D9FDF756B334 % v483));
      unsigned int v490 = 0x7FFFFFFF;
      unsigned int v493 = 0x7FFFFFFF;
      if (v492 != 0x7FFFFFFF)
      {
        unsigned int v493 = *(_DWORD *)(v485 + 4 * (0x2731D9FDF756B334 % v483));
        if (*(unsigned char *)(v484 + 80 * v492 + 12) != 100)
        {
          while (1)
          {
            unsigned int v493 = *(_DWORD *)(v484 + 80 * *(unsigned int *)(v485 + 4 * (0x2731D9FDF756B334 % v483)) + 8) & 0x7FFFFFFF;
            if (v493 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v484 + 80 * v493 + 12) == 100) {
              goto LABEL_624;
            }
          }
          unsigned int v493 = 0x7FFFFFFF;
        }
      }
LABEL_624:
      float v487 = *(float *)(v484 + 80 * v493 + 48);
      uint64_t v494 = *(unsigned int *)(v485 + 4 * (0xF2F8EDE6FA70BF5FLL % v483));
      if (v494 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v484 + 80 * v494 + 12) == 98)
        {
LABEL_628:
          unsigned int v490 = v494;
        }
        else
        {
          while (1)
          {
            LODWORD(v494) = *(_DWORD *)(v484 + 80 * v494 + 8) & 0x7FFFFFFF;
            unsigned int v490 = 0x7FFFFFFF;
            if (v494 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v484 + 80 * v494 + 12) == 98) {
              goto LABEL_628;
            }
          }
        }
      }
LABEL_629:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Point : %.0f (culled %.0f), Directional : %.0f\n", v489, (float)(v487 / v488), (float)(*(float *)(v484 + 80 * v490 + 48) / v488));
      if (!*(void *)(a1 + 16))
      {
        uint64_t v496 = *(void *)(a1 + 32);
        float v499 = *(float *)(v496 + 0x27FFFFFFE0);
        float v500 = (float)*(unint64_t *)(a1 + 256);
        float v501 = v499 / v500;
        unsigned int v502 = 0x7FFFFFFF;
        goto LABEL_649;
      }
      unint64_t v495 = *(unsigned int *)(a1 + 40);
      uint64_t v497 = *(void *)(a1 + 24);
      uint64_t v496 = *(void *)(a1 + 32);
      uint64_t v498 = *(unsigned int *)(v497 + 4 * (0xA7D485D747130317 % v495));
      if (v498 == 0x7FFFFFFF)
      {
        LODWORD(v498) = 0x7FFFFFFF;
      }
      else if (*(unsigned char *)(v496 + 80 * v498 + 12) != 101)
      {
        do
          LODWORD(v498) = *(_DWORD *)(v496 + 80 * v498 + 8) & 0x7FFFFFFF;
        while (v498 != 0x7FFFFFFF && *(unsigned char *)(v496 + 80 * v498 + 12) != 101);
        uint64_t v503 = v496 + 80 * v498;
        goto LABEL_638;
      }
      uint64_t v503 = v496 + 80 * v498;
LABEL_638:
      float v500 = (float)*(unint64_t *)(a1 + 256);
      float v501 = *(float *)(v503 + 48) / v500;
      unsigned int v504 = *(_DWORD *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495));
      unsigned int v502 = 0x7FFFFFFF;
      unsigned int v505 = 0x7FFFFFFF;
      if (v504 != 0x7FFFFFFF)
      {
        unsigned int v505 = *(_DWORD *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495));
        if (*(unsigned char *)(v496 + 80 * v504 + 12) != 102)
        {
          while (1)
          {
            unsigned int v505 = *(_DWORD *)(v496 + 80 * *(unsigned int *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495)) + 8) & 0x7FFFFFFF;
            if (v505 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v496 + 80 * v505 + 12) == 102) {
              goto LABEL_644;
            }
          }
          unsigned int v505 = 0x7FFFFFFF;
        }
      }
LABEL_644:
      float v499 = *(float *)(v496 + 80 * v505 + 48);
      uint64_t v506 = *(unsigned int *)(v497 + 4 * (0x168B5740BA2991FFLL % v495));
      if (v506 != 0x7FFFFFFF)
      {
        if (*(unsigned char *)(v496 + 80 * v506 + 12) == 105)
        {
LABEL_648:
          unsigned int v502 = v506;
        }
        else
        {
          while (1)
          {
            LODWORD(v506) = *(_DWORD *)(v496 + 80 * v506 + 8) & 0x7FFFFFFF;
            unsigned int v502 = 0x7FFFFFFF;
            if (v506 == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned char *)(v496 + 80 * v506 + 12) == 105) {
              goto LABEL_648;
            }
          }
        }
      }
LABEL_649:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Spot : %.0f (culled %.0f), Area : %.0f\n", v501, (float)(v499 / v500), (float)(*(float *)(v496 + 80 * v502 + 48) / v500));
      if (*(void *)(a1 + 16))
      {
        uint64_t v507 = *(void *)(a1 + 32);
        uint64_t v508 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0x17B1332CD96C043DuLL % *(unsigned int *)(a1 + 40)));
        unsigned int v509 = 0x7FFFFFFF;
        if (v508 != 0x7FFFFFFF)
        {
          if (*(unsigned char *)(v507 + 80 * v508 + 12) == 118)
          {
LABEL_654:
            unsigned int v509 = v508;
          }
          else
          {
            while (1)
            {
              LODWORD(v508) = *(_DWORD *)(v507 + 80 * v508 + 8) & 0x7FFFFFFF;
              unsigned int v509 = 0x7FFFFFFF;
              if (v508 == 0x7FFFFFFF) {
                break;
              }
              if (*(unsigned char *)(v507 + 80 * v508 + 12) == 118) {
                goto LABEL_654;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v507 = *(void *)(a1 + 32);
        unsigned int v509 = 0x7FFFFFFF;
      }
      re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Entities: %.0f\n", (float)(*(float *)(v507 + 80 * v509 + 48) / (float)*(unint64_t *)(a1 + 256)));
      re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Component Counts\n");
      if (!*(void *)(a1 + 16))
      {
        uint64_t v511 = *(void *)(a1 + 32);
        float v514 = (float)*(unint64_t *)(a1 + 256);
        float v515 = *(float *)(v511 + 0x27FFFFFFE0) / v514;
        unsigned int v516 = 0x7FFFFFFF;
        goto LABEL_670;
      }
      unint64_t v510 = *(unsigned int *)(a1 + 40);
      uint64_t v512 = *(void *)(a1 + 24);
      uint64_t v511 = *(void *)(a1 + 32);
      uint64_t v513 = *(unsigned int *)(v512 + 4 * (0x4A1033F1AB1B19DDLL % v510));
      if (v513 == 0x7FFFFFFF)
      {
        LODWORD(v513) = 0x7FFFFFFF;
      }
      else if (*(unsigned char *)(v511 + 80 * v513 + 12) != 94)
      {
        do
          LODWORD(v513) = *(_DWORD *)(v511 + 80 * v513 + 8) & 0x7FFFFFFF;
        while (v513 != 0x7FFFFFFF && *(unsigned char *)(v511 + 80 * v513 + 12) != 94);
        uint64_t v517 = v511 + 80 * v513;
LABEL_665:
        float v514 = (float)*(unint64_t *)(a1 + 256);
        float v515 = *(float *)(v517 + 48) / v514;
        uint64_t v518 = *(unsigned int *)(v512 + 4 * (0x2C81EA329AEABA69 % v510));
        unsigned int v516 = 0x7FFFFFFF;
        if (v518 != 0x7FFFFFFF)
        {
          if (*(unsigned char *)(v511 + 80 * v518 + 12) == 106)
          {
LABEL_669:
            unsigned int v516 = v518;
          }
          else
          {
            while (1)
            {
              LODWORD(v518) = *(_DWORD *)(v511 + 80 * v518 + 8) & 0x7FFFFFFF;
              unsigned int v516 = 0x7FFFFFFF;
              if (v518 == 0x7FFFFFFF) {
                break;
              }
              if (*(unsigned char *)(v511 + 80 * v518 + 12) == 106) {
                goto LABEL_669;
              }
            }
          }
        }
LABEL_670:
        re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Meshes: %.0f, Shadows: %.0f\n", v515, (float)(*(float *)(v511 + 80 * v516 + 48) / v514));
        if (*(void *)(a1 + 16))
        {
          uint64_t v519 = *(void *)(a1 + 32);
          uint64_t v520 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * (0xD1F31274AB1CEA5ALL % *(unsigned int *)(a1 + 40)));
          unsigned int v521 = 0x7FFFFFFF;
          if (v520 != 0x7FFFFFFF)
          {
            if (*(unsigned char *)(v519 + 80 * v520 + 12) == 95)
            {
LABEL_675:
              unsigned int v521 = v520;
            }
            else
            {
              while (1)
              {
                LODWORD(v520) = *(_DWORD *)(v519 + 80 * v520 + 8) & 0x7FFFFFFF;
                unsigned int v521 = 0x7FFFFFFF;
                if (v520 == 0x7FFFFFFF) {
                  break;
                }
                if (*(unsigned char *)(v519 + 80 * v520 + 12) == 95) {
                  goto LABEL_675;
                }
              }
            }
          }
        }
        else
        {
          uint64_t v519 = *(void *)(a1 + 32);
          unsigned int v521 = 0x7FFFFFFF;
        }
        re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Lights: %.0f\n", (float)(*(float *)(v519 + 80 * v521 + 48) / (float)*(unint64_t *)(a1 + 256)));
        if (!*(void *)(a1 + 16))
        {
          uint64_t v523 = *(void *)(a1 + 32);
          float v526 = (float)*(unint64_t *)(a1 + 256);
          float v527 = *(float *)(v523 + 0x27FFFFFFE0) / v526;
          unsigned int v528 = 0x7FFFFFFF;
          goto LABEL_691;
        }
        unint64_t v522 = *(unsigned int *)(a1 + 40);
        uint64_t v524 = *(void *)(a1 + 24);
        uint64_t v523 = *(void *)(a1 + 32);
        uint64_t v525 = *(unsigned int *)(v524 + 4 * (0xD732B4173198B1FLL % v522));
        if (v525 == 0x7FFFFFFF)
        {
          LODWORD(v525) = 0x7FFFFFFF;
        }
        else if (*(unsigned __int8 *)(v523 + 80 * v525 + 12) != 149)
        {
          do
            LODWORD(v525) = *(_DWORD *)(v523 + 80 * v525 + 8) & 0x7FFFFFFF;
          while (v525 != 0x7FFFFFFF && *(unsigned __int8 *)(v523 + 80 * v525 + 12) != 149);
          uint64_t v529 = v523 + 80 * v525;
LABEL_686:
          float v526 = (float)*(unint64_t *)(a1 + 256);
          float v527 = *(float *)(v529 + 48) / v526;
          uint64_t v530 = *(unsigned int *)(v524 + 4 * (0xB3CC71E5DDF6EBC3 % v522));
          unsigned int v528 = 0x7FFFFFFF;
          if (v530 != 0x7FFFFFFF)
          {
            if (*(unsigned __int8 *)(v523 + 80 * v530 + 12) == 151)
            {
LABEL_690:
              unsigned int v528 = v530;
            }
            else
            {
              while (1)
              {
                LODWORD(v530) = *(_DWORD *)(v523 + 80 * v530 + 8) & 0x7FFFFFFF;
                unsigned int v528 = 0x7FFFFFFF;
                if (v530 == 0x7FFFFFFF) {
                  break;
                }
                if (*(unsigned __int8 *)(v523 + 80 * v530 + 12) == 151) {
                  goto LABEL_690;
                }
              }
            }
          }
LABEL_691:
          re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "VFX Scenes: %.0f, VFX Draw Calls: %.0f\n", v527, (float)(*(float *)(v523 + 80 * v528 + 48) / v526));
          if (!*(void *)(a1 + 16))
          {
            uint64_t v532 = *(void *)(a1 + 32);
            float v535 = (float)*(unint64_t *)(a1 + 256);
            float v536 = *(float *)(v532 + 0x27FFFFFFE0) / v535;
            unsigned int v537 = 0x7FFFFFFF;
            goto LABEL_705;
          }
          unint64_t v531 = *(unsigned int *)(a1 + 40);
          uint64_t v533 = *(void *)(a1 + 24);
          uint64_t v532 = *(void *)(a1 + 32);
          uint64_t v534 = *(unsigned int *)(v533 + 4 * (0x2427CEE8D2E4A800 % v531));
          if (v534 == 0x7FFFFFFF)
          {
            LODWORD(v534) = 0x7FFFFFFF;
          }
          else if (*(unsigned __int8 *)(v532 + 80 * v534 + 12) != 143)
          {
            do
              LODWORD(v534) = *(_DWORD *)(v532 + 80 * v534 + 8) & 0x7FFFFFFF;
            while (v534 != 0x7FFFFFFF && *(unsigned __int8 *)(v532 + 80 * v534 + 12) != 143);
            uint64_t v538 = v532 + 80 * v534;
LABEL_700:
            float v535 = (float)*(unint64_t *)(a1 + 256);
            float v536 = *(float *)(v538 + 48) / v535;
            uint64_t v539 = *(unsigned int *)(v533 + 4 * (0xA630657CB8C7F164 % v531));
            unsigned int v537 = 0x7FFFFFFF;
            if (v539 != 0x7FFFFFFF)
            {
              if (*(unsigned char *)(v532 + 80 * v539 + 12) == 48)
              {
LABEL_704:
                unsigned int v537 = v539;
              }
              else
              {
                while (1)
                {
                  LODWORD(v539) = *(_DWORD *)(v532 + 80 * v539 + 8) & 0x7FFFFFFF;
                  unsigned int v537 = 0x7FFFFFFF;
                  if (v539 == 0x7FFFFFFF) {
                    break;
                  }
                  if (*(unsigned char *)(v532 + 80 * v539 + 12) == 48) {
                    goto LABEL_704;
                  }
                }
              }
            }
LABEL_705:
            re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "AudioPlayers: %.0f, Network: %.0f\n", v536, (float)(*(float *)(v532 + 80 * v537 + 48) / v535));
            if (!*(void *)(a1 + 16))
            {
              uint64_t v541 = *(void *)(a1 + 32);
              float v544 = (float)*(unint64_t *)(a1 + 256);
              float v545 = *(float *)(v541 + 0x27FFFFFFE0) / v544;
              unsigned int v546 = 0x7FFFFFFF;
              goto LABEL_719;
            }
            unint64_t v540 = *(unsigned int *)(a1 + 40);
            uint64_t v542 = *(void *)(a1 + 24);
            uint64_t v541 = *(void *)(a1 + 32);
            uint64_t v543 = *(unsigned int *)(v542 + 4 * (0xCF4A7B3C48D45C4FLL % v540));
            if (v543 == 0x7FFFFFFF)
            {
              LODWORD(v543) = 0x7FFFFFFF;
            }
            else if (*(unsigned char *)(v541 + 80 * v543 + 12) != 66)
            {
              do
                LODWORD(v543) = *(_DWORD *)(v541 + 80 * v543 + 8) & 0x7FFFFFFF;
              while (v543 != 0x7FFFFFFF && *(unsigned char *)(v541 + 80 * v543 + 12) != 66);
              uint64_t v547 = v541 + 80 * v543;
LABEL_714:
              float v544 = (float)*(unint64_t *)(a1 + 256);
              float v545 = *(float *)(v547 + 48) / v544;
              uint64_t v548 = *(unsigned int *)(v542 + 4 * (0xA46B02245B9F3AF4 % v540));
              unsigned int v546 = 0x7FFFFFFF;
              if (v548 != 0x7FFFFFFF)
              {
                if (*(unsigned char *)(v541 + 80 * v548 + 12) == 67)
                {
LABEL_718:
                  unsigned int v546 = v548;
                }
                else
                {
                  while (1)
                  {
                    LODWORD(v548) = *(_DWORD *)(v541 + 80 * v548 + 8) & 0x7FFFFFFF;
                    unsigned int v546 = 0x7FFFFFFF;
                    if (v548 == 0x7FFFFFFF) {
                      break;
                    }
                    if (*(unsigned char *)(v541 + 80 * v548 + 12) == 67) {
                      goto LABEL_718;
                    }
                  }
                }
              }
LABEL_719:
              re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "RigidBodies: %.0f    Active: %.0f\n", v545, (float)(*(float *)(v541 + 80 * v546 + 48) / v544));
              if (!*(void *)(a1 + 16))
              {
                uint64_t v550 = *(void *)(a1 + 32);
                float v553 = (float)*(unint64_t *)(a1 + 256);
                float v554 = *(float *)(v550 + 0x27FFFFFFE0) / v553;
                unsigned int v555 = 0x7FFFFFFF;
                goto LABEL_733;
              }
              unint64_t v549 = *(unsigned int *)(a1 + 40);
              uint64_t v551 = *(void *)(a1 + 24);
              uint64_t v550 = *(void *)(a1 + 32);
              uint64_t v552 = *(unsigned int *)(v551 + 4 * (0x21C2DD3F1FDB3325 % v549));
              if (v552 == 0x7FFFFFFF)
              {
                LODWORD(v552) = 0x7FFFFFFF;
              }
              else if (*(unsigned char *)(v550 + 80 * v552 + 12) != 68)
              {
                do
                  LODWORD(v552) = *(_DWORD *)(v550 + 80 * v552 + 8) & 0x7FFFFFFF;
                while (v552 != 0x7FFFFFFF && *(unsigned char *)(v550 + 80 * v552 + 12) != 68);
                uint64_t v556 = v550 + 80 * v552;
LABEL_728:
                float v553 = (float)*(unint64_t *)(a1 + 256);
                float v554 = *(float *)(v556 + 48) / v553;
                uint64_t v557 = *(unsigned int *)(v551 + 4 * (0x41956A36DBC51080 % v549));
                unsigned int v555 = 0x7FFFFFFF;
                if (v557 != 0x7FFFFFFF)
                {
                  if (*(unsigned char *)(v550 + 80 * v557 + 12) == 69)
                  {
LABEL_732:
                    unsigned int v555 = v557;
                  }
                  else
                  {
                    while (1)
                    {
                      LODWORD(v557) = *(_DWORD *)(v550 + 80 * v557 + 8) & 0x7FFFFFFF;
                      unsigned int v555 = 0x7FFFFFFF;
                      if (v557 == 0x7FFFFFFF) {
                        break;
                      }
                      if (*(unsigned char *)(v550 + 80 * v557 + 12) == 69) {
                        goto LABEL_732;
                      }
                    }
                  }
                }
LABEL_733:
                re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Colliders: %.0f    Contacts: %.0f\n", v554, (float)(*(float *)(v550 + 80 * v555 + 48) / v553));
                if (!*(void *)(a1 + 16))
                {
                  uint64_t v559 = *(void *)(a1 + 32);
                  float v562 = (float)*(unint64_t *)(a1 + 256);
                  float v563 = *(float *)(v559 + 0x27FFFFFFE0) / v562;
                  unsigned int v564 = 0x7FFFFFFF;
                  goto LABEL_745;
                }
                unint64_t v558 = *(unsigned int *)(a1 + 40);
                uint64_t v560 = *(void *)(a1 + 24);
                uint64_t v559 = *(void *)(a1 + 32);
                uint64_t v561 = *(unsigned int *)(v560 + 4 * (0xCA4B25A23588FF96 % v558));
                if (v561 != 0x7FFFFFFF)
                {
                  if (*(unsigned char *)(v559 + 80 * v561 + 12) == 110)
                  {
LABEL_740:
                    float v562 = (float)*(unint64_t *)(a1 + 256);
                    float v563 = *(float *)(v559 + 80 * v561 + 48) / v562;
                    uint64_t v565 = *(unsigned int *)(v560 + 4 * (0xF2BAED4A618B76B9 % v558));
                    unsigned int v564 = 0x7FFFFFFF;
                    if (v565 != 0x7FFFFFFF)
                    {
                      if (*(unsigned char *)(v559 + 80 * v565 + 12) == 108)
                      {
LABEL_744:
                        unsigned int v564 = v565;
                      }
                      else
                      {
                        while (1)
                        {
                          LODWORD(v565) = *(_DWORD *)(v559 + 80 * v565 + 8) & 0x7FFFFFFF;
                          unsigned int v564 = 0x7FFFFFFF;
                          if (v565 == 0x7FFFFFFF) {
                            break;
                          }
                          if (*(unsigned char *)(v559 + 80 * v565 + 12) == 108) {
                            goto LABEL_744;
                          }
                        }
                      }
                    }
LABEL_745:
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "MeshDeformations: %.0f, SkeletalPoses: %.0f\n", v563, (float)(*(float *)(v559 + 80 * v564 + 48) / v562));
                    if (*(void *)(a1 + 16))
                    {
                      unint64_t v566 = *(unsigned int *)(a1 + 40);
                      uint64_t v568 = *(void *)(a1 + 24);
                      uint64_t v567 = *(void *)(a1 + 32);
                      unsigned int v569 = *(_DWORD *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566));
                      unsigned int v570 = 0x7FFFFFFF;
                      unsigned int v571 = 0x7FFFFFFF;
                      if (v569 != 0x7FFFFFFF)
                      {
                        unsigned int v571 = *(_DWORD *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566));
                        if (*(unsigned char *)(v567 + 80 * v569 + 12) != 116)
                        {
                          while (1)
                          {
                            unsigned int v571 = *(_DWORD *)(v567
                                             + 80 * *(unsigned int *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566))
                                             + 8) & 0x7FFFFFFF;
                            if (v571 == 0x7FFFFFFF) {
                              break;
                            }
                            if (*(unsigned char *)(v567 + 80 * v571 + 12) == 116) {
                              goto LABEL_753;
                            }
                          }
                          unsigned int v571 = 0x7FFFFFFF;
                        }
                      }
LABEL_753:
                      float v572 = *(float *)(v567 + 80 * v571 + 48);
                      unint64_t v573 = *(void *)(a1 + 256);
                      uint64_t v574 = *(unsigned int *)(v568 + 4 * (0xEF08A61A384AADEELL % v566));
                      if (v574 != 0x7FFFFFFF)
                      {
                        if (*(unsigned char *)(v567 + 80 * v574 + 12) == 117)
                        {
LABEL_757:
                          unsigned int v570 = v574;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v574) = *(_DWORD *)(v567 + 80 * v574 + 8) & 0x7FFFFFFF;
                            unsigned int v570 = 0x7FFFFFFF;
                            if (v574 == 0x7FFFFFFF) {
                              break;
                            }
                            if (*(unsigned char *)(v567 + 80 * v574 + 12) == 117) {
                              goto LABEL_757;
                            }
                          }
                        }
                      }
                    }
                    else
                    {
                      uint64_t v567 = *(void *)(a1 + 32);
                      float v572 = *(float *)(v567 + 0x27FFFFFFE0);
                      unint64_t v573 = *(void *)(a1 + 256);
                      unsigned int v570 = 0x7FFFFFFF;
                    }
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "ActiveDeformations: %.0f, Joints: %.0f\n", (float)(v572 / (float)v573), (float)(*(float *)(v567 + 80 * v570 + 48) / (float)v573));
                    info[0].numer = 93;
                    task_info(*MEMORY[0x263EF8960], 0x16u, re::ProfilerDetailedHUDProcessor::setMemoryPowerStatisticsData(void)::vmInfo, (mach_msg_type_number_t *)info);
                    uint64_t v575 = *(void *)(a1 + 200);
                    if (v575)
                    {
                      *(void *)(a1 + 200) = 1;
                      v576 = *(unsigned char **)(a1 + 208);
                    }
                    else
                    {
                      *(unsigned char *)(a1 + 200) = v575 & 1;
                      v576 = (unsigned char *)(a1 + 201);
                    }
                    unsigned char *v576 = 0;
                    re::DynamicString::append((re::DynamicString *)(a1 + 192), "System Memory and Thermal Info\n", 0x1FuLL);
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Engine Dirty Memory : %.2f\n", (float)((float)((float)(unint64_t)qword_26879B78C * 0.00097656) * 0.00097656));
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Engine Peak Dirty Memory : %.2f\n", (float)((float)((float)qword_26879B7A4 * 0.00097656) * 0.00097656));
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Process Memory Limit : %.2f\n", (float)((float)((float)*(unint64_t *)(a1 + 272) * 0.00097656) * 0.00097656));
                    v577 = [MEMORY[0x263F08AB0] processInfo];
                    unint64_t v578 = [v577 thermalState];

                    if (v578 > 2) {
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Thermal State: Critical\n");
                    }
                    else {
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 192), off_264BE82C8[v578]);
                    }
                    uint64_t v579 = *(void *)(a1 + 232);
                    if (v579)
                    {
                      *(void *)(a1 + 232) = 1;
                      v580 = *(unsigned char **)(a1 + 240);
                    }
                    else
                    {
                      *(unsigned char *)(a1 + 232) = v579 & 1;
                      v580 = (unsigned char *)(a1 + 233);
                    }
                    unsigned char *v580 = 0;
                    re::DynamicString::append((re::DynamicString *)(a1 + 224), "Network Session Stats\n", 0x16uLL);
                    re::DynamicString::append((re::DynamicString *)(a1 + 224), "Sent/Recevived\n", 0xFuLL);
                    uint64_t v581 = *(void *)(a1 + 16);
                    if (v581)
                    {
                      uint64_t v582 = *(void *)(a1 + 32);
                      uint64_t v583 = *(unsigned int *)(*(void *)(a1 + 24)
                                             + 4 * (0xB74FD707F0B39325 % *(unsigned int *)(a1 + 40)));
                      unsigned int v584 = 0x7FFFFFFF;
                      if (v583 != 0x7FFFFFFF)
                      {
                        if (*(unsigned char *)(v582 + 80 * v583 + 12) == 40)
                        {
LABEL_772:
                          unsigned int v584 = v583;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v583) = *(_DWORD *)(v582 + 80 * v583 + 8) & 0x7FFFFFFF;
                            unsigned int v584 = 0x7FFFFFFF;
                            if (v583 == 0x7FFFFFFF) {
                              break;
                            }
                            if (*(unsigned char *)(v582 + 80 * v583 + 12) == 40) {
                              goto LABEL_772;
                            }
                          }
                        }
                      }
                    }
                    else
                    {
                      uint64_t v582 = *(void *)(a1 + 32);
                      unsigned int v584 = 0x7FFFFFFF;
                    }
                    float v585 = (float)*(unint64_t *)(a1 + 256);
                    double v586 = (float)(*(float *)(v582 + 80 * v584 + 48) / v585) * 0.0009765625;
                    unsigned int v587 = 0x7FFFFFFF;
                    if (v581)
                    {
                      unsigned int v588 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)));
                      if (v588 != 0x7FFFFFFF)
                      {
                        unsigned int v587 = *(_DWORD *)(*(void *)(a1 + 24)
                                         + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)));
                        if (*(unsigned char *)(v582 + 80 * v588 + 12) != 41)
                        {
                          while (1)
                          {
                            unsigned int v587 = *(_DWORD *)(v582
                                             + 80
                                             * *(unsigned int *)(*(void *)(a1 + 24)
                                                               + 4
                                                               * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)))
                                             + 8) & 0x7FFFFFFF;
                            if (v587 == 0x7FFFFFFF) {
                              break;
                            }
                            if (*(unsigned char *)(v582 + 80 * v587 + 12) == 41) {
                              goto LABEL_781;
                            }
                          }
                          unsigned int v587 = 0x7FFFFFFF;
                        }
                      }
                    }
LABEL_781:
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Bytes [KB]: %.2f/%.2f\n", v586, (float)(*(float *)(v582 + 80 * v587 + 48) / v585) * 0.0009765625);
                    if (!*(void *)(a1 + 16))
                    {
                      uint64_t v590 = *(void *)(a1 + 32);
                      float v593 = (float)*(unint64_t *)(a1 + 256);
                      float v594 = *(float *)(v590 + 0x27FFFFFFE0) / v593;
                      unsigned int v595 = 0x7FFFFFFF;
                      goto LABEL_795;
                    }
                    unint64_t v589 = *(unsigned int *)(a1 + 40);
                    uint64_t v591 = *(void *)(a1 + 24);
                    uint64_t v590 = *(void *)(a1 + 32);
                    uint64_t v592 = *(unsigned int *)(v591 + 4 * (0xA759EA27D4727622 % v589));
                    if (v592 == 0x7FFFFFFF)
                    {
                      LODWORD(v592) = 0x7FFFFFFF;
                    }
                    else if (*(unsigned char *)(v590 + 80 * v592 + 12) != 42)
                    {
                      do
                        LODWORD(v592) = *(_DWORD *)(v590 + 80 * v592 + 8) & 0x7FFFFFFF;
                      while (v592 != 0x7FFFFFFF && *(unsigned char *)(v590 + 80 * v592 + 12) != 42);
                      uint64_t v596 = v590 + 80 * v592;
LABEL_790:
                      float v593 = (float)*(unint64_t *)(a1 + 256);
                      float v594 = *(float *)(v596 + 48) / v593;
                      uint64_t v597 = *(unsigned int *)(v591 + 4 * (0x4F0A61D9C798D8CALL % v589));
                      unsigned int v595 = 0x7FFFFFFF;
                      if (v597 != 0x7FFFFFFF)
                      {
                        if (*(unsigned char *)(v590 + 80 * v597 + 12) == 43)
                        {
LABEL_794:
                          unsigned int v595 = v597;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v597) = *(_DWORD *)(v590 + 80 * v597 + 8) & 0x7FFFFFFF;
                            unsigned int v595 = 0x7FFFFFFF;
                            if (v597 == 0x7FFFFFFF) {
                              break;
                            }
                            if (*(unsigned char *)(v590 + 80 * v597 + 12) == 43) {
                              goto LABEL_794;
                            }
                          }
                        }
                      }
LABEL_795:
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Packets: %.0f/%.0f\n", v594, (float)(*(float *)(v590 + 80 * v595 + 48) / v593));
                      if (!*(void *)(a1 + 16))
                      {
                        uint64_t v599 = *(void *)(a1 + 32);
                        float v602 = (float)*(unint64_t *)(a1 + 256);
                        float v603 = *(float *)(v599 + 0x27FFFFFFE0) / v602;
                        unsigned int v604 = 0x7FFFFFFF;
LABEL_807:
                        re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Components: %.0f/%.0f\n", v603, (float)(*(float *)(v599 + 80 * v604 + 48) / v602));
                        if (*(void *)(a1 + 16))
                        {
                          unint64_t v606 = *(unsigned int *)(a1 + 40);
                          uint64_t v608 = *(void *)(a1 + 24);
                          uint64_t v607 = *(void *)(a1 + 32);
                          unsigned int v609 = *(_DWORD *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606));
                          unsigned int v610 = 0x7FFFFFFF;
                          unsigned int v611 = 0x7FFFFFFF;
                          if (v609 != 0x7FFFFFFF)
                          {
                            unsigned int v611 = *(_DWORD *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606));
                            if (*(unsigned char *)(v607 + 80 * v609 + 12) != 46)
                            {
                              while (1)
                              {
                                unsigned int v611 = *(_DWORD *)(v607
                                                 + 80 * *(unsigned int *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606))
                                                 + 8) & 0x7FFFFFFF;
                                if (v611 == 0x7FFFFFFF) {
                                  break;
                                }
                                if (*(unsigned char *)(v607 + 80 * v611 + 12) == 46) {
                                  goto LABEL_815;
                                }
                              }
                              unsigned int v611 = 0x7FFFFFFF;
                            }
                          }
LABEL_815:
                          float v612 = *(float *)(v607 + 80 * v611 + 48);
                          unint64_t v613 = *(void *)(a1 + 256);
                          uint64_t v614 = *(unsigned int *)(v608 + 4 * (0x5A9FF51BA33ADC1CLL % v606));
                          if (v614 != 0x7FFFFFFF)
                          {
                            if (*(unsigned char *)(v607 + 80 * v614 + 12) == 47)
                            {
LABEL_819:
                              unsigned int v610 = v614;
                            }
                            else
                            {
                              while (1)
                              {
                                LODWORD(v614) = *(_DWORD *)(v607 + 80 * v614 + 8) & 0x7FFFFFFF;
                                unsigned int v610 = 0x7FFFFFFF;
                                if (v614 == 0x7FFFFFFF) {
                                  break;
                                }
                                if (*(unsigned char *)(v607 + 80 * v614 + 12) == 47) {
                                  goto LABEL_819;
                                }
                              }
                            }
                          }
                        }
                        else
                        {
                          uint64_t v607 = *(void *)(a1 + 32);
                          float v612 = *(float *)(v607 + 0x27FFFFFFE0);
                          unint64_t v613 = *(void *)(a1 + 256);
                          unsigned int v610 = 0x7FFFFFFF;
                        }
                        re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Entities: %.0f/%.0f\n", (float)(v612 / (float)v613), (float)(*(float *)(v607 + 80 * v610 + 48) / (float)v613));
                        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
                        return;
                      }
                      unint64_t v598 = *(unsigned int *)(a1 + 40);
                      uint64_t v600 = *(void *)(a1 + 24);
                      uint64_t v599 = *(void *)(a1 + 32);
                      uint64_t v601 = *(unsigned int *)(v600 + 4 * (0xFB2BF4996809BAF7 % v598));
                      if (v601 != 0x7FFFFFFF)
                      {
                        if (*(unsigned char *)(v599 + 80 * v601 + 12) == 44)
                        {
LABEL_802:
                          float v602 = (float)*(unint64_t *)(a1 + 256);
                          float v603 = *(float *)(v599 + 80 * v601 + 48) / v602;
                          uint64_t v605 = *(unsigned int *)(v600 + 4 * (0xBDBFB556329AEE83 % v598));
                          unsigned int v604 = 0x7FFFFFFF;
                          if (v605 != 0x7FFFFFFF)
                          {
                            if (*(unsigned char *)(v599 + 80 * v605 + 12) == 45)
                            {
LABEL_806:
                              unsigned int v604 = v605;
                            }
                            else
                            {
                              while (1)
                              {
                                LODWORD(v605) = *(_DWORD *)(v599 + 80 * v605 + 8) & 0x7FFFFFFF;
                                unsigned int v604 = 0x7FFFFFFF;
                                if (v605 == 0x7FFFFFFF) {
                                  break;
                                }
                                if (*(unsigned char *)(v599 + 80 * v605 + 12) == 45) {
                                  goto LABEL_806;
                                }
                              }
                            }
                          }
                          goto LABEL_807;
                        }
                        while (1)
                        {
                          LODWORD(v601) = *(_DWORD *)(v599 + 80 * v601 + 8) & 0x7FFFFFFF;
                          if (v601 == 0x7FFFFFFF) {
                            break;
                          }
                          if (*(unsigned char *)(v599 + 80 * v601 + 12) == 44) {
                            goto LABEL_802;
                          }
                        }
                      }
                      LODWORD(v601) = 0x7FFFFFFF;
                      goto LABEL_802;
                    }
                    uint64_t v596 = v590 + 80 * v592;
                    goto LABEL_790;
                  }
                  while (1)
                  {
                    LODWORD(v561) = *(_DWORD *)(v559 + 80 * v561 + 8) & 0x7FFFFFFF;
                    if (v561 == 0x7FFFFFFF) {
                      break;
                    }
                    if (*(unsigned char *)(v559 + 80 * v561 + 12) == 110) {
                      goto LABEL_740;
                    }
                  }
                }
                LODWORD(v561) = 0x7FFFFFFF;
                goto LABEL_740;
              }
              uint64_t v556 = v550 + 80 * v552;
              goto LABEL_728;
            }
            uint64_t v547 = v541 + 80 * v543;
            goto LABEL_714;
          }
          uint64_t v538 = v532 + 80 * v534;
          goto LABEL_700;
        }
        uint64_t v529 = v523 + 80 * v525;
        goto LABEL_686;
      }
      uint64_t v517 = v511 + 80 * v513;
      goto LABEL_665;
    }
    uint64_t v469 = v463 + 80 * v465;
    goto LABEL_584;
  }
}

void re::ProfilerDetailedHUDProcessor::~ProfilerDetailedHUDProcessor(re::ProfilerDetailedHUDProcessor *this)
{
  *(void *)this = &unk_26E717C68;
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 224));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 192));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 160));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 128));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 96));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 64));
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E717C68;
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 224));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 192));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 160));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 128));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 96));
  re::DynamicString::deinit((re::ProfilerDetailedHUDProcessor *)((char *)this + 64));
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 2);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ProfilerDetailedHUDProcessor::willNeedEvents(re::ProfilerDetailedHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerDetailedHUDProcessor::willNeedStatistics(re::ProfilerDetailedHUDProcessor *this)
{
  return 1;
}

uint64_t re::ProfilerDetailedHUDProcessor::willNeedAttributions(re::ProfilerDetailedHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerDetailedHUDProcessor::willNeedMemoryStatistics(re::ProfilerDetailedHUDProcessor *this)
{
  return 0;
}

void re::RenderGraphCallbackNode::setup(re::RenderGraphNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  *((unsigned char *)a2 + 593) = 1;
  re::RenderGraphNode::setup(this, a2, a3);
}

void re::RenderGraphCallbackNode::execute(re::RenderGraphCallbackNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = *((void *)a2 + 146);
  unint64_t v5 = (unint64_t)"N2re32CustomPostProcessRenderGraphDataE";
  if (((unint64_t)"N2re32CustomPostProcessRenderGraphDataE" & 0x8000000000000000) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)((unint64_t)"N2re32CustomPostProcessRenderGraphDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  location[0] = (id)((*(void *)(*((void *)a2 + 5) + 48) + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5);
  float v9 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v4 + 16, (uint64_t *)location);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (*v9)
    {
      if (*(void *)(v10 + 8))
      {
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        *(_OWORD *)location = 0u;
        *(_OWORD *)uint64_t v27 = 0u;
        id v28 = 0;
        re::ObjCObject::operator=(location, (id *)(*((void *)a2 + 1) + 184));
        id v11 = objc_msgSend(location[0], sel_newEvent);
        objc_msgSend(v11, sel_setLabel_, @"CustomPostEvent");
        id v12 = objc_retain(*(id *)(re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1)
                                                                                                  + 104))
                                + 16));
        [v12 encodeSignalEvent:v11 value:1];
        uint64_t QueuedCommandBuffer = re::DrawingManager::createQueuedCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
        objc_storeStrong(&location[1], *(id *)(QueuedCommandBuffer + 16));
        unint64_t v14 = @"CustomPostCommandBufferSplit";
        [location[1] setLabel:@"CustomPostCommandBufferSplit"];

        [location[1] encodeWaitForEvent:v11 value:1];
        uint64_t v15 = (*(uint64_t (**)(re::RenderGraphCallbackNode *))(*(void *)this + 72))(this);
        if (v16)
        {
          re::RenderGraphContext::metalTexture((uint64_t)a2, v15, 0, 0, &v25);
          NS::SharedPtr<MTL::Texture>::operator=(&v28, &v25);
          if (v25) {

          }
          uint64_t v17 = (*(uint64_t (**)(re::RenderGraphCallbackNode *))(*(void *)this + 64))(this);
          if (v18)
          {
            re::RenderGraphContext::metalTexture((uint64_t)a2, v17, 0, 0, &v25);
            NS::SharedPtr<MTL::Texture>::operator=(v27, &v25);
            if (v25) {

            }
            uint64_t v19 = (*(uint64_t (**)(re::RenderGraphCallbackNode *))(*(void *)this + 64))(this);
            if (v20 > 1)
            {
              re::RenderGraphContext::metalTexture((uint64_t)a2, v19 + 32, 0, 0, &v25);
              NS::SharedPtr<MTL::Texture>::operator=(&v27[1], &v25);
              if (v25) {

              }
              long long v21 = *(_OWORD *)(v10 + 80);
              long long v30 = *(_OWORD *)(v10 + 64);
              long long v31 = v21;
              long long v22 = *(_OWORD *)(v10 + 112);
              long long v32 = *(_OWORD *)(v10 + 96);
              long long v33 = v22;
              int v29 = *(_DWORD *)(*(void *)a2 + 8);
              uint64_t v23 = (void (**)(id, id *))*(id *)(v10 + 8);
              v23[2](v23, location);
              if (![location[1] status])
              {
                [location[1] encodeSignalEvent:v11 value:2];
                [location[1] encodeWaitForEvent:v11 value:2];

                if (v11) {
                if (v28)
                }
                {

                  id v28 = 0;
                }
                if (v27[1])
                {

                  v27[1] = 0;
                }
                if (v27[0])
                {

                  v27[0] = 0;
                }

                return;
              }
LABEL_30:
              re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) User enqueued/committed custom post processing command buffer.", "0", "execute", 79);
              _os_crash();
              __break(1u);
              return;
            }
LABEL_29:
            re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 1, v20);
            _os_crash();
            __break(1u);
            goto LABEL_30;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, 0, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        goto LABEL_29;
      }
    }
  }
}

void re::RenderGraphCallbackNode::~RenderGraphCallbackNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void *re::allocInfo_RenderGraphDummyNigiriNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_434, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_434))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99870, "RenderGraphDummyNigiriNode");
    __cxa_guard_release(&_MergedGlobals_434);
  }
  return &unk_26AF99870;
}

void re::initInfo_RenderGraphDummyNigiriNode(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0xD15AF44980978ACCLL;
  v9[1] = "RenderGraphDummyNigiriNode";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99868, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99868);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99860 = v7;
      __cxa_guard_release(&qword_26AF99868);
    }
  }
  *((void *)this + 2) = 0x10000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF99860;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDummyNigiriNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDummyNigiriNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDummyNigiriNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDummyNigiriNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

re::RenderGraphNode *re::internal::defaultConstruct<re::RenderGraphDummyNigiriNode>(int a1, int a2, re::RenderGraphNode *this)
{
  float result = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)float result = &unk_26E6C60E8;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphDummyNigiriNode>(int a1, int a2, id *this)
{
}

re::RenderGraphNode *re::internal::defaultConstructV2<re::RenderGraphDummyNigiriNode>(re::RenderGraphNode *a1)
{
  float result = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)float result = &unk_26E6C60E8;
  return result;
}

uint64_t re::introspect_RenderGraphDummyNigiriNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDummyNigiriNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDummyNigiriNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDummyNigiriNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDummyNigiriNode>, this);
}

re::RenderGraphNode *re::RenderGraphNode::RenderGraphNode(re::RenderGraphNode *this)
{
  *(void *)this = &unk_26E6C6978;
  re::StringID::invalid((re::RenderGraphNode *)((char *)this + 8));
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 16) = 1;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(void *)this = &unk_26E71A5C8;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  return this;
}

void re::encodeFullscreenDrawCall(re::DrawCall *a1, uint64_t a2, re::RenderGraphContext *a3, uint64_t a4, int a5, char *a6, char a7)
{
  if (a5)
  {
    uint64_t v14 = re::RenderGraphDataStore::tryGet<re::TintContextData>(*((void *)a3 + 146), *(void *)(*((void *)a3 + 5) + 48));
    if (v14)
    {
      uint64_t v15 = (_DWORD *)v14;
      uint64_t v16 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a3 + 1) + 104));
      re::RenderGraphContext::acquireManagedRenderEncoder(v59, a3, v16, 0);
      uint64_t v17 = *(void **)v59;
      LODWORD(v18) = v15[4];
      LODWORD(v19) = v15[5];
      LODWORD(v20) = v15[6];
      LODWORD(v21) = v15[7];
    }
    else
    {
      uint64_t v22 = re::RenderGraphDataStore::tryGet<re::CameraData>(*((void *)a3 + 146), *(void *)(*((void *)a3 + 5) + 48));
      if (!v22) {
        goto LABEL_7;
      }
      uint64_t v23 = (_DWORD *)v22;
      uint64_t v24 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a3 + 1) + 104));
      re::RenderGraphContext::acquireManagedRenderEncoder(v59, a3, v24, 0);
      uint64_t v17 = *(void **)v59;
      LODWORD(v18) = v23[104];
      LODWORD(v19) = v23[105];
      LODWORD(v20) = v23[106];
      LODWORD(v21) = v23[107];
    }
    objc_msgSend(v17, sel_setBlendColorRed_green_blue_alpha_, v18, v19, v20, v21);
    re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)v59);
  }
LABEL_7:
  re::DrawCallRef::DrawCallRef(&v66, a1);
  uint64_t v25 = re::RenderGraphDataStore::tryGet<re::CameraMatrices>(*((void *)a3 + 146), *(void *)(*((void *)a3 + 5) + 48));
  if (v25)
  {
    uint64_t v26 = v25;
    *((_DWORD *)a1 + 9) = *(unsigned __int8 *)(v25 + 128);
    *(int64x2_t *)&v59[8] = vdupq_n_s64(1uLL);
    *(void *)uint64_t v59 = &v66;
    *(void *)&v59[24] = &v67;
    long long v60 = *(_OWORD *)&v59[8];
    *(_OWORD *)&v61[8] = *(_OWORD *)&v59[8];
    *(void *)float v61 = &v68;
    unint64_t v62 = &v69;
    long long v63 = *(_OWORD *)&v59[8];
    unint64_t v64 = &v70;
    long long v65 = *(_OWORD *)&v59[8];
    memset(v71, 0, sizeof(v71));
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(a3, (uint64_t *)v71);
    uint64_t v72 = 0;
    uint64_t v45 = a2;
    unint64_t v46 = v59;
    uint64_t v27 = *(void *)(v26 + 80);
    uint64_t v47 = *(void *)(v26 + 40);
    uint64_t v48 = v27;
    uint64_t v49 = 0;
    char v50 = *(unsigned char *)(v26 + 128);
    __int16 v51 = 0;
    char v52 = 0;
    char v53 = *a6;
    if (v53)
    {
      long long v54 = *(_OWORD *)(a6 + 1);
      char v55 = a6[17];
    }
    memset(v56, 0, sizeof(v56));
    uint64_t v57 = a4;
    char v58 = 0;
    re::RenderGraphContext::encodeDrawCalls(a3, v71, &v45);
LABEL_11:
    if (a5)
    {
      uint64_t v28 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a3 + 1) + 104));
      re::RenderGraphContext::acquireManagedRenderEncoder(v59, a3, v28, 0);
      objc_msgSend(*(id *)v59, sel_setBlendColorRed_green_blue_alpha_, 0.0, 0.0, 0.0, 0.0);
      re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)v59);
    }
    return;
  }
  uint64_t v29 = re::RenderGraphDataStore::tryGet<re::CameraData>(*((void *)a3 + 146), *(void *)(*((void *)a3 + 5) + 48));
  uint64_t v44 = 0;
  uint64_t v41 = 0;
  memset(v42, 0, sizeof(v42));
  int v43 = 0;
  memset(v39, 0, sizeof(v39));
  int v40 = 0;
  if (!v29)
  {
    *(_OWORD *)uint64_t v59 = xmmword_23435FD50;
    *(_OWORD *)&v59[16] = xmmword_23435FD60;
    long long v60 = xmmword_23435FD80;
    *(_OWORD *)float v61 = xmmword_23435FBB0;
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v39, (uint64_t)v59);
    *(_OWORD *)uint64_t v59 = xmmword_23435FD50;
    *(_OWORD *)&v59[16] = xmmword_23435FD60;
    long long v60 = xmmword_23435FD80;
    *(_OWORD *)float v61 = xmmword_23435FBB0;
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v42, (uint64_t)v59);
    int v36 = 1;
    goto LABEL_21;
  }
  uint64_t v30 = v29;
  char v37 = a7;
  uint64_t v38 = a4;
  if (!*(void *)(v29 + 128))
  {
LABEL_19:
    int v36 = *(unsigned __int8 *)(v30 + 490);
    a4 = v38;
    a7 = v37;
LABEL_21:
    *((_DWORD *)a1 + 9) = v36;
    *(int64x2_t *)&v59[8] = vdupq_n_s64(1uLL);
    *(void *)uint64_t v59 = &v66;
    *(void *)&v59[24] = &v67;
    long long v60 = *(_OWORD *)&v59[8];
    *(_OWORD *)&v61[8] = *(_OWORD *)&v59[8];
    *(void *)float v61 = &v68;
    unint64_t v62 = &v69;
    long long v63 = *(_OWORD *)&v59[8];
    unint64_t v64 = &v70;
    long long v65 = *(_OWORD *)&v59[8];
    uint64_t v45 = a2;
    unint64_t v46 = v59;
    uint64_t v47 = v44;
    uint64_t v48 = v41;
    uint64_t v49 = 0;
    char v50 = v36;
    __int16 v51 = 0;
    char v52 = 0;
    char v53 = *a6;
    if (v53)
    {
      long long v54 = *(_OWORD *)(a6 + 1);
      char v55 = a6[17];
    }
    v56[0] = a7;
    memset(&v56[1], 0, 32);
    uint64_t v57 = a4;
    char v58 = 0;
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(a3, (uint64_t *)v71);
    re::RenderGraphContext::encodeDrawCalls(a3, v71, &v45);
    if (v39[0] && v41) {
      (*(void (**)(void))(*(void *)v39[0] + 40))();
    }
    if (v42[0] && v44) {
      (*(void (**)(void))(*(void *)v42[0] + 40))();
    }
    goto LABEL_11;
  }
  unint64_t v31 = 0;
  int v32 = 0;
  while (1)
  {
    re::Projection::computeMatrix4x4F((re::Projection *)(v30 + 144 + (v31 << 6)), (uint64_t)v59);
    *(void *)&double v34 = re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v39, (uint64_t)v59).n128_u64[0];
    unint64_t v35 = *(void *)(v30 + 48);
    if (v35 <= v31) {
      break;
    }
    re::RenderCamera::computeInverseTransform((float32x4_t *)(v30 + 64 + 32 * v31), (uint64_t)v59);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v42, (uint64_t)v59);
    unint64_t v31 = ++v32;
    if (*(void *)(v30 + 128) <= (unint64_t)v32) {
      goto LABEL_19;
    }
  }
  re::internal::assertLog((re::internal *)6, v33, v34, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v31, v35);
  _os_crash();
  __break(1u);
}

re::RenderGraphFullscreenNode *re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(re::RenderGraphFullscreenNode *this, const char *a2)
{
  uint64_t v3 = re::RenderGraphNode::RenderGraphNode(this, a2);
  *((_DWORD *)v3 + 64) = 1;
  *(void *)uint64_t v3 = &unk_26E717D80;
  uint64_t v4 = (void *)((char *)v3 + 288);
  *(_OWORD *)((char *)v3 + 264) = 0u;
  *(_OWORD *)((char *)v3 + 280) = 0u;
  *(_OWORD *)((char *)v3 + 296) = 0u;
  *((void *)v3 + 39) = 0;
  re::DynamicString::setCapacity(v4, 0);
  *((void *)this + 40) = 0;
  *((_WORD *)this + 164) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 47) = 0;
  *((_DWORD *)this + 100) = 0;
  *((void *)this + 56) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((unsigned char *)this + 352) = 0;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((_DWORD *)this + 110) = 0;
  return this;
}

void re::RenderGraphFullscreenNode::configure(re::RenderGraphFullscreenNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((void *)this + 34)) {
    re::AssetHandle::loadAsync((re::RenderGraphFullscreenNode *)((char *)this + 264));
  }
  re::RenderGraphNode::configure(this, a2, a3, a4);
}

void re::RenderGraphFullscreenNode::execute(re::RenderGraphFullscreenNode *this, re::RenderGraphContext *a2)
{
}

void re::RenderGraphFullscreenNode::executeInternal(re::RenderGraphFullscreenNode *this, re::RenderGraphContext *a2, const re::AssetHandle *a3)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v79, 5038, 0);
  uint64_t v6 = *((void *)this + 40);
  if (!v6)
  {
    uint64_t v6 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphFullscreenNode *)((char *)this + 264));
    *((void *)this + 40) = v6;
    if (!v6) {
      goto LABEL_94;
    }
  }
  uint64_t v7 = *(void *)(v6 + 1664);
  if (re::RenderGraphDataStore::tryGet<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48)))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF998F8, memory_order_acquire) & 1) == 0)
    {
      uint64_t v72 = (re *)__cxa_guard_acquire(&qword_26AF998F8);
      if (v72)
      {
        qword_26AF998F0 = re::hashString(v72, v73);
        __cxa_guard_release(&qword_26AF998F8);
      }
    }
    uint64_t v8 = 0x9E3779B97F4A7C17;
    unint64_t v9 = qword_26AF998F0;
    size_t v10 = strlen(*((const char **)this + 4));
    if (v10)
    {
      MurmurHash3_x64_128(*((void *)this + 4), v10, 0, (unint64_t *)v80);
      uint64_t v8 = ((*(void *)&v80[1] - 0x61C8864680B583E9 + (*(void *)v80 << 6) + (*(void *)v80 >> 2)) ^ *(void *)v80)
         - 0x61C8864680B583E9;
    }
    uint64_t v11 = re::RenderGraphDataStore::tryGet<re::DynamicFunctionConstantsData>(*((void *)a2 + 146), ((v9 >> 2) + (v9 << 6) + v8) ^ v9);
    if (v11) {
      uint64_t v12 = v11 + 8;
    }
    else {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  unint64_t v13 = *((void *)a3 + 1);
  if (v13) {
    uint64_t v14 = *(void *)(v13 + 664);
  }
  else {
    uint64_t v14 = 0;
  }
  unint64_t v15 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v80[0] = (int32x2_t)(v14 ^ (v15 >> 31) ^ v15);
  uint64_t v16 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)a2 + 1568, (uint64_t *)v80);
  if (v16) {
    uint64_t v17 = *v16;
  }
  else {
    uint64_t v17 = 0;
  }
  re::RenderGraphContext::makeFullscreenDrawCall(a2, v7, v17, *((void *)this + 42), *((void *)this + 43), v12, v80);
  double v18 = v82;
  unint64_t v19 = re::Hash<re::DynamicString>::operator()((uint64_t)&v78, (uint64_t)this + 288);
  double v20 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices(v18, v19);
  if (!v21)
  {
    re::internal::assertLog((re::internal *)6, 0, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_62;
  }
  int v81 = *v20;
  if (v81 == -1) {
    goto LABEL_94;
  }
  unint64_t v22 = *((void *)this + 49);
  if (v22)
  {
    uint64_t v23 = 0;
    while (1)
    {
      uint64_t v24 = *((void *)this + 51);
      uint64_t v25 = v24 + 56 * v23;
      if (*(_DWORD *)(v25 + 40) != -1 && *(_DWORD *)(v24 + 56 * v23 + 44) != -1) {
        break;
      }
LABEL_37:
      if (v22 <= ++v23) {
        goto LABEL_38;
      }
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, v25 + 32, *(unsigned __int8 *)(v24 + 56 * v23 + 48), *(unsigned __int8 *)(v24 + 56 * v23 + 50), &v78);
    unint64_t v26 = *(void *)(v25 + 8);
    if (v26)
    {
      uint64_t v28 = *(unsigned char **)(v25 + 16);
      if (!v28)
      {
        uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_34:
        uint64_t v33 = (void *)(*(void *)a2 + 368);
        uint64_t v77 = v32;
        re::DynamicTextureTableAdd(v33, &v77, &v78);
        if (v78) {

        }
        unint64_t v22 = *((void *)this + 49);
        goto LABEL_37;
      }
      LOBYTE(v27) = *v28;
    }
    else
    {
      uint64_t v27 = v26 >> 8;
      uint64_t v28 = (unsigned char *)(v25 + 9);
    }
    if ((_BYTE)v27)
    {
      uint64_t v27 = (char)v27;
      char v29 = v28[1];
      if (v29)
      {
        uint64_t v30 = v28 + 2;
        do
        {
          uint64_t v27 = 31 * v27 + v29;
          int v31 = *v30++;
          char v29 = v31;
        }
        while (v31);
      }
      uint64_t v32 = v27 & 0x7FFFFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v32 = 0;
    }
    goto LABEL_34;
  }
LABEL_38:
  unint64_t v34 = *((void *)this + 54);
  if (v34)
  {
    uint64_t v35 = 0;
    while (1)
    {
      uint64_t v36 = *((void *)this + 56) + 56 * v35;
      if (*(_DWORD *)(v36 + 40) == -1 || *(_DWORD *)(v36 + 44) == -1) {
        goto LABEL_54;
      }
      uint64_t v37 = re::RenderGraphContext::metalBuffer((uint64_t)a2, v36 + 32);
      unint64_t v38 = *(void *)(v36 + 8);
      if ((v38 & 1) == 0) {
        break;
      }
      int v40 = *(unsigned char **)(v36 + 16);
      if (v40)
      {
        LOBYTE(v39) = *v40;
LABEL_46:
        if ((_BYTE)v39)
        {
          uint64_t v39 = (char)v39;
          char v41 = v40[1];
          if (v41)
          {
            unsigned int v42 = v40 + 2;
            do
            {
              uint64_t v39 = 31 * v39 + v41;
              int v43 = *v42++;
              char v41 = v43;
            }
            while (v43);
          }
          uint64_t v44 = v39 & 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v44 = 0;
        }
        goto LABEL_53;
      }
      uint64_t v44 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_53:
      uint64_t v45 = (re::BufferTable *)(*(void *)a2 + 480);
      id v78 = (id)v44;
      re::BufferTable::setBuffer(v45, (const re::WeakStringID *)&v78, v37);
      unint64_t v34 = *((void *)this + 54);
LABEL_54:
      if (v34 <= ++v35) {
        goto LABEL_55;
      }
    }
    uint64_t v39 = v38 >> 8;
    int v40 = (unsigned char *)(v36 + 9);
    goto LABEL_46;
  }
LABEL_55:
  uint64_t v46 = *((void *)this + 37);
  if (v46) {
    uint64_t v47 = (const char *)*((void *)this + 38);
  }
  else {
    uint64_t v47 = (char *)this + 297;
  }
  if (*((unsigned char *)a2 + 1332))
  {
LABEL_62:
    uint64_t v48 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)a2 + 1336), *((const char **)this + 2), v47);
    if ((*((void *)this + 37) & 1) == 0) {
      goto LABEL_60;
    }
    goto LABEL_63;
  }
  uint64_t v48 = 0;
  if ((v46 & 1) == 0)
  {
LABEL_60:
    uint64_t v49 = (char *)this + 297;
    goto LABEL_64;
  }
LABEL_63:
  uint64_t v49 = (char *)*((void *)this + 38);
LABEL_64:
  int v50 = *((unsigned __int8 *)this + 329);
  char v74 = *((unsigned char *)this + 352);
  if (v74)
  {
    char v76 = *((unsigned char *)this + 369);
    long long v75 = *(_OWORD *)((char *)this + 353);
  }
  re::encodeFullscreenDrawCall((re::DrawCall *)v80, (uint64_t)v49, a2, v48, v50 != 0, &v74, *((unsigned char *)this + 328));
  if (*((void *)this + 49))
  {
    uint64_t v52 = 0;
    while (1)
    {
      uint64_t v53 = *((void *)this + 51) + 56 * v52;
      unint64_t v54 = *(void *)(v53 + 8);
      if ((v54 & 1) == 0) {
        break;
      }
      unint64_t v56 = *(unsigned char **)(v53 + 16);
      if (v56)
      {
        LOBYTE(v53) = *v56;
LABEL_72:
        if ((_BYTE)v53)
        {
          uint64_t v53 = (char)v53;
          char v57 = v56[1];
          if (v57)
          {
            char v58 = v56 + 2;
            do
            {
              uint64_t v53 = 31 * v53 + v57;
              int v59 = *v58++;
              char v57 = v59;
            }
            while (v59);
          }
          uint64_t v60 = v53 & 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v60 = 0;
        }
        goto LABEL_79;
      }
      uint64_t v60 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_79:
      float v61 = (re *)(*(void *)a2 + 368);
      id v78 = (id)v60;
      re::DynamicTextureTableRemove(v61, (re::TextureTable *)&v78, v51);
      if (*((void *)this + 49) <= (unint64_t)++v52) {
        goto LABEL_80;
      }
    }
    unint64_t v55 = v54 >> 8;
    unint64_t v56 = (unsigned char *)(v53 + 9);
    LOBYTE(v53) = v55;
    goto LABEL_72;
  }
LABEL_80:
  if (*((void *)this + 54))
  {
    uint64_t v62 = 0;
    while (1)
    {
      uint64_t v63 = *((void *)this + 56) + 56 * v62;
      unint64_t v64 = *(void *)(v63 + 8);
      if ((v64 & 1) == 0) {
        break;
      }
      uint64_t v66 = *(unsigned char **)(v63 + 16);
      if (v66)
      {
        LOBYTE(v63) = *v66;
LABEL_86:
        if ((_BYTE)v63)
        {
          uint64_t v63 = (char)v63;
          char v67 = v66[1];
          if (v67)
          {
            uint64_t v68 = v66 + 2;
            do
            {
              uint64_t v63 = 31 * v63 + v67;
              int v69 = *v68++;
              char v67 = v69;
            }
            while (v69);
          }
          uint64_t v70 = v63 & 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v70 = 0;
        }
        goto LABEL_93;
      }
      uint64_t v70 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_93:
      unint64_t v71 = (re::BufferTable *)(*(void *)a2 + 480);
      id v78 = (id)v70;
      re::BufferTable::removeBuffer(v71, (const re::WeakStringID *)&v78);
      if (*((void *)this + 54) <= (unint64_t)++v62) {
        goto LABEL_94;
      }
    }
    unint64_t v65 = v64 >> 8;
    uint64_t v66 = (unsigned char *)(v63 + 9);
    LOBYTE(v63) = v65;
    goto LABEL_86;
  }
LABEL_94:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v79);
}

double re::RenderGraphFullscreenNode::setRenderGraphTexture(uint64_t a1, const re::DynamicString *a2, __n128 *a3)
{
  unint64_t v5 = (_anonymous_namespace_ *)(a1 + 376);
  re::DynamicString::DynamicString((re::DynamicString *)&v8, a2);
  unint64_t v11 = a3->n128_u64[0];
  uint64_t v12 = a3->n128_i64[1];
  __int16 v13 = 0;
  char v14 = 0;
  double v6 = re::DynamicArray<re::SetRenderGraphTextureCommand>::add(v5, (uint64_t)&v8);
  if (v8.n128_u64[0] && (v8.n128_u8[8] & 1) != 0) {
    (*(void (**)(double))(*(void *)v8.n128_u64[0] + 40))(v6);
  }
  __n128 v8 = *a3;
  uint64_t v9 = 0;
  uint64_t v10 = 2;
  *(void *)&double result = re::DynamicArray<re::TargetRead>::add((_anonymous_namespace_ *)(a1 + 176), &v8).n128_u64[0];
  return result;
}

double re::DynamicArray<re::SetRenderGraphTextureCommand>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SetRenderGraphTextureCommand>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 56 * v4;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v6 = *(void *)(v5 + 16);
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v6;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = -1;
  *(_OWORD *)(v5 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  uint64_t v7 = *(void *)(v5 + 8);
  *(void *)(v5 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v7;
  double result = *(double *)(a2 + 40);
  *(double *)(v5 + 40) = result;
  LOWORD(v7) = *(_WORD *)(a2 + 48);
  *(unsigned char *)(v5 + 50) = *(unsigned char *)(a2 + 50);
  *(_WORD *)(v5 + 48) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

double re::RenderGraphFullscreenNode::setRenderGraphTextureCommand(uint64_t a1, __n128 *a2)
{
  re::DynamicArray<re::SetRenderGraphTextureCommand>::add((_anonymous_namespace_ *)(a1 + 376), (re::DynamicString *)a2);
  __n128 v5 = a2[2];
  uint64_t v6 = 0;
  uint64_t v7 = 2;
  *(void *)&double result = re::DynamicArray<re::TargetRead>::add((_anonymous_namespace_ *)(a1 + 176), &v5).n128_u64[0];
  return result;
}

double re::DynamicArray<re::SetRenderGraphTextureCommand>::add(_anonymous_namespace_ *this, re::DynamicString *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SetRenderGraphTextureCommand>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  __n128 v5 = re::DynamicString::DynamicString((re::DynamicString *)(*((void *)this + 4) + 56 * v4), a2);
  *((void *)v5 + 4) = 0;
  *((void *)v5 + 5) = -1;
  *((void *)v5 + 4) = *((void *)a2 + 4);
  double result = *((double *)a2 + 5);
  *((double *)v5 + 5) = result;
  __int16 v7 = *((_WORD *)a2 + 24);
  *((unsigned char *)v5 + 50) = *((unsigned char *)a2 + 50);
  *((_WORD *)v5 + 24) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::RenderGraphFullscreenNode::getMaterialParameterTables(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 272))
  {
    uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 264));
    if (v4)
    {
      __n128 v5 = *(re::MaterialParameterBlock **)(v4 + 1672);
      if (v5)
      {
        unint64_t v6 = *(void *)(a1 + 272);
        if (v6) {
          uint64_t v7 = *(void *)(v6 + 664);
        }
        else {
          uint64_t v7 = 0;
        }
        unint64_t v8 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
        unint64_t v10 = v7 ^ (v8 >> 31) ^ v8;
        re::MaterialParameterBlock::createMaterialParameterTableIfNeeded(v5, &v9);
        re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a2, &v10, &v9);
        if (v9) {
      }
        }
    }
  }
}

uint64_t re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addAsMove(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 16) + 24 * v11;
    return v10 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 8) != v6)
  {
    LODWORD(v8) = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = v9 + 24 * v8;
  return v10 + 16;
}

void *re::allocInfo_RenderGraphFullscreenNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99908, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99908))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99A48, "RenderGraphFullscreenNode");
    __cxa_guard_release(&qword_26AF99908);
  }
  return &unk_26AF99A48;
}

void re::initInfo_RenderGraphFullscreenNode(re *this, re::IntrospectionBase *a2)
{
  uint64_t v54 = 0x59B9C6E0BF4EAF6ALL;
  unint64_t v55 = "RenderGraphFullscreenNode";
  re::StringID::destroyString((re::StringID *)&v54);
  *((_OWORD *)this + 2) = v49;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99900, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99900);
    if (v4)
    {
      __n128 v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99990 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "material";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99998 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      char v14 = re::IntrospectionInfo<re::DynamicString>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "techniqueName";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x12000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF999A0 = v15;
      uint64_t v16 = (re *)re::introspectionAllocator((re *)v15);
      uint64_t v17 = v16;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99940, memory_order_acquire) & 1) == 0)
      {
        uint64_t v16 = (re *)__cxa_guard_acquire(&qword_26AF99940);
        if (v16)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF999C8);
          qword_26AF999C8 = (uint64_t)&unk_26E717E28;
          __cxa_guard_release(&qword_26AF99940);
        }
      }
      if ((_MergedGlobals_435 & 1) == 0)
      {
        double v18 = (void *)qword_26AF99920;
        if (qword_26AF99920
          || (double v18 = re::allocInfo_SetRenderGraphTextureCommand(v16),
              qword_26AF99920 = (uint64_t)v18,
              re::initInfo_SetRenderGraphTextureCommand((re *)v18, v19),
              (_MergedGlobals_435 & 1) == 0))
        {
          _MergedGlobals_435 = 1;
          int v20 = *((_DWORD *)v18 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF999C8, 0);
          qword_26AF999D8 = 0x2800000003;
          dword_26AF999E0 = v20;
          word_26AF999E4 = 0;
          *(void *)&xmmword_26AF999E8 = 0;
          *((void *)&xmmword_26AF999E8 + 1) = 0xFFFFFFFFLL;
          qword_26AF999F8 = (uint64_t)v18;
          unk_26AF99A00 = 0;
          qword_26AF999C8 = (uint64_t)&unk_26E717E28;
          re::IntrospectionRegistry::add(v21, v22);
          re::getPrettyTypeName((re *)&qword_26AF999C8, (const re::IntrospectionBase *)&v54);
          if (v55) {
            uint64_t v23 = v56;
          }
          else {
            uint64_t v23 = (char *)&v55 + 1;
          }
          if (v54 && (v55 & 1) != 0) {
            (*(void (**)(void))(*(void *)v54 + 40))();
          }
          long long v51 = *((_OWORD *)v18 + 2);
          uint64_t v24 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v52);
          if (v24)
          {
            uint64_t v25 = *v24;
            *((void *)&v50 + 1) = v25;
          }
          else
          {
            long long v53 = v51;
            re::TypeBuilder::beginListType((uint64_t)&v54, v52, 1, 0x28uLL, 8uLL, &v53);
            re::TypeBuilder::setConstructor((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v54, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v54, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v54, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v54, v26);
          }
          xmmword_26AF999E8 = v50;
          re::StringID::destroyString((re::StringID *)v52);
        }
      }
      uint64_t v27 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "RenderGraphTextureCommands";
      *(void *)(v27 + 16) = &qword_26AF999C8;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x17800000003;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF999A8 = v27;
      uint64_t v28 = (re *)re::introspectionAllocator((re *)v27);
      char v29 = v28;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99948, memory_order_acquire) & 1) == 0)
      {
        uint64_t v28 = (re *)__cxa_guard_acquire(&qword_26AF99948);
        if (v28)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF99A08);
          qword_26AF99A08 = (uint64_t)&unk_26E717EC0;
          __cxa_guard_release(&qword_26AF99948);
        }
      }
      if ((byte_26AF998E9 & 1) == 0)
      {
        uint64_t v30 = (void *)qword_26AF99938;
        if (qword_26AF99938
          || (uint64_t v30 = re::allocInfo_SetRenderGraphBufferCommand(v28),
              qword_26AF99938 = (uint64_t)v30,
              re::initInfo_SetRenderGraphBufferCommand((re *)v30, v31),
              (byte_26AF998E9 & 1) == 0))
        {
          byte_26AF998E9 = 1;
          int v32 = *((_DWORD *)v30 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF99A08, 0);
          qword_26AF99A18 = 0x2800000003;
          dword_26AF99A20 = v32;
          word_26AF99A24 = 0;
          *(void *)&xmmword_26AF99A28 = 0;
          *((void *)&xmmword_26AF99A28 + 1) = 0xFFFFFFFFLL;
          qword_26AF99A38 = (uint64_t)v30;
          unk_26AF99A40 = 0;
          qword_26AF99A08 = (uint64_t)&unk_26E717EC0;
          re::IntrospectionRegistry::add(v33, v34);
          re::getPrettyTypeName((re *)&qword_26AF99A08, (const re::IntrospectionBase *)&v54);
          if (v55) {
            uint64_t v35 = v56;
          }
          else {
            uint64_t v35 = (char *)&v55 + 1;
          }
          if (v54 && (v55 & 1) != 0) {
            (*(void (**)(void))(*(void *)v54 + 40))();
          }
          long long v51 = *((_OWORD *)v30 + 2);
          uint64_t v36 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v52);
          if (v36)
          {
            uint64_t v37 = *v36;
            *((void *)&v50 + 1) = v37;
          }
          else
          {
            long long v53 = v51;
            re::TypeBuilder::beginListType((uint64_t)&v54, v52, 1, 0x28uLL, 8uLL, &v53);
            re::TypeBuilder::setConstructor((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v54, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v54, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v54, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v54, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v54, v38);
          }
          xmmword_26AF99A28 = v50;
          re::StringID::destroyString((re::StringID *)v52);
        }
      }
      uint64_t v39 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 72, 8);
      *(_DWORD *)uint64_t v39 = 1;
      *(void *)(v39 + 8) = "RenderGraphBufferCommands";
      *(void *)(v39 + 16) = &qword_26AF99A08;
      *(void *)(v39 + 24) = 0;
      *(void *)(v39 + 32) = 0x1A000000004;
      *(_DWORD *)(v39 + 40) = 0;
      *(void *)(v39 + 48) = 0;
      *(void *)(v39 + 56) = 0;
      *(_DWORD *)(v39 + 64) = 0;
      qword_26AF999B0 = v39;
      int v40 = re::introspectionAllocator((re *)v39);
      unsigned int v42 = re::introspect_BOOL((re *)1, v41);
      uint64_t v43 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 72, 8);
      *(_DWORD *)uint64_t v43 = 1;
      *(void *)(v43 + 8) = "tintBlendColor";
      *(void *)(v43 + 16) = v42;
      *(void *)(v43 + 24) = 0;
      *(void *)(v43 + 32) = 0x14900000005;
      *(_DWORD *)(v43 + 40) = 0;
      *(void *)(v43 + 48) = 0;
      *(void *)(v43 + 56) = 0;
      *(_DWORD *)(v43 + 64) = 0;
      qword_26AF999B8 = v43;
      uint64_t v44 = re::introspectionAllocator((re *)v43);
      uint64_t v46 = re::introspect_BOOL((re *)1, v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 72, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = "setViewportToCoverEntireRenderTarget";
      *(void *)(v47 + 16) = v46;
      *(void *)(v47 + 24) = 0;
      *(void *)(v47 + 32) = 0x14800000006;
      *(_DWORD *)(v47 + 40) = 0;
      *(void *)(v47 + 48) = 0;
      *(void *)(v47 + 56) = 0;
      *(_DWORD *)(v47 + 64) = 0;
      qword_26AF999C0 = v47;
      __cxa_guard_release(&qword_26AF99900);
    }
  }
  *((void *)this + 2) = 0x1C800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 7;
  *((void *)this + 8) = &qword_26AF99990;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphFullscreenNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphFullscreenNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphFullscreenNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphFullscreenNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v48 = v49;
}

re::RenderGraphFullscreenNode *re::internal::defaultConstruct<re::RenderGraphFullscreenNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  return re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
}

uint64_t re::internal::defaultDestruct<re::RenderGraphFullscreenNode>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphFullscreenNode>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphFullscreenNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphFullscreenNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphFullscreenNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphFullscreenNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphFullscreenNode>, this);
}

void *re::allocInfo_SetRenderGraphTextureCommand(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99910, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99910))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99AC0, "SetRenderGraphTextureCommand");
    __cxa_guard_release(&qword_26AF99910);
  }
  return &unk_26AF99AC0;
}

void re::initInfo_SetRenderGraphTextureCommand(re *this, re::IntrospectionBase *a2)
{
  v26[0] = 0xDF7850A971DCEE0CLL;
  v26[1] = "SetRenderGraphTextureCommand";
  re::StringID::destroyString((re::StringID *)v26);
  *((_OWORD *)this + 2) = v27;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99918, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99918);
    if (v4)
    {
      __n128 v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicString>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "bindingName";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99968 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_RenderGraphTargetHandle((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "targetHandle";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99970 = v12;
      __int16 v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_BOOL((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "makeStencilView";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x3000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF99978 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      unint64_t v19 = re::introspect_BOOL((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "isOptional";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x3100000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF99980 = v20;
      uint64_t v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::introspect_BOOL((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "makeArrayView";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x3200000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF99988 = v24;
      __cxa_guard_release(&qword_26AF99918);
    }
  }
  *((void *)this + 2) = 0x3800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 5;
  *((void *)this + 8) = &qword_26AF99968;
  *((void *)this + 9) = re::internal::defaultConstruct<re::SetRenderGraphTextureCommand>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::SetRenderGraphTextureCommand>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::SetRenderGraphTextureCommand>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::SetRenderGraphTextureCommand>;
  re::IntrospectionRegistry::add(this, v3);
  long long v25 = v27;
}

double re::internal::defaultConstruct<re::SetRenderGraphTextureCommand>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  re::DynamicString::setCapacity((void *)a3, 0);
  *(void *)(a3 + 32) = 0;
  double result = NAN;
  *(void *)(a3 + 40) = -1;
  *(_WORD *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 50) = 0;
  return result;
}

double re::internal::defaultDestruct<re::SetRenderGraphTextureCommand>(int a1, int a2, re::DynamicString *this)
{
  return re::DynamicString::deinit(this);
}

double re::internal::defaultConstructV2<re::SetRenderGraphTextureCommand>(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  re::DynamicString::setCapacity((void *)a1, 0);
  *(void *)(a1 + 32) = 0;
  double result = NAN;
  *(void *)(a1 + 40) = -1;
  *(_WORD *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 50) = 0;
  return result;
}

void *re::allocInfo_SetRenderGraphBufferCommand(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99928, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99928))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99B38, "SetRenderGraphBufferCommand");
    __cxa_guard_release(&qword_26AF99928);
  }
  return &unk_26AF99B38;
}

void re::initInfo_SetRenderGraphBufferCommand(re *this, re::IntrospectionBase *a2)
{
  v18[0] = 0x4EBFC76BCFC0BDAALL;
  v18[1] = "SetRenderGraphBufferCommand";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99930, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99930);
    if (v4)
    {
      __n128 v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicString>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "bindingName";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF99950 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_RenderGraphBufferHandle((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "bufferHandle";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF99958 = v12;
      __int16 v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_BOOL((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "isOptional";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x3000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF99960 = v16;
      __cxa_guard_release(&qword_26AF99930);
    }
  }
  *((void *)this + 2) = 0x3800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF99950;
  *((void *)this + 9) = re::internal::defaultConstruct<re::SetRenderGraphBufferCommand>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::SetRenderGraphBufferCommand>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::SetRenderGraphBufferCommand>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::SetRenderGraphBufferCommand>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

double re::internal::defaultConstruct<re::SetRenderGraphBufferCommand>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  re::DynamicString::setCapacity((void *)a3, 0);
  *(void *)(a3 + 32) = 0;
  double result = NAN;
  *(void *)(a3 + 40) = -1;
  *(unsigned char *)(a3 + 48) = 0;
  return result;
}

double re::internal::defaultDestruct<re::SetRenderGraphBufferCommand>(int a1, int a2, re::DynamicString *this)
{
  return re::DynamicString::deinit(this);
}

double re::internal::defaultConstructV2<re::SetRenderGraphBufferCommand>(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  re::DynamicString::setCapacity((void *)a1, 0);
  *(void *)(a1 + 32) = 0;
  double result = NAN;
  *(void *)(a1 + 40) = -1;
  *(unsigned char *)(a1 + 48) = 0;
  return result;
}

void re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(id *this)
{
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t vars8;

  *this = &unk_26E717D80;
  re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit((uint64_t)(this + 52));
  re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit((uint64_t)(this + 47));
  re::DynamicString::deinit((re::DynamicString *)(this + 36));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
}

uint64_t re::RenderGraphFullscreenNode::typeInfo(re::RenderGraphFullscreenNode *this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphFullscreenNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphFullscreenNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphFullscreenNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphFullscreenNode>, 0);
}

uint64_t re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 56 * v4;
        do
        {
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::RenderGraphDataStore::tryGet<re::DynamicFunctionConstantsData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re28DynamicFunctionConstantsDataE";
  if (((unint64_t)"N2re28DynamicFunctionConstantsDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re28DynamicFunctionConstantsDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void *re::DynamicArray<re::SetRenderGraphTextureCommand>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 56 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v12 = v11[2];
          void v11[2] = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v12;
          v11[4] = 0;
          v11[5] = -1;
          *(_OWORD *)(v11 + 3) = *(_OWORD *)(v8 + 24);
          *(void *)(v8 + 24) = 0;
          uint64_t v13 = v11[1];
          v11[1] = *(void *)(v8 + 8);
          *(void *)(v8 + 8) = v13;
          v11[5] = *(void *)(v8 + 40);
          LOWORD(v13) = *(_WORD *)(v8 + 48);
          *((unsigned char *)v11 + 50) = *(unsigned char *)(v8 + 50);
          *((_WORD *)v11 + 24) = v13;
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 56;
          v11 += 7;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 56 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v12 = v11[2];
          void v11[2] = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v12;
          v11[4] = 0;
          v11[5] = -1;
          *(_OWORD *)(v11 + 3) = *(_OWORD *)(v8 + 24);
          *(void *)(v8 + 24) = 0;
          uint64_t v13 = v11[1];
          v11[1] = *(void *)(v8 + 8);
          *(void *)(v8 + 8) = v13;
          v11[5] = *(void *)(v8 + 40);
          *((unsigned char *)v11 + 48) = *(unsigned char *)(v8 + 48);
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 56;
          v11 += 7;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::SetRenderGraphTextureCommand>::resize((_anonymous_namespace_ *)a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::addElement(re::Allocator **a1, re *a2, int a3, _anonymous_namespace_ *a4)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  re::DynamicString::setCapacity(&v11, 0);
  *((void *)&v13 + 1) = 0;
  *(void *)&long long v14 = -1;
  WORD4(v14) = 0;
  BYTE10(v14) = 0;
  double v8 = re::DynamicArray<re::SetRenderGraphTextureCommand>::add(a4, (uint64_t)&v11);
  if (v11 && (v12 & 1) != 0) {
    (*(void (**)(double))(*v11 + 40))(v8);
  }
  uint64_t v9 = (re::IntrospectionBase *)(*((void *)a4 + 4) + 56 * *((void *)a4 + 2) - 56);
  re::introspectionInitElement(a2, a3, a1[6], v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphTextureCommand>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

void re::DynamicArray<re::SetRenderGraphTextureCommand>::resize(_anonymous_namespace_ *a1, unint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = *((void *)a1 + 2);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 56 * a2;
    unint64_t v9 = a2;
    do
    {
      re::DynamicString::deinit((re::DynamicString *)(*((void *)v3 + 4) + v8));
      ++v9;
      v8 += 56;
    }
    while (v9 < *((void *)v3 + 2));
  }
  else
  {
    if (*((void *)a1 + 1) < a2)
    {
      a1 = (_anonymous_namespace_ *)re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity(a1, a2);
      unint64_t v4 = *((void *)v3 + 2);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 56 * v4 + 50;
      do
      {
        unint64_t v7 = (unsigned char *)(*((void *)v3 + 4) + v6);
        *(_OWORD *)(v7 - 34) = 0u;
        *(_OWORD *)(v7 - 50) = 0u;
        a1 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v7 - 50, 0);
        *(void *)(v7 - 18) = 0;
        *(void *)(v7 - 10) = -1;
        *((_WORD *)v7 - 1) = 0;
        v6 += 56;
        *unint64_t v7 = 0;
        --v5;
      }
      while (v5);
    }
  }
  *((void *)v3 + 2) = a2;
  ++*((_DWORD *)v3 + 6);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v8)
    {
      unint64_t v9 = *(re::DynamicString **)(a1 + 32);
      uint64_t v10 = 56 * v8;
      do
      {
        re::DynamicString::deinit(v9);
        unint64_t v9 = (re::DynamicString *)((char *)v9 + 56);
        v10 -= 56;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::SetRenderGraphTextureCommand>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::SetRenderGraphTextureCommand>::resize((_anonymous_namespace_ *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    uint64_t v12 = *(void *)(a1 + 16);
    if (v12)
    {
      long long v13 = *(char **)(a1 + 32);
      uint64_t v14 = 56 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 56;
        v14 -= 56;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 56 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 56 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphTextureCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::SetRenderGraphBufferCommand>::resize((_anonymous_namespace_ *)a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v21, 0);
  unint64_t v9 = *(void *)(a4 + 8);
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= v9)
  {
    unint64_t v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v12 = 2 * v9;
        BOOL v13 = v9 == 0;
        unint64_t v14 = 8;
        if (!v13) {
          unint64_t v14 = v12;
        }
        if (v14 <= v11) {
          unint64_t v15 = v11;
        }
        else {
          unint64_t v15 = v14;
        }
        re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a4, v15);
      }
      else
      {
        re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a4, v11);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v10 = *(void *)(a4 + 16);
  }
  uint64_t v16 = *(void *)(a4 + 32) + 56 * v10;
  *(void *)uint64_t v16 = v21;
  uint64_t v17 = v23;
  *(_OWORD *)(v16 + 8) = v22;
  *(void *)(v16 + 24) = v17;
  *(void *)(v16 + 32) = 0;
  *(void *)(v16 + 40) = -1;
  *(unsigned char *)(v16 + 48) = 0;
  uint64_t v18 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v18 + 1;
  ++*(_DWORD *)(a4 + 24);
  long long v19 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 56 * v18);
  re::introspectionInitElement(a2, a3, a1[6], v19);
  return v19;
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::SetRenderGraphBufferCommand>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 56 * a3;
}

void re::DynamicArray<re::SetRenderGraphBufferCommand>::resize(_anonymous_namespace_ *a1, unint64_t a2)
{
  int v3 = a1;
  unint64_t v4 = *((void *)a1 + 2);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 56 * a2;
    unint64_t v9 = a2;
    do
    {
      re::DynamicString::deinit((re::DynamicString *)(*((void *)v3 + 4) + v8));
      ++v9;
      v8 += 56;
    }
    while (v9 < *((void *)v3 + 2));
  }
  else
  {
    if (*((void *)a1 + 1) < a2)
    {
      a1 = (_anonymous_namespace_ *)re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity(a1, a2);
      unint64_t v4 = *((void *)v3 + 2);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 56 * v4;
      do
      {
        uint64_t v7 = *((void *)v3 + 4) + v6;
        *(_OWORD *)uint64_t v7 = 0u;
        *(_OWORD *)(v7 + 16) = 0u;
        a1 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)v7, 0);
        *(void *)(v7 + 32) = 0;
        *(void *)(v7 + 40) = -1;
        v6 += 56;
        *(unsigned char *)(v7 + 48) = 0;
        --v5;
      }
      while (v5);
    }
  }
  *((void *)v3 + 2) = a2;
  ++*((_DWORD *)v3 + 6);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v8)
    {
      unint64_t v9 = *(re::DynamicString **)(a1 + 32);
      uint64_t v10 = 56 * v8;
      do
      {
        re::DynamicString::deinit(v9);
        unint64_t v9 = (re::DynamicString *)((char *)v9 + 56);
        v10 -= 56;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::SetRenderGraphBufferCommand>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::SetRenderGraphBufferCommand>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::SetRenderGraphBufferCommand>::resize((_anonymous_namespace_ *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    uint64_t v12 = *(void *)(a1 + 16);
    if (v12)
    {
      BOOL v13 = *(char **)(a1 + 32);
      uint64_t v14 = 56 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 56;
        v14 -= 56;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 56 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 56 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SetRenderGraphBufferCommand>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

re::RenderGraphFullscreenNode *re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(re::RenderGraphFullscreenNode *this)
{
  uint64_t v2 = re::RenderGraphNode::RenderGraphNode(this);
  *((_DWORD *)v2 + 64) = 1;
  *(void *)uint64_t v2 = &unk_26E717D80;
  int v3 = (void *)((char *)v2 + 288);
  *(_OWORD *)((char *)v2 + 264) = 0u;
  *(_OWORD *)((char *)v2 + 280) = 0u;
  *(_OWORD *)((char *)v2 + 296) = 0u;
  *((void *)v2 + 39) = 0;
  re::DynamicString::setCapacity(v3, 0);
  *((void *)this + 40) = 0;
  *((_WORD *)this + 164) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 47) = 0;
  *((_DWORD *)this + 100) = 0;
  *((void *)this + 56) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((unsigned char *)this + 352) = 0;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((_DWORD *)this + 110) = 0;
  return this;
}

void re::GenerateClusterAABBNode::configure(re::GenerateClusterAABBNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if ((atomic_exchange((atomic_uchar *volatile)&re::GenerateClusterAABBNode::configure(char const*,char const*,re::RenderFrame &)::__FILE____LINE___logged, 1u) & 1) == 0)
  {
    unint64_t v4 = *re::graphicsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v5 = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "GenerateClusterAABBNode is deprecated and not implemented", v5, 2u);
    }
  }
}

void re::ComputeClusterProbeIntersectionNode::configure(re::ComputeClusterProbeIntersectionNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if ((atomic_exchange((atomic_uchar *volatile)&re::ComputeClusterProbeIntersectionNode::configure(char const*,char const*,re::RenderFrame &)::__FILE____LINE___logged, 1u) & 1) == 0)
  {
    unint64_t v4 = *re::graphicsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v5 = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "ComputeClusterProbeIntersectionNode is deprecated and not implemented", v5, 2u);
    }
  }
}

void re::DebugClusterAABBNode::configure(re::DebugClusterAABBNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if ((atomic_exchange(re::DebugClusterAABBNode::configure(char const*,char const*,re::RenderFrame &)::__FILE____LINE___logged, 1u) & 1) == 0)
  {
    unint64_t v4 = *re::graphicsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v5 = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "DebugClusterAABBNode is deprecated and not implemented", v5, 2u);
    }
  }
}

void *re::allocInfo_GenerateClusterAABBNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_436, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_436))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99C20, "GenerateClusterAABBNode");
    __cxa_guard_release(&_MergedGlobals_436);
  }
  return &unk_26AF99C20;
}

void re::initInfo_GenerateClusterAABBNode(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0xE382A9FAED18684ELL;
  v17[1] = "GenerateClusterAABBNode";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99BB8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99BB8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99BF0 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "library";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99BF8 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::IntrospectionInfo<re::DynamicString>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "computeFunction";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11800000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF99C00 = v15;
      __cxa_guard_release(&qword_26AF99BB8);
    }
  }
  *((void *)this + 2) = 0x14000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF99BF0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::GenerateClusterAABBNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::GenerateClusterAABBNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::GenerateClusterAABBNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::GenerateClusterAABBNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

re::GenerateClusterAABBNode *re::internal::defaultConstruct<re::GenerateClusterAABBNode>(int a1, int a2, re::GenerateClusterAABBNode *this)
{
  return re::GenerateClusterAABBNode::GenerateClusterAABBNode(this);
}

void re::internal::defaultDestruct<re::GenerateClusterAABBNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 + 312);
  if (v4)
  {

    *(void *)(a3 + 312) = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a3 + 280));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)a3);
}

void re::internal::defaultDestructV2<re::GenerateClusterAABBNode>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {

    *(void *)(a1 + 312) = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a1 + 280));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)a1);
}

uint64_t re::introspect_GenerateClusterAABBNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"GenerateClusterAABBNode", (uint64_t (*)(re::internal *))re::allocInfo_GenerateClusterAABBNode, (re::IntrospectionBase *(*)(void))re::initInfo_GenerateClusterAABBNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::GenerateClusterAABBNode>, this);
}

void *re::allocInfo_ComputeClusterProbeIntersectionNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99BC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99BC0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99C98, "ComputeClusterProbeIntersectionNode");
    __cxa_guard_release(&qword_26AF99BC0);
  }
  return &unk_26AF99C98;
}

void re::initInfo_ComputeClusterProbeIntersectionNode(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x7B570A09A2CECBB0;
  v17[1] = "ComputeClusterProbeIntersectionNode";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99BC8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99BC8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99C08 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "library";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99C10 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::IntrospectionInfo<re::DynamicString>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "computeFunction";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11800000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF99C18 = v15;
      __cxa_guard_release(&qword_26AF99BC8);
    }
  }
  *((void *)this + 2) = 0x14000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF99C08;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ComputeClusterProbeIntersectionNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ComputeClusterProbeIntersectionNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ComputeClusterProbeIntersectionNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ComputeClusterProbeIntersectionNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

re::ComputeClusterProbeIntersectionNode *re::internal::defaultConstruct<re::ComputeClusterProbeIntersectionNode>(int a1, int a2, re::ComputeClusterProbeIntersectionNode *this)
{
  return re::ComputeClusterProbeIntersectionNode::ComputeClusterProbeIntersectionNode(this);
}

void re::internal::defaultDestruct<re::ComputeClusterProbeIntersectionNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 + 312);
  if (v4)
  {

    *(void *)(a3 + 312) = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a3 + 280));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)a3);
}

void re::internal::defaultDestructV2<re::ComputeClusterProbeIntersectionNode>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {

    *(void *)(a1 + 312) = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a1 + 280));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)a1);
}

uint64_t re::introspect_ComputeClusterProbeIntersectionNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ComputeClusterProbeIntersectionNode", (uint64_t (*)(re::internal *))re::allocInfo_ComputeClusterProbeIntersectionNode, (re::IntrospectionBase *(*)(void))re::initInfo_ComputeClusterProbeIntersectionNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ComputeClusterProbeIntersectionNode>, this);
}

void *re::allocInfo_DebugClusterAABBNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99BD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99BD0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99D10, "DebugClusterAABBNode");
    __cxa_guard_release(&qword_26AF99BD0);
  }
  return &unk_26AF99D10;
}

void re::initInfo_DebugClusterAABBNode(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0xB58AF7B3E254EF92;
  v13[1] = "DebugClusterAABBNode";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99BD8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99BD8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99BE0 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "material";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99BE8 = v11;
      __cxa_guard_release(&qword_26AF99BD8);
    }
  }
  *((void *)this + 2) = 0x12000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF99BE0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::DebugClusterAABBNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::DebugClusterAABBNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::DebugClusterAABBNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::DebugClusterAABBNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::DebugClusterAABBNode>(int a1, int a2, re::RenderGraphNode *this)
{
  int v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)int v3 = &unk_26E7180A8;
  double result = 0.0;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::DebugClusterAABBNode>(uint64_t a1, uint64_t a2, id *a3)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 33));
  re::RenderGraphNode::~RenderGraphNode(a3);
}

double re::internal::defaultConstructV2<re::DebugClusterAABBNode>(re::RenderGraphNode *a1)
{
  uint64_t v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t v1 = &unk_26E7180A8;
  double result = 0.0;
  *((_OWORD *)v1 + 16) = 0u;
  *((_OWORD *)v1 + 17) = 0u;
  return result;
}

void re::internal::defaultDestructV2<re::DebugClusterAABBNode>(id *a1)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 33));
  re::RenderGraphNode::~RenderGraphNode(a1);
}

uint64_t re::introspect_DebugClusterAABBNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"DebugClusterAABBNode", (uint64_t (*)(re::internal *))re::allocInfo_DebugClusterAABBNode, (re::IntrospectionBase *(*)(void))re::initInfo_DebugClusterAABBNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::DebugClusterAABBNode>, this);
}

void re::GenerateClusterAABBNode::~GenerateClusterAABBNode(re::GenerateClusterAABBNode *this)
{
  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::DynamicString::deinit((re::GenerateClusterAABBNode *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::GenerateClusterAABBNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

{
  void *v2;
  uint64_t vars8;

  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::DynamicString::deinit((re::GenerateClusterAABBNode *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::GenerateClusterAABBNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
  JUMPOUT(0x237DBCBD0);
}

void re::ComputeClusterProbeIntersectionNode::~ComputeClusterProbeIntersectionNode(re::ComputeClusterProbeIntersectionNode *this)
{
  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::DynamicString::deinit((re::ComputeClusterProbeIntersectionNode *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::ComputeClusterProbeIntersectionNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

{
  void *v2;
  uint64_t vars8;

  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::DynamicString::deinit((re::ComputeClusterProbeIntersectionNode *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::ComputeClusterProbeIntersectionNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
  JUMPOUT(0x237DBCBD0);
}

void re::DebugClusterAABBNode::~DebugClusterAABBNode(id *this)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
}

{
  uint64_t vars8;

  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

re::GenerateClusterAABBNode *re::GenerateClusterAABBNode::GenerateClusterAABBNode(re::GenerateClusterAABBNode *this)
{
  uint64_t v2 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v2 = &unk_26E717F58;
  int v3 = (void *)((char *)v2 + 280);
  *((_OWORD *)v2 + 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((_OWORD *)v2 + 18) = 0u;
  *((void *)v2 + 38) = 0;
  re::DynamicString::setCapacity(v3, 0);
  *((void *)this + 39) = 0;
  return this;
}

re::ComputeClusterProbeIntersectionNode *re::ComputeClusterProbeIntersectionNode::ComputeClusterProbeIntersectionNode(re::ComputeClusterProbeIntersectionNode *this)
{
  uint64_t v2 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v2 = &unk_26E718000;
  int v3 = (void *)((char *)v2 + 280);
  *((_OWORD *)v2 + 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((_OWORD *)v2 + 18) = 0u;
  *((void *)v2 + 38) = 0;
  re::DynamicString::setCapacity(v3, 0);
  *((void *)this + 39) = 0;
  return this;
}

void re::RenderGraphDofSetupNode::configure(re::RenderGraphDofSetupNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((void *)this + 64)) {
    re::AssetHandle::loadAsync((re::RenderGraphDofSetupNode *)((char *)this + 504));
  }
  if (*((void *)this + 67)) {
    re::AssetHandle::loadAsync((re::RenderGraphDofSetupNode *)((char *)this + 528));
  }
  if (*((void *)this + 70)) {
    re::AssetHandle::loadAsync((re::RenderGraphDofSetupNode *)((char *)this + 552));
  }
  re::RenderGraphFullscreenNode::configure(this, a2, a3, a4);
}

void re::RenderGraphDofSetupNode::execute(re::RenderGraphDofSetupNode *this, re::RenderGraphContext *a2)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v52, 5048, 0);
  uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDofSetupNode *)((char *)this + 504));
  *((void *)this + 57) = v4;
  if (!v4) {
    goto LABEL_33;
  }
  uint64_t v5 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDofSetupNode *)((char *)this + 528));
  *((void *)this + 58) = v5;
  if (!v5) {
    goto LABEL_33;
  }
  uint64_t v6 = (uint64_t *)((char *)this + 552);
  uint64_t v7 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDofSetupNode *)((char *)this + 552));
  *((void *)this + 59) = v7;
  if (!v7) {
    goto LABEL_33;
  }
  if (!*((void *)this + 24))
  {
    id v53 = 0;
    long long v58 = 0u;
    memset(&v57, 0, sizeof(v57));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v54 = 136315906;
    *(void *)&v54[4] = "operator[]";
    *(_WORD *)&v54[12] = 1024;
    *(_DWORD *)&v54[14] = 789;
    *(_WORD *)&v54[18] = 2048;
    *(void *)&v54[20] = 0;
    __int16 v55 = 2048;
    uint64_t v56 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_39:
    re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26), 0, 0, &v53);
  uint64_t v8 = re::RenderGraphDataStore::get<re::CameraData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!*(void *)(v8 + 128)) {
    goto LABEL_39;
  }
  re::Projection::computeMatrix4x4F((re::Projection *)(v8 + 144), (uint64_t)&v57);
  simd_float4x4 v60 = __invert_f4(v57);
  simd_float4 v49 = v60.columns[1];
  simd_float4 v50 = v60.columns[0];
  simd_float4 v47 = v60.columns[3];
  simd_float4 v48 = v60.columns[2];
  v60.columns[0].i32[0] = *((_DWORD *)this + 120);
  float v10 = *((float *)this + 122);
  float v11 = v60.columns[0].f32[0] * (float)((float)(v60.columns[0].f32[0] / *((float *)this + 121)) * 0.5);
  float v12 = v60.columns[0].f32[0] + (float)(v10 * -1000.0);
  float v13 = *((float *)this + 123);
  id v14 = objc_msgSend(v53, sel_height);
  uint64_t v15 = *(re::Allocator **)(*(void *)a2 + 24);
  if (*((unsigned char *)this + 296)) {
    long long v16 = (const char *)*((void *)this + 38);
  }
  else {
    long long v16 = (char *)this + 297;
  }
  memset(&v57, 0, 32);
  float v17 = v11 / v12;
  re::DynamicString::DynamicString((re::DynamicString *)&v57.columns[2], v16, v15);
  int v18 = *((_DWORD *)this + 124);
  if (v18 == 1)
  {
    v57.columns[0].i64[0] = *((void *)this + 58);
    float v19 = 5.0;
    uint64_t v6 = (uint64_t *)((char *)this + 528);
  }
  else if (v18 == 2)
  {
    v57.columns[0].i64[0] = *((void *)this + 59);
    float v19 = 10.0;
  }
  else
  {
    v57.columns[0].i64[0] = *((void *)this + 57);
    float v19 = 5.0;
    uint64_t v6 = (uint64_t *)((char *)this + 504);
  }
  float v20 = v17 / v13;
  uint64_t v21 = (re *)re::AssetHandle::operator=((uint64_t)&v57.columns[0].i64[1], v6);
  float v22 = v19 * 0.25;
  uint64_t v23 = *((void *)a2 + 146);
  unint64_t v24 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE" & 0x8000000000000000) != 0)
  {
    long long v25 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      unint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  float v28 = v20 * (float)(unint64_t)v14;
  unint64_t v29 = (*(void *)(*((void *)a2 + 5) + 48) + (v24 << 6) + (v24 >> 2) - 0x61C8864680B583E9) ^ v24;
  float v30 = v22 / *((float *)this + 122);
  int v31 = re::globalAllocators(v21);
  int v32 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31[2] + 32))(v31[2], 72, 8);
  *int v32 = &unk_26E718360;
  v32[1] = v57.columns[0].i64[0];
  v32[2] = 0;
  v32[3] = 0;
  v32[4] = 0;
  uint64_t v33 = v57.columns[1].i64[0];
  v57.columns[1].i64[0] = 0;
  uint64_t v34 = v32[2];
  v32[2] = v57.columns[0].i64[1];
  *(_OWORD *)(v32 + 3) = __PAIR128__(v57.columns[1].u64[1], v33);
  v57.columns[0].i64[1] = v34;
  v57.columns[1].i64[1] = 0;
  re::DynamicString::DynamicString((re::DynamicString *)(v32 + 5), (const re::DynamicString *)&v57.columns[2]);
  unint64_t v35 = *(void *)(v23 + 16);
  if (!v35
    || (unint64_t v35 = v29 % *(unsigned int *)(v23 + 40),
        uint64_t v36 = *(unsigned int *)(*(void *)(v23 + 24) + 4 * v35),
        v36 == 0x7FFFFFFF))
  {
LABEL_19:
    uint64_t v37 = *(unsigned int *)(v23 + 52);
    if (v37 == 0x7FFFFFFF)
    {
      uint64_t v37 = *(unsigned int *)(v23 + 48);
      int v38 = v37;
      if (v37 == *(_DWORD *)(v23 + 40))
      {
        re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v23 + 16, 2 * *(_DWORD *)(v23 + 44));
        LODWORD(v35) = v29 % *(unsigned int *)(v23 + 40);
        int v38 = *(_DWORD *)(v23 + 48);
      }
      *(_DWORD *)(v23 + 48) = v38 + 1;
      uint64_t v39 = *(void *)(v23 + 32);
      int v40 = *(_DWORD *)(v39 + 24 * v37);
    }
    else
    {
      uint64_t v39 = *(void *)(v23 + 32);
      int v40 = *(_DWORD *)(v39 + 24 * v37);
      *(_DWORD *)(v23 + 52) = v40 & 0x7FFFFFFF;
    }
    uint64_t v41 = 24 * v37;
    *(_DWORD *)(v39 + v41) = v40 | 0x80000000;
    *(_DWORD *)(*(void *)(v23 + 32) + v41) = *(_DWORD *)(*(void *)(v23 + 32) + 24 * v37) & 0x80000000 | *(_DWORD *)(*(void *)(v23 + 24) + 4 * v35);
    *(void *)(*(void *)(v23 + 32) + 24 * v37 + 8) = v29;
    *(void *)(*(void *)(v23 + 32) + 24 * v37 + 16) = v32;
    *(_DWORD *)(*(void *)(v23 + 24) + 4 * v35) = v37;
    ++*(_DWORD *)(v23 + 44);
    ++*(_DWORD *)(v23 + 56);
    goto LABEL_25;
  }
  uint64_t v45 = *(void *)(v23 + 32);
  while (*(void *)(v45 + 24 * v36 + 8) != v29)
  {
    LODWORD(v36) = *(_DWORD *)(v45 + 24 * v36) & 0x7FFFFFFF;
    if (v36 == 0x7FFFFFFF) {
      goto LABEL_19;
    }
  }
LABEL_25:
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x60uLL, 0x10uLL, (uint64_t)v54);
  unsigned int v42 = *(void **)&v54[16];
  uint64_t v46 = *(void *)&v54[8];
  uint64_t v43 = (simd_float4 *)(*(void *)v54 + *(unsigned int *)&v54[8]);
  *uint64_t v43 = v50;
  v43[1] = v49;
  v43[2] = v48;
  v43[3] = v47;
  v43[4].f32[0] = v10;
  v43[4].f32[1] = v28;
  v43[4].f32[2] = v19;
  v43[4].f32[3] = 1.0 / v19;
  v43[5].f32[0] = v22;
  v43[5].f32[1] = v30;
  *(void *)uint64_t v54 = v42;
  *(void *)&v54[8] = v46;
  uint64_t v44 = (re::BufferTable *)(*(void *)a2 + 480);
  uint64_t v51 = 0x248FEBCC4417DE54;
  re::BufferTable::setBuffer(v44, (const re::WeakStringID *)&v51, (uint64_t)v54);
  re::RenderGraphFullscreenNode::executeInternal(this, a2, (re::RenderGraphDofSetupNode *)((char *)this + 264));
  if (*(void *)v54) {

  }
  if (v57.columns[2].i64[0])
  {
    if (v57.columns[2].i8[8]) {
      (*(void (**)(void))(*(void *)v57.columns[2].i64[0] + 40))();
    }
    memset(&v57.columns[2], 0, 32);
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v57.columns[0].u32[2]);
  if (v53) {

  }
LABEL_33:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v52);
}

void re::RenderGraphDofSetupNode::getMaterialParameterTables(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 496);
  if (v4 == 1)
  {
    if (!*(void *)(a1 + 536)) {
      goto LABEL_20;
    }
    uint64_t v9 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 528));
    if (!v9) {
      goto LABEL_20;
    }
    uint64_t v6 = *(re::MaterialParameterBlock **)(v9 + 1672);
    if (!v6) {
      goto LABEL_20;
    }
    unint64_t v7 = *(void *)(a1 + 536);
    if (!v7) {
      goto LABEL_7;
    }
  }
  else if (v4 == 2)
  {
    if (!*(void *)(a1 + 560)) {
      goto LABEL_20;
    }
    uint64_t v5 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 552));
    if (!v5) {
      goto LABEL_20;
    }
    uint64_t v6 = *(re::MaterialParameterBlock **)(v5 + 1672);
    if (!v6) {
      goto LABEL_20;
    }
    unint64_t v7 = *(void *)(a1 + 560);
    if (!v7)
    {
LABEL_7:
      uint64_t v8 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    if (!*(void *)(a1 + 512)) {
      goto LABEL_20;
    }
    uint64_t v10 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 504));
    if (!v10) {
      goto LABEL_20;
    }
    uint64_t v6 = *(re::MaterialParameterBlock **)(v10 + 1672);
    if (!v6) {
      goto LABEL_20;
    }
    unint64_t v7 = *(void *)(a1 + 512);
    if (!v7) {
      goto LABEL_7;
    }
  }
  uint64_t v8 = *(void *)(v7 + 664);
LABEL_18:
  unint64_t v11 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
  unint64_t v13 = v8 ^ (v11 >> 31) ^ v11;
  re::MaterialParameterBlock::createMaterialParameterTableIfNeeded(v6, &v12);
  re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a2, &v13, &v12);
  if (v12) {

  }
LABEL_20:
  re::RenderGraphFullscreenNode::getMaterialParameterTables(a1, a2);
}

void re::RenderGraphDofBokehBlurNode::execute(re::RenderGraphDofBokehBlurNode *this, re::RenderGraphContext *a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12, 5050, 0);
  uint64_t v4 = *((void *)a2 + 146);
  unint64_t v5 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_28DepthOfFieldBlurMaterialDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  *(void *)buf = (*(void *)(*((void *)a2 + 5) + 48) + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5;
  uint64_t v9 = (re *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v4 + 16, (uint64_t *)buf);
  if (v9 && (uint64_t v10 = *(void **)v9) != 0)
  {
    *((void *)this + 40) = v10[1];
    re::DynamicString::operator=((re::RenderGraphDofBokehBlurNode *)((char *)this + 288), (re::DynamicString *)(v10 + 5));
    re::RenderGraphFullscreenNode::executeInternal(this, a2, (const re::AssetHandle *)(v10 + 2));
  }
  else
  {
    unint64_t v11 = *re::graphicsLogObjects(v9);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "RenderGraphDofBokehBlurNode expects DepthOfFieldBlurMaterialDataWrapper from the render graph                         data store but there isn't any. Will skip the execution. Did you forget to add a RenderGraphDofSetupNode?", buf, 2u);
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12);
}

void re::RenderGraphDofCompositeNode::configure(re::RenderGraphDofCompositeNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((void *)this + 61)) {
    re::AssetHandle::loadAsync((re::RenderGraphDofCompositeNode *)((char *)this + 480));
  }
  if (*((void *)this + 64)) {
    re::AssetHandle::loadAsync((re::RenderGraphDofCompositeNode *)((char *)this + 504));
  }
  re::RenderGraphFullscreenNode::configure(this, a2, a3, a4);
}

void re::RenderGraphDofCompositeNode::execute(re::RenderGraphDofCompositeNode *this, re::RenderGraphContext *a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v6, 5052, 0);
  uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDofCompositeNode *)((char *)this + 480));
  *((void *)this + 57) = v4;
  if (v4)
  {
    uint64_t v5 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDofCompositeNode *)((char *)this + 504));
    *((void *)this + 58) = v5;
    if (v5)
    {
      if (!*((unsigned char *)this + 472)) {
        uint64_t v5 = *((void *)this + 57);
      }
      *((void *)this + 40) = v5;
      re::RenderGraphFullscreenNode::executeInternal(this, a2, (re::RenderGraphDofCompositeNode *)((char *)this + 264));
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v6);
}

void re::RenderGraphDofCompositeNode::getMaterialParameterTables(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 504));
  if (v4)
  {
    uint64_t v5 = *(re::MaterialParameterBlock **)(v4 + 1672);
    if (v5)
    {
      unint64_t v6 = *(void *)(a1 + 272);
      if (v6) {
        uint64_t v7 = *(void *)(v6 + 664);
      }
      else {
        uint64_t v7 = 0;
      }
      unint64_t v8 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
      unint64_t v10 = v7 ^ (v8 >> 31) ^ v8;
      re::MaterialParameterBlock::createMaterialParameterTableIfNeeded(v5, &v9);
      re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a2, &v10, &v9);
      if (v9) {
    }
      }
  }
}

void re::introspect_DepthOfFieldQualityProfile(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99D90, memory_order_acquire) & 1) == 0)
  {
    unint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF99D90);
    if (v24)
    {
      long long v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Low";
      qword_26AF99DD8 = (uint64_t)v26;
      unsigned int v27 = re::introspectionAllocator(v26);
      float v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)float v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Medium";
      qword_26AF99DE0 = (uint64_t)v28;
      unint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = 2;
      *(void *)(v30 + 16) = "High";
      qword_26AF99DE8 = v30;
      __cxa_guard_release(&qword_26AF99D90);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99D98, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99D98))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF99E10, "DepthOfFieldQualityProfile", 4, 4, 1, 1);
    qword_26AF99E10 = (uint64_t)&unk_26E715E00;
    qword_26AF99E50 = (uint64_t)&re::introspect_DepthOfFieldQualityProfile(BOOL)::enumTable;
    dword_26AF99E20 = 9;
    __cxa_guard_release(&qword_26AF99D98);
  }
  if ((_MergedGlobals_437 & 1) == 0)
  {
    _MergedGlobals_437 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF99E10, a2);
    uint64_t v32 = 0xBD83B9DA93A8E214;
    uint64_t v33 = "DepthOfFieldQualityProfile";
    v36[0] = 208862;
    v36[1] = "int";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v36);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v36);
      uint64_t v4 = (unsigned int *)qword_26AF99E50;
      v35[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v36, &v32, 1, 1, (uint64_t)v35);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v34.var0 = 2 * v10;
            v34.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v36, v14, &v34);
            re::StringID::destroyString((re::StringID *)&v34);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              float v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    float v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v34.var0 = 2 * v18;
              v34.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v36, v22, &v34);
              re::StringID::destroyString((re::StringID *)&v34);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v36, v23);
      xmmword_26AF99E30 = (__int128)v34;
      re::StringID::destroyString((re::StringID *)&v32);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "DepthOfFieldQualityProfile", v32, v33);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RenderGraphDofSetupNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99DA0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99EA0, "RenderGraphDofSetupNode");
    __cxa_guard_release(&qword_26AF99DA0);
  }
  return &unk_26AF99EA0;
}

void re::initInfo_RenderGraphDofSetupNode(re *this, re::IntrospectionBase *a2)
{
  v40[0] = 0xA4807A93825450F8;
  v40[1] = "RenderGraphDofSetupNode";
  re::StringID::destroyString((re::StringID *)v40);
  *((_OWORD *)this + 2) = v41;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DA8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99DA8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99E58 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_float((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "focalLength";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1E000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99E60 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_float((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "aperture";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x1E400000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF99E68 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_float((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "focalDistance";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x1E800000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF99E70 = v19;
      float v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_float((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "sensorSize";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x1EC00000004;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF99E78 = v23;
      unint64_t v24 = (re *)re::introspectionAllocator((re *)v23);
      re::introspect_DepthOfFieldQualityProfile(v24, v25);
      uint64_t v26 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *(void *)(v26 + 8) = "qualityProfile";
      *(void *)(v26 + 16) = &qword_26AF99E10;
      *(void *)(v26 + 24) = 0;
      *(void *)(v26 + 32) = 0x1F000000005;
      *(_DWORD *)(v26 + 40) = 0;
      *(void *)(v26 + 48) = 0;
      *(void *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_26AF99E80 = v26;
      unsigned int v27 = re::introspectionAllocator((re *)v26);
      unint64_t v29 = re::introspect_AssetHandle((re *)1, v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 72, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = "blurMaterialLowQuality";
      *(void *)(v30 + 16) = v29;
      *(void *)(v30 + 24) = 0;
      *(void *)(v30 + 32) = 0x1F800000006;
      *(_DWORD *)(v30 + 40) = 0;
      *(void *)(v30 + 48) = 0;
      *(void *)(v30 + 56) = 0;
      *(_DWORD *)(v30 + 64) = 0;
      qword_26AF99E88 = v30;
      uint64_t v31 = re::introspectionAllocator((re *)v30);
      uint64_t v33 = re::introspect_AssetHandle((re *)1, v32);
      uint64_t v34 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 72, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *(void *)(v34 + 8) = "blurMaterialMediumQuality";
      *(void *)(v34 + 16) = v33;
      *(void *)(v34 + 24) = 0;
      *(void *)(v34 + 32) = 0x21000000007;
      *(_DWORD *)(v34 + 40) = 0;
      *(void *)(v34 + 48) = 0;
      *(void *)(v34 + 56) = 0;
      *(_DWORD *)(v34 + 64) = 0;
      qword_26AF99E90 = v34;
      unint64_t v35 = re::introspectionAllocator((re *)v34);
      uint64_t v37 = re::introspect_AssetHandle((re *)1, v36);
      uint64_t v38 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 72, 8);
      *(_DWORD *)uint64_t v38 = 1;
      *(void *)(v38 + 8) = "blurMaterialHighQuality";
      *(void *)(v38 + 16) = v37;
      *(void *)(v38 + 24) = 0;
      *(void *)(v38 + 32) = 0x22800000008;
      *(_DWORD *)(v38 + 40) = 0;
      *(void *)(v38 + 48) = 0;
      *(void *)(v38 + 56) = 0;
      *(_DWORD *)(v38 + 64) = 0;
      qword_26AF99E98 = v38;
      __cxa_guard_release(&qword_26AF99DA8);
    }
  }
  *((void *)this + 2) = 0x24000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 9;
  *((void *)this + 8) = &qword_26AF99E58;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDofSetupNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDofSetupNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDofSetupNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDofSetupNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v39 = v41;
}

double re::internal::defaultConstruct<re::RenderGraphDofSetupNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v3 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)uint64_t v3 = &unk_26E718150;
  *((void *)v3 + 58) = 0;
  *((void *)v3 + 59) = 0;
  *((void *)v3 + 57) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)v3 + 504) = 0u;
  *(_OWORD *)((char *)v3 + 520) = 0u;
  *(_OWORD *)((char *)v3 + 536) = 0u;
  *(_OWORD *)((char *)v3 + 552) = 0u;
  *((void *)v3 + 71) = 0;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphDofSetupNode>(int a1, int a2, id *this)
{
}

double re::internal::defaultConstructV2<re::RenderGraphDofSetupNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v1 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)uint64_t v1 = &unk_26E718150;
  *((void *)v1 + 58) = 0;
  *((void *)v1 + 59) = 0;
  *((void *)v1 + 57) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)v1 + 504) = 0u;
  *(_OWORD *)((char *)v1 + 520) = 0u;
  *(_OWORD *)((char *)v1 + 536) = 0u;
  *(_OWORD *)((char *)v1 + 552) = 0u;
  *((void *)v1 + 71) = 0;
  return result;
}

uint64_t re::introspect_RenderGraphDofSetupNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDofSetupNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDofSetupNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDofSetupNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDofSetupNode>, this);
}

void *re::allocInfo_RenderGraphDofBokehBlurNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DB0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99DB0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99F18, "RenderGraphDofBokehBlurNode");
    __cxa_guard_release(&qword_26AF99DB0);
  }
  return &unk_26AF99F18;
}

void re::initInfo_RenderGraphDofBokehBlurNode(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0xB7007C36957F51CELL;
  v9[1] = "RenderGraphDofBokehBlurNode";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DC0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99DC0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99DB8 = v7;
      __cxa_guard_release(&qword_26AF99DC0);
    }
  }
  *((void *)this + 2) = 0x1C800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF99DB8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDofBokehBlurNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDofBokehBlurNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDofBokehBlurNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDofBokehBlurNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

re::RenderGraphFullscreenNode *re::internal::defaultConstruct<re::RenderGraphDofBokehBlurNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  double result = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)double result = &unk_26E7181F8;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphDofBokehBlurNode>(int a1, int a2, id *this)
{
}

re::RenderGraphFullscreenNode *re::internal::defaultConstructV2<re::RenderGraphDofBokehBlurNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  double result = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)double result = &unk_26E7181F8;
  return result;
}

uint64_t re::introspect_RenderGraphDofBokehBlurNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDofBokehBlurNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDofBokehBlurNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDofBokehBlurNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDofBokehBlurNode>, this);
}

void *re::allocInfo_RenderGraphDofCompositeNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF99DC8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF99F90, "RenderGraphDofCompositeNode");
    __cxa_guard_release(&qword_26AF99DC8);
  }
  return &unk_26AF99F90;
}

void re::initInfo_RenderGraphDofCompositeNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0xCCEAEE98621BAA0CLL;
  v21[1] = "RenderGraphDofCompositeNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF99DD0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF99DD0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF99DF0 = v7;
      long long v8 = re::introspectionAllocator((re *)v7);
      long long v10 = re::introspect_BOOL((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "debugPassthrough";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1D800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF99DF8 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_AssetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "compositeMaterial";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x1E000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF99E00 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_AssetHandle((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "debugPassthroughMaterial";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x1F800000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF99E08 = v19;
      __cxa_guard_release(&qword_26AF99DD0);
    }
  }
  *((void *)this + 2) = 0x21000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF99DF0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDofCompositeNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDofCompositeNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDofCompositeNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDofCompositeNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

double re::internal::defaultConstruct<re::RenderGraphDofCompositeNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v3 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)uint64_t v3 = &unk_26E7182A0;
  *((void *)v3 + 57) = 0;
  *((void *)v3 + 58) = 0;
  double result = 0.0;
  *((_OWORD *)v3 + 30) = 0u;
  *((_OWORD *)v3 + 31) = 0u;
  *((_OWORD *)v3 + 32) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphDofCompositeNode>(uint64_t a1, uint64_t a2, id *a3)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 63));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 60));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(a3);
}

double re::internal::defaultConstructV2<re::RenderGraphDofCompositeNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v1 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)uint64_t v1 = &unk_26E7182A0;
  *((void *)v1 + 57) = 0;
  *((void *)v1 + 58) = 0;
  double result = 0.0;
  *((_OWORD *)v1 + 30) = 0u;
  *((_OWORD *)v1 + 31) = 0u;
  *((_OWORD *)v1 + 32) = 0u;
  return result;
}

void re::internal::defaultDestructV2<re::RenderGraphDofCompositeNode>(id *a1)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 63));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 60));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(a1);
}

uint64_t re::introspect_RenderGraphDofCompositeNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDofCompositeNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDofCompositeNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDofCompositeNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDofCompositeNode>, this);
}

void re::RenderGraphDofSetupNode::~RenderGraphDofSetupNode(id *this)
{
  re::RenderGraphDofSetupNode::~RenderGraphDofSetupNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t vars8;

  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 69));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 66));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 63));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
}

void re::RenderGraphDofBokehBlurNode::~RenderGraphDofBokehBlurNode(id *this)
{
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphDofCompositeNode::~RenderGraphDofCompositeNode(id *this)
{
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 63));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 60));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
}

{
  uint64_t vars8;

  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 63));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 60));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::get<re::CameraData>(uint64_t a1, uint64_t a2)
{
  void v11[2] = *MEMORY[0x263EF8340];
  {
    re::introspect<re::CameraData>(void)::mach_timebase_info info = (_UNKNOWN *)re::introspect_CameraData(0);
  }
  size_t v4 = strlen(*((const char **)re::introspect<re::CameraData>(void)::info + 6));
  if (v4)
  {
    MurmurHash3_x64_128(*((void *)re::introspect<re::CameraData>(void)::info + 6), v4, 0, v11);
    unint64_t v5 = (v11[1] - 0x61C8864680B583E9 + (v11[0] << 6) + (v11[0] >> 2)) ^ v11[0];
  }
  else
  {
    unint64_t v5 = 0;
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 - 0x61C8864680B583E9 + (v5 << 6) + (v5 >> 2)) ^ v5;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

void *re::RenderGraphDataStoreWrapper<re::DepthOfFieldBlurMaterialData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E718360;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 2));
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::DepthOfFieldBlurMaterialData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E718360;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 5));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 2));
  JUMPOUT(0x237DBCBD0);
}

void re::BloomUserParameters::computeRenderParameters(re::BloomUserParameters *this@<X0>, uint64_t a2@<X8>)
{
  int v3 = *((_DWORD *)this + 1);
  int v4 = *((_DWORD *)this + 3);
  float v5 = *((float *)this + 2) + 1.0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(float *)(a2 + 4) = v5;
  *(_DWORD *)(a2 + 8) = v3;
  unsigned int v6 = vcvtps_s32_f32(v5);
  int v7 = 3 * v6;
  *(_DWORD *)(a2 + 12) = v4;
  *(_DWORD *)(a2 + 16) = 3 * v6;
  if ((v6 & 0x80000000) == 0)
  {
    int v8 = -3 * v6;
    if (v7 >= 0) {
      int v9 = 3 * v6;
    }
    else {
      int v9 = -3 * v6;
    }
    int v10 = v9 + 1;
    uint64_t v11 = (float *)(a2 + 4 * (v8 + (uint64_t)v7) + 20);
    do
    {
      float v12 = *(float *)(a2 + 4);
      *v11++ = (float)(1.0 / (float)(v12 * 2.5066))
             * expf((float)-(float)((float)v8 * (float)v8) / (float)(v12 * (float)(v12 + v12)));
      ++v8;
    }
    while (v10 != v8);
  }
}

void re::RenderGraphUploadBloomParams::setup(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 592) = 1;
}

void re::RenderGraphUploadBloomParams::execute(re::RenderGraphUploadBloomParams *this, re::FrameContext **a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v23, 5058, 0);
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  re::BloomUserParameters::computeRenderParameters((re::RenderGraphUploadBloomParams *)((char *)this + 256), (uint64_t)&v13);
  re::FrameContext::perFrameAlloc(*a2, 0x98uLL, 4uLL, (uint64_t)&v24);
  int v4 = v26;
  uint64_t v12 = v25;
  float v5 = &v24[v25];
  long long v6 = v20;
  *((_OWORD *)v5 + 6) = v19;
  *((_OWORD *)v5 + 7) = v6;
  *((_OWORD *)v5 + 8) = v21;
  *((void *)v5 + 18) = v22;
  long long v7 = v16;
  *((_OWORD *)v5 + 2) = v15;
  *((_OWORD *)v5 + 3) = v7;
  long long v8 = v18;
  *((_OWORD *)v5 + 4) = v17;
  *((_OWORD *)v5 + 5) = v8;
  long long v9 = v14;
  *(_OWORD *)float v5 = v13;
  *((_OWORD *)v5 + 1) = v9;
  uint64_t v10 = re::RenderGraphDataStore::add<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(a2[146], *((void *)a2[5] + 6));
  *(_DWORD *)(v10 + 24) = HIDWORD(v13);
  unint64_t v24 = v4;
  uint64_t v25 = v12;
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v10 + 8), (void **)&v24);
  uint64_t v11 = v24;
  *(void *)(v10 + 16) = v25;
  if (v11) {

  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v23);
}

void re::RenderGraphDownsampleThresholdNode::configure(re::RenderGraphDownsampleThresholdNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((void *)this + 34)) {
    re::AssetHandle::loadAsync((re::RenderGraphDownsampleThresholdNode *)((char *)this + 264));
  }
  re::RenderGraphNode::configure(this, a2, a3, a4);
}

void re::RenderGraphDownsampleThresholdNode::execute(re::RenderGraphDownsampleThresholdNode *this, re::RenderGraphContext *a2)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  uint64_t v6 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::RenderGraphDownsampleThresholdNode *)((char *)this + 264));
  *((void *)this + 32) = v6;
  if (!v6) {
    return;
  }
  uint64_t v7 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(*((void *)this + 32) + 1664);
    unint64_t v10 = *((void *)this + 34);
    if (v10) {
      uint64_t v11 = *(void *)(v10 + 664);
    }
    else {
      uint64_t v11 = 0;
    }
    unint64_t v13 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) >> 27));
    *(void *)buf = v11 ^ (v13 >> 31) ^ v13;
    long long v14 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)a2 + 1568, (uint64_t *)buf);
    if (v14) {
      uint64_t v15 = *v14;
    }
    else {
      uint64_t v15 = 0;
    }
    re::RenderGraphContext::makeFullscreenDrawCall(a2, v9, v15, 0, 0, 0, (int32x2_t *)buf);
    uint64_t v16 = v46;
    MurmurHash3_x64_128((uint64_t)"fullscreen", 10, 0, (unint64_t *)v61);
    long long v17 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v16, (*(void *)&v61[8] + (*(void *)v61 << 6) + (*(void *)v61 >> 2) - 0x61C8864680B583E9) ^ *(void *)v61);
    if (v18)
    {
      int v45 = *v17;
      if (v45 == -1) {
        return;
      }
      uint64_t v2 = &v48;
      uint64_t v3 = 0xA3521511A35B9;
      uint64_t v19 = *(void *)a2;
      v41[0] = 0xA3521511A35B9;
      if (!*((void *)this + 24)) {
        goto LABEL_33;
      }
      long long v20 = (void *)(v19 + 368);
      re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26), 0, 0, (id *)v61);
      re::DynamicTextureTableAdd(v20, v41, (id *)v61);
      if (*(void *)v61) {

      }
      uint64_t v16 = 0x127DBE076EDDD69;
      long long v21 = (re::BufferTable *)(*(void *)a2 + 480);
      *(void *)float v61 = 0x127DBE076EDDD69;
      re::BufferTable::setBuffer(v21, (const re::WeakStringID *)v61, v8 + 8);
      uint64_t v22 = re::RenderGraphDataStore::tryGet<re::CameraData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
      uint64_t v43 = 0;
      uint64_t v40 = 0;
      memset(v41, 0, sizeof(v41));
      int v42 = 0;
      memset(v38, 0, sizeof(v38));
      int v39 = 0;
      if (v22)
      {
        uint64_t v23 = v22;
        if (*(void *)(v22 + 128))
        {
          unint64_t v24 = 0;
          uint64_t v3 = 0;
          while (1)
          {
            re::Projection::computeMatrix4x4F((re::Projection *)(v23 + 144 + (v24 << 6)), (uint64_t)v61);
            *(void *)&double v26 = re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v41, (uint64_t)v61).n128_u64[0];
            unint64_t v27 = *(void *)(v23 + 48);
            if (v27 <= v24) {
              break;
            }
            re::RenderCamera::computeInverseTransform((float32x4_t *)(v23 + 64 + 32 * v24), (uint64_t)v61);
            re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v38, (uint64_t)v61);
            uint64_t v3 = (v3 + 1);
            unint64_t v24 = v3;
            if (*(void *)(v23 + 128) <= (unint64_t)v3) {
              goto LABEL_21;
            }
          }
          re::internal::assertLog((re::internal *)6, v25, v26, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v24, v27);
          _os_crash();
          __break(1u);
          goto LABEL_32;
        }
LABEL_21:
        char v28 = *(unsigned char *)(v23 + 490);
        uint64_t v3 = 0xA3521511A35B9;
      }
      else
      {
        *(_OWORD *)float v61 = xmmword_23435FD50;
        *(_OWORD *)&v61[16] = xmmword_23435FD60;
        long long v62 = xmmword_23435FD80;
        *(_OWORD *)uint64_t v63 = xmmword_23435FBB0;
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v41, (uint64_t)v61);
        *(_OWORD *)float v61 = xmmword_23435FD50;
        *(_OWORD *)&v61[16] = xmmword_23435FD60;
        long long v62 = xmmword_23435FD80;
        *(_OWORD *)uint64_t v63 = xmmword_23435FBB0;
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v38, (uint64_t)v61);
        char v28 = 1;
      }
      re::DrawCallRef::DrawCallRef(&v33, (const re::DrawCall *)buf);
      uint64_t v29 = 0;
      *(void *)float v61 = &v33;
      *(void *)&unsigned char v61[24] = &v34;
      *(void *)uint64_t v63 = &v35;
      unint64_t v64 = &v36;
      *(int64x2_t *)&v61[8] = vdupq_n_s64(1uLL);
      long long v62 = *(_OWORD *)&v61[8];
      *(_OWORD *)&v63[8] = *(_OWORD *)&v61[8];
      long long v65 = *(_OWORD *)&v61[8];
      uint64_t v66 = &v37;
      long long v67 = *(_OWORD *)&v61[8];
      simd_float4 v48 = "fullscreen";
      simd_float4 v49 = v61;
      uint64_t v50 = v40;
      uint64_t v51 = v43;
      uint64_t v52 = 0;
      char v53 = v28;
      __int16 v54 = 2;
      __int16 v55 = 0;
      long long v56 = 0u;
      long long v57 = 0u;
      char v58 = 0;
      if (!*((unsigned char *)a2 + 1332)) {
        goto LABEL_24;
      }
      goto LABEL_34;
    }
LABEL_32:
    re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_33:
    v47[0] = 0;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    a2 = (re::RenderGraphContext *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v48) = 136315906;
    *(const char **)((char *)v2 + 4) = "operator[]";
    WORD2(v49) = 1024;
    *(_DWORD *)((char *)v2 + 14) = 789;
    WORD1(v50) = 2048;
    *(const char **)((char *)v2 + 20) = 0;
    WORD2(v51) = 2048;
    *(const char **)((char *)v2 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_34:
    uint64_t v29 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)a2 + 1336), *((const char **)this + 2), "fullscreen");
LABEL_24:
    uint64_t v59 = v29;
    char v60 = 0;
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(a2, v47);
    re::RenderGraphContext::encodeDrawCalls(a2, v47, &v48);
    uint64_t v30 = (re *)(*(void *)a2 + 368);
    v47[0] = v3;
    re::DynamicTextureTableRemove(v30, (re::TextureTable *)v47, v31);
    uint64_t v32 = (re::BufferTable *)(*(void *)a2 + 480);
    v47[0] = v16;
    re::BufferTable::removeBuffer(v32, (const re::WeakStringID *)v47);
    if (v38[0] && v40) {
      (*(void (**)(void, uint64_t))(*(void *)v38[0] + 40))(v38[0], v40);
    }
    if (v41[0])
    {
      if (v43) {
        (*(void (**)(void, uint64_t))(*(void *)v41[0] + 40))(v41[0], v43);
      }
    }
    return;
  }
  uint64_t v12 = *re::graphicsLogObjects(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "RenderGraphDownsampleThresholdNode expects BloomExecDataWrapper from the render graph data store but there isn't any.                          Will skip the execution. Did you forget to add a upload node?", buf, 2u);
  }
}

void re::RenderGraphDownsampleThresholdNode::getMaterialParameterTables(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 272))
  {
    uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(a1 + 264));
    if (v4)
    {
      float v5 = *(re::MaterialParameterBlock **)(v4 + 1672);
      if (v5)
      {
        unint64_t v6 = *(void *)(a1 + 272);
        if (v6) {
          uint64_t v7 = *(void *)(v6 + 664);
        }
        else {
          uint64_t v7 = 0;
        }
        unint64_t v8 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
        unint64_t v10 = v7 ^ (v8 >> 31) ^ v8;
        re::MaterialParameterBlock::createMaterialParameterTableIfNeeded(v5, &v9);
        re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a2, &v10, &v9);
        if (v9) {
      }
        }
    }
  }
}

uint64_t re::RenderGraphDownsampleBlur::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  v10[0] = 0;
  uint64_t v16 = 0;
  memset(v14, 0, sizeof(v14));
  int v15 = 0;
  char v17 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  char v20 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v10);
  NS::SharedPtr<MTL::Texture>::operator=(this + 39, ComputePipelineState);
  re::RenderGraphNode::configure((re::RenderGraphNode *)this, a2, a3, a4);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v14);
  uint64_t result = v13[0];
  if (v13[0])
  {
    if (v13[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v13[0] + 40))();
    }
    memset(v13, 0, sizeof(v13));
  }
  if (v10[0])
  {
    uint64_t result = v11;
    if (v11)
    {
      if (v12) {
        return (*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::RenderGraphDownsampleBlur::setup(re::RenderGraphDownsampleBlur *this, re::GrowableLinearAllocator **a2, re::RenderGraphDataStore *a3)
{
  uint64_t v4 = this;
  uint64_t v23 = *MEMORY[0x263EF8340];
  float v5 = (char *)this + 256;
  *(_DWORD *)((char *)&v16 + 3) = 0;
  LODWORD(v16) = 0;
  *((void *)&v16 + 1) = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)this + 256, (uint64_t)&v16);
  *(void *)&long long v16 = 0x500000000;
  long long v17 = xmmword_23435FBB0;
  LOWORD(v18) = 0;
  *(void *)((char *)&v18 + 4) = 0;
  re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)v5, (uint64_t)&v16);
  unint64_t v6 = (long long *)re::RenderGraphCompiled::targetDescription((uint64_t)a2, (uint64_t)v5);
  long long v7 = v6[5];
  long long v8 = v6[6];
  long long v9 = v6[3];
  long long v20 = v6[4];
  long long v10 = v6[1];
  long long v11 = v6[2];
  long long v16 = *v6;
  long long v17 = v10;
  long long v18 = v11;
  long long v19 = v9;
  long long v21 = v7;
  long long v22 = v8;
  HIDWORD(v20) = *((_DWORD *)v4 + 67);
  re::RenderGraphResourceDescriptions::addTarget(a2, (const re::RenderGraphTargetDescription *)&v16, "scratchTarget", v13);
  uint64_t v4 = (re::RenderGraphDownsampleBlur *)((char *)v4 + 296);
  *(_OWORD *)uint64_t v4 = v13[0];
  *(_DWORD *)((char *)v13 + 3) = 0;
  LODWORD(v13[0]) = 0;
  *((void *)&v13[0] + 1) = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)v4, (uint64_t)v13);
  *(void *)&v13[0] = 0x500000000;
  v13[1] = xmmword_23435FBB0;
  __int16 v14 = 0;
  uint64_t v15 = 0;
  return re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)v4, (uint64_t)v13);
}

void re::RenderGraphDownsampleBlur::execute(re::RenderGraphDownsampleBlur *this, re::RenderGraphContext *a2)
{
  v48[1] = *MEMORY[0x263EF8340];
  uint64_t v34 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (v34)
  {
    uint64_t v4 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v4, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v41);
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 256, 0, 0, &v40);
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 296, 0, 0, &v39);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A070, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A070))
    {
      uint64_t v30 = re::ns::String::String((re::ns::String *)&qword_26AF9A068, (re::ns *)"Bloom Blur Downsampled Mipmap");
      __cxa_guard_release((__guard *)v30 + 1);
    }
    id v5 = (id)qword_26AF9A068;
    [v41 setLabel:v5];

    [v41 setComputePipelineState:*((void *)this + 39)];
    id v6 = v40;
    id v7 = objc_msgSend(v40, sel_pixelFormat);
    id v8 = objc_msgSend(v6, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v7, 2, (char *)objc_msgSend(v40, sel_mipmapLevelCount) - 1, 1, 0, 1);
    [v41 setTexture:v8 atIndex:2];
    [v41 setBuffer:*(void *)(v34 + 8) offset:*(unsigned int *)(v34 + 16) atIndex:0];
    unsigned int v32 = objc_msgSend(*((id *)this + 39), sel_threadExecutionWidth);
    unsigned int v9 = objc_msgSend(*((id *)this + 39), sel_maxTotalThreadsPerThreadgroup);
    uint64_t v10 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
    if (v10)
    {
      if (!*(void *)(v10 + 16))
      {
        re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, 0, 0);
        _os_crash();
        __break(1u);
      }
      long long v12 = *(_OWORD *)(v10 + 32);
    }
    else
    {
      long long v12 = xmmword_2343854A0;
    }
    int8x16_t v33 = (int8x16_t)v12;
    uint64_t v31 = a2;
    uint64_t v14 = *((void *)a2 + 1);
    id v38 = v41;
    re::RenderManager::sampleComputeEncoderMTLCounterBegin(v14, &v38, 1u);

    if (*(_DWORD *)(v34 + 24))
    {
      uint64_t v15 = 0;
      uint64_t v16 = v9 / v32;
      float32x2_t v17 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      while (1)
      {
        id v18 = objc_msgSend(v40, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, objc_msgSend(v40, sel_pixelFormat), 2, v15, 1, 0, 1);
        id v19 = objc_msgSend(v39, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, objc_msgSend(v39, sel_pixelFormat), 2, v15, 1, 0, 1);
        unsigned int v20 = objc_msgSend(v18, sel_width);
        float32x2_t v21 = vcvt_f32_s32((int32x2_t)vand_s8((int8x8_t)__PAIR64__(objc_msgSend(v18, sel_height), v20), (int8x8_t)0xFFFF0000FFFFLL));
        int16x4_t v22 = (int16x4_t)vcvt_s32_f32(vrndp_f32(vmla_f32((float32x2_t)0xBF000000BF000000, *(float32x2_t *)v33.i8, v21)));
        int16x4_t v23 = (int16x4_t)vcvt_s32_f32(vrndm_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v17, v21)));
        int8x8_t v24 = vmvn_s8((int8x8_t)vceq_s32((int32x2_t)v23, (int32x2_t)v22));
        if ((v24.i32[0] & v24.i32[1] & 1) == 0) {
          break;
        }
        unsigned __int16 v25 = v23.i16[2] - v22.i16[2];
        unsigned __int16 v26 = v23.i16[0] - v22.i16[0];
        v48[0] = vuzp1_s16(v22, v23);
        [v41 setBytes:v48 length:8 atIndex:2];
        uint64_t v27 = (v32 - 1 + v26) / v32;
        uint64_t v28 = (v16 - 1 + v25) / v16;
        [v41 setTexture:v18 atIndex:0];
        [v41 setTexture:v19 atIndex:1];
        int v37 = 0;
        [v41 setBytes:&v37 length:4 atIndex:1];
        *(void *)buf = v27;
        uint64_t v46 = v28;
        uint64_t v47 = 1;
        uint64_t v42 = v32;
        uint64_t v43 = v16;
        uint64_t v44 = 1;
        [v41 dispatchThreadgroups:buf threadsPerThreadgroup:&v42];
        [v41 setTexture:v19 atIndex:0];
        [v41 setTexture:v18 atIndex:1];
        int v36 = 1;
        [v41 setBytes:&v36 length:4 atIndex:1];
        *(void *)buf = v27;
        uint64_t v46 = v28;
        uint64_t v47 = 1;
        uint64_t v42 = v32;
        uint64_t v43 = v16;
        uint64_t v44 = 1;
        [v41 dispatchThreadgroups:buf threadsPerThreadgroup:&v42];
        if (v19) {

        }
        if (v18) {
        if (++v15 >= (unint64_t)*(unsigned int *)(v34 + 24))
        }
          goto LABEL_22;
      }
      if (v19) {

      }
      if (v18) {
    }
      }
LABEL_22:
    uint64_t v29 = *((void *)v31 + 1);
    id v35 = v41;
    re::RenderManager::sampleComputeEncoderMTLCounterEnd(v29, &v35, 1u);

    if (v8) {
    if (v39)
    }

    if (v40) {
  }
    }
  else
  {
    unint64_t v13 = *re::graphicsLogObjects(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "RenderGraphDownsampleBlur expects BloomExecDataWrapper from the render graph data store but there isn't any.                          Will skip the execution. Did you forget to add a upload node?", buf, 2u);
    }
  }
}

void re::RenderGraphBloomNode::execute(re::RenderGraphBloomNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (v4)
  {
    id v5 = (re::BufferTable *)(*(void *)a2 + 480);
    *(void *)id v8 = 0x127DBE076EDDD69;
    re::BufferTable::setBuffer(v5, (const re::WeakStringID *)v8, v4 + 8);
    re::RenderGraphFullscreenNode::executeInternal(this, a2, (re::RenderGraphBloomNode *)((char *)this + 264));
    id v6 = (re::BufferTable *)(*(void *)a2 + 480);
    *(void *)id v8 = 0x127DBE076EDDD69;
    re::BufferTable::removeBuffer(v6, (const re::WeakStringID *)v8);
  }
  else
  {
    id v7 = *re::graphicsLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl(&dword_233120000, v7, OS_LOG_TYPE_DEFAULT, "RenderGraphBloomNode expects BloomExecDataWrapper from the render graph data store but there isn't any.                          Will skip the execution. Did you forget to add a upload node?", v8, 2u);
    }
  }
}

void *re::allocInfo_BloomUserParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_438, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_438))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A0D0, "BloomUserParameters");
    __cxa_guard_release(&_MergedGlobals_438);
  }
  return &unk_26AF9A0D0;
}

void re::initInfo_BloomUserParameters(re *this, re::IntrospectionBase *a2)
{
  v22[0] = 0x789DF83014C541B0;
  v22[1] = "BloomUserParameters";
  re::StringID::destroyString((re::StringID *)v22);
  *((_OWORD *)this + 2) = v23;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A010, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A010);
    if (v4)
    {
      id v5 = re::introspectionAllocator(v4);
      id v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "strength";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9A0B0 = v8;
      unsigned int v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "threshold";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF9A0B8 = v12;
      unint64_t v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "spread";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF9A0C0 = v16;
      float32x2_t v17 = re::introspectionAllocator((re *)v16);
      id v19 = re::introspect_int((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "numPasses";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0xC00000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF9A0C8 = v20;
      __cxa_guard_release(&qword_26AF9A010);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9A0B0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BloomUserParameters>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BloomUserParameters>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BloomUserParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BloomUserParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v21 = v23;
}

double re::internal::defaultConstruct<re::BloomUserParameters>(uint64_t a1, uint64_t a2, void *a3)
{
  double result = 0.00781250182;
  *a3 = 0x3F8000003E800000;
  a3[1] = 0x13F800000;
  return result;
}

double re::internal::defaultConstructV2<re::BloomUserParameters>(void *a1)
{
  double result = 0.00781250182;
  *a1 = 0x3F8000003E800000;
  a1[1] = 0x13F800000;
  return result;
}

uint64_t re::introspect_BloomUserParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BloomUserParameters", (uint64_t (*)(re::internal *))re::allocInfo_BloomUserParameters, (re::IntrospectionBase *(*)(void))re::initInfo_BloomUserParameters, (void (*)(re::IntrospectionBase *))&qword_26AF9A018, this);
}

void *re::allocInfo_RenderGraphUploadBloomParams(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A020, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A020))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A148, "RenderGraphUploadBloomParams");
    __cxa_guard_release(&qword_26AF9A020);
  }
  return &unk_26AF9A148;
}

void re::initInfo_RenderGraphUploadBloomParams(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xEDF6B9216B19DCA0;
  v14[1] = "RenderGraphUploadBloomParams";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A028, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A028);
    if (v4)
    {
      id v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A078 = v7;
      uint64_t v8 = (re *)re::introspectionAllocator((re *)v7);
      unsigned int v9 = v8;
      uint64_t v10 = (re *)qword_26AF9A018;
      if (!qword_26AF9A018)
      {
        uint64_t v10 = (re *)re::allocInfo_BloomUserParameters(v8);
        qword_26AF9A018 = (uint64_t)v10;
        re::initInfo_BloomUserParameters(v10, v11);
      }
      uint64_t v12 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "bloomUserParameters";
      *(void *)(v12 + 16) = v10;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x10000000001;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF9A080 = v12;
      __cxa_guard_release(&qword_26AF9A028);
    }
  }
  *((void *)this + 2) = 0x11000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9A078;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphUploadBloomParams>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphUploadBloomParams>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphUploadBloomParams>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphUploadBloomParams>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

double re::internal::defaultConstruct<re::RenderGraphUploadBloomParams>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v3 = &unk_26E718388;
  double result = 0.00781250182;
  *((void *)v3 + 32) = 0x3F8000003E800000;
  *((void *)v3 + 33) = 0x13F800000;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphUploadBloomParams>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::RenderGraphUploadBloomParams>(re::RenderGraphNode *a1)
{
  uint64_t v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t v1 = &unk_26E718388;
  double result = 0.00781250182;
  *((void *)v1 + 32) = 0x3F8000003E800000;
  *((void *)v1 + 33) = 0x13F800000;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphUploadBloomParams>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphUploadBloomParams(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphUploadBloomParams", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphUploadBloomParams, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphUploadBloomParams, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphUploadBloomParams>, this);
}

void *re::allocInfo_RenderGraphDownsampleThresholdNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A030, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A030))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A1C0, "RenderGraphDownsampleThresholdNode");
    __cxa_guard_release(&qword_26AF9A030);
  }
  return &unk_26AF9A1C0;
}

void re::initInfo_RenderGraphDownsampleThresholdNode(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x49FD523B65429E92;
  v13[1] = "RenderGraphDownsampleThresholdNode";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A038, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A038);
    if (v4)
    {
      id v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A088 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "downsampleThresholdMaterial";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A090 = v11;
      __cxa_guard_release(&qword_26AF9A038);
    }
  }
  *((void *)this + 2) = 0x12000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9A088;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDownsampleThresholdNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDownsampleThresholdNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDownsampleThresholdNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDownsampleThresholdNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::RenderGraphDownsampleThresholdNode>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v3 = &unk_26E718430;
  double result = 0.0;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphDownsampleThresholdNode>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::RenderGraphDownsampleThresholdNode>(re::RenderGraphNode *a1)
{
  uint64_t v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t v1 = &unk_26E718430;
  double result = 0.0;
  *((_OWORD *)v1 + 16) = 0u;
  *((_OWORD *)v1 + 17) = 0u;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphDownsampleThresholdNode>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphDownsampleThresholdNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDownsampleThresholdNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDownsampleThresholdNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDownsampleThresholdNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDownsampleThresholdNode>, this);
}

void *re::allocInfo_RenderGraphDownsampleBlur(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A040, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A040))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A238, "RenderGraphDownsampleBlur");
    __cxa_guard_release(&qword_26AF9A040);
  }
  return &unk_26AF9A238;
}

void re::initInfo_RenderGraphDownsampleBlur(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x92E90B1749510D56;
  v17[1] = "RenderGraphDownsampleBlur";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A048, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A048);
    if (v4)
    {
      id v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A098 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_RenderGraphTargetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "downsampledTarget";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A0A0 = v11;
      long long v12 = re::introspectionAllocator((re *)v11);
      long long v14 = re::introspect_AssetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "library";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9A0A8 = v15;
      __cxa_guard_release(&qword_26AF9A048);
    }
  }
  *((void *)this + 2) = 0x14000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF9A098;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphDownsampleBlur>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphDownsampleBlur>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphDownsampleBlur>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphDownsampleBlur>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

double re::internal::defaultConstruct<re::RenderGraphDownsampleBlur>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v3 = &unk_26E7184D8;
  *((void *)v3 + 32) = 0;
  double result = NAN;
  *((void *)v3 + 33) = -1;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((void *)v3 + 38) = -1;
  *((void *)v3 + 39) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphDownsampleBlur>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::RenderGraphDownsampleBlur>(re::RenderGraphNode *a1)
{
  uint64_t v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t v1 = &unk_26E7184D8;
  *((void *)v1 + 32) = 0;
  double result = NAN;
  *((void *)v1 + 33) = -1;
  *((_OWORD *)v1 + 17) = 0u;
  *((_OWORD *)v1 + 18) = 0u;
  *((void *)v1 + 38) = -1;
  *((void *)v1 + 39) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphDownsampleBlur>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphDownsampleBlur(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphDownsampleBlur", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphDownsampleBlur, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphDownsampleBlur, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphDownsampleBlur>, this);
}

void *re::allocInfo_RenderGraphBloomNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A050, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A050))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A2B0, "RenderGraphBloomNode");
    __cxa_guard_release(&qword_26AF9A050);
  }
  return &unk_26AF9A2B0;
}

void re::initInfo_RenderGraphBloomNode(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0x228CD58E70E1D09ALL;
  v9[1] = "RenderGraphBloomNode";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A060, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A060);
    if (v4)
    {
      id v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A058 = v7;
      __cxa_guard_release(&qword_26AF9A060);
    }
  }
  *((void *)this + 2) = 0x1C800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF9A058;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphBloomNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphBloomNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphBloomNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphBloomNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

re::RenderGraphFullscreenNode *re::internal::defaultConstruct<re::RenderGraphBloomNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  double result = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)double result = &unk_26E718580;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphBloomNode>(int a1, int a2, id *this)
{
}

re::RenderGraphFullscreenNode *re::internal::defaultConstructV2<re::RenderGraphBloomNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  double result = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)double result = &unk_26E718580;
  return result;
}

uint64_t re::introspect_RenderGraphBloomNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphBloomNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphBloomNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphBloomNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphBloomNode>, this);
}

void re::RenderGraphUploadBloomParams::~RenderGraphUploadBloomParams(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphDownsampleThresholdNode::~RenderGraphDownsampleThresholdNode(id *this)
{
  *this = &unk_26E718430;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
}

{
  uint64_t vars8;

  *this = &unk_26E718430;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphDownsampleBlur::~RenderGraphDownsampleBlur(re::RenderGraphDownsampleBlur *this)
{
  *(void *)this = &unk_26E7184D8;
  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::AssetHandle::~AssetHandle((re::RenderGraphDownsampleBlur *)((char *)this + 272));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E7184D8;
  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {

    *((void *)this + 39) = 0;
  }
  re::AssetHandle::~AssetHandle((re::RenderGraphDownsampleBlur *)((char *)this + 272));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphBloomNode::~RenderGraphBloomNode(id *this)
{
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::add<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(re *a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  uint64_t v11 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t v6 = (uint64_t)a1 + 16;
  uint64_t v7 = re::globalAllocators(a1);
  long long v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 32, 8);
  void v8[2] = 0;
  v8[3] = 0;
  *long long v8 = &unk_26E718640;
  v8[1] = 0;
  long long v10 = v8;
  return *(void *)re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addNew<re::CameraData *>(v6, (unint64_t *)&v11, &v10);
}

void *re::RenderGraphDataStoreWrapper<re::BloomExecData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E718640;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::BloomExecData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E718640;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13BloomExecDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void re::RenderGraphMPSImageGaussianBlurNode::setup(re::RenderGraphMPSImageGaussianBlurNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  *((unsigned char *)a2 + 593) = 1;
  re::RenderGraphNode::setup(this, a2, a3);
  if (*((unsigned char *)this + 261))
  {
    if (*((void *)this + 24))
    {
      uint64_t v6 = *((void *)this + 26);
      *(_DWORD *)((char *)v7 + 3) = 0;
      v7[0] = 0;
      uint64_t v8 = 0xC00000002;
      re::RenderGraphBuilder::read((uint64_t)a2, v6, (uint64_t)v7);
    }
    else
    {
      re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
      _os_crash();
      __break(1u);
    }
  }
}

void re::RenderGraphMPSImageGaussianBlurNode::configure(re::RenderGraphMPSImageGaussianBlurNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  re::RenderGraphNode::configure(this, a2, a3, a4);
  id v6 = *(id *)(*((void *)a4 + 1) + 184);
  id v30 = v6;
  unint64_t v7 = (id *)((char *)this + 264);
  id v8 = (id)*((void *)this + 33);
  if (!v8)
  {
    re::mtl::mps::ImageGaussianBlur::ImageGaussianBlur((re::mtl::mps::ImageGaussianBlur *)&v18, (const re::mtl::Device *)&v30, *((float *)this + 64));
    if (v7 != &v18)
    {
      id v9 = v18;
      id v18 = 0;
      id v10 = *v7;
      *unint64_t v7 = v9;
    }
    id v8 = *v7;
  }
  uint64_t v11 = (_anonymous_namespace_ *)[v8 sigma];
  float v13 = v12;
  float v14 = *((float *)this + 64);
  if (v13 != v14)
  {
    re::mtl::mps::ImageGaussianBlur::ImageGaussianBlur((re::mtl::mps::ImageGaussianBlur *)&v18, (const re::mtl::Device *)&v30, v14);
    if (v7 != &v18)
    {
      id v15 = v18;
      id v18 = 0;
      id v16 = *v7;
      *unint64_t v7 = v15;
    }
  }
  if (!*((void *)this + 34))
  {
    LOBYTE(v18) = 0;
    long long v22 = 0uLL;
    *((void *)&v21 + 1) = 0;
    re::DynamicString::setCapacity(&v21, 0);
    uint64_t v25 = 0;
    memset(v23, 0, sizeof(v23));
    int v24 = 0;
    char v26 = 0;
    char v27 = 0;
    uint64_t v28 = 0;
    char v29 = 0;
    v31[0] = "ClearImage";
    v31[1] = 10;
    re::DynamicString::operator=((re::DynamicString *)&v21, (uint64_t)v31);
    ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)&v18);
    NS::SharedPtr<MTL::Texture>::operator=((void **)this + 34, ComputePipelineState);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v23);
    if ((void)v21)
    {
      if (BYTE8(v21)) {
        (*(void (**)(void))(*(void *)v21 + 40))();
      }
      long long v21 = 0u;
      long long v22 = 0u;
    }
    if (_BYTE)v18 && v19 && (v20) {
      (*(void (**)(void))(*(void *)v19 + 40))();
    }
  }
}

void re::RenderGraphMPSImageGaussianBlurNode::execute(id *this, re::RenderGraphContext *a2)
{
  uint64_t v149 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v132, 5091, 0);
  uint64_t v4 = *(id **)a2;
  unint64_t v100 = a2;
  re::RenderGraphMPSNodeBase::getCommandBufferWithProtectionOptions((re::RenderGraphMPSNodeBase *)this, a2, &v131);
  id v125 = *v4;
  id v124 = v131;
  uint64_t v130 = 0;
  id v127 = 0;
  id v128 = 0;
  id location = 0;
  char v129 = 0;
  re::ObjCObject::operator=(&v127, &v124);
  re::ObjCObject::operator=(&location, &v125);

  [this[33] setEdgeMode:*((unsigned __int8 *)this + 260)];
  if (!this[24])
  {
LABEL_117:
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_118;
  }
  id v6 = (uint64_t *)this[26];
  uint64_t v122 = 0;
  uint64_t v123 = -1;
  uint64_t v122 = *v6;
  uint64_t v123 = v6[1];
  if (!this[29])
  {
LABEL_118:
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_119;
  }
  unint64_t v7 = (uint64_t *)this[31];
  uint64_t v120 = 0;
  uint64_t v121 = -1;
  uint64_t v120 = *v7;
  uint64_t v121 = v7[1];
  re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)&v122, 0, 0, &v119);
  re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)&v120, 0, 0, &v118);
  id v8 = (unsigned __int8 *)re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  unint64_t v9 = (unint64_t)v8;
  if (v8) {
    unsigned int v10 = v8[64];
  }
  else {
    unsigned int v10 = 1;
  }
  unint64_t v110 = 0;
  int v111 = 1;
  uint64_t v11 = v10;
  unint64_t v112 = 0;
  unsigned int v113 = 0;
  float v12 = (_anonymous_namespace_ *)re::DynamicOverflowArray<MTL::Region,2ul>::setCapacity(&v109, v10);
  char v13 = v111 + 2;
  v111 += 2;
  if (v110 >= v10)
  {
    if (v110 <= v10) {
      goto LABEL_22;
    }
  }
  else
  {
    if (!v109)
    {
      re::DynamicOverflowArray<MTL::Region,2ul>::setCapacity(&v109, v10);
      char v13 = v111 + 2;
      v111 += 2;
    }
    BOOL v14 = (v13 & 1) == 0;
    unint64_t v15 = 2;
    if (v14) {
      unint64_t v15 = v112;
    }
    if (v15 < v10) {
      re::DynamicOverflowArray<MTL::Region,2ul>::setCapacity(&v109, v10);
    }
    unint64_t v16 = v10 - v110;
    if (v10 > v110)
    {
      uint64_t v17 = 6 * v110;
      do
      {
        if (v111) {
          id v18 = &v112;
        }
        else {
          id v18 = v113;
        }
        uint64_t v19 = &v18[v17];
        *((_OWORD *)v19 + 1) = 0uLL;
        *((_OWORD *)v19 + 2) = 0uLL;
        *(_OWORD *)uint64_t v19 = 0uLL;
        v17 += 6;
        --v16;
      }
      while (v16);
    }
  }
  unint64_t v110 = v10;
  v111 += 2;
LABEL_22:
  LODWORD(v144) = v123;
  uint64_t v20 = re::SmallHashTable<unsigned int,re::DynamicOverflowArray<re::AABB,2ul>,8ul,re::Hash<unsigned int>,re::EqualTo<unsigned int>,false>::tryGet((uint64_t)a2 + 96, (unsigned int *)&v144);
  long long v22 = &selRef_stepFunction_0;
  unint64_t v99 = this;
  if (*((unsigned char *)this + 261))
  {
    uint64_t v101 = v20;
    re::SyncMechanism::sync((re::SyncMechanism *)&location);
    re::mtl::CommandBuffer::makeComputeCommandEncoder(&v131, &v108);
    v140[1] = 0;
    v140[0] = 0;
    uint64_t v139 = 0;
    re::mtl::CommandBuffer::commandQueue(&v131, &v107);
    re::mtl::CommandQueue::device(&v107, v141);
    if (*(void *)v141)
    {
      long long v144 = 0uLL;
      v145.i64[0] = 0;
      [*(id *)v141 maxThreadsPerThreadgroup];
      unint64_t v23 = v144;
      int v24 = *(void **)v141;
    }
    else
    {
      int v24 = 0;
      unint64_t v23 = 0;
    }
    uint64_t v25 = sqrt((double)v23);

    [v108 setComputePipelineState:this[34]];
    [v108 setBytes:v140 length:16 atIndex:0];
    [v108 setBytes:&v139 length:8 atIndex:1];
    if (objc_msgSend(v118, sel_textureType) == (id)2)
    {
      [v108 setTexture:v118 atIndex:0];
      unsigned int v26 = objc_msgSend(v118, sel_width);
      unsigned int v27 = objc_msgSend(v118, sel_height);
      *(void *)&long long v144 = v26;
      *((void *)&v144 + 1) = v27;
      v145.i64[0] = 1;
      *(void *)unint64_t v141 = v25;
      *(void *)&v141[8] = v25;
      *(void *)&v141[16] = 1;
      [v108 dispatchThreads:&v144 threadsPerThreadgroup:v141];
    }
    else if (objc_msgSend(v118, sel_textureType) == (id)3 && objc_msgSend(v118, sel_arrayLength))
    {
      unint64_t v28 = 0;
      do
      {
        re::makeView2DArrayTo2D(&v118, v28, &v107);
        id v29 = v107;
        [v108 setTexture:v107 atIndex:0];
        unsigned int v30 = objc_msgSend(v118, sel_width);
        unsigned int v31 = objc_msgSend(v118, sel_height);
        *(void *)&long long v144 = v30;
        *((void *)&v144 + 1) = v31;
        v145.i64[0] = 1;
        *(void *)unint64_t v141 = v25;
        *(void *)&v141[8] = v25;
        *(void *)&v141[16] = 1;
        [v108 dispatchThreads:&v144 threadsPerThreadgroup:v141];
        if (v29) {

        }
        ++v28;
      }
      while (v28 < (unint64_t)objc_msgSend(v118, sel_arrayLength));
    }
    [v108 endEncoding];

    long long v22 = &selRef_stepFunction_0;
    if (*((unsigned char *)this + 261))
    {
      if (v101 && *(void *)(v101 + 8))
      {
        [this[33] sigma];
        if (!v10)
        {
          char v54 = 1;
          goto LABEL_64;
        }
        unint64_t v35 = 0;
        *(float *)v33.i32 = (float)((float)(*(float *)v33.i32 + *(float *)v33.i32) * 2.0) + 1.0;
        uint64_t v36 = v101;
        *(float *)v34.i32 = (float)(2 * (int)*(float *)v33.i32);
        *(float *)v33.i32 = (float)(int)*(float *)v33.i32;
        float32x2_t v37 = (float32x2_t)vdup_lane_s32(v33, 0);
        float32x2_t v38 = (float32x2_t)vdup_lane_s32(v34, 0);
        uint64_t v39 = 16;
        uint64_t v40 = 5;
        while (1)
        {
          unint64_t v41 = *(void *)(v36 + 8);
          if (v41 <= v35) {
            goto LABEL_114;
          }
          uint64_t v42 = v101 + 32;
          if ((*(unsigned char *)(v36 + 16) & 1) == 0) {
            uint64_t v42 = *(void *)(v36 + 40);
          }
          long long v43 = xmmword_2343854A0;
          if (v9)
          {
            unint64_t v44 = *(void *)(v9 + 16);
            if (v44 <= v35) {
              goto LABEL_116;
            }
            long long v43 = *(_OWORD *)(v9 + 32 + 16 * v35);
          }
          int8x16_t v102 = (int8x16_t)v43;
          id v45 = objc_msgSend(v119, sel_width);
          id v46 = objc_msgSend(v119, sel_height);
          this = (id *)v110;
          if (v110 <= v35) {
            goto LABEL_115;
          }
          v47.i64[0] = (uint64_t)v45;
          v47.i64[1] = (uint64_t)v46;
          float32x2_t v48 = vcvt_f32_f64(vcvtq_f64_u64(v47));
          long long v49 = *(_OWORD *)(v42 + v39);
          long long v50 = *(_OWORD *)(v42 + v39 - 16);
          if (v111) {
            uint64_t v51 = &v112;
          }
          else {
            uint64_t v51 = v113;
          }
          uint64_t v52 = (uint64x2_t *)&v51[v40];
          float32x2_t v53 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v102, v102, 8uLL), v48);
          *(uint64x2_t *)((char *)v52 - 40) = vcvtq_u64_f64(vcvtq_f64_f32(vsub_f32(vmla_f32(vmul_f32(*(float32x2_t *)v102.i8, v48), *(float32x2_t *)&v50, v53), v37)));
          v52[-2].i64[1] = 0;
          v52[-1] = vcvtq_u64_f64(vcvtq_f64_f32(vmla_f32(v38, vmaxnm_f32(vsub_f32(*(float32x2_t *)&v49, *(float32x2_t *)&v50), 0), v53)));
          char v54 = 1;
          v52->i64[0] = 1;
          ++v35;
          v39 += 32;
          v40 += 6;
          uint64_t v36 = v101;
          if (v11 == v35) {
            goto LABEL_62;
          }
        }
      }
    }
  }
  if (!v10)
  {
    char v54 = 0;
    goto LABEL_64;
  }
  unint64_t v41 = 0;
  __int16 v55 = (id *)(v9 + 32);
  unint64_t v35 = 24;
  do
  {
    long long v56 = xmmword_2343854A0;
    if (v9)
    {
      unint64_t v57 = *(void *)(v9 + 16);
      if (v57 <= v41) {
        goto LABEL_112;
      }
      long long v56 = *(_OWORD *)&v55[2 * v41];
    }
    int8x16_t v103 = (int8x16_t)v56;
    this = (id *)objc_msgSend(v119, sel_width);
    id v58 = objc_msgSend(v119, sel_height);
    uint64_t v59 = (id *)v110;
    if (v110 <= v41)
    {
      v140[0] = 0;
      __int16 v55 = (id *)v141;
      long long v147 = 0u;
      long long v148 = 0u;
      int8x16_t v145 = 0u;
      long long v146 = 0u;
      long long v144 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v141 = 136315906;
      *(void *)&v141[4] = "operator[]";
      *(_WORD *)&v141[12] = 1024;
      *(_DWORD *)&v141[14] = 858;
      *(_WORD *)&v141[18] = 2048;
      *(void *)&v141[20] = v41;
      __int16 v142 = 2048;
      unint64_t v143 = v59;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_112:
      re::internal::assertLog((re::internal *)6, v21, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v41, v57);
      _os_crash();
      __break(1u);
LABEL_113:
      v140[0] = 0;
      long long v147 = 0u;
      long long v148 = 0u;
      int8x16_t v145 = 0u;
      long long v146 = 0u;
      long long v144 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v141 = 136315906;
      *(void *)&v141[4] = "operator[]";
      *(_WORD *)&v141[12] = 1024;
      *(_DWORD *)&v141[14] = 858;
      *(_WORD *)&v141[18] = 2048;
      *(void *)&v141[20] = v9;
      __int16 v142 = 2048;
      unint64_t v143 = v55;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_114:
      v140[0] = 0;
      long long v147 = 0u;
      long long v148 = 0u;
      int8x16_t v145 = 0u;
      long long v146 = 0u;
      long long v144 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v141 = 136315906;
      *(void *)&v141[4] = "operator[]";
      *(_WORD *)&v141[12] = 1024;
      *(_DWORD *)&v141[14] = 866;
      *(_WORD *)&v141[18] = 2048;
      *(void *)&v141[20] = v35;
      __int16 v142 = 2048;
      unint64_t v143 = (id *)v41;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_115:
      v140[0] = 0;
      long long v147 = 0u;
      long long v148 = 0u;
      int8x16_t v145 = 0u;
      long long v146 = 0u;
      long long v144 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v141 = 136315906;
      *(void *)&v141[4] = "operator[]";
      *(_WORD *)&v141[12] = 1024;
      *(_DWORD *)&v141[14] = 858;
      *(_WORD *)&v141[18] = 2048;
      *(void *)&v141[20] = v35;
      __int16 v142 = 2048;
      unint64_t v143 = this;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_116:
      re::internal::assertLog((re::internal *)6, v32, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v35, v44);
      _os_crash();
      __break(1u);
      goto LABEL_117;
    }
    v60.i64[0] = (uint64_t)this;
    v60.i64[1] = (uint64_t)v58;
    float32x2_t v61 = vcvt_f32_f64(vcvtq_f64_u64(v60));
    unint64_t v62 = (unint64_t)vmuls_lane_f32(*(float *)&v103.i32[1], v61, 1);
    float v63 = vmuls_n_f32(*(float *)v103.i32, v61.f32[0]);
    if (v111) {
      unint64_t v64 = &v112;
    }
    else {
      unint64_t v64 = v113;
    }
    long long v65 = (uint64x2_t *)((char *)v64 + v35);
    v65[-2].i64[1] = (unint64_t)v63;
    v65[-1].i64[0] = v62;
    v65[-1].i64[1] = 0;
    *long long v65 = vcvtq_u64_f64(vcvtq_f64_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v103, v103, 8uLL), v61)));
    v65[1].i64[0] = 1;
    ++v41;
    v35 += 48;
  }
  while (v10 != v41);
  char v54 = 0;
LABEL_62:
  this = v99;
  long long v22 = &selRef_stepFunction_0;
LABEL_64:
  re::SyncMechanism::sync((re::SyncMechanism *)&location);
  if ((v54 & 1) == 0 && *((unsigned char *)this + 261)) {
    goto LABEL_100;
  }
  if ([v119 v22[11]] != (id)2)
  {
    if ([v119 v22[11]] != (id)3)
    {
      [v119 v22[11]];
      id v97 = [v119 v22[11]];
      re::internal::assertLog((re::internal *)5, v98, "assertion failure: '%s' (%s:line %i) Unsupported texture type %lu.", "false", "execute", 177, v97);
      _os_crash();
      __break(1u);
      return;
    }
    if (!objc_msgSend(v119, sel_arrayLength)) {
      goto LABEL_99;
    }
    unint64_t v41 = 0;
    unint64_t v9 = 0;
    unint64_t v35 = (unint64_t)&v144;
    this = v99;
    while (1)
    {
      __int16 v55 = (id *)v110;
      if (v110 <= v9) {
        goto LABEL_113;
      }
      if (v111) {
        int v69 = &v112;
      }
      else {
        int v69 = v113;
      }
      uint64_t v70 = (int8x16_t *)((char *)v69 + v41);
      uint64_t v72 = v70->i64[1];
      int8x16_t v104 = v70[1];
      uint64_t v73 = v70[2].i64[0];
      uint64_t v74 = v70[2].i64[1];
      id v75 = v99[33];
      v105[0] = v70->i64[0];
      uint64_t v71 = v105[0];
      v105[1] = v72;
      v105[2] = 0;
      [v75 setOffset:v105];
      id v76 = v99[33];
      *(void *)&long long v144 = v71;
      *((void *)&v144 + 1) = v72;
      int8x16_t v145 = v104;
      *(void *)&long long v146 = v73;
      *((void *)&v146 + 1) = v74;
      [v76 setClipRect:&v144];
      re::makeView2DArrayTo2D(&v119, v9, &v144);
      View2DArrayTo2D = (re *)re::makeView2DArrayTo2D(&v118, v9, v141);
      uint64_t v78 = *(void *)(*((void *)v100 + 1) + 56);
      uint64_t v134 = re::globalAllocators(View2DArrayTo2D)[2];
      unint64_t v135 = 0;
      float v79 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v134 + 32))(v134, 40, 0);
      *float v79 = &unk_26E718768;
      v79[1] = v99;
      v79[2] = &v131;
      v79[3] = &v144;
      v79[4] = v141;
      unint64_t v135 = v79;
      re::ShaderManager::executeWithPrioritizedShaderCompilation(v78, (uint64_t)v133);
      re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v133);
      if (*(void *)v141) {

      }
      if ((void)v144) {
      ++v9;
      }
      v41 += 48;
      if (v9 >= (unint64_t)objc_msgSend(v119, sel_arrayLength)) {
        goto LABEL_99;
      }
    }
  }
  if (!v110)
  {
LABEL_119:
    v140[0] = 0;
    long long v147 = 0u;
    long long v148 = 0u;
    int8x16_t v145 = 0u;
    long long v146 = 0u;
    long long v144 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v141 = 136315906;
    *(void *)&v141[4] = "operator[]";
    *(_WORD *)&v141[12] = 1024;
    *(_DWORD *)&v141[14] = 858;
    *(_WORD *)&v141[18] = 2048;
    *(void *)&v141[20] = 0;
    __int16 v142 = 2048;
    unint64_t v143 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_120;
  }
  id v66 = this[33];
  if (v111)
  {
    unint64_t v68 = v112;
    long long v67 = &v112;
  }
  else
  {
    long long v67 = v113;
    unint64_t v68 = *v113;
  }
  unint64_t v80 = v67[1];
  v106[0] = v68;
  v106[1] = v80;
  v106[2] = 0;
  [v66 setOffset:v106];
  if (!v110)
  {
LABEL_120:
    v140[0] = 0;
    long long v147 = 0u;
    long long v148 = 0u;
    int8x16_t v145 = 0u;
    long long v146 = 0u;
    long long v144 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v141 = 136315906;
    *(void *)&v141[4] = "operator[]";
    *(_WORD *)&v141[12] = 1024;
    *(_DWORD *)&v141[14] = 858;
    *(_WORD *)&v141[18] = 2048;
    *(void *)&v141[20] = 0;
    __int16 v142 = 2048;
    unint64_t v143 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  int v81 = &v113;
  if (v111) {
    unint64_t v82 = &v112;
  }
  else {
    unint64_t v82 = v113;
  }
  id v83 = this[33];
  unint64_t v84 = *v82;
  if ((v111 & 1) == 0) {
    int v81 = (unint64_t **)(v113 + 1);
  }
  uint64_t v85 = *v81;
  uint64_t v86 = (uint64_t *)(v113 + 2);
  if (v111) {
    uint64_t v86 = &v114;
  }
  uint64_t v87 = *v86;
  float v88 = (uint64_t *)(v113 + 3);
  if (v111) {
    float v88 = &v115;
  }
  uint64_t v89 = *v88;
  double v90 = (uint64_t *)(v113 + 4);
  if (v111) {
    double v90 = &v116;
  }
  uint64_t v91 = *v90;
  unint64_t v92 = &v117;
  if ((v111 & 1) == 0) {
    unint64_t v92 = (uint64_t *)(v113 + 5);
  }
  uint64_t v93 = *v92;
  *(void *)&long long v144 = v84;
  *((void *)&v144 + 1) = v85;
  v145.i64[0] = v87;
  v145.i64[1] = v89;
  *(void *)&long long v146 = v91;
  *((void *)&v146 + 1) = v93;
  uint64_t v94 = (re *)[v83 setClipRect:&v144];
  uint64_t v95 = *(void *)(*((void *)v100 + 1) + 56);
  uint64_t v137 = re::globalAllocators(v94)[2];
  float v96 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v137 + 32))(v137, 40, 0);
  *float v96 = &unk_26E718710;
  v96[1] = this;
  v96[2] = &v131;
  v96[3] = &v119;
  v96[4] = &v118;
  uint64_t v138 = v96;
  re::ShaderManager::executeWithPrioritizedShaderCompilation(v95, (uint64_t)v136);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v136);
LABEL_99:
  re::SyncMechanism::sync((re::SyncMechanism *)&location);
LABEL_100:
  if (v109 && (v111 & 1) == 0) {
    (*(void (**)(void))(*v109 + 40))();
  }
  if (v118) {

  }
  if (v119) {
  if (v128)
  }
  {

    id v128 = 0;
  }

  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v132);
}

uint64_t re::SmallHashTable<unsigned int,re::DynamicOverflowArray<re::AABB,2ul>,8ul,re::Hash<unsigned int>,re::EqualTo<unsigned int>,false>::tryGet(uint64_t a1, unsigned int *a2)
{
  if (*(_DWORD *)(a1 + 956)) {
    return re::HashTable<unsigned int,re::DynamicOverflowArray<re::AABB,2ul>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,false,false>::tryGet(a1 + 928, a2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t result = a1 + 48;
  uint64_t v4 = 112 * v3;
  while (*(_DWORD *)(result - 16) != *a2)
  {
    result += 112;
    v4 -= 112;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

void *re::allocInfo_RenderGraphMPSImageGaussianBlurNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_439, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_439))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A358, "RenderGraphMPSImageGaussianBlurNode");
    __cxa_guard_release(&_MergedGlobals_439);
  }
  return &unk_26AF9A358;
}

void re::initInfo_RenderGraphMPSImageGaussianBlurNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0xDD66E2E47DA234ELL;
  v21[1] = "RenderGraphMPSImageGaussianBlurNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A330, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A330);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A338 = v7;
      id v8 = re::introspectionAllocator((re *)v7);
      unsigned int v10 = re::introspect_float((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "sigma";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A340 = v11;
      float v12 = re::introspectionAllocator((re *)v11);
      BOOL v14 = re::introspect_MPSImageEdgeModeType((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "edgeMode";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x10400000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9A348 = v15;
      unint64_t v16 = re::introspectionAllocator((re *)v15);
      id v18 = re::introspect_BOOL((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "enableRestrictedClipRegion";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x10500000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9A350 = v19;
      __cxa_guard_release(&qword_26AF9A330);
    }
  }
  *((void *)this + 2) = 0x11800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9A338;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphMPSImageGaussianBlurNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphMPSImageGaussianBlurNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphMPSImageGaussianBlurNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphMPSImageGaussianBlurNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

re::RenderGraphNode *re::internal::defaultConstruct<re::RenderGraphMPSImageGaussianBlurNode>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t result = &unk_26E718668;
  *((_WORD *)result + 130) = 0;
  *((void *)result + 33) = 0;
  *((void *)result + 34) = 0;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphMPSImageGaussianBlurNode>(int a1, int a2, re::RenderGraphMPSImageGaussianBlurNode *this)
{
}

re::RenderGraphNode *re::internal::defaultConstructV2<re::RenderGraphMPSImageGaussianBlurNode>(re::RenderGraphNode *a1)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t result = &unk_26E718668;
  *((_WORD *)result + 130) = 0;
  *((void *)result + 33) = 0;
  *((void *)result + 34) = 0;
  return result;
}

uint64_t re::introspect_RenderGraphMPSImageGaussianBlurNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphMPSImageGaussianBlurNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphMPSImageGaussianBlurNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphMPSImageGaussianBlurNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphMPSImageGaussianBlurNode>, this);
}

void re::RenderGraphMPSImageGaussianBlurNode::~RenderGraphMPSImageGaussianBlurNode(re::RenderGraphMPSImageGaussianBlurNode *this)
{
  re::RenderGraphMPSImageGaussianBlurNode::~RenderGraphMPSImageGaussianBlurNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  void *v2;
  uint64_t vars8;

  unint64_t v2 = (void *)*((void *)this + 34);
  if (v2)
  {

    *((void *)this + 34) = 0;
  }

  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

void re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_0,void ()(void)>::~Callable()
{
}

void re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_0,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E718710;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E718710;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_0,void ()(void)>::size()
{
  return 40;
}

void re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_1,void ()(void)>::~Callable()
{
}

void re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_1,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_1,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E718768;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_1,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E718768;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphMPSImageGaussianBlurNode::execute(re::RenderGraphContext &)::$_1,void ()(void)>::size()
{
  return 40;
}

void *re::DynamicOverflowArray<MTL::Region,2ul>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *result;
  if (a2 && !v4)
  {
    uint64_t result = (void *)re::DynamicOverflowArray<MTL::Region,2ul>::setCapacity(v3, a2);
    int v5 = *((_DWORD *)v3 + 4) + 2;
LABEL_4:
    *((_DWORD *)v3 + 4) = v5;
    return result;
  }
  int v6 = *((_DWORD *)result + 4);
  if (v6) {
    uint64_t v7 = 2;
  }
  else {
    uint64_t v7 = result[3];
  }
  if (v7 != a2)
  {
    unint64_t v8 = result[1];
    if (v8 <= a2 && (a2 > 2 || (v6 & 1) == 0))
    {
      if (a2 < 3)
      {
        char v13 = result + 3;
        uint64_t v14 = v3[4];
        if (v6) {
          uint64_t v15 = v3 + 3;
        }
        else {
          uint64_t v15 = (const void *)v3[4];
        }
        memcpy(v13, v15, 48 * v8);
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v14);
        int v5 = *((_DWORD *)v3 + 4) | 1;
        goto LABEL_4;
      }
      unint64_t v9 = (void *)(*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v4 + 32))(*result, 48 * a2, 1);
      if (v9)
      {
        uint64_t v11 = v9;
        if (v3[2]) {
          float v12 = v3 + 3;
        }
        else {
          float v12 = (const void *)v3[4];
        }
        uint64_t result = memcpy(v9, v12, 48 * v3[1]);
        int v16 = *((_DWORD *)v3 + 4);
        if ((v16 & 1) == 0)
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v3[4]);
          int v16 = *((_DWORD *)v3 + 4);
        }
        *((_DWORD *)v3 + 4) = v16 & 0xFFFFFFFE;
        v3[3] = a2;
        v3[4] = v11;
      }
      else
      {
        re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, 48 * a2, *(void *)(*v3 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::DynamicOverflowArray<re::AABB,2ul>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,false,false>::tryGet(uint64_t a1, unsigned int *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = *a2;
  unint64_t v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 112 * v4 + 4) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 112 * v4) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v6 + 112 * v4 + 4) == v2) {
        return v6 + 112 * v4 + 16;
      }
    }
    return 0;
  }
  return v6 + 112 * v4 + 16;
}

void re::CopyShadowTextureNode::execute(re::CopyShadowTextureNode *this, re::RenderGraphContext *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!*((void *)this + 29))
  {
    uint64_t v21 = 0;
    long long v33 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)id v29 = 0u;
    long long v30 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v22 = 136315906;
    *(void *)&v22[4] = "operator[]";
    __int16 v23 = 1024;
    int v24 = 789;
    __int16 v25 = 2048;
    uint64_t v26 = 0;
    __int16 v27 = 2048;
    unint64_t v28 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_32;
  }
  re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 31), 0, 0, &v20);
  unint64_t v2 = *((void *)this + 29);
  if (v2 <= 1)
  {
LABEL_32:
    uint64_t v21 = 0;
    long long v33 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)id v29 = 0u;
    long long v30 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v22 = 136315906;
    *(void *)&v22[4] = "operator[]";
    __int16 v23 = 1024;
    int v24 = 789;
    __int16 v25 = 2048;
    uint64_t v26 = 1;
    __int16 v27 = 2048;
    unint64_t v28 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_33;
  }
  re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 31) + 64, 0, 0, &v19);
  if (!*((void *)this + 19))
  {
LABEL_33:
    uint64_t v21 = 0;
    long long v33 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)id v29 = 0u;
    long long v30 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v22 = 136315906;
    *(void *)&v22[4] = "operator[]";
    __int16 v23 = 1024;
    int v24 = 789;
    __int16 v25 = 2048;
    uint64_t v26 = 0;
    __int16 v27 = 2048;
    unint64_t v28 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_34;
  }
  id v5 = *(id *)re::RenderGraphContext::metalBuffer((uint64_t)a2, *((void *)this + 21));
  v29[0] = v5;
  uint64_t v6 = *(id **)(*((void *)a2 + 1) + 168);
  id v7 = v6[87];
  unint64_t v8 = v6 + 88;
  id v9 = v6[88];
  uint64_t v10 = v6 + 89;
  id v11 = v6[89];
  if (v20 == v6[87] && v19 == *v8 && v5 == *v10) {
    goto LABEL_18;
  }
  uint64_t v12 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
  re::RenderGraphContext::acquireManagedBlitEncoder((uint64_t)a2, v12, *((re::RenderGraphNodeBase **)a2 + 5), 0, v22);
  if (v7)
  {
    id v13 = objc_msgSend(v20, sel_arrayLength);
    if (v13 >= objc_msgSend(v7, sel_arrayLength))
    {
      [*(id *)v22 copyFromTexture:v7 toTexture:v20];
      goto LABEL_10;
    }
LABEL_34:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Reducing the texture size is not supported as it requires compaction", "newShadowTexture->arrayLength() >= oldShadowTexture->arrayLength()", "execute", 118);
    _os_crash();
    __break(1u);
  }
LABEL_10:
  uint64_t v15 = v6 + 87;
  if (v9) {
    [*(id *)v22 copyFromTexture:v9 toTexture:v19];
  }
  if (v11)
  {
    id v16 = objc_msgSend(v11, sel_length);
    id v17 = objc_msgSend(v5, sel_length);
    if (v17 >= v16) {
      id v18 = v16;
    }
    else {
      id v18 = v17;
    }
    [*(id *)v22 copyFromBuffer:v11 sourceOffset:0 toBuffer:v5 destinationOffset:0 size:v18];
  }
  NS::SharedPtr<MTL::Texture>::operator=(v8, &v19);
  NS::SharedPtr<MTL::Texture>::operator=(v15, &v20);
  NS::SharedPtr<MTL::Texture>::operator=(v10, v29);

LABEL_18:
  if (v11) {

  }
  if (v9) {
  if (v7)
  }

  if (v29[0]) {
  if (v19)
  }

  if (v20) {
}
  }

void re::GenerateTiledShadowDepthPrepassMapNode::execute(const char **this, float32x4_t *a2)
{
  uint64_t v139 = *MEMORY[0x263EF8340];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A3D8, memory_order_acquire) & 1) == 0) {
    goto LABEL_79;
  }
  while (1)
  {
    if (a2[83].i8[4]) {
LABEL_76:
    }
      uint64_t v4 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)&a2[83].u32[2], this[2], "DrawInstancedDepthOnlyDepthAsColor");
    else {
      uint64_t v4 = 0;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A3E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A3E8))
    {
      qword_26AF9A3E0 = re::getCombinedScopeHash((re *)"SceneArray", v75, v76);
      __cxa_guard_release(&qword_26AF9A3E8);
    }
    id v5 = (re::GenerateTiledShadowDepthPrepassMapNode *)re::RenderGraphDataStore::tryGet<re::SceneArrayData>(a2[73].i64[0], qword_26AF9A3E0);
    if (!v5)
    {
      uint64_t v72 = *re::graphicsLogObjects(0);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_233120000, v72, OS_LOG_TYPE_DEFAULT, "GenerateTiledShadowDepthPrepassMapNode::execute: Missing SceneArrayData. Skipping node execution.", buf, 2u);
      }
      return;
    }
    this = (const char **)v5;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A3F8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A3F8))
    {
      qword_26AF9A3F0 = re::hashString((re *)"ProjectiveMeshShadow", v77);
      __cxa_guard_release(&qword_26AF9A3F8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A408, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A408))
    {
      qword_26AF9A400 = re::getCombinedScopeHash(qword_26AF9A3F0, v78, v79);
      __cxa_guard_release(&qword_26AF9A408);
    }
    uint64_t v6 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(a2[73].i64[0], qword_26AF9A400);
    if (!v6) {
      return;
    }
    uint64_t v7 = v6;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A418, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A418))
    {
      qword_26AF9A410 = re::hashString((re *)"DepthColorClear", v80);
      __cxa_guard_release(&qword_26AF9A418);
    }
    re::RenderGraphContext::makeFullscreenDrawCall(a2, *(void *)(v7 + 128), *(void *)(v7 + 136), 0, 0, 0, (int32x2_t *)buf);
    a2[94].i8[8] = 1;
    unint64_t v8 = re::MaterialParameterTableLayers::resolveTechniqueIndices(v124[0], qword_26AF9A410);
    if (!v9)
    {
      re::internal::assertLog((re::internal *)6, 0, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
      _os_crash();
      __break(1u);
      goto LABEL_78;
    }
    uint64_t v10 = *(void *)(v7 + 448);
    HIDWORD(v122) = *v8;
    LODWORD(v122) = v10;
    v107[0] = 0;
    re::encodeFullscreenDrawCall((re::DrawCall *)buf, (uint64_t)"DepthColorClear", (re::RenderGraphContext *)a2, v4, 0, v107, 0);
    a2[94].i8[8] = 0;
    id v11 = *(re::Allocator **)(a2->i64[0] + 24);
    uint64_t v12 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 224, 16);
    *(_OWORD *)(v12 + 96) = 0u;
    *(_OWORD *)(v12 + 112) = 0u;
    *(_OWORD *)(v12 + 64) = 0u;
    *(_OWORD *)(v12 + 80) = 0u;
    *(_OWORD *)(v12 + 32) = 0u;
    *(_OWORD *)(v12 + 48) = 0u;
    *(_OWORD *)uint64_t v12 = 0u;
    *(_OWORD *)(v12 + 16) = 0u;
    *(_OWORD *)(v12 + 128) = 0u;
    *(_OWORD *)(v12 + 144) = 0u;
    *(_OWORD *)(v12 + 160) = 0u;
    *(_OWORD *)(v12 + 176) = 0u;
    *(_OWORD *)(v12 + 192) = 0u;
    *(_OWORD *)(v12 + 208) = 0u;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)(v12 + 152) = _D0;
    *(_DWORD *)(v12 + 160) = 1065353216;
    *(_OWORD *)(v12 + 40) = *(_OWORD *)(v7 + 144);
    uint64_t v97 = v12;
    id v18 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v12, _MergedGlobals_440);
    if (v19) {
      break;
    }
LABEL_78:
    re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_79:
    if (__cxa_guard_acquire(&qword_26AF9A3D8))
    {
      _MergedGlobals_440 = re::hashString((re *)"DrawInstancedDepthOnlyDepthAsColor", v74);
      __cxa_guard_release(&qword_26AF9A3D8);
    }
  }
  unint64_t v20 = (unint64_t)v110;
  int v96 = *v18;
  unint64_t v92 = (re::DrawTable *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 328, 8);
  re::DrawTable::DrawTable(v92, v11);
  uint64_t v21 = this[3];
  if (!v21) {
    goto LABEL_73;
  }
  long long v22 = (const char **)this[5];
  uint64_t v86 = &v22[(void)v21];
  uint64_t v93 = (re::RenderGraphContext *)a2;
  int v81 = v11;
  uint64_t v82 = v4;
  while (2)
  {
    float v88 = v22;
    __int16 v23 = *v22;
    unint64_t v24 = qword_26AF9A3F0;
    size_t v25 = strlen(*v22);
    uint64_t v26 = 0x9E3779B97F4A7C17;
    if (v25)
    {
      MurmurHash3_x64_128((uint64_t)v23, v25, 0, (unint64_t *)buf);
      uint64_t v26 = ((*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf)
          - 0x61C8864680B583E9;
    }
    uint64_t v27 = a2[73].i64[0];
    unint64_t v28 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPerSceneGenerationDataEEE";
    if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPerSceneGenerationDataEEE" & 0x8000000000000000) != 0)
    {
      id v29 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPerSceneGenerationDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v30 = 5381;
      do
      {
        unint64_t v28 = v30;
        unsigned int v31 = *v29++;
        uint64_t v30 = (33 * v30) ^ v31;
      }
      while (v31);
    }
    *(void *)buf = ((((v24 >> 2) + (v24 << 6) + v26) ^ v24) - 0x61C8864680B583E9 + (v28 << 6) + (v28 >> 2)) ^ v28;
    long long v32 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v27 + 64, (uint64_t *)buf);
    if (!v32) {
      goto LABEL_63;
    }
    uint64_t v33 = *v32;
    if (!*v32) {
      goto LABEL_63;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A428, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A428))
    {
      qword_26AF9A420 = re::hashString((re *)"MeshScenes", v71);
      __cxa_guard_release(&qword_26AF9A428);
    }
    unint64_t v34 = qword_26AF9A420;
    size_t v35 = strlen(v23);
    uint64_t v36 = 0x9E3779B97F4A7C17;
    if (v35)
    {
      MurmurHash3_x64_128((uint64_t)v23, v35, 0, (unint64_t *)buf);
      uint64_t v36 = ((*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf)
          - 0x61C8864680B583E9;
    }
    uint64_t v37 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshSceneArrays>>(a2[73].i64[0], ((v34 >> 2) + (v34 << 6) + v36) ^ v34);
    if (!v37) {
      goto LABEL_63;
    }
    uint64_t v38 = v37;
    uint64_t v39 = *(void *)(a2->i64[1] + 88);
    if (v39)
    {
      *(void *)buf = 0x8026BAB35997FC70;
      *(void *)&uint8_t buf[8] = "meshshadow:enableSUMeshCullingPerCaster";
      LOBYTE(v115) = 0;
      if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v39, buf, &v115))
      {
        re::StringID::destroyString((re::StringID *)buf);
        goto LABEL_26;
      }
      int v95 = v115;
      re::StringID::destroyString((re::StringID *)buf);
    }
    else
    {
LABEL_26:
      int v95 = 1;
    }
    *(void *)&long long v103 = 0;
    DWORD2(v103) = 0;
    *(void *)&long long v104 = 0;
    long long v102 = (unint64_t)v11;
    re::DynamicArray<re::MeshPartDrawContext>::setCapacity(&v102, 0);
    ++DWORD2(v103);
    uint64_t v84 = *(void *)(v38 + 48);
    if (!v84)
    {
LABEL_59:
      if ((void)v102)
      {
        if ((void)v104) {
          (*(void (**)(void, void))(*(void *)v102 + 40))(v102, v104);
        }
      }
      a2 = (float32x4_t *)v93;
      id v11 = v81;
      uint64_t v4 = v82;
      unint64_t v20 = (unint64_t)v110;
LABEL_63:
      long long v22 = v88 + 1;
      if (v88 + 1 == v86) {
        goto LABEL_73;
      }
      continue;
    }
    break;
  }
  unint64_t v40 = 0;
  uint64_t v41 = v38 + 8;
  uint64_t v83 = v38 + 8;
  while (1)
  {
    unint64_t v85 = v40;
    uint64_t v42 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](v41, v40);
    uint64_t v43 = *(void *)(v42 + 16);
    if (v43) {
      break;
    }
LABEL_58:
    unint64_t v40 = v85 + 1;
    uint64_t v41 = v83;
    if (v85 + 1 == v84) {
      goto LABEL_59;
    }
  }
  a2 = *(float32x4_t **)(v42 + 32);
  uint64_t v87 = (re::RenderGraphContext *)&a2[41 * v43];
  uint64_t v44 = *(void *)(*((void *)v93 + 1) + 32);
  uint64_t v89 = v44 + 8;
  uint64_t v90 = v44 + 72;
  while (!a2[40].i8[4]
       || !re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v33 + 8, (uint64_t *)&a2[26])|| !a2->i64[1])
  {
LABEL_57:
    a2 += 41;
    if (a2 == (float32x4_t *)v87) {
      goto LABEL_58;
    }
  }
  unint64_t v45 = 0;
  while (1)
  {
    uint64_t v46 = re::DataArray<re::MeshInstance>::get(v90, *(void *)(a2->i64[0] + 8 * v45));
    uint64_t v47 = re::DataArray<re::MeshModel>::get(v89, *(void *)(v46 + 16));
    uint64_t v48 = v47;
    uint64_t v49 = 0;
    float32x4_t v50 = a2[3];
    float32x4_t v51 = a2[4];
    float32x4_t v52 = a2[5];
    float32x4_t v53 = a2[6];
    long long v54 = *(_OWORD *)(v46 + 48);
    long long v55 = *(_OWORD *)(v46 + 64);
    long long v56 = *(_OWORD *)(v46 + 80);
    *(_OWORD *)unint64_t v110 = *(_OWORD *)(v46 + 32);
    *(_OWORD *)&v110[16] = v54;
    *(_OWORD *)&v110[32] = v55;
    long long v111 = v56;
    do
    {
      *(long long *)((char *)&v115 + v49) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v50, COERCE_FLOAT(*(_OWORD *)&v110[v49])), v51, *(float32x2_t *)&v110[v49], 1), v52, *(float32x4_t *)&v110[v49], 2), v53, *(float32x4_t *)&v110[v49], 3);
      v49 += 16;
    }
    while (v49 != 64);
    long long v100 = v116;
    long long v101 = v115;
    long long v98 = v118;
    long long v99 = v117;
    uint64_t v57 = a2[1].i64[0];
    unint64_t v91 = v45;
    if (v57 && (uint64_t v58 = *(void *)(v57 + 96)) != 0)
    {
      this = *(const char ***)(v58 + 8);
      if ((unint64_t)this <= v45)
      {
        uint64_t v109 = 0;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        long long v115 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v110 = 136315906;
        *(void *)&v110[4] = "operator[]";
        *(_WORD *)&v110[12] = 1024;
        *(_DWORD *)&v110[14] = 468;
        *(_WORD *)&v110[18] = 2048;
        *(void *)&v110[20] = v45;
        *(_WORD *)&v110[28] = 2048;
        *(void *)&v110[30] = this;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_76;
      }
      uint64_t v59 = *(void *)(v58 + 16) + 24 * v45;
      unint64_t v60 = *(void *)(v59 + 8);
      uint64_t v94 = *(void *)(v59 + 16);
    }
    else
    {
      unint64_t v60 = 0;
      uint64_t v94 = 0;
    }
    if (*(void *)(v47 + 56)) {
      break;
    }
LABEL_56:
    unint64_t v45 = v91 + 1;
    if (v91 + 1 >= a2->i64[1]) {
      goto LABEL_57;
    }
  }
  unint64_t v20 = 0;
  while (2)
  {
    if (v20 >= v60) {
      uint64_t v61 = 0;
    }
    else {
      uint64_t v61 = *(void *)(v94 + 8 * v20);
    }
    uint64_t v62 = *(void *)(v48 + 64) + 560 * v20;
    int v63 = (((*(_DWORD *)(v62 + 544) ^ *(_DWORD *)(*(void *)(v97 + 40) + 216)) & ~*(_DWORD *)(*(void *)(v97 + 40)
                                                                                               + 220) | *(_DWORD *)(*(void *)(v97 + 40) + 220) & *(_DWORD *)(*(void *)(v97 + 40) + 216)) ^ a2[25].i32[2]) & ~a2[25].i32[3] | a2[25].i32[2] & a2[25].i32[3];
    *(void *)buf = a2[26].i64[0];
    *(void *)&uint8_t buf[8] = 0;
    *(void *)&long long v122 = 0;
    long long v121 = (unint64_t)v62;
    *((void *)&v122 + 1) = v61;
    *(void *)&long long v123 = v97;
    *((void *)&v123 + 1) = 0xFFFF010000000000;
    *(_OWORD *)id v124 = v101;
    long long v125 = v100;
    long long v126 = v99;
    long long v127 = v98;
    uint64_t v129 = 0;
    uint64_t v128 = 0;
    *(_DWORD *)((char *)&v131[1] + 3) = 0;
    *(void *)id v131 = 0;
    *(void *)&v131[3] = 0;
    *(void *)&v131[5] = 0;
    __int16 v132 = 0;
    int v130 = -1;
    int v133 = v63;
    uint64_t v134 = 0x7FFFFFFF00000000;
    int v135 = 0;
    uint64_t v136 = 0xFFFFFFFFLL;
    uint64_t v137 = 0;
    uint64_t v138 = 0;
    long long v64 = *(_OWORD *)(v62 + 448);
    v108[0] = *(_OWORD *)(v62 + 432);
    v108[1] = v64;
    int v130 = v96;
    if (!v95)
    {
LABEL_54:
      uint64_t v69 = *(void *)v93;
      *(void *)&long long v115 = 0;
      DWORD2(v115) = 0;
      uint64_t v70 = re::addDrawCall((uint64_t)v92, (uint64_t)buf, v69, 1u, (uint64_t)&v115);
      *(_DWORD *)(v70 + 40) = *(_DWORD *)(v33 + 56);
      *(_DWORD *)(v70 + 32) = *(_DWORD *)(v33 + 60);
LABEL_55:
      if (++v20 >= *(void *)(v48 + 56)) {
        goto LABEL_56;
      }
      continue;
    }
    break;
  }
  unint64_t v65 = *(unsigned int *)(v33 + 56);
  if (v65 >= *(_DWORD *)(v33 + 60) + (int)v65) {
    goto LABEL_55;
  }
  uint64_t v4 = 112 * v65;
  while (1)
  {
    unint64_t v66 = *(void *)(v7 + 480);
    if (v66 <= v65) {
      break;
    }
    long long v67 = (uint64_t *)(*(void *)(v7 + 488) + v4);
    uint64_t v68 = *v67;
    *(void *)&long long v115 = v67 + 2;
    *((void *)&v115 + 1) = v68;
    if (re::isBoundingBoxInsidePlanes((uint64_t)v108, (uint64_t)&v115, (float32x4_t *)v124)) {
      goto LABEL_54;
    }
    ++v65;
    v4 += 112;
    if (v65 >= (*(_DWORD *)(v33 + 60) + *(_DWORD *)(v33 + 56))) {
      goto LABEL_55;
    }
  }
  uint64_t v109 = 0;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v115 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)unint64_t v110 = 136315906;
  *(void *)&v110[4] = "operator[]";
  *(_WORD *)&v110[12] = 1024;
  *(_DWORD *)&v110[14] = 476;
  *(_WORD *)&v110[18] = 2048;
  *(void *)&v110[20] = v65;
  *(_WORD *)&v110[28] = 2048;
  *(void *)&v110[30] = v66;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_73:
  uint64_t v73 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(a2->i64[1] + 104));
  re::RenderGraphContext::acquireManagedRenderEncoder(v108, a2, v73, 0);
  uint64_t v106 = 0;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs((re::RenderGraphContext *)a2, (uint64_t *)&v102);
  *(_OWORD *)buf = xmmword_23435FD50;
  long long v121 = xmmword_23435FD60;
  long long v122 = xmmword_23435FD80;
  long long v123 = xmmword_23435FBB0;
  *(_OWORD *)id v124 = xmmword_23435FD50;
  long long v125 = xmmword_23435FD60;
  long long v126 = xmmword_23435FD80;
  long long v127 = xmmword_23435FBB0;
  re::DrawTableSlice::DrawTableSlice(&v115, (uint64_t)v92);
  a2[94].i8[8] = 1;
  *(void *)unint64_t v110 = "DrawInstancedDepthOnlyDepthAsColor";
  *(void *)&v110[8] = &v115;
  *(void *)&v110[16] = buf;
  *(void *)&v110[24] = buf;
  *(void *)&v110[32] = 0;
  *(_WORD *)&v110[40] = 513;
  v110[42] = 0;
  *(_WORD *)&v110[44] = 0;
  *(_OWORD *)(v20 + 63) = 0u;
  *(_OWORD *)(v20 + 79) = 0u;
  char v112 = 0;
  uint64_t v113 = v4;
  char v114 = 0;
  re::RenderGraphContext::encodeDrawCalls(a2, &v102, v110);
  a2[94].i8[8] = 0;
  re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)v108);
}

unint64_t re::getCombinedScopeHash(unint64_t this, unint64_t a2, const char *a3)
{
  void v5[2] = *MEMORY[0x263EF8340];
  MurmurHash3_x64_128((uint64_t)"RenderFrame", 11, 0, v5);
  return ((this << 6)
        + (this >> 2)
        - 0x61C8864680B583E9
        + ((v5[1] + (v5[0] << 6) + (v5[0] >> 2) - 0x61C8864680B583E9) ^ v5[0])) ^ this;
}

void re::GenerateProjectiveMeshShadowMapNode::execute(const char **this, re::RenderGraphContext *a2)
{
  uint64_t v4 = a2;
  uint64_t v197 = *MEMORY[0x263EF8340];
  uint64_t v6 = (unsigned char *)*((void *)a2 + 1);
  uint64_t v7 = "SurfaceShaderMeshShadowCaster";
  unint64_t v8 = "projectiveMeshShadowTechnique";
  if (v6[307] && *v6)
  {
    unint64_t v8 = "projectiveMeshShadowTechniqueProgrammableBlending";
    uint64_t v7 = "SurfaceShaderMeshShadowCasterProgrammableBlending";
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A438, memory_order_acquire) & 1) == 0) {
    goto LABEL_120;
  }
  while (1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A448, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A448))
    {
      qword_26AF9A440 = re::hashString((re *)v7, v115);
      __cxa_guard_release(&qword_26AF9A448);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A458, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A458))
    {
      qword_26AF9A450 = re::getCombinedScopeHash((re *)"SceneArray", v116, v117);
      __cxa_guard_release(&qword_26AF9A458);
    }
    uint64_t v9 = re::RenderGraphDataStore::tryGet<re::SceneArrayData>(*((void *)v4 + 146), qword_26AF9A450);
    if (!v9)
    {
      char v112 = *re::graphicsLogObjects(0);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_233120000, v112, OS_LOG_TYPE_DEFAULT, "GenerateProjectiveMeshShadowMapNode::execute: Missing SceneArrayData. Skipping node execution.", buf, 2u);
      }
      return;
    }
    uint64_t v7 = (char *)v9;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A468, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A468))
    {
      qword_26AF9A460 = re::hashString((re *)"ProjectiveMeshShadow", v118);
      __cxa_guard_release(&qword_26AF9A468);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A478, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A478))
    {
      qword_26AF9A470 = re::getCombinedScopeHash(qword_26AF9A460, v119, v120);
      __cxa_guard_release(&qword_26AF9A478);
    }
    uint64_t v10 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(*((void *)v4 + 146), qword_26AF9A470);
    if (!v10) {
      return;
    }
    id v11 = (float *)v10;
    unint64_t v160 = (void *)v10;
    if (*((unsigned char *)v4 + 1332)) {
      goto LABEL_117;
    }
    uint64_t v129 = 0;
LABEL_13:
    long long v125 = v8;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A488, memory_order_acquire) & 1) == 0)
    {
      int v121 = __cxa_guard_acquire(&qword_26AF9A488);
      id v11 = (float *)v160;
      if (v121)
      {
        qword_26AF9A480 = re::hashString((re *)"ShadowClear", v122);
        __cxa_guard_release(&qword_26AF9A488);
        id v11 = (float *)v160;
      }
    }
    uint64_t v12 = v11;
    re::RenderGraphContext::makeFullscreenDrawCall(v4, *((void *)v11 + 16), *((void *)v11 + 17), 0, 0, 0, (int32x2_t *)buf);
    id v13 = re::MaterialParameterTableLayers::resolveTechniqueIndices(v182[0], qword_26AF9A480);
    if (v14) {
      break;
    }
    re::internal::assertLog((re::internal *)6, 0, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_119:
    v162[0] = 0;
    long long v181 = 0u;
    *(_OWORD *)unsigned int v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    *(_OWORD *)buf = 0u;
    unint64_t v8 = (char *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v176 = 136315906;
    *(void *)&v176[4] = "operator[]";
    *(_WORD *)&v176[12] = 1024;
    *(_DWORD *)&v176[14] = 468;
    *(_WORD *)&v176[18] = 2048;
    *(void *)&v176[20] = this;
    *(_WORD *)&v176[28] = 2048;
    *(void *)&v176[30] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_120:
    if (__cxa_guard_acquire(&qword_26AF9A438))
    {
      qword_26AF9A430 = re::hashString((re *)v8, v114);
      __cxa_guard_release(&qword_26AF9A438);
    }
  }
  uint64_t v15 = *((void *)v12 + 56);
  HIDWORD(v180) = *v13;
  LODWORD(v180) = v15;
  *((unsigned char *)v4 + 1512) = 1;
  v175[0] = 0;
  re::encodeFullscreenDrawCall((re::DrawCall *)buf, (uint64_t)"ShadowClear", v4, v129, 0, v175, 0);
  *((unsigned char *)v4 + 1512) = 0;
  float v16 = v12[63];
  float v17 = v12[64];
  id v18 = *(re::Allocator **)(*(void *)v4 + 24);
  uint64_t v19 = (re::DrawTable *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 328, 8);
  float v157 = v18;
  re::DrawTable::DrawTable(v19, v18);
  uint64_t v20 = *((void *)v7 + 3);
  if (v20)
  {
    uint64_t v21 = (const char **)*((void *)v7 + 5);
    long long v22 = &unk_26AF9A000;
    id v124 = &v21[v20];
    float v23 = v16 / v17;
    __asm { FMOV            V9.2S, #1.0 }
    while (1)
    {
      long long v126 = v21;
      id v29 = *v21;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A498, memory_order_acquire) & 1) == 0)
      {
        uint64_t v109 = v22;
        int v110 = __cxa_guard_acquire(&qword_26AF9A498);
        long long v22 = v109;
        if (v110)
        {
          qword_26AF9A490 = re::hashString((re *)"MeshScenes", v111);
          __cxa_guard_release(&qword_26AF9A498);
          long long v22 = v109;
        }
      }
      unint64_t v30 = v22[146];
      size_t v31 = strlen(v29);
      uint64_t v32 = 0x9E3779B97F4A7C17;
      if (v31)
      {
        MurmurHash3_x64_128((uint64_t)v29, v31, 0, (unint64_t *)buf);
        uint64_t v32 = ((*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf)
            - 0x61C8864680B583E9;
      }
      uint64_t v33 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshSceneArrays>>(*((void *)v4 + 146), ((v30 >> 2) + (v30 << 6) + v32) ^ v30);
      uint64_t v34 = v33 ? v33 + 8 : 0;
      uint64_t v132 = *(void *)(v34 + 40);
      if (v132) {
        break;
      }
LABEL_103:
      uint64_t v21 = v126 + 1;
      long long v22 = (void *)&unk_26AF9A000;
      if (v126 + 1 == v124) {
        goto LABEL_109;
      }
    }
    unint64_t v35 = 0;
    while (1)
    {
      unint64_t v134 = v35;
      uint64_t v142 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](v34, v35);
      unint64_t v36 = *(void *)(v142 + 16);
      uint64_t v37 = (float *)v160;
      if (v36) {
        break;
      }
LABEL_102:
      unint64_t v35 = v134 + 1;
      if (v134 + 1 == v132) {
        goto LABEL_103;
      }
    }
    uint64_t v38 = 0;
    uint64_t v39 = *(void *)(*((void *)v4 + 1) + 32);
    uint64_t v133 = v39 + 72;
    uint64_t v40 = v39 + 8;
    while (1)
    {
      uint64_t v41 = *(void *)(v142 + 32);
      uint64_t v143 = v41 + 656 * v38;
      if (*(unsigned char *)(v143 + 643))
      {
        if (*((void *)v37 + 10))
        {
          uint64_t v42 = v41 + 656 * v38;
          unint64_t v43 = *(void *)(v42 + 416);
          unint64_t v44 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v43 ^ (v43 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v43 ^ (v43 >> 30))) >> 27));
          uint64_t v45 = *(unsigned int *)(*((void *)v37 + 11) + 4 * ((v44 ^ (v44 >> 31)) % *((unsigned int *)v37 + 26)));
          if (v45 != 0x7FFFFFFF)
          {
            uint64_t v46 = *((void *)v37 + 12);
            while (*(void *)(v46 + (v45 << 6) + 16) != v43)
            {
              uint64_t v45 = *(_DWORD *)(v46 + (v45 << 6) + 8) & 0x7FFFFFFF;
              if (v45 == 0x7FFFFFFF) {
                goto LABEL_101;
              }
            }
            uint64_t v47 = v41 + 656 * v38;
            if (*(float *)(v47 + 376) != 0.0)
            {
              uint64_t v48 = v41 + 656 * v38;
              if (((*(_DWORD *)(v48 + 408) ^ *(_DWORD *)(v48 + 412)) & 0x10) == 0)
              {
                if (*(void *)(v143 + 8)) {
                  break;
                }
              }
            }
          }
        }
      }
LABEL_101:
      if (++v38 >= v36) {
        goto LABEL_102;
      }
    }
    uint64_t v123 = v34;
    uint64_t v49 = 0;
    double v159 = (char **)(v42 + 416);
    uint64_t v138 = (float *)(v47 + 376);
    uint64_t v149 = (_DWORD *)(v48 + 412);
    unint64_t v150 = (_DWORD *)(v48 + 408);
    uint64_t v50 = v41 + 656 * v38;
    int v135 = (unsigned char *)(v50 + 560);
    uint64_t v127 = v40;
    uint64_t v128 = (_OWORD *)(v50 + 576);
    uint64_t v130 = v50 + 16;
    id v131 = (float32x4_t *)(v50 + 48);
    long long v146 = (void *)(v50 + 112);
    long long v147 = (unint64_t *)(v50 + 120);
    long long v148 = (void *)(v50 + 392);
    double v151 = (unint64_t *)(v50 + 400);
    unint64_t v152 = (_DWORD *)(v50 + 320);
    uint64_t v140 = v38;
    float32x4_t v51 = (void *)v50;
    while (1)
    {
      uint64_t v136 = v49;
      uint64_t v52 = re::DataArray<re::MeshInstance>::get(v133, *(void *)(*v51 + 8 * (void)v49));
      float32x4_t v53 = (_OWORD *)v52;
      if (*v135)
      {
        uint64_t v54 = *(void *)(*((void *)v4 + 1) + 32) + 8;
        uint64_t v55 = v160[9];
      }
      else
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v54 = v127;
      }
      uint64_t v141 = re::DataArray<re::MeshModel>::get(v54, v55);
      uint64_t v56 = 0;
      float32x4_t v57 = *v131;
      float32x4_t v58 = v131[1];
      float32x4_t v59 = v131[2];
      float32x4_t v60 = v131[3];
      long long v61 = v53[3];
      long long v62 = v53[4];
      long long v63 = v53[5];
      *(_OWORD *)double v176 = v53[2];
      *(_OWORD *)&v176[16] = v61;
      *(_OWORD *)&v176[32] = v62;
      long long v177 = v63;
      do
      {
        *(float32x4_t *)&buf[v56] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v57, COERCE_FLOAT(*(_OWORD *)&v176[v56])), v58, *(float32x2_t *)&v176[v56], 1), v59, *(float32x4_t *)&v176[v56], 2), v60, *(float32x4_t *)&v176[v56], 3);
        v56 += 16;
      }
      while (v56 != 64);
      float32x4_t v64 = *(float32x4_t *)buf;
      float32x4_t v65 = (float32x4_t)v179;
      float32x4_t v66 = (float32x4_t)v180;
      float32x4_t v67 = (float32x4_t)v181;
      this = v136;
      uint64_t v37 = (float *)v160;
      if (*v135)
      {
        uint64_t v68 = 0;
        long long v69 = v128[1];
        long long v70 = v128[2];
        long long v71 = v128[3];
        *(_OWORD *)double v176 = *v128;
        *(_OWORD *)&v176[16] = v69;
        *(_OWORD *)&v176[32] = v70;
        long long v177 = v71;
        do
        {
          *(float32x4_t *)&buf[v68] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v64, COERCE_FLOAT(*(_OWORD *)&v176[v68])), v65, *(float32x2_t *)&v176[v68], 1), v66, *(float32x4_t *)&v176[v68], 2), v67, *(float32x4_t *)&v176[v68], 3);
          v68 += 16;
        }
        while (v68 != 64);
        float32x4_t v64 = *(float32x4_t *)buf;
        float32x4_t v65 = (float32x4_t)v179;
        float32x4_t v66 = (float32x4_t)v180;
        float32x4_t v67 = (float32x4_t)v181;
      }
      if (*(void *)v130 && (uint64_t v72 = *(void *)(*(void *)v130 + 96)) != 0)
      {
        uint64_t v7 = *(char **)(v72 + 8);
        if (v7 <= (char *)v136) {
          goto LABEL_119;
        }
        uint64_t v137 = *(void *)(*(void *)(v72 + 16) + 24 * (void)v136 + 16);
        unint64_t v139 = *(void *)(*(void *)(v72 + 16) + 24 * (void)v136 + 8);
      }
      else
      {
        unint64_t v139 = 0;
        uint64_t v137 = 0;
      }
      uint64_t v73 = v141;
      if (*(void *)(v141 + 56)) {
        break;
      }
LABEL_99:
      uint64_t v49 = (const char **)((char *)v136 + 1);
      float32x4_t v51 = (void *)v143;
      if ((unint64_t)v136 + 1 >= *(void *)(v143 + 8))
      {
        unint64_t v36 = *(void *)(v142 + 16);
        uint64_t v34 = v123;
        uint64_t v40 = v127;
        goto LABEL_101;
      }
    }
    unint64_t v74 = 0;
    long long v155 = (__int128)v65;
    float32x4_t v156 = v64;
    long long v153 = (__int128)v67;
    long long v154 = (__int128)v66;
    while (2)
    {
      uint64_t v144 = *(void *)(v73 + 64);
      unint64_t v145 = v74;
      this = (const char **)qword_26AF9A430;
      unint64_t v161 = v144 + 560 * v74;
      unint64_t v75 = *(unsigned __int16 *)(v161 + 474);
      if (*v147 > v75)
      {
        uint64_t v76 = *(void *)(*v146 + 8 * v75);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4A8, memory_order_acquire) & 1) == 0)
        {
          int v108 = __cxa_guard_acquire(&qword_26AF9A4A8);
          uint64_t v37 = (float *)v160;
          if (v108)
          {
            MurmurHash3_x64_128((uint64_t)"Occlusion", 9, 0, (unint64_t *)buf);
            qword_26AF9A4A0 = (*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf;
            __cxa_guard_release(&qword_26AF9A4A8);
            uint64_t v37 = (float *)v160;
          }
        }
        if (v76)
        {
          uint64_t v77 = qword_26AF9A4A0;
          if (re::MaterialParameterTable::kDefaultNameHash(void)::once != -1) {
            dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
          }
          if (!re::MaterialParameterTable::tryGetPassTechniqueMapping((re::MaterialParameterTable *)(v76 + 224), v77, re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash))
          {
            uint64_t v78 = qword_26AF9A440;
            if (re::MaterialParameterTable::kDefaultNameHash(void)::once != -1) {
              dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
            }
            if (re::MaterialParameterTable::tryGetPassTechniqueMapping((re::MaterialParameterTable *)(v76 + 224), v78, re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash))
            {
              this = (const char **)qword_26AF9A440;
            }
            uint64_t v37 = (float *)v160;
            break;
          }
LABEL_91:
          unint64_t v74 = v145 + 1;
          uint64_t v38 = v140;
          uint64_t v73 = v141;
          uint64_t v37 = (float *)v160;
          if (v145 + 1 >= *(void *)(v141 + 56)) {
            goto LABEL_99;
          }
          continue;
        }
      }
      break;
    }
    if (v74 >= v139) {
      uint64_t v158 = 0;
    }
    else {
      uint64_t v158 = *(void *)(v137 + 8 * v74);
    }
    uint64_t v7 = *v159;
    uint64_t v79 = *((void *)v37 + 10);
    unint64_t v80 = (unint64_t)*v159 ^ ((unint64_t)*v159 >> 30);
    if (v79)
    {
      unint64_t v81 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v80) ^ ((0xBF58476D1CE4E5B9 * v80) >> 27));
      uint64_t v82 = *((void *)v37 + 12);
      uint64_t v83 = *(unsigned int *)(*((void *)v37 + 11) + 4 * ((v81 ^ (v81 >> 31)) % *((unsigned int *)v37 + 26)));
      if (v83 != 0x7FFFFFFF)
      {
        while (*(char **)(v82 + (v83 << 6) + 16) != v7)
        {
          uint64_t v83 = *(_DWORD *)(v82 + (v83 << 6) + 8) & 0x7FFFFFFF;
          if (v83 == 0x7FFFFFFF) {
            goto LABEL_74;
          }
        }
LABEL_75:
        uint64_t v84 = v82 + (v83 << 6);
        if (!*(void *)(v84 + 40)) {
          goto LABEL_115;
        }
        unint64_t v2 = **(unsigned int **)(v84 + 56);
        unint64_t v3 = (unsigned __int16 *)*((void *)v37 + 7);
        if ((unint64_t)v3 <= v2) {
          goto LABEL_116;
        }
        float v85 = *(float *)(*((void *)v37 + 8) + 4 * v2);
        unint64_t v2 = (unint64_t)v37;
        float v86 = powf(*v138, v37[65]);
        if (v79
          && (unint64_t v87 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v80) ^ ((0xBF58476D1CE4E5B9 * v80) >> 27)),
              uint64_t v88 = *(unsigned int *)(*(void *)(v2 + 88) + 4 * ((v87 ^ (v87 >> 31)) % *(unsigned int *)(v2 + 104))),
              v88 != 0x7FFFFFFF))
        {
          uint64_t v106 = *(char **)(v82 + (v88 << 6) + 16);
          for (uint64_t i = v88; v106 != v7; v88 = i)
          {
            uint64_t i = *(_DWORD *)(v82 + (i << 6) + 8) & 0x7FFFFFFF;
            uint64_t v88 = 0x7FFFFFFFLL;
            if (i == 0x7FFFFFFF) {
              break;
            }
            uint64_t v106 = *(char **)(v82 + (i << 6) + 16);
          }
        }
        else
        {
          uint64_t v88 = 0x7FFFFFFFLL;
        }
        uint64_t v89 = v82 + (v88 << 6);
        uint64_t v90 = *(void *)(v89 + 40);
        if (v90)
        {
          unint64_t v3 = (unsigned __int16 *)(v161 + 474);
          float v91 = v23 * (float)(v85 * v86);
          uint64_t v7 = *(char **)(v89 + 56);
          uint64_t v92 = 4 * v90;
          while (1)
          {
            uint64_t v93 = (uint64_t)v19;
            uint64_t v94 = (uint64_t *)v4;
            unint64_t v2 = *(unsigned int *)v7;
            uint64_t v95 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v157 + 32))(v157, 224, 16);
            uint64_t v96 = v95;
            *(_OWORD *)(v95 + 128) = 0u;
            *(_OWORD *)(v95 + 144) = 0u;
            *(_OWORD *)(v95 + 160) = 0u;
            *(_OWORD *)(v95 + 176) = 0u;
            *(_OWORD *)(v95 + 192) = 0u;
            *(_OWORD *)(v95 + 208) = 0u;
            *(_OWORD *)(v95 + 96) = 0u;
            *(_OWORD *)(v95 + 112) = 0u;
            *(_OWORD *)(v95 + 64) = 0u;
            *(_OWORD *)(v95 + 80) = 0u;
            *(_OWORD *)(v95 + 32) = 0u;
            *(_OWORD *)(v95 + 48) = 0u;
            *(_OWORD *)uint64_t v95 = 0u;
            *(_OWORD *)(v95 + 16) = 0u;
            *(void *)(v95 + 156) = _D9;
            *(float *)(v95 + 152) = v91;
            uint64_t v97 = v160 + 2;
            if (this == (const char **)qword_26AF9A440)
            {
              unint64_t v98 = *v3;
              uint64_t v97 = v160 + 2;
              if (*v147 > v98) {
                uint64_t v97 = (void *)(*v146 + 8 * v98);
              }
            }
            *(void *)(v95 + 40) = *v97;
            uint64_t v4 = (re::RenderGraphContext *)v160[4];
            if ((unint64_t)v4 <= v2) {
              break;
            }
            *(void *)(v95 + 72) = *(void *)(v160[5] + 8 * v2);
            *(_DWORD *)(v95 + 120) = *v152;
            long long v99 = (unsigned int *)re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v95, (uint64_t)this);
            if (!v100) {
              goto LABEL_113;
            }
            unint64_t v2 = *v99;
            uint64_t v4 = (re::RenderGraphContext *)((*(_DWORD *)(v144 + 560 * v145 + 544) ^ *(_DWORD *)(*(void *)(v96 + 40)
                                                                                              + 216)) & ~*(_DWORD *)(*(void *)(v96 + 40) + 220) | (*(_DWORD *)(*(void *)(v96 + 40) + 220) & *(_DWORD *)(*(void *)(v96 + 40) + 216)));
            unint64_t v101 = *v151;
            if (*v151)
            {
              unint64_t v102 = *v3;
              if (v101 <= v102) {
                goto LABEL_114;
              }
              unint64_t v103 = re::MaterialRenderFlags::flattenToOverrideFlags((re::MaterialRenderFlags *)(*v148 + 18 * *v3));
              LODWORD(v4) = (v4 ^ v103) & ~HIDWORD(v103) | HIDWORD(v103) & v103;
            }
            unsigned int v104 = (*v150 ^ v4) & ~*v149 | *v150 & *v149;
            *(void *)buf = *v159;
            *(void *)&uint8_t buf[8] = 0;
            *(void *)&long long v180 = 0;
            long long v179 = v161;
            *((void *)&v180 + 1) = v158;
            *(void *)&long long v181 = v96;
            *((void *)&v181 + 1) = 0xFFFF010000000000;
            *(float32x4_t *)unsigned int v182 = v156;
            long long v183 = v155;
            long long v184 = v154;
            long long v185 = v153;
            uint64_t v187 = 0;
            uint64_t v186 = 0;
            *(void *)uint64_t v189 = 0;
            *(_DWORD *)((char *)&v189[1] + 3) = 0;
            *(void *)&v189[3] = 0;
            *(void *)&v189[5] = 0;
            __int16 v190 = 0;
            int v188 = v2;
            unsigned int v191 = v104;
            uint64_t v192 = 0x7FFFFFFF00000000;
            int v193 = 0;
            uint64_t v194 = 0xFFFFFFFFLL;
            uint64_t v195 = 0;
            uint64_t v196 = 0;
            uint64_t v4 = (re::RenderGraphContext *)v94;
            uint64_t v105 = *v94;
            uint64_t v173 = 0;
            int v174 = 0;
            uint64_t v19 = (re::DrawTable *)v93;
            re::addDrawCall(v93, (uint64_t)buf, v105, 1u, (uint64_t)&v173);
            v7 += 4;
            v92 -= 4;
            if (!v92) {
              goto LABEL_91;
            }
          }
          v162[0] = 0;
          long long v181 = 0uLL;
          *(_OWORD *)unsigned int v182 = 0uLL;
          long long v179 = 0uLL;
          long long v180 = 0uLL;
          *(_OWORD *)buf = 0uLL;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)double v176 = 136315906;
          *(void *)&v176[4] = "operator[]";
          *(_WORD *)&v176[12] = 1024;
          *(_DWORD *)&v176[14] = 476;
          *(_WORD *)&v176[18] = 2048;
          *(void *)&v176[20] = v2;
          *(_WORD *)&v176[28] = 2048;
          *(void *)&v176[30] = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_113:
          re::internal::assertLog((re::internal *)6, v100, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
          _os_crash();
          __break(1u);
LABEL_114:
          re::internal::assertLog((re::internal *)6, v100, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, v102, v101);
          _os_crash();
          __break(1u);
LABEL_115:
          v162[0] = 0;
          long long v181 = 0u;
          *(_OWORD *)unsigned int v182 = 0u;
          long long v179 = 0u;
          long long v180 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)double v176 = 136315906;
          *(void *)&v176[4] = "operator[]";
          *(_WORD *)&v176[12] = 1024;
          *(_DWORD *)&v176[14] = 797;
          *(_WORD *)&v176[18] = 2048;
          *(void *)&v176[20] = 0;
          *(_WORD *)&v176[28] = 2048;
          *(void *)&v176[30] = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_116:
          v162[0] = 0;
          long long v181 = 0u;
          *(_OWORD *)unsigned int v182 = 0u;
          long long v179 = 0u;
          long long v180 = 0u;
          *(_OWORD *)buf = 0u;
          unint64_t v8 = (char *)&_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)double v176 = 136315906;
          *(void *)&v176[4] = "operator[]";
          *(_WORD *)&v176[12] = 1024;
          *(_DWORD *)&v176[14] = 476;
          *(_WORD *)&v176[18] = 2048;
          *(void *)&v176[20] = v2;
          *(_WORD *)&v176[28] = 2048;
          *(void *)&v176[30] = v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_117:
          uint64_t v113 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)v4 + 1336), this[2], 0);
          id v11 = (float *)v160;
          uint64_t v129 = v113;
          goto LABEL_13;
        }
        goto LABEL_91;
      }
    }
    else
    {
      uint64_t v82 = *((void *)v37 + 12);
    }
LABEL_74:
    uint64_t v83 = 0x7FFFFFFFLL;
    goto LABEL_75;
  }
LABEL_109:
  if (*((void *)v19 + 5))
  {
    *(_OWORD *)buf = xmmword_23435FD50;
    long long v179 = xmmword_23435FD60;
    long long v180 = xmmword_23435FD80;
    long long v181 = xmmword_23435FBB0;
    *(_OWORD *)unsigned int v182 = xmmword_23435FD50;
    long long v183 = xmmword_23435FD60;
    long long v184 = xmmword_23435FD80;
    long long v185 = xmmword_23435FBB0;
    re::DrawTableSlice::DrawTableSlice(v176, (uint64_t)v19);
    *((unsigned char *)v4 + 1512) = 1;
    uint64_t v172 = 0;
    memset(v171, 0, sizeof(v171));
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(v4, (uint64_t *)v171);
    v162[0] = v125;
    v162[1] = v176;
    v162[2] = buf;
    v162[3] = buf;
    v162[4] = 0;
    __int16 v163 = 513;
    char v164 = 0;
    __int16 v165 = 0;
    long long v166 = 0u;
    long long v167 = 0u;
    char v168 = 0;
    uint64_t v169 = v129;
    char v170 = 1;
    re::RenderGraphContext::encodeDrawCalls(v4, v171, v162);
    *((unsigned char *)v4 + 1512) = 0;
  }
}

uint64_t re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderProjectiveMeshShadowPatchesNode *this, re::RenderGraphContext *a2)
{
  uint64_t v228 = *MEMORY[0x263EF8340];
  uint64_t result = re::RenderGraphDataStore::tryGet<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!result) {
    return result;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A4B8))
  {
    qword_26AF9A4B0 = re::hashString((re *)"ProjectiveMeshShadow", v135);
    __cxa_guard_release(&qword_26AF9A4B8);
  }
  __int16 v165 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A4C8))
  {
    qword_26AF9A4C0 = re::getCombinedScopeHash(qword_26AF9A4B0, v136, v137);
    __cxa_guard_release(&qword_26AF9A4C8);
  }
  int v195 = 1;
  uint64_t v4 = *(void *)(*((void *)a2 + 1) + 88);
  if (!v4) {
    goto LABEL_7;
  }
  *(void *)&long long v207 = 0x8E55C4195E970258;
  *((void *)&v207 + 1) = "meshshadow:visualizeShadows";
  v202[0] = 0;
  if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v4, &v207, v202))
  {
    re::StringID::destroyString((re::StringID *)&v207);
LABEL_7:
    int v156 = 0;
    goto LABEL_8;
  }
  int v12 = v202[0];
  re::StringID::destroyString((re::StringID *)&v207);
  if (!v12) {
    goto LABEL_7;
  }
  int v156 = 1;
LABEL_8:
  uint64_t v5 = *(void *)(*((void *)v165 + 1) + 88);
  if (!v5)
  {
LABEL_11:
    char v149 = 1;
    goto LABEL_12;
  }
  *(void *)&long long v207 = 0xB54CABA028476570;
  *((void *)&v207 + 1) = "meshshadow:visualizeDepthPrepass";
  v202[0] = 0;
  if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v5, &v207, v202))
  {
    re::StringID::destroyString((re::StringID *)&v207);
    goto LABEL_11;
  }
  int v13 = v202[0];
  re::StringID::destroyString((re::StringID *)&v207);
  if (!v13) {
    goto LABEL_11;
  }
  char v149 = 0;
LABEL_12:
  uint64_t v6 = *(void *)(*((void *)v165 + 1) + 88);
  if (!v6)
  {
LABEL_15:
    int v155 = 0;
    goto LABEL_16;
  }
  *(void *)&long long v207 = 0x8E55C417E7AA3440;
  *((void *)&v207 + 1) = "meshshadow:visualizeOverlap";
  v202[0] = 0;
  if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v6, &v207, v202))
  {
    re::StringID::destroyString((re::StringID *)&v207);
    goto LABEL_15;
  }
  int v14 = v202[0];
  re::StringID::destroyString((re::StringID *)&v207);
  if (!v14) {
    goto LABEL_15;
  }
  int v155 = 1;
LABEL_16:
  BOOL v7 = re::internal::shadows::g_enableMaxBlend != 0;
  uint64_t v8 = *(void *)(*((void *)v165 + 1) + 88);
  if (v8)
  {
    *(void *)&long long v207 = 0x8B008DEF08584B7ALL;
    *((void *)&v207 + 1) = "meshshadow:enableMaxBlend";
    v202[0] = 0;
    if (!re::DebugSettingsManager::getWithErrorCode<BOOL>(v8, &v207, v202)) {
      BOOL v7 = v202[0] != 0;
    }
    re::StringID::destroyString((re::StringID *)&v207);
  }
  if (*((unsigned char *)this + 256))
  {
    uint64_t v9 = &qword_26AF9A5E0;
    if ((atomic_load_explicit(algn_26AF9A5E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire((__guard *)algn_26AF9A5E8))
    {
      qword_26AF9A5E0 = re::hashString((re *)"PatchShadowReceiverDepthOnly", v142);
      uint64_t v143 = (__guard *)algn_26AF9A5E8;
      uint64_t v10 = re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::depthOnlyPassName;
LABEL_190:
      __cxa_guard_release(v143);
      goto LABEL_36;
    }
    uint64_t v10 = re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::depthOnlyPassName;
  }
  else
  {
    char v11 = !v7;
    if (!*((unsigned char *)this + 258)) {
      char v11 = 1;
    }
    if (v11)
    {
      uint64_t v9 = &qword_26AF9A600;
      if ((atomic_load_explicit(algn_26AF9A608, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire((__guard *)algn_26AF9A608))
      {
        qword_26AF9A600 = re::hashString((re *)"DrawMeshShadowPatchReceiver", v148);
        uint64_t v143 = (__guard *)algn_26AF9A608;
        uint64_t v10 = &re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::defaultPassName;
        goto LABEL_190;
      }
      uint64_t v10 = &re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::defaultPassName;
    }
    else
    {
      uint64_t v9 = &qword_26AF9A5F0;
      if ((atomic_load_explicit(algn_26AF9A5F8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire((__guard *)algn_26AF9A5F8))
      {
        qword_26AF9A5F0 = re::hashString((re *)"DrawMeshShadowPatchReceiverMaxBlend", v147);
        uint64_t v143 = (__guard *)algn_26AF9A5F8;
        uint64_t v10 = re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::maxBlendPassName;
        goto LABEL_190;
      }
      uint64_t v10 = re::RenderProjectiveMeshShadowPatchesNode::execute(re::RenderGraphContext &)::$_4::operator() const(void)::maxBlendPassName;
    }
  }
LABEL_36:
  unint64_t v15 = *v9;
  unint64_t v152 = *v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A4D8))
  {
    qword_26AF9A4D0 = re::hashString((re *)"MeshShadowPatchReceiverDepthPrepass", v138);
    __cxa_guard_release(&qword_26AF9A4D8);
  }
  float v16 = v165;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A4E8))
  {
    int v139 = [*(id *)(*((void *)v165 + 1) + 184) supportsShaderBarycentricCoordinates];
    uint64_t v140 = "MeshShadowPatchReceiverVisualizeDepthPrepass";
    if (v139) {
      uint64_t v140 = "MeshShadowPatchReceiverVisualizeDepthPrepassWithWireframe";
    }
    qword_26AF9A4E0 = (uint64_t)v140;
    __cxa_guard_release(&qword_26AF9A4E8);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A4F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A4F8))
  {
    qword_26AF9A4F0 = re::hashString((re *)qword_26AF9A4E0, v141);
    float v16 = v165;
    __cxa_guard_release(&qword_26AF9A4F8);
  }
  uint64_t result = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowRenderingData>>(*((void *)v16 + 146), qword_26AF9A4C0);
  uint64_t v17 = result;
  if (*((unsigned char *)v16 + 1332))
  {
LABEL_161:
    uint64_t result = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)v16 + 1336), *((const char **)this + 2), 0);
    uint64_t v154 = result;
    if (!v17) {
      return result;
    }
  }
  else
  {
    uint64_t v154 = 0;
    if (!result) {
      return result;
    }
  }
  if (!*(_DWORD *)(v17 + 20)) {
    return result;
  }
  uint64_t v158 = *(re::Allocator **)(*(void *)v165 + 24);
  uint64_t v18 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v158 + 32))(v158, 224, 16);
  *(_OWORD *)uint64_t v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + 32) = 0u;
  *(_OWORD *)(v18 + 48) = 0u;
  *(_OWORD *)(v18 + 64) = 0u;
  *(_OWORD *)(v18 + 80) = 0u;
  *(_OWORD *)(v18 + 96) = 0u;
  *(_OWORD *)(v18 + 112) = 0u;
  *(_OWORD *)(v18 + 128) = 0u;
  *(_OWORD *)(v18 + 144) = 0u;
  *(_OWORD *)(v18 + 160) = 0u;
  *(_OWORD *)(v18 + 176) = 0u;
  *(_OWORD *)(v18 + 192) = 0u;
  *(_OWORD *)(v18 + 208) = 0u;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v18 + 152) = _D0;
  *(_DWORD *)(v18 + 160) = 1065353216;
  *(_OWORD *)(v18 + 40) = *(_OWORD *)(v17 + 56);
  unint64_t v178 = (re::MaterialParameterTableLayers *)v18;
  unint64_t v24 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v18, v15);
  if (!v25)
  {
    re::internal::assertLog((re::internal *)6, 0, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_164;
  }
  int v26 = *v24;
  uint64_t v150 = *(void *)(*((void *)v165 + 1) + 168);
  if (*((unsigned char *)this + 256) || *((unsigned char *)this + 257))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A508, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A508))
    {
      qword_26AF9A500 = re::hashString((re *)"SetStencilForBackgroundPixels", v146);
      __cxa_guard_release(&qword_26AF9A508);
    }
    re::RenderGraphContext::makeFullscreenDrawCall(v165, *(void *)(v17 + 56), 0, 0, 0, 0, (int32x2_t *)&v207);
    uint64_t v27 = re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v211, qword_26AF9A500);
    if (v28)
    {
      HIDWORD(v209) = *v27;
      *((unsigned char *)v165 + 1512) = 1;
      char v192 = 1;
      long long v193 = __const__ZN2re20FeatureStencilStates17getMeshShadowInfoENS0_15MeshShadowUsageE_kWriteStInfo;
      char v194 = 0x80;
      re::encodeFullscreenDrawCall((re::DrawCall *)&v207, (uint64_t)"SetStencilForBackgroundPixels", v165, v154, 0, &v192, 0);
      *((unsigned char *)v165 + 1512) = 0;
      goto LABEL_48;
    }
LABEL_164:
    re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_165:
    re::internal::assertLog((re::internal *)6, v100, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_166:
    re::internal::assertLog((re::internal *)6, v111, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_167:
    re::internal::assertLog((re::internal *)6, v117, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
LABEL_48:
  uint64_t v153 = re::RenderGraphDataStore::get<re::CameraMatrices>(*((void *)v165 + 146), *(void *)(*((void *)v165 + 5) + 48));
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A518, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A518))
  {
    qword_26AF9A510 = re::getCombinedScopeHash((re *)"SceneArray", v144, v145);
    __cxa_guard_release(&qword_26AF9A518);
  }
  uint64_t result = re::RenderGraphDataStore::tryGet<re::SceneArrayData>(*((void *)v165 + 146), qword_26AF9A510);
  uint64_t v29 = *(void *)(result + 24);
  if (v29)
  {
    unint64_t v30 = *(const char ***)(result + 40);
    float v157 = &v30[v29];
    int v167 = v26;
    while (1)
    {
      double v159 = v30;
      size_t v31 = *v30;
      unint64_t v32 = qword_26AF9A4B0;
      size_t v33 = strlen(*v30);
      unint64_t v34 = 0x9E3779B97F4A7C17;
      if (v33)
      {
        MurmurHash3_x64_128((uint64_t)v31, v33, 0, (unint64_t *)&v207);
        unint64_t v34 = ((*((void *)&v207 + 1) - 0x61C8864680B583E9 + ((void)v207 << 6) + ((unint64_t)v207 >> 2)) ^ v207)
            - 0x61C8864680B583E9;
      }
      uint64_t result = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneRenderingData>>(*((void *)v165 + 146), ((v32 >> 2) + (v32 << 6) + v34) ^ v32);
      uint64_t v160 = result;
      if (!result) {
        goto LABEL_141;
      }
      uint64_t v35 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v158 + 32))(v158, 64, 8);
      *(_OWORD *)uint64_t v35 = 0u;
      *(_OWORD *)(v35 + 16) = 0u;
      *(_OWORD *)(v35 + 32) = 0u;
      *(_OWORD *)(v35 + 48) = 0u;
      re::HashBrown<unsigned long long,re::ecs2::PortalServiceQuery::WorldType,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::init((void *)v35, (uint64_t)v158, 5);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A528, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A528))
      {
        qword_26AF9A520 = re::hashString((re *)"MeshShadowUseFlatShadows", v127);
        __cxa_guard_release(&qword_26AF9A528);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A538, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A538))
      {
        qword_26AF9A530 = re::hashString((re *)"ImmersionOption", v128);
        __cxa_guard_release(&qword_26AF9A538);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A548, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A548))
      {
        qword_26AF9A540 = re::hashString((re *)"MeshShadowRenderAsRGB", v129);
        __cxa_guard_release(&qword_26AF9A548);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A558, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A558))
      {
        qword_26AF9A550 = re::hashString((re *)"MeshShadowEnableFlatShadowMeshFallback", v130);
        __cxa_guard_release(&qword_26AF9A558);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A568, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A568))
      {
        qword_26AF9A560 = re::hashString((re *)"MeshShadowVisualizeOverlap", v131);
        __cxa_guard_release(&qword_26AF9A568);
      }
      if (re::internal::shadows::g_enableShadowFlattening) {
        BOOL v36 = *(unsigned char *)(v160 + 16) == 0;
      }
      else {
        BOOL v36 = 0;
      }
      *(void *)&long long v207 = qword_26AF9A520;
      *(_DWORD *)unint64_t v202 = v36;
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addNew((_anonymous_namespace_ *)v35, &v207, (int *)v202);
      *(void *)&long long v207 = qword_26AF9A530;
      if (re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v35, &v207) == -1)re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::internalAdd((_anonymous_namespace_ *)v35, &v207, &v195); {
      *(void *)&long long v207 = qword_26AF9A540;
      }
      *(_DWORD *)unint64_t v202 = v156;
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addNew((_anonymous_namespace_ *)v35, &v207, (int *)v202);
      *(void *)&long long v207 = qword_26AF9A550;
      *(_DWORD *)unint64_t v202 = re::internal::shadows::g_enableMeshDepthFallbackWhenFlattening;
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addNew((_anonymous_namespace_ *)v35, &v207, (int *)v202);
      *(void *)&long long v207 = qword_26AF9A560;
      *(_DWORD *)unint64_t v202 = v155;
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addNew((_anonymous_namespace_ *)v35, &v207, (int *)v202);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A578, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A578))
      {
        qword_26AF9A570 = re::hashString((re *)"DynamicFunctionConstants", v132);
        __cxa_guard_release(&qword_26AF9A578);
      }
      unint64_t v37 = qword_26AF9A570;
      size_t v38 = strlen(*((const char **)this + 4));
      unint64_t v39 = 0x9E3779B97F4A7C17;
      if (v38)
      {
        MurmurHash3_x64_128(*((void *)this + 4), v38, 0, (unint64_t *)&v207);
        unint64_t v39 = ((*((void *)&v207 + 1) - 0x61C8864680B583E9 + ((void)v207 << 6) + ((unint64_t)v207 >> 2)) ^ v207)
            - 0x61C8864680B583E9;
      }
      uint64_t v40 = re::RenderGraphDataStore::tryGet<re::DynamicFunctionConstantsData>(*((void *)v165 + 146), ((v37 >> 2) + (v37 << 6) + v39) ^ v37);
      uint64_t v41 = v40 + 8;
      if (!v40) {
        uint64_t v41 = 0;
      }
      *((void *)v178 + 11) = v35;
      *((void *)v178 + 12) = v41;
      *((void *)v178 + 13) = 0;
      *((unsigned char *)v178 + 112) = 0;
      uint64_t v42 = (re::DrawTable *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v158 + 32))(v158, 328, 8);
      re::DrawTable::DrawTable(v42, v158);
      if (!v36) {
        break;
      }
      unint64_t v43 = *(void *)(v150 + 256);
      int v44 = (*(_DWORD *)(v43 + 544) ^ *(_DWORD *)(*((void *)v178 + 5) + 216)) & ~*(_DWORD *)(*((void *)v178 + 5)
                                                                                               + 220) | *(_DWORD *)(*((void *)v178 + 5) + 220) & *(_DWORD *)(*((void *)v178 + 5) + 216);
      long long v207 = 0uLL;
      long long v209 = 0uLL;
      long long v208 = v43;
      *(void *)&long long v210 = v178;
      long long v211 = xmmword_23435FD50;
      long long v212 = xmmword_23435FD60;
      long long v213 = xmmword_23435FD80;
      long long v214 = xmmword_23435FBB0;
      uint64_t v216 = 0;
      *((void *)&v210 + 1) = 0xFFFF010000000000;
      uint64_t v215 = 0;
      memset(v218, 0, sizeof(v218));
      uint64_t v219 = 0;
      uint64_t v220 = 0;
      __int16 v221 = 0;
      int v217 = v26;
      LODWORD(v222) = v44;
      *(void *)((char *)&v222 + 4) = 0x7FFFFFFF00000000;
      HIDWORD(v222) = 0;
      uint64_t v223 = 0xFFFFFFFFLL;
      uint64_t v224 = 0;
      uint64_t v225 = 0;
      uint64_t v45 = *(void *)v165;
      unsigned __int32 v46 = *(unsigned __int8 *)(v153 + 128);
      uint64_t v190 = 0;
      int v191 = 0;
      uint64_t v47 = re::addDrawCall((uint64_t)v42, (uint64_t)&v207, v45, v46, (uint64_t)&v190);
      *(_DWORD *)(v47 + 40) = *(_DWORD *)(v160 + 8);
      *(_DWORD *)(v47 + 32) = *(_DWORD *)(v160 + 12);
      uint64_t v48 = (uint64_t)v42;
LABEL_135:
      if (*((unsigned char *)this + 256) || *((unsigned char *)this + 257))
      {
        char v124 = 0;
        *(_OWORD *)double v226 = __const__ZN2re20FeatureStencilStates17getMeshShadowInfoENS0_15MeshShadowUsageE_kReadStInfo;
        v226[16] = 0x80;
        char v125 = 1;
      }
      else
      {
        char v125 = 0;
        char v124 = 1;
      }
      re::DrawTableSlice::DrawTableSlice(&v207, v48);
      *((unsigned char *)v165 + 1512) = 1;
      *(void *)unint64_t v202 = v152;
      *(void *)&v202[8] = &v207;
      uint64_t v126 = *(void *)(v153 + 80);
      *(void *)&v202[16] = *(void *)(v153 + 40);
      *(void *)&v202[24] = v126;
      *(void *)&v202[32] = 0;
      v202[40] = *(unsigned char *)(v153 + 128);
      *(_WORD *)&v202[41] = 0;
      v202[44] = 0;
      v202[45] = v125;
      if ((v124 & 1) == 0)
      {
        *(_OWORD *)&v202[46] = *(_OWORD *)v226;
        v202[62] = v226[16];
      }
      char v204 = 0;
      *(_OWORD *)&v202[63] = 0u;
      long long v203 = 0u;
      uint64_t v205 = v154;
      char v206 = 0;
      re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(v165, (uint64_t *)&v197);
      uint64_t result = re::RenderGraphContext::encodeDrawCalls(v165, &v197, v202);
      *((unsigned char *)v165 + 1512) = 0;
LABEL_141:
      unint64_t v30 = v159 + 1;
      if (v159 + 1 == v157) {
        return result;
      }
    }
    uint64_t v151 = (uint64_t)v42;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9A588))
    {
      qword_26AF9A580 = re::hashString((re *)"MeshScenes", v133);
      __cxa_guard_release(&qword_26AF9A588);
    }
    unint64_t v49 = qword_26AF9A580;
    size_t v50 = strlen(v31);
    unint64_t v51 = 0x9E3779B97F4A7C17;
    if (v50)
    {
      MurmurHash3_x64_128((uint64_t)v31, v50, 0, (unint64_t *)&v207);
      unint64_t v51 = ((*((void *)&v207 + 1) - 0x61C8864680B583E9 + ((void)v207 << 6) + ((unint64_t)v207 >> 2)) ^ v207)
          - 0x61C8864680B583E9;
    }
    uint64_t result = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshSceneArrays>>(*((void *)v165 + 146), ((v49 >> 2) + (v49 << 6) + v51) ^ v49);
    if (!result) {
      goto LABEL_141;
    }
    uint64_t v52 = result;
    unint64_t v198 = 0;
    unint64_t v199 = 0;
    int v200 = 0;
    uint64_t v201 = 0;
    uint64_t v197 = (uint64_t *)v158;
    re::DynamicArray<re::MeshPartDrawContext>::setCapacity(&v197, 0);
    ++v200;
    uint64_t v162 = *(void *)(v52 + 48);
    if (v162)
    {
      unint64_t v53 = 0;
      uint64_t v161 = v52 + 8;
      do
      {
        unint64_t v164 = v53;
        uint64_t v54 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](v161, v53);
        uint64_t v55 = *(void *)(v54 + 16);
        if (v55)
        {
          uint64_t v56 = *(float32x4_t **)(v54 + 32);
          long long v166 = &v56[41 * v55];
          uint64_t v57 = *(void *)(*((void *)v165 + 1) + 32);
          uint64_t v168 = v57 + 8;
          uint64_t v169 = v57 + 72;
          do
          {
            if (v56[40].i8[4])
            {
              long long v179 = v56;
              BOOL v58 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v160 + 24, (uint64_t *)&v56[26]);
              uint64_t v56 = v179;
              if (v58)
              {
                if (v179->i64[1])
                {
                  unint64_t v59 = 0;
                  do
                  {
                    unint64_t v170 = v59;
                    uint64_t v60 = re::DataArray<re::MeshInstance>::get(v169, *(void *)(v56->i64[0] + 8 * v59));
                    long long v61 = (_anonymous_namespace_ *)re::DataArray<re::MeshModel>::get(v168, *(void *)(v60 + 16));
                    uint64_t v56 = v179;
                    uint64_t v62 = 0;
                    float32x4_t v63 = v179[3];
                    float32x4_t v64 = v179[4];
                    float32x4_t v65 = v179[5];
                    float32x4_t v66 = v179[6];
                    long long v67 = *(_OWORD *)(v60 + 48);
                    long long v68 = *(_OWORD *)(v60 + 64);
                    long long v69 = *(_OWORD *)(v60 + 80);
                    *(_OWORD *)unint64_t v202 = *(_OWORD *)(v60 + 32);
                    *(_OWORD *)&v202[16] = v67;
                    *(_OWORD *)&v202[32] = v68;
                    *(_OWORD *)&v202[48] = v69;
                    do
                    {
                      *(long long *)((char *)&v207 + v62) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v63, COERCE_FLOAT(*(_OWORD *)&v202[v62])), v64, *(float32x2_t *)&v202[v62], 1), v65, *(float32x4_t *)&v202[v62], 2), v66, *(float32x4_t *)&v202[v62], 3);
                      v62 += 16;
                    }
                    while (v62 != 64);
                    long long v70 = v207;
                    long long v71 = v208;
                    long long v72 = v209;
                    long long v73 = v210;
                    uint64_t v74 = v179[1].i64[0];
                    unint64_t v75 = v178;
                    if (v74 && (uint64_t v76 = *(void *)(v74 + 96)) != 0)
                    {
                      unint64_t v15 = *(void *)(v76 + 8);
                      uint64_t v17 = v170;
                      if (v15 <= v170)
                      {
                        uint64_t v196 = 0;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v207 = 0u;
                        float v16 = (re::RenderGraphContext *)&_os_log_internal;
                        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)unint64_t v202 = 136315906;
                        *(void *)&v202[4] = "operator[]";
                        *(_WORD *)&v202[12] = 1024;
                        *(_DWORD *)&v202[14] = 468;
                        *(_WORD *)&v202[18] = 2048;
                        *(void *)&v202[20] = v170;
                        *(_WORD *)&v202[28] = 2048;
                        *(void *)&v202[30] = v15;
                        _os_log_send_and_compose_impl();
                        _os_crash_msg();
                        __break(1u);
                        goto LABEL_161;
                      }
                      uint64_t v77 = *(void *)(v76 + 16) + 24 * v170;
                      unint64_t v78 = *(void *)(v77 + 8);
                      uint64_t v79 = *(void *)(v77 + 16);
                    }
                    else
                    {
                      unint64_t v78 = 0;
                      uint64_t v79 = 0;
                    }
                    if (*((void *)v61 + 7))
                    {
                      unint64_t v80 = 0;
                      uint64_t v81 = 544;
                      long long v177 = v61;
                      long long v175 = v208;
                      long long v176 = v207;
                      long long v173 = v210;
                      long long v174 = v209;
                      uint64_t v171 = v79;
                      unint64_t v172 = v78;
                      do
                      {
                        if (v80 >= v78) {
                          uint64_t v82 = 0;
                        }
                        else {
                          uint64_t v82 = *(void *)(v79 + 8 * v80);
                        }
                        uint64_t v83 = *((void *)v61 + 8);
                        uint64_t v84 = *((void *)v75 + 5);
                        int v85 = *(_DWORD *)(v83 + v81);
                        int v86 = *(_DWORD *)(v84 + 216);
                        int v87 = *(_DWORD *)(v84 + 220);
                        __int32 v88 = v56[25].i32[3];
                        __int32 v89 = v56[25].i32[2];
                        uint64_t v90 = v56[26].i64[0];
                        memset(&v227[1], 0, 18);
                        *(void *)&v226[4] = 0;
                        *(void *)&v226[12] = 0;
                        unint64_t v91 = v199;
                        if (v199 >= v198)
                        {
                          unint64_t v92 = v199 + 1;
                          if (v198 < v199 + 1)
                          {
                            uint64_t v180 = v82;
                            if (v197)
                            {
                              unint64_t v93 = 2 * v198;
                              if (!v198) {
                                unint64_t v93 = 8;
                              }
                              if (v93 <= v92) {
                                unint64_t v94 = v199 + 1;
                              }
                              else {
                                unint64_t v94 = v93;
                              }
                              re::DynamicArray<re::MeshPartDrawContext>::setCapacity(&v197, v94);
                            }
                            else
                            {
                              re::DynamicArray<re::MeshPartDrawContext>::setCapacity(&v197, v92);
                              ++v200;
                            }
                            unint64_t v75 = v178;
                            long long v61 = v177;
                            uint64_t v56 = v179;
                            uint64_t v82 = v180;
                            long long v71 = v175;
                            long long v70 = v176;
                            long long v73 = v173;
                            long long v72 = v174;
                            uint64_t v79 = v171;
                            unint64_t v78 = v172;
                          }
                          unint64_t v91 = v199;
                        }
                        uint64_t v95 = v201 + 224 * v91;
                        *(void *)uint64_t v95 = v90;
                        *(void *)(v95 + 8) = 0;
                        *(void *)(v95 + 16) = v83 + v81 - 544;
                        *(void *)(v95 + 24) = 0;
                        *(void *)(v95 + 32) = 0;
                        *(void *)(v95 + 40) = v82;
                        *(void *)(v95 + 48) = v75;
                        *(void *)(v95 + 56) = 0xFFFF010000000000;
                        *(_OWORD *)(v95 + 64) = v70;
                        *(_OWORD *)(v95 + 80) = v71;
                        *(_OWORD *)(v95 + 96) = v72;
                        *(_OWORD *)(v95 + 112) = v73;
                        *(void *)(v95 + 128) = 0;
                        *(void *)(v95 + 136) = 0;
                        *(_DWORD *)(v95 + 144) = -1;
                        *(void *)(v95 + 148) = 0;
                        *(_DWORD *)(v95 + 155) = 0;
                        long long v96 = *(_OWORD *)v227;
                        *(_DWORD *)(v95 + 174) = *(_DWORD *)&v227[15];
                        *(_OWORD *)(v95 + 159) = v96;
                        *(_DWORD *)(v95 + 180) = (((v85 ^ v86) & ~v87 | v87 & v86) ^ v89) & ~v88 | v89 & v88;
                        *(void *)(v95 + 184) = 0x7FFFFFFF00000000;
                        *(_DWORD *)(v95 + 192) = 0;
                        *(void *)(v95 + 196) = 0xFFFFFFFFLL;
                        *(_OWORD *)(v95 + 204) = *(_OWORD *)v226;
                        *(_DWORD *)(v95 + 220) = *(_DWORD *)&v226[16];
                        unint64_t v199 = v91 + 1;
                        ++v200;
                        ++v80;
                        v81 += 560;
                      }
                      while (v80 < *((void *)v61 + 7));
                    }
                    unint64_t v59 = v170 + 1;
                    int v26 = v167;
                  }
                  while (v170 + 1 < v56->i64[1]);
                }
              }
            }
            v56 += 41;
          }
          while (v56 != v166);
        }
        unint64_t v53 = v164 + 1;
      }
      while (v164 + 1 != v162);
    }
    if (*((unsigned char *)this + 256))
    {
      unint64_t v97 = v199;
      uint64_t v98 = v201;
    }
    else
    {
      long long v99 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices(v178, qword_26AF9A4D0);
      if (!v100) {
        goto LABEL_165;
      }
      if (!v199) {
        goto LABEL_121;
      }
      uint64_t v101 = 0;
      int v102 = *v99;
      uint64_t v98 = v201;
      unint64_t v181 = v199;
      uint64_t v103 = 224 * v199;
      do
      {
        uint64_t v104 = *(void *)v165;
        uint64_t v188 = 0;
        int v189 = 0;
        uint64_t v105 = (_DWORD *)re::addDrawCall(v151, v98 + v101, v104, 1u, (uint64_t)&v188);
        int v106 = *(_DWORD *)(v160 + 8);
        v105[8] = 1;
        v105[10] = v106;
        v105[11] = v102;
        v101 += 224;
      }
      while (v103 != v101);
      unint64_t v97 = v181;
    }
    if (v97)
    {
      uint64_t v107 = 224 * v97;
      do
      {
        uint64_t v108 = *(void *)v165;
        uint64_t v186 = 0;
        int v187 = 0;
        uint64_t v109 = (_DWORD *)re::addDrawCall(v151, v98, v108, 1u, (uint64_t)&v186);
        v109[10] = *(_DWORD *)(v160 + 8);
        v109[8] = *(_DWORD *)(v160 + 12);
        v109[11] = v26;
        v98 += 224;
        v107 -= 224;
      }
      while (v107);
    }
LABEL_121:
    if (!*((unsigned char *)this + 256))
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A598, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9A598))
      {
        qword_26AF9A590 = re::hashString((re *)"MeshShadowDepthClear", v134);
        __cxa_guard_release(&qword_26AF9A598);
      }
      int v110 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices(v178, qword_26AF9A590);
      if (!v111) {
        goto LABEL_166;
      }
      int v112 = *v110;
      long long v207 = 0uLL;
      unint64_t v113 = *((void *)v165 + 187);
      long long v209 = 0uLL;
      long long v208 = v113;
      *(void *)&long long v210 = v178;
      long long v211 = xmmword_23435FD50;
      long long v212 = xmmword_23435FD60;
      long long v213 = xmmword_23435FD80;
      long long v214 = xmmword_23435FBB0;
      uint64_t v216 = 0;
      *((void *)&v210 + 1) = 0xFFFF010000000000;
      uint64_t v215 = 0;
      int v217 = v112;
      memset(v218, 0, sizeof(v218));
      uint64_t v219 = 0;
      uint64_t v220 = 0;
      __int16 v221 = 0;
      *(void *)&long long v222 = 25172350;
      *((void *)&v222 + 1) = 0x7FFFFFFFLL;
      uint64_t v223 = 0xFFFFFFFFLL;
      uint64_t v224 = 0;
      uint64_t v225 = 0;
      uint64_t v114 = *(void *)v165;
      uint64_t v184 = 0;
      int v185 = 0;
      re::addDrawCall(v151, (uint64_t)&v207, v114, 1u, (uint64_t)&v184);
      char v115 = v149;
      if (*((unsigned char *)this + 256)) {
        char v115 = 1;
      }
      if ((v115 & 1) == 0)
      {
        long long v116 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices(v178, qword_26AF9A4F0);
        if (!v117) {
          goto LABEL_167;
        }
        if (v199)
        {
          int v118 = *v116;
          uint64_t v119 = v201;
          uint64_t v120 = 224 * v199;
          do
          {
            uint64_t v121 = *(void *)v165;
            uint64_t v182 = 0;
            int v183 = 0;
            long long v122 = (_DWORD *)re::addDrawCall(v151, v119, v121, 1u, (uint64_t)&v182);
            int v123 = *(_DWORD *)(v160 + 8);
            v122[8] = 1;
            v122[10] = v123;
            v122[11] = v118;
            v119 += 224;
            v120 -= 224;
          }
          while (v120);
        }
      }
    }
    if (v197 && v201) {
      (*(void (**)(uint64_t *, uint64_t))(*v197 + 40))(v197, v201);
    }
    uint64_t v48 = v151;
    goto LABEL_135;
  }
  return result;
}

uint64_t re::MeshShadowGenerateMipmapNode::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v5 = *((void *)a4 + 1);
  v19[0] = (uint64_t)this;
  v19[1] = v5;
  v8[0] = 0;
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)(this + 60));
  uint64_t v14 = 0;
  memset(v12, 0, sizeof(v12));
  int v13 = 0;
  char v15 = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  char v18 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(v5, (uint64_t)v8);
  NS::SharedPtr<MTL::Texture>::operator=(this + 68, ComputePipelineState);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v12);
  if (v11[0])
  {
    if (v11[1]) {
      (*(void (**)(void))(*(void *)v11[0] + 40))();
    }
    memset(v11, 0, sizeof(v11));
  }
  if (v8[0] && v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  re::MeshShadowGenerateMipmapNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(v19, 1u);
  return re::MeshShadowGenerateMipmapNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(v19, 0);
}

uint64_t re::MeshShadowGenerateMipmapNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(uint64_t *a1, unsigned int a2)
{
  char v28 = a2;
  uint64_t v4 = *a1;
  v17[0] = 0;
  uint64_t v5 = re::DynamicString::DynamicString((re::DynamicString *)v20, (const re::DynamicString *)(v4 + 512));
  uint64_t v23 = 0;
  memset(v21, 0, sizeof(v21));
  int v22 = 0;
  char v24 = 0;
  char v25 = 0;
  uint64_t v26 = 0;
  char v27 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  re::DynamicString::setCapacity(&v9, 0);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v29[0] = "MeshShadowMipDoReduction";
  v29[1] = 24;
  uint64_t v6 = re::DynamicString::operator=((re::DynamicString *)&v9, (uint64_t)v29);
  int v13 = 10682421;
  re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v21, (re::DynamicString *)&v9);
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(a1[1], (uint64_t)v17);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v4 + 8 * a2 + 552), ComputePipelineState);
  if (v14)
  {
    if (v15)
    {
      (*(void (**)(void))(*(void *)v14 + 40))();
      uint64_t v15 = 0;
      uint64_t v16 = 0;
    }
    uint64_t v14 = 0;
  }
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*v9 + 40))();
  }
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v21);
  uint64_t result = v20[0];
  if (v20[0])
  {
    if (v20[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v20[0] + 40))();
    }
    memset(v20, 0, sizeof(v20));
  }
  if (v17[0])
  {
    uint64_t result = v18;
    if (v18)
    {
      if (v19) {
        return (*(uint64_t (**)(void))(*(void *)v18 + 40))();
      }
    }
  }
  return result;
}

void re::MeshShadowGenerateMipmapNode::execute(uint64_t this, re::RenderGraphContext *a2)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A5A8, memory_order_acquire) & 1) == 0) {
    goto LABEL_44;
  }
  while (1)
  {
    uint64_t v5 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(*((void *)a2 + 146), qword_26AF9A5A0);
    if (!v5) {
      break;
    }
    uint64_t v6 = (float *)v5;
    BOOL v7 = v90;
    uint64_t v8 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v8, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v81);
    if (!*(void *)(this + 192)) {
      goto LABEL_41;
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, *(void *)(this + 208), 0, 0, &v80);
    unint64_t v2 = *(void *)(this + 192);
    if (v2 <= 1) {
      goto LABEL_42;
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, *(void *)(this + 208) + 32, 0, 0, &v79);
    if (*(void *)(this + 152))
    {
      long long v69 = a2;
      id v70 = *(id *)re::RenderGraphContext::metalBuffer((uint64_t)a2, *(void *)(this + 168));
      if (!*((void *)v6 + 56))
      {
LABEL_32:
        if (v70) {

        }
        if (v79) {
        if (v80)
        }

        return;
      }
      uint64_t v65 = 0;
      unint64_t v9 = 0;
      long long v67 = v6;
      long long v68 = (id *)this;
      while (1)
      {
        unint64_t v2 = *((void *)v6 + 21);
        if (v2 <= v9) {
          break;
        }
        unint64_t v64 = v9;
        int v72 = *(unsigned __int16 *)(*((void *)v6 + 58) + 32 * v9 + 24);
        uint64_t v10 = *((void *)v6 + 22);
        if ((unint64_t)objc_msgSend(v80, sel_mipmapLevelCount) >= 2)
        {
          uint64_t v71 = v10 + 928 * v64;
          float32x4_t v66 = (_DWORD *)(v71 + 912);
          uint64_t v11 = v10 + v65;
          unint64_t v12 = 1;
          do
          {
            int v13 = (float32x2_t *)(v71 + 224 * v12);
            id v14 = v80;
            id v15 = objc_msgSend(v80, sel_pixelFormat, v62, v63);
            id v16 = objc_msgSend(v80, sel_textureType);
            id v76 = objc_msgSend(v14, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v15, v16, v12 - 1, 1, 0, objc_msgSend(v80, sel_arrayLength));
            id v17 = v80;
            id v18 = objc_msgSend(v80, sel_pixelFormat);
            id v19 = [v80 (SEL)0x264BEE5E1];
            id v20 = objc_msgSend(v17, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v18, v19, v12, 1, 0, objc_msgSend(v80, sel_arrayLength));
            id v21 = v79;
            id v22 = objc_msgSend(v79, sel_pixelFormat);
            id v23 = [v79 (SEL)0x264BEE5E1];
            id v24 = objc_msgSend(v21, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v22, v23, v12 - 1, 1, 0, objc_msgSend(v79, sel_arrayLength));
            id v25 = v79;
            id v26 = objc_msgSend(v79, sel_pixelFormat);
            id v27 = objc_msgSend(v79, sel_textureType);
            id v28 = objc_msgSend(v79, sel_arrayLength);
            id v29 = v26;
            unint64_t v30 = v76;
            id v31 = objc_msgSend(v25, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v29, v27, v12, 1, 0, v28);
            [v81 setTexture:v76 atIndex:0];
            id v74 = v24;
            id v32 = v24;
            this = (uint64_t)v68;
            [v81 setTexture:v32 atIndex:1];
            id v75 = v20;
            [v81 setTexture:v20 atIndex:2];
            id v73 = v31;
            [v81 setTexture:v31 atIndex:3];
            [v81 setTexture:v80 atIndex:4];
            [v81 setTexture:v79 atIndex:5];
            [v81 setBuffer:v70 offset:0 atIndex:1];
            [v81 setComputePipelineState:v68[68]];
            unint64_t v33 = (unint64_t)sqrt((double)(unint64_t)objc_msgSend(v68[68], sel_maxTotalThreadsPerThreadgroup));
            int32x2_t v34 = vcvt_s32_f32(vrndm_f32(v13[4]));
            WORD5(v85) = v34.i16[2];
            WORD4(v85) = v34.i16[0];
            int32x2_t v35 = vcvt_s32_f32(vrndp_f32(v13[5]));
            HIWORD(v85) = v35.i16[2];
            WORD6(v85) = v35.i16[0];
            int32x2_t v36 = vcvt_s32_f32(vrndm_f32(*v13));
            WORD1(v85) = v36.i16[2];
            LOWORD(v85) = v36.i16[0];
            unint64_t v37 = v13 + 1;
            int32x2_t v38 = vcvt_s32_f32(vrndp_f32(v13[1]));
            WORD3(v85) = v38.i16[2];
            WORD2(v85) = v38.i16[0];
            v38.i32[0] = v13[6].i32[0];
            v38.i32[1] = v13[8].i32[1];
            *(int32x2_t *)&long long v86 = v38;
            *((float32x2_t *)&v86 + 1) = v13[10];
            v38.i32[0] = v13[12].i32[0];
            v38.i32[1] = v13[14].i32[1];
            *(int32x2_t *)&long long v87 = v38;
            *((float32x2_t *)&v87 + 1) = v13[16];
            LODWORD(v88) = v72;
            [v81 setBytes:&v85 length:56 atIndex:0];
            uint64_t v39 = *((void *)v69 + 1);
            id v78 = v81;
            re::RenderManager::sampleComputeEncoderMTLCounterBegin(v39, &v78, 1u);

            unint64_t v40 = (v33 - 1 + (unint64_t)(float)(v13[5].f32[0] - v13[4].f32[0])) / v33;
            unint64_t v41 = (v33 - 1 + (unint64_t)(float)(v13[5].f32[1] - v13[4].f32[1])) / v33;
            if (v40 <= 1) {
              unint64_t v40 = 1;
            }
            else {
              unint64_t v40 = v40;
            }
            if (v41 <= 1) {
              unint64_t v41 = 1;
            }
            else {
              unint64_t v41 = v41;
            }
            *(void *)uint64_t v90 = v40;
            *(void *)&v90[8] = v41;
            *(void *)&v90[16] = 1;
            uint64_t v82 = v33;
            uint64_t v83 = v33;
            uint64_t v84 = 1;
            [v81 dispatchThreadgroups:v90 threadsPerThreadgroup:&v82];
            uint64_t v42 = *((void *)v69 + 1);
            id v77 = v81;
            re::RenderManager::sampleComputeEncoderMTLCounterEnd(v42, &v77, 1u);

            if ((char *)objc_msgSend(v80, sel_mipmapLevelCount) - 1 == (unsigned char *)v12)
            {
              LODWORD(v43) = *v66;
              objc_msgSend(v81, "setComputePipelineState:", v68[69], v43);
              unint64_t v44 = (unint64_t)sqrt((double)(unint64_t)objc_msgSend(v68[69], sel_maxTotalThreadsPerThreadgroup));
              float32x2_t v45 = *v13;
              unint64_t v46 = (v44 - 1 + (unint64_t)(float)(v37->f32[0] - COERCE_FLOAT(*v13))) / v44;
              unint64_t v47 = (v44 - 1 + (unint64_t)(float)(*(float *)(v71 + 224 * v12 + 12) - v45.f32[1])) / v44;
              LODWORD(v85) = v72;
              int32x2_t v48 = vcvt_s32_f32(vrndm_f32(v45));
              WORD3(v85) = v48.i16[2];
              WORD2(v85) = v48.i16[0];
              int32x2_t v49 = vcvt_s32_f32(vrndp_f32(*v37));
              WORD5(v85) = v49.i16[2];
              WORD4(v85) = v49.i16[0];
              HIWORD(v85) = v47;
              WORD6(v85) = v46;
              LOWORD(v86) = (unsigned __int16)objc_msgSend(v80, sel_mipmapLevelCount);
              float v50 = *(float *)(v71 + 904) / v67[72];
              *((float *)&v86 + 1) = v50 * (float)((unint64_t)objc_msgSend(v80, sel_mipmapLevelCount) - 1);
              DWORD2(v86) = *(_DWORD *)(v71 + 908);
              LOWORD(v87) = (unsigned __int16)objc_msgSend(v80, sel_width);
              HIDWORD(v86) = *v66;
              if (objc_msgSend(v80, sel_mipmapLevelCount))
              {
                uint64_t v51 = 0;
                unint64_t v52 = 0;
                this = 208;
                do
                {
                  long long v53 = *(_OWORD *)(v11 + this - 64);
                  uint64_t v54 = v11 + 4 * v51;
                  LODWORD(v55) = *(_DWORD *)(v54 + 176);
                  HIDWORD(v55) = *(_DWORD *)(v54 + 196);
                  uint64_t v56 = *(void *)(v11 + this - 48);
                  uint64_t v57 = *(void *)(v11 + this - 40);
                  uint64_t v58 = *(void *)(v11 + this);
                  unint64_t v59 = (char *)&v85 + v51;
                  *((_DWORD *)v59 + 10) = v52;
                  *((_OWORD *)v59 + 3) = v53;
                  *((void *)v59 + 8) = v56;
                  *((void *)v59 + 9) = v57;
                  *((void *)v59 + 10) = v55;
                  *((void *)v59 + 11) = v58;
                  ++v52;
                  v51 += 56;
                  this += 224;
                }
                while ((unint64_t)objc_msgSend(v80, sel_mipmapLevelCount) > v52);
              }
              [v81 setBytes:&v85 length:600 atIndex:0];
              [v81 setThreadgroupMemoryLength:(8 * v44 * v44 * v46 * v47 + 15) & 0xFFFFFFFFFFFFFFF0 atIndex:0];
              *(int64x2_t *)uint64_t v90 = vdupq_n_s64(1uLL);
              *(void *)&v90[16] = 1;
              uint64_t v82 = v44;
              uint64_t v83 = v44;
              uint64_t v84 = 1;
              [v81 dispatchThreadgroups:v90 threadsPerThreadgroup:&v82];
              unint64_t v30 = v76;
            }
            if (v73) {

            }
            if (v74) {
            if (v75)
            }

            if (v30) {
            ++v12;
            }
          }
          while ((unint64_t)objc_msgSend(v80, sel_mipmapLevelCount) > v12);
        }
        unint64_t v9 = v64 + 1;
        uint64_t v6 = v67;
        v65 += 928;
        if (*((void *)v67 + 56) <= v64 + 1) {
          goto LABEL_32;
        }
      }
      uint64_t v82 = 0;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v85 = 0u;
      BOOL v7 = (unsigned char *)v9;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v90 = 136315906;
      *(void *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 476;
      *(_WORD *)&v90[18] = 2048;
      *(void *)&v90[20] = v7;
      __int16 v91 = 2048;
      unint64_t v92 = v2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_41:
      uint64_t v82 = 0;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v85 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v90 = 136315906;
      *(void *)(v7 + 4) = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)(v7 + 14) = 789;
      *(_WORD *)&v90[18] = 2048;
      *(void *)(v7 + 20) = 0;
      __int16 v91 = 2048;
      *(void *)(v7 + 30) = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_42:
      uint64_t v82 = 0;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v85 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v90 = 136315906;
      *(void *)(v7 + 4) = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)(v7 + 14) = 789;
      *(_WORD *)&v90[18] = 2048;
      *(void *)(v7 + 20) = 1;
      __int16 v91 = 2048;
      *(void *)(v7 + 30) = v2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v82 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v85 = 0u;
    a2 = (re::RenderGraphContext *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v90 = 136315906;
    *(void *)(v7 + 4) = "operator[]";
    *(_WORD *)&v90[12] = 1024;
    *(_DWORD *)(v7 + 14) = 789;
    *(_WORD *)&v90[18] = 2048;
    *(void *)(v7 + 20) = 0;
    __int16 v91 = 2048;
    *(void *)(v7 + 30) = 0;
    LODWORD(v63) = 38;
    uint64_t v62 = v90;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_44:
    if (__cxa_guard_acquire(&qword_26AF9A5A8))
    {
      qword_26AF9A5A0 = re::getCombinedScopeHash((re *)"ProjectiveMeshShadow", v60, v61);
      __cxa_guard_release(&qword_26AF9A5A8);
    }
  }
}

void re::MeshShadowGenerateFinalTextureNode::execute(re::MeshShadowGenerateFinalTextureNode *this, re::RenderGraphContext *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A5B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A5B8))
  {
    qword_26AF9A5B0 = re::getCombinedScopeHash((re *)"ProjectiveMeshShadow", v12, v13);
    __cxa_guard_release(&qword_26AF9A5B8);
  }
  uint64_t v4 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(*((void *)a2 + 146), qword_26AF9A5B0);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v6, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v16);
    id v15 = v16;
    re::RenderGraphComputeNodeBase::setTexturesAndBuffersOnEncoders(this, (uint64_t)a2, &v15);

    [v16 setComputePipelineState:*((void *)this + 59)];
    id v7 = objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup);
    if (*(void *)(v5 + 448))
    {
      unint64_t v8 = 0;
      unint64_t v9 = (unint64_t)sqrt((double)(unint64_t)v7);
      uint64_t v10 = 24;
      do
      {
        int v14 = *(unsigned __int16 *)(*(void *)(v5 + 464) + v10);
        [v16 setBytes:&v14 length:4 atIndex:0];
        unint64_t v11 = (v9 - 1 + *(unsigned int *)(v5 + 200)) / v9;
        if (v11 <= 1) {
          unint64_t v11 = 1;
        }
        else {
          unint64_t v11 = v11;
        }
        v18[0] = v11;
        v18[1] = v11;
        void v18[2] = 1;
        v17[0] = v9;
        v17[1] = v9;
        void v17[2] = 1;
        [v16 dispatchThreadgroups:v18 threadsPerThreadgroup:v17];
        ++v8;
        v10 += 32;
      }
      while (*(void *)(v5 + 448) > v8);
    }
  }
}

void **re::ProjectiveMeshShadowBlurNode::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  unsigned int v5 = 0;
  uint64_t v6 = *((void *)a4 + 1);
  v8[0] = (uint64_t)this;
  v8[1] = v6;
  do
  {
    re::ProjectiveMeshShadowBlurNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(v8, 1u, v5);
    re::ProjectiveMeshShadowBlurNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(v8, 0, v5++);
  }
  while (v5 != 11);
  return NS::SharedPtr<MTL::Texture>::operator=(this + 59, this + 82);
}

uint64_t re::ProjectiveMeshShadowBlurNode::configure(char const*,char const*,re::RenderFrame &)::$_0::operator()(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  char v40 = a2;
  uint64_t v6 = *a1;
  v29[0] = 0;
  id v7 = re::DynamicString::DynamicString((re::DynamicString *)v32, (const re::DynamicString *)(v6 + 280));
  uint64_t v35 = 0;
  memset(v33, 0, sizeof(v33));
  int v34 = 0;
  char v36 = 0;
  char v37 = 0;
  uint64_t v38 = 0;
  char v39 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  re::DynamicString::setCapacity(&v21, 0);
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v13 = (uint64_t *)"MeshShadowEnableBilateralFilter";
  uint64_t v14 = 31;
  unint64_t v8 = re::DynamicString::operator=((re::DynamicString *)&v21, (uint64_t)&v13);
  int v25 = 10551349;
  unint64_t v9 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v33, (re::DynamicString *)&v21);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  re::DynamicString::setCapacity(&v13, 0);
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  id v20 = 0;
  v41[0] = "MeshShadowBlurRadius";
  v41[1] = 20;
  uint64_t v10 = re::DynamicString::operator=((re::DynamicString *)&v13, (uint64_t)v41);
  int v17 = 10616861;
  *id v20 = a3;
  re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v33, (re::DynamicString *)&v13);
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(a1[1], (uint64_t)v29);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v6 + 88 * a2 + 8 * a3 + 488), ComputePipelineState);
  if (v18)
  {
    if (v19)
    {
      (*(void (**)(void))(*(void *)v18 + 40))();
      uint64_t v19 = 0;
      id v20 = 0;
    }
    uint64_t v18 = 0;
  }
  if (v13 && (v14 & 1) != 0) {
    (*(void (**)(void))(*v13 + 40))();
  }
  if (v26)
  {
    if (v27)
    {
      (*(void (**)(void))(*(void *)v26 + 40))();
      uint64_t v27 = 0;
      uint64_t v28 = 0;
    }
    uint64_t v26 = 0;
  }
  if (v21 && (v22 & 1) != 0) {
    (*(void (**)(void))(*v21 + 40))();
  }
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v33);
  uint64_t result = v32[0];
  if (v32[0])
  {
    if (v32[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v32[0] + 40))();
    }
    memset(v32, 0, sizeof(v32));
  }
  if (v29[0])
  {
    uint64_t result = v30;
    if (v30)
    {
      if (v31) {
        return (*(uint64_t (**)(void))(*(void *)v30 + 40))();
      }
    }
  }
  return result;
}

void re::ProjectiveMeshShadowBlurNode::execute(re::ProjectiveMeshShadowBlurNode *this, re::RenderGraphContext *a2)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A5C8, memory_order_acquire) & 1) == 0) {
    goto LABEL_65;
  }
  while (1)
  {
    uint64_t v5 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(*((void *)a2 + 146), qword_26AF9A5C0);
    if (!v5) {
      break;
    }
    uint64_t v6 = (void *)v5;
    id v7 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v7, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v87);
    BOOL v8 = re::internal::shadows::g_enableShadowFlattening == 0;
    uint64_t v71 = (void **)((char *)this + 472);
    NS::SharedPtr<MTL::Texture>::operator=((void **)this + 59, (void **)this + 11 * (re::internal::shadows::g_enableShadowFlattening == 0) + 71);
    [v87 setComputePipelineState:*((void *)this + 59)];
    id v9 = objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup);
    id v86 = v87;
    re::RenderGraphComputeNodeBase::setTexturesAndBuffersOnEncoders(this, (uint64_t)a2, &v86);

    if (!*((void *)this + 24)) {
      goto LABEL_61;
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26), 0, 0, &v85);
    unint64_t v2 = *((void *)this + 24);
    if (v2 <= 1) {
      goto LABEL_62;
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26) + 32, 0, 0, &v84);
    if (!*((void *)this + 29)) {
      goto LABEL_63;
    }
    re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 31), 0, 0, &v83);
    if (*((void *)this + 14))
    {
      int v72 = a2;
      id v73 = *(id *)re::RenderGraphContext::metalBuffer((uint64_t)a2, *((void *)this + 16));
      unsigned int v10 = objc_msgSend(v85, sel_mipmapLevelCount);
      unint64_t v11 = v6[56];
      if (!v11)
      {
LABEL_50:
        if (v73) {

        }
        if (v83) {
        if (v84)
        }

        if (v85) {
        return;
        }
      }
      unint64_t v12 = 0;
      unint64_t v13 = (unint64_t)sqrt((double)(unint64_t)v9);
      uint64_t v78 = v10;
      id v70 = (char *)this + 88 * v8;
      uint64_t v79 = 10;
      id v80 = this;
      long long v68 = v6;
      while (1)
      {
        a2 = (re::RenderGraphContext *)v6[21];
        if ((unint64_t)a2 <= v12) {
          break;
        }
        if (v78)
        {
          uint64_t v14 = 0;
          unsigned int v77 = *(unsigned __int16 *)(v6[58] + 32 * v12 + 24);
          uint64_t v15 = v6[22] + 928 * v12;
          unint64_t v69 = v12;
          id v75 = (unsigned int *)(v15 + 900);
          uint64_t v76 = v15;
          id v74 = (float *)(v15 + 896);
          do
          {
            uint64_t v16 = (float32x2_t *)(v76 + 224 * v14);
            float32x2_t v18 = v16[4];
            float32x2_t v17 = v16[5];
            unint64_t v19 = *v75;
            if (v19 >= 0xA) {
              uint64_t v20 = 10;
            }
            else {
              uint64_t v20 = v19;
            }
            if (v79 != v20)
            {
              NS::SharedPtr<MTL::Texture>::operator=(v71, (void **)&v70[8 * v20 + 488]);
              [v87 setComputePipelineState:*((void *)this + 59)];
              unint64_t v13 = (unint64_t)sqrt((double)(unint64_t)objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup));
              uint64_t v79 = v20;
            }
            uint64_t v21 = 0;
            float32x2_t v22 = vsub_f32(v17, v18);
            *(void *)&long long v92 = 25152;
            *((uint32x2_t *)&v92 + 1) = vcvt_u32_f32(v18);
            *(uint32x2_t *)&long long v93 = vcvt_u32_f32(v17);
            *((void *)&v93 + 1) = __PAIR64__(v14, v77);
            memset(v94, 0, 24);
            float v23 = *v74;
            float v24 = *v74 * 0.70711;
            do
            {
              if (v23 >= 0.7)
              {
                _S0 = expf((float)-(v21 * v21) / (float)(v23 * (float)(v23 + v23)));
              }
              else
              {
                float v25 = erff((float)((float)(int)v21 + -0.5) / v24);
                _S0 = (float)(erff((float)((float)(int)v21 + 0.5) / v24) - v25) * 0.5;
              }
              __asm { FCVT            H0, S0 }
              *((_WORD *)v94 + v21++) = _H0;
            }
            while (v20 + 1 != v21);
            int v32 = -(int)v20;
            int v33 = (2 * v20) | 1;
            float v34 = 0.0;
            do
            {
              if (v32 >= 0) {
                unsigned int v35 = v32;
              }
              else {
                unsigned int v35 = -v32;
              }
              _H1 = *((_WORD *)v94 + v35);
              __asm { FCVT            S1, H1 }
              float v34 = v34 + _S1;
              ++v32;
              --v33;
            }
            while (v33);
            uint64_t v38 = 0;
            if (v19 >= 0xA) {
              uint64_t v39 = 10;
            }
            else {
              uint64_t v39 = v19;
            }
            uint64_t v40 = 2 * v39 + 2;
            do
            {
              _H1 = *(_WORD *)((char *)v94 + v38);
              __asm { FCVT            S1, H1 }
              _S1 = _S1 / v34;
              __asm { FCVT            H1, S1 }
              *(_WORD *)((char *)v94 + v38) = LOWORD(_S1);
              v38 += 2;
            }
            while (v40 != v38);
            id v44 = v85;
            id v45 = objc_msgSend(v85, sel_pixelFormat);
            id v46 = objc_msgSend(v85, sel_textureType);
            id v47 = objc_msgSend(v44, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v45, v46, v14, 1, 0, objc_msgSend(v85, sel_arrayLength));
            id v48 = v84;
            id v49 = objc_msgSend(v84, sel_pixelFormat);
            id v50 = objc_msgSend(v84, sel_textureType);
            id v51 = objc_msgSend(v48, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v49, v50, v14, 1, 0, objc_msgSend(v84, sel_arrayLength));
            id v52 = v83;
            id v53 = objc_msgSend(v83, sel_pixelFormat);
            id v54 = objc_msgSend(v83, sel_textureType);
            id v55 = objc_msgSend(v52, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v53, v54, v14, 1, 0, objc_msgSend(v85, sel_arrayLength));
            [v87 setTexture:v47 atIndex:0];
            [v87 setTexture:v51 atIndex:1];
            [v87 setTexture:v55 atIndex:2];
            [v87 setTexture:v83 atIndex:3];
            [v87 setBuffer:v73 offset:0 atIndex:1];
            [v87 setBytes:&v92 length:56 atIndex:0];
            if (*((_DWORD *)v80 + 120))
            {
              unint64_t v56 = v13 - 1 + (unint64_t)v22.f32[0];
              float v57 = v22.f32[1] * 0.5;
            }
            else
            {
              unint64_t v56 = v13 - 1 + (unint64_t)(float)(v22.f32[0] * 0.5);
              float v57 = v22.f32[1];
            }
            unint64_t v58 = v56 / v13;
            uint64_t v59 = *((void *)v72 + 1);
            unint64_t v60 = (v13 - 1 + (unint64_t)v57) / v13;
            id v82 = v87;
            re::RenderManager::sampleComputeEncoderMTLCounterBegin(v59, &v82, 1u);

            if (v58 <= 1) {
              uint64_t v61 = 1;
            }
            else {
              uint64_t v61 = v58;
            }
            if (v60 <= 1) {
              uint64_t v62 = 1;
            }
            else {
              uint64_t v62 = v60;
            }
            *(void *)long long v89 = v61;
            *(void *)&v89[8] = v62;
            *(void *)&v89[16] = 1;
            v88[0] = v13;
            v88[1] = v13;
            v88[2] = 1;
            objc_msgSend(v87, "dispatchThreadgroups:threadsPerThreadgroup:", v89, v88, v66, v67);
            uint64_t v63 = *((void *)v72 + 1);
            id v81 = v87;
            re::RenderManager::sampleComputeEncoderMTLCounterEnd(v63, &v81, 1u);

            if (v55) {
            if (v51)
            }

            this = v80;
            if (v47) {

            }
            ++v14;
          }
          while (v14 != v78);
          uint64_t v6 = v68;
          unint64_t v12 = v69;
          unint64_t v11 = v68[56];
        }
        if (v11 <= ++v12) {
          goto LABEL_50;
        }
      }
      v88[0] = 0;
      long long v95 = 0u;
      long long v93 = 0u;
      memset(v94, 0, sizeof(v94));
      long long v92 = 0u;
      unint64_t v2 = v12;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v89 = 136315906;
      *(void *)&v89[4] = "operator[]";
      *(_WORD *)&v89[12] = 1024;
      *(_DWORD *)&v89[14] = 476;
      *(_WORD *)&v89[18] = 2048;
      *(void *)&v89[20] = v2;
      __int16 v90 = 2048;
      __int16 v91 = a2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_61:
      v88[0] = 0;
      long long v95 = 0u;
      long long v93 = 0u;
      memset(v94, 0, sizeof(v94));
      long long v92 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v89 = 136315906;
      *(void *)&v89[4] = "operator[]";
      *(_WORD *)&v89[12] = 1024;
      *(_DWORD *)&v89[14] = 789;
      *(_WORD *)&v89[18] = 2048;
      *(void *)&v89[20] = 0;
      __int16 v90 = 2048;
      __int16 v91 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_62:
      v88[0] = 0;
      long long v95 = 0u;
      long long v93 = 0u;
      memset(v94, 0, sizeof(v94));
      long long v92 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v89 = 136315906;
      *(void *)&v89[4] = "operator[]";
      *(_WORD *)&v89[12] = 1024;
      *(_DWORD *)&v89[14] = 789;
      *(_WORD *)&v89[18] = 2048;
      *(void *)&v89[20] = 1;
      __int16 v90 = 2048;
      __int16 v91 = (re::RenderGraphContext *)v2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_63:
      v88[0] = 0;
      long long v95 = 0u;
      long long v93 = 0u;
      memset(v94, 0, sizeof(v94));
      long long v92 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v89 = 136315906;
      *(void *)&v89[4] = "operator[]";
      *(_WORD *)&v89[12] = 1024;
      *(_DWORD *)&v89[14] = 789;
      *(_WORD *)&v89[18] = 2048;
      *(void *)&v89[20] = 0;
      __int16 v90 = 2048;
      __int16 v91 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v88[0] = 0;
    long long v95 = 0u;
    long long v93 = 0u;
    memset(v94, 0, sizeof(v94));
    long long v92 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v89 = 136315906;
    *(void *)&v89[4] = "operator[]";
    *(_WORD *)&v89[12] = 1024;
    *(_DWORD *)&v89[14] = 789;
    *(_WORD *)&v89[18] = 2048;
    *(void *)&v89[20] = 0;
    __int16 v90 = 2048;
    __int16 v91 = 0;
    LODWORD(v67) = 38;
    float32x4_t v66 = v89;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_65:
    if (__cxa_guard_acquire(&qword_26AF9A5C8))
    {
      qword_26AF9A5C0 = re::getCombinedScopeHash((re *)"ProjectiveMeshShadow", v64, v65);
      __cxa_guard_release(&qword_26AF9A5C8);
    }
  }
}

void *re::allocInfo_RenderProjectiveMeshShadowPatchesNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A5D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A5D0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A630, "RenderProjectiveMeshShadowPatchesNode");
    __cxa_guard_release(&qword_26AF9A5D0);
  }
  return &unk_26AF9A630;
}

void re::initInfo_RenderProjectiveMeshShadowPatchesNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0x86836557EB7BBFECLL;
  v21[1] = "RenderProjectiveMeshShadowPatchesNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A5D8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A5D8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A610 = v7;
      BOOL v8 = re::introspectionAllocator((re *)v7);
      unsigned int v10 = re::introspect_BOOL((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "depthOnly";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A618 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_BOOL((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "disableRenderOverContent";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x10100000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9A620 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      float32x2_t v18 = re::introspect_BOOL((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "useMaxBlend";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x10200000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9A628 = v19;
      __cxa_guard_release(&qword_26AF9A5D8);
    }
  }
  *((void *)this + 2) = 0x10800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9A610;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderProjectiveMeshShadowPatchesNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderProjectiveMeshShadowPatchesNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderProjectiveMeshShadowPatchesNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderProjectiveMeshShadowPatchesNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

re::RenderGraphNode *re::internal::defaultConstruct<re::RenderProjectiveMeshShadowPatchesNode>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t result = &unk_26E7189B8;
  *((_WORD *)result + 128) = 0;
  *((unsigned char *)result + 258) = 0;
  return result;
}

void re::internal::defaultDestruct<re::RenderProjectiveMeshShadowPatchesNode>(int a1, int a2, id *this)
{
}

re::RenderGraphNode *re::internal::defaultConstructV2<re::RenderProjectiveMeshShadowPatchesNode>(re::RenderGraphNode *a1)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t result = &unk_26E7189B8;
  *((_WORD *)result + 128) = 0;
  *((unsigned char *)result + 258) = 0;
  return result;
}

uint64_t re::introspect_RenderProjectiveMeshShadowPatchesNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderProjectiveMeshShadowPatchesNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderProjectiveMeshShadowPatchesNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderProjectiveMeshShadowPatchesNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderProjectiveMeshShadowPatchesNode>, this);
}

void re::CopyShadowTextureNode::~CopyShadowTextureNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::GenerateTiledShadowDepthPrepassMapNode::~GenerateTiledShadowDepthPrepassMapNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::GenerateProjectiveMeshShadowMapNode::~GenerateProjectiveMeshShadowMapNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderProjectiveMeshShadowPatchesNode::~RenderProjectiveMeshShadowPatchesNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::MeshShadowGenerateMipmapNode::~MeshShadowGenerateMipmapNode(re::MeshShadowGenerateMipmapNode *this)
{
  *(void *)this = &unk_26E718A60;
  for (uint64_t i = 560; i != 544; i -= 8)
  {
    unint64_t v3 = *(void **)((char *)this + i);
    if (v3)
    {

      *(void *)((char *)this + i) = 0;
    }
  }
  uint64_t v4 = (void *)*((void *)this + 68);
  if (v4)
  {

    *((void *)this + 68) = 0;
  }
  re::DynamicString::deinit((re::MeshShadowGenerateMipmapNode *)((char *)this + 512));
  re::DynamicString::deinit((re::MeshShadowGenerateMipmapNode *)((char *)this + 480));
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_26E718A60;
  unint64_t v2 = 560;
  while (1)
  {
    unint64_t v3 = *(void **)((char *)this + v2);
    if (v3)
    {

      *(void *)((char *)this + v2) = 0;
    }
    v2 -= 8;
    if (v2 == 544)
    {
      uint64_t v4 = (void *)*((void *)this + 68);
      if (v4)
      {

        *((void *)this + 68) = 0;
      }
      re::DynamicString::deinit((re::MeshShadowGenerateMipmapNode *)((char *)this + 512));
      re::DynamicString::deinit((re::MeshShadowGenerateMipmapNode *)((char *)this + 480));
      re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
      JUMPOUT(0x237DBCBD0);
    }
  }
}

uint64_t re::RenderGraphComputeNode::getGraphBuildValidationCode(re::RenderGraphComputeNode *this)
{
  return 0x1398425203831E0ELL;
}

uint64_t re::RenderGraphComputeNodeBase::skipNode(re::RenderGraphComputeNodeBase *this, re::RenderGraphContext *a2)
{
  return 0;
}

void re::MeshShadowGenerateFinalTextureNode::~MeshShadowGenerateFinalTextureNode(re::MeshShadowGenerateFinalTextureNode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::ProjectiveMeshShadowBlurNode::~ProjectiveMeshShadowBlurNode(re::ProjectiveMeshShadowBlurNode *this)
{
  *(void *)this = &unk_26E718BE0;
  for (uint64_t i = 656; i != 480; i -= 8)
  {
    unint64_t v3 = *(void **)((char *)this + i);
    if (v3)
    {

      *(void *)((char *)this + i) = 0;
    }
  }
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26E718BE0;
  unint64_t v2 = 656;
  while (1)
  {
    unint64_t v3 = *(void **)((char *)this + v2);
    if (v3)
    {

      *(void *)((char *)this + v2) = 0;
    }
    v2 -= 8;
    if (v2 == 480)
    {
      re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
      JUMPOUT(0x237DBCBD0);
    }
  }
}

re::DrawTable *re::DrawTable::DrawTable(re::DrawTable *this, re::Allocator *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 1;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  re::BucketArray<re::DrawCall,128ul>::init((uint64_t)this, (uint64_t)a2, 0);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 1;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 26) = 0;
  re::BucketArray<re::Matrix4x4<float>,128ul>::init((uint64_t)this + 56, (uint64_t)a2, 0);
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 32) = 1;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 40) = 0;
  re::BucketArray<re::ConstantTable const*,128ul>::init((uint64_t)this + 112, (uint64_t)a2, 0);
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 1;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 24) = 0;
  *((_DWORD *)this + 54) = 0;
  re::BucketArray<float,128ul>::init((uint64_t)this + 168, (uint64_t)a2, 0);
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((_DWORD *)this + 60) = 1;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 68) = 0;
  re::BucketArray<unsigned int,128ul>::init((uint64_t)this + 224, (uint64_t)a2, 0);
  *((unsigned char *)this + 320) = 1;
  return this;
}

void *re::DrawTableSlice::DrawTableSlice(void *result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void *)(a2 + 40);
  if (*(_DWORD *)(a2 + 16)) {
    uint64_t v2 = a2 + 24;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  re::RenderGraphNode *result = v2;
  result[1] = v4;
  result[2] = v3;
  uint64_t v5 = *(void *)(a2 + 88);
  uint64_t v6 = *(void *)(a2 + 96);
  if (*(_DWORD *)(a2 + 72)) {
    uint64_t v5 = a2 + 80;
  }
  uint64_t v7 = *(void *)(a2 + 64);
  result[3] = v5;
  result[4] = v7;
  result[5] = v6;
  uint64_t v8 = *(void *)(a2 + 144);
  uint64_t v9 = *(void *)(a2 + 152);
  if (*(_DWORD *)(a2 + 128)) {
    uint64_t v8 = a2 + 136;
  }
  uint64_t v10 = *(void *)(a2 + 120);
  result[6] = v8;
  result[7] = v10;
  result[8] = v9;
  uint64_t v11 = *(void *)(a2 + 200);
  uint64_t v12 = *(void *)(a2 + 208);
  if (*(_DWORD *)(a2 + 184)) {
    uint64_t v11 = a2 + 192;
  }
  uint64_t v13 = *(void *)(a2 + 176);
  result[9] = v11;
  result[10] = v13;
  result[11] = v12;
  uint64_t v14 = *(void *)(a2 + 256);
  uint64_t v15 = *(void *)(a2 + 264);
  if (*(_DWORD *)(a2 + 240)) {
    uint64_t v14 = a2 + 248;
  }
  uint64_t v16 = *(void *)(a2 + 232);
  result[12] = v14;
  result[13] = v16;
  result[14] = v15;
  return result;
}

unsigned char *re::FixedArray<unsigned char>::init<BOOL const&>(void *a1, uint64_t a2, unsigned char *a3)
{
  *a1 = a2;
  a1[1] = 1;
  uint64_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 1, 1);
  a1[2] = result;
  if (result)
  {
    unsigned char *result = *a3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = (unsigned char *)_os_crash();
    __break(1u);
  }
  return result;
}

void re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(re::RenderGraphComputeNodeBase *this)
{
  *(void *)this = &unk_26E718D28;
  uint64_t v2 = (void *)*((void *)this + 59);
  if (v2)
  {

    *((void *)this + 59) = 0;
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 432);
  re::DynamicString::deinit((re::RenderGraphComputeNodeBase *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::RenderGraphComputeNodeBase *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

uint64_t re::RenderGraphDataStore::tryGet<re::SceneArrayData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re14SceneArrayDataE";
  if (((unint64_t)"N2re14SceneArrayDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re14SceneArrayDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshSceneArrays>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_15MeshSceneArraysEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_15MeshSceneArraysEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_15MeshSceneArraysEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void *re::DynamicArray<re::MeshPartDrawContext>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unsigned int v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0xE0uLL))
        {
          uint64_t v2 = 224 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 224 * a2, 16);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 224 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 224, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshPartDrawContext>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::BucketArray<re::MeshSceneCollection,16ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 4) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 4)) + 40 * (a2 & 0xF);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 4) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 4)) + 40 * (a2 & 0xF);
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowRenderingData>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::RenderGraphDataStore::get<re::CameraMatrices>(uint64_t a1, uint64_t a2)
{
  void v11[2] = *MEMORY[0x263EF8340];
  {
    re::introspect<re::CameraMatrices>(void)::mach_timebase_info info = (_UNKNOWN *)re::introspect_CameraMatrices(0);
  }
  size_t v4 = strlen(*((const char **)re::introspect<re::CameraMatrices>(void)::info + 6));
  if (v4)
  {
    MurmurHash3_x64_128(*((void *)re::introspect<re::CameraMatrices>(void)::info + 6), v4, 0, v11);
    unint64_t v5 = (v11[1] - 0x61C8864680B583E9 + (v11[0] << 6) + (v11[0] >> 2)) ^ v11[0];
  }
  else
  {
    unint64_t v5 = 0;
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 - 0x61C8864680B583E9 + (v5 << 6) + (v5 >> 2)) ^ v5;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneRenderingData>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void *re::VRRUnwarpProvider::VRRUnwarpProvider(void *a1, const re::DynamicString *a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)v5, a2);
  *a1 = &unk_26E6D52C8;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 1), (const re::DynamicString *)v5);
  uint64_t v3 = *(_anonymous_namespace_ **)&v5[0];
  if (*(void *)&v5[0])
  {
    if (BYTE8(v5[0])) {
      uint64_t v3 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v5[0] + 40))();
    }
    memset(v5, 0, sizeof(v5));
  }
  *a1 = &unk_26E718CA0;
  a1[6] = 0;
  a1[7] = 0;
  a1[5] = 0;
  a1[12] = 65290051;
  a1[13] = "Color";
  return a1;
}

void re::VRRUnwarpProvider::~VRRUnwarpProvider(re::VRRUnwarpProvider *this)
{
  *(void *)this = &unk_26E6D52C8;
  re::DynamicString::deinit((re::VRRUnwarpProvider *)((char *)this + 8));
}

{
  uint64_t vars8;

  re::VRRUnwarpProvider::~VRRUnwarpProvider(this);
  JUMPOUT(0x237DBCBD0);
}

unint64_t re::VRRUnwarpProvider::prepareFrame(re::VRRUnwarpProvider *this, char *__s, const char *a3, re::RenderFrame *a4)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  size_t v8 = strlen(__s);
  if (v8)
  {
    MurmurHash3_x64_128((uint64_t)__s, v8, 0, (unint64_t *)buf);
    unint64_t v9 = (*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf;
  }
  else
  {
    unint64_t v9 = 0;
  }
  size_t v10 = strlen(a3);
  if (v10)
  {
    MurmurHash3_x64_128((uint64_t)a3, v10, 0, (unint64_t *)buf);
    uint64_t v11 = ((*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf)
        - 0x61C8864680B583E9;
  }
  else
  {
    uint64_t v11 = 0x9E3779B97F4A7C17;
  }
  uint64_t v12 = ((v9 >> 2) + (v9 << 6) + v11) ^ v9;
  uint64_t v13 = re::RenderGraphDataStore::tryGet<re::CameraData>((uint64_t)a4 + 32, v12);
  uint64_t v14 = re::RenderGraphDataStore::tryGet<re::VRRData>((uint64_t)a4 + 32, v12);
  if (!v13) {
    return 0;
  }
  BOOL v15 = !*(unsigned char *)(v13 + 461) || v14 == 0;
  if (v15 || !*(unsigned char *)(v14 + 12)) {
    return 0;
  }
  unint64_t v16 = *(unsigned int *)(v14 + 8);
  unint64_t v17 = *((void *)a4 + 506);
  if (v17 <= v16)
  {
    id v59 = 0;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v61 = 136315906;
    *(void *)&v61[4] = "operator[]";
    *(_WORD *)&v61[12] = 1024;
    *(_DWORD *)&v61[14] = 797;
    __int16 v62 = 2048;
    unint64_t v63 = v16;
    __int16 v64 = 2048;
    unint64_t v65 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v18 = *((void *)a4 + 508);
  if (!*(void *)(v18 + 8 * v16))
  {
    uint64_t v21 = *re::graphicsLogObjects((re *)v14);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_233120000, v21, OS_LOG_TYPE_ERROR, "Could not get valid ratemap in Unwarp provider", buf, 2u);
    }
    return 0;
  }
  *(void *)uint64_t v61 = 0;
  *(void *)&v61[8] = 0;
  uint64_t v19 = *(void *)(*((void *)a4 + 1) + 104);
  if (v19) {
    uint64_t v20 = *(void *)(v19 + 336);
  }
  else {
    uint64_t v20 = 0;
  }
  float v24 = (re::PerFrameAllocatorGPU *)re::PerFrameAllocatorGPUManager::perFrameAllocatorGPU(v20, *((void *)a4 + 46));
  re::PerFrameAllocatorGPU::allocInternal(v24, (unint64_t)objc_msgSend(*(id *)(v18 + 8 * v16), sel_parameterBufferSizeAndAlign), 0x10uLL, 0, buf);
  unsigned int v25 = v67;
  LODWORD(v24) = *(_DWORD *)&buf[8];
  id v59 = **((id **)&v67 + 1);
  unint64_t v60 = __PAIR64__(v25, v24);
  NS::SharedPtr<MTL::Texture>::operator=((void **)v61, &v59);
  unsigned int v26 = v60;
  *(void *)&v61[8] = v60;
  if (v59)
  {

    unsigned int v26 = *(_DWORD *)&v61[8];
  }
  objc_msgSend(*(id *)(v18 + 8 * v16), sel_copyParameterDataToBuffer_offset_, *(void *)v61, v26);
  BOOL v27 = re::ConstStringID::operator==((void *)this + 12, re::RenderFrame::kColorOutputLaneID);
  id v28 = *(id *)v61;
  id v29 = v28;
  if (v27)
  {
    v58[0] = v28;
    v58[1] = *(void *)&v61[8];
    *(void *)buf = 0x4F06877B79D47715;
    if (a3)
    {
      uint64_t v30 = *a3;
      if (*a3)
      {
        char v31 = a3[1];
        if (v31)
        {
          int v32 = a3 + 2;
          do
          {
            uint64_t v30 = 31 * v30 + v31;
            int v33 = *(unsigned __int8 *)v32++;
            char v31 = v33;
          }
          while (v33);
        }
        v30 &= ~0x8000000000000000;
      }
    }
    else
    {
      uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
    }
    id v59 = (id)v30;
    uint64_t v38 = v58;
  }
  else
  {
    v57[0] = v28;
    v57[1] = *(void *)&v61[8];
    *(void *)buf = 0x4F06877B79D47716;
    if (a3)
    {
      uint64_t v34 = *a3;
      if (*a3)
      {
        char v35 = a3[1];
        if (v35)
        {
          char v36 = a3 + 2;
          do
          {
            uint64_t v34 = 31 * v34 + v35;
            int v37 = *(unsigned __int8 *)v36++;
            char v35 = v37;
          }
          while (v37);
        }
        v34 &= ~0x8000000000000000;
      }
    }
    else
    {
      uint64_t v34 = 0x7FFFFFFFFFFFFFFFLL;
    }
    id v59 = (id)v34;
    uint64_t v38 = v57;
  }
  re::RenderFrame::registerExternalBuffer((uint64_t)a4, (uint64_t)v38, buf, &v59, 0);
  if (v29) {

  }
  unint64_t v39 = (unint64_t)"N2re13VRRUnwarpDataE";
  if (((unint64_t)"N2re13VRRUnwarpDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v40 = (unsigned __int8 *)((unint64_t)"N2re13VRRUnwarpDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = 5381;
    do
    {
      unint64_t v39 = v41;
      unsigned int v42 = *v40++;
      uint64_t v41 = (33 * v41) ^ v42;
    }
    while (v42);
  }
  unint64_t v43 = (v12 - 0x61C8864680B583E9 + (v39 << 6) + (v39 >> 2)) ^ v39;
  id v44 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a4 + 5) + 32))(*((void *)a4 + 5), 16, 8);
  v44[1] = 0;
  unint64_t v45 = *((void *)a4 + 12);
  *id v44 = &unk_26E718D00;
  if (!v45
    || (unint64_t v45 = v43 % *((unsigned int *)a4 + 30),
        uint64_t v46 = *(unsigned int *)(*((void *)a4 + 13) + 4 * v45),
        v46 == 0x7FFFFFFF))
  {
LABEL_48:
    uint64_t v47 = *((unsigned int *)a4 + 33);
    if (v47 == 0x7FFFFFFF)
    {
      uint64_t v47 = *((unsigned int *)a4 + 32);
      int v48 = v47;
      if (v47 == *((_DWORD *)a4 + 30))
      {
        re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity((uint64_t)a4 + 96, 2 * *((_DWORD *)a4 + 31));
        LODWORD(v45) = v43 % *((unsigned int *)a4 + 30);
        int v48 = *((_DWORD *)a4 + 32);
      }
      *((_DWORD *)a4 + 32) = v48 + 1;
      uint64_t v49 = *((void *)a4 + 14);
      int v50 = *(_DWORD *)(v49 + 24 * v47);
    }
    else
    {
      uint64_t v49 = *((void *)a4 + 14);
      int v50 = *(_DWORD *)(v49 + 24 * v47);
      *((_DWORD *)a4 + 33) = v50 & 0x7FFFFFFF;
    }
    uint64_t v51 = 24 * v47;
    *(_DWORD *)(v49 + v51) = v50 | 0x80000000;
    *(_DWORD *)(*((void *)a4 + 14) + v51) = *(_DWORD *)(*((void *)a4 + 14) + 24 * v47) & 0x80000000 | *(_DWORD *)(*((void *)a4 + 13) + 4 * v45);
    *(void *)(*((void *)a4 + 14) + 24 * v47 + 8) = v43;
    *(void *)(*((void *)a4 + 14) + 24 * v47 + 16) = v44;
    *(_DWORD *)(*((void *)a4 + 13) + 4 * v45) = v47;
    ++*((_DWORD *)a4 + 31);
    ++*((_DWORD *)a4 + 34);
    uint64_t v52 = *((void *)a4 + 14) + 24 * v47;
    goto LABEL_58;
  }
  uint64_t v53 = *((void *)a4 + 14);
  while (*(void *)(v53 + 24 * v46 + 8) != v43)
  {
    LODWORD(v46) = *(_DWORD *)(v53 + 24 * v46) & 0x7FFFFFFF;
    if (v46 == 0x7FFFFFFF) {
      goto LABEL_48;
    }
  }
  uint64_t v52 = v53 + 24 * v46;
LABEL_58:
  uint64_t v54 = *(void *)(v52 + 16);
  *(_WORD *)(v54 + 8) = 0;
  if ((unint64_t)objc_msgSend(*(id *)(v18 + 8 * v16), sel_layerCount) > 1) {
    __int16 v55 = 1;
  }
  else {
    __int16 v55 = 255;
  }
  *(_WORD *)(v54 + 10) = v55;
  v56[0] = 0x2988A88C0AE16068;
  v56[1] = (unint64_t)"VRRUnwarpProvider";
  unint64_t ScopeHash = re::RenderGraphProviderBase::generateScopeHash(v56, __s, a3);
  if (*(void *)v61) {

  }
  return ScopeHash;
}

BOOL re::ConstStringID::operator==(void *a1, void *a2)
{
  if (*a1 == *a2)
  {
    unint64_t v2 = (unsigned char *)a1[1];
    uint64_t v3 = (unsigned char *)a2[1];
    int v4 = *v2;
    if (!*v2) {
      return *v3 == 0;
    }
    unsigned int v5 = v2 + 1;
    while (*v3 && v4 == *v3)
    {
      ++v3;
      int v7 = *v5++;
      int v4 = v7;
      if (!v7) {
        return *v3 == 0;
      }
    }
  }
  return 0;
}

void re::VRRUnwarpProvider::provide(re::VRRUnwarpProvider *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((unsigned char *)this + 72)) {
    size_t v8 = (const char *)*((void *)this + 10);
  }
  else {
    size_t v8 = (char *)this + 73;
  }
  re::RenderFrame::tryGetInputTarget(a4, v8, 0, (double *)&v49);
  if (DWORD2(v49) == -1 || HIDWORD(v49) == -1)
  {
    uint64_t v11 = *re::graphicsLogObjects(v9);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, "Could not get input color in Unwarp provider", buf, 2u);
    }
  }
  else
  {
    uint64_t v12 = 0xBC9C7D0DAB09280ELL;
    RenderGraph = (re *)re::RenderFrame::makeRenderGraph(a4, a3, 0);
    uint64_t v41 = -1;
    uint64_t v40 = -1;
    uint64_t v39 = -1;
    char v42 = 0;
    long long v44 = xmmword_2343AEB90;
    long long v45 = xmmword_2343AEBA0;
    int v46 = -1;
    long long v47 = xmmword_234378E20;
    char v48 = 0;
    *(void *)buf = 0x7300000003;
    int v38 = 3;
    __asm { FMOV            V0.2S, #1.0 }
    uint64_t v43 = _D0;
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)buf, "UnwarpedTarget", &v36);
    v30[0] = *((void *)this + 12) & 0x7FFFFFFFFFFFFFFFLL;
    re::RenderFrame::addTargetOutput(a4, v30, (double *)&v36, 0);
    v30[1] = -1;
    char v31 = 0;
    int v32 = 1065353216;
    unint64_t v33 = 0xFFFFFFFF00000020;
    uint64_t v34 = -1;
    LODWORD(v30[0]) = 2;
    if (re::ConstStringID::operator==((void *)this + 12, re::RenderFrame::kColorOutputLaneID))
    {
      if (a3)
      {
        uint64_t v19 = *a3;
        if (*a3)
        {
          char v20 = a3[1];
          if (v20)
          {
            uint64_t v21 = a3 + 2;
            do
            {
              uint64_t v19 = 31 * v19 + v20;
              int v22 = *(unsigned __int8 *)v21++;
              char v20 = v22;
            }
            while (v22);
          }
          uint64_t v12 = ((v19 & 0x7FFFFFFFFFFFFFFFLL) + 0x739AFA76D2DD5F1CLL) ^ 0x4F06877B79D47715;
        }
        else
        {
          uint64_t v12 = 0x3C9C7D0DAB092809;
        }
      }
      *(void *)&long long v50 = 0x9E0D0EF6F3A8EE2ALL;
      *((void *)&v50 + 1) = "UnwarpRateMapBuffer0";
      uint64_t v35 = v12;
    }
    else
    {
      if (a3)
      {
        uint64_t v23 = *a3;
        if (*a3)
        {
          char v24 = a3[1];
          if (v24)
          {
            unsigned int v25 = a3 + 2;
            do
            {
              uint64_t v23 = 31 * v23 + v24;
              int v26 = *(unsigned __int8 *)v25++;
              char v24 = v26;
            }
            while (v26);
          }
          uint64_t v27 = ((v23 & 0x7FFFFFFFFFFFFFFFLL) + 0x739AFA76D2DD5F5CLL) ^ 0x4F06877B79D47716;
        }
        else
        {
          uint64_t v27 = 0x3C9C7D0DAB09284ALL;
        }
      }
      else
      {
        uint64_t v27 = 0xBC9C7D0DAB09284DLL;
      }
      *(void *)&long long v50 = 0x9E0D0EF6F3A8EE2CLL;
      *((void *)&v50 + 1) = "UnwarpRateMapBuffer1";
      uint64_t v35 = v27;
    }
    re::StringID::destroyString((re::StringID *)&v50);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)v30, "RateMapBuffer", &v50);
    id v28 = re::RenderGraph::addNode<re::RenderGraphVRRUnwarpNode>(RenderGraph, "Unwarp node");
    long long v29 = v36;
    *((_OWORD *)v28 + 16) = v49;
    *((_OWORD *)v28 + 17) = v29;
    *((_OWORD *)v28 + 18) = v50;
    re::AssetHandle::operator=((uint64_t)v28 + 304, (uint64_t *)this + 5);
    re::RenderGraphVRRUnwarpNode::configure((void **)v28, a2, a3, a4);
  }
}

void re::VRRUnwarpData::~VRRUnwarpData(re::VRRUnwarpData *this)
{
}

void re::guided_filter_occlusion::GuidedFilterOcclusionTextureRecycler::prepareTexturesForFrame(re::guided_filter_occlusion::GuidedFilterOcclusionTextureRecycler *this)
{
  uint64_t v2 = *((void *)this + 5);
  uint64_t v3 = *(unsigned int *)(v2 + 176);
  uint64_t v4 = *(unsigned int *)(v2 + 180);
  re::mtl::makeDefaultDevice(&v19);
  unsigned int v5 = (void *)MEMORY[0x263F12A50];
  id v6 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v6, sel_setStorageMode_, 2);
  objc_msgSend(v6, sel_setPixelFormat_, 115);
  objc_msgSend(v6, sel_setWidth_, v3);
  objc_msgSend(v6, sel_setHeight_, v4);
  objc_msgSend(v6, sel_setUsage_, 3);

  uint64_t v7 = *((void *)this + 5);
  uint64_t v8 = *(unsigned int *)(v7 + 176);
  uint64_t v9 = *(unsigned int *)(v7 + 180);
  re::mtl::makeDefaultDevice(&v19);
  id v10 = objc_msgSend(objc_msgSend(v5, sel_alloc), sel_init);
  objc_msgSend(v10, sel_setStorageMode_, 2);
  objc_msgSend(v10, sel_setPixelFormat_, 70);
  objc_msgSend(v10, sel_setWidth_, v8);
  objc_msgSend(v10, sel_setHeight_, v9);
  objc_msgSend(v10, sel_setUsage_, 3);

  uint64_t v11 = *(void ***)(*((void *)this + 5) + 32);
  uint64_t v13 = v11 + 1;
  uint64_t v12 = v11[1];
  if (!v12
    || (id v14 = objc_msgSend(v12, sel_width), v14 != objc_msgSend(v6, sel_width))
    || (id v15 = objc_msgSend(*v13, sel_height), v15 != objc_msgSend(v6, sel_height))
    || (unint64_t v16 = v11[4]) == 0
    || (id v17 = objc_msgSend(v16, sel_width), v17 != objc_msgSend(v10, sel_width))
    || (id v18 = objc_msgSend(v11[4], sel_height), v18 != objc_msgSend(v10, sel_height)))
  {
    *((unsigned char *)this + 56) = 1;
    re::mtl::Device::makeTexture(v6, (id *)this + 6, &v19);
    NS::SharedPtr<MTL::Texture>::operator=(v13, &v19);
    if (v19) {

    }
    re::mtl::Device::makeTexture(v6, (id *)this + 6, &v19);
    NS::SharedPtr<MTL::Texture>::operator=(v11 + 3, &v19);
    if (v19) {

    }
    re::mtl::Device::makeTexture(v6, (id *)this + 6, &v19);
    NS::SharedPtr<MTL::Texture>::operator=(v11 + 2, &v19);
    if (v19) {

    }
    re::mtl::Device::makeTexture(v10, (id *)this + 6, &v19);
    NS::SharedPtr<MTL::Texture>::operator=(v11 + 4, &v19);
    if (v19) {

    }
    re::mtl::Device::makeTexture(v10, (id *)this + 6, &v19);
    NS::SharedPtr<MTL::Texture>::operator=(v11 + 5, &v19);
    if (v19) {
  }
    }
  NS::SharedPtr<MTL::Texture>::operator=((void **)this, v13);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 1, v11 + 3);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 2, v11 + 2);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 3, v11 + 4);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 4, v11 + 5);
  if (v10) {

  }
  if (v6) {
}
  }

void re::guided_filter_occlusion::GuidedFilterOcclusionTextureRecycler::saveTexturesForNextFrame(re::guided_filter_occlusion::GuidedFilterOcclusionTextureRecycler *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 5) + 32);
  id v4 = *(id *)(v1 + 16);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v1 + 16), (void **)(v1 + 24));
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v1 + 24), &v4);
  uint64_t v2 = *(void **)(v1 + 32);
  v1 += 32;
  id v3 = v2;
  NS::SharedPtr<MTL::Texture>::operator=((void **)v1, (void **)(v1 + 8));
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v1 + 8), &v3);
  if (v3) {

  }
  if (v4) {
}
  }

void **re::guided_filter_occlusion::GuidedFilterKernelRecycler::prepareKernelsForFrame(re::guided_filter_occlusion::GuidedFilterKernelRecycler *this, const re::RenderManager *a2, re::mtl::Library *a3, int a4)
{
  unsigned int v5 = *(void ***)(*((void *)this + 6) + 32);
  if (a4)
  {
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 6, ComputePipelineState);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    uint64_t v8 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        uint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      uint64_t v8 = v66;
      if (v66)
      {
        if (v67) {
          uint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    uint64_t v9 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 7, v9);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    id v10 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        id v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      id v10 = v66;
      if (v66)
      {
        if (v67) {
          id v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    uint64_t v11 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 8, v11);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    uint64_t v12 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        uint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      uint64_t v12 = v66;
      if (v66)
      {
        if (v67) {
          uint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    uint64_t v13 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 9, v13);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    id v14 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        id v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      id v14 = v66;
      if (v66)
      {
        if (v67) {
          id v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    id v15 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 10, v15);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    unint64_t v16 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        unint64_t v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      unint64_t v16 = v66;
      if (v66)
      {
        if (v67) {
          unint64_t v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    id v17 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 11, v17);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    id v18 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        id v18 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      id v18 = v66;
      if (v66)
      {
        if (v67) {
          id v18 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    id v19 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 12, v19);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    char v20 = (_anonymous_namespace_ *)v68;
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        char v20 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if ((_BYTE)v65)
    {
      char v20 = v66;
      if (v66)
      {
        if (v67) {
          char v20 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v66 + 40))();
        }
      }
    }
    LOBYTE(v65) = 0;
    uint64_t v74 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    uint64_t v70 = 0;
    int v73 = 0;
    char v75 = 0;
    char v76 = 0;
    uint64_t v77 = 0;
    char v78 = 0;
    uint64_t v21 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v65);
    NS::SharedPtr<MTL::Texture>::operator=(v5 + 13, v21);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v70);
    if ((void)v68)
    {
      if (BYTE8(v68)) {
        (*(void (**)(void))(*(void *)v68 + 40))();
      }
      long long v68 = 0u;
      long long v69 = 0u;
    }
    if (_BYTE)v65 && v66 && (v67) {
      (*(void (**)(void))(*(void *)v66 + 40))();
    }
  }
  uint64_t v23 = v5 + 14;
  int v22 = v5[14];
  if (!v22
    || (id v24 = v22,
        uint64_t v25 = [v24 kernelDiameter],
        uint64_t v26 = *(unsigned int *)(*((void *)this + 6) + 124),
        v24,
        v25 != v26))
  {
    re::mtl::mps::ImageGuidedFilter::ImageGuidedFilter((re::mtl::mps::ImageGuidedFilter *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56), *(unsigned int *)(*((void *)this + 6) + 124));
    if (v23 != &v65)
    {
      id v27 = v65;
      id v65 = 0;
      id v28 = *v23;
      *uint64_t v23 = v27;
    }
    LODWORD(v29) = 981668463;
    [*v23 setEpsilon:v29];
  }
  char v31 = v5 + 15;
  uint64_t v30 = v5[15];
  if (v30)
  {
    id v32 = v30;
    if ([v32 kernelWidth] == *(_DWORD *)(*((void *)this + 6) + 112))
    {
      id v33 = *v31;
      uint64_t v34 = [v33 kernelHeight];
      uint64_t v35 = *(unsigned int *)(*((void *)this + 6) + 112);

      if (v34 == v35) {
        goto LABEL_79;
      }
    }
    else
    {
    }
  }
  uint64_t v36 = *(unsigned int *)(*((void *)this + 6) + 112);
  re::mtl::mps::ImageAreaMax::ImageAreaMax((re::mtl::mps::ImageAreaMax *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56), v36, v36);
  if (v31 != &v65)
  {
    id v37 = v65;
    id v65 = 0;
    id v38 = *v31;
    *char v31 = v37;
  }
LABEL_79:
  uint64_t v40 = v5 + 16;
  uint64_t v39 = v5[16];
  if (v39)
  {
    id v41 = v39;
    if ([v41 kernelWidth] == *(_DWORD *)(*((void *)this + 6) + 120))
    {
      id v42 = *v40;
      uint64_t v43 = [v42 kernelHeight];
      uint64_t v44 = *(unsigned int *)(*((void *)this + 6) + 120);

      if (v43 == v44) {
        goto LABEL_87;
      }
    }
    else
    {
    }
  }
  uint64_t v45 = *(unsigned int *)(*((void *)this + 6) + 120);
  re::mtl::mps::ImageAreaMax::ImageAreaMax((re::mtl::mps::ImageAreaMax *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56), v45, v45);
  if (v40 != &v65)
  {
    id v46 = v65;
    id v65 = 0;
    id v47 = *v40;
    *uint64_t v40 = v46;
  }
LABEL_87:
  long long v49 = v5 + 17;
  char v48 = v5[17];
  if (v48)
  {
    id v50 = v48;
    if ([v50 kernelWidth] == *(_DWORD *)(*((void *)this + 6) + 132))
    {
      id v51 = *v49;
      uint64_t v52 = [v51 kernelHeight];
      uint64_t v53 = *(unsigned int *)(*((void *)this + 6) + 132);

      if (v52 == v53) {
        goto LABEL_95;
      }
    }
    else
    {
    }
  }
  uint64_t v54 = *(unsigned int *)(*((void *)this + 6) + 132);
  re::mtl::mps::ImageTent::ImageTent((re::mtl::mps::ImageTent *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56), v54, v54);
  if (v49 != &v65)
  {
    id v55 = v65;
    id v65 = 0;
    id v56 = *v49;
    *long long v49 = v55;
  }
LABEL_95:
  float v57 = v5 + 18;
  if (!v5[18])
  {
    re::mtl::mps::ImageBilinearScale::ImageBilinearScale((re::mtl::mps::ImageBilinearScale *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56));
    if (v57 != &v65)
    {
      id v58 = v65;
      id v65 = 0;
      id v59 = *v57;
      *float v57 = v58;
    }
  }
  uint64_t v61 = v5[19];
  unint64_t v60 = v5 + 19;
  if (!v61)
  {
    re::mtl::mps::ImageBilinearScale::ImageBilinearScale((re::mtl::mps::ImageBilinearScale *)&v65, (re::guided_filter_occlusion::GuidedFilterKernelRecycler *)((char *)this + 56));
    if (v60 != &v65)
    {
      id v62 = v65;
      id v65 = 0;
      id v63 = *v60;
      *unint64_t v60 = v62;
    }
  }
  re::ObjCObject::operator=((void **)this, *v23);
  re::ObjCObject::operator=((void **)this + 2, *v40);
  re::ObjCObject::operator=((void **)this + 3, *v49);
  re::ObjCObject::operator=((void **)this + 4, *v57);
  return re::ObjCObject::operator=((void **)this + 5, *v60);
}

re::RenderGraphComputeNodeBase *re::RenderGraphComputeNodeBase::RenderGraphComputeNodeBase(re::RenderGraphComputeNodeBase *this, const char *a2)
{
  id v3 = re::RenderGraphNode::RenderGraphNode(this, a2);
  *(void *)id v3 = &unk_26E718D28;
  id v4 = (void *)((char *)v3 + 280);
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((void *)v3 + 38) = 0;
  re::DynamicString::setCapacity(v4, 0);
  *((unsigned char *)this + 312) = 0;
  *((unsigned char *)this + 336) = 0;
  *((unsigned char *)this + 360) = 0;
  *((unsigned char *)this + 368) = 0;
  *((unsigned char *)this + 400) = 0;
  *((void *)this + 51) = -1;
  *((void *)this + 52) = -1;
  *((void *)this + 53) = -1;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = 0;
  *((_DWORD *)this + 114) = 0;
  *((void *)this + 58) = 0;
  *((void *)this + 59) = 0;
  return this;
}

uint64_t re::RenderGraphComputeNodeBase::configure(re::RenderGraphComputeNodeBase *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v8 = (re::RenderGraphComputeNodeBase *)((char *)this + 256);
  re::AssetHandle::loadNow(*((void *)this + 33), 0);
  uint64_t v9 = *(void *)(re::AssetHandle::loadedAsset<re::ShaderLibraryAsset>(v8) + 72);
  v12[0] = 0;
  re::DynamicString::DynamicString((re::DynamicString *)v15, (re::RenderGraphComputeNodeBase *)((char *)this + 280));
  uint64_t v18 = 0;
  memset(v16, 0, sizeof(v16));
  int v17 = 0;
  char v19 = 0;
  char v20 = 0;
  uint64_t v21 = v9;
  char v22 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v12);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 59, ComputePipelineState);
  re::RenderGraphNode::configure(this, a2, a3, a4);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v16);
  uint64_t result = v15[0];
  if (v15[0])
  {
    if (v15[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v15[0] + 40))();
    }
    memset(v15, 0, sizeof(v15));
  }
  if (v12[0])
  {
    uint64_t result = v13;
    if (v13)
    {
      if (v14) {
        return (*(uint64_t (**)(void))(*(void *)v13 + 40))();
      }
    }
  }
  return result;
}

void re::RenderGraphComputeNodeBase::setTexturesAndBuffersOnEncoders(void *a1, uint64_t a2, id *a3)
{
  uint64_t v6 = a1[14];
  if (v6)
  {
    uint64_t v7 = a1[16];
    uint64_t v8 = 32 * v6;
    do
    {
      if (!*(unsigned char *)(v7 + 20) || *(_DWORD *)(v7 + 8) != -1 && *(_DWORD *)(v7 + 12) != -1)
      {
        uint64_t v9 = re::RenderGraphContext::metalBuffer(a2, v7);
        [*a3 setBuffer:*(void *)v9 offset:*(unsigned int *)(v9 + 8) atIndex:*(unsigned int *)(v7 + 16)];
      }
      v7 += 32;
      v8 -= 32;
    }
    while (v8);
  }
  uint64_t v10 = a1[19];
  if (v10)
  {
    uint64_t v11 = a1[21];
    uint64_t v12 = v10 << 6;
    do
    {
      if (!*(unsigned char *)(v11 + 49) || *(_DWORD *)(v11 + 8) != -1 && *(_DWORD *)(v11 + 12) != -1)
      {
        uint64_t v13 = re::RenderGraphContext::metalBuffer(a2, v11);
        [*a3 setBuffer:*(void *)v13 offset:*(unsigned int *)(v13 + 8) atIndex:*(unsigned int *)(v11 + 16)];
      }
      v11 += 64;
      v12 -= 64;
    }
    while (v12);
  }
  uint64_t v14 = a1[24];
  if (v14)
  {
    uint64_t v15 = a1[26];
    uint64_t v16 = 32 * v14;
    do
    {
      if (!*(unsigned char *)(v15 + 20) || *(_DWORD *)(v15 + 8) != -1 && *(_DWORD *)(v15 + 12) != -1)
      {
        re::RenderGraphContext::metalTexture(a2, v15, *(unsigned __int8 *)(v15 + 21), *(unsigned __int8 *)(v15 + 22), &v20);
        [*a3 setTexture:v20 atIndex:*(unsigned int *)(v15 + 16)];
        if (v20) {
      }
        }
      v15 += 32;
      v16 -= 32;
    }
    while (v16);
  }
  uint64_t v17 = a1[29];
  if (v17)
  {
    uint64_t v18 = a1[31];
    uint64_t v19 = v17 << 6;
    do
    {
      if (!*(unsigned char *)(v18 + 49) || *(_DWORD *)(v18 + 8) != -1 && *(_DWORD *)(v18 + 12) != -1)
      {
        re::RenderGraphContext::metalTexture(a2, v18, 0, 0, &v20);
        [*a3 setTexture:v20 atIndex:*(unsigned int *)(v18 + 16)];
        if (v20) {
      }
        }
      v18 += 64;
      v19 -= 64;
    }
    while (v19);
  }
}

void re::RenderGraphComputeNodeBase::execute(re::RenderGraphComputeNodeBase *this, re::RenderGraphContext *a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v22, 5036, 0);
  if (((*(uint64_t (**)(re::RenderGraphComputeNodeBase *, re::RenderGraphContext *))(*(void *)this + 136))(this, a2) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, re::RenderGraphComputeNodeBase *, re::RenderGraphContext *))(*(void *)this + 128))(&v17, this, a2);
    id v4 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v4, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v16);
    [v16 setComputePipelineState:*((void *)this + 59)];
    id v5 = v16;
    id v15 = v5;
    re::RenderGraphComputeNodeBase::setTexturesAndBuffersOnEncoders(this, (uint64_t)a2, &v15);

    uint64_t v6 = *((void *)this + 56);
    if (v6)
    {
      uint64_t v7 = 8 * v6;
      uint64_t v8 = (unsigned int *)(*((void *)this + 58) + 4);
      do
      {
        [v16 setThreadgroupMemoryLength:*v8 atIndex:*(v8 - 1)];
        v8 += 2;
        v7 -= 8;
      }
      while (v7);
    }
    id v14 = v16;
    (*(void (**)(re::RenderGraphComputeNodeBase *, re::RenderGraphContext *, id *))(*(void *)this + 144))(this, a2, &v14);

    uint64_t v9 = *((void *)a2 + 1);
    id v13 = v16;
    re::RenderManager::sampleComputeEncoderMTLCounterBegin(v9, &v13, 1u);

    *(void *)&long long v10 = v17;
    *((void *)&v10 + 1) = HIDWORD(v17);
    long long v25 = v10;
    uint64_t v26 = v18;
    *(void *)&long long v10 = v19;
    *((void *)&v10 + 1) = v20;
    long long v23 = v10;
    uint64_t v24 = v21;
    [v16 dispatchThreadgroups:&v25 threadsPerThreadgroup:&v23];
    uint64_t v11 = *((void *)a2 + 1);
    id v12 = v16;
    re::RenderManager::sampleComputeEncoderMTLCounterEnd(v11, &v12, 1u);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v22);
}

void re::RenderGraphComputeNode::getDispatchSizes(re::RenderGraphComputeNode *this@<X0>, const re::RenderGraphContext *a2@<X1>, unsigned int *a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 105);
  unsigned int v6 = *((_DWORD *)this + 106);
  int v7 = *((_DWORD *)this + 107);
  unsigned int v8 = *((_DWORD *)this + 102);
  unsigned int v9 = *((_DWORD *)this + 103);
  unsigned int v10 = *((_DWORD *)this + 104);
  if (*((unsigned char *)this + 312))
  {
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 320, 0, 0, &v17);
    if (v5 == -1) {
      unsigned int v5 = objc_msgSend(*((id *)this + 59), sel_threadExecutionWidth);
    }
    if (v6 == -1) {
      unsigned int v6 = objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup) / v5;
    }
    if (v7 == -1) {
      int v7 = 1;
    }
    if (*((unsigned char *)this + 368))
    {
      float v11 = *((float *)this + 96);
      float v12 = *((float *)this + 97);
      float v13 = *((float *)this + 98);
    }
    else
    {
      float v12 = 1.0;
      float v11 = 1.0;
      float v13 = 1.0;
    }
    if (v8 == -1) {
      unsigned int v8 = (float)((float)(roundf(v11 * (float)(unint64_t)objc_msgSend(v17, sel_width)) + (float)v5)
    }
                               + -1.0)
         / v5;
    if (v9 == -1) {
      unsigned int v9 = (float)((float)(roundf(v12 * (float)(unint64_t)objc_msgSend(v17, sel_height)) + (float)v6)
    }
                               + -1.0)
         / v6;
    if (v10 == -1) {
      unsigned int v10 = vcvtas_u32_f32(v13 * (float)(unint64_t)objc_msgSend(v17, sel_depth));
    }
    id v16 = v17;
    if (!v17) {
      goto LABEL_51;
    }
LABEL_50:

    goto LABEL_51;
  }
  if (*((unsigned char *)this + 336))
  {
    id v14 = *(id *)re::RenderGraphContext::metalBuffer((uint64_t)a2, (uint64_t)this + 344);
    if (v5 == -1) {
      unsigned int v5 = objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup);
    }
    if (v6 == -1) {
      unsigned int v6 = 1;
    }
    if (v7 == -1) {
      int v7 = 1;
    }
    if (*((unsigned char *)this + 400)) {
      float v15 = *((float *)this + 101);
    }
    else {
      float v15 = 1.0;
    }
    if (v8 == -1) {
      unsigned int v8 = (float)((float)(roundf(v15 * (float)(unint64_t)objc_msgSend(v14, sel_length)) + (float)v5)
    }
                               + -1.0)
         / v5;
    if (v9 == -1) {
      unsigned int v9 = 1;
    }
    if (v10 == -1) {
      unsigned int v10 = 1;
    }
    if (v14)
    {
      id v16 = v14;
      goto LABEL_50;
    }
  }
  else if (*((unsigned char *)this + 360))
  {
    if (v5 == -1) {
      unsigned int v5 = objc_msgSend(*((id *)this + 59), sel_maxTotalThreadsPerThreadgroup);
    }
    if (v6 == -1) {
      unsigned int v6 = 1;
    }
    if (v7 == -1) {
      int v7 = 1;
    }
    if (v8 == -1) {
      unsigned int v8 = (v5 + *((_DWORD *)this + 91) - 1) / v5;
    }
    if (v9 == -1) {
      unsigned int v9 = 1;
    }
    if (v10 == -1) {
      unsigned int v10 = 1;
    }
  }
LABEL_51:
  *a3 = v8;
  a3[1] = v9;
  a3[2] = v10;
  a3[3] = v5;
  a3[4] = v6;
  a3[5] = v7;
}

void re::RenderGraphComputeNode::validateAttachmentsDuringGraphBuild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v94 = 0;
  long long v92 = 0u;
  long long v93 = 0u;
  uint64_t v95 = 0x7FFFFFFFLL;
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)&v92, a3, 3);
  uint64_t v5 = *(void *)(a1 + 112);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 128);
    uint64_t v7 = v6 + 32 * v5;
    do
    {
      unint64_t v8 = *(unsigned int *)(v6 + 16);
      uint64_t v9 = v92;
      if ((void)v92)
      {
        unint64_t v10 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
        uint64_t v11 = *(unsigned int *)(*((void *)&v92 + 1) + 4 * ((v10 ^ (v10 >> 31)) % DWORD2(v93)));
        if (v11 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v93 + 32 * v11 + 12) != v8)
          {
            uint64_t v11 = *(_DWORD *)(v93 + 32 * v11 + 8) & 0x7FFFFFFF;
            if (v11 == 0x7FFFFFFF) {
              goto LABEL_13;
            }
          }
          uint64_t v12 = *(void *)(a1 + 16);
          re::RenderGraphCompiled::bufferName((re::StringID *)&v84, *(void *)(a2 + 296), *(_DWORD *)(v6 + 8));
          re::DynamicString::format((re::DynamicString *)"(%s): Buffer read (%s, %u) contains compute index which is already in use on a RenderGraphComputeNode.", (re::DynamicString *)&v88, v12, *((void *)&v84 + 1), *(unsigned int *)(v6 + 16));
          re::RenderGraphCompiled::addError(a2, (uint64_t)&v88);
          if ((void)v88)
          {
            if (BYTE8(v88)) {
              (*(void (**)(void, void))(*(void *)v88 + 40))(v88, v89);
            }
            long long v88 = 0u;
            long long v89 = 0u;
          }
          re::StringID::destroyString((re::StringID *)&v84);
          unint64_t v8 = *(unsigned int *)(v6 + 16);
        }
      }
LABEL_13:
      unint64_t v13 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
      unint64_t v14 = v13 ^ (v13 >> 31);
      if (v9)
      {
        unint64_t v15 = v14 % DWORD2(v93);
        uint64_t v16 = *(unsigned int *)(*((void *)&v92 + 1) + 4 * v15);
        if (v16 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v93 + 32 * v16 + 12) != v8)
          {
            uint64_t v16 = *(_DWORD *)(v93 + 32 * v16 + 8) & 0x7FFFFFFF;
            if (v16 == 0x7FFFFFFF) {
              goto LABEL_19;
            }
          }
          goto LABEL_25;
        }
      }
      else
      {
        unint64_t v15 = 0;
      }
LABEL_19:
      uint64_t v17 = v95;
      if (v95 == 0x7FFFFFFF)
      {
        uint64_t v17 = v94;
        unsigned int v18 = v94;
        if (v94 == DWORD2(v93))
        {
          re::HashTable<unsigned int,re::RenderGraphBufferHandle,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity((uint64_t)&v92, 2 * HIDWORD(v93));
          unsigned int v18 = v94;
          unint64_t v15 = v14 % DWORD2(v93);
        }
        unsigned int v94 = v18 + 1;
        uint64_t v19 = v93;
        int v20 = *(_DWORD *)(v93 + 32 * v17 + 8);
      }
      else
      {
        uint64_t v19 = v93;
        int v20 = *(_DWORD *)(v93 + 32 * v95 + 8);
        LODWORD(v95) = v20 & 0x7FFFFFFF;
      }
      uint64_t v21 = v19 + 32 * v17;
      *(_DWORD *)(v21 + 8) = v20 | 0x80000000;
      uint64_t v22 = *((void *)&v92 + 1);
      *(_DWORD *)(v21 + 8) = *(_DWORD *)(*((void *)&v92 + 1) + 4 * v15) | 0x80000000;
      *(void *)uint64_t v21 = v14;
      *(_DWORD *)(v21 + 12) = *(_DWORD *)(v6 + 16);
      *(void *)(v21 + 16) = 0;
      *(void *)(v21 + 24) = -1;
      *(void *)(v21 + 16) = *(void *)v6;
      *(void *)(v21 + 24) = *(void *)(v6 + 8);
      *(_DWORD *)(v22 + 4 * v15) = v17;
      ++HIDWORD(v93);
      ++HIDWORD(v95);
LABEL_25:
      v6 += 32;
    }
    while (v6 != v7);
  }
  int v90 = 0;
  long long v88 = 0u;
  long long v89 = 0u;
  uint64_t v91 = 0x7FFFFFFFLL;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::init((uint64_t)&v88, a3, 3);
  uint64_t v23 = *(void *)(a1 + 152);
  if (v23)
  {
    uint64_t v24 = *(unsigned int **)(a1 + 168);
    long long v25 = &v24[16 * v23];
    do
    {
      uint64_t v26 = v24[4];
      if (re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey((uint64_t)&v88, v24[4]))
      {
        uint64_t v27 = *(void *)(a1 + 16);
        re::RenderGraphCompiled::bufferName((re::StringID *)&v78, *(void *)(a2 + 296), v24[2]);
        re::DynamicString::format((re::DynamicString *)"(%s): Buffer write (%s, %u) contains compute index which is already in use on a RenderGraphComputeNode.", (re::DynamicString *)&v84, v27, *((void *)&v78 + 1), v24[4]);
        re::RenderGraphCompiled::addError(a2, (uint64_t)&v84);
        if ((void)v84)
        {
          if (BYTE8(v84)) {
            (*(void (**)(void))(*(void *)v84 + 40))();
          }
          long long v84 = 0u;
          long long v85 = 0u;
        }
        re::StringID::destroyString((re::StringID *)&v78);
        uint64_t v26 = v24[4];
      }
      if ((void)v92)
      {
        unint64_t v28 = 0xBF58476D1CE4E5B9 * (v26 ^ ((unint64_t)v26 >> 30));
        uint64_t v29 = *(unsigned int *)(*((void *)&v92 + 1)
                              + 4
                              * (((0x94D049BB133111EBLL * (v28 ^ (v28 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                                 * (v28 ^ (v28 >> 27))) >> 31))
                               % DWORD2(v93)));
        if (v29 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v93 + 32 * v29 + 12) != v26)
          {
            uint64_t v29 = *(_DWORD *)(v93 + 32 * v29 + 8) & 0x7FFFFFFF;
            if (v29 == 0x7FFFFFFF) {
              goto LABEL_45;
            }
          }
          unsigned int v30 = *(_DWORD *)(v93 + 32 * v29 + 24);
          if (v30 != v24[2])
          {
            uint64_t v31 = *(void *)(a1 + 16);
            re::RenderGraphCompiled::bufferName((re::StringID *)&v78, *(void *)(a2 + 296), v30);
            uint64_t v32 = *((void *)&v78 + 1);
            re::RenderGraphCompiled::bufferName((re::StringID *)&v76, *(void *)(a2 + 296), v24[2]);
            re::DynamicString::format((re::DynamicString *)"(%s): Buffer read_write at compute index %u is not consistent. [read]: %s; [write]: %"
                                   "s. They should be the same.",
              (re::DynamicString *)&v84,
              v31,
              v26,
              v32,
              *((void *)&v76 + 1));
            re::RenderGraphCompiled::addError(a2, (uint64_t)&v84);
            if ((void)v84)
            {
              if (BYTE8(v84)) {
                (*(void (**)(void))(*(void *)v84 + 40))();
              }
              long long v84 = 0u;
              long long v85 = 0u;
            }
            re::StringID::destroyString((re::StringID *)&v76);
            re::StringID::destroyString((re::StringID *)&v78);
          }
        }
      }
LABEL_45:
      if (v24[5] != 5)
      {
        uint64_t v33 = *(void *)(a1 + 16);
        re::RenderGraphCompiled::bufferName((re::StringID *)&v78, *(void *)(a2 + 296), v24[2]);
        re::DynamicString::format((re::DynamicString *)"(%s): Buffer write (%s, %u) Non-compute write on compute node", (re::DynamicString *)&v84, v33, *((void *)&v78 + 1), v24[4]);
        re::RenderGraphCompiled::addError(a2, (uint64_t)&v84);
        if ((void)v84)
        {
          if (BYTE8(v84)) {
            (*(void (**)(void))(*(void *)v84 + 40))();
          }
          long long v84 = 0u;
          long long v85 = 0u;
        }
        re::StringID::destroyString((re::StringID *)&v78);
      }
      re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add((uint64_t)&v88, v24 + 4);
      v24 += 16;
    }
    while (v24 != v25);
  }
  unsigned int v86 = 0;
  long long v84 = 0u;
  long long v85 = 0u;
  uint64_t v87 = 0x7FFFFFFFLL;
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)&v84, a3, 3);
  uint64_t v34 = *(void *)(a1 + 192);
  if (v34)
  {
    uint64_t v35 = *(uint64_t **)(a1 + 208);
    uint64_t v36 = &v35[4 * v34];
    do
    {
      unint64_t v37 = *((unsigned int *)v35 + 4);
      uint64_t v38 = v84;
      if ((void)v84)
      {
        unint64_t v39 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) >> 27));
        uint64_t v40 = *(unsigned int *)(*((void *)&v84 + 1) + 4 * ((v39 ^ (v39 >> 31)) % DWORD2(v85)));
        if (v40 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v85 + 32 * v40 + 12) != v37)
          {
            uint64_t v40 = *(_DWORD *)(v85 + 32 * v40 + 8) & 0x7FFFFFFF;
            if (v40 == 0x7FFFFFFF) {
              goto LABEL_64;
            }
          }
          uint64_t v41 = *(void *)(a1 + 16);
          uint64_t v82 = 0;
          uint64_t v83 = -1;
          uint64_t v82 = *v35;
          uint64_t v83 = v35[1];
          re::RenderGraphCompiled::targetName(a2, (uint64_t)&v82, (re::StringID *)&v76);
          re::DynamicString::format((re::DynamicString *)"(%s): Target read (%s, %u) contains compute index which is already in use on a RenderGraphComputeNode.", (re::DynamicString *)&v78, v41, *((void *)&v76 + 1), *((unsigned int *)v35 + 4));
          re::RenderGraphCompiled::addError(a2, (uint64_t)&v78);
          if ((void)v78)
          {
            if (BYTE8(v78)) {
              (*(void (**)(void))(*(void *)v78 + 40))();
            }
            long long v78 = 0u;
            long long v79 = 0u;
          }
          re::StringID::destroyString((re::StringID *)&v76);
          unint64_t v37 = *((unsigned int *)v35 + 4);
        }
      }
LABEL_64:
      unint64_t v42 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v37 ^ (v37 >> 30))) >> 27));
      unint64_t v43 = v42 ^ (v42 >> 31);
      if (v38)
      {
        unint64_t v44 = v43 % DWORD2(v85);
        uint64_t v45 = *(unsigned int *)(*((void *)&v84 + 1) + 4 * v44);
        if (v45 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v85 + 32 * v45 + 12) != v37)
          {
            uint64_t v45 = *(_DWORD *)(v85 + 32 * v45 + 8) & 0x7FFFFFFF;
            if (v45 == 0x7FFFFFFF) {
              goto LABEL_70;
            }
          }
          goto LABEL_76;
        }
      }
      else
      {
        unint64_t v44 = 0;
      }
LABEL_70:
      uint64_t v46 = v87;
      if (v87 == 0x7FFFFFFF)
      {
        uint64_t v46 = v86;
        unsigned int v47 = v86;
        if (v86 == DWORD2(v85))
        {
          re::HashTable<unsigned int,re::RenderGraphBufferHandle,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity((uint64_t)&v84, 2 * HIDWORD(v85));
          unsigned int v47 = v86;
          unint64_t v44 = v43 % DWORD2(v85);
        }
        unsigned int v86 = v47 + 1;
        uint64_t v48 = v85;
        int v49 = *(_DWORD *)(v85 + 32 * v46 + 8);
      }
      else
      {
        uint64_t v48 = v85;
        int v49 = *(_DWORD *)(v85 + 32 * v87 + 8);
        LODWORD(v87) = v49 & 0x7FFFFFFF;
      }
      uint64_t v50 = v48 + 32 * v46;
      *(_DWORD *)(v50 + 8) = v49 | 0x80000000;
      uint64_t v51 = *((void *)&v84 + 1);
      *(_DWORD *)(v50 + 8) = *(_DWORD *)(*((void *)&v84 + 1) + 4 * v44) | 0x80000000;
      *(void *)uint64_t v50 = v43;
      *(_DWORD *)(v50 + 12) = *((_DWORD *)v35 + 4);
      *(void *)(v50 + 16) = 0;
      *(void *)(v50 + 24) = -1;
      *(void *)(v50 + 16) = *v35;
      *(void *)(v50 + 24) = v35[1];
      *(_DWORD *)(v51 + 4 * v44) = v46;
      ++HIDWORD(v85);
      ++HIDWORD(v87);
LABEL_76:
      v35 += 4;
    }
    while (v35 != v36);
  }
  int v80 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  uint64_t v81 = 0x7FFFFFFFLL;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::init((uint64_t)&v78, a3, 3);
  uint64_t v52 = *(void *)(a1 + 232);
  if (v52)
  {
    uint64_t v53 = *(uint64_t **)(a1 + 248);
    uint64_t v54 = &v53[8 * v52];
    do
    {
      uint64_t v55 = *((unsigned int *)v53 + 4);
      if (re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey((uint64_t)&v78, *((_DWORD *)v53 + 4)))
      {
        uint64_t v56 = *(void *)(a1 + 16);
        uint64_t v72 = 0;
        uint64_t v73 = -1;
        uint64_t v72 = *v53;
        uint64_t v73 = v53[1];
        re::RenderGraphCompiled::targetName(a2, (uint64_t)&v72, (re::StringID *)v74);
        re::DynamicString::format((re::DynamicString *)"(%s): Target write (%s, %u) contains compute index which is already in use on a RenderGraphComputeNode.", (re::DynamicString *)&v76, v56, v75, *((unsigned int *)v53 + 4));
        re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
        if ((void)v76)
        {
          if (BYTE8(v76)) {
            (*(void (**)(void))(*(void *)v76 + 40))();
          }
          long long v76 = 0u;
          long long v77 = 0u;
        }
        re::StringID::destroyString((re::StringID *)v74);
        uint64_t v55 = *((unsigned int *)v53 + 4);
      }
      if ((void)v84)
      {
        unint64_t v57 = 0xBF58476D1CE4E5B9 * (v55 ^ ((unint64_t)v55 >> 30));
        uint64_t v58 = *(unsigned int *)(*((void *)&v84 + 1)
                              + 4
                              * (((0x94D049BB133111EBLL * (v57 ^ (v57 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                                 * (v57 ^ (v57 >> 27))) >> 31))
                               % DWORD2(v85)));
        if (v58 != 0x7FFFFFFF)
        {
          while (*(_DWORD *)(v85 + 32 * v58 + 12) != v55)
          {
            uint64_t v58 = *(_DWORD *)(v85 + 32 * v58 + 8) & 0x7FFFFFFF;
            if (v58 == 0x7FFFFFFF) {
              goto LABEL_96;
            }
          }
          uint64_t v59 = v85 + 32 * v58;
          if (*(_DWORD *)(v59 + 24) != *((_DWORD *)v53 + 2))
          {
            uint64_t v60 = *(void *)(a1 + 16);
            uint64_t v70 = 0;
            uint64_t v71 = -1;
            uint64_t v70 = *(void *)(v59 + 16);
            uint64_t v71 = *(void *)(v59 + 24);
            re::RenderGraphCompiled::targetName(a2, (uint64_t)&v70, (re::StringID *)v74);
            uint64_t v61 = v75;
            uint64_t v66 = 0;
            uint64_t v67 = -1;
            uint64_t v66 = *v53;
            uint64_t v67 = v53[1];
            re::RenderGraphCompiled::targetName(a2, (uint64_t)&v66, (re::StringID *)v68);
            re::DynamicString::format((re::DynamicString *)"(%s): Target read_write at compute index %u is not consistent. [read]: %s; [write]: %"
                                   "s. They should be the same.",
              (re::DynamicString *)&v76,
              v60,
              v55,
              v61,
              v69);
            re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
            if ((void)v76)
            {
              if (BYTE8(v76)) {
                (*(void (**)(void))(*(void *)v76 + 40))();
              }
              long long v76 = 0u;
              long long v77 = 0u;
            }
            re::StringID::destroyString((re::StringID *)v68);
            re::StringID::destroyString((re::StringID *)v74);
          }
        }
      }
LABEL_96:
      if (*((_DWORD *)v53 + 5) != 5)
      {
        uint64_t v62 = *(void *)(a1 + 16);
        uint64_t v64 = 0;
        uint64_t v65 = -1;
        uint64_t v64 = *v53;
        uint64_t v65 = v53[1];
        re::RenderGraphCompiled::targetName(a2, (uint64_t)&v64, (re::StringID *)v74);
        re::DynamicString::format((re::DynamicString *)"(%s): Target write (%s, %u) Non-compute write on compute node", (re::DynamicString *)&v76, v62, v75, *((unsigned int *)v53 + 4));
        re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
        if ((void)v76)
        {
          if (BYTE8(v76)) {
            (*(void (**)(void))(*(void *)v76 + 40))();
          }
          long long v76 = 0u;
          long long v77 = 0u;
        }
        re::StringID::destroyString((re::StringID *)v74);
      }
      re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add((uint64_t)&v78, (_DWORD *)v53 + 4);
      v53 += 8;
    }
    while (v53 != v54);
  }
  if (!*(unsigned char *)(a1 + 312) && !*(unsigned char *)(a1 + 336) && !*(unsigned char *)(a1 + 360))
  {
    if (*(_DWORD *)(a1 + 408) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): gridSizeWidth not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
    if (*(_DWORD *)(a1 + 412) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): gridSizeHeight not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
    if (*(_DWORD *)(a1 + 416) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): gridSizeDepth not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
    if (*(_DWORD *)(a1 + 420) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): threadGroupSizeWidth not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
    if (*(_DWORD *)(a1 + 424) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): threadGroupSizeHeight not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
    if (*(_DWORD *)(a1 + 428) == -1)
    {
      re::DynamicString::format((re::DynamicString *)"(%s): threadGroupSizeDepth not specified and no outputDimensionsTarget or outputDimensionsBuffer or outputElementCount was supplied on a RenderGraphComputeNode.", (re::DynamicString *)&v76, *(void *)(a1 + 16));
      re::RenderGraphCompiled::addError(a2, (uint64_t)&v76);
      if ((void)v76)
      {
        if (BYTE8(v76)) {
          (*(void (**)(void))(*(void *)v76 + 40))();
        }
      }
    }
  }
  re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)&v78);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v84);
  re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)&v88);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v92);
}

re::StringID *re::RenderGraphCompiled::bufferName(re::StringID *a1, uint64_t a2, unsigned int a3)
{
  if (*(void *)(a2 + 16) <= (unint64_t)a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  id v3 = (const StringID *)(*(void *)(a2 + 32) + 48 * a3 + 8);
  return re::StringID::StringID(a1, v3);
}

BOOL re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % v2));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 16 * v4 + 12) == a2) {
    return 1;
  }
  do
  {
    uint64_t v4 = *(_DWORD *)(v6 + 16 * v4 + 8) & 0x7FFFFFFF;
    BOOL result = v4 != 0x7FFFFFFF;
  }
  while (v4 != 0x7FFFFFFF && *(_DWORD *)(v6 + 16 * v4 + 12) != a2);
  return result;
}

uint64_t re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add(uint64_t result, _DWORD *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *a2;
  unint64_t v5 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  unint64_t v6 = v5 ^ (v5 >> 31);
  unint64_t v7 = *(unsigned int *)(result + 24);
  if (v7)
  {
    unint64_t v8 = v6 % v7;
    uint64_t v9 = *(unsigned int *)(*(void *)(result + 8) + 4 * (v6 % v7));
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v10 = *(void *)(result + 16);
      if (*(_DWORD *)(v10 + 16 * v9 + 12) == v4) {
        return result;
      }
      while (1)
      {
        uint64_t v9 = *(_DWORD *)(v10 + 16 * v9 + 8) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v10 + 16 * v9 + 12) == v4) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  BOOL result = re::HashSetBase<unsigned int,unsigned int,re::internal::ValueAsKey<unsigned int>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsCopy(result, v8, v6, (uint64_t)a2, a2);
  ++*(_DWORD *)(v3 + 40);
  return result;
}

re::StringID *re::RenderGraphCompiled::targetName@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::StringID *a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 296);
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if (*(void *)(v3 + 16) <= v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v5 = (const StringID *)(*(void *)(v3 + 32) + 48 * v4 + 8);
  return re::StringID::StringID(a3, v5);
}

void *re::allocInfo_ThreadGroupMemorySetting(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A6B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A770, "ThreadGroupMemorySetting");
    __cxa_guard_release(&qword_26AF9A6B0);
  }
  return &unk_26AF9A770;
}

void re::initInfo_ThreadGroupMemorySetting(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x22B37C92029F6B34;
  v14[1] = "ThreadGroupMemorySetting";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6B8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A6B8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      unint64_t v7 = re::introspect_uint32_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "index";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9A6E0 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "bytes";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF9A6E8 = v12;
      __cxa_guard_release(&qword_26AF9A6B8);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9A6E0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ThreadGroupMemorySetting>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ThreadGroupMemorySetting>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ThreadGroupMemorySetting>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ThreadGroupMemorySetting>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void *re::allocInfo_RenderGraphComputeNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A6C0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A7E8, "RenderGraphComputeNode");
    __cxa_guard_release(&qword_26AF9A6C0);
  }
  return &unk_26AF9A7E8;
}

void re::initInfo_RenderGraphComputeNode(re *this, re::IntrospectionBase *a2)
{
  v61[0] = 0xB2B40BD8F0C94D02;
  v61[1] = "RenderGraphComputeNode";
  re::StringID::destroyString((re::StringID *)v61);
  *((_OWORD *)this + 2) = v62;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6C8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A6C8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A860 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "library";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A868 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      unint64_t v14 = re::IntrospectionInfo<re::DynamicString>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "computeFunction";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11800000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9A870 = v15;
      uint64_t v16 = re::introspectionAllocator((re *)v15);
      unsigned int v18 = re::introspect_uint32_t((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "gridSizeWidth";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x19800000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9A878 = v19;
      int v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_uint32_t((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "gridSizeHeight";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x19C00000005;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF9A880 = v23;
      uint64_t v24 = re::introspectionAllocator((re *)v23);
      uint64_t v26 = re::introspect_uint32_t((re *)1, v25);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "gridSizeDepth";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x1A000000006;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF9A888 = v27;
      unint64_t v28 = re::introspectionAllocator((re *)v27);
      unsigned int v30 = re::introspect_uint32_t((re *)1, v29);
      uint64_t v31 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v28 + 32))(v28, 72, 8);
      *(_DWORD *)uint64_t v31 = 1;
      *(void *)(v31 + 8) = "threadGroupSizeWidth";
      *(void *)(v31 + 16) = v30;
      *(void *)(v31 + 24) = 0;
      *(void *)(v31 + 32) = 0x1A400000007;
      *(_DWORD *)(v31 + 40) = 0;
      *(void *)(v31 + 48) = 0;
      *(void *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_26AF9A890 = v31;
      uint64_t v32 = re::introspectionAllocator((re *)v31);
      uint64_t v34 = re::introspect_uint32_t((re *)1, v33);
      uint64_t v35 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 72, 8);
      *(_DWORD *)uint64_t v35 = 1;
      *(void *)(v35 + 8) = "threadGroupSizeHeight";
      *(void *)(v35 + 16) = v34;
      *(void *)(v35 + 24) = 0;
      *(void *)(v35 + 32) = 0x1A800000008;
      *(_DWORD *)(v35 + 40) = 0;
      *(void *)(v35 + 48) = 0;
      *(void *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_26AF9A898 = v35;
      uint64_t v36 = re::introspectionAllocator((re *)v35);
      uint64_t v38 = re::introspect_uint32_t((re *)1, v37);
      uint64_t v39 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 72, 8);
      *(_DWORD *)uint64_t v39 = 1;
      *(void *)(v39 + 8) = "threadGroupSizeDepth";
      *(void *)(v39 + 16) = v38;
      *(void *)(v39 + 24) = 0;
      *(void *)(v39 + 32) = 0x1AC00000009;
      *(_DWORD *)(v39 + 40) = 0;
      *(void *)(v39 + 48) = 0;
      *(void *)(v39 + 56) = 0;
      *(_DWORD *)(v39 + 64) = 0;
      qword_26AF9A8A0 = v39;
      uint64_t v40 = re::introspectionAllocator((re *)v39);
      uint64_t v41 = re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get((re *)1);
      uint64_t v42 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 72, 8);
      *(_DWORD *)uint64_t v42 = 1;
      *(void *)(v42 + 8) = "threadGroupMemorySettings";
      *(void *)(v42 + 16) = v41;
      *(void *)(v42 + 24) = 0;
      *(void *)(v42 + 32) = 0x1B00000000ALL;
      *(_DWORD *)(v42 + 40) = 0;
      *(void *)(v42 + 48) = 0;
      *(void *)(v42 + 56) = 0;
      *(_DWORD *)(v42 + 64) = 0;
      qword_26AF9A8A8 = v42;
      unint64_t v43 = re::introspectionAllocator((re *)v42);
      re::IntrospectionInfo<re::Optional<re::RenderGraphTargetHandle>>::get((uint64_t)v43, v44);
      uint64_t v45 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v43 + 32))(v43, 72, 8);
      *(_DWORD *)uint64_t v45 = 1;
      *(void *)(v45 + 8) = "outputDimensionsTarget";
      *(void *)(v45 + 16) = &qword_26AF9A6F0;
      *(void *)(v45 + 24) = 0;
      *(void *)(v45 + 32) = 0x1380000000CLL;
      *(_DWORD *)(v45 + 40) = 0;
      *(void *)(v45 + 48) = 0;
      *(void *)(v45 + 56) = 0;
      *(_DWORD *)(v45 + 64) = 0;
      qword_26AF9A8B0 = v45;
      uint64_t v46 = re::introspectionAllocator((re *)v45);
      re::IntrospectionInfo<re::Optional<re::RenderGraphBufferHandle>>::get((uint64_t)v46, v47);
      uint64_t v48 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 72, 8);
      *(_DWORD *)uint64_t v48 = 1;
      *(void *)(v48 + 8) = "outputDimensionsBuffer";
      *(void *)(v48 + 16) = qword_26AF9A730;
      *(void *)(v48 + 24) = 0;
      *(void *)(v48 + 32) = 0x1500000000DLL;
      *(_DWORD *)(v48 + 40) = 0;
      *(void *)(v48 + 48) = 0;
      *(void *)(v48 + 56) = 0;
      *(_DWORD *)(v48 + 64) = 0;
      qword_26AF9A8B8 = v48;
      int v49 = re::introspectionAllocator((re *)v48);
      uint64_t v51 = re::IntrospectionInfo<re::Optional<unsigned int>>::get(1, v50);
      uint64_t v52 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v49 + 32))(v49, 72, 8);
      *(_DWORD *)uint64_t v52 = 1;
      *(void *)(v52 + 8) = "outputElementCount";
      *(void *)(v52 + 16) = v51;
      *(void *)(v52 + 24) = 0;
      *(void *)(v52 + 32) = 0x1680000000ELL;
      *(_DWORD *)(v52 + 40) = 0;
      *(void *)(v52 + 48) = 0;
      *(void *)(v52 + 56) = 0;
      *(_DWORD *)(v52 + 64) = 0;
      qword_26AF9A8C0 = v52;
      uint64_t v53 = re::introspectionAllocator((re *)v52);
      uint64_t v54 = re::IntrospectionInfo<re::Optional<re::Vector3<float>>>::get(1);
      uint64_t v55 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v53 + 32))(v53, 72, 8);
      *(_DWORD *)uint64_t v55 = 1;
      *(void *)(v55 + 8) = "outputDimensionsTargetMultiplier";
      *(void *)(v55 + 16) = v54;
      *(void *)(v55 + 24) = 0;
      *(void *)(v55 + 32) = 0x1700000000FLL;
      *(_DWORD *)(v55 + 40) = 0;
      *(void *)(v55 + 48) = 0;
      *(void *)(v55 + 56) = 0;
      *(_DWORD *)(v55 + 64) = 0;
      qword_26AF9A8C8 = v55;
      uint64_t v56 = re::introspectionAllocator((re *)v55);
      uint64_t v58 = re::IntrospectionInfo<re::Optional<float>>::get(1, v57);
      uint64_t v59 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 72, 8);
      *(_DWORD *)uint64_t v59 = 1;
      *(void *)(v59 + 8) = "outputDimensionsBufferMultiplier";
      *(void *)(v59 + 16) = v58;
      *(void *)(v59 + 24) = 0;
      *(void *)(v59 + 32) = 0x19000000010;
      *(_DWORD *)(v59 + 40) = 0;
      *(void *)(v59 + 48) = 0;
      *(void *)(v59 + 56) = 0;
      *(_DWORD *)(v59 + 64) = 0;
      qword_26AF9A8D0 = v59;
      __cxa_guard_release(&qword_26AF9A6C8);
    }
  }
  *((void *)this + 2) = 0x1E000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 15;
  *((void *)this + 8) = &qword_26AF9A860;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphComputeNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphComputeNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphComputeNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphComputeNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v60 = v62;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(re *a1)
{
  int v1 = (int)a1;
  {
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info);
      re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::mach_timebase_info info = (uint64_t)&unk_26E718EA8;
    }
  }
  if (v1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  unint64_t v5 = (int *)re::internal::introspectionInfoStorage<re::ThreadGroupMemorySetting>;
  if (!re::internal::introspectionInfoStorage<re::ThreadGroupMemorySetting>)
  {
    unint64_t v5 = (int *)re::allocInfo_ThreadGroupMemorySetting(a1);
    re::internal::introspectionInfoStorage<re::ThreadGroupMemorySetting> = (uint64_t)v5;
    re::initInfo_ThreadGroupMemorySetting((re *)v5, v6);
  }
  if (re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::isInitialized)
  {
    if ((v1 & 1) == 0)
    {
LABEL_11:
      uint64_t v7 = re::introspectionSharedMutex(a1);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::isInitialized = 1;
    int v9 = v5[6];
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info, 0);
    qword_2687962B0 = 0x2800000003;
    dword_2687962B8 = v9;
    word_2687962BC = 0;
    *(void *)&xmmword_2687962C0 = 0;
    *((void *)&xmmword_2687962C0 + 1) = 0xFFFFFFFFLL;
    qword_2687962D0 = (uint64_t)v5;
    unk_2687962D8 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::mach_timebase_info info = (uint64_t)&unk_26E718EA8;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      uint64_t v12 = v15;
    }
    else {
      uint64_t v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *((_OWORD *)v5 + 2);
    xmmword_2687962C0 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((v1 & 1) == 0) {
      goto LABEL_11;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::ThreadGroupMemorySetting>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::Optional<re::RenderGraphTargetHandle>>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A6D0))
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)&qword_26AF9A6F0);
    qword_26AF9A6F0 = (uint64_t)&unk_26E718F40;
    __cxa_guard_release(&qword_26AF9A6D0);
  }
  if ((_MergedGlobals_441 & 1) == 0)
  {
    int v2 = re::introspect_RenderGraphTargetHandle((re *)1, a2);
    if ((_MergedGlobals_441 & 1) == 0)
    {
      uint64_t v3 = (uint64_t)v2;
      _MergedGlobals_441 = 1;
      int v4 = *((_DWORD *)v2 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF9A6F0, 0);
      qword_26AF9A700 = 0x180000000DLL;
      dword_26AF9A708 = v4;
      word_26AF9A70C = 0;
      *(void *)&xmmword_26AF9A710 = 0;
      *((void *)&xmmword_26AF9A710 + 1) = 0xFFFFFFFFLL;
      qword_26AF9A720 = v3;
      unk_26AF9A728 = 0;
      qword_26AF9A6F0 = (uint64_t)&unk_26E718F40;
      re::IntrospectionRegistry::add(v5, v6);
      re::getPrettyTypeName((re *)&qword_26AF9A6F0, (const re::IntrospectionBase *)&v15);
      if (v16) {
        uint64_t v7 = *(const char **)&v17[7];
      }
      else {
        uint64_t v7 = v17;
      }
      if (v15 && (v16 & 1) != 0) {
        (*(void (**)(void))(*(void *)v15 + 40))();
      }
      long long v12 = *(_OWORD *)(v3 + 32);
      uint64_t v8 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v13);
      if (v8)
      {
        uint64_t v9 = *v8;
        *((void *)&v11 + 1) = v9;
      }
      else
      {
        long long v14 = v12;
        re::TypeBuilder::beginOptionalType((uint64_t)&v15, v13, 0x18uLL, 8uLL, &v14);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v15, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::RenderGraphTargetHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::RenderGraphTargetHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v15, v10);
      }
      xmmword_26AF9A710 = v11;
      re::StringID::destroyString((re::StringID *)v13);
    }
  }
}

void re::IntrospectionInfo<re::Optional<re::RenderGraphBufferHandle>>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A6D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A6D8))
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)qword_26AF9A730);
    qword_26AF9A730[0] = (uint64_t)&unk_26E718FC0;
    __cxa_guard_release(&qword_26AF9A6D8);
  }
  if ((byte_26AF9A6A9 & 1) == 0)
  {
    int v2 = re::introspect_RenderGraphBufferHandle((re *)1, a2);
    if ((byte_26AF9A6A9 & 1) == 0)
    {
      uint64_t v3 = v2;
      byte_26AF9A6A9 = 1;
      int v4 = *((_DWORD *)v2 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_26AF9A730, 0);
      unk_26AF9A740 = 0x180000000DLL;
      unk_26AF9A748 = v4;
      unk_26AF9A74C = 0;
      *(void *)&xmmword_26AF9A750 = 0;
      *((void *)&xmmword_26AF9A750 + 1) = 0xFFFFFFFFLL;
      unk_26AF9A760 = v3;
      unk_26AF9A768 = 0;
      qword_26AF9A730[0] = (uint64_t)&unk_26E718FC0;
      re::IntrospectionRegistry::add(v5, v6);
      re::getPrettyTypeName((re *)qword_26AF9A730, (const re::IntrospectionBase *)&v15);
      if (v16) {
        uint64_t v7 = *(const char **)&v17[7];
      }
      else {
        uint64_t v7 = v17;
      }
      if (v15 && (v16 & 1) != 0) {
        (*(void (**)(void))(*(void *)v15 + 40))();
      }
      long long v12 = *((_OWORD *)v3 + 2);
      uint64_t v8 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v13);
      if (v8)
      {
        uint64_t v9 = *v8;
        *((void *)&v11 + 1) = v9;
      }
      else
      {
        long long v14 = v12;
        re::TypeBuilder::beginOptionalType((uint64_t)&v15, v13, 0x18uLL, 8uLL, &v14);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v15, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::RenderGraphBufferHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::RenderGraphBufferHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v15, v10);
      }
      xmmword_26AF9A750 = v11;
      re::StringID::destroyString((re::StringID *)v13);
    }
  }
}

re::RenderGraphComputeNodeBase *re::internal::defaultConstruct<re::RenderGraphComputeNode>(int a1, int a2, re::RenderGraphComputeNodeBase *this)
{
  BOOL result = re::RenderGraphComputeNodeBase::RenderGraphComputeNodeBase(this);
  *(void *)BOOL result = &unk_26E718DE8;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphComputeNode>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

re::RenderGraphComputeNodeBase *re::internal::defaultConstructV2<re::RenderGraphComputeNode>(re::RenderGraphComputeNodeBase *a1)
{
  BOOL result = re::RenderGraphComputeNodeBase::RenderGraphComputeNodeBase(a1);
  *(void *)BOOL result = &unk_26E718DE8;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphComputeNode>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphComputeNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphComputeNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphComputeNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphComputeNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphComputeNode>, this);
}

void re::RenderGraphComputeNode::~RenderGraphComputeNode(re::RenderGraphComputeNode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::HashTable<unsigned int,re::RenderGraphBufferHandle,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)uint64_t v23 = v5;
      *(void *)&unsigned char v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = v6 + 12;
        do
        {
          if ((*(_DWORD *)(v13 - 4) & 0x80000000) != 0)
          {
            unint64_t v14 = *(void *)(v13 - 12);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<unsigned int,re::RenderGraphBufferHandle,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 32 * v17) = v14;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 12) = *(_DWORD *)v13;
            uint64_t v21 = *(void *)(a1 + 16) + 32 * v17;
            *(void *)(v21 + 16) = 0;
            *(void *)(v21 + 24) = -1;
            *(void *)(v21 + 16) = *(void *)(v13 + 4);
            *(void *)(v21 + 24) = *(void *)(v13 + 12);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 32;
          --v10;
        }
        while (v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

void re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unsigned int v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    long long v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  BOOL result = re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::ThreadGroupMemorySetting>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v10 = 0;
  re::DynamicArray<re::RenderGraphResourceAllocationManager::TextureIndexAndStage>::add(this, &v10);
  unsigned int v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 8 * *((void *)this + 2) - 8);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::ThreadGroupMemorySetting>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

void re::DynamicArray<re::ThreadGroupMemorySetting>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      long long v5 = (void *)(*(void *)(a1 + 32) + 8 * v4);
      uint64_t v6 = 8 * a2 - 8 * v4;
      if (v6 >= 1) {
        bzero(v5, 8 * (((unint64_t)v6 >> 3) - ((unint64_t)v6 > 7)) + 8);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  BOOL result = re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::MeshResourceDefinition::Level>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::ThreadGroupMemorySetting>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 8 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 8;
        v11 -= 8;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 8 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 8 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::ThreadGroupMemorySetting>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionOptional<re::RenderGraphTargetHandle>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::RenderGraphTargetHandle>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionOptional<re::RenderGraphTargetHandle>::construct(uint64_t a1, unsigned char *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::RenderGraphTargetHandle>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

double re::IntrospectionOptional<re::RenderGraphTargetHandle>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v4[0] = 1;
    uint64_t v5 = 0;
    uint64_t v6 = -1;
  }
  else
  {
    v4[0] = 0;
  }
  return re::Optional<re::RenderGraphTargetHandle>::operator=(a2, v4);
}

uint64_t re::IntrospectionOptional<re::RenderGraphTargetHandle>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

{
  return a2 + 8;
}

double re::Optional<re::RenderGraphTargetHandle>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (*(unsigned char *)a1) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = v2 == 0;
  }
  if (!v3)
  {
    if (*(unsigned char *)a1) {
      BOOL v4 = v2 == 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      *(unsigned char *)a1 = 0;
    }
    else
    {
      if (*(unsigned char *)a1) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v2 == 0;
      }
      if (v5)
      {
        long long v6 = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 8) = v6;
      }
      else
      {
        *(unsigned char *)a1 = 1;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = -1;
        *(void *)(a1 + 8) = *((void *)a2 + 1);
        *(void *)&long long v6 = *((void *)a2 + 2);
        *(void *)(a1 + 16) = v6;
      }
    }
  }
  return *(double *)&v6;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::RenderGraphTargetHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  int v2 = *a1;
  uint64_t result = a1 + 8;
  if (!v2) {
    return 0;
  }
  return result;
}

double re::TypeBuilderHelper::registerOptional<re::RenderGraphTargetHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    v3[0] = 1;
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
  }
  else
  {
    v3[0] = 0;
  }
  return re::Optional<re::RenderGraphTargetHandle>::operator=(a1, v3);
}

void *re::IntrospectionOptional<re::RenderGraphBufferHandle>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::RenderGraphBufferHandle>::~IntrospectionOptional(void *a1)
{
  *a1 = &unk_26E6CB2D8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionOptional<re::RenderGraphBufferHandle>::construct(uint64_t a1, unsigned char *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::RenderGraphBufferHandle>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

double re::IntrospectionOptional<re::RenderGraphBufferHandle>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    v4[0] = 1;
    uint64_t v5 = 0;
    uint64_t v6 = -1;
  }
  else
  {
    v4[0] = 0;
  }
  return re::Optional<re::RenderGraphTargetHandle>::operator=(a2, v4);
}

uint64_t re::IntrospectionOptional<re::RenderGraphBufferHandle>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

{
  return a2 + 8;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::RenderGraphBufferHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  int v2 = *a1;
  uint64_t result = a1 + 8;
  if (!v2) {
    return 0;
  }
  return result;
}

double re::TypeBuilderHelper::registerOptional<re::RenderGraphBufferHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    v3[0] = 1;
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
  }
  else
  {
    v3[0] = 0;
  }
  return re::Optional<re::RenderGraphTargetHandle>::operator=(a1, v3);
}

re::RenderGraphComputeNodeBase *re::RenderGraphComputeNodeBase::RenderGraphComputeNodeBase(re::RenderGraphComputeNodeBase *this)
{
  int v2 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)int v2 = &unk_26E718D28;
  BOOL v3 = (void *)((char *)v2 + 280);
  *((_OWORD *)v2 + 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((_OWORD *)v2 + 18) = 0u;
  *((void *)v2 + 38) = 0;
  re::DynamicString::setCapacity(v3, 0);
  *((unsigned char *)this + 312) = 0;
  *((unsigned char *)this + 336) = 0;
  *((unsigned char *)this + 360) = 0;
  *((unsigned char *)this + 368) = 0;
  *((unsigned char *)this + 400) = 0;
  *((void *)this + 51) = -1;
  *((void *)this + 52) = -1;
  *((void *)this + 53) = -1;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = 0;
  *((_DWORD *)this + 114) = 0;
  *((void *)this + 58) = 0;
  *((void *)this + 59) = 0;
  return this;
}

uint64_t re::DepthStencilSplitterProvider::DepthStencilSplitterProvider(uint64_t a1, const re::DynamicString *a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)&v4, a2);
  *(void *)a1 = &unk_26E6D52C8;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 8), (const re::DynamicString *)&v4);
  if (v4 && (v5 & 1) != 0) {
    (*(void (**)(void))(*(void *)v4 + 40))();
  }
  *(void *)a1 = &unk_26E719040;
  *(void *)(a1 + 40) = 65290051;
  *(void *)(a1 + 48) = "Color";
  *(void *)(a1 + 56) = 65919651;
  *(void *)(a1 + 64) = "Depth";
  *(void *)(a1 + 72) = 0x11F25A259CLL;
  *(void *)(a1 + 80) = "Stencil";
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return a1;
}

void re::DepthStencilSplitterProvider::~DepthStencilSplitterProvider(re::DepthStencilSplitterProvider *this)
{
  *(void *)this = &unk_26E6D52C8;
  re::DynamicString::deinit((re::DepthStencilSplitterProvider *)((char *)this + 8));
}

{
  uint64_t vars8;

  re::DepthStencilSplitterProvider::~DepthStencilSplitterProvider(this);
  JUMPOUT(0x237DBCBD0);
}

unint64_t re::DepthStencilSplitterProvider::prepareFrame(re::DepthStencilSplitterProvider *this, char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v23 = *((void *)this + 7) & 0x7FFFFFFFFFFFFFFFLL;
  signed int ScopePixelFormat = re::RenderFrame::getScopePixelFormat((uint64_t)a4, a3, &v23);
  uint64_t v22 = *((void *)this + 9) & 0x7FFFFFFFFFFFFFFFLL;
  signed int v9 = re::RenderFrame::getScopePixelFormat((uint64_t)a4, a3, &v22);
  size_t v10 = strlen(a2);
  if (v10)
  {
    MurmurHash3_x64_128((uint64_t)a2, v10, 0, &v24);
    unint64_t v11 = (v25 - 0x61C8864680B583E9 + (v24 << 6) + (v24 >> 2)) ^ v24;
  }
  else
  {
    unint64_t v11 = 0;
  }
  size_t v12 = strlen(a3);
  if (v12)
  {
    MurmurHash3_x64_128((uint64_t)a3, v12, 0, &v24);
    unint64_t v13 = ((v25 - 0x61C8864680B583E9 + (v24 << 6) + (v24 >> 2)) ^ v24) - 0x61C8864680B583E9;
  }
  else
  {
    unint64_t v13 = 0x9E3779B97F4A7C17;
  }
  uint64_t v14 = *(unsigned int *)(re::RenderGraphDataStore::get<re::CameraData>((uint64_t)a4 + 32, ((v11 >> 2) + (v11 << 6) + v13) ^ v11)+ 484);
  v21[0] = 0x4C6F466C1137D991;
  v21[1] = (unint64_t)"DepthStencilSplitterProvider";
  unint64_t ScopeHash = re::RenderGraphProviderBase::generateScopeHash(v21, a2, a3);
  unint64_t v16 = 0xBF58476D1CE4E5B9 * (ScopePixelFormat ^ ((unint64_t)ScopePixelFormat >> 30));
  unint64_t v17 = (((0x94D049BB133111EBLL * (v16 ^ (v16 >> 27))) ^ ((0x94D049BB133111EBLL * (v16 ^ (v16 >> 27))) >> 31))
       - 0x61C8864680B583E9
       + (ScopeHash << 6)
       + (ScopeHash >> 2)) ^ ScopeHash;
  unint64_t v18 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v9 ^ ((unint64_t)v9 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                        * (v9 ^ ((unint64_t)v9 >> 30))) >> 27));
  unint64_t v19 = ((v18 ^ (v18 >> 31)) - 0x61C8864680B583E9 + (v17 << 6) + (v17 >> 2)) ^ v17;
  return (v14 - 0x61C8864680B583E9 + (v19 << 6) + (v19 >> 2)) ^ v19;
}

void re::DepthStencilSplitterProvider::provide(re::DepthStencilSplitterProvider *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v28 = *((void *)this + 7) & 0x7FFFFFFFFFFFFFFFLL;
  unsigned int ScopePixelFormat = re::RenderFrame::getScopePixelFormat((uint64_t)a4, a3, &v28);
  unsigned int v29 = ScopePixelFormat;
  uint64_t v26 = *((void *)this + 9) & 0x7FFFFFFFFFFFFFFFLL;
  unsigned int v9 = re::RenderFrame::getScopePixelFormat((uint64_t)a4, a3, &v26);
  unsigned int v27 = v9;
  BOOL v11 = ScopePixelFormat != 250 && ScopePixelFormat != 252;
  BOOL v13 = ScopePixelFormat != 255 && ScopePixelFormat != 260;
  BOOL v15 = v9 != 255 && v9 != 260;
  if (!v13 && !v15)
  {
    BOOL v16 = v9 == 0;
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_0::operator()((uint64_t)this, a3, a4, (int *)&v29, ScopePixelFormat == 0, "DepthStencilBlit");
    unint64_t v17 = this;
    unint64_t v18 = a3;
    unint64_t v19 = a4;
    BOOL v20 = v16;
    uint64_t v21 = "DepthStencilBlit";
LABEL_22:
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_1::operator()((uint64_t)v17, v18, v19, (int *)&v27, v20, v21);
    return;
  }
  char v22 = v9 != 253 || v13;
  if ((v22 & 1) == 0)
  {
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_0::operator()((uint64_t)this, a3, a4, (int *)&v29, ScopePixelFormat == 0, "DepthBlit");
    goto LABEL_46;
  }
  if (v9) {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_0::operator()((uint64_t)this, a3, a4, (int *)&v29, ScopePixelFormat == 0, "DepthBlit");
    return;
  }
  if (!v11 && !v15)
  {
    BOOL v25 = v9 == 0;
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_3::operator()((uint64_t)this, a2, a3, a4, (int *)&v29, ScopePixelFormat == 0);
    uint64_t v21 = "StencilBlit";
    unint64_t v17 = this;
    unint64_t v18 = a3;
    unint64_t v19 = a4;
    BOOL v20 = v25;
    goto LABEL_22;
  }
  if (ScopePixelFormat) {
    LOBYTE(v15) = 1;
  }
  if (!v15)
  {
    BOOL v20 = v9 == 0;
    uint64_t v21 = "StencilBlit";
    unint64_t v17 = this;
    unint64_t v18 = a3;
    unint64_t v19 = a4;
    goto LABEL_22;
  }
  char v23 = v9 != 253 || v11;
  if ((v23 & 1) == 0)
  {
    if (*(unsigned char *)(*((void *)a4 + 1) + 308)) {
      return;
    }
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_3::operator()((uint64_t)this, a2, a3, a4, (int *)&v29, ScopePixelFormat == 0);
LABEL_46:
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_4::operator()((uint64_t)this, a2, a3, a4, (int *)&v27);
    return;
  }
  if (v11 || v9 != 0)
  {
    BOOL v24 = v9 != 253 || ScopePixelFormat != 0;
    if (!v24 && !*(unsigned char *)(*((void *)a4 + 1) + 308)) {
      goto LABEL_46;
    }
  }
  else if (!*(unsigned char *)(*((void *)a4 + 1) + 308))
  {
    re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_3::operator()((uint64_t)this, a2, a3, a4, (int *)&v29, ScopePixelFormat == 0);
  }
}

uint16x4_t re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_0::operator()(uint64_t a1, const char *a2, re::RenderFrame *this, int *a4, int a5, const char *a6)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  size_t v12 = (void *)(a1 + 56);
  re::RenderFrame::tryGetInputTarget(this, *(const char **)(a1 + 64), 0, (double *)&v29);
  uint64_t v27 = 0;
  uint64_t v28 = -1;
  memset(&v32[4], 255, 24);
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&v32[32] = _D0;
  long long v33 = xmmword_2343AEB90;
  long long v34 = xmmword_2343AEBA0;
  int v35 = -1;
  v32[28] = 0;
  long long v36 = xmmword_234378E20;
  char v37 = 0;
  int v18 = *a4;
  LODWORD(v31) = 3;
  HIDWORD(v31) = v18;
  *(_DWORD *)uint64_t v32 = 2;
  if (re::ConstStringID::operator==(v12, re::RenderFrame::kEnvironmentDepthOutputLaneID)) {
    unint64_t v19 = "FinalEnvironmentDepth";
  }
  else {
    unint64_t v19 = "FinalDepth";
  }
  re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v31, v19, &v27);
  uint64_t v20 = 56;
  if (a5) {
    uint64_t v20 = 72;
  }
  uint64_t v26 = *(void *)(a1 + v20) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::inheritLaneProperties(this, &v26, (double *)&v27, 0);
  uint64_t v31 = *(void *)(a1 + 56) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::addTargetOutput(this, &v31, (double *)&v27, 0);
  RenderGraph = (re *)re::RenderFrame::makeRenderGraph(this, a2, 0);
  v22.i64[0] = v30;
  v22.i64[1] = v28;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  uint16x4_t result = (uint16x4_t)vmovn_s32(vceqq_s32(v22, v23));
  result.i16[0] = vmaxv_u16(result);
  if ((result.i8[0] & 1) == 0)
  {
    BOOL v25 = re::RenderGraph::addNode<re::RenderGraphTargetCopyNode>(RenderGraph, a6);
    *((unsigned char *)v25 + 360) = 1;
    uint64_t v31 = v29;
    *(void *)uint64_t v32 = v30;
    *(void *)&v32[8] = 0;
    *(void *)&v32[16] = 2;
    re::DynamicArray<re::TargetRead>::add((re::RenderGraphNode *)((char *)v25 + 176), (__n128 *)&v31);
    uint64_t v31 = v27;
    *(void *)uint64_t v32 = v28;
    *(void *)&v32[8] = 0x400000000;
    *(_OWORD *)&v32[24] = xmmword_23435FBB0;
    LOWORD(v33) = 0;
    *(void *)((char *)&v33 + 4) = 0;
    return (uint16x4_t)re::DynamicArray<re::TargetWrite>::add((re::RenderGraphNode *)((char *)v25 + 216), (uint64_t)&v31).n128_u64[0];
  }
  return result;
}

re *re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_4::operator()(uint64_t a1, const char *a2, const char *a3, re::RenderFrame *this, int *a5)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  unint64_t v10 = 0x9E3779B97F4A7C17;
  re::RenderFrame::tryGetInputTarget(this, *(const char **)(a1 + 80), 0, (double *)&v46);
  size_t v11 = strlen(a2);
  if (v11)
  {
    MurmurHash3_x64_128((uint64_t)a2, v11, 0, &v47);
    unint64_t v12 = (*(void *)v48 - 0x61C8864680B583E9 + (v47 << 6) + (v47 >> 2)) ^ v47;
  }
  else
  {
    unint64_t v12 = 0;
  }
  size_t v13 = strlen(a3);
  if (v13)
  {
    MurmurHash3_x64_128((uint64_t)a3, v13, 0, &v47);
    unint64_t v10 = ((*(void *)v48 - 0x61C8864680B583E9 + (v47 << 6) + (v47 >> 2)) ^ v47) - 0x61C8864680B583E9;
  }
  uint64_t v14 = re::RenderGraphDataStore::tryGet<re::CameraData>((uint64_t)this + 32, ((v12 >> 2) + (v12 << 6) + v10) ^ v12);
  uint64_t v44 = 0;
  int8x8_t v45 = (int8x8_t)-1;
  uint64_t v42 = 0;
  int8x8_t v43 = (int8x8_t)-1;
  *(void *)&v48[4] = -1;
  *(void *)&v48[12] = -1;
  *(void *)int v49 = -1;
  v49[8] = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&v49[12] = _D0;
  long long v50 = xmmword_2343AEB90;
  long long v51 = xmmword_2343AEBA0;
  int v52 = -1;
  long long v53 = xmmword_234378E20;
  char v54 = 0;
  int v20 = *a5;
  LODWORD(v47) = 3;
  HIDWORD(v47) = v20;
  *(_DWORD *)uint64_t v48 = 3;
  re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v47, "FinalStencil", &v44);
  if (*(_DWORD *)(v14 + 484) >= 2u)
  {
    *(_DWORD *)&v48[12] = *(_DWORD *)(v14 + 484);
    *(_DWORD *)uint64_t v48 = 8;
    re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v47, "FinalStencil[MSAA]", &v42);
    v35.n128_u64[0] = *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL;
    re::RenderFrame::addTargetOutput(this, (uint64_t *)&v35, (double *)&v42, 0);
    v41[0] = v44;
    v41[1] = (uint64_t)v45;
    __int32 v21 = v43.i32[0];
    *(_DWORD *)(re::RenderGraphResourceDescriptions::targetDescription((re::RenderFrame *)((char *)this + 3448), v41)
              + 80) = v21;
    v35.n128_u64[0] = *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL;
    re::RenderFrame::inheritLaneProperties(this, (uint64_t *)&v35, (double *)&v42, 0);
  }
  v35.n128_u64[0] = *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::inheritLaneProperties(this, (uint64_t *)&v35, (double *)&v44, 0);
  unint64_t v47 = *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::addTargetOutput(this, (uint64_t *)&v47, (double *)&v44, 0);
  uint16x4_t result = (re *)re::RenderFrame::makeRenderGraph(this, a3, 0);
  v23.i64[0] = *((void *)&v46 + 1);
  v23.u64[1] = (unint64_t)v45;
  v24.i64[0] = -1;
  v24.i64[1] = -1;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32(v23, v24))) & 1) == 0)
  {
    uint64_t v25 = *(void *)(a1 + 120);
    if (v25)
    {
      unsigned int v26 = atomic_load((unsigned int *)(v25 + 704));
      if (v26 == 2)
      {
        uint64_t v27 = result;
        uint64_t v28 = (uint64_t *)(a1 + 112);
        uint64_t v29 = re::RenderGraph::addNode<re::RenderGraphFullscreenNode>(result, "StencilCopy");
        re::AssetHandle::operator=((uint64_t)v29 + 264, v28);
        unint64_t v47 = (unint64_t)"fullscreenarray";
        *(void *)uint64_t v48 = 15;
        uint64_t v30 = re::DynamicString::operator=((re::RenderGraphFullscreenNode *)((char *)v29 + 288), (uint64_t)&v47);
        v35.n128_u64[1] = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        re::DynamicString::setCapacity(&v35, 0);
        *(void *)&long long v38 = 0;
        *((void *)&v38 + 1) = -1;
        __int16 v39 = 0;
        char v40 = 0;
        unint64_t v47 = (unint64_t)"inputImage";
        *(void *)uint64_t v48 = 10;
        re::DynamicString::operator=((re::DynamicString *)&v35, (uint64_t)&v47);
        long long v38 = v46;
        char v40 = 1;
        LOBYTE(v39) = 1;
        re::RenderGraphFullscreenNode::setRenderGraphTextureCommand((uint64_t)v29, &v35);
        unsigned int v31 = *(_DWORD *)(v14 + 484) > 1u;
        uint64_t v32 = (unint64_t *)&v44;
        if (*(_DWORD *)(v14 + 484) > 1u) {
          uint64_t v32 = (unint64_t *)&v42;
        }
        unint64_t v47 = *v32;
        *(int8x8_t *)uint64_t v48 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v31), 0x1FuLL)), v43, v45);
        *(void *)&v48[8] = 0x300000000;
        *(_OWORD *)&unsigned char v49[4] = xmmword_23435FBB0;
        LOWORD(v50) = 0;
        *(void *)((char *)&v50 + 4) = 0;
        __n128 v33 = re::DynamicArray<re::TargetWrite>::add((re::RenderGraphFullscreenNode *)((char *)v29 + 216), (uint64_t)&v47);
        (*(void (**)(re::RenderGraphFullscreenNode *, const char *, const char *, re::RenderFrame *, __n128))(*(void *)v29 + 80))(v29, a2, a3, this, v33);
        if (*(_DWORD *)(v14 + 484) >= 2u)
        {
          long long v34 = re::RenderGraph::addNode<re::RenderGraphResolveNode>(v27, "StencilResolve");
          unint64_t v47 = v44;
          *(int8x8_t *)uint64_t v48 = v45;
          *(void *)&v48[8] = 0x800000000;
          *(_OWORD *)&unsigned char v49[4] = xmmword_23435FBB0;
          LOWORD(v50) = 0;
          *(void *)((char *)&v50 + 4) = 0;
          re::DynamicArray<re::TargetWrite>::add((re::RenderGraphNode *)((char *)v34 + 216), (uint64_t)&v47);
          re::RenderGraphResolveNode::configure(v34, a2, a3, this);
        }
        uint16x4_t result = (re *)v35.n128_u64[0];
        if (v35.n128_u64[0])
        {
          if (v35.n128_u8[8]) {
            return (re *)(*(uint64_t (**)(void))(*(void *)v35.n128_u64[0] + 40))();
          }
        }
      }
    }
  }
  return result;
}

re *re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_3::operator()(uint64_t a1, const char *a2, const char *a3, re::RenderFrame *this, int *a5, int a6)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  unint64_t v12 = 0x9E3779B97F4A7C17;
  re::RenderFrame::tryGetInputTarget(this, *(const char **)(a1 + 64), 0, (double *)&v50);
  size_t v13 = strlen(a2);
  if (v13)
  {
    MurmurHash3_x64_128((uint64_t)a2, v13, 0, &v51);
    unint64_t v14 = (*(void *)v52 - 0x61C8864680B583E9 + (v51 << 6) + (v51 >> 2)) ^ v51;
  }
  else
  {
    unint64_t v14 = 0;
  }
  size_t v15 = strlen(a3);
  if (v15)
  {
    MurmurHash3_x64_128((uint64_t)a3, v15, 0, &v51);
    unint64_t v12 = ((*(void *)v52 - 0x61C8864680B583E9 + (v51 << 6) + (v51 >> 2)) ^ v51) - 0x61C8864680B583E9;
  }
  uint64_t v16 = re::RenderGraphDataStore::tryGet<re::CameraData>((uint64_t)this + 32, ((v14 >> 2) + (v14 << 6) + v12) ^ v14);
  uint64_t v48 = 0;
  int8x8_t v49 = (int8x8_t)-1;
  uint64_t v46 = 0;
  int8x8_t v47 = (int8x8_t)-1;
  *(void *)&v52[4] = -1;
  *(void *)&v52[12] = -1;
  *(void *)long long v53 = -1;
  v53[8] = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&v53[12] = _D0;
  long long v54 = xmmword_2343AEB90;
  long long v55 = xmmword_2343AEBA0;
  int v56 = -1;
  long long v57 = xmmword_234378E20;
  char v58 = 0;
  int v22 = *a5;
  LODWORD(v51) = 3;
  HIDWORD(v51) = v22;
  *(_DWORD *)int v52 = 3;
  re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v51, "FinalDepth", &v48);
  if (*(_DWORD *)(v16 + 484) >= 2u)
  {
    *(_DWORD *)&v52[12] = *(_DWORD *)(v16 + 484);
    *(_DWORD *)int v52 = 8;
    re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v51, "FinalDepth[MSAA]", &v46);
    v39.n128_u64[0] = *(void *)(a1 + 56) & 0x7FFFFFFFFFFFFFFFLL;
    re::RenderFrame::addTargetOutput(this, (uint64_t *)&v39, (double *)&v46, 0);
    v45[0] = v48;
    v45[1] = (uint64_t)v49;
    __int32 v23 = v47.i32[0];
    *(_DWORD *)(re::RenderGraphResourceDescriptions::targetDescription((re::RenderFrame *)((char *)this + 3448), v45)
              + 80) = v23;
    uint64_t v24 = 56;
    if (a6) {
      uint64_t v24 = 72;
    }
    v39.n128_u64[0] = *(void *)(a1 + v24) & 0x7FFFFFFFFFFFFFFFLL;
    re::RenderFrame::inheritLaneProperties(this, (uint64_t *)&v39, (double *)&v46, 0);
  }
  uint64_t v25 = 56;
  if (a6) {
    uint64_t v25 = 72;
  }
  v39.n128_u64[0] = *(void *)(a1 + v25) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::inheritLaneProperties(this, (uint64_t *)&v39, (double *)&v48, 0);
  unint64_t v51 = *(void *)(a1 + 56) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::addTargetOutput(this, (uint64_t *)&v51, (double *)&v48, 0);
  uint16x4_t result = (re *)re::RenderFrame::makeRenderGraph(this, a3, 0);
  v27.i64[0] = *((void *)&v50 + 1);
  v27.u64[1] = (unint64_t)v49;
  v28.i64[0] = -1;
  v28.i64[1] = -1;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32(v27, v28))) & 1) == 0)
  {
    uint64_t v29 = *(void *)(a1 + 96);
    if (v29)
    {
      unsigned int v30 = atomic_load((unsigned int *)(v29 + 704));
      if (v30 == 2)
      {
        unsigned int v31 = result;
        uint64_t v32 = (uint64_t *)(a1 + 88);
        __n128 v33 = re::RenderGraph::addNode<re::RenderGraphFullscreenNode>(result, "DepthCopy");
        re::AssetHandle::operator=((uint64_t)v33 + 264, v32);
        unint64_t v51 = (unint64_t)"fullscreenarray";
        *(void *)int v52 = 15;
        long long v34 = re::DynamicString::operator=((re::RenderGraphFullscreenNode *)((char *)v33 + 288), (uint64_t)&v51);
        v39.n128_u64[1] = 0;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        re::DynamicString::setCapacity(&v39, 0);
        *(void *)&long long v42 = 0;
        *((void *)&v42 + 1) = -1;
        __int16 v43 = 0;
        char v44 = 0;
        unint64_t v51 = (unint64_t)"inputImage";
        *(void *)int v52 = 10;
        re::DynamicString::operator=((re::DynamicString *)&v39, (uint64_t)&v51);
        long long v42 = v50;
        char v44 = 1;
        LOBYTE(v43) = 0;
        re::RenderGraphFullscreenNode::setRenderGraphTextureCommand((uint64_t)v33, &v39);
        unsigned int v35 = *(_DWORD *)(v16 + 484) > 1u;
        uint64_t v36 = (unint64_t *)&v48;
        if (*(_DWORD *)(v16 + 484) > 1u) {
          uint64_t v36 = (unint64_t *)&v46;
        }
        unint64_t v51 = *v36;
        *(int8x8_t *)int v52 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v35), 0x1FuLL)), v47, v49);
        *(void *)&v52[8] = 0x200000000;
        *(_OWORD *)&unsigned char v53[4] = xmmword_23435FBB0;
        LOWORD(v54) = 0;
        *(void *)((char *)&v54 + 4) = 0;
        __n128 v37 = re::DynamicArray<re::TargetWrite>::add((re::RenderGraphFullscreenNode *)((char *)v33 + 216), (uint64_t)&v51);
        (*(void (**)(re::RenderGraphFullscreenNode *, const char *, const char *, re::RenderFrame *, __n128))(*(void *)v33 + 80))(v33, a2, a3, this, v37);
        if (*(_DWORD *)(v16 + 484) >= 2u)
        {
          long long v38 = re::RenderGraph::addNode<re::RenderGraphResolveNode>(v31, "DepthResolve");
          unint64_t v51 = v48;
          *(int8x8_t *)int v52 = v49;
          *(void *)&v52[8] = 0x700000000;
          *(_OWORD *)&unsigned char v53[4] = xmmword_23435FBB0;
          LOWORD(v54) = 0;
          *(void *)((char *)&v54 + 4) = 0;
          re::DynamicArray<re::TargetWrite>::add((re::RenderGraphNode *)((char *)v38 + 216), (uint64_t)&v51);
          re::RenderGraphResolveNode::configure(v38, a2, a3, this);
        }
        uint16x4_t result = (re *)v39.n128_u64[0];
        if (v39.n128_u64[0])
        {
          if (v39.n128_u8[8]) {
            return (re *)(*(uint64_t (**)(void))(*(void *)v39.n128_u64[0] + 40))();
          }
        }
      }
    }
  }
  return result;
}

uint16x4_t re::DepthStencilSplitterProvider::provide(char const*,char const*,re::RenderFrame &)const::$_1::operator()(uint64_t a1, const char *a2, re::RenderFrame *this, int *a4, int a5, const char *a6)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v12 = (void *)(a1 + 72);
  re::RenderFrame::tryGetInputTarget(this, *(const char **)(a1 + 80), 0, (double *)&v29);
  uint64_t v27 = 0;
  uint64_t v28 = -1;
  memset(&v32[4], 255, 24);
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&v32[32] = _D0;
  long long v33 = xmmword_2343AEB90;
  long long v34 = xmmword_2343AEBA0;
  int v35 = -1;
  v32[28] = 0;
  long long v36 = xmmword_234378E20;
  char v37 = 0;
  int v18 = *a4;
  LODWORD(v31) = 3;
  HIDWORD(v31) = v18;
  *(_DWORD *)uint64_t v32 = 2;
  if (re::ConstStringID::operator==(v12, re::RenderFrame::kEnvironmentStencilOutputLaneID)) {
    unint64_t v19 = "FinalEnvironmentStencil";
  }
  else {
    unint64_t v19 = "FinalStencil";
  }
  re::RenderFrame::createTarget(this, (const re::RenderGraphTargetDescription *)&v31, v19, &v27);
  uint64_t v20 = 72;
  if (a5) {
    uint64_t v20 = 56;
  }
  uint64_t v26 = *(void *)(a1 + v20) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::inheritLaneProperties(this, &v26, (double *)&v27, 0);
  uint64_t v31 = *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::addTargetOutput(this, &v31, (double *)&v27, 0);
  RenderGraph = (re *)re::RenderFrame::makeRenderGraph(this, a2, 0);
  v22.i64[0] = v30;
  v22.i64[1] = v28;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  uint16x4_t result = (uint16x4_t)vmovn_s32(vceqq_s32(v22, v23));
  result.i16[0] = vmaxv_u16(result);
  if ((result.i8[0] & 1) == 0)
  {
    uint64_t v25 = re::RenderGraph::addNode<re::RenderGraphTargetCopyNode>(RenderGraph, a6);
    *((unsigned char *)v25 + 360) = 1;
    uint64_t v31 = v29;
    *(void *)uint64_t v32 = v30;
    *(_DWORD *)&v32[8] = 0;
    *(_WORD *)&v32[12] = 256;
    v32[14] = 0;
    *(void *)&v32[16] = 2;
    re::DynamicArray<re::TargetRead>::add((re::RenderGraphNode *)((char *)v25 + 176), (__n128 *)&v31);
    uint64_t v31 = v27;
    *(void *)uint64_t v32 = v28;
    *(void *)&v32[8] = 0x400000000;
    *(_OWORD *)&v32[24] = xmmword_23435FBB0;
    LOWORD(v33) = 0;
    *(void *)((char *)&v33 + 4) = 0;
    return (uint16x4_t)re::DynamicArray<re::TargetWrite>::add((re::RenderGraphNode *)((char *)v25 + 216), (uint64_t)&v31).n128_u64[0];
  }
  return result;
}

uint64_t re::RealityDataPipe::RealityDataPipe(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E719088;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 1;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 0;
  re::BucketArray<re::DynamicArray<re::RenderProfilerText>,4ul>::init(a1 + 72, a2, 1uLL);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 1;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_DWORD *)(a1 + 200) = 1;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 256) = 1;
  *(_DWORD *)(a1 + 288) = 0;
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_DWORD *)(a1 + 312) = 1;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_DWORD *)(a1 + 344) = 0;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_DWORD *)(a1 + 368) = 1;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 424) = 1;
  *(void *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1;
  *(void *)(a1 + 504) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_DWORD *)(a1 + 536) = 1;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_DWORD *)(a1 + 568) = 0;
  *(void *)(a1 + 560) = 0;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_DWORD *)(a1 + 592) = 1;
  *(_DWORD *)(a1 + 624) = 0;
  *(void *)(a1 + 616) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_DWORD *)(a1 + 648) = 1;
  *(_DWORD *)(a1 + 680) = 0;
  *(void *)(a1 + 672) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_DWORD *)(a1 + 704) = 1;
  *(_DWORD *)(a1 + 736) = 0;
  *(void *)(a1 + 728) = 0;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_DWORD *)(a1 + 760) = 1;
  *(_DWORD *)(a1 + 792) = 0;
  *(void *)(a1 + 784) = 0;
  *(_OWORD *)(a1 + 768) = 0u;
  re::BucketArray<re::BlurPlanesRenderFrameData,4ul>::init(a1 + 744, a2, 1uLL);
  *(_OWORD *)(a1 + 800) = 0u;
  *(_DWORD *)(a1 + 816) = 1;
  *(void *)(a1 + 824) = 0;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_DWORD *)(a1 + 848) = 0;
  re::BucketArray<re::TintContext,4ul>::init(a1 + 800, a2, 1uLL);
  *(_OWORD *)(a1 + 856) = 0u;
  *(_DWORD *)(a1 + 872) = 1;
  *(void *)(a1 + 880) = 0;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_DWORD *)(a1 + 904) = 0;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_DWORD *)(a1 + 928) = 1;
  *(void *)(a1 + 936) = 0;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_DWORD *)(a1 + 960) = 0;
  re::BucketArray<re::MeshSceneCollection,4ul>::init(a1 + 912, a2, 1uLL);
  *(_OWORD *)(a1 + 968) = 0u;
  *(_DWORD *)(a1 + 984) = 1;
  *(void *)(a1 + 992) = 0;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_DWORD *)(a1 + 1016) = 0;
  re::BucketArray<re::MeshDeformationCollection,4ul>::init(a1 + 968, a2, 1uLL);
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_DWORD *)(a1 + 1040) = 1;
  *(void *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_DWORD *)(a1 + 1072) = 0;
  *(_OWORD *)(a1 + 1080) = 0u;
  *(_DWORD *)(a1 + 1096) = 1;
  *(void *)(a1 + 1104) = 0;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_DWORD *)(a1 + 1152) = 1;
  *(_OWORD *)(a1 + 1160) = 0u;
  *(_DWORD *)(a1 + 1184) = 0;
  *(void *)(a1 + 1176) = 0;
  re::BucketArray<re::StaticTextInfo,4ul>::init(a1 + 1136, a2, 1uLL);
  *(_OWORD *)(a1 + 1192) = 0u;
  *(_DWORD *)(a1 + 1208) = 1;
  *(void *)(a1 + 1216) = 0;
  *(_OWORD *)(a1 + 1224) = 0u;
  *(_DWORD *)(a1 + 1240) = 0;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_DWORD *)(a1 + 1264) = 1;
  *(void *)(a1 + 1272) = 0;
  *(_OWORD *)(a1 + 1280) = 0u;
  *(_DWORD *)(a1 + 1296) = 0;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_DWORD *)(a1 + 1320) = 1;
  *(_OWORD *)(a1 + 1328) = 0u;
  *(_DWORD *)(a1 + 1352) = 0;
  *(void *)(a1 + 1344) = 0;
  *(_OWORD *)(a1 + 1360) = 0u;
  *(_DWORD *)(a1 + 1376) = 1;
  *(_OWORD *)(a1 + 1384) = 0u;
  *(_DWORD *)(a1 + 1408) = 0;
  *(void *)(a1 + 1400) = 0;
  *(_OWORD *)(a1 + 1416) = 0u;
  *(_DWORD *)(a1 + 1432) = 1;
  *(void *)(a1 + 1456) = 0;
  *(_DWORD *)(a1 + 1464) = 0;
  *(_OWORD *)(a1 + 1440) = 0u;
  re::BucketArray<re::FilterViewMeshScenes,4ul>::init(a1 + 1416, a2, 1uLL);
  *(_OWORD *)(a1 + 1472) = 0u;
  *(_DWORD *)(a1 + 1488) = 1;
  *(void *)(a1 + 1496) = 0;
  *(_OWORD *)(a1 + 1504) = 0u;
  *(_DWORD *)(a1 + 1520) = 0;
  *(_OWORD *)(a1 + 1528) = 0u;
  *(_DWORD *)(a1 + 1544) = 1;
  *(void *)(a1 + 1552) = 0;
  *(_OWORD *)(a1 + 1560) = 0u;
  *(_DWORD *)(a1 + 1576) = 0;
  re::BucketArray<re::SceneCRWSReferencePosition,4ul>::init(a1 + 1528, a2, 1uLL);
  *(_OWORD *)(a1 + 1584) = 0u;
  *(_DWORD *)(a1 + 1600) = 1;
  *(void *)(a1 + 1608) = 0;
  *(_OWORD *)(a1 + 1616) = 0u;
  *(_DWORD *)(a1 + 1632) = 0;
  *(_OWORD *)(a1 + 1640) = 0u;
  *(_DWORD *)(a1 + 1656) = 1;
  *(void *)(a1 + 1664) = 0;
  *(_OWORD *)(a1 + 1672) = 0u;
  *(_DWORD *)(a1 + 1688) = 0;
  re::BucketArray<re::MeshSortingCollection,4ul>::init(a1 + 1640, a2, 1uLL);
  *(_OWORD *)(a1 + 1696) = 0u;
  *(_DWORD *)(a1 + 1712) = 1;
  *(void *)(a1 + 1720) = 0;
  *(_OWORD *)(a1 + 1728) = 0u;
  *(_DWORD *)(a1 + 1744) = 0;
  *(_OWORD *)(a1 + 1752) = 0u;
  *(_DWORD *)(a1 + 1768) = 1;
  *(void *)(a1 + 1776) = 0;
  *(_OWORD *)(a1 + 1784) = 0u;
  *(_DWORD *)(a1 + 1800) = 0;
  *(_OWORD *)(a1 + 1808) = 0u;
  *(_DWORD *)(a1 + 1824) = 1;
  *(_OWORD *)(a1 + 1832) = 0u;
  *(_DWORD *)(a1 + 1856) = 0;
  *(void *)(a1 + 1848) = 0;
  *(_OWORD *)(a1 + 1864) = 0u;
  *(_DWORD *)(a1 + 1880) = 1;
  *(void *)(a1 + 1896) = 0;
  *(void *)(a1 + 1888) = 0;
  *(_DWORD *)(a1 + 1912) = 0;
  *(void *)(a1 + 1904) = 0;
  return a1;
}

void re::RealityDataPipe::~RealityDataPipe(re::RealityDataPipe *this)
{
  *(void *)this = &unk_26E719088;
  int v2 = (uint64_t *)((char *)this + 1864);
  uint64_t v3 = *((void *)this + 238);
  if (v3)
  {
    for (unint64_t i = 0; i != v3; ++i)
    {
      uint64_t v5 = re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::operator[]((uint64_t)v2, i);
      re::DynamicArray<re::VirtualEnvironmentProbeSource>::deinit(v5);
    }
  }
  while (*((void *)this + 234))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  *((void *)this + 238) = 0;
  ++*((_DWORD *)this + 478);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  uint64_t v6 = *((void *)this + 231);
  if (v6)
  {
    for (unint64_t j = 0; j != v6; ++j)
    {
      uint64_t v8 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1808, j);
      re::DynamicArray<unsigned long>::deinit(v8);
    }
  }
  while (*((void *)this + 227))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 226);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1808);
  *((void *)this + 231) = 0;
  ++*((_DWORD *)this + 464);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1808);
  uint64_t v9 = *((void *)this + 224);
  if (v9)
  {
    for (unint64_t k = 0; k != v9; ++k)
    {
      uint64_t v11 = re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)this + 1752, k);
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(v11 + 8));
    }
  }
  while (*((void *)this + 220))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 219);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1752);
  *((void *)this + 224) = 0;
  ++*((_DWORD *)this + 450);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1752);
  uint64_t v12 = *((void *)this + 217);
  if (v12)
  {
    for (unint64_t m = 0; m != v12; ++m)
      re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::operator[]((uint64_t)this + 1696, m);
  }
  while (*((void *)this + 213))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 212);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1696);
  *((void *)this + 217) = 0;
  ++*((_DWORD *)this + 436);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1696);
  uint64_t v14 = *((void *)this + 210);
  if (v14)
  {
    for (unint64_t n = 0; n != v14; ++n)
    {
      uint64_t v16 = (uint64_t *)re::BucketArray<re::MeshSortingCollection,4ul>::operator[]((uint64_t)this + 1640, n);
      re::HashTable<re::ecs2::Entity const*,re::ecs2::BillboardData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::deinit(v16 + 18);
      re::HashTable<unsigned long long,re::MeshSortingCollection::GroupData,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v16 + 12);
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit(v16 + 6);
      re::HashTable<unsigned long long,re::MeshSortingCollection::EntitySortingData,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v16);
    }
  }
  while (*((void *)this + 206))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 205);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1640);
  *((void *)this + 210) = 0;
  ++*((_DWORD *)this + 422);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1640);
  uint64_t v17 = *((void *)this + 203);
  if (v17)
  {
    for (iunint64_t i = 0; ii != v17; ++ii)
    {
      uint64_t v19 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1584, ii);
      re::DynamicArray<re::PlanarReflectionData>::deinit(v19);
    }
  }
  while (*((void *)this + 199))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 198);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1584);
  *((void *)this + 203) = 0;
  ++*((_DWORD *)this + 408);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1584);
  uint64_t v20 = *((void *)this + 196);
  if (v20)
  {
    for (junint64_t j = 0; jj != v20; ++jj)
      re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 1528, jj);
  }
  while (*((void *)this + 192))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 191);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1528);
  *((void *)this + 196) = 0;
  ++*((_DWORD *)this + 394);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1528);
  uint64_t v22 = *((void *)this + 189);
  if (v22)
  {
    for (kunint64_t k = 0; kk != v22; ++kk)
      re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::operator[]((uint64_t)this + 1472, kk);
  }
  while (*((void *)this + 185))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 184);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1472);
  *((void *)this + 189) = 0;
  ++*((_DWORD *)this + 380);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1472);
  uint64_t v24 = *((void *)this + 182);
  if (v24)
  {
    for (munint64_t m = 0; mm != v24; ++mm)
    {
      uint64_t v26 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1416, mm);
      re::DynamicArray<re::MeshScene>::deinit(v26);
    }
  }
  while (*((void *)this + 178))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 177);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1416);
  *((void *)this + 182) = 0;
  ++*((_DWORD *)this + 366);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1416);
  uint64_t v27 = *((void *)this + 175);
  if (v27)
  {
    for (nunint64_t n = 0; nn != v27; ++nn)
    {
      uint64_t v29 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1360, nn);
      re::DynamicArray<re::StencilPortal>::deinit(v29);
    }
  }
  while (*((void *)this + 171))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 170);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1360);
  *((void *)this + 175) = 0;
  ++*((_DWORD *)this + 352);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1360);
  uint64_t v30 = *((void *)this + 168);
  if (v30)
  {
    for (unint64_t i1 = 0; i1 != v30; ++i1)
    {
      uint64_t v32 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1304, i1);
      re::DynamicArray<re::RenderGraphFileProvider>::deinit(v32);
    }
  }
  while (*((void *)this + 164))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 163);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1304);
  *((void *)this + 168) = 0;
  ++*((_DWORD *)this + 338);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1304);
  re::BucketArray<re::DynamicArray<re::VFXScene>,4ul>::deinit((uint64_t)this + 1248);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1248);
  uint64_t v33 = *((void *)this + 154);
  if (v33)
  {
    for (unint64_t i2 = 0; i2 != v33; ++i2)
    {
      uint64_t v35 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1192, i2);
      re::DynamicArray<re::RenderText>::deinit(v35);
    }
  }
  while (*((void *)this + 150))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 149);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1192);
  *((void *)this + 154) = 0;
  ++*((_DWORD *)this + 310);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1192);
  uint64_t v36 = *((void *)this + 147);
  if (v36)
  {
    for (unint64_t i3 = 0; i3 != v36; ++i3)
      re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 1136, i3);
  }
  while (*((void *)this + 143))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 142);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1136);
  *((void *)this + 147) = 0;
  ++*((_DWORD *)this + 296);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1136);
  uint64_t v38 = *((void *)this + 140);
  if (v38)
  {
    for (unint64_t i4 = 0; i4 != v38; ++i4)
    {
      uint64_t v40 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1080, i4);
      re::DynamicArray<re::CameraMultiView>::deinit(v40);
    }
  }
  while (*((void *)this + 136))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 135);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1080);
  *((void *)this + 140) = 0;
  ++*((_DWORD *)this + 282);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1080);
  uint64_t v41 = *((void *)this + 133);
  if (v41)
  {
    for (unint64_t i5 = 0; i5 != v41; ++i5)
    {
      uint64_t v43 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1024, i5);
      re::DynamicArray<re::CameraView>::deinit(v43);
    }
  }
  while (*((void *)this + 129))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 128);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1024);
  *((void *)this + 133) = 0;
  ++*((_DWORD *)this + 268);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1024);
  re::BucketArray<re::MeshDeformationCollection,4ul>::deinit((uint64_t)this + 968);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 968);
  uint64_t v44 = *((void *)this + 119);
  if (v44)
  {
    for (unint64_t i6 = 0; i6 != v44; ++i6)
    {
      uint64_t v46 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 912, i6);
      re::DynamicArray<re::MeshScene>::deinit(v46);
    }
  }
  while (*((void *)this + 115))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 114);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 912);
  *((void *)this + 119) = 0;
  ++*((_DWORD *)this + 240);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 912);
  uint64_t v47 = *((void *)this + 112);
  if (v47)
  {
    for (unint64_t i7 = 0; i7 != v47; ++i7)
    {
      uint64_t v49 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 856, i7);
      re::StringID::destroyString((re::StringID *)(v49 + 8));
    }
  }
  while (*((void *)this + 108))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 107);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 856);
  *((void *)this + 112) = 0;
  ++*((_DWORD *)this + 226);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 856);
  uint64_t v50 = *((void *)this + 105);
  if (v50)
  {
    for (unint64_t i8 = 0; i8 != v50; ++i8)
      re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[]((uint64_t)this + 800, i8);
  }
  while (*((void *)this + 101))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 100);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 800);
  *((void *)this + 105) = 0;
  ++*((_DWORD *)this + 212);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 800);
  uint64_t v52 = *((void *)this + 98);
  if (v52)
  {
    for (unint64_t i9 = 0; i9 != v52; ++i9)
    {
      uint64_t v54 = re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::operator[]((uint64_t)this + 744, i9);
      re::DynamicArray<unsigned long>::deinit(v54 + 40);
      re::DynamicArray<unsigned long>::deinit(v54);
    }
  }
  while (*((void *)this + 94))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 93);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 744);
  *((void *)this + 98) = 0;
  ++*((_DWORD *)this + 198);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 744);
  uint64_t v55 = *((void *)this + 91);
  if (v55)
  {
    for (unint64_t i10 = 0; i10 != v55; ++i10)
    {
      uint64_t v57 = re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)this + 688, i10);
      char v58 = *(void **)(v57 + 40);
      if (v58)
      {

        *(void *)(v57 + 40) = 0;
      }
      re::DynamicArray<re::IBL>::deinit(v57);
    }
  }
  while (*((void *)this + 87))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 86);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 688);
  *((void *)this + 91) = 0;
  ++*((_DWORD *)this + 184);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 688);
  uint64_t v59 = *((void *)this + 84);
  if (v59)
  {
    for (unint64_t i11 = 0; i11 != v59; ++i11)
    {
      uint64_t v61 = re::BucketArray<re::MeshScene,4ul>::operator[]((uint64_t)this + 632, i11);
      re::HashTable<unsigned long long,re::HashSet<re::ecs2::Entity *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(v61 + 368));
      re::DynamicArray<unsigned long>::deinit(v61 + 328);
      re::DynamicArray<unsigned long>::deinit(v61 + 288);
      re::DynamicArray<re::MeshCasterReceiverWorldUpdateInfo>::deinit(v61 + 248);
      re::DynamicArray<re::MeshCasterReceiverWorldUpdateInfo>::deinit(v61 + 208);
      re::DynamicArray<unsigned long>::deinit(v61 + 168);
      re::DynamicArray<re::MeshShadowCluster>::deinit(v61 + 128);
      re::DynamicArray<unsigned long>::deinit(v61 + 88);
      re::DynamicArray<unsigned long>::deinit(v61 + 48);
      re::DynamicArray<unsigned long>::deinit(v61 + 8);
    }
  }
  while (*((void *)this + 80))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 79);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 632);
  *((void *)this + 84) = 0;
  ++*((_DWORD *)this + 170);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 632);
  uint64_t v62 = *((void *)this + 77);
  if (v62)
  {
    for (unint64_t i12 = 0; i12 != v62; ++i12)
    {
      uint64_t v64 = re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::operator[]((uint64_t)this + 576, i12);
      uint64_t v65 = (void *)v64;
      if (*(unsigned char *)(v64 + 56)) {
        re::StringID::destroyString((re::StringID *)(v64 + 64));
      }
      uint64_t v66 = v65[5];
      if (v66)
      {

        v65[5] = 0;
      }
      uint64_t v67 = v65[4];
      if (v67)
      {

        v65[4] = 0;
      }
      uint64_t v68 = v65[3];
      if (v68)
      {

        v65[3] = 0;
      }
    }
  }
  while (*((void *)this + 73))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 72);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 576);
  *((void *)this + 77) = 0;
  ++*((_DWORD *)this + 156);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 576);
  uint64_t v69 = *((void *)this + 70);
  if (v69)
  {
    for (unint64_t i13 = 0; i13 != v69; ++i13)
      re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::operator[]((uint64_t)this + 520, i13);
  }
  while (*((void *)this + 66))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 65);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 520);
  *((void *)this + 70) = 0;
  ++*((_DWORD *)this + 142);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 520);
  uint64_t v71 = *((void *)this + 63);
  if (v71)
  {
    for (unint64_t i14 = 0; i14 != v71; ++i14)
    {
      uint64_t v73 = re::BucketArray<re::OpenSkyData,4ul>::operator[]((uint64_t)this + 464, i14);
      re::DynamicArray<unsigned long>::deinit(v73 + 128);
      re::DynamicArray<unsigned long>::deinit(v73 + 88);
    }
  }
  while (*((void *)this + 59))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 58);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 464);
  *((void *)this + 63) = 0;
  ++*((_DWORD *)this + 128);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 464);
  uint64_t v74 = *((void *)this + 56);
  if (v74)
  {
    for (unint64_t i15 = 0; i15 != v74; ++i15)
      re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[]((uint64_t)this + 408, i15);
  }
  while (*((void *)this + 52))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 51);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 408);
  *((void *)this + 56) = 0;
  ++*((_DWORD *)this + 114);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 408);
  uint64_t v76 = *((void *)this + 49);
  if (v76)
  {
    for (unint64_t i16 = 0; i16 != v76; ++i16)
    {
      uint64_t v78 = re::BucketArray<re::CameraStreamContext,4ul>::operator[]((uint64_t)this + 352, i16);
      long long v79 = *(void **)(v78 + 1824);
      if (v79)
      {

        *(void *)(v78 + 1824) = 0;
      }
      int v80 = *(void **)(v78 + 1816);
      if (v80)
      {

        *(void *)(v78 + 1816) = 0;
      }
      re::SmallHashTable<re::WeakStringID,re::CameraStreamParams,4ul,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false>::~SmallHashTable(v78);
    }
  }
  while (*((void *)this + 45))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 44);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 352);
  *((void *)this + 49) = 0;
  ++*((_DWORD *)this + 100);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 352);
  uint64_t v81 = *((void *)this + 42);
  if (v81)
  {
    for (unint64_t i17 = 0; i17 != v81; ++i17)
    {
      uint64_t v83 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 296, i17);
      re::DynamicArray<re::VirtualEnvironmentProbeSource>::deinit(v83);
    }
  }
  while (*((void *)this + 38))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 37);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 296);
  *((void *)this + 42) = 0;
  ++*((_DWORD *)this + 86);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 296);
  uint64_t v84 = *((void *)this + 35);
  if (v84)
  {
    for (unint64_t i18 = 0; i18 != v84; ++i18)
    {
      uint64_t v86 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 240, i18);
      uint64_t v87 = *(void **)(v86 + 16);
      if (v87)
      {

        *(void *)(v86 + 16) = 0;
      }
      long long v88 = *(void **)(v86 + 8);
      if (v88)
      {

        *(void *)(v86 + 8) = 0;
      }
      if (*(void *)v86)
      {

        *(void *)uint64_t v86 = 0;
      }
    }
  }
  while (*((void *)this + 31))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 30);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 240);
  *((void *)this + 35) = 0;
  ++*((_DWORD *)this + 72);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 240);
  uint64_t v89 = *((void *)this + 28);
  if (v89)
  {
    for (unint64_t i19 = 0; i19 != v89; ++i19)
      re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 184, i19);
  }
  while (*((void *)this + 24))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 23);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 184);
  *((void *)this + 28) = 0;
  ++*((_DWORD *)this + 58);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 184);
  uint64_t v91 = *((void *)this + 21);
  if (v91)
  {
    for (unint64_t i20 = 0; i20 != v91; ++i20)
      re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 128, i20);
  }
  while (*((void *)this + 17))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 16);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 128);
  *((void *)this + 21) = 0;
  ++*((_DWORD *)this + 44);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 128);
  uint64_t v93 = *((void *)this + 14);
  if (v93)
  {
    for (unint64_t i21 = 0; i21 != v93; ++i21)
    {
      uint64_t v95 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 72, i21);
      re::DynamicArray<re::RenderText>::deinit(v95);
    }
  }
  while (*((void *)this + 10))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 9);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 72);
  *((void *)this + 14) = 0;
  ++*((_DWORD *)this + 30);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 72);
  uint64_t v96 = *((void *)this + 7);
  if (v96)
  {
    for (unint64_t i22 = 0; i22 != v96; ++i22)
    {
      uint64_t v98 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 16, i22);
      re::DynamicArray<NS::SharedPtr<MTL::SamplerState>>::deinit(v98);
    }
  }
  while (*((void *)this + 3))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 16);
  *((void *)this + 7) = 0;
  ++*((_DWORD *)this + 16);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 16);
}

{
  uint64_t vars8;

  re::RealityDataPipe::~RealityDataPipe(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RealityDataPipe::addMipmapGenerationContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 16;
  unint64_t v5 = *(void *)(a1 + 56);
  unint64_t v6 = *(void *)(a1 + 24);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 16), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 24);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 32)) {
    uint64_t v7 = a1 + 40;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 48);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 56);
  ++*(_DWORD *)(a1 + 64);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 56);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetMipmapGenerationContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 7)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 16, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMipmapGenerationContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 7)) {
    return (uint64_t)this + 16;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMipmapGenerationContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 16;
}

uint64_t re::RealityDataPipe::addRenderProfilerTextArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 72;
  unint64_t v5 = *(void *)(a1 + 112);
  unint64_t v6 = *(void *)(a1 + 80);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::DynamicArray<re::RenderProfilerText>,4ul>::setBucketsCapacity((void *)(a1 + 72), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 80);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 88)) {
    uint64_t v7 = a1 + 96;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 104);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 112);
  ++*(_DWORD *)(a1 + 120);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 112);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetRenderProfilerTextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 14)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 72, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderProfilerTextArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 14)) {
    return (uint64_t)this + 72;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderProfilerTextArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 72;
}

uint64_t re::RealityDataPipe::addClippingParametersSlice(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 128;
  unint64_t v5 = *(void *)(a1 + 168);
  unint64_t v6 = *(void *)(a1 + 136);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::Slice<re::ClippingParametersEntry>,4ul>::setBucketsCapacity((void *)(a1 + 128), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 136);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 144)) {
    uint64_t v7 = a1 + 152;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 160);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 168);
  ++*(_DWORD *)(a1 + 176);
  *(_OWORD *)(v8 + 16 * (v5 & 3)) = *a2;
  uint64_t v9 = *(void *)(a1 + 168);
  if (!v9)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::PipelineCompilationData,4ul>::operator[](v4, v9 - 1);
}

uint64_t re::RealityDataPipe::tryGetClippingParametersSlice(re::RealityDataPipe *this)
{
  if (*((void *)this + 21)) {
    return re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 128, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetClippingParametersSliceArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 21)) {
    return (uint64_t)this + 128;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetClippingParametersSliceArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 128;
}

uint64_t re::RealityDataPipe::addClippingIndexIndirectionSlice(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 184;
  unint64_t v5 = *(void *)(a1 + 224);
  unint64_t v6 = *(void *)(a1 + 192);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::Slice<re::ClippingParametersEntry>,4ul>::setBucketsCapacity((void *)(a1 + 184), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 192);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 200)) {
    uint64_t v7 = a1 + 208;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 216);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 224);
  ++*(_DWORD *)(a1 + 232);
  *(_OWORD *)(v8 + 16 * (v5 & 3)) = *a2;
  uint64_t v9 = *(void *)(a1 + 224);
  if (!v9)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::PipelineCompilationData,4ul>::operator[](v4, v9 - 1);
}

uint64_t re::RealityDataPipe::tryGetClippingIndexIndirectionSlice(re::RealityDataPipe *this)
{
  if (*((void *)this + 28)) {
    return re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 184, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetClippingIndexIndirectionSliceArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 28)) {
    return (uint64_t)this + 184;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetClippingIndexIndirectionSliceArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 184;
}

uint64_t re::RealityDataPipe::addProbeContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 240;
  unint64_t v5 = *(void *)(a1 + 280);
  unint64_t v6 = *(void *)(a1 + 248);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 240), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 248);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 256)) {
    uint64_t v7 = a1 + 264;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 272);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 280);
  ++*(_DWORD *)(a1 + 288);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(_OWORD *)(v9 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v10 = *(void *)(a2 + 24);
  *(unsigned char *)(v9 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(v9 + 24) = v10;
  uint64_t v11 = *(void *)(a1 + 280);
  if (!v11)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v11 - 1);
}

uint64_t re::RealityDataPipe::tryGetProbeContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 35)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 240, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProbeContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 35)) {
    return (uint64_t)this + 240;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProbeContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 240;
}

uint64_t re::RealityDataPipe::addBlurGenerationContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 296;
  unint64_t v5 = *(void *)(a1 + 336);
  unint64_t v6 = *(void *)(a1 + 304);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 296), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 304);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 312)) {
    uint64_t v7 = a1 + 320;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 328);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 336);
  ++*(_DWORD *)(a1 + 344);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 336);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetBlurGenerationContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 42)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 296, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetBlurGenerationContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 42)) {
    return (uint64_t)this + 296;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetBlurGenerationContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 296;
}

uint64_t re::RealityDataPipe::addCameraStreamContext(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 352;
  unint64_t v5 = *(void *)(a1 + 392);
  unint64_t v6 = *(void *)(a1 + 360);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::CameraStreamContext,4ul>::setBucketsCapacity((void *)(a1 + 352), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 360);
  }
  if (v6 <= v5 >> 2)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v17 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 368)) {
    uint64_t v7 = a1 + 376;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 384);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 392);
  ++*(_DWORD *)(a1 + 400);
  uint64_t v9 = v8 + 1840 * (v5 & 3);
  *(void *)uint64_t v9 = 0;
  *(void *)(v9 + 16) = 0;
  *(_DWORD *)(v9 + 8) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(_DWORD *)(v9 + 1728) = 0;
  *(_OWORD *)(v9 + 1712) = 0u;
  *(_OWORD *)(v9 + 1696) = 0u;
  *(void *)(v9 + 1732) = 0x7FFFFFFFLL;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)&long long v17 = 0;
  DWORD2(v17) = 0;
  re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::move((uint64_t *)&v17, (uint64_t *)(v9 + 16));
  if (v9 != a2)
  {
    re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::move((uint64_t *)(v9 + 16), (uint64_t *)(a2 + 16));
    ++*(_DWORD *)(v9 + 24);
  }
  if (&v17 != (long long *)(a2 + 16))
  {
    re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::move((uint64_t *)(a2 + 16), (uint64_t *)&v17);
    ++*(_DWORD *)(a2 + 24);
  }
  re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::clear(&v17);
  DWORD2(v19) = 0;
  *(void *)&long long v17 = *(void *)(v9 + 1696);
  *(void *)(v9 + 1696) = 0;
  *((void *)&v17 + 1) = *(void *)(v9 + 1704);
  *(void *)(v9 + 1704) = 0;
  *(void *)&long long v18 = *(void *)(v9 + 1712);
  *(void *)(v9 + 1712) = 0;
  DWORD2(v18) = *(_DWORD *)(v9 + 1720);
  *(_DWORD *)(v9 + 1720) = 0;
  HIDWORD(v18) = *(_DWORD *)(v9 + 1724);
  *(_DWORD *)(v9 + 1724) = 0;
  LODWORD(v19) = *(_DWORD *)(v9 + 1728);
  *(_DWORD *)(v9 + 1728) = 0;
  DWORD1(v19) = *(_DWORD *)(v9 + 1732);
  *(_DWORD *)(v9 + 1732) = 0x7FFFFFFF;
  re::HashTable<re::WeakStringID,re::CameraStreamParams,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::operator=(v9 + 1696, a2 + 1696);
  re::HashTable<re::WeakStringID,re::CameraStreamParams,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::operator=(a2 + 1696, (uint64_t)&v17);
  re::HashTable<re::WeakStringID,re::CameraStreamParams,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)&v17);
  uint64_t v11 = v8 + 1840 * (v5 & 3);
  *(_OWORD *)(v11 + 1744) = *(_OWORD *)(a2 + 1744);
  long long v12 = *(_OWORD *)(a2 + 1760);
  long long v13 = *(_OWORD *)(a2 + 1776);
  long long v14 = *(_OWORD *)(a2 + 1792);
  *(_DWORD *)(v11 + 1808) = *(_DWORD *)(a2 + 1808);
  *(_OWORD *)(v11 + 1792) = v14;
  *(_OWORD *)(v11 + 1776) = v13;
  *(_OWORD *)(v11 + 1760) = v12;
  *(void *)(v11 + 1816) = *(void *)(a2 + 1816);
  *(void *)(a2 + 1816) = 0;
  *(void *)(v11 + 1824) = *(void *)(a2 + 1824);
  *(void *)(a2 + 1824) = 0;
  uint64_t v15 = *(void *)(a1 + 392);
  if (!v15)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::CameraStreamContext,4ul>::operator[](v4, v15 - 1);
}

uint64_t re::RealityDataPipe::tryGetCameraStreamContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 49)) {
    return re::BucketArray<re::CameraStreamContext,4ul>::operator[]((uint64_t)this + 352, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraStreamContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 49)) {
    return (uint64_t)this + 352;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraStreamContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 352;
}

uint64_t re::RealityDataPipe::addSFBSystemShellBlurContext(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 408;
  unint64_t v5 = *(void *)(a1 + 448);
  unint64_t v6 = *(void *)(a1 + 416);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::SFBSystemShellBlurContext,4ul>::setBucketsCapacity((void *)(a1 + 408), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 416);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 424)) {
    uint64_t v7 = a1 + 432;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 440);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 448);
  ++*(_DWORD *)(a1 + 456);
  uint64_t v9 = (_OWORD *)(v8 + 32 * (v5 & 3));
  long long v10 = a2[1];
  *uint64_t v9 = *a2;
  v9[1] = v10;
  uint64_t v11 = *(void *)(a1 + 448);
  if (!v11)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[](v4, v11 - 1);
}

uint64_t re::RealityDataPipe::tryGetSFBSystemShellBlurContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 56)) {
    return re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[]((uint64_t)this + 408, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSFBSystemShellBlurContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 56)) {
    return (uint64_t)this + 408;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSFBSystemShellBlurContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 408;
}

uint64_t re::RealityDataPipe::addOpenSkyData(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 464;
  unint64_t v5 = *(void *)(a1 + 504);
  unint64_t v6 = *(void *)(a1 + 472);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::OpenSkyData,4ul>::setBucketsCapacity((void *)(a1 + 464), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 472);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 480)) {
    uint64_t v7 = a1 + 488;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 496);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 504);
  ++*(_DWORD *)(a1 + 512);
  uint64_t v9 = v8 + 208 * (v5 & 3);
  long long v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  *(_OWORD *)(v9 + 16) = v10;
  long long v11 = *(_OWORD *)(a2 + 32);
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v13 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(v9 + 80) = *(_DWORD *)(a2 + 80);
  *(_OWORD *)(v9 + 48) = v12;
  *(_OWORD *)(v9 + 64) = v13;
  *(_OWORD *)(v9 + 32) = v11;
  *(void *)(v9 + 120) = 0;
  *(void *)(v9 + 96) = 0;
  *(void *)(v9 + 104) = 0;
  *(void *)(v9 + 88) = 0;
  *(_DWORD *)(v9 + 112) = 0;
  *(void *)(v9 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  *(void *)(v9 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  uint64_t v14 = *(void *)(v9 + 104);
  *(void *)(v9 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v14;
  uint64_t v15 = *(void *)(v9 + 120);
  *(void *)(v9 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = v15;
  ++*(_DWORD *)(a2 + 112);
  ++*(_DWORD *)(v9 + 112);
  *(void *)(v9 + 160) = 0;
  *(_DWORD *)(v9 + 152) = 0;
  *(void *)(v9 + 136) = 0;
  *(void *)(v9 + 144) = 0;
  *(void *)(v9 + 128) = 0;
  *(void *)(v9 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = 0;
  *(void *)(v9 + 136) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = 0;
  uint64_t v16 = *(void *)(v9 + 144);
  *(void *)(v9 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v16;
  uint64_t v17 = *(void *)(v9 + 160);
  *(void *)(v9 + 160) = *(void *)(a2 + 160);
  *(void *)(a2 + 160) = v17;
  ++*(_DWORD *)(a2 + 152);
  ++*(_DWORD *)(v9 + 152);
  long long v18 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(v9 + 177) = *(_OWORD *)(a2 + 177);
  *(_OWORD *)(v9 + 168) = v18;
  uint64_t v19 = *(void *)(a1 + 504);
  if (!v19)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::OpenSkyData,4ul>::operator[](v4, v19 - 1);
}

uint64_t re::RealityDataPipe::tryGetOpenSkyData(re::RealityDataPipe *this)
{
  if (*((void *)this + 63)) {
    return re::BucketArray<re::OpenSkyData,4ul>::operator[]((uint64_t)this + 464, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetOpenSkyDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 63)) {
    return (uint64_t)this + 464;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetOpenSkyDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 464;
}

uint64_t re::RealityDataPipe::addProjectiveShadowBuilderInputGlobalData(uint64_t a1, void *__src)
{
  uint64_t v4 = a1 + 520;
  unint64_t v5 = *(void *)(a1 + 560);
  unint64_t v6 = *(void *)(a1 + 528);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::setBucketsCapacity((void *)(a1 + 520), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 528);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 536)) {
    uint64_t v7 = a1 + 544;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 552);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 560);
  ++*(_DWORD *)(a1 + 568);
  memcpy((void *)(v8 + 272 * (v5 & 3)), __src, 0x110uLL);
  uint64_t v10 = *(void *)(a1 + 560);
  if (!v10)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::operator[](v4, v10 - 1);
}

uint64_t re::RealityDataPipe::tryGetProjectiveShadowBuilderInputGlobalData(re::RealityDataPipe *this)
{
  if (*((void *)this + 70)) {
    return re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::operator[]((uint64_t)this + 520, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProjectiveShadowBuilderInputGlobalDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 70)) {
    return (uint64_t)this + 520;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProjectiveShadowBuilderInputGlobalDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 520;
}

uint64_t re::RealityDataPipe::addProjectiveMeshShadowBuilderInputGlobalData(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 576;
  unint64_t v5 = *(void *)(a1 + 616);
  unint64_t v6 = *(void *)(a1 + 584);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::setBucketsCapacity((void *)(a1 + 576), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 584);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
  if (*(unsigned char *)(a1 + 592)) {
    uint64_t v7 = a1 + 600;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 608);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 616);
  ++*(_DWORD *)(a1 + 624);
  uint64_t v9 = v8 + 352 * (v5 & 3);
  long long v10 = *a2;
  *(void *)(v9 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  *(void *)(v9 + 24) = *((void *)a2 + 3);
  *((void *)a2 + 3) = 0;
  *(void *)(v9 + 32) = *((void *)a2 + 4);
  *((void *)a2 + 4) = 0;
  *(void *)(v9 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 5) = 0;
  *(void *)(v9 + 48) = *((void *)a2 + 6);
  int v11 = *((unsigned __int8 *)a2 + 56);
  *(unsigned char *)(v9 + 56) = v11;
  if (v11)
  {
    uint64_t v12 = v8 + 352 * (v5 & 3);
    uint64_t v13 = *((void *)a2 + 8);
    *(void *)(v12 + 64) = *(void *)(v12 + 64) & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
    *(void *)(v12 + 64) = a2[4] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
    *(void *)(v12 + 72) = *((void *)a2 + 9);
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = "";
  }
  memcpy((void *)(v8 + 352 * (v5 & 3) + 80), a2 + 5, 0x110uLL);
  uint64_t v15 = *(void *)(a1 + 616);
  if (!v15)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::operator[](v4, v15 - 1);
}

uint64_t re::RealityDataPipe::tryGetProjectiveMeshShadowBuilderInputGlobalData(re::RealityDataPipe *this)
{
  if (*((void *)this + 77)) {
    return re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::operator[]((uint64_t)this + 576, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProjectiveMeshShadowBuilderInputGlobalDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 77)) {
    return (uint64_t)this + 576;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProjectiveMeshShadowBuilderInputGlobalDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 576;
}

uint64_t re::RealityDataPipe::addMeshShadowPerFrameUpdateData(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = a1 + 632;
  unint64_t v5 = *(void *)(a1 + 672);
  unint64_t v6 = *(void *)(a1 + 640);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MeshShadowPerFrameUpdateData,4ul>::setBucketsCapacity((void *)(a1 + 632), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 640);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 648)) {
    uint64_t v7 = a1 + 656;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 664);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 672);
  ++*(_DWORD *)(a1 + 680);
  re::MeshShadowPerFrameUpdateData::MeshShadowPerFrameUpdateData(v8 + 656 * (v5 & 3), a2);
  uint64_t v10 = *(void *)(a1 + 672);
  if (!v10)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::MeshScene,4ul>::operator[](v4, v10 - 1);
}

uint64_t re::RealityDataPipe::tryGetMeshShadowPerFrameUpdateData(re::RealityDataPipe *this)
{
  if (*((void *)this + 84)) {
    return re::BucketArray<re::MeshScene,4ul>::operator[]((uint64_t)this + 632, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshShadowPerFrameUpdateDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 84)) {
    return (uint64_t)this + 632;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshShadowPerFrameUpdateDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 632;
}

uint64_t re::RealityDataPipe::addIBLContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 688;
  uint64_t v5 = re::BucketArray<re::IBLContext,4ul>::addUninitialized(a1 + 688);
  *(void *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 8) = v7;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v8 = *(void *)(v5 + 16);
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v8;
  uint64_t v9 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v9;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v5 + 24);
  *(void *)(v5 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(_DWORD *)(v5 + 48) = *(_DWORD *)(a2 + 48);
  uint64_t v10 = *(void *)(a1 + 728);
  if (v10)
  {
    return re::BucketArray<re::IBLContext,4ul>::operator[](v4, v10 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::tryGetIBLContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 91)) {
    return re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)this + 688, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetIBLContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 91)) {
    return (uint64_t)this + 688;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetIBLContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 688;
}

uint64_t re::RealityDataPipe::addIBLContext(re::RealityDataPipe *this, re::IBLContext *a2)
{
  uint64_t v4 = (char *)this + 688;
  uint64_t v5 = re::BucketArray<re::IBLContext,4ul>::addUninitialized((uint64_t)this + 688);
  re::DynamicArray<re::IBL>::DynamicArray(v5, (uint64_t *)a2);
  *(void *)(v5 + 40) = *((id *)a2 + 5);
  *(_DWORD *)(v5 + 48) = *((_DWORD *)a2 + 12);
  uint64_t v7 = *((void *)this + 91);
  if (v7)
  {
    return re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)v4, v7 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::addBlurPlanesRenderFrameData(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 744;
  unint64_t v5 = *(void *)(a1 + 784);
  unint64_t v6 = *(void *)(a1 + 752);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::BlurPlanesRenderFrameData,4ul>::setBucketsCapacity((void *)(a1 + 744), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 752);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 760)) {
    uint64_t v7 = a1 + 768;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 776);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 784);
  ++*(_DWORD *)(a1 + 792);
  uint64_t v9 = v8 + 88 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  *(void *)(v9 + 72) = 0;
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 56) = 0;
  *(void *)(v9 + 40) = 0;
  *(_DWORD *)(v9 + 64) = 0;
  *(void *)(v9 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(v9 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  uint64_t v12 = *(void *)(v9 + 56);
  *(void *)(v9 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v12;
  uint64_t v13 = *(void *)(v9 + 72);
  *(void *)(v9 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v13;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(v9 + 64);
  *(_WORD *)(v9 + 80) = *(_WORD *)(a2 + 80);
  uint64_t v14 = *(void *)(a1 + 784);
  if (!v14)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::operator[](v4, v14 - 1);
}

uint64_t re::RealityDataPipe::tryGetBlurPlanesRenderFrameData(re::RealityDataPipe *this)
{
  if (*((void *)this + 98)) {
    return re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::operator[]((uint64_t)this + 744, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetBlurPlanesRenderFrameDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 98)) {
    return (uint64_t)this + 744;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetBlurPlanesRenderFrameDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 744;
}

uint64_t re::RealityDataPipe::addTintContext(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 800;
  unint64_t v5 = *(void *)(a1 + 840);
  unint64_t v6 = *(void *)(a1 + 808);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::TintContext,4ul>::setBucketsCapacity((void *)(a1 + 800), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 808);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 816)) {
    uint64_t v7 = a1 + 824;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 832);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 840);
  ++*(_DWORD *)(a1 + 848);
  uint64_t v9 = (_OWORD *)(v8 + 32 * (v5 & 3));
  long long v10 = a2[1];
  *uint64_t v9 = *a2;
  v9[1] = v10;
  uint64_t v11 = *(void *)(a1 + 840);
  if (!v11)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[](v4, v11 - 1);
}

uint64_t re::RealityDataPipe::tryGetTintContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 105)) {
    return re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[]((uint64_t)this + 800, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetTintContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 105)) {
    return (uint64_t)this + 800;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetTintContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 800;
}

uint64_t re::RealityDataPipe::addSceneName(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 856;
  unint64_t v5 = *(void *)(a1 + 896);
  unint64_t v6 = *(void *)(a1 + 864);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 856), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 864);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 872)) {
    uint64_t v7 = a1 + 880;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 888);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 896);
  ++*(_DWORD *)(a1 + 904);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)uint64_t v9 = *(void *)a2;
  uint64_t v10 = *(void *)(a2 + 8);
  *(void *)(v9 + 8) = *(void *)(v9 + 8) & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
  *(void *)(v9 + 8) = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = "";
  uint64_t v11 = *(void *)(a2 + 24);
  *(unsigned char *)(v9 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(v9 + 24) = v11;
  uint64_t v12 = *(void *)(a1 + 896);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetSceneName(re::RealityDataPipe *this)
{
  if (*((void *)this + 112)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 856, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneNameArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 112)) {
    return (uint64_t)this + 856;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneNameArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 856;
}

uint64_t re::RealityDataPipe::addMeshSceneCollection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 912;
  uint64_t v5 = re::BucketArray<re::MeshSceneCollection,4ul>::addUninitialized(a1 + 912);
  *(void *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 8) = v7;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v8 = *(void *)(v5 + 16);
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v8;
  uint64_t v9 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v9;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v5 + 24);
  uint64_t v10 = *(void *)(a1 + 952);
  if (v10)
  {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v10 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::tryGetMeshSceneCollection(re::RealityDataPipe *this)
{
  if (*((void *)this + 119)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 912, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshSceneCollectionArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 119)) {
    return (uint64_t)this + 912;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshSceneCollectionArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 912;
}

uint64_t re::RealityDataPipe::addMeshSceneCollection(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 912;
  uint64_t v5 = re::BucketArray<re::MeshSceneCollection,4ul>::addUninitialized(a1 + 912);
  re::DynamicArray<re::MeshScene>::DynamicArray(v5, a2);
  uint64_t v7 = *(void *)(a1 + 952);
  if (v7)
  {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v7 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::addMeshDeformationCollection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 968;
  uint64_t v5 = re::BucketArray<re::MeshDeformationCollection,4ul>::addUninitialized(a1 + 968);
  *(void *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 1;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(v5, a2);
  uint64_t v7 = *(void *)(a1 + 1008);
  if (v7)
  {
    return re::BucketArray<re::IBLContext,4ul>::operator[](v4, v7 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  long long v18;
  long long v19;
  long long v20;
  long long v21;
  long long v22;
  uint64_t v23;
  uint64_t v25;
  _OWORD v26[5];
  uint64_t v27;
  uint64_t vars8;

  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 968;
  uint64_t v5 = re::BucketArray<re::MeshDeformationCollection,4ul>::addUninitialized(a1 + 968);
  *(void *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 1;
  *(void *)(v5 + 24) = 0;
  uint64_t v6 = v5 + 24;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  uint64_t v7 = *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v8 = v5;
    uint64_t v25 = v4;
    re::BucketArray<re::MeshDeformation,8ul>::init(v5, v7, *(void *)(a2 + 8));
    uint64_t v9 = *(void *)(a2 + 40);
    if (v9 >= *(void *)(v8 + 40))
    {
      re::BucketArray<re::MeshDeformation,8ul>::setBucketsCapacity((uint64_t *)v8, (v9 + 7) >> 3);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation&,re::BucketArray<re::MeshDeformation,8ul>&,true>>((uint64_t)v26, a2, 0, a2, *(void *)(v8 + 40), v8, 0);
      uint64_t v11 = *(void *)(v8 + 40);
      uint64_t v12 = v9 - v11;
      if (v9 != v11)
      {
        uint64_t v13 = 0;
        while (1)
        {
          uint64_t v14 = v13 + *(void *)(v8 + 40);
          if (*(void *)(v8 + 8) <= v14 >> 3) {
            break;
          }
          if (*(_DWORD *)(v8 + 16)) {
            uint64_t v15 = v6;
          }
          else {
            uint64_t v15 = *(void *)(v8 + 32);
          }
          uint64_t v16 = *(void *)(v15 + 8 * (v14 >> 3)) + 104 * (v14 & 7);
          uint64_t v17 = re::BucketArray<re::MeshDeformation,8ul>::operator[](a2, v14);
          uint64_t v19 = *(_OWORD *)(v17 + 16);
          long long v18 = *(_OWORD *)(v17 + 32);
          *(_OWORD *)uint64_t v16 = *(_OWORD *)v17;
          *(_OWORD *)(v16 + 16) = v19;
          *(_OWORD *)(v16 + 32) = v18;
          long long v21 = *(_OWORD *)(v17 + 64);
          long long v20 = *(_OWORD *)(v17 + 80);
          uint64_t v22 = *(_OWORD *)(v17 + 48);
          *(void *)(v16 + 96) = *(void *)(v17 + 96);
          *(_OWORD *)(v16 + 64) = v21;
          *(_OWORD *)(v16 + 80) = v20;
          *(_OWORD *)(v16 + 48) = v22;
          if (v12 == ++v13) {
            goto LABEL_14;
          }
        }
        memset(v26, 0, sizeof(v26));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_20:
        re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
        _os_crash();
        __break(1u);
      }
    }
    else
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation&,re::BucketArray<re::MeshDeformation,8ul>&,true>>((uint64_t)v26, a2, 0, a2, *(void *)(a2 + 40), v8, 0);
      if (v9 != *(void *)(v8 + 40))
      {
        uint64_t v10 = v9;
        do
          re::BucketArray<re::MeshDeformation,8ul>::operator[](v8, v10++);
        while (v10 != *(void *)(v8 + 40));
      }
    }
LABEL_14:
    *(void *)(v8 + 40) = v9;
    uint64_t v4 = v25;
  }
  int32x4_t v23 = *(void *)(a1 + 1008);
  if (!v23) {
    goto LABEL_20;
  }
  return re::BucketArray<re::IBLContext,4ul>::operator[](v4, v23 - 1);
}

uint64_t re::RealityDataPipe::tryGetMeshDeformationCollection(re::RealityDataPipe *this)
{
  if (*((void *)this + 126)) {
    return re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)this + 968, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshDeformationCollectionArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 126)) {
    return (uint64_t)this + 968;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshDeformationCollectionArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 968;
}

uint64_t re::RealityDataPipe::addCameraViewArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1024;
  unint64_t v5 = *(void *)(a1 + 1064);
  unint64_t v6 = *(void *)(a1 + 1032);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1024), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1032);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1040)) {
    uint64_t v7 = a1 + 1048;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1056);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1064);
  ++*(_DWORD *)(a1 + 1072);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1064);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetCameraViewArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 133)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1024, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraViewArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 133)) {
    return (uint64_t)this + 1024;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraViewArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1024;
}

uint64_t re::RealityDataPipe::addCameraMultiViewArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1080;
  unint64_t v5 = *(void *)(a1 + 1120);
  unint64_t v6 = *(void *)(a1 + 1088);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1080), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1088);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1096)) {
    uint64_t v7 = a1 + 1104;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1112);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1120);
  ++*(_DWORD *)(a1 + 1128);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1120);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetCameraMultiViewArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 140)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1080, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraMultiViewArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 140)) {
    return (uint64_t)this + 1080;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetCameraMultiViewArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1080;
}

uint64_t re::RealityDataPipe::addStaticTextInfo(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 1136;
  unint64_t v5 = *(void *)(a1 + 1176);
  unint64_t v6 = *(void *)(a1 + 1144);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::StaticTextInfo,4ul>::setBucketsCapacity((void *)(a1 + 1136), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1144);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1152)) {
    uint64_t v7 = a1 + 1160;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1168);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  unint64_t v9 = *(void *)(a1 + 1176);
  *(void *)(a1 + 1176) = v9 + 1;
  ++*(_DWORD *)(a1 + 1184);
  *(void *)(v8 + 8 * (v5 & 3)) = *a2;
  if (v9 == -1)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<unsigned long,4ul>::operator[](v4, v9);
}

uint64_t re::RealityDataPipe::tryGetStaticTextInfo(re::RealityDataPipe *this)
{
  if (*((void *)this + 147)) {
    return re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 1136, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetStaticTextInfoArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 147)) {
    return (uint64_t)this + 1136;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetStaticTextInfoArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1136;
}

uint64_t re::RealityDataPipe::addRenderTextArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1192;
  unint64_t v5 = *(void *)(a1 + 1232);
  unint64_t v6 = *(void *)(a1 + 1200);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1192), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1200);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1208)) {
    uint64_t v7 = a1 + 1216;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1224);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1232);
  ++*(_DWORD *)(a1 + 1240);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1232);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetRenderTextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 154)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1192, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderTextArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 154)) {
    return (uint64_t)this + 1192;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderTextArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1192;
}

uint64_t re::RealityDataPipe::addVFXSceneArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1248;
  unint64_t v5 = *(void *)(a1 + 1288);
  unint64_t v6 = *(void *)(a1 + 1256);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1248), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1256);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1264)) {
    uint64_t v7 = a1 + 1272;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1280);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1288);
  ++*(_DWORD *)(a1 + 1296);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1288);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetVFXSceneArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 161)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1248, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetVFXSceneArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 161)) {
    return (uint64_t)this + 1248;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetVFXSceneArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1248;
}

uint64_t re::RealityDataPipe::addRenderGraphFileProviderArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1304;
  uint64_t v5 = re::BucketArray<re::DynamicArray<re::RenderGraphFileProvider>,4ul>::addUninitialized(a1 + 1304);
  *(void *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 8) = v7;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v8 = *(void *)(v5 + 16);
  *(void *)(v5 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v8;
  uint64_t v9 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v9;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v5 + 24);
  uint64_t v10 = *(void *)(a1 + 1344);
  if (v10)
  {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v10 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::tryGetRenderGraphFileProviderArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 168)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1304, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderGraphFileProviderArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 168)) {
    return (uint64_t)this + 1304;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderGraphFileProviderArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1304;
}

uint64_t re::RealityDataPipe::addRenderGraphFileProviders(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 1304;
  uint64_t v5 = re::BucketArray<re::DynamicArray<re::RenderGraphFileProvider>,4ul>::addUninitialized(a1 + 1304);
  re::DynamicArray<re::RenderGraphFileProvider>::DynamicArray(v5, a2);
  uint64_t v7 = *(void *)(a1 + 1344);
  if (v7)
  {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v7 - 1);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::RealityDataPipe::addStencilPortalArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1360;
  unint64_t v5 = *(void *)(a1 + 1400);
  unint64_t v6 = *(void *)(a1 + 1368);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1360), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1368);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1376)) {
    uint64_t v7 = a1 + 1384;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1392);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1400);
  ++*(_DWORD *)(a1 + 1408);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1400);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetStencilPortalArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 175)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1360, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetStencilPortalArrayArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 175)) {
    return (uint64_t)this + 1360;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetStencilPortalArrayArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1360;
}

uint64_t re::RealityDataPipe::addFilterViewMeshScenes(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1416;
  unint64_t v5 = *(void *)(a1 + 1456);
  unint64_t v6 = *(void *)(a1 + 1424);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::FilterViewMeshScenes,4ul>::setBucketsCapacity((void *)(a1 + 1416), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1424);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1432)) {
    uint64_t v7 = a1 + 1440;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1448);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1456);
  ++*(_DWORD *)(a1 + 1464);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1456);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetFilterViewMeshScenes(re::RealityDataPipe *this)
{
  if (*((void *)this + 182)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1416, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetFilterViewMeshScenesArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 182)) {
    return (uint64_t)this + 1416;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetFilterViewMeshScenesArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1416;
}

unint64_t re::RealityDataPipe::addProbeLightingEnabledMetadata(uint64_t a1)
{
  uint64_t v2 = a1 + 1472;
  unint64_t v3 = *(void *)(a1 + 1512);
  unint64_t v4 = *(void *)(a1 + 1480);
  if (v3 + 1 > 4 * v4)
  {
    re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::setBucketsCapacity((void *)(a1 + 1472), (v3 + 4) >> 2);
    unint64_t v4 = *(void *)(a1 + 1480);
  }
  if (v4 <= v3 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  unint64_t v5 = *(void *)(a1 + 1512);
  ++*(_DWORD *)(a1 + 1520);
  *(void *)(a1 + 1512) = v5 + 1;
  if (v5 == -1) {
    goto LABEL_9;
  }
  return re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::operator[](v2, v5);
}

unint64_t re::RealityDataPipe::tryGetProbeLightingEnabledMetadata(re::RealityDataPipe *this)
{
  if (*((void *)this + 189)) {
    return re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::operator[]((uint64_t)this + 1472, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProbeLightingEnabledMetadataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 189)) {
    return (uint64_t)this + 1472;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetProbeLightingEnabledMetadataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1472;
}

uint64_t re::RealityDataPipe::addSceneCRWSReferencePosition(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 1528;
  unint64_t v5 = *(void *)(a1 + 1568);
  unint64_t v6 = *(void *)(a1 + 1536);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::SceneCRWSReferencePosition,4ul>::setBucketsCapacity((void *)(a1 + 1528), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1536);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1544)) {
    uint64_t v7 = a1 + 1552;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1560);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1568);
  ++*(_DWORD *)(a1 + 1576);
  *(_OWORD *)(v8 + 16 * (v5 & 3)) = *a2;
  uint64_t v9 = *(void *)(a1 + 1568);
  if (!v9)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::PipelineCompilationData,4ul>::operator[](v4, v9 - 1);
}

uint64_t re::RealityDataPipe::tryGetSceneCRWSReferencePosition(re::RealityDataPipe *this)
{
  if (*((void *)this + 196)) {
    return re::BucketArray<re::PipelineCompilationData,4ul>::operator[]((uint64_t)this + 1528, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneCRWSReferencePositionArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 196)) {
    return (uint64_t)this + 1528;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneCRWSReferencePositionArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1528;
}

uint64_t re::RealityDataPipe::addPlanarReflectionContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1584;
  unint64_t v5 = *(void *)(a1 + 1624);
  unint64_t v6 = *(void *)(a1 + 1592);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1584), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1592);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1600)) {
    uint64_t v7 = a1 + 1608;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1616);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1624);
  ++*(_DWORD *)(a1 + 1632);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1624);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetPlanarReflectionContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 203)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1584, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetPlanarReflectionContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 203)) {
    return (uint64_t)this + 1584;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetPlanarReflectionContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1584;
}

uint64_t re::RealityDataPipe::addMeshSortingCollection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1640;
  unint64_t v5 = *(void *)(a1 + 1680);
  unint64_t v6 = *(void *)(a1 + 1648);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MeshSortingCollection,4ul>::setBucketsCapacity((void *)(a1 + 1640), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1648);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1656)) {
    uint64_t v7 = a1 + 1664;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1672);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1680);
  ++*(_DWORD *)(a1 + 1688);
  uint64_t v9 = v8 + 200 * (v5 & 3);
  *(_DWORD *)(v9 + 32) = 0;
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(void *)(v9 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v9, (uint64_t *)a2);
  *(_DWORD *)(v9 + 80) = 0;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(void *)(v9 + 84) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(v9 + 48), (uint64_t *)(a2 + 48));
  *(_DWORD *)(v9 + 128) = 0;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(void *)(v9 + 132) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(v9 + 96), (uint64_t *)(a2 + 96));
  *(_OWORD *)(v9 + 144) = 0u;
  v9 += 144;
  *(_DWORD *)(v9 + 32) = 0;
  *(_OWORD *)(v9 + 16) = 0u;
  *(void *)(v9 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v9, (uint64_t *)(a2 + 144));
  *(_WORD *)(v9 + 48) = *(_WORD *)(a2 + 192);
  uint64_t v11 = *(void *)(a1 + 1680);
  if (!v11)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::MeshSortingCollection,4ul>::operator[](v4, v11 - 1);
}

uint64_t re::RealityDataPipe::tryGetMeshSortingCollection(re::RealityDataPipe *this)
{
  if (*((void *)this + 210)) {
    return re::BucketArray<re::MeshSortingCollection,4ul>::operator[]((uint64_t)this + 1640, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshSortingCollectionArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 210)) {
    return (uint64_t)this + 1640;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetMeshSortingCollectionArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1640;
}

uint64_t re::RealityDataPipe::addSceneUnderstandingFlagEmitterData(uint64_t a1, int *a2)
{
  uint64_t v4 = a1 + 1696;
  unint64_t v5 = *(void *)(a1 + 1736);
  unint64_t v6 = *(void *)(a1 + 1704);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::setBucketsCapacity((void *)(a1 + 1696), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1704);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1712)) {
    uint64_t v7 = a1 + 1720;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1728);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1736);
  ++*(_DWORD *)(a1 + 1744);
  uint64_t v9 = (_DWORD *)(v8 - (v5 & 3) + 8 * (v5 & 3));
  int v10 = *a2;
  *(_DWORD *)((char *)v9 + 3) = *(int *)((char *)a2 + 3);
  *uint64_t v9 = v10;
  uint64_t v11 = *(void *)(a1 + 1736);
  if (!v11)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::operator[](v4, v11 - 1);
}

uint64_t re::RealityDataPipe::tryGetSceneUnderstandingFlagEmitterData(re::RealityDataPipe *this)
{
  if (*((void *)this + 217)) {
    return re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::operator[]((uint64_t)this + 1696, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneUnderstandingFlagEmitterDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 217)) {
    return (uint64_t)this + 1696;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetSceneUnderstandingFlagEmitterDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1696;
}

uint64_t re::RealityDataPipe::addRenderCallbacks(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1752;
  unint64_t v5 = *(void *)(a1 + 1792);
  unint64_t v6 = *(void *)(a1 + 1760);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::IBLContext,4ul>::setBucketsCapacity((void *)(a1 + 1752), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1760);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1768)) {
    uint64_t v7 = a1 + 1776;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1784);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1792);
  ++*(_DWORD *)(a1 + 1800);
  uint64_t v9 = v8 + 56 * (v5 & 3);
  uint64_t v10 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)uint64_t v9 = v10;
  *(_OWORD *)(v9 + 8) = 0u;
  *(_DWORD *)(v9 + 40) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(void *)(v9 + 44) = 0x7FFFFFFFLL;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v11 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v11;
  uint64_t v12 = *(void *)(v9 + 24);
  *(void *)(v9 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v12;
  LODWORD(v12) = *(_DWORD *)(v9 + 32);
  *(_DWORD *)(v9 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = v12;
  LODWORD(v12) = *(_DWORD *)(v9 + 36);
  *(_DWORD *)(v9 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v12;
  LODWORD(v12) = *(_DWORD *)(v9 + 40);
  *(_DWORD *)(v9 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v12;
  LODWORD(v12) = *(_DWORD *)(v9 + 44);
  *(_DWORD *)(v9 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a2 + 44) = v12;
  uint64_t v13 = *(void *)(a1 + 1792);
  if (!v13)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::IBLContext,4ul>::operator[](v4, v13 - 1);
}

uint64_t re::RealityDataPipe::tryGetRenderCallbacks(re::RealityDataPipe *this)
{
  if (*((void *)this + 224)) {
    return re::BucketArray<re::IBLContext,4ul>::operator[]((uint64_t)this + 1752, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderCallbacksArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 224)) {
    return (uint64_t)this + 1752;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetRenderCallbacksArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1752;
}

uint64_t re::RealityDataPipe::addAnchorTransformData(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1808;
  unint64_t v5 = *(void *)(a1 + 1848);
  unint64_t v6 = *(void *)(a1 + 1816);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)(a1 + 1808), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1816);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1824)) {
    uint64_t v7 = a1 + 1832;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1840);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1848);
  ++*(_DWORD *)(a1 + 1856);
  uint64_t v9 = v8 + 40 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  uint64_t v12 = *(void *)(a1 + 1848);
  if (!v12)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v4, v12 - 1);
}

uint64_t re::RealityDataPipe::tryGetAnchorTransformData(re::RealityDataPipe *this)
{
  if (*((void *)this + 231)) {
    return re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)this + 1808, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetAnchorTransformDataArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 231)) {
    return (uint64_t)this + 1808;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetAnchorTransformDataArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1808;
}

uint64_t re::RealityDataPipe::addVirtualEnvironmentProbeContext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1864;
  unint64_t v5 = *(void *)(a1 + 1904);
  unint64_t v6 = *(void *)(a1 + 1872);
  if (v5 + 1 > 4 * v6)
  {
    re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::setBucketsCapacity((void *)(a1 + 1864), (v5 + 4) >> 2);
    unint64_t v6 = *(void *)(a1 + 1872);
  }
  if (v6 <= v5 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 1880)) {
    uint64_t v7 = a1 + 1888;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1896);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 2));
  ++*(void *)(a1 + 1904);
  ++*(_DWORD *)(a1 + 1912);
  uint64_t v9 = v8 + 96 * (v5 & 3);
  *(void *)(v9 + 32) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v9 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v9 + 16);
  *(void *)(v9 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v9 + 32);
  *(void *)(v9 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v9 + 24);
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v13 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v9 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v9 + 80) = v13;
  *(_OWORD *)(v9 + 48) = v12;
  uint64_t v14 = *(void *)(a1 + 1904);
  if (!v14)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::operator[](v4, v14 - 1);
}

uint64_t re::RealityDataPipe::tryGetVirtualEnvironmentProbeContext(re::RealityDataPipe *this)
{
  if (*((void *)this + 238)) {
    return re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::operator[]((uint64_t)this + 1864, 0);
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetVirtualEnvironmentProbeContextArray(re::RealityDataPipe *this)
{
  if (*((void *)this + 238)) {
    return (uint64_t)this + 1864;
  }
  else {
    return 0;
  }
}

uint64_t re::RealityDataPipe::tryGetVirtualEnvironmentProbeContextArrayRaw(re::RealityDataPipe *this)
{
  return (uint64_t)this + 1864;
}

void *re::BucketArray<re::DynamicArray<re::RenderProfilerText>,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::DynamicArray<re::RenderProfilerText>,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::DynamicArray<re::RenderProfilerText>,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 160, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::BlurPlanesRenderFrameData,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::BlurPlanesRenderFrameData,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::BlurPlanesRenderFrameData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 352, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::TintContext,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::TintContext,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::TintContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 128, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t *re::BucketArray<re::MeshSceneCollection,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::MeshSceneCollection,4ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::MeshSceneCollection,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 160, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::MeshDeformationCollection,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::MeshDeformationCollection,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::MeshDeformationCollection,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 224, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::StaticTextInfo,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::StaticTextInfo,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::StaticTextInfo,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 32, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::FilterViewMeshScenes,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::FilterViewMeshScenes,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::FilterViewMeshScenes,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 160, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::MeshSortingCollection,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::MeshSortingCollection,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::MeshSortingCollection,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 800, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::SceneCRWSReferencePosition,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::SceneCRWSReferencePosition,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::SceneCRWSReferencePosition,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 64, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::CameraStreamContext,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 1840 * (a2 & 3);
}

uint64_t re::BucketArray<re::SFBSystemShellBlurContext,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 32 * (a2 & 3);
}

uint64_t re::BucketArray<re::OpenSkyData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 208 * (a2 & 3);
}

uint64_t re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 272 * (a2 & 3);
}

uint64_t re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 352 * (a2 & 3);
}

uint64_t re::BucketArray<re::IBLContext,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 56 * (a2 & 3);
}

uint64_t re::BucketArray<re::MeshDeformationCollection,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::IBLContext,4ul>::operator[](a1, i);
      re::BucketArray<re::MeshDeformation,8ul>::deinit(v4);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::DynamicArray<re::VFXScene>,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](a1, i);
      re::DynamicArray<re::VFXScene>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

unint64_t re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + (a2 & 3);
}

uint64_t re::BucketArray<re::MeshSortingCollection,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 200 * (a2 & 3);
}

uint64_t re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) - (a2 & 3) + 8 * (a2 & 3);
}

uint64_t re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 96 * (a2 & 3);
}

void *re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 160, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::Slice<re::ClippingParametersEntry>,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 64, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::Slice<re::ClippingParametersEntry>,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::CameraStreamContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 7360, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::CameraStreamContext,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::move(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t)(a2 + 2);
  uint64_t v5 = *a2;
  uint64_t v6 = (uint64_t)(a1 + 2);
  if (*a2 >= (unint64_t)*a1)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *>(v4, v4 + 416 * *a1, v6);
    uint64_t v10 = *a1;
    if (*a1 != v5)
    {
      uint64_t v11 = 416 * v10;
      uint64_t v12 = v4 + 416 * v10;
      uint64_t v13 = v6 + v11;
      do
      {
        *(void *)uint64_t v13 = *(void *)v12;
        long long v14 = *(_OWORD *)(v12 + 16);
        long long v15 = *(_OWORD *)(v12 + 48);
        *(_OWORD *)(v13 + 32) = *(_OWORD *)(v12 + 32);
        *(_OWORD *)(v13 + 48) = v15;
        *(_OWORD *)(v13 + 16) = v14;
        long long v16 = *(_OWORD *)(v12 + 64);
        long long v17 = *(_OWORD *)(v12 + 80);
        long long v18 = *(_OWORD *)(v12 + 112);
        *(_OWORD *)(v13 + 96) = *(_OWORD *)(v12 + 96);
        *(_OWORD *)(v13 + 112) = v18;
        *(_OWORD *)(v13 + 64) = v16;
        *(_OWORD *)(v13 + 80) = v17;
        long long v19 = *(_OWORD *)(v12 + 128);
        long long v20 = *(_OWORD *)(v12 + 144);
        long long v21 = *(_OWORD *)(v12 + 176);
        *(_OWORD *)(v13 + 160) = *(_OWORD *)(v12 + 160);
        *(_OWORD *)(v13 + 176) = v21;
        *(_OWORD *)(v13 + 128) = v19;
        *(_OWORD *)(v13 + 144) = v20;
        *(void *)(v13 + 200) = 0;
        *(void *)(v13 + 208) = 0;
        *(void *)(v13 + 192) = 0;
        uint64_t v22 = *(void *)(v12 + 200);
        *(void *)(v13 + 192) = *(void *)(v12 + 192);
        *(void *)(v13 + 200) = v22;
        *(void *)(v12 + 192) = 0;
        *(void *)(v12 + 200) = 0;
        uint64_t v23 = *(void *)(v13 + 208);
        *(void *)(v13 + 208) = *(void *)(v12 + 208);
        *(void *)(v12 + 208) = v23;
        *(void *)(v13 + 216) = *(void *)(v12 + 216);
        *(void *)(v12 + 216) = 0;
        long long v24 = *(_OWORD *)(v12 + 336);
        long long v26 = *(_OWORD *)(v12 + 288);
        long long v25 = *(_OWORD *)(v12 + 304);
        *(_OWORD *)(v13 + 320) = *(_OWORD *)(v12 + 320);
        *(_OWORD *)(v13 + 336) = v24;
        *(_OWORD *)(v13 + 288) = v26;
        *(_OWORD *)(v13 + 304) = v25;
        long long v27 = *(_OWORD *)(v12 + 352);
        long long v28 = *(_OWORD *)(v12 + 368);
        long long v29 = *(_OWORD *)(v12 + 400);
        *(_OWORD *)(v13 + 384) = *(_OWORD *)(v12 + 384);
        *(_OWORD *)(v13 + 400) = v29;
        *(_OWORD *)(v13 + 352) = v27;
        *(_OWORD *)(v13 + 368) = v28;
        long long v30 = *(_OWORD *)(v12 + 240);
        long long v32 = *(_OWORD *)(v12 + 256);
        long long v31 = *(_OWORD *)(v12 + 272);
        *(_OWORD *)(v13 + 224) = *(_OWORD *)(v12 + 224);
        *(_OWORD *)(v13 + 240) = v30;
        *(_OWORD *)(v13 + 256) = v32;
        *(_OWORD *)(v13 + 272) = v31;
        v12 += 416;
        v13 += 416;
      }
      while (v12 != v4 + 416 * v5);
    }
  }
  else
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *>(v4, v4 + 416 * v5, v6);
    if (v5 != *a1)
    {
      uint64_t v7 = -416 * v5 + 416 * *a1;
      int v8 = &a1[52 * v5 + 26];
      do
      {
        unint64_t v9 = (void *)v8[3];
        if (v9)
        {

          v8[3] = 0;
        }
        re::FixedArray<CoreIKTransform>::deinit(v8);
        *(v8 - 24) = 0;
        v8 += 52;
        v7 -= 416;
      }
      while (v7);
    }
  }
  *a1 = v5;
  return re::DynamicInlineArray<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams>,4ul>::clear(a2);
}

__n128 std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *,re::KeyValuePair<re::WeakStringID,re::CameraStreamParams> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(void *)a3 = *(void *)v5;
      long long v6 = *(_OWORD *)(v5 + 16);
      long long v7 = *(_OWORD *)(v5 + 48);
      *(_OWORD *)(a3 + 32) = *(_OWORD *)(v5 + 32);
      *(_OWORD *)(a3 + 48) = v7;
      *(_OWORD *)(a3 + 16) = v6;
      long long v8 = *(_OWORD *)(v5 + 64);
      long long v9 = *(_OWORD *)(v5 + 80);
      long long v10 = *(_OWORD *)(v5 + 112);
      *(_OWORD *)(a3 + 96) = *(_OWORD *)(v5 + 96);
      *(_OWORD *)(a3 + 112) = v10;
      *(_OWORD *)(a3 + 64) = v8;
      *(_OWORD *)(a3 + 80) = v9;
      long long v11 = *(_OWORD *)(v5 + 128);
      long long v12 = *(_OWORD *)(v5 + 144);
      long long v13 = *(_OWORD *)(v5 + 176);
      *(_OWORD *)(a3 + 160) = *(_OWORD *)(v5 + 160);
      *(_OWORD *)(a3 + 176) = v13;
      *(_OWORD *)(a3 + 128) = v11;
      *(_OWORD *)(a3 + 144) = v12;
      re::FixedArray<float>::operator=((uint64_t *)(a3 + 192), (uint64_t *)(v5 + 192));
      NS::SharedPtr<MTL::Texture>::operator=((void **)(a3 + 216), (void **)(v5 + 216));
      long long v14 = *(_OWORD *)(v5 + 272);
      long long v16 = *(_OWORD *)(v5 + 224);
      long long v15 = *(_OWORD *)(v5 + 240);
      *(_OWORD *)(a3 + 256) = *(_OWORD *)(v5 + 256);
      *(_OWORD *)(a3 + 272) = v14;
      *(_OWORD *)(a3 + 224) = v16;
      *(_OWORD *)(a3 + 240) = v15;
      long long v17 = *(_OWORD *)(v5 + 336);
      long long v19 = *(_OWORD *)(v5 + 288);
      long long v18 = *(_OWORD *)(v5 + 304);
      *(_OWORD *)(a3 + 320) = *(_OWORD *)(v5 + 320);
      *(_OWORD *)(a3 + 336) = v17;
      *(_OWORD *)(a3 + 288) = v19;
      *(_OWORD *)(a3 + 304) = v18;
      __n128 result = *(__n128 *)(v5 + 384);
      long long v21 = *(_OWORD *)(v5 + 400);
      long long v23 = *(_OWORD *)(v5 + 352);
      long long v22 = *(_OWORD *)(v5 + 368);
      *(__n128 *)(a3 + 384) = result;
      *(_OWORD *)(a3 + 400) = v21;
      *(_OWORD *)(a3 + 352) = v23;
      *(_OWORD *)(a3 + 368) = v22;
      v5 += 416;
      a3 += 416;
    }
    while (v5 != a2);
  }
  return result;
}

void *re::BucketArray<re::SFBSystemShellBlurContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 128, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::SFBSystemShellBlurContext,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::OpenSkyData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 832, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::OpenSkyData,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1088, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::ProjectiveShadowBuilderInputGlobalData,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1408, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::ProjectiveMeshShadowBuilderInputGlobalData,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::MeshShadowPerFrameUpdateData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 2624, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::MeshShadowPerFrameUpdateData,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<re::IBLContext,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::IBLContext,4ul>::setBucketsCapacity((void *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 56 * (v2 & 3);
}

void *re::BucketArray<re::IBLContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 224, 0);
          long long v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::IBLContext,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<re::MeshSceneCollection,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::MeshSceneCollection,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 40 * (v2 & 3);
}

uint64_t re::DynamicArray<re::MeshScene>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshScene>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshScene>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshScene>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshScene>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshScene *,re::MeshScene *,re::MeshScene *>((uint64_t)&v43, *(void *)(a2 + 32), *(void *)(a2 + 32) + 656 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = v9 + 656 * v4;
      uint64_t v11 = a1[4];
      uint64_t v12 = 656 * v8;
      do
      {
        uint64_t v13 = v11 + v12;
        uint64_t v14 = v9 + v12;
        long long v15 = *(_OWORD *)(v9 + v12);
        long long v16 = *(_OWORD *)(v9 + v12 + 16);
        long long v17 = *(_OWORD *)(v9 + v12 + 48);
        *(_OWORD *)(v13 + 32) = *(_OWORD *)(v9 + v12 + 32);
        *(_OWORD *)(v13 + 48) = v17;
        *(_OWORD *)uint64_t v13 = v15;
        *(_OWORD *)(v13 + 16) = v16;
        long long v18 = *(_OWORD *)(v9 + v12 + 64);
        long long v19 = *(_OWORD *)(v9 + v12 + 80);
        long long v20 = *(_OWORD *)(v9 + v12 + 112);
        *(_OWORD *)(v13 + 96) = *(_OWORD *)(v9 + v12 + 96);
        *(_OWORD *)(v13 + 112) = v20;
        *(_OWORD *)(v13 + 64) = v18;
        *(_OWORD *)(v13 + 80) = v19;
        long long v21 = *(_OWORD *)(v9 + v12 + 128);
        long long v22 = *(_OWORD *)(v9 + v12 + 144);
        long long v23 = *(_OWORD *)(v9 + v12 + 176);
        *(_OWORD *)(v13 + 160) = *(_OWORD *)(v9 + v12 + 160);
        *(_OWORD *)(v13 + 176) = v23;
        *(_OWORD *)(v13 + 128) = v21;
        *(_OWORD *)(v13 + 144) = v22;
        long long v24 = *(_OWORD *)(v9 + v12 + 192);
        long long v25 = *(_OWORD *)(v9 + v12 + 208);
        long long v26 = *(_OWORD *)(v9 + v12 + 240);
        *(_OWORD *)(v13 + 224) = *(_OWORD *)(v9 + v12 + 224);
        *(_OWORD *)(v13 + 240) = v26;
        *(_OWORD *)(v13 + 192) = v24;
        *(_OWORD *)(v13 + 208) = v25;
        re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::HashBrown(v11 + v12 + 256, (uint64_t *)(v9 + v12 + 256));
        *(_DWORD *)(v13 + 320) = *(_DWORD *)(v9 + v12 + 320);
        int v27 = *(unsigned __int8 *)(v9 + v12 + 328);
        *(unsigned char *)(v13 + 328) = v27;
        if (v27) {
          *(void *)(v13 + 336) = *(void *)(v14 + 336);
        }
        *(_OWORD *)(v13 + 344) = *(_OWORD *)(v14 + 344);
        long long v28 = *(_OWORD *)(v14 + 360);
        long long v29 = *(_OWORD *)(v14 + 376);
        long long v30 = *(_OWORD *)(v14 + 408);
        *(_OWORD *)(v13 + 392) = *(_OWORD *)(v14 + 392);
        *(_OWORD *)(v13 + 408) = v30;
        *(_OWORD *)(v13 + 360) = v28;
        *(_OWORD *)(v13 + 376) = v29;
        long long v31 = *(_OWORD *)(v14 + 424);
        long long v32 = *(_OWORD *)(v14 + 440);
        long long v33 = *(_OWORD *)(v14 + 472);
        *(_OWORD *)(v13 + 456) = *(_OWORD *)(v14 + 456);
        *(_OWORD *)(v13 + 472) = v33;
        *(_OWORD *)(v13 + 424) = v31;
        *(_OWORD *)(v13 + 440) = v32;
        int v34 = *(unsigned __int8 *)(v14 + 496);
        *(unsigned char *)(v13 + 496) = v34;
        if (v34)
        {
          uint64_t v35 = v11 + v12;
          long long v36 = *(_OWORD *)(v9 + v12 + 528);
          *(_OWORD *)(v35 + 512) = *(_OWORD *)(v9 + v12 + 512);
          *(_OWORD *)(v35 + 528) = v36;
        }
        *(void *)(v13 + 544) = *(void *)(v14 + 544);
        int v37 = *(unsigned __int8 *)(v14 + 560);
        *(unsigned char *)(v13 + 560) = v37;
        if (v37)
        {
          uint64_t v38 = (_OWORD *)(v11 + v12);
          long long v39 = *(_OWORD *)(v9 + v12 + 576);
          long long v40 = *(_OWORD *)(v9 + v12 + 592);
          long long v41 = *(_OWORD *)(v9 + v12 + 624);
          v38[38] = *(_OWORD *)(v9 + v12 + 608);
          v38[39] = v41;
          v38[36] = v39;
          v38[37] = v40;
        }
        *(void *)(v13 + 640) = *(void *)(v14 + 640);
        v11 += 656;
        v9 += 656;
      }
      while (v14 + 656 != v10);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshScene *,re::MeshScene *,re::MeshScene *>((uint64_t)&v42, *(void *)(a2 + 32), *(void *)(a2 + 32) + 656 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = -656 * v4 + 656 * v5;
      uint64_t v7 = 656 * v4 + a1[4] + 256;
      do
      {
        re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(v7);
        v7 += 656;
        v6 -= 656;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshScene *,re::MeshScene *,re::MeshScene *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    uint64_t v8 = a4 + v7;
    uint64_t v9 = a2 + v7;
    long long v10 = *(_OWORD *)(a2 + v7);
    long long v11 = *(_OWORD *)(a2 + v7 + 16);
    long long v12 = *(_OWORD *)(a2 + v7 + 48);
    *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + v7 + 32);
    *(_OWORD *)(v8 + 48) = v12;
    *(_OWORD *)uint64_t v8 = v10;
    *(_OWORD *)(v8 + 16) = v11;
    long long v13 = *(_OWORD *)(a2 + v7 + 64);
    long long v14 = *(_OWORD *)(a2 + v7 + 80);
    long long v15 = *(_OWORD *)(a2 + v7 + 112);
    *(_OWORD *)(v8 + 96) = *(_OWORD *)(a2 + v7 + 96);
    *(_OWORD *)(v8 + 112) = v15;
    *(_OWORD *)(v8 + 64) = v13;
    *(_OWORD *)(v8 + 80) = v14;
    long long v16 = *(_OWORD *)(a2 + v7 + 128);
    long long v17 = *(_OWORD *)(a2 + v7 + 144);
    long long v18 = *(_OWORD *)(a2 + v7 + 176);
    *(_OWORD *)(v8 + 160) = *(_OWORD *)(a2 + v7 + 160);
    *(_OWORD *)(v8 + 176) = v18;
    *(_OWORD *)(v8 + 128) = v16;
    *(_OWORD *)(v8 + 144) = v17;
    long long v19 = *(_OWORD *)(a2 + v7 + 192);
    long long v20 = *(_OWORD *)(a2 + v7 + 208);
    long long v21 = *(_OWORD *)(a2 + v7 + 240);
    *(_OWORD *)(v8 + 224) = *(_OWORD *)(a2 + v7 + 224);
    *(_OWORD *)(v8 + 240) = v21;
    *(_OWORD *)(v8 + 192) = v19;
    *(_OWORD *)(v8 + 208) = v20;
    if (a4 != a2) {
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::copy((_anonymous_namespace_ *)(v8 + 256), (uint64_t *)(v9 + 256));
    }
    *(_DWORD *)(v8 + 320) = *(_DWORD *)(v9 + 320);
    if (*(unsigned char *)(v8 + 328) || *(unsigned char *)(v9 + 328))
    {
      if (!*(unsigned char *)(v8 + 328) || *(unsigned char *)(v9 + 328))
      {
        if (*(unsigned char *)(v8 + 328) || !*(unsigned char *)(v9 + 328))
        {
          *(void *)(a4 + v7 + 336) = *(void *)(a2 + v7 + 336);
        }
        else
        {
          *(unsigned char *)(v8 + 328) = 1;
          *(void *)(a4 + v7 + 336) = *(void *)(a2 + v7 + 336);
        }
      }
      else
      {
        *(unsigned char *)(v8 + 328) = 0;
      }
    }
    uint64_t v22 = a4 + v7;
    long long v23 = (_OWORD *)(a4 + v7 + 344);
    *long long v23 = *(_OWORD *)(v9 + 344);
    long long v24 = *(_OWORD *)(v9 + 360);
    long long v25 = *(_OWORD *)(v9 + 376);
    long long v26 = *(_OWORD *)(v9 + 408);
    void v23[3] = *(_OWORD *)(v9 + 392);
    unsigned char v23[4] = v26;
    v23[1] = v24;
    v23[2] = v25;
    long long v27 = *(_OWORD *)(v9 + 424);
    long long v28 = *(_OWORD *)(v9 + 440);
    long long v29 = *(_OWORD *)(v9 + 472);
    v23[7] = *(_OWORD *)(v9 + 456);
    v23[8] = v29;
    v23[5] = v27;
    v23[6] = v28;
    if (*(unsigned char *)(a4 + v7 + 496) || *(unsigned char *)(v9 + 496))
    {
      if (!*(unsigned char *)(a4 + v7 + 496) || *(unsigned char *)(v9 + 496))
      {
        if (!*(unsigned char *)(a4 + v7 + 496) && *(unsigned char *)(v9 + 496)) {
          *(unsigned char *)(v22 + 496) = 1;
        }
        long long v30 = *(_OWORD *)(a2 + v7 + 528);
        *(_OWORD *)(a4 + v7 + 512) = *(_OWORD *)(a2 + v7 + 512);
        *(_OWORD *)(a4 + v7 + 528) = v30;
      }
      else
      {
        *(unsigned char *)(v22 + 496) = 0;
      }
    }
    uint64_t v31 = a4 + v7;
    *(void *)(a4 + v7 + 544) = *(void *)(v9 + 544);
    if (*(unsigned char *)(a4 + v7 + 560) || *(unsigned char *)(v9 + 560))
    {
      if (!*(unsigned char *)(a4 + v7 + 560) || *(unsigned char *)(v9 + 560))
      {
        if (!*(unsigned char *)(a4 + v7 + 560) && *(unsigned char *)(v9 + 560)) {
          *(unsigned char *)(v31 + 560) = 1;
        }
        long long v32 = *(_OWORD *)(a2 + v7 + 576);
        long long v33 = *(_OWORD *)(a2 + v7 + 592);
        long long v34 = *(_OWORD *)(a2 + v7 + 624);
        *(_OWORD *)(a4 + v7 + 608) = *(_OWORD *)(a2 + v7 + 608);
        *(_OWORD *)(a4 + v7 + 624) = v34;
        *(_OWORD *)(a4 + v7 + 576) = v32;
        *(_OWORD *)(a4 + v7 + 592) = v33;
      }
      else
      {
        *(unsigned char *)(v31 + 560) = 0;
      }
    }
    *(void *)(a4 + v7 + 640) = *(void *)(v9 + 640);
    v7 += 656;
  }
  while (v9 + 656 != v6);
  return v6;
}

uint64_t re::BucketArray<re::MeshDeformationCollection,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::MeshDeformationCollection,4ul>::setBucketsCapacity((void *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 56 * (v2 & 3);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation const&,re::BucketArray<re::MeshDeformation,8ul> const&,true>,re::BucketArray<re::MeshDeformation,8ul>::BucketArrayIterator<re::MeshDeformation,re::MeshDeformation&,re::BucketArray<re::MeshDeformation,8ul>&,true>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  long long v12 = (void *)result;
  if (a2 != a4 || a3 != a5)
  {
    unint64_t v13 = a5 - 1;
    do
    {
      do
      {
        unint64_t v14 = a3;
        uint64_t v15 = re::BucketArray<re::MeshDeformation,8ul>::operator[](a2, a3);
        __n128 result = re::BucketArray<re::MeshDeformation,8ul>::operator[](a6, a7);
        long long v17 = *(_OWORD *)(v15 + 16);
        long long v16 = *(_OWORD *)(v15 + 32);
        *(_OWORD *)__n128 result = *(_OWORD *)v15;
        *(_OWORD *)(result + 16) = v17;
        *(_OWORD *)(result + 32) = v16;
        long long v19 = *(_OWORD *)(v15 + 64);
        long long v18 = *(_OWORD *)(v15 + 80);
        long long v20 = *(_OWORD *)(v15 + 48);
        *(void *)(result + 96) = *(void *)(v15 + 96);
        *(_OWORD *)(result + 64) = v19;
        *(_OWORD *)(result + 80) = v18;
        *(_OWORD *)(result + 48) = v20;
        a3 = v14 + 1;
        ++a7;
      }
      while (a2 != a4);
    }
    while (v13 != v14);
    a3 = a5;
  }
  *long long v12 = a2;
  v12[1] = a3;
  v12[2] = a6;
  void v12[3] = a7;
  return result;
}

uint64_t re::BucketArray<re::DynamicArray<re::RenderGraphFileProvider>,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::MipmapGenerationContext,4ul>::setBucketsCapacity((void *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 40 * (v2 & 3);
}

void *re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 4, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::ProbeLightingEnabledMetadata,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 28, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<SceneUnderstandingFlagEmitterData,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 384, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    __n128 result = (void *)re::BucketArray<re::VirtualEnvironmentProbeContext,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::allocInfo_RenderGraphSelectionParams(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_442, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_442))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A958, "RenderGraphSelectionParams");
    __cxa_guard_release(&_MergedGlobals_442);
  }
  return &unk_26AF9A958;
}

void re::initInfo_RenderGraphSelectionParams(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0x5F078B5A7D39B3B4;
  v9[1] = "RenderGraphSelectionParams";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A8E8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A8E8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphData((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphData";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A8E0 = v7;
      __cxa_guard_release(&qword_26AF9A8E8);
    }
  }
  *((void *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF9A8E0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphSelectionParams>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphSelectionParams>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphSelectionParams>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphSelectionParams>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

int32x4_t re::internal::defaultConstruct<re::RenderGraphSelectionParams>(uint64_t a1, uint64_t a2, int32x4_t *a3)
{
  a3->i64[0] = (uint64_t)&unk_26E719590;
  a3->i64[1] = -1;
  a3[1].i64[0] = -1;
  a3[1].i64[1] = 0xFFFFFFFF00000000;
  a3[2].i32[0] = -1;
  int32x4_t result = vdupq_n_s32(0x7FC00000u);
  a3[3] = result;
  a3[4] = result;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphSelectionParams>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

int32x4_t re::internal::defaultConstructV2<re::RenderGraphSelectionParams>(int32x4_t *a1)
{
  a1->i64[0] = (uint64_t)&unk_26E719590;
  a1->i64[1] = -1;
  a1[1].i64[0] = -1;
  a1[1].i64[1] = 0xFFFFFFFF00000000;
  a1[2].i32[0] = -1;
  int32x4_t result = vdupq_n_s32(0x7FC00000u);
  a1[3] = result;
  a1[4] = result;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphSelectionParams>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

re::RenderGraphSelectionEmitter *re::RenderGraphSelectionEmitter::RenderGraphSelectionEmitter(re::RenderGraphSelectionEmitter *this)
{
  *((unsigned char *)this + 8) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(void *)((char *)this + 124) = 0x7FFFFFFFLL;
  *(void *)this = &unk_26E719530;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 56) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_DWORD *)this + 46) = 0;
  *(void *)((char *)this + 276) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((void *)this + 44) = &unk_26E719590;
  *((void *)this + 45) = -1;
  *((void *)this + 46) = -1;
  *((void *)this + 47) = 0xFFFFFFFF00000000;
  *((_DWORD *)this + 96) = -1;
  int32x4_t v2 = vdupq_n_s32(0x7FC00000u);
  *((int32x4_t *)this + 25) = v2;
  *((int32x4_t *)this + 26) = v2;
  re::StringID::invalid((re::RenderGraphSelectionEmitter *)((char *)this + 432));
  *((void *)this + 56) = 0;
  *((void *)this + 57) = 0;
  *((void *)this + 58) = "";
  return this;
}

uint64_t re::RenderGraphSelectionEmitter::handleRenderFrameData(uint64_t this, re::RenderFrame *a2)
{
  uint64_t v3 = this;
  uint64_t v52[2] = *MEMORY[0x263EF8340];
  uint64_t v4 = *((unsigned int *)a2 + 74);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)*((void *)a2 + 35);
    while (1)
    {
      int v7 = *v6;
      v6 += 18;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)a2 + 74);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    long long v8 = (re::RenderFrame *)((char *)a2 + 264);
    uint64_t v9 = v5;
    long long v10 = (void *)(this + 456);
    uint64_t v11 = *((void *)a2 + 35);
    int v44 = *((_DWORD *)a2 + 74);
    int8x8_t v45 = (re::RenderFrame *)((char *)a2 + 264);
    char v43 = (void *)(this + 456);
    do
    {
      unint64_t v12 = (const re::WeakStringID *)(v11 + 72 * v9 + 8);
      uint64_t v13 = **(void **)(re::RenderFrameData::stream(v8, v12) + 48);
      this = (*(uint64_t (**)(void))(v13 + 520))();
      uint64_t v15 = this;
      if (*v10 <= 1uLL)
      {
        unint64_t v16 = *(unsigned char **)(v3 + 464);
        if (v16)
        {
          if (!*v16) {
            goto LABEL_17;
          }
        }
      }
      if (this)
      {
        if (!*(void *)(this + 40))
        {
          re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 761);
          _os_crash();
          __break(1u);
LABEL_49:
          re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 761);
          _os_crash();
          __break(1u);
LABEL_50:
          std::__throw_bad_function_call[abi:nn180100]();
        }
        uint64_t v17 = re::BucketArray<re::SceneName,4ul>::operator[](this, v14);
        this = re::StringID::operator==((void *)(v17 + 8), v10);
        if (this)
        {
          if (!*(void *)(v15 + 40)) {
            goto LABEL_49;
          }
          this = re::BucketArray<re::SceneName,4ul>::operator[](v15, v18);
          if (!*(void *)(this + 24))
          {
LABEL_17:
            strcpy((char *)v52, "Selection");
            strcpy((char *)v51, "Selection");
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A900, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_26AF9A900))
            {
              qword_26AF9A8F8 = re::getCombinedScopeHash((re *)v52, (const char *)v51, v42);
              __cxa_guard_release(&qword_26AF9A900);
            }
            v49[0] = &unk_26E719AC0;
            v49[1] = v3;
            uint64_t v50 = v49;
            uint64_t v19 = re::RenderFrameData::stream(v8, v12);
            long long v20 = (uint64_t (**)(uint64_t, void, void, void *, void *))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v19, (uint64_t *)&v46);
            if (v20)
            {
              if (v21)
              {
                uint64_t v22 = *(void *)(v21 + 40);
                if (v22)
                {
                  unint64_t v23 = 0;
                  do
                  {
                    uint64_t v24 = re::BucketArray<unsigned long,4ul>::operator[](v21, v23);
                    if (!v50) {
                      goto LABEL_50;
                    }
                    (*(void (**)(void *, re::RenderFrame *, char *, uint64_t))(*v50 + 48))(v50, a2, (char *)a2 + 32, v24);
                  }
                  while (v22 != ++v23);
                }
              }
            }
            if (v50 == v49)
            {
              (*(void (**)(void *))(v49[0] + 32))(v49);
              long long v25 = v45;
            }
            else
            {
              long long v25 = v45;
              if (v50) {
                (*(void (**)(void))(*v50 + 40))();
              }
            }
            *(void *)uint64_t v48 = v52[0];
            *(_WORD *)&v48[8] = v52[1];
            *(void *)&v48[10] = v51[0];
            *(_WORD *)&v48[18] = v51[1];
            long long v26 = (char *)operator new(0x28uLL);
            *(void *)long long v26 = &unk_26E719B78;
            *(_OWORD *)(v26 + 8) = *(_OWORD *)v48;
            *((void *)v26 + 3) = *(void *)&v48[16];
            *((void *)v26 + 4) = v3;
            uint64_t v4 = v3;
            uint64_t v27 = **(void **)(re::RenderFrameData::stream(v25, v12) + 48);
            uint64_t v28 = (*(uint64_t (**)(void))(v27 + 632))();
            if (v28)
            {
              uint64_t v29 = v28;
              uint64_t v30 = *(void *)(v28 + 40);
              if (v30)
              {
                for (unint64_t i = 0; i != v30; ++i)
                {
                  uint64_t v32 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v29, i);
                  (*(void (**)(char *, re::RenderFrame *, char *, uint64_t))(*(void *)v26 + 48))(v26, a2, (char *)a2 + 32, v32);
                }
              }
            }
            (*(void (**)(char *))(*(void *)v26 + 40))(v26);
            *(void *)uint64_t v47 = v52[0];
            *(_WORD *)&v47[8] = v52[1];
            *(void *)&v47[10] = v51[0];
            *(_WORD *)&v47[18] = v51[1];
            long long v33 = (char *)operator new(0x28uLL);
            *(void *)long long v33 = &unk_26E719C48;
            *(_OWORD *)(v33 + 8) = *(_OWORD *)v47;
            *((void *)v33 + 3) = *(void *)&v47[16];
            *((void *)v33 + 4) = v4;
            uint64_t v34 = **(void **)(re::RenderFrameData::stream(v45, v12) + 48);
            uint64_t v35 = (*(uint64_t (**)(void))(v34 + 664))();
            if (v35)
            {
              uint64_t v36 = v35;
              uint64_t v37 = *(void *)(v35 + 40);
              if (v37)
              {
                for (unint64_t j = 0; j != v37; ++j)
                {
                  uint64_t v39 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v36, j);
                  (*(void (**)(char *, re::RenderFrame *, char *, uint64_t))(*(void *)v33 + 48))(v33, a2, (char *)a2 + 32, v39);
                }
              }
            }
            this = (*(uint64_t (**)(char *))(*(void *)v33 + 40))(v33);
            uint64_t v3 = v4;
            LODWORD(v4) = v44;
            long long v8 = v45;
            long long v10 = v43;
          }
        }
      }
      uint64_t v11 = *((void *)a2 + 35);
      if (*((_DWORD *)a2 + 74) <= (v5 + 1)) {
        int v40 = v5 + 1;
      }
      else {
        int v40 = *((_DWORD *)a2 + 74);
      }
      while (1)
      {
        uint64_t v9 = (v5 + 1);
        if (v40 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        int v41 = v9;
        if ((*(_DWORD *)(v11 + 72 * v9) & 0x80000000) != 0) {
          goto LABEL_44;
        }
      }
      int v41 = v40;
LABEL_44:
      LODWORD(v5) = v41;
    }
    while (v4 != v41);
  }
  return this;
}

uint64_t *re::DynamicInlineArray<re::RenderCamera,2ul>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *a2;
    unint64_t v4 = *a1;
    if (*a2 >= (unint64_t)*a1)
    {
      uint64_t v5 = a2 + 2;
      uint64_t v6 = &a2[4 * v4 + 2];
      int v7 = a1 + 2;
      if (v4) {
        memmove(a1 + 2, a2 + 2, 32 * v4);
      }
      memcpy(&v7[4 * v4], v6, (char *)&v5[4 * v3] - (char *)v6);
    }
    else if (v3)
    {
      memmove(a1 + 2, a2 + 2, 32 * v3);
    }
    *a1 = v3;
    ++*((_DWORD *)a1 + 2);
  }
  return a1;
}

uint64_t *re::DynamicInlineArray<re::Projection,2ul>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *a2;
    unint64_t v4 = *a1;
    if (*a2 >= (unint64_t)*a1)
    {
      uint64_t v5 = a2 + 2;
      uint64_t v6 = &a2[8 * v4 + 2];
      int v7 = a1 + 2;
      if (v4) {
        memmove(a1 + 2, a2 + 2, v4 << 6);
      }
      memcpy(&v7[8 * v4], v6, (char *)&v5[8 * v3] - (char *)v6);
    }
    else if (v3)
    {
      memmove(a1 + 2, a2 + 2, v3 << 6);
    }
    *a1 = v3;
    ++*((_DWORD *)a1 + 2);
  }
  return a1;
}

re *re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphSelectionEmitter *this, re::RenderGraphManager *a2, AssetService *a3)
{
  v18[5] = *MEMORY[0x263EF8340];
  int32x4_t result = (re *)re::FontID::isValid((re::RenderGraphSelectionEmitter *)((char *)this + 432));
  if ((result & 1) == 0)
  {
    uint64_t v6 = re::globalAllocators(result);
    uint64_t v7 = v6[2];
    v18[0] = &unk_26E719628;
    v18[1] = this;
    void v18[3] = v7;
    v18[4] = v18;
    uint64_t v8 = re::globalAllocators((re *)v6)[2];
    v17[0] = &unk_26E719690;
    v17[1] = this;
    void v17[3] = v8;
    v17[4] = v17;
    re::RenderGraphManager::addProvider(a2, "Selection", (uint64_t)v18, (uint64_t)v17, 0, (uint64_t)&v13);
    uint64_t v9 = v13;
    long long v10 = v14;
    uint64_t v13 = 0;
    uint64_t v14 = "";
    uint64_t v11 = *((void *)this + 54);
    uint64_t v12 = *((void *)this + 55);
    *((void *)this + 54) = v9;
    *((void *)this + 55) = v10;
    v16[0] = v9 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
    v16[1] = v12;
    re::StringID::destroyString((re::StringID *)v16);
    *((void *)this + 56) = v15;
    re::StringID::destroyString((re::StringID *)&v13);
    re::FunctionBase<24ul,void ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v17);
    return (re *)re::FunctionBase<24ul,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v18);
  }
  return result;
}

void re::RenderGraphSelectionEmitter::unregisterProviders(re::RenderGraphSelectionEmitter *this, re::RenderGraphManager *a2)
{
  unint64_t v4 = (StringID *)((char *)this + 432);
  if (re::FontID::isValid((re::RenderGraphSelectionEmitter *)((char *)this + 432)))
  {
    re::StringID::StringID((re::StringID *)v5, v4);
    uint64_t v6 = *((void *)this + 56);
    re::RenderGraphManager::removeProvider((uint64_t)a2, (uint64_t)v5);
    re::StringID::destroyString((re::StringID *)v5);
    re::ProviderHandle::invalidate((re::ProviderHandle *)v4);
  }
}

void re::ProviderHandle::invalidate(re::ProviderHandle *this)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  re::StringID::invalid((re::StringID *)&v6);
  uint64_t v2 = v6;
  uint64_t v3 = v7;
  uint64_t v7 = "";
  uint64_t v8 = 0;
  uint64_t v6 = 0;
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *((void *)this + 1);
  *(void *)this = v2;
  *((void *)this + 1) = v3;
  v9[0] = v2 & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  v9[1] = v5;
  re::StringID::destroyString((re::StringID *)v9);
  *((void *)this + 2) = v8;
  re::StringID::destroyString((re::StringID *)&v6);
}

void *re::RenderGraphSelectionEmitter::addSelectionCompleteCallback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v7[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = *a2;
  v7[3] = 0;
  uint64_t v6 = v4;
  std::function<void ()(re::Slice<unsigned long long> const&)>::operator=(v7, a3);
  re::DynamicArray<re::SelectionCompleteHandler>::add((_anonymous_namespace_ *)(a1 + 160), &v6);
  return std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](v7);
}

void *std::function<void ()(re::Slice<unsigned long long> const&)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::__value_func[abi:nn180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::swap[abi:nn180100](v4, a1);
  std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](v4);
  return a1;
}

uint64_t re::DynamicArray<re::SelectionCompleteHandler>::add(_anonymous_namespace_ *this, void *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SelectionCompleteHandler>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = (void *)(*((void *)this + 4) + 40 * v4);
  *uint64_t v5 = *a2;
  uint64_t result = std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::__value_func[abi:nn180100]((uint64_t)(v5 + 1), (uint64_t)(a2 + 1));
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::RenderGraphSelectionEmitter::addSelectionConcludeCallback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v7[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = *a2;
  v7[3] = 0;
  uint64_t v6 = v4;
  std::function<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::operator=(v7, a3);
  re::DynamicArray<re::SelectionConcludeHandler>::add((_anonymous_namespace_ *)(a1 + 200), &v6);
  return std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](v7);
}

void *std::function<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::__value_func[abi:nn180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::swap[abi:nn180100](v4, a1);
  std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](v4);
  return a1;
}

uint64_t re::DynamicArray<re::SelectionConcludeHandler>::add(_anonymous_namespace_ *this, void *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SelectionConcludeHandler>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = (void *)(*((void *)this + 4) + 40 * v4);
  *uint64_t v5 = *a2;
  uint64_t result = std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::__value_func[abi:nn180100]((uint64_t)(v5 + 1), (uint64_t)(a2 + 1));
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::RenderGraphSelectionEmitter::setFilteredEntityIDSet(re::RenderGraphSelectionEmitter *this, const __CFArray *a2)
{
  uint64_t v3 = (char *)this + 240;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)this + 240);
  uint64_t result = CFArrayGetCount(a2);
  if (result >= 1)
  {
    uint64_t v5 = result;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, i);
      uint64_t valuePtr = 0;
      uint64_t result = CFNumberGetValue(ValueAtIndex, kCFNumberLongLongType, &valuePtr);
      if (result) {
        uint64_t result = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v3, &valuePtr);
      }
    }
  }
  return result;
}

void *re::allocInfo_RenderGraphSelectionEmitter(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A908, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A908))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9A9D0, "RenderGraphSelectionEmitter");
    __cxa_guard_release(&qword_26AF9A908);
  }
  return &unk_26AF9A9D0;
}

void re::initInfo_RenderGraphSelectionEmitter(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x81E9DFF0C63BCB34;
  v13[1] = "RenderGraphSelectionEmitter";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A910, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9A910);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphEmitterBase((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphEmitterBase";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9A948 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      long long v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "selectionMaterial";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x8800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9A950 = v11;
      __cxa_guard_release(&qword_26AF9A910);
    }
  }
  *((void *)this + 2) = 0x1E000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9A948;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphSelectionEmitter>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphSelectionEmitter>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphSelectionEmitter>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphSelectionEmitter>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

re::RenderGraphSelectionEmitter *re::internal::defaultConstruct<re::RenderGraphSelectionEmitter>(int a1, int a2, re::RenderGraphSelectionEmitter *this)
{
  return re::RenderGraphSelectionEmitter::RenderGraphSelectionEmitter(this);
}

void re::internal::defaultDestruct<re::RenderGraphSelectionEmitter>(int a1, int a2, re::RenderGraphSelectionEmitter *this)
{
}

uint64_t re::introspect_RenderGraphSelectionEmitter(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphSelectionEmitter", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphSelectionEmitter, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphSelectionEmitter, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphSelectionEmitter>, this);
}

void re::RenderGraphSelectionEmitter::~RenderGraphSelectionEmitter(re::RenderGraphSelectionEmitter *this)
{
  re::RenderGraphSelectionEmitter::~RenderGraphSelectionEmitter(this);
  JUMPOUT(0x237DBCBD0);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t vars8;

  re::StringID::destroyString((re::RenderGraphSelectionEmitter *)((char *)this + 456));
  re::StringID::destroyString((re::RenderGraphSelectionEmitter *)((char *)this + 432));
  uint64_t v2 = (void *)*((void *)this + 43);
  if (v2)
  {

    *((void *)this + 43) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 42);
  if (v3)
  {

    *((void *)this + 42) = 0;
  }
  unint64_t v4 = (void *)*((void *)this + 41);
  if (v4)
  {

    *((void *)this + 41) = 0;
  }
  uint64_t v5 = (void *)*((void *)this + 40);
  if (v5)
  {

    *((void *)this + 40) = 0;
  }
  uint64_t v6 = (void *)*((void *)this + 39);
  if (v6)
  {

    *((void *)this + 39) = 0;
  }
  uint64_t v7 = (void *)*((void *)this + 38);
  if (v7)
  {

    *((void *)this + 38) = 0;
  }
  uint64_t v8 = (void *)*((void *)this + 37);
  if (v8)
  {

    *((void *)this + 37) = 0;
  }
  uint64_t v9 = (void *)*((void *)this + 36);
  if (v9)
  {

    *((void *)this + 36) = 0;
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 30);
  re::DynamicArray<re::SelectionConcludeHandler>::deinit((uint64_t)this + 200);
  re::DynamicArray<re::SelectionCompleteHandler>::deinit((uint64_t)this + 160);
  re::AssetHandle::~AssetHandle((re::RenderGraphSelectionEmitter *)((char *)this + 136));
  re::RenderGraphEmitterBase::~RenderGraphEmitterBase(this);
}

void re::RenderGraphSelectionParams::~RenderGraphSelectionParams(re::RenderGraphSelectionParams *this)
{
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::prepareForRendering(char const*,char const*,re::RenderFrame &)::$_0,void ()(re::FrameCount)>::~Callable()
{
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::prepareForRendering(char const*,char const*,re::RenderFrame &)::$_0,void ()(re::FrameCount)>::operator()(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  uint64_t v4 = a1[1];
  uint64_t v41 = 0;
  v38[1] = 0;
  uint64_t v39 = 0;
  v38[0] = 0;
  int v40 = 0;
  if (*(void *)(v4 + 176))
  {
    a1 = *(void **)(v4 + 288);
    if (a1)
    {
      unint64_t v5 = *(void *)(v2[2] + 16);
      a1 = objc_msgSend(a1, sel_contents);
      if (v5 >= 5)
      {
        uint64_t v6 = a1;
        unint64_t v7 = 0;
        unint64_t v8 = v5 / 5;
        do
        {
          if (v6[v7])
          {
            v32[0] = 0;
            uint64_t v9 = v2[2];
            unint64_t v10 = *(void *)(v9 + 16);
            if (v10 <= v7)
            {
              uint64_t v33 = 0;
              long long v48 = 0u;
              long long v49 = 0u;
              long long v46 = 0u;
              long long v47 = 0u;
              long long v45 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)char v42 = 136315906;
              *(void *)&v42[4] = "operator[]";
              *(_WORD *)&v42[12] = 1024;
              *(_DWORD *)&v42[14] = 789;
              *(_WORD *)&v42[18] = 2048;
              *(void *)&v42[20] = v7;
              __int16 v43 = 2048;
              *(void *)int v44 = v10;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_63:
              std::__throw_bad_function_call[abi:nn180100]();
            }
            v32[0] = *(void *)(*(void *)(v9 + 32) + 8 * v7);
            a1 = re::DynamicArray<re::TransitionCondition *>::add(v38, v32);
          }
          ++v7;
        }
        while (v8 != v7);
      }
    }
  }
  *(void *)&v44[2] = 0;
  memset(v42, 0, sizeof(v42));
  if (*(void *)(v4 + 216))
  {
    a1 = *(void **)(v4 + 296);
    if (a1)
    {
      if (*(void *)(v4 + 304))
      {
        if (*(void *)(v4 + 312))
        {
          if (*(void *)(v4 + 320))
          {
            if (*(void *)(v4 + 328))
            {
              if (*(void *)(v4 + 336))
              {
                if (*(void *)(v4 + 344))
                {
                  uint64_t v11 = *objc_msgSend(a1, sel_contents);
                  *(void *)&long long v45 = v11;
                  long long v46 = *(_OWORD *)objc_msgSend(*(id *)(v4 + 304), sel_contents);
                  long long v47 = *(_OWORD *)objc_msgSend(*(id *)(v4 + 312), sel_contents);
                  *(void *)&long long v48 = *objc_msgSend(*(id *)(v4 + 320), sel_contents);
                  DWORD2(v48) = *(_DWORD *)objc_msgSend(*(id *)(v4 + 328), sel_contents);
                  HIDWORD(v48) = *(_DWORD *)objc_msgSend(*(id *)(v4 + 336), sel_contents);
                  a1 = objc_msgSend(*(id *)(v4 + 344), sel_contents);
                  long long v49 = *(_OWORD *)a1;
                  if (v11) {
                    re::DynamicArray<re::RenderGraphSelectionConcludeResult>::add((uint64_t)v42, (uint64_t)&v45);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  *(void *)&long long v47 = 0;
  *(void *)&long long v46 = 0;
  long long v45 = 0uLL;
  DWORD2(v46) = 0;
  uint64_t v12 = *(void *)(v4 + 176);
  if (v12)
  {
    uint64_t v13 = *(void **)(v4 + 192);
    uint64_t v14 = 40 * v12;
    do
    {
      if ((*v13 & 0xFFFFFFFFFFFFFFFuLL) <= (v3 & 0xFFFFFFFFFFFFFFFuLL))
      {
        uint64_t v33 = v41;
        uint64_t v34 = v39;
        uint64_t v15 = v13[4];
        if (!v15) {
          goto LABEL_63;
        }
        a1 = (void *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v15 + 48))(v15, &v33);
      }
      else
      {
        a1 = (void *)re::DynamicArray<re::SelectionCompleteHandler>::add((_anonymous_namespace_ *)&v45, v13);
      }
      v13 += 5;
      v14 -= 40;
    }
    while (v14);
  }
  if ((long long *)(v4 + 160) != &v45)
  {
    if (*(void *)(v4 + 160))
    {
      if ((void)v45)
      {
        a1 = re::DynamicArray<re::SelectionCompleteHandler>::copy(v4 + 160, (uint64_t)&v45);
      }
      else
      {
        uint64_t v17 = *(void *)(v4 + 176);
        *(void *)(v4 + 176) = 0;
        if (v17)
        {
          uint64_t v18 = 40 * v17;
          a1 = (void *)(*(void *)(v4 + 192) + 8);
          do
          {
            a1 = std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](a1)
               + 5;
            v18 -= 40;
          }
          while (v18);
        }
      }
      ++*(_DWORD *)(v4 + 184);
    }
    else if ((void)v45)
    {
      unint64_t v16 = v46;
      *(void *)(v4 + 160) = v45;
      re::DynamicArray<re::SelectionCompleteHandler>::setCapacity((void *)(v4 + 160), v16);
      ++*(_DWORD *)(v4 + 184);
      a1 = re::DynamicArray<re::SelectionCompleteHandler>::copy(v4 + 160, (uint64_t)&v45);
    }
  }
  uint64_t v37 = 0;
  uint64_t v34 = 0;
  unint64_t v35 = 0;
  uint64_t v33 = 0;
  int v36 = 0;
  uint64_t v19 = *(void *)(v4 + 216);
  if (v19)
  {
    long long v20 = *(void **)(v4 + 232);
    unint64_t v21 = v3 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v22 = *(void *)&v44[2];
    uint64_t v23 = *(void *)&v42[16];
    uint64_t v24 = 40 * v19;
    do
    {
      if ((*v20 & 0xFFFFFFFFFFFFFFFuLL) <= v21)
      {
        v32[0] = v22;
        v32[1] = v23;
        uint64_t v25 = v20[4];
        if (!v25) {
          goto LABEL_63;
        }
        a1 = (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 48))(v25, v32);
      }
      else
      {
        a1 = (void *)re::DynamicArray<re::SelectionConcludeHandler>::add((_anonymous_namespace_ *)&v33, v20);
      }
      v20 += 5;
      v24 -= 40;
    }
    while (v24);
  }
  if ((uint64_t *)(v4 + 200) != &v33)
  {
    if (*(void *)(v4 + 200))
    {
      if (v33)
      {
        a1 = re::DynamicArray<re::SelectionConcludeHandler>::copy(v4 + 200, (uint64_t)&v33);
      }
      else
      {
        uint64_t v27 = *(void *)(v4 + 216);
        *(void *)(v4 + 216) = 0;
        if (v27)
        {
          uint64_t v28 = 40 * v27;
          a1 = (void *)(*(void *)(v4 + 232) + 8);
          do
          {
            a1 = std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](a1)
               + 5;
            v28 -= 40;
          }
          while (v28);
        }
      }
      ++*(_DWORD *)(v4 + 224);
    }
    else if (v33)
    {
      unint64_t v26 = v35;
      *(void *)(v4 + 200) = v33;
      re::DynamicArray<re::SelectionConcludeHandler>::setCapacity((void *)(v4 + 200), v26);
      ++*(_DWORD *)(v4 + 224);
      a1 = re::DynamicArray<re::SelectionConcludeHandler>::copy(v4 + 200, (uint64_t)&v33);
    }
  }
  uint64_t v29 = v2[2];
  if (v29)
  {
    uint64_t v30 = re::globalAllocators((re *)a1)[2];
    re::DynamicArray<unsigned long>::deinit(v29);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 40))(v30, v29);
  }
  re::DynamicArray<re::SelectionConcludeHandler>::deinit((uint64_t)&v33);
  re::DynamicArray<re::SelectionCompleteHandler>::deinit((uint64_t)&v45);
  if (*(void *)v42 && *(void *)&v44[2]) {
    (*(void (**)(void))(**(void **)v42 + 40))();
  }
  uint64_t result = v38[0];
  if (v38[0])
  {
    if (v41) {
      return (*(uint64_t (**)(void))(*(void *)v38[0] + 40))();
    }
  }
  return result;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::prepareForRendering(char const*,char const*,re::RenderFrame &)::$_0,void ()(re::FrameCount)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E7195D0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::prepareForRendering(char const*,char const*,re::RenderFrame &)::$_0,void ()(re::FrameCount)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E7195D0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::prepareForRendering(char const*,char const*,re::RenderFrame &)::$_0,void ()(re::FrameCount)>::size()
{
  return 24;
}

__n128 re::DynamicArray<re::RenderGraphSelectionConcludeResult>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 80 * v5;
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v11 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v11 + 64) = v14;
  *(__n128 *)(v11 + 16) = result;
  *(_OWORD *)(v11 + 32) = v13;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t *re::DynamicArray<re::SelectionCompleteHandler>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::SelectionCompleteHandler>::setCapacity((void *)a1, *(void *)(a2 + 16));
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * *(void *)(a1 + 16)), *(void **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      uint64_t v9 = 40 * v4 - 40 * v8;
      uint64_t v10 = 40 * v8 + 8;
      uint64_t v11 = *(void *)(a2 + 32) + v10;
      __n128 result = (uint64_t *)(*(void *)(a1 + 32) + v10);
      do
      {
        *(result - 1) = *(void *)(v11 - 8);
        uint64_t v12 = std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::__value_func[abi:nn180100]((uint64_t)result, v11);
        v11 += 40;
        __n128 result = (uint64_t *)(v12 + 40);
        v9 -= 40;
      }
      while (v9);
    }
  }
  else
  {
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * v4), *(void **)(a1 + 32));
    uint64_t v6 = *(void *)(a1 + 16);
    if (v4 != v6)
    {
      uint64_t v7 = 40 * v6 - 40 * v4;
      __n128 result = (uint64_t *)(*(void *)(a1 + 32) + 40 * v4 + 8);
      do
      {
        __n128 result = std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](result)
               + 5;
        v7 -= 40;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
  return result;
}

void *re::DynamicArray<re::SelectionCompleteHandler>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::SelectionCompleteHandler>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_21;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_21:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = (uint64_t **)(v7 + 4);
        uint64_t v11 = (uint64_t **)(v8 + 32);
        uint64_t v12 = 40 * v9;
        do
        {
          *(v10 - 4) = *(v11 - 4);
          long long v13 = *v11;
          if (*v11)
          {
            if (v11 - 3 == (uint64_t **)v13)
            {
              *uint64_t v10 = (uint64_t *)(v10 - 3);
              (*(void (**)(void))(**v11 + 24))();
            }
            else
            {
              *uint64_t v10 = v13;
              *uint64_t v11 = 0;
            }
          }
          else
          {
            *uint64_t v10 = 0;
          }
          std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](v11 - 3);
          v10 += 5;
          v11 += 5;
          v12 -= 40;
        }
        while (v12);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_21;
    }
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,re::SelectionCompleteHandler *,0>(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result != a2)
  {
    unint64_t v5 = result;
    do
    {
      uint64_t v6 = (uint64_t)(v5 + 1);
      uint64_t v7 = *v5;
      v5 += 5;
      uint64_t v8 = a3 + 1;
      *a3 = v7;
      a3 += 5;
      __n128 result = std::function<void ()(re::Slice<unsigned long long> const&)>::operator=(v8, v6);
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *re::DynamicArray<re::SelectionConcludeHandler>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::SelectionConcludeHandler>::setCapacity((void *)a1, *(void *)(a2 + 16));
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * *(void *)(a1 + 16)), *(void **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      uint64_t v9 = 40 * v4 - 40 * v8;
      uint64_t v10 = 40 * v8 + 8;
      uint64_t v11 = *(void *)(a2 + 32) + v10;
      __n128 result = (uint64_t *)(*(void *)(a1 + 32) + v10);
      do
      {
        *(result - 1) = *(void *)(v11 - 8);
        uint64_t v12 = std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::__value_func[abi:nn180100]((uint64_t)result, v11);
        v11 += 40;
        __n128 result = (uint64_t *)(v12 + 40);
        v9 -= 40;
      }
      while (v9);
    }
  }
  else
  {
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * v4), *(void **)(a1 + 32));
    uint64_t v6 = *(void *)(a1 + 16);
    if (v4 != v6)
    {
      uint64_t v7 = 40 * v6 - 40 * v4;
      __n128 result = (uint64_t *)(*(void *)(a1 + 32) + 40 * v4 + 8);
      do
      {
        __n128 result = std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](result)
               + 5;
        v7 -= 40;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
  return result;
}

void *re::DynamicArray<re::SelectionConcludeHandler>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::SelectionConcludeHandler>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_21;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_21:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = (uint64_t **)(v7 + 4);
        uint64_t v11 = (uint64_t **)(v8 + 32);
        uint64_t v12 = 40 * v9;
        do
        {
          *(v10 - 4) = *(v11 - 4);
          long long v13 = *v11;
          if (*v11)
          {
            if (v11 - 3 == (uint64_t **)v13)
            {
              *uint64_t v10 = (uint64_t *)(v10 - 3);
              (*(void (**)(void))(**v11 + 24))();
            }
            else
            {
              *uint64_t v10 = v13;
              *uint64_t v11 = 0;
            }
          }
          else
          {
            *uint64_t v10 = 0;
          }
          std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](v11 - 3);
          v10 += 5;
          v11 += 5;
          v12 -= 40;
        }
        while (v12);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_21;
    }
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,re::SelectionConcludeHandler *,0>(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result != a2)
  {
    unint64_t v5 = result;
    do
    {
      uint64_t v6 = (uint64_t)(v5 + 1);
      uint64_t v7 = *v5;
      v5 += 5;
      uint64_t v8 = a3 + 1;
      *a3 = v7;
      a3 += 5;
      __n128 result = std::function<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::operator=(v8, v6);
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t re::DynamicArray<re::SelectionConcludeHandler>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        uint64_t v6 = (void *)(v3 + 8);
        do
        {
          uint64_t v6 = std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](v6)
             + 5;
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::SelectionCompleteHandler>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        uint64_t v6 = (void *)(v3 + 8);
        do
        {
          uint64_t v6 = std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](v6)
             + 5;
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_1,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::~Callable()
{
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_1,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::operator()(uint64_t a1, const char **a2, char **a3, uint64_t a4)
{
  uint64_t v173 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  if (*a3)
  {
    uint64_t v8 = *v7;
    if (*v7)
    {
      char v9 = v7[1];
      if (v9)
      {
        uint64_t v10 = (unsigned __int8 *)(v7 + 2);
        do
        {
          uint64_t v8 = 31 * v8 + v9;
          int v11 = *v10++;
          char v9 = v11;
        }
        while (v11);
      }
      v8 &= ~0x8000000000000000;
    }
  }
  else
  {
    uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v167 = v8;
  size_t v13 = strlen(v6);
  uint64_t v129 = v6;
  if (v13)
  {
    MurmurHash3_x64_128((uint64_t)v6, v13, 0, &v168);
    unint64_t v14 = (v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168;
  }
  else
  {
    unint64_t v14 = 0;
  }
  size_t v15 = strlen(v7);
  unint64_t v16 = 0x9E3779B97F4A7C17;
  if (v15)
  {
    MurmurHash3_x64_128((uint64_t)v7, v15, 0, &v168);
    unint64_t v16 = ((v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168) - 0x61C8864680B583E9;
  }
  __s = v7;
  uint64_t v17 = ((v14 >> 2) + (v14 << 6) + v16) ^ v14;
  unint64_t v18 = (unint64_t)"N2re16SkyboxMeshIDDataE";
  if (((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v19 = (unsigned __int8 *)((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  uint64_t v136 = v17 - 0x61C8864680B583E9;
  unint64_t v168 = (v17 - 0x61C8864680B583E9 + (v18 << 6) + (v18 >> 2)) ^ v18;
  uint64_t v133 = a4 + 96;
  uint64_t v22 = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a4 + 96, (uint64_t *)&v168);
  uint64_t v134 = a4;
  uint64_t v135 = v12;
  if (v22 && *(void *)v22)
  {
    char v23 = 0;
    uint64_t v4 = *(void *)(*(void *)v22 + 8);
  }
  else
  {
    char v23 = 1;
  }
  uint64_t v128 = a4 + 32;
  uint64_t v131 = re::RenderGraphDataStore::get<re::CurrentSelectionData>(a4 + 32, v17);
  uint64_t v139 = *(void *)(*(void *)(v131 + 8) + 440);
  uint64_t v137 = *(void *)(v139 + 40);
  uint64_t v24 = 0;
  if (v137)
  {
    unint64_t v25 = 0;
    uint64_t v26 = *(void *)(*(void *)(v134 + 8) + 32);
    uint64_t v27 = v26 + 72;
    uint64_t v28 = v26 + 8;
    do
    {
      unint64_t v141 = v25;
      uint64_t v29 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](v139, v25);
      uint64_t v30 = *(void *)(v29 + 16);
      if (v30)
      {
        uint64_t v31 = *(void *)(v29 + 32);
        uint64_t v32 = v31 + 656 * v30;
        do
        {
          if (((v23 & 1) != 0 || *(void *)(v31 + 416) != v4)
            && !re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v135 + 240, (uint64_t *)(v31 + 416)))
          {
            uint64_t v33 = *(void *)(v31 + 8);
            if (v33)
            {
              uint64_t v34 = *(uint64_t **)v31;
              uint64_t v35 = 8 * v33;
              do
              {
                uint64_t v36 = *v34++;
                uint64_t v37 = re::DataArray<re::MeshInstance>::get(v27, v36);
                v24 += *(void *)(re::DataArray<re::MeshModel>::get(v28, *(void *)(v37 + 16)) + 56);
                v35 -= 8;
              }
              while (v35);
            }
          }
          v31 += 656;
        }
        while (v31 != v32);
      }
      unint64_t v25 = v141 + 1;
    }
    while (v141 + 1 != v137);
  }
  if (([*(id *)(*(void *)(v134 + 8) + 184) supportsFamily:1007] & 1) == 0) {
    [*(id *)(*(void *)(v134 + 8) + 184) supportsFamily:2002];
  }
  unint64_t v38 = (unint64_t)"N2re27SelectionDrawCallBufferDataE";
  if (((unint64_t)"N2re27SelectionDrawCallBufferDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v39 = (unsigned __int8 *)((unint64_t)"N2re27SelectionDrawCallBufferDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      unint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  unint64_t v42 = (v136 + (v38 << 6) + (v38 >> 2)) ^ v38;
  __int16 v43 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v134 + 40) + 32))(*(void *)(v134 + 40), 16, 8);
  *__int16 v43 = &unk_26E719CD8;
  v43[1] = 8 * v24;
  unint64_t v44 = *(void *)(v134 + 96);
  if (v44)
  {
    unint64_t v44 = v42 % *(unsigned int *)(v134 + 120);
    uint64_t v45 = *(unsigned int *)(*(void *)(v134 + 104) + 4 * v44);
    if (v45 != 0x7FFFFFFF)
    {
      uint64_t v52 = *(void *)(v134 + 112);
      if (*(void *)(v52 + 24 * v45 + 8) == v42)
      {
LABEL_48:
        uint64_t v51 = v52 + 24 * v45;
        goto LABEL_49;
      }
      while (1)
      {
        LODWORD(v45) = *(_DWORD *)(v52 + 24 * v45) & 0x7FFFFFFF;
        if (v45 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v52 + 24 * v45 + 8) == v42) {
          goto LABEL_48;
        }
      }
    }
  }
  uint64_t v46 = *(unsigned int *)(v134 + 132);
  if (v46 == 0x7FFFFFFF)
  {
    uint64_t v46 = *(unsigned int *)(v134 + 128);
    int v47 = v46;
    if (v46 == *(_DWORD *)(v134 + 120))
    {
      re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v133, 2 * *(_DWORD *)(v134 + 124));
      LODWORD(v44) = v42 % *(unsigned int *)(v134 + 120);
      int v47 = *(_DWORD *)(v134 + 128);
    }
    *(_DWORD *)(v134 + 128) = v47 + 1;
    uint64_t v48 = *(void *)(v134 + 112);
    int v49 = *(_DWORD *)(v48 + 24 * v46);
  }
  else
  {
    uint64_t v48 = *(void *)(v134 + 112);
    int v49 = *(_DWORD *)(v48 + 24 * v46);
    *(_DWORD *)(v134 + 132) = v49 & 0x7FFFFFFF;
  }
  uint64_t v50 = 24 * v46;
  *(_DWORD *)(v48 + v50) = v49 | 0x80000000;
  *(_DWORD *)(*(void *)(v134 + 112) + v50) = *(_DWORD *)(*(void *)(v134 + 112) + 24 * v46) & 0x80000000 | *(_DWORD *)(*(void *)(v134 + 104) + 4 * v44);
  *(void *)(*(void *)(v134 + 112) + 24 * v46 + 8) = v42;
  *(void *)(*(void *)(v134 + 112) + 24 * v46 + 16) = v43;
  *(_DWORD *)(*(void *)(v134 + 104) + 4 * v44) = v46;
  ++*(_DWORD *)(v134 + 124);
  ++*(_DWORD *)(v134 + 136);
  uint64_t v51 = *(void *)(v134 + 112) + 24 * v46;
LABEL_49:
  uint64_t v53 = *(void *)(v51 + 16);
  if (*(void *)(v53 + 8))
  {
    uint64_t v54 = *(void **)(v135 + 288);
    if (!v54 || (unint64_t)objc_msgSend(v54, sel_length) < *(void *)(v53 + 8))
    {
      unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v135 + 288), (void **)&v168);
      if (v168) {
    }
      }
  }
  uint64_t v55 = *(re::Allocator **)(v134 + 376);
  unint64_t v164 = 0;
  uint64_t v161 = 0;
  {
    re::introspect<re::CameraData>(void)::mach_timebase_info info = (_UNKNOWN *)re::introspect_CameraData(0);
  }
  uint64_t v161 = (re::CameraData *)re::introspect<re::CameraData>(void)::info;
  size_t v56 = strlen(*((const char **)re::introspect<re::CameraData>(void)::info + 6));
  if (v56)
  {
    MurmurHash3_x64_128(*((void *)re::introspect<re::CameraData>(void)::info + 6), v56, 0, &v168);
    unint64_t v57 = (v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168;
  }
  else
  {
    unint64_t v57 = 0;
  }
  unint64_t v164 = v57;
  re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addOrReplace<re::IntrospectionStructure const*&>(v134 + 208, &v164, &v161);
  unint64_t v168 = (v136 + (v164 << 6) + (v164 >> 2)) ^ v164;
  char v58 = (re::CameraData *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v134 + 40) + 32))(*(void *)(v134 + 40), 528, 16);
  uint64_t v161 = re::CameraData::CameraData(v58, v55);
  uint64_t v59 = *(uint64_t **)re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addNew<re::CameraData *>(v133, &v168, &v161);
  long long v60 = *(uint64_t **)(v131 + 8);
  v59[55] = v60[55];
  v59[56] = v60[56];
  uint64_t v61 = v59 + 6;
  re::DynamicInlineArray<re::RenderCamera,2ul>::operator=(v59 + 6, v60 + 6);
  re::DynamicInlineArray<re::Projection,2ul>::operator=(v59 + 16, (uint64_t *)(*(void *)(v131 + 8) + 128));
  uint64_t v62 = (id *)(v135 + 296);
  if (!*(void *)(v135 + 296))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 8 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v135 + 296), (void **)&v168);
    if (v168) {
  }
    }
  id v63 = (id *)(v135 + 304);
  if (!*(void *)(v135 + 304))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 16 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v135 + 304), (void **)&v168);
    if (v168) {
  }
    }
  uint64_t v64 = (id *)(v135 + 312);
  if (!*(void *)(v135 + 312))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 16 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v135 + 312), (void **)&v168);
    if (v168) {
  }
    }
  uint64_t v132 = (void **)(v135 + 320);
  if (!*(void *)(v135 + 320))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 8 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=(v132, (void **)&v168);
    if (v168) {
  }
    }
  uint64_t v138 = (void **)(v135 + 328);
  if (!*(void *)(v135 + 328))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 4 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=(v138, (void **)&v168);
    if (v168) {
  }
    }
  uint64_t v140 = (void **)(v135 + 336);
  if (!*(void *)(v135 + 336))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 4 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=(v140, (void **)&v168);
    if (v168) {
  }
    }
  uint64_t v142 = (void **)(v135 + 344);
  if (!*(void *)(v135 + 344))
  {
    unint64_t v168 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v134 + 8) + 184), sel_newBufferWithLength_options_, 16 * *v61, 0);
    NS::SharedPtr<MTL::Texture>::operator=(v142, (void **)&v168);
    if (v168) {
  }
    }
  unint64_t v164 = 0;
  uint64_t v161 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A920, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A920))
  {
    qword_26AF9A918 = re::internal::getOrCreateInfo((re::internal *)"RenderGraphSelectionParams", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphSelectionParams, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphSelectionParams, (void (*)(re::IntrospectionBase *))&unk_26AF9A8F0, 0);
    __cxa_guard_release(&qword_26AF9A920);
  }
  uint64_t v161 = (re::CameraData *)qword_26AF9A918;
  size_t v65 = strlen(*(const char **)(qword_26AF9A918 + 48));
  if (v65)
  {
    MurmurHash3_x64_128(*(void *)(qword_26AF9A918 + 48), v65, 0, &v168);
    unint64_t v66 = (v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168;
  }
  else
  {
    unint64_t v66 = 0;
  }
  unint64_t v164 = v66;
  re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addOrReplace<re::IntrospectionStructure const*&>(v134 + 208, &v164, &v161);
  unint64_t v67 = (v136 + (v164 << 6) + (v164 >> 2)) ^ v164;
  uint64_t v68 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v134 + 40) + 32))(*(void *)(v134 + 40), 80, 16);
  uint64_t v69 = v68;
  *(void *)uint64_t v68 = &unk_26E719590;
  *(_OWORD *)(v68 + 8) = *(_OWORD *)(v135 + 360);
  long long v70 = *(_OWORD *)(v135 + 376);
  long long v71 = *(_OWORD *)(v135 + 392);
  long long v72 = *(_OWORD *)(v135 + 408);
  *(void *)(v68 + 72) = *(void *)(v135 + 424);
  *(_OWORD *)(v68 + 56) = v72;
  *(_OWORD *)(v68 + 40) = v71;
  *(_OWORD *)(v68 + 24) = v70;
  unint64_t v73 = *(void *)(v134 + 96);
  if (v73)
  {
    unint64_t v73 = v67 % *(unsigned int *)(v134 + 120);
    uint64_t v74 = *(unsigned int *)(*(void *)(v134 + 104) + 4 * v73);
    if (v74 != 0x7FFFFFFF)
    {
      uint64_t v114 = *(void *)(v134 + 112);
      if (*(void *)(v114 + 24 * v74 + 8) == v67) {
        goto LABEL_91;
      }
      while (1)
      {
        LODWORD(v74) = *(_DWORD *)(v114 + 24 * v74) & 0x7FFFFFFF;
        if (v74 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v114 + 24 * v74 + 8) == v67) {
          goto LABEL_91;
        }
      }
    }
  }
  uint64_t v75 = *(unsigned int *)(v134 + 132);
  if (v75 == 0x7FFFFFFF)
  {
    uint64_t v75 = *(unsigned int *)(v134 + 128);
    int v76 = v75;
    if (v75 == *(_DWORD *)(v134 + 120))
    {
      re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v133, 2 * *(_DWORD *)(v134 + 124));
      LODWORD(v73) = v67 % *(unsigned int *)(v134 + 120);
      int v76 = *(_DWORD *)(v134 + 128);
    }
    *(_DWORD *)(v134 + 128) = v76 + 1;
    uint64_t v77 = *(void *)(v134 + 112);
    int v78 = *(_DWORD *)(v77 + 24 * v75);
  }
  else
  {
    uint64_t v77 = *(void *)(v134 + 112);
    int v78 = *(_DWORD *)(v77 + 24 * v75);
    *(_DWORD *)(v134 + 132) = v78 & 0x7FFFFFFF;
  }
  uint64_t v79 = 24 * v75;
  *(_DWORD *)(v77 + v79) = v78 | 0x80000000;
  *(_DWORD *)(*(void *)(v134 + 112) + v79) = *(_DWORD *)(*(void *)(v134 + 112) + 24 * v75) & 0x80000000 | *(_DWORD *)(*(void *)(v134 + 104) + 4 * v73);
  *(void *)(*(void *)(v134 + 112) + 24 * v75 + 8) = v67;
  *(void *)(*(void *)(v134 + 112) + 24 * v75 + 16) = v69;
  *(_DWORD *)(*(void *)(v134 + 104) + 4 * v73) = v75;
  ++*(_DWORD *)(v134 + 124);
  ++*(_DWORD *)(v134 + 136);
LABEL_91:
  int v80 = re::globalAllocators((re *)v68);
  uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[2] + 32))(v80[2], 40, 8);
  uint64_t v82 = v81;
  *(void *)(v81 + 32) = 0;
  *(void *)(v81 + 8) = 0;
  *(void *)(v81 + 16) = 0;
  *(void *)uint64_t v81 = 0;
  unint64_t v83 = (unint64_t)"N2re22DrawCallIdentifierDataE";
  *(_DWORD *)(v81 + 24) = 0;
  if (((unint64_t)"N2re22DrawCallIdentifierDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v84 = (unsigned __int8 *)((unint64_t)"N2re22DrawCallIdentifierDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v85 = 5381;
    do
    {
      unint64_t v83 = v85;
      unsigned int v86 = *v84++;
      uint64_t v85 = (33 * v85) ^ v86;
    }
    while (v86);
  }
  unint64_t v87 = (v136 + (v83 << 6) + (v83 >> 2)) ^ v83;
  long long v88 = re::globalAllocators((re *)v81);
  uint64_t v89 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v88[2] + 32))(v88[2], 16, 8);
  int v90 = (re *)(v134 + 48);
  unint64_t v91 = *(void *)(v134 + 48);
  *uint64_t v89 = &unk_26E719D00;
  v89[1] = v82;
  if (v91)
  {
    unint64_t v91 = v87 % *(unsigned int *)(v134 + 72);
    uint64_t v92 = *(unsigned int *)(*(void *)(v134 + 56) + 4 * v91);
    uint64_t v93 = &selRef_taskToken;
    if (v92 != 0x7FFFFFFF)
    {
      uint64_t v94 = *(void *)(v134 + 64);
      if (*(void *)(v94 + 24 * v92 + 8) == v87)
      {
LABEL_99:
        uint64_t v95 = v94 + 24 * v92;
        goto LABEL_107;
      }
      while (1)
      {
        LODWORD(v92) = *(_DWORD *)(v94 + 24 * v92) & 0x7FFFFFFF;
        if (v92 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v94 + 24 * v92 + 8) == v87) {
          goto LABEL_99;
        }
      }
    }
  }
  else
  {
    uint64_t v93 = &selRef_taskToken;
  }
  uint64_t v96 = *(unsigned int *)(v134 + 84);
  if (v96 == 0x7FFFFFFF)
  {
    uint64_t v96 = *(unsigned int *)(v134 + 80);
    int v97 = v96;
    if (v96 == *(_DWORD *)(v134 + 72))
    {
      re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity((uint64_t)v90, 2 * *(_DWORD *)(v134 + 76));
      LODWORD(v91) = v87 % *(unsigned int *)(v134 + 72);
      int v97 = *(_DWORD *)(v134 + 80);
    }
    *(_DWORD *)(v134 + 80) = v97 + 1;
    uint64_t v98 = *(void *)(v134 + 64);
    int v99 = *(_DWORD *)(v98 + 24 * v96);
  }
  else
  {
    uint64_t v98 = *(void *)(v134 + 64);
    int v99 = *(_DWORD *)(v98 + 24 * v96);
    *(_DWORD *)(v134 + 84) = v99 & 0x7FFFFFFF;
  }
  uint64_t v100 = 24 * v96;
  *(_DWORD *)(v98 + v100) = v99 | 0x80000000;
  *(_DWORD *)(*(void *)(v134 + 64) + v100) = *(_DWORD *)(*(void *)(v134 + 64) + 24 * v96) & 0x80000000 | *(_DWORD *)(*(void *)(v134 + 56) + 4 * v91);
  *(void *)(*(void *)(v134 + 64) + 24 * v96 + 8) = v87;
  *(void *)(*(void *)(v134 + 64) + 24 * v96 + 16) = v89;
  *(_DWORD *)(*(void *)(v134 + 56) + 4 * v91) = v96;
  ++*(_DWORD *)(v134 + 76);
  ++*(_DWORD *)(v134 + 88);
  uint64_t v95 = *(void *)(v134 + 64) + 24 * v96;
LABEL_107:
  uint64_t v101 = *(void *)(*(void *)(v95 + 16) + 8);
  uint64_t v102 = re::globalAllocators(v90)[2];
  uint64_t v170 = v101;
  uint64_t v171 = v102;
  unint64_t v168 = (unint64_t)&unk_26E7195D0;
  uint64_t v169 = v135;
  unint64_t v172 = &v168;
  re::DynamicArray<re::Function<void ()(re::FrameCount)>>::add((_anonymous_namespace_ *)(v134 + 3832), (uint64_t)&v168);
  re::FunctionBase<24ul,void ()(re::FrameCount)>::destroyCallable((uint64_t)&v168);
  if (!*(void *)(v53 + 8)) {
    return 0;
  }
  id v103 = *(id *)(v135 + 288);
  unint64_t v164 = (unint64_t)v103;
  int v165 = 0;
  unsigned int v166 = [*(id *)(v135 + 288) v93[280]];
  unint64_t v168 = 0x254F47A4D0EF9BB6;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v164, &v168, &v167, 0);
  if (v103) {

  }
  uint64_t v104 = (re::CameraData *)*v62;
  uint64_t v161 = v104;
  int v162 = 0;
  unsigned int v163 = [*v62 v93[280]];
  unint64_t v168 = 0x32320846451280ADLL;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v161, &v168, &v167, 0);
  if (v104) {

  }
  id v105 = *v63;
  id v158 = v105;
  int v159 = 0;
  unsigned int v160 = [*v63 v93[280]];
  unint64_t v168 = 0x7F4B8EECA403FF29;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v158, &v168, &v167, 0);
  if (v105) {

  }
  id v106 = *v64;
  id v155 = v106;
  int v156 = 0;
  unsigned int v157 = [*v64 v93[280]];
  unint64_t v168 = 0x1D6555C5E40CE967;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v155, &v168, &v167, 0);
  if (v106) {

  }
  id v107 = *v132;
  id v152 = v107;
  int v153 = 0;
  unsigned int v154 = [*v132 v93[280]];
  unint64_t v168 = 0x4AABB4110780FA30;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v152, &v168, &v167, 0);
  if (v107) {

  }
  id v108 = *v138;
  id v149 = v108;
  int v150 = 0;
  unsigned int v151 = [*v138 v93[280]];
  unint64_t v168 = 0x511FDEFE273D287BLL;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v149, &v168, &v167, 0);
  if (v108) {

  }
  id v109 = *v140;
  id v146 = v109;
  int v147 = 0;
  unsigned int v148 = [*v140 v93[280]];
  unint64_t v168 = 0xC687454B2B05CFFLL;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v146, &v168, &v167, 0);
  if (v109) {

  }
  id v110 = *v142;
  id v143 = v110;
  int v144 = 0;
  unsigned int v145 = [*v142 v93[280]];
  unint64_t v168 = 0x60FB3170E2E2B568;
  re::RenderFrame::registerExternalBuffer(v134, (uint64_t)&v143, &v168, &v167, 0);
  if (v110) {

  }
  size_t v111 = strlen(v129);
  if (v111)
  {
    MurmurHash3_x64_128((uint64_t)v129, v111, 0, &v168);
    unint64_t v112 = (v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168;
  }
  else
  {
    unint64_t v112 = 0;
  }
  size_t v115 = strlen(__s);
  unint64_t v116 = 0x9E3779B97F4A7C17;
  if (v115)
  {
    MurmurHash3_x64_128((uint64_t)__s, v115, 0, &v168);
    unint64_t v116 = ((v169 - 0x61C8864680B583E9 + (v168 << 6) + (v168 >> 2)) ^ v168) - 0x61C8864680B583E9;
  }
  uint64_t v117 = *(void *)(re::RenderGraphDataStore::get<re::CurrentSelectionData>(v128, ((v112 >> 2) + (v112 << 6) + v116) ^ v112)+ 8);
  if (*(unsigned char *)(v117 + 16)) {
    int v118 = *(const char **)(v117 + 24);
  }
  else {
    int v118 = (const char *)(v117 + 17);
  }
  ScopeResolutiounint64_t n = re::RenderFrame::getScopeResolution((re::RenderFrame *)v134, v118);
  unsigned int v120 = *(_DWORD *)(v135 + 380);
  if (v120 == -1) {
    unint64_t v121 = ScopeResolution;
  }
  else {
    unint64_t v121 = v120;
  }
  unsigned int v122 = *(_DWORD *)(v135 + 384);
  if (v122 == -1) {
    unint64_t v123 = HIDWORD(ScopeResolution);
  }
  else {
    unint64_t v123 = v122;
  }
  unint64_t v124 = *((void *)re::AssetHandle::assetInfo((re::AssetHandle *)(v135 + 136)) + 10);
  if (v124 == -1) {
    unint64_t v124 = 0;
  }
  unint64_t v125 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v124 ^ (v124 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v124 ^ (v124 >> 30))) >> 27));
  unint64_t v126 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v121 ^ (v121 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v121 ^ (v121 >> 30))) >> 27));
  unint64_t v127 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v123 ^ (v123 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v123 ^ (v123 >> 30))) >> 27));
  return (((v125 ^ (v125 >> 31)) << 6)
        - 0x61C8864680B583E9
        + ((v125 ^ (v125 >> 31)) >> 2)
        + (((v127 ^ (v127 >> 31)) - 0x61C8864680B583E9 + ((v126 ^ (v126 >> 31)) << 6) + ((v126 ^ (v126 >> 31)) >> 2)) ^ v126 ^ (v126 >> 31))) ^ v125 ^ (v125 >> 31);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_1,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E719628;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_1,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E719628;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_1,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::size()
{
  return 16;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0,void ()(char const*,char const*,re::RenderFrame &)>::~Callable()
{
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0,void ()(char const*,char const*,re::RenderFrame &)>::operator()(uint64_t a1, const char **a2, char **a3, re::RenderFrame *a4)
{
  uint64_t v400 = *MEMORY[0x263EF8340];
  unint64_t v5 = 0x9E3779B97F4A7C17;
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  unint64_t v8 = *(void *)(a1 + 8);
  size_t v9 = strlen(*a2);
  if (v9)
  {
    MurmurHash3_x64_128((uint64_t)v6, v9, 0, &v359);
    unint64_t v10 = (unint64_t)&v360[64 * v359 - 0x61C8864680B583E9 + (v359 >> 2)] ^ v359;
  }
  else
  {
    unint64_t v10 = 0;
  }
  size_t v11 = strlen(v7);
  if (v11)
  {
    MurmurHash3_x64_128((uint64_t)v7, v11, 0, &v359);
    unint64_t v5 = ((unint64_t)&v360[64 * v359 - 0x61C8864680B583E9 + (v359 >> 2)] ^ v359) - 0x61C8864680B583E9;
  }
  uint64_t v12 = ((v10 >> 2) + (v10 << 6) + v5) ^ v10;
  uint64_t v13 = re::RenderGraphDataStore::get<re::CurrentSelectionData>((uint64_t)a4 + 32, v12);
  uint64_t v14 = re::RenderGraphDataStore::get<re::SelectionDrawCallBufferData>((uint64_t)a4 + 32, v12);
  if (v7)
  {
    uint64_t v15 = *v7;
    if (*v7)
    {
      char v16 = v7[1];
      if (v16)
      {
        uint64_t v17 = (unsigned __int8 *)(v7 + 2);
        do
        {
          uint64_t v15 = 31 * v15 + v16;
          int v18 = *v17++;
          char v16 = v18;
        }
        while (v18);
      }
      uint64_t v19 = v15 & 0x7FFFFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v20 = *(void *)(v8 + 144);
  if (v20)
  {
    unsigned int v21 = atomic_load((unsigned int *)(v20 + 704));
    if (v21 == 2) {
      goto LABEL_19;
    }
    uint64_t v22 = *(void *)(v8 + 144);
  }
  else
  {
    uint64_t v22 = 0;
  }
  re::AssetHandle::loadNow(v22, 0);
LABEL_19:
  if (*(void *)(v14 + 8))
  {
    uint64_t v317 = -1;
    char v318 = 0;
    int v319 = 1065353216;
    unint64_t v320 = 0xFFFFFFFF00000020;
    int v316 = 2;
    unint64_t v359 = 0x4A9E8F49A1DF376CLL;
    double v360 = "ResultsBuffer";
    uint64_t v321 = -1;
    uint64_t v322 = (v19 - 0x4A2CB291092AF7CLL) ^ 0x254F47A4D0EF9BB6;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v310 = -1;
    char v311 = 0;
    int v312 = 1065353216;
    unint64_t v313 = 0xFFFFFFFF00000020;
    int v309 = 2;
    unint64_t v359 = 0x6464108C8A25015ALL;
    double v360 = "SelectedEntityConcludeResults";
    uint64_t v314 = -1;
    uint64_t v315 = (v19 + 0x37460D5C552F4782) ^ 0x32320846451280ADLL;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v303 = -1;
    char v304 = 0;
    int v305 = 1065353216;
    unint64_t v306 = 0xFFFFFFFF00000020;
    int v302 = 2;
    unint64_t v359 = 0xFE971DD94807FE52;
    double v360 = "SelectedNormalConcludeResults";
    uint64_t v307 = -1;
    uint64_t v308 = (v19 - 0x6F11E76256B4B9DFLL) ^ 0x7F4B8EECA403FF29;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v296 = -1;
    char v297 = 0;
    int v298 = 1065353216;
    unint64_t v299 = 0xFFFFFFFF00000020;
    int v295 = 2;
    unint64_t v359 = 0x3ACAAB8BC819D2CELL;
    double v360 = "SelectedPositionConcludeResults";
    uint64_t v300 = -1;
    uint64_t v301 = (v19 - 0x119BF5C0477EFD0) ^ 0x1D6555C5E40CE967;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v289 = -1;
    char v290 = 0;
    int v291 = 1065353216;
    unint64_t v292 = 0xFFFFFFFF00000020;
    int v288 = 2;
    unint64_t v359 = 0x955768220F01F460;
    double v360 = "SelectedMeshPartConcludeResults";
    uint64_t v293 = -1;
    uint64_t v294 = (v19 + 0x5BCF6AFFA16946A3) ^ 0x4AABB4110780FA30;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v282 = -1;
    char v283 = 0;
    int v284 = 1065353216;
    unint64_t v285 = 0xFFFFFFFF00000020;
    int v281 = 2;
    unint64_t v359 = 0xA23FBDFC4E7A50F6;
    double v360 = "SelectedInstanceConcludeResults";
    uint64_t v286 = -1;
    uint64_t v287 = (v19 - 0x588CEFD279C1B0BLL) ^ 0x511FDEFE273D287BLL;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v275 = -1;
    char v276 = 0;
    int v277 = 1065353216;
    unint64_t v278 = 0xFFFFFFFF00000020;
    int v274 = 2;
    unint64_t v359 = 0x18D0E8A96560B9FELL;
    double v360 = "SelectedPrimitiveConcludeResults";
    uint64_t v279 = -1;
    uint64_t v280 = (v19 - 0x44915404A7F22CEALL) ^ 0xC687454B2B05CFFLL;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v268 = -1;
    char v269 = 0;
    int v270 = 1065353216;
    unint64_t v271 = 0xFFFFFFFF00000020;
    int v267 = 2;
    unint64_t v359 = 0xC1F662E1C5C56AD0;
    double v360 = "SelectedBarycentricConcludeResults";
    uint64_t v272 = -1;
    uint64_t v273 = (v19 - 0xABD5DB18F4F7C8FLL) ^ 0x60FB3170E2E2B568;
    re::StringID::destroyString((re::StringID *)&v359);
    uint64_t v23 = *(void *)(v13 + 8);
    if (*(unsigned char *)(v23 + 16)) {
      uint64_t v24 = *(const char **)(v23 + 24);
    }
    else {
      uint64_t v24 = (const char *)(v23 + 17);
    }
    ScopeResolutiounint64_t n = re::RenderFrame::getScopeResolution(a4, v24);
    if (*(_DWORD *)(v8 + 380) == -1) {
      int v26 = ScopeResolution;
    }
    else {
      int v26 = *(_DWORD *)(v8 + 380);
    }
    if (*(_DWORD *)(v8 + 384) == -1) {
      int v27 = HIDWORD(ScopeResolution);
    }
    else {
      int v27 = *(_DWORD *)(v8 + 384);
    }
    float32x4_t v28 = *(float32x4_t *)(v8 + 416);
    int32x4_t v29 = (int32x4_t)vmulq_f32(v28, v28);
    v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v29, 2), vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.i8, 1))).u32[0];
    float32x2_t v30 = vrsqrte_f32((float32x2_t)v29.u32[0]);
    float32x2_t v31 = vmul_f32(v30, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v30, v30)));
    float32x4_t v32 = vmulq_n_f32(v28, vmul_f32(v31, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v31, v31))).f32[0]);
    v401.columns[2] = (simd_float4)vnegq_f32(v32);
    float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v401.columns[2], (int32x4_t)v401.columns[2]), (int8x16_t)v401.columns[2], 0xCuLL);
    float32x4_t v34 = vmlaq_f32(vmulq_f32(v33, (float32x4_t)xmmword_23437C080), (float32x4_t)xmmword_23437C090, v32);
    float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL);
    int32x4_t v36 = (int32x4_t)vmulq_f32(v34, v34);
    v36.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), *(float32x2_t *)v36.i8)).u32[0];
    float32x2_t v37 = vrsqrte_f32((float32x2_t)v36.u32[0]);
    float32x2_t v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v37, v37)));
    v401.columns[0] = (simd_float4)vmulq_n_f32(v35, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v38, v38))).f32[0]);
    int8x16_t v39 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v401.columns[0], (int32x4_t)v401.columns[0]), (int8x16_t)v401.columns[0], 0xCuLL), v32), (float32x4_t)v401.columns[0], v33);
    v401.columns[0].i32[3] = 0;
    v401.columns[1] = (simd_float4)vrev64q_s32(vuzp1q_s32((int32x4_t)v39, (int32x4_t)vextq_s8((int8x16_t)0, v39, 0xCuLL)));
    v401.columns[2].i32[3] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    v401.columns[3].i64[0] = *(void *)(v8 + 400);
    v401.columns[3].i32[2] = *(_DWORD *)(v8 + 408);
    simd_float4x4 v402 = __invert_f4(v401);
    simd_float4 v79 = v402.columns[0];
    simd_float4 v76 = v402.columns[3];
    simd_float4 v77 = v402.columns[2];
    simd_float4 v78 = v402.columns[1];
    uint64_t v259 = -1;
    uint64_t v258 = -1;
    char v260 = 0;
    __asm { FMOV            V0.2S, #1.0 }
    uint64_t v261 = v402.columns[0].i64[0];
    long long v262 = xmmword_2343AEB90;
    long long v263 = xmmword_2343AEBA0;
    int v264 = -1;
    long long v265 = xmmword_234378E20;
    char v266 = 0;
    uint64_t v254 = 0x6700000000;
    int v255 = 2;
    int v256 = v26;
    int v257 = v27;
    uint64_t v246 = -1;
    uint64_t v245 = -1;
    char v247 = 0;
    uint64_t v248 = v402.columns[0].i64[0];
    long long v249 = xmmword_2343AEB90;
    long long v250 = xmmword_2343AEBA0;
    int v251 = -1;
    long long v252 = xmmword_234378E20;
    char v253 = 0;
    uint64_t v241 = 0x7D00000000;
    int v242 = 2;
    int v243 = v26;
    int v244 = v27;
    uint64_t v233 = -1;
    uint64_t v232 = -1;
    char v234 = 0;
    uint64_t v235 = v402.columns[0].i64[0];
    long long v236 = xmmword_2343AEB90;
    long long v237 = xmmword_2343AEBA0;
    int v238 = -1;
    long long v239 = xmmword_234378E20;
    char v240 = 0;
    uint64_t v228 = 0x7D00000000;
    int v229 = 2;
    int v230 = v26;
    int v231 = v27;
    uint64_t v220 = -1;
    uint64_t v219 = -1;
    char v221 = 0;
    uint64_t v222 = v402.columns[0].i64[0];
    long long v223 = xmmword_2343AEB90;
    long long v224 = xmmword_2343AEBA0;
    int v225 = -1;
    long long v226 = xmmword_234378E20;
    char v227 = 0;
    uint64_t v215 = 0x6700000000;
    int v216 = 2;
    int v217 = v26;
    int v218 = v27;
    uint64_t v207 = -1;
    uint64_t v206 = -1;
    char v208 = 0;
    uint64_t v209 = v402.columns[0].i64[0];
    long long v210 = xmmword_2343AEB90;
    long long v211 = xmmword_2343AEBA0;
    int v212 = -1;
    long long v213 = xmmword_234378E20;
    char v214 = 0;
    uint64_t v202 = 0x3500000000;
    int v203 = 2;
    int v204 = v26;
    int v205 = v27;
    uint64_t v194 = -1;
    uint64_t v193 = -1;
    char v195 = 0;
    uint64_t v196 = v402.columns[0].i64[0];
    long long v197 = xmmword_2343AEB90;
    long long v198 = xmmword_2343AEBA0;
    int v199 = -1;
    long long v200 = xmmword_234378E20;
    char v201 = 0;
    uint64_t v189 = 0x3500000000;
    int v190 = 2;
    int v191 = v26;
    int v192 = v27;
    uint64_t v181 = -1;
    uint64_t v180 = -1;
    char v182 = 0;
    uint64_t v183 = v402.columns[0].i64[0];
    long long v184 = xmmword_2343AEB90;
    long long v185 = xmmword_2343AEBA0;
    int v186 = -1;
    long long v187 = xmmword_234378E20;
    char v188 = 0;
    uint64_t v176 = 0x7D00000000;
    int v177 = 2;
    int v178 = v26;
    int v179 = v27;
    uint64_t v168 = -1;
    uint64_t v167 = -1;
    char v169 = 0;
    uint64_t v170 = v402.columns[0].i64[0];
    long long v171 = xmmword_2343AEB90;
    long long v172 = xmmword_2343AEBA0;
    int v173 = -1;
    long long v174 = xmmword_234378E20;
    char v175 = 0;
    uint64_t v163 = 0xFC00000000;
    int v164 = 2;
    int v165 = v26;
    int v166 = v27;
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v254, "ResultEntity", &v161);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v241, "ResultNormal", &v159);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v228, "ResultPosition", &v157);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v215, "ResultMeshPart", &v155);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v202, "ResultInstance", &v153);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v189, "ResultPrimitive", &v151);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v176, "ResultBarycentric", &v149);
    re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v163, "ResultDepthDiscard", &v146);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v316, "ResultsBuffer", &v143);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v309, "SelectedEntityConcludeResults", &v140);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v302, "SelectedNormalConcludeResults", &v137);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v295, "SelectedPositionConcludeResults", &v134);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v288, "SelectedMeshPartConcludeResults", &v131);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v281, "SelectedInstanceConcludeResults", &v128);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v274, "SelectedPrimitiveConcludeResults", &v125);
    re::RenderFrame::createBuffer(a4, (const re::RenderGraphBufferDescription *)&v267, "SelectedBarycentricConcludeResults", &v122);
    RenderGraph = (re *)re::RenderFrame::makeRenderGraph(a4, "SelectionGraph", 0);
    double v45 = v146;
    v116[0] = v161;
    v116[1] = v162;
    v116[2] = v159;
    v116[3] = v160;
    v80[0] = v161;
    v80[1] = v162;
    v110[0] = v157;
    _OWORD v80[2] = v159;
    v110[1] = v158;
    v80[3] = v160;
    v110[2] = v155;
    v80[4] = v157;
    int32x2_t v80[5] = v158;
    v110[3] = v156;
    v80[6] = v155;
    v104[0] = v153;
    v80[7] = v156;
    v104[1] = v154;
    v80[8] = v153;
    v80[9] = v154;
    v104[2] = v151;
    v80[10] = v151;
    v104[3] = v152;
    v80[11] = v152;
    int v46 = v147;
    int v47 = v148;
    v116[4] = v146;
    int v117 = v147;
    int v118 = v148;
    unint64_t v359 = v8;
    double v360 = *(const char **)&v161;
    double v362 = v159;
    double v48 = v143;
    double v119 = v143;
    v80[14] = v143;
    double v364 = v157;
    double v366 = v155;
    int v49 = v144;
    double v368 = v153;
    double v370 = v151;
    double v372 = v149;
    double v374 = v143;
    int v50 = v145;
    int v120 = v144;
    int v121 = v145;
    v110[4] = v146;
    int v111 = v147;
    int v112 = v148;
    double v113 = v143;
    int v114 = v144;
    int v115 = v145;
    v104[4] = v146;
    int v105 = v147;
    int v106 = v148;
    double v107 = v143;
    int v108 = v144;
    int v109 = v145;
    int v81 = v144;
    int v82 = v145;
    int v375 = v144;
    uint64_t v83 = v140;
    int v376 = v145;
    uint64_t v377 = v140;
    int v84 = v141;
    int v85 = v142;
    int v378 = v141;
    uint64_t v86 = v137;
    int v379 = v142;
    uint64_t v380 = v137;
    int v87 = v138;
    int v88 = v139;
    int v381 = v138;
    uint64_t v89 = v134;
    int v382 = v139;
    uint64_t v383 = v134;
    int v90 = v135;
    int v91 = v136;
    int v384 = v135;
    uint64_t v92 = v131;
    int v385 = v136;
    uint64_t v386 = v131;
    int v93 = v132;
    int v94 = v133;
    int v387 = v132;
    uint64_t v95 = v128;
    int v388 = v133;
    uint64_t v389 = v128;
    int v96 = v129;
    int v97 = v130;
    int v390 = v129;
    uint64_t v98 = v125;
    int v391 = v130;
    uint64_t v392 = v125;
    int v99 = v126;
    int v100 = v127;
    int v393 = v126;
    uint64_t v101 = v122;
    int v394 = v127;
    uint64_t v395 = v122;
    int v396 = v123;
    int v102 = v123;
    int v103 = v124;
    int v397 = v124;
    double v75 = v149;
    v80[12] = v149;
    int v73 = HIDWORD(v150);
    int v74 = LODWORD(v150);
    v80[13] = v150;
    double v361 = v162;
    double v363 = v160;
    double v365 = v158;
    double v367 = v156;
    double v369 = v154;
    double v371 = v152;
    double v373 = v150;
    int v398 = v26;
    int v399 = v27;
    uint64_t v357 = re::globalAllocators(RenderGraph)[2];
    uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v357 + 32))(v357, 40, 0);
    *(void *)uint64_t v51 = &unk_26E7197B0;
    *(double *)(v51 + 8) = v45;
    *(_DWORD *)(v51 + 16) = v46;
    *(_DWORD *)(v51 + 20) = v47;
    *(double *)(v51 + 24) = v48;
    *(_DWORD *)(v51 + 32) = v49;
    *(_DWORD *)(v51 + 36) = v50;
    uint64_t v358 = v51;
    uint64_t v354 = re::globalAllocators((re *)v51)[2];
    uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v354 + 32))(v354, 112, 0);
    *(void *)uint64_t v52 = &unk_26E719818;
    *(void *)(v52 + 16) = v8;
    *(double *)(v52 + 24) = v48;
    *(_DWORD *)(v52 + 32) = v49;
    *(_DWORD *)(v52 + 36) = v50;
    *(_DWORD *)(v52 + 40) = v26;
    *(_DWORD *)(v52 + 44) = v27;
    *(simd_float4 *)(v52 + 48) = v79;
    *(simd_float4 *)(v52 + 64) = v78;
    *(simd_float4 *)(v52 + 80) = v77;
    *(simd_float4 *)(v52 + 96) = v76;
    uint64_t v355 = v52;
    re::RenderGraph::addNode(RenderGraph, "SelectionRenderVisibleNode", (uint64_t)v356, (uint64_t)v353);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v353);
    uint64_t v53 = (re *)re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v356);
    uint64_t v54 = (double *)re::globalAllocators(v53)[2];
    double v351 = v54;
    if (v54) {
      uint64_t v54 = (double *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v54 + 32))(v54, 72, 0);
    }
    re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(v54, v116);
    unint64_t v352 = v55;
    uint64_t v348 = re::globalAllocators(v55)[2];
    uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v348 + 32))(v348, 112, 0);
    *(void *)uint64_t v56 = &unk_26E719818;
    *(void *)(v56 + 16) = v8;
    *(double *)(v56 + 24) = v48;
    *(_DWORD *)(v56 + 32) = v49;
    *(_DWORD *)(v56 + 36) = v50;
    *(_DWORD *)(v56 + 40) = v26;
    *(_DWORD *)(v56 + 44) = v27;
    *(simd_float4 *)(v56 + 48) = v79;
    *(simd_float4 *)(v56 + 64) = v78;
    *(simd_float4 *)(v56 + 80) = v77;
    *(simd_float4 *)(v56 + 96) = v76;
    uint64_t v349 = v56;
    re::RenderGraph::addNode(RenderGraph, "SelectionRenderGroup01Node", (uint64_t)v350, (uint64_t)v347);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v347);
    unint64_t v57 = (re *)re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v350);
    char v58 = (double *)re::globalAllocators(v57)[2];
    uint64_t v345 = v58;
    if (v58) {
      char v58 = (double *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v58 + 32))(v58, 72, 0);
    }
    re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(v58, v110);
    unsigned int v346 = v59;
    uint64_t v342 = re::globalAllocators(v59)[2];
    uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v342 + 32))(v342, 112, 0);
    *(void *)uint64_t v60 = &unk_26E719818;
    *(void *)(v60 + 16) = v8;
    *(double *)(v60 + 24) = v48;
    *(_DWORD *)(v60 + 32) = v49;
    *(_DWORD *)(v60 + 36) = v50;
    *(_DWORD *)(v60 + 40) = v26;
    *(_DWORD *)(v60 + 44) = v27;
    *(simd_float4 *)(v60 + 48) = v79;
    *(simd_float4 *)(v60 + 64) = v78;
    *(simd_float4 *)(v60 + 80) = v77;
    *(simd_float4 *)(v60 + 96) = v76;
    uint64_t v343 = v60;
    re::RenderGraph::addNode(RenderGraph, "SelectionRenderGroup23Node", (uint64_t)v344, (uint64_t)v341);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v341);
    uint64_t v61 = (re *)re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v344);
    uint64_t v62 = (double *)re::globalAllocators(v61)[2];
    unint64_t v339 = v62;
    if (v62) {
      uint64_t v62 = (double *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v62 + 32))(v62, 72, 0);
    }
    re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(v62, v104);
    double v340 = v63;
    uint64_t v336 = re::globalAllocators(v63)[2];
    uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v336 + 32))(v336, 112, 0);
    *(void *)uint64_t v64 = &unk_26E719818;
    *(void *)(v64 + 16) = v8;
    *(double *)(v64 + 24) = v48;
    *(_DWORD *)(v64 + 32) = v49;
    *(_DWORD *)(v64 + 36) = v50;
    *(_DWORD *)(v64 + 40) = v26;
    *(_DWORD *)(v64 + 44) = v27;
    *(simd_float4 *)(v64 + 48) = v79;
    *(simd_float4 *)(v64 + 64) = v78;
    *(simd_float4 *)(v64 + 80) = v77;
    *(simd_float4 *)(v64 + 96) = v76;
    uint64_t v337 = v64;
    re::RenderGraph::addNode(RenderGraph, "SelectionRenderGroup45Node", (uint64_t)v338, (uint64_t)v335);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v335);
    size_t v65 = (re *)re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v338);
    uint64_t v333 = re::globalAllocators(v65)[2];
    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v333 + 32))(v333, 56, 0);
    *(void *)uint64_t v66 = &unk_26E7199B8;
    *(double *)(v66 + 8) = v75;
    *(_DWORD *)(v66 + 16) = v74;
    *(_DWORD *)(v66 + 20) = v73;
    *(double *)(v66 + 24) = v45;
    *(_DWORD *)(v66 + 32) = v46;
    *(_DWORD *)(v66 + 36) = v47;
    *(double *)(v66 + 40) = v48;
    *(_DWORD *)(v66 + 48) = v49;
    *(_DWORD *)(v66 + 52) = v50;
    uint64_t v334 = v66;
    uint64_t v330 = re::globalAllocators((re *)v66)[2];
    uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v330 + 32))(v330, 112, 0);
    *(void *)uint64_t v67 = &unk_26E719818;
    *(void *)(v67 + 16) = v8;
    *(double *)(v67 + 24) = v48;
    *(_DWORD *)(v67 + 32) = v49;
    *(_DWORD *)(v67 + 36) = v50;
    *(_DWORD *)(v67 + 40) = v26;
    *(_DWORD *)(v67 + 44) = v27;
    *(simd_float4 *)(v67 + 48) = v79;
    *(simd_float4 *)(v67 + 64) = v78;
    *(simd_float4 *)(v67 + 80) = v77;
    *(simd_float4 *)(v67 + 96) = v76;
    uint64_t v331 = v67;
    re::RenderGraph::addNode(RenderGraph, "SelectionRenderGroup67Node", (uint64_t)v332, (uint64_t)v329);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v329);
    uint64_t v68 = (re *)re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v332);
    uint64_t v69 = (double *)re::globalAllocators(v68)[2];
    uint64_t v327 = v69;
    if (v69) {
      uint64_t v69 = (double *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v69 + 32))(v69, 248, 0);
    }
    re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(v69, v80);
    unsigned int v328 = v70;
    long long v71 = (double *)re::globalAllocators(v70)[2];
    unint64_t v324 = v71;
    if (v71) {
      long long v71 = (double *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v71 + 32))(v71, 264, 0);
    }
    re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::Callable(v71, (double *)&v359);
    uint64_t v325 = v72;
    re::RenderGraph::addNode(RenderGraph, "SelectionGatherResultsNode", (uint64_t)v326, (uint64_t)v323);
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v323);
    re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v326);
  }
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0,void ()(char const*,char const*,re::RenderFrame &)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E719690;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0,void ()(char const*,char const*,re::RenderFrame &)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E719690;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0,void ()(char const*,char const*,re::RenderFrame &)>::size()
{
  return 16;
}

void *re::RenderGraph::addNode(re *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unint64_t v8 = re::globalAllocators(a1);
  size_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 176, 8);
  uint64_t v16 = *(void *)(a3 + 24);
  uint64_t v17 = 0;
  re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator=<24ul>((uint64_t)v15, a3);
  uint64_t v13 = *(void *)(a4 + 24);
  uint64_t v14 = 0;
  re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::operator=<24ul>((uint64_t)v12, a4);
  re::InlineRenderGraphNode::InlineRenderGraphNode((uint64_t)v9, a2, (uint64_t)v15, (uint64_t)v12);
  re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)v12);
  re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)v15);
  size_t v11 = v9;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v11);
  v9[3] = *((void *)a1 + 10);
  v9[4] = *((void *)a1 + 12);
  v9[6] = *((void *)a1 + 13);
  return v9;
}

uint64_t re::RenderGraphDataStore::get<re::SelectionDrawCallBufferData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27SelectionDrawCallBufferDataE";
  if (((unint64_t)"N2re27SelectionDrawCallBufferDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27SelectionDrawCallBufferDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

uint64_t re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::InlineRenderGraphNode::InlineRenderGraphNode(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_26E6C6978;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (re::StringID *)(a1 + 8);
  *(void *)(a1 + 16) = "";
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 64) = 1;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)a1 = &unk_26E719710;
  *(void *)(a1 + 120) = *(void *)(a3 + 24);
  *(void *)(a1 + 128) = 0;
  re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator=<24ul>(a1 + 96, a3);
  *(void *)(a1 + 160) = *(void *)(a4 + 24);
  *(void *)(a1 + 168) = 0;
  re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::operator=<24ul>(a1 + 136, a4);
  return a1;
}

void re::InlineRenderGraphNode::~InlineRenderGraphNode(id *this)
{
  *this = &unk_26E719710;
  re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)(this + 17));
  re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)(this + 12));
  *this = &unk_26E6C6978;

  re::StringID::destroyString((re::StringID *)(this + 1));
}

{
  uint64_t vars8;

  *this = &unk_26E719710;
  re::FunctionBase<24ul,void ()(re::RenderGraphContext &)>::destroyCallable((uint64_t)(this + 17));
  re::FunctionBase<24ul,void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::destroyCallable((uint64_t)(this + 12));
  *this = &unk_26E6C6978;

  re::StringID::destroyString((re::StringID *)(this + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::InlineRenderGraphNode::getPerFrameValidationCode(re::InlineRenderGraphNode *this)
{
  return 0x11F4512BD17030A0;
}

uint64_t re::InlineRenderGraphNode::getGraphBuildValidationCode(re::InlineRenderGraphNode *this)
{
  return 0x7752D40886CA6E90;
}

uint64_t re::InlineRenderGraphNode::setup(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 16))();
}

uint64_t re::InlineRenderGraphNode::execute(re::InlineRenderGraphNode *this, re::RenderGraphContext *a2)
{
  return (*(uint64_t (**)(void, re::RenderGraphContext *))(**((void **)this + 21) + 16))(*((void *)this + 21), a2);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E7197B0;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E7197B0;
  JUMPOUT(0x237DBCBD0);
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v5 = 0x200000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  int v8 = 0;
  int v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 8, (uint64_t)&v5);
  return re::RenderGraphBuilder::setVisibilityResultsBuffer(a2, a1 + 24);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E7197B0;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  return a2;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(void *a1, void *a2)
{
  *a2 = &unk_26E7197B0;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#1},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 40;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E719818;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::~Callable(void *a1)
{
  *a1 = &unk_26E719818;
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::operator()(uint64_t a1, re::RenderGraphContext *a2)
{
  uint64_t v164 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
  re::RenderGraphContext::acquireManagedRenderEncoder(&v142, a2, v6, 0);
  uint64_t v7 = re::RenderGraphDataStore::get<re::CameraData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  int v8 = (_DWORD *)re::RenderGraphDataStore::get<re::RenderGraphSelectionParams>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v9 = *((void *)a2 + 146);
  uint64_t v10 = *(void *)(*((void *)a2 + 5) + 48);
  unint64_t v11 = (unint64_t)"N2re22DrawCallIdentifierDataE";
  if (((unint64_t)"N2re22DrawCallIdentifierDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)((unint64_t)"N2re22DrawCallIdentifierDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  unsigned int v15 = 0x7FFFFFFF;
  if (*(void *)(v9 + 16))
  {
    unint64_t v16 = (v10 + (v11 << 6) + (v11 >> 2) - 0x61C8864680B583E9) ^ v11;
    unsigned int v17 = *(_DWORD *)(*(void *)(v9 + 24) + 4 * (v16 % *(unsigned int *)(v9 + 40)));
    if (v17 != 0x7FFFFFFF)
    {
      uint64_t v18 = *(void *)(v9 + 32);
      unsigned int v15 = *(_DWORD *)(*(void *)(v9 + 24) + 4 * (v16 % *(unsigned int *)(v9 + 40)));
      if (*(void *)(v18 + 24 * v17 + 8) != v16)
      {
        while (1)
        {
          unsigned int v15 = *(_DWORD *)(v18 + 24
                                * *(unsigned int *)(*(void *)(v9 + 24) + 4 * (v16 % *(unsigned int *)(v9 + 40)))) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v18 + 24 * v15 + 8) == v16) {
            goto LABEL_11;
          }
        }
        unsigned int v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_11:
  uint64_t v19 = *(void *)(*(void *)(v9 + 32) + 24 * v15 + 16);
  uint64_t v109 = re::RenderGraphDataStore::get<re::SelectionDrawCallBufferData>(v9, v10);
  unsigned int v21 = v8[2];
  unsigned int v20 = v8[3];
  unsigned int v23 = v8[4];
  unsigned int v22 = v8[5];
  unsigned int v24 = *(_DWORD *)(a1 + 40);
  if (v21 == -1 && v20 == -1 && v23 == -1 && v22 == -1)
  {
    unsigned int v21 = v24 >> 1;
    unsigned int v28 = *(_DWORD *)(a1 + 44);
    unsigned int v20 = v28 >> 1;
    unsigned int v22 = 1;
    unsigned int v23 = 1;
  }
  else
  {
    unsigned int v28 = *(_DWORD *)(a1 + 44);
  }
  if (v21 + v23 <= v24) {
    uint64_t v29 = v23;
  }
  else {
    uint64_t v29 = v24 - v21;
  }
  uint64_t v157 = v21;
  uint64_t v158 = v20;
  if (v20 + v22 <= v28) {
    uint64_t v30 = v22;
  }
  else {
    uint64_t v30 = v28 - v20;
  }
  v159[0] = v29;
  v159[1] = v30;
  objc_msgSend(v142, sel_setScissorRect_, &v157);
  uint64_t v157 = 0;
  LODWORD(v158) = 0;
  uint64_t v160 = 0;
  int v161 = 0;
  char v163 = 0;
  int v140 = 0;
  memset(v139, 0, sizeof(v139));
  uint64_t v141 = 0x7FFFFFFFLL;
  int v137 = 0;
  memset(v136, 0, sizeof(v136));
  uint64_t v138 = 0x7FFFFFFFLL;
  uint64_t v31 = *(void *)(re::AssetHandle::asset<re::MaterialAsset>((re::MaterialAsset *)(v5 + 136)) + 1664);
  uint64_t v32 = re::RenderGraphDataStore::get<re::MeshLodSelectInputData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v33 = *((void *)a2 + 146);
  unint64_t v34 = (unint64_t)"N2re16SkyboxMeshIDDataE";
  if (((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x8000000000000000) != 0)
  {
    float32x4_t v35 = (unsigned __int8 *)((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v36 = 5381;
    do
    {
      unint64_t v34 = v36;
      unsigned int v37 = *v35++;
      uint64_t v36 = (33 * v36) ^ v37;
    }
    while (v37);
  }
  *(void *)&long long v152 = (*(void *)(*((void *)a2 + 5) + 48) - 0x61C8864680B583E9 + (v34 << 6) + (v34 >> 2)) ^ v34;
  uint64_t v38 = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v33 + 64, (uint64_t *)&v152);
  id v110 = v8;
  int v111 = a2;
  if (v38 && *(void *)v38)
  {
    unint64_t v2 = *(unsigned char **)(*(void *)v38 + 8);
    uint64_t v39 = 1;
  }
  else
  {
    uint64_t v39 = 0;
  }
  uint64_t v40 = 0;
  uint64_t v41 = *(void *)a2;
  uint64_t v42 = *(void *)(*((void *)a2 + 1) + 32);
  uint64_t v43 = *(void *)(v19 + 8);
  v128[1] = 0;
  v128[2] = v32 + 16;
  v128[4] = 0;
  v128[5] = 0;
  v128[3] = &v157;
  do
  {
    *(_DWORD *)((char *)&v128[6] + v40) = -65280;
    v40 += 4;
  }
  while (v40 != 8);
  int v129 = 0;
  char v130 = 0;
  v128[0] = &unk_26E70EDD8;
  uint64_t v131 = v139;
  uint64_t v132 = v43;
  uint64_t v133 = v31;
  uint64_t v134 = v41;
  uint64_t v135 = v42;
  uint64_t v44 = *(void *)(v7 + 440);
  uint64_t v45 = *(void *)(v44 + 40);
  if (v45)
  {
    unint64_t v46 = 0;
    uint64_t v47 = v5 + 240;
    do
    {
      uint64_t v38 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](v44, v46);
      uint64_t v48 = *(void *)(v38 + 16);
      if (v48)
      {
        uint64_t v49 = *(void *)(v38 + 32) + 416;
        uint64_t v50 = 656 * v48;
        do
        {
          if (*(unsigned char **)v49 == v2) {
            char v51 = v39;
          }
          else {
            char v51 = 0;
          }
          if (*(void *)v49)
          {
            if ((v51 & 1) == 0)
            {
              uint64_t v38 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v47, (uint64_t *)v49);
              if ((v38 & 1) == 0 && (*(_DWORD *)(v49 + 12) & *(_DWORD *)(v7 + 504)) != 0) {
                uint64_t v38 = re::mesh_traversal::traverseMeshScene((uint64_t)v128, v49 - 416, v135, 0);
              }
            }
          }
          v49 += 656;
          v50 -= 656;
        }
        while (v50);
      }
      ++v46;
    }
    while (v46 != v45);
  }
  char v126 = 0;
  HIBYTE(v127) = 0;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  uint64_t v120 = 0;
  uint64_t v117 = 0;
  memset(v118, 0, sizeof(v118));
  int v119 = 0;
  memset(v115, 0, sizeof(v115));
  int v116 = 0;
  uint64_t v52 = (uint64_t)v111;
  if (!*(void *)(v7 + 128))
  {
LABEL_59:
    unint64_t v2 = v121;
    unint64_t v58 = *(unsigned __int8 *)(v7 + 490);
    if (v58 <= 1)
    {
      if ((void)v124)
      {
        **((_OWORD **)&v124 + 1) = xmmword_2343854A0;
        if ((void)v124)
        {
          if (*((void *)&v122 + 1))
          {
            uint64_t v67 = v123;
            *(float32x2_t *)v68.f32 = vcvt_f32_u32(*(uint32x2_t *)(a1 + 40));
            v68.i64[1] = v68.i64[0];
            *(float32x4_t *)long long v123 = vrndaq_f32(vmulq_f32(**((float32x4_t **)&v124 + 1), v68));
            *(_DWORD *)(v67 + 16) = 0;
            uint64_t v66 = (_DWORD *)(v67 + 20);
            goto LABEL_71;
          }
          goto LABEL_148;
        }
        goto LABEL_146;
      }
    }
    else
    {
      if ((void)v124)
      {
        **((_OWORD **)&v124 + 1) = xmmword_2343E1EE0;
        unint64_t v60 = v124;
        if ((void)v124)
        {
          if (*((void *)&v122 + 1))
          {
            uint64_t v61 = *((void *)&v124 + 1);
            uint64_t v62 = v123;
            *(float32x2_t *)v63.f32 = vcvt_f32_u32(*(uint32x2_t *)(a1 + 40));
            v63.i64[1] = v63.i64[0];
            *(float32x4_t *)long long v123 = vrndaq_f32(vmulq_f32(**((float32x4_t **)&v124 + 1), v63));
            *(void *)(v62 + 16) = 0x3F80000000000000;
            if (v60 > 1)
            {
              *(_OWORD *)(v61 + 16) = xmmword_2343E1EF0;
              uint64_t v39 = v124;
              if ((unint64_t)v124 > 1)
              {
                uint64_t v39 = *((void *)&v122 + 1);
                if (*((void *)&v122 + 1) > 1uLL)
                {
                  uint64_t v64 = v123;
                  *(float32x2_t *)v65.f32 = vcvt_f32_u32(*(uint32x2_t *)(a1 + 40));
                  v65.i64[1] = v65.i64[0];
                  *(float32x4_t *)(v123 + 24) = vrndaq_f32(vmulq_f32(*(float32x4_t *)(*((void *)&v124 + 1) + 16), v65));
                  *(_DWORD *)(v64 + 40) = 0;
                  uint64_t v66 = (_DWORD *)(v64 + 44);
LABEL_71:
                  *uint64_t v66 = 1065353216;
                  char v125 = 2;
                  v121[0] = 0;
                  __int16 v127 = 0;
                  uint64_t v7 = re::RenderGraphContext::rtResolution(v111);
                  if (*((unsigned char *)v111 + 1332)) {
                    goto LABEL_140;
                  }
                  uint64_t v69 = 0;
                  uint64_t v70 = 0;
                  goto LABEL_73;
                }
LABEL_151:
                uint64_t v112 = 0;
                long long v155 = 0u;
                long long v156 = 0u;
                long long v153 = 0u;
                long long v154 = 0u;
                long long v152 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                int v144 = 136315906;
                int v145 = "operator[]";
                __int16 v146 = 1024;
                int v147 = 468;
                __int16 v148 = 2048;
                uint64_t v149 = 1;
                __int16 v150 = 2048;
                uint64_t v151 = v39;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
              }
LABEL_150:
              uint64_t v112 = 0;
              long long v155 = 0u;
              long long v156 = 0u;
              long long v153 = 0u;
              long long v154 = 0u;
              long long v152 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v144 = 136315906;
              int v145 = "operator[]";
              __int16 v146 = 1024;
              int v147 = 468;
              __int16 v148 = 2048;
              uint64_t v149 = 1;
              __int16 v150 = 2048;
              uint64_t v151 = v39;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_151;
            }
LABEL_149:
            uint64_t v112 = 0;
            long long v155 = 0u;
            long long v156 = 0u;
            long long v153 = 0u;
            long long v154 = 0u;
            long long v152 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v144 = 136315906;
            int v145 = "operator[]";
            __int16 v146 = 1024;
            int v147 = 468;
            __int16 v148 = 2048;
            uint64_t v149 = 1;
            __int16 v150 = 2048;
            uint64_t v151 = 1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_150;
          }
          goto LABEL_147;
        }
        goto LABEL_145;
      }
      uint64_t v112 = 0;
      long long v155 = 0u;
      long long v156 = 0u;
      long long v153 = 0u;
      long long v154 = 0u;
      long long v152 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v144 = 136315906;
      int v145 = "operator[]";
      __int16 v146 = 1024;
      int v147 = 468;
      __int16 v148 = 2048;
      uint64_t v149 = 0;
      __int16 v150 = 2048;
      uint64_t v151 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v112 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v144 = 136315906;
    int v145 = "operator[]";
    __int16 v146 = 1024;
    int v147 = 468;
    __int16 v148 = 2048;
    uint64_t v149 = 0;
    __int16 v150 = 2048;
    uint64_t v151 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_145:
    uint64_t v112 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v144 = 136315906;
    int v145 = "operator[]";
    __int16 v146 = 1024;
    int v147 = 468;
    __int16 v148 = 2048;
    uint64_t v149 = 0;
    __int16 v150 = 2048;
    uint64_t v151 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_146:
    uint64_t v112 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v144 = 136315906;
    int v145 = "operator[]";
    __int16 v146 = 1024;
    int v147 = 468;
    __int16 v148 = 2048;
    uint64_t v149 = 0;
    __int16 v150 = 2048;
    uint64_t v151 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_147:
    uint64_t v112 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v144 = 136315906;
    int v145 = "operator[]";
    __int16 v146 = 1024;
    int v147 = 468;
    __int16 v148 = 2048;
    uint64_t v149 = 0;
    __int16 v150 = 2048;
    uint64_t v151 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_148:
    uint64_t v112 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v144 = 136315906;
    int v145 = "operator[]";
    __int16 v146 = 1024;
    int v147 = 468;
    __int16 v148 = 2048;
    uint64_t v149 = 0;
    __int16 v150 = 2048;
    uint64_t v151 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_149;
  }
  unint64_t v53 = 0;
  LODWORD(v39) = 0;
  while (1)
  {
    re::Projection::computeMatrix4x4F((re::Projection *)(v7 + 144 + (v53 << 6)), (uint64_t)&v152);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v118, (uint64_t)&v152);
    if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 64)), (int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 48))), vandq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 80)), (int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 96))))) & 0x80000000) != 0)break; {
    long long v55 = *(_OWORD *)(a1 + 64);
    }
    long long v152 = *(_OWORD *)(a1 + 48);
    long long v153 = v55;
    long long v56 = *(_OWORD *)(a1 + 96);
    long long v154 = *(_OWORD *)(a1 + 80);
    long long v155 = v56;
LABEL_58:
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v115, (uint64_t)&v152);
    uint64_t v39 = (v39 + 1);
    unint64_t v53 = v39;
    if (*(void *)(v7 + 128) <= (unint64_t)v39) {
      goto LABEL_59;
    }
  }
  unint64_t v57 = *(void *)(v7 + 48);
  if (v57 > v53)
  {
    re::RenderCamera::computeInverseTransform((float32x4_t *)(v7 + 64 + 32 * v53), (uint64_t)&v152);
    goto LABEL_58;
  }
  re::internal::assertLog((re::internal *)6, v54, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v53, v57);
  _os_crash();
  __break(1u);
LABEL_140:
  uint64_t v70 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)v111 + 1336), "SelectionEmitter", "SelectionAll");
  if (!*((unsigned char *)v111 + 1332))
  {
    uint64_t v69 = 0;
    goto LABEL_73;
  }
  uint64_t v69 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)v111 + 1336), "SelectionEmitter", "SelectionNearestPass1");
  if (!*((unsigned char *)v111 + 1332))
  {
LABEL_73:
    uint64_t v71 = 0;
    goto LABEL_74;
  }
  uint64_t v71 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)v111 + 1336), "SelectionEmitter", "SelectionNearestPass2");
LABEL_74:
  ((void (*)(void, char *, id))v143[19])(*v143, sel_pushDebugGroup_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "Selection", 4));
  int v72 = v110[6];
  int v73 = *(const char **)(*((void *)v111 + 5) + 16);
  int v74 = strcmp(v73, "SelectionRenderGroup01Node");
  if (v72 == 1)
  {
    double v75 = "SelectionAllGroup01";
    BOOL v76 = "SelectionAllGroup01" == "SelectionAll";
    if (v74)
    {
      double v75 = "SelectionAllGroup23";
      BOOL v76 = "SelectionAllGroup23" == "SelectionAll";
      if (strcmp(v73, "SelectionRenderGroup23Node"))
      {
        double v75 = "SelectionAllGroup45";
        BOOL v76 = "SelectionAllGroup45" == "SelectionAll";
        if (strcmp(v73, "SelectionRenderGroup45Node"))
        {
          int v77 = strcmp(v73, "SelectionRenderGroup67Node");
          if (v77) {
            double v75 = "SelectionAll";
          }
          else {
            double v75 = "SelectionAllGroup67";
          }
          BOOL v76 = "SelectionAllGroup67" == "SelectionAll" || v77 != 0;
        }
      }
    }
    size_t v78 = strlen(v75);
    if (v78)
    {
      MurmurHash3_x64_128((uint64_t)v75, v78, 0, (unint64_t *)&v152);
      unint64_t v79 = (*((void *)&v152 + 1) - 0x61C8864680B583E9 + ((void)v152 << 6) + ((unint64_t)v152 >> 2)) ^ v152;
    }
    else
    {
      unint64_t v79 = 0;
    }
    *(void *)&long long v152 = v79;
    uint64_t v82 = re::HashTable<unsigned long,re::DrawTable,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)v139, (uint64_t *)&v152);
    if (v82)
    {
      re::DrawTableSlice::DrawTableSlice(&v152, v82);
      uint64_t v83 = *(void *)v111;
      uint64_t v84 = *((void *)v111 + 1);
      uint64_t v85 = *((void *)v111 + 3);
      re::RenderGraphContext::rtInfo(v111, *((re::RenderGraphNodeBase **)v111 + 5), (uint64_t)&v144);
      uint64_t v112 = 134217472;
      uint64_t v113 = 134217472;
      char v114 = 0;
      re::encodeDrawCalls((uint64_t)&v142, (uint64_t)&v152, v83, v84, v85, (uint64_t)&v144, (uint64_t)&v112, (uint64_t)v75, *(void *)(*((void *)v111 + 5) + 16), *(void *)(*((void *)v111 + 5) + 24), *(void *)(*((void *)v111 + 5) + 32), v117, v120, (uint64_t)v121, v7, v70, v76, 0, 0,
        0,
        0);
    }
  }
  else
  {
    if (v74)
    {
      uint64_t v80 = v109;
      if (!strcmp(v73, "SelectionRenderGroup23Node"))
      {
        int v81 = "SelectionNearestPass1Group23";
      }
      else if (!strcmp(v73, "SelectionRenderGroup45Node"))
      {
        int v81 = "SelectionNearestPass1Group45";
      }
      else if (!strcmp(v73, "SelectionRenderGroup67Node"))
      {
        int v81 = "SelectionNearestPass1Group67";
      }
      else
      {
        int v81 = "SelectionNearestPass1";
      }
    }
    else
    {
      int v81 = "SelectionNearestPass1Group01";
      uint64_t v80 = v109;
    }
    size_t v86 = strlen(v81);
    if (v86)
    {
      MurmurHash3_x64_128((uint64_t)v81, v86, 0, (unint64_t *)&v152);
      unint64_t v87 = (*((void *)&v152 + 1) - 0x61C8864680B583E9 + ((void)v152 << 6) + ((unint64_t)v152 >> 2)) ^ v152;
    }
    else
    {
      unint64_t v87 = 0;
    }
    *(void *)&long long v152 = v87;
    uint64_t v88 = re::HashTable<unsigned long,re::DrawTable,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)v139, (uint64_t *)&v152);
    if (v88)
    {
      re::DrawTableSlice::DrawTableSlice(&v152, v88);
      uint64_t v89 = *(void *)v111;
      uint64_t v90 = *((void *)v111 + 1);
      uint64_t v91 = *((void *)v111 + 3);
      re::RenderGraphContext::rtInfo(v111, *((re::RenderGraphNodeBase **)v111 + 5), (uint64_t)&v144);
      uint64_t v112 = 134217472;
      uint64_t v113 = 134217472;
      char v114 = 0;
      uint64_t v92 = v90;
      uint64_t v93 = v91;
      unint64_t v2 = v121;
      uint64_t v52 = (uint64_t)v111;
      re::encodeDrawCalls((uint64_t)&v142, (uint64_t)&v152, v89, v92, v93, (uint64_t)&v144, (uint64_t)&v112, (uint64_t)v81, *(void *)(*((void *)v111 + 5) + 16), *(void *)(*((void *)v111 + 5) + 24), *(void *)(*((void *)v111 + 5) + 32), v117, v120, (uint64_t)v121, v7, v69, 0, 0, 0,
        0,
        0);
    }
    if (*(void *)(v80 + 8))
    {
      id v94 = objc_msgSend(*(id *)re::RenderGraphContext::metalBuffer(v52, a1 + 24), sel_contents);
      bzero(v94, *(void *)(v80 + 8));
    }
    uint64_t v95 = *(const char **)(*(void *)(v52 + 40) + 16);
    int v96 = "SelectionNearestPass2Group01";
    BOOL v97 = "SelectionNearestPass2Group01" == "SelectionNearestPass2";
    if (strcmp(v95, "SelectionRenderGroup01Node"))
    {
      int v96 = "SelectionNearestPass2Group23";
      BOOL v97 = "SelectionNearestPass2Group23" == "SelectionNearestPass2";
      if (strcmp(v95, "SelectionRenderGroup23Node"))
      {
        int v96 = "SelectionNearestPass2Group45";
        BOOL v97 = "SelectionNearestPass2Group45" == "SelectionNearestPass2";
        if (strcmp(v95, "SelectionRenderGroup45Node"))
        {
          int v98 = strcmp(v95, "SelectionRenderGroup67Node");
          if (v98) {
            int v96 = "SelectionNearestPass2";
          }
          else {
            int v96 = "SelectionNearestPass2Group67";
          }
          BOOL v97 = "SelectionNearestPass2Group67" == "SelectionNearestPass2" || v98 != 0;
        }
      }
    }
    size_t v99 = strlen(v96);
    if (v99)
    {
      MurmurHash3_x64_128((uint64_t)v96, v99, 0, (unint64_t *)&v152);
      unint64_t v100 = (*((void *)&v152 + 1) - 0x61C8864680B583E9 + ((void)v152 << 6) + ((unint64_t)v152 >> 2)) ^ v152;
    }
    else
    {
      unint64_t v100 = 0;
    }
    *(void *)&long long v152 = v100;
    uint64_t v101 = re::HashTable<unsigned long,re::DrawTable,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)v139, (uint64_t *)&v152);
    if (v101)
    {
      re::DrawTableSlice::DrawTableSlice(&v152, v101);
      uint64_t v102 = *(void *)v52;
      uint64_t v103 = *(void *)(v52 + 8);
      uint64_t v104 = *(void *)(v52 + 24);
      re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v52, *(re::RenderGraphNodeBase **)(v52 + 40), (uint64_t)&v144);
      uint64_t v112 = 134217472;
      uint64_t v113 = 134217472;
      char v114 = 0;
      re::encodeDrawCalls((uint64_t)&v142, (uint64_t)&v152, v102, v103, v104, (uint64_t)&v144, (uint64_t)&v112, (uint64_t)v96, *(void *)(*(void *)(v52 + 40) + 16), *(void *)(*(void *)(v52 + 40) + 24), *(void *)(*(void *)(v52 + 40) + 32), v117, v120, (uint64_t)v121, v7, v71, v97, 0, 0,
        0,
        0);
    }
  }
  ((void (*)(void, char *))v143[20])(*v143, sel_popDebugGroup);
  if (v115[0] && v117) {
    (*(void (**)(void))(*(void *)v115[0] + 40))();
  }
  if (v118[0] && v120) {
    (*(void (**)(void))(*(void *)v118[0] + 40))();
  }
  if (*((void *)&v123 + 1))
  {
    if ((void)v124)
    {
      (*(void (**)(void))(**((void **)&v123 + 1) + 40))();
      *((void *)v2 + 5) = 0;
      *((void *)v2 + 6) = 0;
    }
    *((void *)&v123 + 1) = 0;
  }
  if ((void)v122 && *((void *)&v122 + 1)) {
    (*(void (**)(void))(*(void *)v122 + 40))();
  }
  re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)v136);
  re::HashTable<unsigned long,re::DrawTable,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)v139);
  if (v160)
  {
    int v105 = v162;
    int v106 = &v162[9 * v160];
    do
    {
      *(void *)int v105 = 0;
      ++*((_DWORD *)v105 + 2);
      v105 += 9;
    }
    while (v105 != v106);
  }
  if (v157)
  {
    double v107 = v159;
    int v108 = &v159[14 * v157];
    do
    {
      *double v107 = 0;
      ++*((_DWORD *)v107 + 2);
      v107 += 14;
    }
    while (v107 != v108);
  }
  re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)&v142);
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E719818;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = -1;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a2 + 24) = v2;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  long long v3 = *(_OWORD *)(a1 + 56);
  long long v4 = *(_OWORD *)(a1 + 72);
  long long v5 = *(_OWORD *)(a1 + 88);
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(_OWORD *)(a2 + 88) = v5;
  *(_OWORD *)(a2 + 72) = v4;
  *(_OWORD *)(a2 + 56) = v3;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E719818;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = -1;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a2 + 24) = v2;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  long long v3 = *(_OWORD *)(a1 + 56);
  long long v4 = *(_OWORD *)(a1 + 72);
  long long v5 = *(_OWORD *)(a1 + 88);
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(_OWORD *)(a2 + 88) = v5;
  *(_OWORD *)(a2 + 72) = v4;
  *(_OWORD *)(a2 + 56) = v3;
  return a2;
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#1},void ()(re::RenderGraphContext &)>::size()
{
  return 112;
}

uint64_t re::RenderGraphDataStore::get<re::RenderGraphSelectionParams>(uint64_t a1, uint64_t a2)
{
  void v11[2] = *MEMORY[0x263EF8340];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A920, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9A920))
  {
    qword_26AF9A918 = re::internal::getOrCreateInfo((re::internal *)"RenderGraphSelectionParams", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphSelectionParams, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphSelectionParams, (void (*)(re::IntrospectionBase *))&unk_26AF9A8F0, 0);
    __cxa_guard_release(&qword_26AF9A920);
  }
  size_t v4 = strlen(*(const char **)(qword_26AF9A918 + 48));
  if (v4)
  {
    MurmurHash3_x64_128(*(void *)(qword_26AF9A918 + 48), v4, 0, v11);
    unint64_t v5 = (v11[1] - 0x61C8864680B583E9 + (v11[0] << 6) + (v11[0] >> 2)) ^ v11[0];
  }
  else
  {
    unint64_t v5 = 0;
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 - 0x61C8864680B583E9 + (v5 << 6) + (v5 >> 2)) ^ v5;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

uint64_t re::RenderGraphDataStore::get<re::MeshLodSelectInputData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re22MeshLodSelectInputDataE";
  if (((unint64_t)"N2re22MeshLodSelectInputDataE" & 0x8000000000000000) != 0)
  {
    long long v3 = (unsigned __int8 *)((unint64_t)"N2re22MeshLodSelectInputDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(double *a1, double *a2)
{
  *(void *)a1 = &unk_26E7198B0;
  a1[1] = 0.0;
  a1[2] = NAN;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = 0.0;
  a1[4] = NAN;
  a1[3] = a2[2];
  a1[4] = a2[3];
  a1[5] = 0.0;
  a1[6] = NAN;
  a1[5] = a2[4];
  a1[6] = a2[5];
  a1[7] = 0.0;
  a1[8] = NAN;
  a1[7] = a2[6];
  double result = a2[7];
  a1[8] = result;
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E7198B0;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E7198B0;
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v5[0] = 0x100000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 8, (uint64_t)v5);
  v5[0] = 0x100000001;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 24, (uint64_t)v5);
  v5[0] = 0x200000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  return re::RenderGraphBuilder::write(a2, a1 + 40, (uint64_t)v5);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E7198B0;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = -1;
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = 0;
  a2[8] = -1;
  a2[7] = a1[7];
  a2[8] = a1[8];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#2},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 72;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(double *a1, double *a2)
{
  *(void *)a1 = &unk_26E719908;
  a1[1] = 0.0;
  a1[2] = NAN;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = 0.0;
  a1[4] = NAN;
  a1[3] = a2[2];
  a1[4] = a2[3];
  a1[5] = 0.0;
  a1[6] = NAN;
  a1[5] = a2[4];
  a1[6] = a2[5];
  a1[7] = 0.0;
  a1[8] = NAN;
  a1[7] = a2[6];
  double result = a2[7];
  a1[8] = result;
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E719908;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E719908;
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v5[0] = 0x100000002;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 8, (uint64_t)v5);
  v5[0] = 0x100000003;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 24, (uint64_t)v5);
  v5[0] = 0x200000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  return re::RenderGraphBuilder::write(a2, a1 + 40, (uint64_t)v5);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E719908;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = -1;
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = 0;
  a2[8] = -1;
  a2[7] = a1[7];
  a2[8] = a1[8];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#3},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 72;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(double *a1, double *a2)
{
  *(void *)a1 = &unk_26E719960;
  a1[1] = 0.0;
  a1[2] = NAN;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = 0.0;
  a1[4] = NAN;
  a1[3] = a2[2];
  a1[4] = a2[3];
  a1[5] = 0.0;
  a1[6] = NAN;
  a1[5] = a2[4];
  a1[6] = a2[5];
  a1[7] = 0.0;
  a1[8] = NAN;
  a1[7] = a2[6];
  double result = a2[7];
  a1[8] = result;
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E719960;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E719960;
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v5[0] = 0x100000004;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 8, (uint64_t)v5);
  v5[0] = 0x100000005;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 24, (uint64_t)v5);
  v5[0] = 0x200000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  return re::RenderGraphBuilder::write(a2, a1 + 40, (uint64_t)v5);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E719960;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = -1;
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = 0;
  a2[8] = -1;
  a2[7] = a1[7];
  a2[8] = a1[8];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#4},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 72;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(double *a1, double *a2)
{
  *(void *)a1 = &unk_26E7199B8;
  a1[1] = 0.0;
  a1[2] = NAN;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = 0.0;
  a1[4] = NAN;
  a1[3] = a2[2];
  a1[4] = a2[3];
  a1[5] = 0.0;
  a1[6] = NAN;
  a1[5] = a2[4];
  double result = a2[5];
  a1[6] = result;
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E7199B8;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E7199B8;
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v5[0] = 0x100000006;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 8, (uint64_t)v5);
  v5[0] = 0x200000000;
  long long v6 = xmmword_23435FBB0;
  __int16 v7 = 0;
  uint64_t v8 = 0;
  return re::RenderGraphBuilder::write(a2, a1 + 24, (uint64_t)v5);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E7199B8;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = -1;
  a2[5] = a1[5];
  a2[6] = a1[6];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#5},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 56;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(double *a1, double *a2)
{
  *(void *)a1 = &unk_26E719A10;
  a1[1] = 0.0;
  a1[2] = NAN;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = 0.0;
  a1[4] = NAN;
  a1[3] = a2[2];
  a1[4] = a2[3];
  a1[5] = 0.0;
  a1[6] = NAN;
  a1[5] = a2[4];
  a1[6] = a2[5];
  a1[7] = 0.0;
  a1[8] = NAN;
  a1[7] = a2[6];
  a1[8] = a2[7];
  a1[9] = 0.0;
  a1[10] = NAN;
  a1[9] = a2[8];
  a1[10] = a2[9];
  a1[11] = 0.0;
  a1[12] = NAN;
  a1[11] = a2[10];
  a1[12] = a2[11];
  a1[13] = 0.0;
  a1[14] = NAN;
  a1[13] = a2[12];
  a1[14] = a2[13];
  a1[15] = 0.0;
  a1[16] = NAN;
  a1[15] = a2[14];
  a1[16] = a2[15];
  a1[17] = 0.0;
  a1[18] = NAN;
  a1[17] = a2[16];
  a1[18] = a2[17];
  a1[19] = 0.0;
  a1[20] = NAN;
  a1[19] = a2[18];
  a1[20] = a2[19];
  a1[21] = 0.0;
  a1[22] = NAN;
  a1[21] = a2[20];
  a1[22] = a2[21];
  a1[23] = 0.0;
  a1[24] = NAN;
  a1[23] = a2[22];
  a1[24] = a2[23];
  a1[25] = 0.0;
  a1[26] = NAN;
  a1[25] = a2[24];
  a1[26] = a2[25];
  a1[27] = 0.0;
  a1[28] = NAN;
  a1[27] = a2[26];
  a1[28] = a2[27];
  a1[29] = 0.0;
  a1[30] = NAN;
  a1[29] = a2[28];
  double result = a2[29];
  a1[30] = result;
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E719A10;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::~Callable(void *a1)
{
  *a1 = &unk_26E719A10;
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 8;
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 120, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, v4, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 24, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 40, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 56, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 72, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 88, (uint64_t)&v5);
  *(_DWORD *)((char *)&v5 + 3) = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, a1 + 104, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 136, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 152, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 168, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 184, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 200, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 216, (uint64_t)&v5);
  uint64_t v5 = 0x400000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write(a2, a1 + 232, (uint64_t)&v5);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::cloneInto(void *a1, void *a2)
{
  *a2 = &unk_26E719A10;
  a2[1] = 0;
  a2[2] = -1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = 0;
  a2[4] = -1;
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = -1;
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = 0;
  a2[8] = -1;
  a2[7] = a1[7];
  a2[8] = a1[8];
  a2[9] = 0;
  a2[10] = -1;
  a2[9] = a1[9];
  a2[10] = a1[10];
  a2[11] = 0;
  a2[12] = -1;
  a2[11] = a1[11];
  a2[12] = a1[12];
  a2[13] = 0;
  a2[14] = -1;
  a2[13] = a1[13];
  a2[14] = a1[14];
  a2[15] = 0;
  a2[16] = -1;
  a2[15] = a1[15];
  a2[16] = a1[16];
  a2[17] = 0;
  a2[18] = -1;
  a2[17] = a1[17];
  a2[18] = a1[18];
  a2[19] = 0;
  a2[20] = -1;
  a2[19] = a1[19];
  a2[20] = a1[20];
  a2[21] = 0;
  a2[22] = -1;
  a2[21] = a1[21];
  a2[22] = a1[22];
  a2[23] = 0;
  a2[24] = -1;
  a2[23] = a1[23];
  a2[24] = a1[24];
  a2[25] = 0;
  a2[26] = -1;
  a2[25] = a1[25];
  a2[26] = a1[26];
  a2[27] = 0;
  a2[28] = -1;
  a2[27] = a1[27];
  a2[28] = a1[28];
  a2[29] = 0;
  a2[30] = -1;
  a2[29] = a1[29];
  a2[30] = a1[30];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphBuilder &,re::RenderGraphDataStore &)#6},void ()(re::RenderGraphBuilder &,re::RenderGraphDataStore &)>::size()
{
  return 248;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::Callable(double *a1, double *a2)
{
  a1[2] = 0.0;
  double v2 = *a2;
  uint64_t v3 = *((void *)a2 + 1);
  *(void *)a1 = &unk_26E719A68;
  a1[1] = v2;
  a1[3] = NAN;
  *((void *)a1 + 2) = v3;
  a1[3] = a2[2];
  a1[4] = 0.0;
  a1[5] = NAN;
  a1[4] = a2[3];
  a1[5] = a2[4];
  a1[6] = 0.0;
  a1[7] = NAN;
  a1[6] = a2[5];
  a1[7] = a2[6];
  a1[8] = 0.0;
  a1[9] = NAN;
  a1[8] = a2[7];
  a1[9] = a2[8];
  a1[10] = 0.0;
  a1[11] = NAN;
  a1[10] = a2[9];
  a1[11] = a2[10];
  a1[12] = 0.0;
  a1[13] = NAN;
  a1[12] = a2[11];
  a1[13] = a2[12];
  a1[14] = 0.0;
  a1[15] = NAN;
  a1[14] = a2[13];
  a1[15] = a2[14];
  a1[16] = 0.0;
  a1[17] = NAN;
  a1[16] = a2[15];
  a1[17] = a2[16];
  a1[18] = 0.0;
  a1[19] = NAN;
  a1[18] = a2[17];
  a1[19] = a2[18];
  a1[20] = 0.0;
  a1[21] = NAN;
  a1[20] = a2[19];
  a1[21] = a2[20];
  a1[22] = 0.0;
  a1[23] = NAN;
  a1[22] = a2[21];
  a1[23] = a2[22];
  a1[24] = 0.0;
  a1[25] = NAN;
  a1[24] = a2[23];
  a1[25] = a2[24];
  a1[26] = 0.0;
  a1[27] = NAN;
  a1[26] = a2[25];
  a1[27] = a2[26];
  a1[28] = 0.0;
  a1[29] = NAN;
  a1[28] = a2[27];
  a1[29] = a2[28];
  a1[30] = 0.0;
  a1[31] = NAN;
  a1[30] = a2[29];
  double result = a2[30];
  a1[31] = result;
  a1[32] = a2[31];
  return result;
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::~Callable(void *result)
{
  uint64_t *result = &unk_26E719A68;
  return result;
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::~Callable(void *a1)
{
  *a1 = &unk_26E719A68;
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_DWORD *)re::RenderGraphDataStore::get<re::RenderGraphSelectionParams>(*(void *)(a2 + 1168), *(void *)(*(void *)(a2 + 40) + 48));
  uint64_t v5 = *(unsigned int *)(a1 + 256);
  uint64_t v6 = 8 * v5;
  unsigned int v7 = *(_DWORD *)(a1 + 260);
  unsigned int v8 = v7 * v5;
  uint64_t v9 = 8 * v7 * v5;
  uint64_t v33 = 16 * v7 * v5;
  uint64_t v34 = 16 * v5;
  unsigned int v10 = v4[2];
  unsigned int v11 = v4[3];
  int v12 = v10 & v11 & v4[4] & v4[5];
  unsigned int v13 = v7 >> 1;
  if (v12 == -1) {
    uint64_t v14 = v5 >> 1;
  }
  else {
    uint64_t v14 = v10;
  }
  if (v12 == -1) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = v11;
  }
  uint64_t v16 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(a2 + 8) + 104));
  re::RenderGraphContext::acquireManagedBlitEncoder(a2, v16, *(re::RenderGraphNodeBase **)(a2 + 40), 0, &v37);
  re::RenderGraphContext::metalTexture(a2, a1 + 16, 0, 0, &v36);
  id v17 = v36;
  uint64_t v18 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 144);
  uint64_t v40 = v14;
  uint64_t v41 = v15;
  uint64_t v35 = v15;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v17 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v18 destinationOffset:0 destinationBytesPerRow:8 * v5 destinationBytesPerImage:v9];
  if (v36) {

  }
  re::RenderGraphContext::metalTexture(a2, a1 + 32, 0, 0, &v36);
  id v19 = v36;
  unsigned int v20 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 160);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v19 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v20 destinationOffset:0 destinationBytesPerRow:v34 destinationBytesPerImage:v33];
  if (v36) {

  }
  re::RenderGraphContext::metalTexture(a2, a1 + 48, 0, 0, &v36);
  id v21 = v36;
  unsigned int v22 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 176);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v21 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v22 destinationOffset:0 destinationBytesPerRow:v34 destinationBytesPerImage:v33];
  if (v36) {

  }
  uint64_t v23 = 4 * v5;
  uint64_t v24 = 4 * v8;
  re::RenderGraphContext::metalTexture(a2, a1 + 64, 0, 0, &v36);
  id v25 = v36;
  int v26 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 192);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v25 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v26 destinationOffset:0 destinationBytesPerRow:v6 destinationBytesPerImage:v9];
  if (v36) {

  }
  re::RenderGraphContext::metalTexture(a2, a1 + 80, 0, 0, &v36);
  id v27 = v36;
  unsigned int v28 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 208);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v27 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v28 destinationOffset:0 destinationBytesPerRow:v23 destinationBytesPerImage:v24];
  if (v36) {

  }
  re::RenderGraphContext::metalTexture(a2, a1 + 96, 0, 0, &v36);
  id v29 = v36;
  uint64_t v30 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 224);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v29 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v30 destinationOffset:0 destinationBytesPerRow:v23 destinationBytesPerImage:v24];
  if (v36) {

  }
  re::RenderGraphContext::metalTexture(a2, a1 + 112, 0, 0, &v36);
  id v31 = v36;
  uint64_t v32 = (void *)re::RenderGraphContext::metalBuffer(a2, a1 + 240);
  uint64_t v40 = v14;
  uint64_t v41 = v35;
  uint64_t v42 = 0;
  int64x2_t v38 = vdupq_n_s64(1uLL);
  uint64_t v39 = 1;
  [v37 copyFromTexture:v31 sourceSlice:0 sourceLevel:0 sourceOrigin:&v40 sourceSize:&v38 toBuffer:*v32 destinationOffset:0 destinationBytesPerRow:v34 destinationBytesPerImage:v33];
  if (v36) {

  }
  re::RenderGraphContext::metalBuffer(a2, a1 + 128);
  re::RenderGraphContext::metalBuffer(a2, a1 + 144);
  re::RenderGraphContext::metalBuffer(a2, a1 + 160);
  re::RenderGraphContext::metalBuffer(a2, a1 + 176);
  re::RenderGraphContext::metalBuffer(a2, a1 + 192);
  re::RenderGraphContext::metalBuffer(a2, a1 + 208);
  re::RenderGraphContext::metalBuffer(a2, a1 + 224);
  re::RenderGraphContext::metalBuffer(a2, a1 + 240);
}

void *re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::cloneInto(void *a1, void *a2)
{
  a2[2] = 0;
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  *a2 = &unk_26E719A68;
  a2[1] = v2;
  a2[3] = -1;
  a2[2] = v3;
  a2[3] = a1[3];
  a2[4] = 0;
  a2[5] = -1;
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = 0;
  a2[7] = -1;
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = 0;
  a2[9] = -1;
  a2[8] = a1[8];
  a2[9] = a1[9];
  a2[10] = 0;
  a2[11] = -1;
  a2[10] = a1[10];
  a2[11] = a1[11];
  a2[12] = 0;
  a2[13] = -1;
  a2[12] = a1[12];
  a2[13] = a1[13];
  a2[14] = 0;
  a2[15] = -1;
  a2[14] = a1[14];
  a2[15] = a1[15];
  a2[16] = 0;
  a2[17] = -1;
  a2[16] = a1[16];
  a2[17] = a1[17];
  a2[18] = 0;
  a2[19] = -1;
  a2[18] = a1[18];
  a2[19] = a1[19];
  a2[20] = 0;
  a2[21] = -1;
  a2[20] = a1[20];
  a2[21] = a1[21];
  a2[22] = 0;
  a2[23] = -1;
  a2[22] = a1[22];
  a2[23] = a1[23];
  a2[24] = 0;
  a2[25] = -1;
  a2[24] = a1[24];
  a2[25] = a1[25];
  a2[26] = 0;
  a2[27] = -1;
  a2[26] = a1[26];
  a2[27] = a1[27];
  a2[28] = 0;
  a2[29] = -1;
  a2[28] = a1[28];
  a2[29] = a1[29];
  a2[30] = 0;
  a2[31] = -1;
  a2[30] = a1[30];
  a2[31] = a1[31];
  a2[32] = a1[32];
  return a2;
}

double re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::moveInto(uint64_t a1, double *a2)
{
  return re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::Callable(a2, (double *)(a1 + 8));
}

uint64_t re::internal::Callable<re::RenderGraphSelectionEmitter::registerProviders(re::RenderGraphManager &,re::AssetService *)::$_0::operator() const(char const*,char const*,re::RenderFrame &)::{lambda(re::RenderGraphContext &)#2},void ()(re::RenderGraphContext &)>::size()
{
  return 264;
}

void *std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void re::RenderGraphEmitterBase::~RenderGraphEmitterBase(re::RenderGraphEmitterBase *this)
{
  *(void *)this = &unk_26E71EFD0;
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 11);
  re::DynamicArray<re::BindPointAndPath>::deinit((uint64_t)this + 48);
  re::BindNode::deinit((re::RenderGraphEmitterBase *)((char *)this + 16));
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26E719AC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E719AC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v20 = *a4;
  unint64_t v5 = (unint64_t)"N2re16SkyboxMeshIDDataE";
  if (((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"N2re16SkyboxMeshIDDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  unint64_t v9 = (qword_26AF9A8F8 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5;
  unsigned int v10 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a3 + 8) + 32))(*(void *)(a3 + 8), 16, 8);
  unint64_t v11 = *(void *)(a3 + 64);
  int v12 = v10;
  *unsigned int v10 = &unk_26E719B40;
  v10[1] = v20;
  if (v11)
  {
    unint64_t v11 = v9 % *(unsigned int *)(a3 + 88);
    uint64_t v13 = *(unsigned int *)(*(void *)(a3 + 72) + 4 * v11);
    if (v13 != 0x7FFFFFFF)
    {
      uint64_t v19 = *(void *)(a3 + 80);
      if (*(void *)(v19 + 24 * v13 + 8) == v9) {
        return;
      }
      while (1)
      {
        LODWORD(v13) = *(_DWORD *)(v19 + 24 * v13) & 0x7FFFFFFF;
        if (v13 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v19 + 24 * v13 + 8) == v9) {
          return;
        }
      }
    }
  }
  uint64_t v14 = *(unsigned int *)(a3 + 100);
  if (v14 == 0x7FFFFFFF)
  {
    uint64_t v14 = *(unsigned int *)(a3 + 96);
    int v15 = v14;
    if (v14 == *(_DWORD *)(a3 + 88))
    {
      re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a3 + 64, 2 * *(_DWORD *)(a3 + 92));
      LODWORD(v11) = v9 % *(unsigned int *)(a3 + 88);
      int v15 = *(_DWORD *)(a3 + 96);
    }
    *(_DWORD *)(a3 + 96) = v15 + 1;
    uint64_t v16 = *(void *)(a3 + 80);
    int v17 = *(_DWORD *)(v16 + 24 * v14);
  }
  else
  {
    uint64_t v16 = *(void *)(a3 + 80);
    int v17 = *(_DWORD *)(v16 + 24 * v14);
    *(_DWORD *)(a3 + 100) = v17 & 0x7FFFFFFF;
  }
  uint64_t v18 = 24 * v14;
  *(_DWORD *)(v16 + v18) = v17 | 0x80000000;
  *(_DWORD *)(*(void *)(a3 + 80) + v18) = *(_DWORD *)(*(void *)(a3 + 80) + 24 * v14) & 0x80000000 | *(_DWORD *)(*(void *)(a3 + 72) + 4 * v11);
  *(void *)(*(void *)(a3 + 80) + 24 * v14 + 8) = v9;
  *(void *)(*(void *)(a3 + 80) + 24 * v14 + 16) = v12;
  *(_DWORD *)(*(void *)(a3 + 72) + 4 * v11) = v14;
  ++*(_DWORD *)(a3 + 92);
  ++*(_DWORD *)(a3 + 104);
}

uint64_t std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_0>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::ecs2::SkyboxMeshID &)>::target_type()
{
}

void re::SkyboxMeshIDData::~SkyboxMeshIDData(re::SkyboxMeshIDData *this)
{
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::~__func()
{
}

__n128 std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26E719B78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E719B78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::operator()(uint64_t a1, re::RenderFrame *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*(void *)(a4 + 16))
  {
    uint64_t v5 = a3;
    uint64_t v4 = a1;
    unint64_t v7 = 0x9E3779B97F4A7C17;
    uint64_t v6 = *(void *)(a4 + 32);
    if (atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A930, memory_order_acquire)) {
      goto LABEL_3;
    }
  }
  else
  {
    memset(v16, 0, sizeof(v16));
    a2 = (re::RenderFrame *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (__cxa_guard_acquire(&qword_26AF9A930))
  {
    MurmurHash3_x64_128((uint64_t)"Camera", 6, 0, (unint64_t *)v16);
    qword_26AF9A928 = (*((void *)&v16[0] + 1) + v7 + (*(void *)&v16[0] << 6) + (*(void *)&v16[0] >> 2)) ^ *(void *)&v16[0];
    __cxa_guard_release(&qword_26AF9A930);
  }
LABEL_3:
  if (*(unsigned char *)(v6 + 8)) {
    unint64_t v9 = *(const char **)(v6 + 16);
  }
  else {
    unint64_t v9 = (const char *)(v6 + 9);
  }
  unint64_t v10 = qword_26AF9A928;
  size_t v11 = strlen(v9);
  if (v11)
  {
    MurmurHash3_x64_128((uint64_t)v9, v11, 0, (unint64_t *)v16);
    v7 += (*((void *)&v16[0] + 1) + v7 + (*(void *)&v16[0] << 6) + (*(void *)&v16[0] >> 2)) ^ *(void *)&v16[0];
  }
  uint64_t v12 = ((v10 >> 2) + (v10 << 6) + v7) ^ v10;
  uint64_t v13 = re::RenderGraphDataStore::tryGet<re::CameraData>(v5, v12);
  if (v13)
  {
    if (*(void *)(v13 + 440))
    {
      *(void *)&v16[0] = &unk_26E719BF8;
      *((void *)&v16[0] + 1) = v13;
      re::RenderGraphDataStore::add<re::CurrentSelectionData,re::CurrentSelectionData&>(v5, qword_26AF9A8F8, (uint64_t)v16);
      uint64_t v14 = qword_26AF9A8F8;
      uint64_t v15 = re::RenderGraphDataStore::get<re::MeshLodSelectInputData>(v5, v12);
      re::RenderGraphDataStore::add<re::MeshLodSelectInputData,re::MeshLodSelectInputData&>(v5, v14, v15);
      re::RenderFrame::emitGraph(a2, (const char *)(v4 + 8), (const char *)(v4 + 18));
    }
  }
}

uint64_t std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_1>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraView> &)>::target_type()
{
}

void re::RenderGraphDataStore::add<re::CurrentSelectionData,re::CurrentSelectionData&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)"N2re20CurrentSelectionDataE";
  if (((unint64_t)"N2re20CurrentSelectionDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"N2re20CurrentSelectionDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  unint64_t v9 = (a2 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5;
  unint64_t v10 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 16, 8);
  v10[1] = *(void *)(a3 + 8);
  unint64_t v11 = *(void *)(a1 + 64);
  *unint64_t v10 = &unk_26E719BF8;
  if (v11)
  {
    unint64_t v11 = v9 % *(unsigned int *)(a1 + 88);
    uint64_t v12 = *(unsigned int *)(*(void *)(a1 + 72) + 4 * v11);
    if (v12 != 0x7FFFFFFF)
    {
      uint64_t v18 = *(void *)(a1 + 80);
      if (*(void *)(v18 + 24 * v12 + 8) == v9) {
        return;
      }
      while (1)
      {
        LODWORD(v12) = *(_DWORD *)(v18 + 24 * v12) & 0x7FFFFFFF;
        if (v12 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v18 + 24 * v12 + 8) == v9) {
          return;
        }
      }
    }
  }
  uint64_t v13 = *(unsigned int *)(a1 + 100);
  if (v13 == 0x7FFFFFFF)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 96);
    int v14 = v13;
    if (v13 == *(_DWORD *)(a1 + 88))
    {
      re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a1 + 64, 2 * *(_DWORD *)(a1 + 92));
      LODWORD(v11) = v9 % *(unsigned int *)(a1 + 88);
      int v14 = *(_DWORD *)(a1 + 96);
    }
    *(_DWORD *)(a1 + 96) = v14 + 1;
    uint64_t v15 = *(void *)(a1 + 80);
    int v16 = *(_DWORD *)(v15 + 24 * v13);
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 80);
    int v16 = *(_DWORD *)(v15 + 24 * v13);
    *(_DWORD *)(a1 + 100) = v16 & 0x7FFFFFFF;
  }
  uint64_t v17 = 24 * v13;
  *(_DWORD *)(v15 + v17) = v16 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 80) + v17) = *(_DWORD *)(*(void *)(a1 + 80) + 24 * v13) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 72) + 4 * v11);
  *(void *)(*(void *)(a1 + 80) + 24 * v13 + 8) = v9;
  *(void *)(*(void *)(a1 + 80) + 24 * v13 + 16) = v10;
  *(_DWORD *)(*(void *)(a1 + 72) + 4 * v11) = v13;
  ++*(_DWORD *)(a1 + 92);
  ++*(_DWORD *)(a1 + 104);
}

uint64_t re::RenderGraphDataStore::add<re::MeshLodSelectInputData,re::MeshLodSelectInputData&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)"N2re22MeshLodSelectInputDataE";
  if (((unint64_t)"N2re22MeshLodSelectInputDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"N2re22MeshLodSelectInputDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  uint64_t v20 = (a2 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5;
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 160, 16);
  *(void *)uint64_t v9 = &unk_26E711050;
  *(unsigned char *)(v9 + 16) = *(unsigned char *)(a3 + 16);
  int v10 = *(unsigned __int8 *)(a3 + 17);
  *(unsigned char *)(v9 + 17) = v10;
  if (v10) {
    *(unsigned char *)(v9 + 18) = *(unsigned char *)(a3 + 18);
  }
  int v11 = *(unsigned __int8 *)(a3 + 20);
  *(unsigned char *)(v9 + 20) = v11;
  if (v11) {
    *(_DWORD *)(v9 + 24) = *(_DWORD *)(a3 + 24);
  }
  long long v12 = *(_OWORD *)(a3 + 32);
  long long v13 = *(_OWORD *)(a3 + 48);
  long long v14 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(v9 + 64) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(v9 + 80) = v14;
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v13;
  long long v15 = *(_OWORD *)(a3 + 96);
  long long v16 = *(_OWORD *)(a3 + 112);
  long long v17 = *(_OWORD *)(a3 + 144);
  *(_OWORD *)(v9 + 128) = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(v9 + 144) = v17;
  *(_OWORD *)(v9 + 96) = v15;
  *(_OWORD *)(v9 + 112) = v16;
  uint64_t v19 = v9;
  return *(void *)re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addNew<re::CameraData *>(a1 + 64, (unint64_t *)&v20, &v19);
}

void re::CurrentSelectionData::~CurrentSelectionData(re::CurrentSelectionData *this)
{
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::~__func()
{
}

__n128 std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26E719C48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E719C48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::operator()(uint64_t a1, re::RenderFrame *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*(void *)(a4 + 16))
  {
    uint64_t v5 = a3;
    uint64_t v4 = a1;
    unint64_t v7 = 0x9E3779B97F4A7C17;
    uint64_t v6 = *(void *)(a4 + 32);
    if (atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9A940, memory_order_acquire)) {
      goto LABEL_3;
    }
  }
  else
  {
    memset(v16, 0, sizeof(v16));
    a2 = (re::RenderFrame *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (__cxa_guard_acquire(&qword_26AF9A940))
  {
    MurmurHash3_x64_128((uint64_t)"Camera", 6, 0, (unint64_t *)v16);
    qword_26AF9A938 = (*((void *)&v16[0] + 1) + v7 + (*(void *)&v16[0] << 6) + (*(void *)&v16[0] >> 2)) ^ *(void *)&v16[0];
    __cxa_guard_release(&qword_26AF9A940);
  }
LABEL_3:
  if (*(unsigned char *)(v6 + 8)) {
    uint64_t v9 = *(const char **)(v6 + 16);
  }
  else {
    uint64_t v9 = (const char *)(v6 + 9);
  }
  unint64_t v10 = qword_26AF9A938;
  size_t v11 = strlen(v9);
  if (v11)
  {
    MurmurHash3_x64_128((uint64_t)v9, v11, 0, (unint64_t *)v16);
    v7 += (*((void *)&v16[0] + 1) + v7 + (*(void *)&v16[0] << 6) + (*(void *)&v16[0] >> 2)) ^ *(void *)&v16[0];
  }
  uint64_t v12 = ((v10 >> 2) + (v10 << 6) + v7) ^ v10;
  uint64_t v13 = re::RenderGraphDataStore::tryGet<re::CameraData>(v5, v12);
  if (v13)
  {
    if (*(void *)(v13 + 440))
    {
      *(void *)&v16[0] = &unk_26E719BF8;
      *((void *)&v16[0] + 1) = v13;
      re::RenderGraphDataStore::add<re::CurrentSelectionData,re::CurrentSelectionData&>(v5, qword_26AF9A8F8, (uint64_t)v16);
      uint64_t v14 = qword_26AF9A8F8;
      uint64_t v15 = re::RenderGraphDataStore::get<re::MeshLodSelectInputData>(v5, v12);
      re::RenderGraphDataStore::add<re::MeshLodSelectInputData,re::MeshLodSelectInputData&>(v5, v14, v15);
      re::RenderFrame::emitGraph(a2, (const char *)(v4 + 8), (const char *)(v4 + 18));
    }
  }
}

uint64_t std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2,std::allocator<re::RenderGraphSelectionEmitter::handleRenderFrameDataStream(re::RenderFrame &,re::WeakStringID const&)::$_2>,void ()(re::RenderFrame &,re::RenderGraphDataStore &,re::DynamicArray<re::CameraMultiView> &)>::target_type()
{
}

uint64_t re::BucketArray<re::SceneName,4ul>::operator[](uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 40))
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1018, 0, 0);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (!*(void *)(a1 + 8)) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v2 = a1 + 24;
  }
  else {
    uint64_t v2 = *(void *)(a1 + 32);
  }
  return *(void *)v2;
}

uint64_t re::RenderGraphDataStore::get<re::CurrentSelectionData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re20CurrentSelectionDataE";
  if (((unint64_t)"N2re20CurrentSelectionDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re20CurrentSelectionDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

void re::SelectionDrawCallBufferData::~SelectionDrawCallBufferData(re::SelectionDrawCallBufferData *this)
{
}

void re::DrawCallIdentifierData::~DrawCallIdentifierData(re::DrawCallIdentifierData *this)
{
}

void *re::DynamicArray<re::SelectionCompleteHandler>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SelectionCompleteHandler>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SelectionCompleteHandler>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SelectionConcludeHandler>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SelectionConcludeHandler>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SelectionConcludeHandler>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *std::__function::__value_func<void ()(re::Slice<unsigned long long> const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    unint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(re::Slice<re::RenderGraphSelectionConcludeResult> const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    unint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t re::isBoundingBoxInsideVCAPlanes(uint64_t a1, float32x4_t *a2, uint64_t a3, int a4, unsigned char *a5, float32x4_t *a6, float32x4_t *a7, uint64_t a8, float32x4_t *a9, uint64_t a10, uint64_t a11, int a12)
{
  uint64_t v17 = (re *)re::transformedAABBVertices(a1, a2, v37);
  if (a3 != a11 || a3 == 0 || a11 == 0)
  {
    switch(*a5)
    {
      case 0:
        goto LABEL_24;
      case 1:
      case 3:
        uint64_t v20 = 0;
        while (1)
        {
          int8x16_t v21 = (int8x16_t)vmulq_f32(*a7, (float32x4_t)v37[v20]);
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL))) <= 0.0) {
            break;
          }
          if (++v20 == 8) {
            return 0;
          }
        }
        goto LABEL_30;
      case 2:
      case 4:
        uint64_t v22 = 0;
        break;
      case 5:
        float32x4_t v24 = *a6;
        v24.i32[3] = 1.0;
        int8x16_t v25 = (int8x16_t)vmulq_f32(*a7, v24);
        float v26 = vaddv_f32(vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)));
        goto LABEL_29;
      default:
        if ((atomic_exchange(re::isBoundingBoxInsideVCAPlanes(re::AABB const&,re::Matrix4x4<float> const&,unsigned long long,int,re::MeshSortingConfiguration const&,re::Vector3<float> const&,re::PlaneF const&,re::Slice<re::PlaneF>,unsigned long long,int)::__FILE____LINE___logged, 1u) & 1) == 0)
        {
          id v27 = *re::graphicsLogObjects(v17);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)id v36 = 0;
            _os_log_impl(&dword_233120000, v27, OS_LOG_TYPE_DEFAULT, "An unknown mesh sort point heuristic has been encountered. All unknown heuristics will default to kCentroid.", v36, 2u);
          }
        }
LABEL_24:
        uint64_t v28 = 0;
        float v26 = 0.0;
        do
        {
          int8x16_t v29 = (int8x16_t)vmulq_f32(*a7, (float32x4_t)v37[v28]);
          float v30 = vaddv_f32(vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL)));
          if (v30 >= 0.0) {
            float v31 = 1.0;
          }
          else {
            float v31 = 2.0;
          }
          float v26 = v26 + (float)(v30 * v31);
          ++v28;
        }
        while (v28 != 8);
LABEL_29:
        if (v26 <= 0.0) {
          goto LABEL_30;
        }
        return 0;
    }
    while (1)
    {
      int8x16_t v23 = (int8x16_t)vmulq_f32(*a7, (float32x4_t)v37[v22]);
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL))) > 0.0) {
        return 0;
      }
      if (++v22 == 8) {
        goto LABEL_30;
      }
    }
  }
  if (a12 <= a4) {
    return 0;
  }
LABEL_30:
  if (!a10) {
    return 1;
  }
  uint64_t v32 = a9;
  uint64_t result = 1;
  do
  {
    uint64_t v34 = 0;
    while (1)
    {
      int8x16_t v35 = (int8x16_t)vmulq_f32(*v32, (float32x4_t)v37[v34]);
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL))) <= 0.0) {
        break;
      }
      if (++v34 == 8) {
        return 0;
      }
    }
    ++v32;
  }
  while (v32 != &a9[a10]);
  return result;
}

void re::SFBSystemShellStencilBlurMeshNode::execute(const char **this, re::RenderGraphContext *a2)
{
  uint64_t v4 = (uint64_t)a2;
  uint64_t v360 = *MEMORY[0x263EF8340];
  uint64_t v6 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  {
    *(unsigned char *)(v4 + 1120) = 1;
    unint64_t v7 = v321;
    *(unsigned char *)(v4 + 1512) = 5;
    *(void *)&v313.var0 = 0x2476C06B76;
    v313.var1 = "VCABlur";
    unsigned int v8 = (re::StringID *)&v314;
    *(void *)&v314.var0 = 5231452;
    v314.var1 = "True";
    *(void *)&v311.var0 = 0x4CB6D3AA6EABE92CLL;
    v311.var1 = "Transparent_BackCompat";
    uint64_t v9 = (re::StringID *)&v312;
    *(void *)&v312.var0 = 5231452;
    v312.var1 = "True";
    re::StringID::StringID((re::StringID *)v321, &v313);
    re::StringID::StringID((re::StringID *)&v321[1], &v314);
    re::StringID::StringID((re::StringID *)&v322, &v311);
    re::StringID::StringID((re::StringID *)&v323, &v312);
    *(void *)&long long v10 = 0;
    *((void *)&v10 + 1) = "";
    v310[3] = v10;
    v310[2] = v10;
    v310[1] = v10;
    v310[0] = v10;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigDataTypeClass::RigDataTypeAttribute *,re::RigDataTypeClass::RigDataTypeAttribute *,re::RigDataTypeClass::RigDataTypeAttribute *>((uint64_t)&v343, (uint64_t *)v321, (uint64_t *)&v324, (unint64_t *)v310);
    uint64_t v11 = 64;
    do
    {
      re::StringID::destroyString((re::StringID *)((char *)&v319[2] + v11));
      re::StringID::destroyString((re::StringID *)((char *)v319 + v11));
      v11 -= 32;
    }
    while (v11);
    uint64_t v12 = (float32x4_t *)0x9E3779B97F4A7C17;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AA58, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9AA58))
    {
      MurmurHash3_x64_128((uint64_t)"PlattersOnly", 12, 0, (unint64_t *)v321);
      qword_26AF9AA50 = (v321[0].i64[1]
                       - 0x61C8864680B583E9
                       + (v321[0].i64[0] << 6)
                       + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0];
      __cxa_guard_release(&qword_26AF9AA58);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AA68, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9AA68))
    {
      MurmurHash3_x64_128((uint64_t)"PlatterContentsOnly", 19, 0, (unint64_t *)v321);
      qword_26AF9AA60 = (v321[0].i64[1]
                       - 0x61C8864680B583E9
                       + (v321[0].i64[0] << 6)
                       + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0];
      __cxa_guard_release(&qword_26AF9AA68);
    }
    uint64_t v13 = *(void *)(v4 + 1168);
    unint64_t v14 = (unint64_t)"N2re13VCARenderDataE";
    if (((unint64_t)"N2re13VCARenderDataE" & 0x8000000000000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)((unint64_t)"N2re13VCARenderDataE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    v321[0].i64[0] = (*(void *)(*(void *)(v4 + 40) + 48) - 0x61C8864680B583E9 + (v14 << 6) + (v14 >> 2)) ^ v14;
    uint64_t v18 = (float32x4_t **)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v13 + 64, (uint64_t *)v321);
    if (!v18 || (uint64_t v233 = *v18) == 0)
    {
      uint64_t v30 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v4 + 8) + 104));
      re::RenderGraphContext::acquireManagedRenderEncoder(v321, v4, v30, 0);
      re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)v321);
LABEL_17:
      uint64_t v31 = 8;
      do
      {
        re::StringID::destroyString((re::StringID *)((char *)&v309 + v31 * 8));
        re::StringID::destroyString((re::StringID *)&v308[v31]);
        v31 -= 4;
      }
      while (v31 * 8);
      re::StringID::destroyString(v9);
      re::StringID::destroyString((re::StringID *)&v311);
      re::StringID::destroyString(v8);
      re::StringID::destroyString((re::StringID *)&v313);
      *(unsigned char *)(v4 + 1120) = 0;
      *(unsigned char *)(v4 + 1512) = 0;
      return;
    }
    uint64_t v19 = re::RenderGraphDataStore::get<re::CameraData>(*(void *)(v4 + 1168), *(void *)(*(void *)(v4 + 40) + 48));
    if (*(void *)(v19 + 48))
    {
      unint64_t v2 = (float32x2_t *)v19;
      uint64_t v236 = v19 + 64;
      re::RenderCamera::computeLocalTransform((re::RenderCamera *)(v19 + 64), (uint64_t)v321);
      int32x4_t v21 = (int32x4_t)vmulq_f32(v322, v322);
      v21.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v21, 2), vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1))).u32[0];
      float32x2_t v22 = vrsqrte_f32((float32x2_t)v21.u32[0]);
      float32x2_t v23 = vmul_f32(v22, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v22, v22)));
      float32x4_t v309 = vnegq_f32(vmulq_n_f32(v322, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v23, v23))).f32[0]));
      float32x2_t v24 = v2[8];
      v308[1] = v2[9];
      v308[0] = v24;
      uint64_t v25 = *(void *)(*(void *)v4 + 24);
      unint64_t v306 = &unk_26E71A588;
      uint64_t v307 = 0;
      uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 48, 8);
      *(_OWORD *)uint64_t v26 = 0u;
      *(_OWORD *)(v26 + 16) = 0u;
      *(_DWORD *)(v26 + 32) = 0;
      uint64_t v3 = 0x7FFFFFFFLL;
      *(void *)(v26 + 36) = 0x7FFFFFFFLL;
      int v230 = (re::Allocator *)v25;
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init(v26, v25, 3);
      uint64_t v307 = v26;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AA78, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9AA78))
      {
        MurmurHash3_x64_128((uint64_t)"RenderGraphGlobals", 18, 0, (unint64_t *)v321);
        unint64_t v191 = (v321[0].i64[1] - 0x61C8864680B583E9 + (v321[0].i64[0] << 6) + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0];
        MurmurHash3_x64_128((uint64_t)"RenderFrame", 11, 0, (unint64_t *)v321);
        qword_26AF9AA70 = ((v191 << 6)
                         - 0x61C8864680B583E9
                         + (v191 >> 2)
                         + ((v321[0].i64[1]
                           - 0x61C8864680B583E9
                           + (v321[0].i64[0] << 6)
                           + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0])) ^ v191;
        __cxa_guard_release(&qword_26AF9AA78);
      }
      char v234 = (re::SFBSystemShellStencilBlurMeshNode *)re::RenderGraphDataStore::get<re::RendererGlobals>(*(void *)(v4 + 1168), qword_26AF9AA70);
      v225.i64[1] = re::RenderGraphDataStore::get<re::SceneScope>(*(void *)(v4 + 1168), *(void *)(*(void *)(v4 + 40) + 48));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AA88, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF9AA88))
      {
        MurmurHash3_x64_128((uint64_t)"DynamicFunctionConstants", 24, 0, (unint64_t *)v321);
        qword_26AF9AA80 = (v321[0].i64[1]
                         - 0x61C8864680B583E9
                         + (v321[0].i64[0] << 6)
                         + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0];
        __cxa_guard_release(&qword_26AF9AA88);
      }
      unint64_t v27 = qword_26AF9AA80;
      size_t v28 = strlen(this[4]);
      if (v28)
      {
        MurmurHash3_x64_128((uint64_t)this[4], v28, 0, (unint64_t *)v321);
        unint64_t v29 = ((v321[0].i64[1] - 0x61C8864680B583E9 + (v321[0].i64[0] << 6) + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0])
            - 0x61C8864680B583E9;
      }
      else
      {
        unint64_t v29 = 0x9E3779B97F4A7C17;
      }
      uint64_t v32 = re::RenderGraphDataStore::tryGet<re::DynamicFunctionConstantsData>(*(void *)(v4 + 1168), ((v27 >> 2) + (v27 << 6) + v29) ^ v27);
      if (v32) {
        uint64_t v11 = v32 + 8;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v33 = re::RenderGraphDataStore::get<re::MeshLodSelectInputData>(*(void *)(v4 + 1168), *(void *)(*(void *)(v4 + 40) + 48));
      unint64_t v292 = &unk_26E711050;
      char v293 = *(unsigned char *)(v33 + 16);
      if (*(unsigned char *)(v33 + 17)) {
        char v295 = *(unsigned char *)(v33 + 18);
      }
      uint64_t v219 = &v314;
      uint64_t v220 = this;
      int v218 = &v312;
      uint64_t v221 = v4;
      char v296 = *(unsigned char *)(v33 + 20);
      long long v34 = *(_OWORD *)(v33 + 64);
      long long v36 = *(_OWORD *)(v33 + 32);
      long long v35 = *(_OWORD *)(v33 + 48);
      long long v301 = *(_OWORD *)(v33 + 80);
      long long v300 = v34;
      long long v298 = v36;
      long long v299 = v35;
      long long v37 = *(_OWORD *)(v33 + 128);
      long long v39 = *(_OWORD *)(v33 + 96);
      long long v38 = *(_OWORD *)(v33 + 112);
      long long v305 = *(_OWORD *)(v33 + 144);
      long long v304 = v37;
      long long v302 = v39;
      long long v303 = v38;
      if (!v296) {
        char v296 = 1;
      }
      uint64_t v4 = 2139095040;
      int v297 = 2139095040;
      re::CameraMatrices::CameraMatrices((re::CameraMatrices *)v352, v230, v2[61].u8[2]);
      if (!v2[61].i8[2])
      {
LABEL_34:
        v287[0] = v221;
        v287[1] = v2;
        v287[2] = v352;
        v287[3] = v225.i64[1];
        v287[4] = v234;
        v287[5] = &v306;
        v287[6] = &v292;
        v287[7] = 0;
        __int16 v288 = 1;
        char v289 = 1;
        char v290 = 0;
        uint64_t v291 = v11;
        re::RenderGraphCameraSetupNode::setupDrawCallsForCamera((uint64_t)v287, v41, v42, v43, v44, v45);
        *(void *)&long long v49 = 0x7F0000007FLL;
        *((void *)&v49 + 1) = 0x7F0000007FLL;
        *(int32x4_t *)(v221 + 64) = vdupq_n_s32(0x7F800000u);
        *(_OWORD *)(v221 + 80) = v49;
        v321[0].i64[0] = qword_26AF9AA50;
        char v234 = (re::SFBSystemShellStencilBlurMeshNode *)re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v307, (uint64_t *)v321);
        v321[0].i64[0] = qword_26AF9AA60;
        v225.i64[1] = re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v307, (uint64_t *)v321);
        unint64_t v284 = 0;
        int v285 = 0;
        re::rendergraph_helper::getOcclusionMeshPasses((uint64_t)v321);
        re::rendergraph_helper::populateMeshPassArray<1ul,re::FixedInlineArray<re::rendergraph_helper::RenderPass,1ul>>((uint64_t)&v306, (uint64_t *)&v284, (uint64_t)v321);
        unint64_t v281 = 0;
        int v282 = 0;
        re::rendergraph_helper::getOpaqueMeshPasses((uint64_t)v321);
        re::rendergraph_helper::populateMeshPassArray<1ul,re::FixedInlineArray<re::rendergraph_helper::RenderPass,1ul>>((uint64_t)&v306, (uint64_t *)&v281, (uint64_t)v321);
        uint64_t v278 = 0;
        int v279 = 0;
        re::rendergraph_helper::getTransparentMeshPasses(v321);
        for (unint64_t i = 0; i != 168; i += 24)
        {
          __int8 v51 = v321[1].i8[i];
          __int8 v52 = v321[1].i8[i + 1];
          __int8 v53 = v321[1].i8[i + 2];
          int v54 = *(__int32 *)((char *)&v321[1].i32[i / 4] + 3);
          __int8 v55 = v321[1].i8[i + 7];
          uint64_t v343 = (float32x4_t *)v321[0].i64[i / 8 + 1];
          long long v56 = (float32x4_t *)re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v307, (uint64_t *)&v343);
          if (v56)
          {
            uint64_t v343 = v56;
            LOBYTE(v344) = 1;
            *(_DWORD *)((char *)&v344 + 1) = v54;
            BYTE5(v344) = v51;
            BYTE6(v344) = v52;
            HIBYTE(v344) = v53;
            LOBYTE(v345) = v55;
            re::DynamicInlineArray<re::FilteredMeshPass,10ul>::add((uint64_t)&v278, (uint64_t)&v343);
          }
        }
        uint64_t v11 = v278;
        if (v225.i64[1])
        {
          v321[0].i64[0] = v225.i64[1];
          v321[0].i8[8] = 1;
          *(uint64_t *)((char *)&v321[0].i64[1] + 1) = 0xFF0003030303;
          re::DynamicInlineArray<re::FilteredMeshPass,10ul>::add((uint64_t)&v278, (uint64_t)v321);
        }
        unint64_t v275 = 0;
        int v276 = 0;
        uint64_t v4 = v221;
        RenderGraphDataPipe = (const char **)re::RenderGraphDataStore::tryGet<re::SceneScope>(*(void *)(v221 + 1168), *(void *)(*(void *)(v221 + 40) + 48));
        uint64_t v9 = (re::StringID *)&v312;
        unsigned int v8 = (re::StringID *)&v314;
        if (RenderGraphDataPipe)
        {
          RenderGraphDataPipe = (const char **)re::RenderGraphContext::tryGetRenderGraphDataPipe((re::RenderGraphContext *)v221, RenderGraphDataPipe[1]);
          unint64_t v7 = (float32x4_t *)v230;
          uint64_t v12 = v233;
          if (RenderGraphDataPipe)
          {
            RenderGraphDataPipe = (const char **)(*((uint64_t (**)(const char **))*RenderGraphDataPipe + 105))(RenderGraphDataPipe);
            uint64_t v222 = (uint64_t)RenderGraphDataPipe;
          }
          else
          {
            uint64_t v222 = 0;
          }
        }
        else
        {
          uint64_t v222 = 0;
          unint64_t v7 = (float32x4_t *)v230;
          uint64_t v12 = v233;
        }
        this = (const char **)v234;
        if (!*(unsigned char *)(v221 + 1332))
        {
          uint64_t v59 = 0;
          if (!v234)
          {
LABEL_53:
            if (!*(void *)(v222 + 40))
            {
LABEL_211:
              BOOL v76 = 0;
              uint64_t v77 = 0;
              goto LABEL_212;
            }
            HIDWORD(v212) = v11;
            unint64_t v61 = v275;
LABEL_55:
            uint64_t v62 = v277;
            uint64_t v347 = re::globalAllocators((re *)RenderGraphDataPipe)[2];
            uint64_t v343 = (float32x4_t *)&unk_26E71A2F0;
            uint64_t v344 = &v12->i64[1];
            uint64_t v348 = (void **)&v343;
            v321[0].i64[0] = 0;
            v321[0].i64[1] = (uint64_t)&v313;
            v321[1] = (float32x4_t)1uLL;
            v322.i64[0] = 0;
            *((void *)&v324 + 1) = v347;
            *(void *)&long long v325 = 0;
            re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::operator=<32ul>((uint64_t)&v322.i64[1], (uint64_t)&v343);
            WORD4(v325) = 1;
            BYTE12(v325) = 0;
            *(void *)&v273[0] = v277;
            *((void *)&v273[0] + 1) = v61;
            re::RenderGraphMeshNodeBase::depthSort((re *)2, v273, v4, (uint64_t)&v240, v59, (uint64_t)v321, v7, v63, v64, v65, v66, v67, v68, v69, v70, v71, v192, (int)v194, SHIDWORD(v194),
              (uint64_t)v196,
              v198,
              v200,
              v202,
              v204,
              v205,
              (uint64_t)v206,
              v207,
              v209,
              v210,
              v212,
              v213,
              v215,
              v216,
              *((float *)&v216 + 1),
              *(float *)&v217,
              HIDWORD(v217),
              *(float *)&v218,
              SHIDWORD(v218),
              (__int16)v219,
              SBYTE2(v219),
              SBYTE3(v219),
              SBYTE4(v219),
              SBYTE5(v219),
              SBYTE6(v219),
              SHIBYTE(v219),
              (char)v220,
              SBYTE1(v220),
              SBYTE2(v220),
              SBYTE3(v220),
              SBYTE4(v220),
              v221,
              SBYTE4(v221),
              BYTE5(v221),
              SBYTE6(v221),
              SHIBYTE(v221),
              v222,
              SHIDWORD(v222),
              v223,
              v225,
              (uint64_t)v230,
              v233,
              *(float *)&v234,
              v236);
            uint64_t v215 = (long long *)v240.i64[0];
            int v72 = (void *)v241;
            float32x4_t v240 = 0uLL;
            unint64_t v241 = 0;
            uint64_t v217 = v243;
            uint64_t v243 = 0;
            LODWORD(v242) = v242 + 1;
            re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v322.i64[1]);
            re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v343);
            if (v72)
            {
              uint64_t v274 = 0;
              memset(v273, 0, sizeof(v273));
              re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs((re::RenderGraphContext *)v4, (uint64_t *)v273);
              uint64_t v343 = v7;
              LODWORD(v344) = 0;
              uint64_t v345 = 0;
              int v346 = 0;
              int v350 = 0;
              memset(v349, 0, sizeof(v349));
              uint64_t v206 = (uint64_t *)v349;
              uint64_t v351 = 0x7FFFFFFFLL;
              uint64_t v73 = (*(uint64_t (**)(float32x4_t *, uint64_t, uint64_t))(v7->i64[0] + 32))(v7, 328, 8);
              int v74 = re::DrawTable::DrawTable((re::DrawTable *)v73, (re::Allocator *)v7, ((unint64_t)v72 + 127) >> 7);
              LODWORD(v337) = 0;
              float v338 = v74;
              unint64_t v339 = (void **)v12;
              double v340 = (void **)&v343;
              double v75 = (void (***)(void))((char *)v74 + 280);
              if (!*(unsigned char *)(v73 + 320)) {
                (**v75)(v75);
              }
              size_t v78 = (StringID *)&v337;
              *(void *)(v73 + 280) = &unk_26E71A418;
              *(void *)(v73 + 288) = &v337;
              *(unsigned char *)(v73 + 320) = 0;
              v318.i64[0] = (uint64_t)v277;
              v318.i64[1] = v275;
              DrawCallsFromMeshParts = (re *)re::RenderGraphMeshNodeBase::makeDrawCallsFromMeshParts((uint64_t *)&v318, v217, (unint64_t)v72, (float32x4_t *)v4, v73, v356, (uint64_t)v352, 0, v59);
              if (!*(void *)(v73 + 40)) {
                goto LABEL_63;
              }
              re::DrawTableSlice::DrawTableSlice(v321, v73);
              uint64_t v80 = 0;
              v240.i64[0] = (uint64_t)"StencilBlurSetStencil";
              v240.i64[1] = (uint64_t)v321;
              unint64_t v241 = v354;
              uint64_t v242 = v358;
              uint64_t v243 = 0;
              char v244 = v359;
              __int16 v245 = 2;
              __int16 v246 = 256;
              long long v247 = __const__ZN2re20FeatureStencilStates18getStencilBlurInfoENS0_16StencilBlurUsageE_kWriteStInfo;
              char v248 = 0;
              long long v249 = 0u;
              long long v250 = 0u;
              char v251 = 0;
              if (*(unsigned char *)(v4 + 1332)) {
                goto LABEL_227;
              }
              while (1)
              {
                uint64_t v252 = v80;
                char v253 = 0;
                DrawCallsFromMeshParts = (re *)re::RenderGraphContext::encodeDrawCalls(v4, v273, &v240);
LABEL_63:
                uint64_t v341 = re::globalAllocators(DrawCallsFromMeshParts)[2];
                uint64_t v337 = &unk_26E71A358;
                float v338 = v12;
                unint64_t v339 = (void **)&v343;
                uint64_t v342 = v78;
                v226.i64[1] = (uint64_t)v62;
                if (*(unsigned char *)(v4 + 1332))
                {
LABEL_224:
                  uint64_t v82 = (re::DrawCallRecorderGroup *)re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "Occlusion");
                  if (*(unsigned char *)(v4 + 1332))
                  {
                    int v81 = (re::DrawCallRecorderGroup *)re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "Opaque");
                    uint64_t v235 = *(unsigned char *)(v221 + 1332)
                         ? re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "Transparent"): 0;
                  }
                  else
                  {
                    uint64_t v235 = 0;
                    int v81 = 0;
                  }
                }
                else
                {
                  uint64_t v235 = 0;
                  int v81 = 0;
                  uint64_t v82 = 0;
                }
                unint64_t v83 = v284;
                memset(v321, 0, 24);
                size_t v78 = &v313;
                v321[1].i64[1] = (uint64_t)&v313;
                uint64_t v4 = 1;
                v322.i64[0] = 1;
                *((void *)&v324 + 1) = v341;
                *(void *)&long long v325 = 0;
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::operator=<32ul>((uint64_t)&v322.i64[1], (uint64_t)&v337);
                WORD4(v325) = 0;
                BYTE12(v325) = 0;
                v240.i64[0] = (uint64_t)v286;
                v240.i64[1] = v83;
                *((void *)&v224 + 1) = v286;
                uint64_t v84 = v231;
                uint64_t v12 = (float32x4_t *)v221;
                re::RenderGraphMeshNodeBase::techniqueSort(&v240, v221, (uint64_t)v270, v82, v231);
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v322.i64[1]);
                uint64_t v62 = v283;
                unint64_t v85 = v281;
                memset(v321, 0, 24);
                v321[1].i64[1] = (uint64_t)&v313;
                v322.i64[0] = 1;
                *((void *)&v324 + 1) = v341;
                *(void *)&long long v325 = 0;
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::operator=<32ul>((uint64_t)&v322.i64[1], (uint64_t)&v337);
                WORD4(v325) = 0;
                BYTE12(v325) = 0;
                v240.i64[0] = (uint64_t)v283;
                v240.i64[1] = v85;
                v226.i64[0] = (uint64_t)v283;
                re::RenderGraphMeshNodeBase::techniqueSort(&v240, v221, (uint64_t)v267, v81, v231);
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v322.i64[1]);
                unint64_t v86 = v278;
                memset(v321, 0, 24);
                v321[1].i64[1] = (uint64_t)v310;
                v322.i64[0] = 2;
                *((void *)&v324 + 1) = v341;
                *(void *)&long long v325 = 0;
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::operator=<32ul>((uint64_t)&v322.i64[1], (uint64_t)&v337);
                WORD4(v325) = 768;
                BYTE12(v325) = 0;
                v240.i64[0] = (uint64_t)v280;
                v240.i64[1] = v86;
                re::RenderGraphMeshNodeBase::depthSort((re *)2, &v240, v221, (uint64_t)v264, v235, (uint64_t)v321, v231, v87, v88, v89, v90, v91, v92, v93, v94, v95, (uint64_t)v193, (int)v195, SHIDWORD(v195),
                  (uint64_t)v197,
                  v199,
                  v201,
                  v203,
                  v204,
                  (uint64_t)v280,
                  (uint64_t)v206,
                  v208,
                  v209,
                  v211,
                  v212,
                  (int)v214,
                  v215,
                  v216,
                  *((float *)&v216 + 1),
                  *(float *)&v217,
                  HIDWORD(v217),
                  *(float *)&v218,
                  SHIDWORD(v218),
                  (__int16)v219,
                  SBYTE2(v219),
                  SBYTE3(v219),
                  SBYTE4(v219),
                  SBYTE5(v219),
                  SBYTE6(v219),
                  SHIBYTE(v219),
                  (char)v220,
                  SBYTE1(v220),
                  SBYTE2(v220),
                  SBYTE3(v220),
                  SBYTE4(v220),
                  v221,
                  SBYTE4(v221),
                  BYTE5(v221),
                  SBYTE6(v221),
                  SHIBYTE(v221),
                  v222,
                  SHIDWORD(v222),
                  v224,
                  v226,
                  (uint64_t)v231,
                  v233,
                  *(float *)&v235,
                  (uint64_t)v237);
                re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v322.i64[1]);
                if (v275 > *(unsigned __int8 *)(v217 + 12 * ((void)v72 - 1) + 4)) {
                  break;
                }
                uint64_t v201 = *(unsigned __int8 *)(v217 + 12 * ((void)v72 - 1) + 4);
                uint64_t v203 = v275;
                long long v197 = "operator[]";
                uint64_t v199 = 381;
                uint64_t v193 = "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu";
                char v195 = "index < m_size";
                re::internal::assertLog((re::internal *)6, v96);
                _os_crash();
                __break(1u);
LABEL_227:
                uint64_t v80 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "StencilBlurSetStencil");
              }
              uint64_t v216 = *(void *)re::BucketArray<re::MeshPartDrawContext,128ul>::operator[](*(void *)(v228 + 24 * *(unsigned __int8 *)(v217 + 12 * ((void)v72 - 1) + 4)), *(unsigned int *)(v217 + 12 * ((void)v72 - 1)));
              char v234 = *(re::SFBSystemShellStencilBlurMeshNode **)(v12->i64[1] + 32);
              unint64_t v263 = 0;
              unint64_t v260 = 0;
              unint64_t v261 = 0;
              int v262 = 0;
              uint64_t v259 = v84;
              re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v259, 0);
              ++v262;
              __int16 v258 = 0;
              re::buildCullingFrustum((uint64_t)v237, &v2[18], v2[61].u8[2], &v258, (uint64_t)v321, v97, v98);
              v240.i64[0] = 0;
              v240.i32[2] = 0;
              re::DynamicInlineArray<re::DynamicInlineArray<re::PlaneF,6ul>,2ul>::copy(&v240, (uint64_t *)v321);
              if (v222)
              {
                uint64_t v238 = *(void *)(v222 + 40);
                if (v238)
                {
                  for (unint64_t j = 0; j != v238; ++j)
                  {
                    uint64_t v100 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v222, j);
                    uint64_t v101 = *(void *)(v100 + 16);
                    if (v101)
                    {
                      uint64_t v102 = *(float32x4_t **)(v100 + 32);
                      uint64_t v103 = &v102[46 * v101];
                      do
                      {
                        if (v102[42].i8[0])
                        {
                          re::computeMeshSceneBoundingBox(v102 + 2, (uint64_t)v234, &v318);
                          if (re::isBoundingBoxInsidePlanesArray((uint64_t)&v318, &v240, v102 + 5))
                          {
                            uint64_t v105 = v233[1].i64[1];
                            if (v105)
                            {
                              int v106 = (float32x4_t *)v233[2].i64[1];
                              uint64_t v107 = 112 * v105;
                              int v108 = v106 + 6;
                              uint64_t v109 = v106 + 2;
                              while (!re::isBoundingBoxInsideVCAPlanes((uint64_t)&v318, v102 + 5, 0, 0, &v102[23].i8[8], v102 + 24, v108, v104, v109, 4, v108[-6].i64[1], v108[-5].i32[0]))
                              {
                                v108 += 7;
                                v109 += 7;
                                v107 -= 112;
                                if (!v107) {
                                  goto LABEL_84;
                                }
                              }
                              LOBYTE(v315[0]) = 0;
                              re::RenderGraphMeshNodeBase::computeSortDistance((uint64_t)&v318, v102 + 5, &v102[23].i8[8], (__n128 *)&v102[24], v308, &v309, 0, (uint64_t)v315, v110, v111, v112, v113);
                              int v116 = v115;
                              unint64_t v117 = v261 + 1;
                              if (v261 >= v260 && v260 < v117)
                              {
                                if (v259)
                                {
                                  unint64_t v121 = 8;
                                  if (v260) {
                                    unint64_t v121 = 2 * v260;
                                  }
                                  if (v121 <= v117) {
                                    unint64_t v122 = v261 + 1;
                                  }
                                  else {
                                    unint64_t v122 = v121;
                                  }
                                  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v259, v122);
                                }
                                else
                                {
                                  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v259, v117);
                                  ++v262;
                                }
                              }
                              unint64_t v119 = v261;
                              uint64_t v120 = v263 + 16 * v261;
                              *(_DWORD *)uint64_t v120 = v116;
                              *(void *)(v120 + 8) = v102;
                              unint64_t v261 = v119 + 1;
                              ++v262;
                            }
                          }
                        }
LABEL_84:
                        v102 += 46;
                      }
                      while (v102 != v103);
                    }
                  }
                }
              }
              unint64_t v123 = 126 - 2 * __clz(v261);
              if (v261) {
                uint64_t v124 = v123;
              }
              else {
                uint64_t v124 = 0;
              }
              std::__introsort<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *,false>(v263, (float *)(v263 + 16 * v261), v124, 1);
              if (v240.i64[0])
              {
                char v125 = &v241;
                char v126 = &v241 + 14 * v240.i64[0];
                do
                {
                  *char v125 = 0;
                  ++*((_DWORD *)v125 + 2);
                  v125 += 14;
                }
                while (v125 != v126);
              }
              if (v335)
              {
                __int16 v127 = v336;
                uint64_t v128 = &v336[9 * v335];
                do
                {
                  *(void *)__int16 v127 = 0;
                  ++*((_DWORD *)v127 + 2);
                  v127 += 9;
                }
                while (v127 != v128);
              }
              if (v321[0].i64[0])
              {
                int v129 = &v321[1];
                char v130 = &v321[7 * v321[0].i64[0] + 1];
                do
                {
                  v129->i64[0] = 0;
                  ++v129->i32[2];
                  v129 += 7;
                }
                while (v129 != v130);
              }
              unint64_t v131 = v265;
              if (v265 <= v271) {
                unint64_t v131 = v271;
              }
              if (v268 <= v131) {
                unint64_t v132 = v131;
              }
              else {
                unint64_t v132 = v268;
              }
              uint64_t v133 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v231 + 32))(v231, 328, 8);
              uint64_t v134 = re::DrawTable::DrawTable((re::DrawTable *)v133, (re::Allocator *)v231, (v132 + 127) >> 7);
              v318.i64[0] = (uint64_t)&unk_26E71A480;
              v318.i64[1] = (uint64_t)v233;
              v319[0] = v134;
              v319[1] = &v343;
              char v320 = 0;
              if (v271)
              {
                re::DrawTable::clearAll((re::DrawTable *)v133);
                re::InlineFunction<40ul,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator=((unsigned char *)(v133 + 280), &v318);
                uint64_t v135 = *(unsigned char *)(v221 + 1332)
                     ? re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v221 + 1336), v220[2], "Occlusion"): 0;
                v321[0].i64[0] = *((void *)&v224 + 1);
                v321[0].i64[1] = v284;
                re::RenderGraphMeshNodeBase::makeDrawCallsFromMeshParts((uint64_t *)v321, v272, v271, (float32x4_t *)v221, v133, v356, (uint64_t)v352, 0, v135);
                if (*(void *)(v133 + 40))
                {
                  re::DrawTableSlice::DrawTableSlice(v321, v133);
                  v240.i64[0] = (uint64_t)"Occlusion";
                  v240.i64[1] = (uint64_t)v321;
                  unint64_t v241 = v354;
                  uint64_t v242 = v358;
                  uint64_t v243 = 0;
                  char v244 = v359;
                  __int16 v245 = 2;
                  __int16 v246 = 256;
                  long long v247 = __const__ZN2re20FeatureStencilStates18getStencilBlurInfoENS0_16StencilBlurUsageE_kReadStInfo;
                  char v248 = 0;
                  long long v249 = 0u;
                  long long v250 = 0u;
                  char v251 = 0;
                  uint64_t v252 = v135;
                  char v253 = 0;
                  re::RenderGraphContext::encodeDrawCalls(v221, v273, &v240);
                }
              }
              if (v268)
              {
                re::DrawTable::clearAll((re::DrawTable *)v133);
                re::InlineFunction<40ul,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator=((unsigned char *)(v133 + 280), &v318);
                uint64_t v136 = *(unsigned char *)(v221 + 1332)
                     ? re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v221 + 1336), v220[2], "Opaque"): 0;
                v321[0].i64[0] = v227;
                v321[0].i64[1] = v281;
                re::RenderGraphMeshNodeBase::makeDrawCallsFromMeshParts((uint64_t *)v321, v269, v268, (float32x4_t *)v221, v133, v356, (uint64_t)v352, 0, v136);
                if (*(void *)(v133 + 40))
                {
                  re::DrawTableSlice::DrawTableSlice(v321, v133);
                  v240.i64[0] = (uint64_t)"Opaque";
                  v240.i64[1] = (uint64_t)v321;
                  unint64_t v241 = v354;
                  uint64_t v242 = v358;
                  uint64_t v243 = 0;
                  char v244 = v359;
                  __int16 v245 = 2;
                  __int16 v246 = 256;
                  long long v247 = __const__ZN2re20FeatureStencilStates18getStencilBlurInfoENS0_16StencilBlurUsageE_kReadStInfo;
                  char v248 = 0;
                  long long v249 = 0u;
                  long long v250 = 0u;
                  char v251 = 0;
                  uint64_t v252 = v136;
                  char v253 = 0;
                  re::RenderGraphContext::encodeDrawCalls(v221, v273, &v240);
                }
              }
              uint64_t v209 = (re::DrawTable *)v133;
              v240.i64[0] = (uint64_t)v231;
              v240.i32[2] = 0;
              uint64_t v11 = (uint64_t)&v240;
              unint64_t v241 = 0;
              LODWORD(v242) = 0;
              unsigned int v8 = (re::StringID *)&v254;
              long long v254 = 0u;
              long long v255 = 0u;
              int v256 = 0;
              uint64_t v257 = v3;
              if (atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAB8, memory_order_acquire)) {
                goto LABEL_123;
              }
              goto LABEL_240;
            }
            uint64_t v9 = (re::StringID *)v218;
            unsigned int v8 = (re::StringID *)v219;
            BOOL v76 = v215;
            uint64_t v77 = v217;
LABEL_212:
            uint64_t v190 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v4 + 8) + 104));
            re::RenderGraphContext::acquireManagedRenderEncoder(v321, v4, v190, 0);
            re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)v321);
LABEL_213:
            if (v76 && v77) {
              (*(void (**)(long long *, uint64_t, __n128))(*(void *)v76 + 40))(v76, v77, v189);
            }
            if (v355[0])
            {
              if (v358) {
                (*(void (**)(__n128))(*(void *)v355[0] + 40))(v189);
              }
              uint64_t v358 = 0;
              v355[1] = 0;
              uint64_t v356 = 0;
              v355[0] = 0;
              ++v357;
            }
            if (v353[0] && v354) {
              (*(void (**)(__n128))(*(void *)v353[0] + 40))(v189);
            }
            goto LABEL_17;
          }
LABEL_47:
          HIDWORD(v212) = v11;
          if (v275 >= 2)
          {
            re::internal::assertLog((re::internal *)4, v58, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
            _os_crash();
            __break(1u);
LABEL_240:
            if (__cxa_guard_acquire(&qword_26AF9AAB8))
            {
              MurmurHash3_x64_128((uint64_t)"PlattersOnly", 12, 0, (unint64_t *)v321);
              qword_26AF9AAB0 = (v321[0].i64[1]
                               - 0x61C8864680B583E9
                               + (v321[0].i64[0] << 6)
                               + ((unint64_t)v321[0].i64[0] >> 2)) ^ v321[0].i64[0];
              __cxa_guard_release(&qword_26AF9AAB8);
            }
LABEL_123:
            uint64_t v208 = *(void *)(v222 + 40);
            if (v208)
            {
              unint64_t v137 = 0;
              uint64_t v138 = (void *)(v11 + 16);
              uint64_t v139 = *(void *)(*(void *)(v221 + 8) + 32);
              *((void *)&v224 + 1) = v139 + 8;
              v226.i64[0] = v139 + 72;
              v226.i64[1] = (uint64_t)&v243;
              uint64_t v4 = (uint64_t)&v323;
              __asm { FMOV            V8.2S, #1.0 }
              *(void *)&long long v224 = v11 + 16;
              while (1)
              {
                uint64_t v211 = v137;
                uint64_t v144 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v222, v137);
                uint64_t v145 = *(void *)(v144 + 16);
                if (v145) {
                  break;
                }
LABEL_158:
                unint64_t v137 = v211 + 1;
                if (v211 + 1 == v208) {
                  goto LABEL_159;
                }
              }
              int v72 = *(void **)(v144 + 32);
              char v214 = &v72[92 * v145];
              while (!v72[5])
              {
LABEL_157:
                v72 += 92;
                if (v72 == v214) {
                  goto LABEL_158;
                }
              }
              __int16 v146 = 0;
              uint64_t v9 = (re::StringID *)v72[18];
              unint64_t v147 = v72[19];
              long long v237 = v72 + 2;
              while (1)
              {
                int v231 = v146;
                uint64_t v148 = re::DataArray<re::MeshInstance>::get(v226.i64[0], *(void *)(v72[4] + 8 * (void)v146));
                uint64_t v149 = re::DataArray<re::MeshModel>::get(*((uint64_t *)&v224 + 1), *(void *)(v148 + 16));
                if (*(void *)(v149 + 56)) {
                  break;
                }
LABEL_156:
                __int16 v146 = (uint64_t *)((char *)v231 + 1);
                if ((unint64_t)v231 + 1 >= v72[5]) {
                  goto LABEL_157;
                }
              }
              unint64_t v2 = (float32x2_t *)v149;
              uint64_t v151 = 0;
              while (1)
              {
                float32x2_t v152 = v2[8];
                int v328 = 0;
                char v329 = 0;
                uint64_t v330 = 0;
                memset(v321, 0, sizeof(v321));
                v322.i8[0] = 0;
                long long v323 = 0u;
                long long v324 = 0u;
                long long v325 = 0u;
                long long v326 = 0u;
                char v327 = 0;
                uint64_t v331 = _D8;
                int v332 = 1065353216;
                char v333 = 0;
                char v334 = 0;
                unint64_t v153 = *(unsigned __int16 *)(*(void *)&v152 + 560 * v151 + 474);
                if (v147 <= v153)
                {
                  re::internal::assertLog((re::internal *)6, v150, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, v153, v147);
                  _os_crash();
                  __break(1u);
LABEL_210:
                  re::internal::assertLog((re::internal *)6, v150, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
                  _os_crash();
                  __break(1u);
                  goto LABEL_211;
                }
                uint64_t v154 = v72[35];
                v322.i64[1] = *((void *)v9 + v153);
                *((void *)&v324 + 1) = v154;
                long long v155 = (_anonymous_namespace_ *)re::MaterialParameterTableLayers::resolveTechniqueIndices((re::MaterialParameterTableLayers *)v321, qword_26AF9AAB0);
                if (!v150) {
                  goto LABEL_210;
                }
                if (*(_DWORD *)v155 != -1)
                {
                  if (HIDWORD(v255)) {
                    goto LABEL_135;
                  }
                  if (v241)
                  {
                    uint64_t v156 = 0;
                    while (*(uint64_t *)((char *)&v243 + v156) != *v237)
                    {
                      v156 += 8;
                      if (8 * v241 == v156) {
                        goto LABEL_142;
                      }
                    }
                    if (v156 != 8 * v241) {
                      goto LABEL_146;
                    }
LABEL_142:
                    if (v241 > 0xF)
                    {
                      double v159 = (uint64_t *)v240.i64[0];
                      if (!v240.i64[0])
                      {
                      }
                      if (!(void)v254) {
                        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::init((uint64_t)v8, (uint64_t)v159, 32);
                      }
                      uint64_t v160 = (uint64_t)v8;
                      if (v241)
                      {
                        uint64_t v161 = 8 * v241;
                        double v162 = &v243;
                        do
                        {
                          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::add(v160, v162++);
                          v161 -= 8;
                        }
                        while (v161);
                      }
                      unint64_t v241 = 0;
                      LODWORD(v242) = v242 + 1;
                      unsigned int v8 = (re::StringID *)v160;
                      uint64_t v138 = (void *)v224;
LABEL_135:
                      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::add((uint64_t)v8, v237);
                      goto LABEL_146;
                    }
                  }
                  int v157 = re::DynamicInlineArray<unsigned long long,16ul>::ensureCapacity(v138, v150);
                  unint64_t v158 = v241;
                  if (v157)
                  {
                    *(&v243 + v241) = *v237;
                    unint64_t v241 = ++v158;
                    LODWORD(v242) = v242 + 1;
                  }
                  if (!v158)
                  {
                    uint64_t v201 = -1;
                    uint64_t v203 = 0;
                    long long v197 = "operator[]";
                    uint64_t v199 = 381;
                    uint64_t v193 = "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu";
                    char v195 = "index < m_size";
                    re::internal::assertLog((re::internal *)6, v150);
                    _os_crash();
                    __break(1u);
                    goto LABEL_224;
                  }
                }
LABEL_146:
                if ((unint64_t)++v151 >= *(void *)&v2[7]) {
                  goto LABEL_156;
                }
              }
            }
LABEL_159:
            unint64_t v163 = v261;
            uint64_t v4 = v221;
            uint64_t v164 = v233;
            uint64_t v165 = v216;
            if (v261)
            {
              uint64_t v166 = 0;
              unint64_t v167 = v263;
              unint64_t v229 = v263;
              uint64_t v232 = (re::Allocator *)v261;
              do
              {
                uint64_t v168 = *(float32x4_t **)(v167 + 16 * v166 + 8);
                uint64_t v170 = (uint64_t *)&v168[1];
                unint64_t v169 = v168[1].u64[0];
                if (v169 != v165)
                {
                  if (!v171 || (unsigned __int8 v172 = *v171 + 1, *v171 == 0xFE))
                  {
                    re::computeMeshSceneBoundingBox(v168 + 2, (uint64_t)v234, v321);
                    uint64_t v174 = v164[1].i64[1];
                    long long v239 = v168;
                    if (v174)
                    {
                      char v175 = (float32x4_t *)v164[2].i64[1];
                      uint64_t v176 = v168 + 5;
                      int v177 = &v168[23].i8[8];
                      int v178 = v168 + 24;
                      int v179 = v175 + 6;
                      uint64_t v180 = 112 * v174;
                      uint64_t v181 = v175 + 2;
                      unsigned __int8 v172 = -1;
                      do
                      {
                        if (re::isBoundingBoxInsideVCAPlanes((uint64_t)v321, v176, 0, 0, v177, v178, v179, v173, v181, 4, v179[-6].i64[1], v179[-5].i32[0]))
                        {
                          if (v182)
                          {
                            if (v172 >= *v182) {
                              unsigned __int8 v172 = *v182;
                            }
                          }
                        }
                        v179 += 7;
                        v181 += 7;
                        v180 -= 112;
                      }
                      while (v180);
                    }
                    else
                    {
                      unsigned __int8 v172 = -1;
                    }
                    uint64_t v4 = v221;
                    unint64_t v163 = (unint64_t)v232;
                    uint64_t v164 = v233;
                    uint64_t v165 = v216;
                    unint64_t v167 = v229;
                    uint64_t v168 = v239;
                  }
                  if (HIDWORD(v255))
                  {
                    BOOL v183 = re::HashSetBase<re::WeakStringID,re::WeakStringID,re::internal::ValueAsKey<re::WeakStringID>,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::contains((uint64_t)v8, v170);
                    long long v184 = v220;
                  }
                  else
                  {
                    if (v241)
                    {
                      uint64_t v185 = 8 * v241;
                      int v186 = &v243;
                      long long v184 = v220;
                      while (*v186 != *v170)
                      {
                        ++v186;
                        v185 -= 8;
                        if (!v185)
                        {
                          int v186 = &v243 + v241;
                          break;
                        }
                      }
                    }
                    else
                    {
                      int v186 = &v243 + v241;
                      long long v184 = v220;
                    }
                    BOOL v183 = v186 != &v243 + v241;
                  }
                  v321[0] = (float32x4_t)0x1000001uLL;
                  v321[0].i8[2] = v183;
                  v321[1].i64[0] = 127;
                  v321[1].i8[1] = v172;
                  re::StencilPtInjectionNode::executeForPortal((unint64_t)v168, (float32x4_t *)v4, (uint64_t)v234, (uint64_t)v184[2], (char *)v184[3], (unint64_t)v184[4], (uint64_t)v321);
                }
                ++v166;
              }
              while (v166 != v163);
            }
            if ((void)v254) {
              re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit((uint64_t *)v8);
            }
            LODWORD(v242) = v242 + 1;
            unint64_t v241 = 0;
            v240.i64[0] = 0;
            v187.n128_f64[0] = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit((uint64_t *)v8);
            uint64_t v9 = (re::StringID *)v218;
            unsigned int v8 = (re::StringID *)v219;
            uint64_t v77 = v217;
            if (v265)
            {
              re::DrawTable::clearAll(v209);
              v315[0] = &unk_26E71A4D8;
              v315[1] = v164;
              v315[2] = &v343;
              v315[3] = v209;
              char v316 = BYTE4(v212);
              char v317 = 0;
              re::InlineFunction<40ul,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator=((unsigned char *)v209 + 280, v315);
              if (*(unsigned char *)(v4 + 1332)) {
                uint64_t v188 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "Transparent");
              }
              else {
                uint64_t v188 = 0;
              }
              v321[0].i64[0] = v205;
              v321[0].i64[1] = v278;
              re::RenderGraphMeshNodeBase::makeDrawCallsFromMeshParts((uint64_t *)v321, v266, v265, (float32x4_t *)v4, (uint64_t)v209, v356, (uint64_t)v352, 0, v188);
              if (*((void *)v209 + 5))
              {
                re::DrawTableSlice::DrawTableSlice(v321, (uint64_t)v209);
                v240.i64[0] = (uint64_t)"Transparent";
                v240.i64[1] = (uint64_t)v321;
                unint64_t v241 = v354;
                uint64_t v242 = v358;
                uint64_t v243 = 0;
                char v244 = v359;
                __int16 v245 = 2;
                __int16 v246 = 256;
                long long v247 = __const__ZN2re20FeatureStencilStates18getStencilBlurInfoENS0_16StencilBlurUsageE_kReadStInfo;
                char v248 = 0;
                long long v249 = 0u;
                long long v250 = 0u;
                char v251 = 0;
                uint64_t v252 = v188;
                char v253 = 0;
                re::RenderGraphContext::encodeDrawCalls(v4, v273, &v240);
              }
              if (!v317) {
                (*(void (**)(void *))v315[0])(v315);
              }
            }
            if (!v320) {
              (*(void (**)(float32x4_t *, __n128))v318.i64[0])(&v318, v187);
            }
            BOOL v76 = v215;
            if (v259 && v263) {
              (*(void (**)(__n128))(*v259 + 40))(v187);
            }
            if (v264[0] && v266) {
              (*(void (**)(__n128))(*(void *)v264[0] + 40))(v187);
            }
            if (v267[0] && v269) {
              (*(void (**)(__n128))(*(void *)v267[0] + 40))(v187);
            }
            if (v270[0] && v272) {
              (*(void (**)(__n128))(*(void *)v270[0] + 40))(v187);
            }
            re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable((uint64_t)&v337);
            uint64_t v345 = 0;
            ++v346;
            re::HashTable<unsigned long long,re::RenderGraphTargetHandle,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit(v206);
            uint64_t v343 = 0;
            LODWORD(v344) = 0;
            v189.n128_f64[0] = re::HashTable<unsigned long long,re::RenderGraphTargetHandle,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit(v206);
            goto LABEL_213;
          }
          unint64_t v60 = &v275 + 3 * v275;
          v60[2] = (unint64_t)this;
          *((unsigned char *)v60 + 24) = 0;
          *(_DWORD *)((char *)v60 + 29) = 65280;
          unint64_t v61 = ++v275;
          ++v276;
          goto LABEL_55;
        }
LABEL_52:
        RenderGraphDataPipe = (const char **)re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v4 + 1336), v220[2], "BlurPlatterMeshDraw");
        uint64_t v59 = (uint64_t)RenderGraphDataPipe;
        if (!this) {
          goto LABEL_53;
        }
        goto LABEL_47;
      }
      this = 0;
      unsigned int v8 = (re::StringID *)&v2[18];
      uint64_t v9 = (re::StringID *)v353;
      uint64_t v12 = (float32x4_t *)v236;
      while (1)
      {
        unint64_t v46 = (unint64_t)v2[16];
        if (v46 <= (unint64_t)this) {
          break;
        }
        re::Projection::computeMatrix4x4F(v8, (uint64_t)v321);
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v355, (uint64_t)v321);
        unint64_t v48 = (unint64_t)v2[6];
        if (v48 <= (unint64_t)this) {
          goto LABEL_50;
        }
        re::RenderCamera::computeInverseTransform(v12, (uint64_t)v321);
        *(void *)&double v41 = re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v353, (uint64_t)v321).n128_u64[0];
        this = (const char **)((char *)this + 1);
        v12 += 2;
        unsigned int v8 = (re::StringID *)((char *)v8 + 64);
        if ((unint64_t)this >= v2[61].u8[2]) {
          goto LABEL_34;
        }
      }
      re::internal::assertLog((re::internal *)6, v40, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, this, v46);
      _os_crash();
      __break(1u);
LABEL_50:
      re::internal::assertLog((re::internal *)6, v47, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, this, v48);
      _os_crash();
      __break(1u);
    }
    uint64_t v200 = 0;
    uint64_t v202 = 0;
    uint64_t v196 = "operator[]";
    uint64_t v198 = 389;
    uint64_t v194 = "index < m_size";
    re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu");
    _os_crash();
    __break(1u);
    goto LABEL_52;
  }
}

BOOL anonymous namespace'::shouldSkipBlurMaterial(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 8) != 0;
  }
  unint64_t v2 = *re::graphicsLogObjects(0);
  BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl(&dword_233120000, v2, OS_LOG_TYPE_ERROR, "BlurReprojectionState was not set.", v3, 2u);
    return 0;
  }
  return result;
}

uint64_t re::rendergraph_helper::populateMeshPassArray<1ul,re::FixedInlineArray<re::rendergraph_helper::RenderPass,1ul>>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v4 = *(unsigned char *)(a3 + 16);
  char v5 = *(unsigned char *)(a3 + 17);
  char v6 = *(unsigned char *)(a3 + 18);
  int v7 = *(_DWORD *)(a3 + 19);
  char v8 = *(unsigned char *)(a3 + 23);
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t result = re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(*(void *)(a1 + 8), &v10);
  if (result)
  {
    uint64_t v10 = result;
    char v11 = 1;
    int v12 = v7;
    char v13 = v4;
    char v14 = v5;
    char v15 = v6;
    char v16 = v8;
    return re::DynamicInlineArray<re::FilteredMeshPass,1ul>::add(a2, (uint64_t)&v10);
  }
  return result;
}

uint64_t re::DynamicInlineArray<re::FilteredMeshPass,10ul>::add(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)result;
  if (*(void *)result >= 0xAuLL)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = result + 16;
    uint64_t v4 = result + 16 + 24 * v2;
    *(void *)uint64_t v4 = *(void *)a2;
    int v5 = *(unsigned __int8 *)(a2 + 8);
    *(unsigned char *)(v4 + 8) = v5;
    if (v5) {
      *(_DWORD *)(v3 + 24 * v2 + 9) = *(_DWORD *)(a2 + 9);
    }
    *(_DWORD *)(v3 + 24 * v2 + 13) = *(_DWORD *)(a2 + 13);
    ++*(void *)result;
    ++*(_DWORD *)(result + 8);
  }
  return result;
}

uint64_t re::RenderGraphContext::tryGetRenderGraphDataPipe(re::RenderGraphContext *this, const char *__s)
{
  char v6[2] = *MEMORY[0x263EF8340];
  uint64_t v4 = (const char *)strlen(__s);
  if (v4)
  {
    MurmurHash3_x64_128((uint64_t)__s, (int)v4, 0, v6);
    uint64_t v4 = (const char *)((v6[1] + (v6[0] << 6) + (v6[0] >> 2) - 0x61C8864680B583E9) ^ v6[0]);
  }
  return re::RenderGraphContext::tryGetRenderGraphDataPipe(this, v4);
}

unsigned char *re::DrawTable::clearAll(re::DrawTable *this)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<re::DrawCall,128ul>::operator[]((uint64_t)this, i);
  }
  *((void *)this + 5) = 0;
  ++*((_DWORD *)this + 12);
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    for (unint64_t j = 0; j != v4; ++j)
      re::BucketArray<re::Matrix4x4<float>,128ul>::operator[]((uint64_t)this + 56, j);
  }
  *((void *)this + 12) = 0;
  ++*((_DWORD *)this + 26);
  uint64_t v6 = *((void *)this + 19);
  if (v6)
  {
    for (unint64_t k = 0; k != v6; ++k)
      re::BucketArray<re::ConstantTable const*,128ul>::operator[]((uint64_t)this + 112, k);
  }
  *((void *)this + 19) = 0;
  ++*((_DWORD *)this + 40);
  uint64_t v8 = *((void *)this + 26);
  if (v8)
  {
    for (unint64_t m = 0; m != v8; ++m)
      re::BucketArray<unsigned int,128ul>::operator[]((uint64_t)this + 168, m);
  }
  *((void *)this + 26) = 0;
  ++*((_DWORD *)this + 54);
  uint64_t v10 = *((void *)this + 33);
  if (v10)
  {
    for (unint64_t n = 0; n != v10; ++n)
      re::BucketArray<unsigned int,128ul>::operator[]((uint64_t)this + 224, n);
  }
  *((void *)this + 33) = 0;
  ++*((_DWORD *)this + 68);
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  BYTE8(v14) = 1;
  uint64_t result = re::InlineFunction<40ul,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator=((unsigned char *)this + 280, v13);
  if (!BYTE8(v14)) {
    return (unsigned char *)(**(uint64_t (***)(_OWORD *))&v13[0])(v13);
  }
  return result;
}

uint64_t re::SmallHashTable<unsigned long long,re::anonymous namespace'::SPlatterDrawInfo,16ul,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(_DWORD *)(a1 + 444))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6)
    {
      uint64_t result = a1 + 40;
      uint64_t v7 = 24 * v6;
      while (*(void *)(result - 8) != a2)
      {
        result += 24;
        v7 -= 24;
        if (!v7) {
          return 0;
        }
      }
      return result;
    }
    return 0;
  }
  if (!*(void *)(a1 + 416)) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 424) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 440)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 432);
  if (*(void *)(v4 + 32 * v3 + 8) != a2)
  {
    while (1)
    {
      uint64_t v3 = *(_DWORD *)(v4 + 32 * v3) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v4 + 32 * v3 + 8) == a2) {
        return v4 + 32 * v3 + 16;
      }
    }
    return 0;
  }
  return v4 + 32 * v3 + 16;
}

void re::allocViewportPercentsBuffer(re *this, re::RenderGraphContext *a2, const re::ViewportPercentData *a3)
{
  re::FrameContext::perFrameAlloc(a2, 0x20uLL, 0x10uLL, (uint64_t)&v17);
  uint64_t v6 = v17;
  uint64_t v8 = v18;
  unint64_t v7 = v19;
  uint64_t v9 = v20;
  *(void *)this = v17;
  *((_DWORD *)this + 2) = v8;
  *((_DWORD *)this + 3) = v7;
  *((void *)this + 2) = v9;
  unint64_t v10 = v7 >> 4;
  if (v7 <= 0xF)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v10);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  char v11 = (_OWORD *)(v6 + v8);
  *char v11 = xmmword_2343854A0;
  if (v7 <= 0x1F)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v10);
    _os_crash();
    __break(1u);
    return;
  }
  v11[1] = xmmword_2343854A0;
  if (a3)
  {
    unsigned int v12 = *((unsigned __int8 *)a3 + 64);
    if (v12 >= 2) {
      unsigned int v12 = 2;
    }
    if (v12)
    {
      for (unint64_t i = 0; ; unint64_t i = 1)
      {
        unint64_t v14 = *((void *)a3 + 2);
        if (v14 <= i) {
          break;
        }
        if (i == v10) {
          goto LABEL_16;
        }
        v11[i] = *((_OWORD *)a3 + i + 2);
        unint64_t v15 = i + 1;
        if (*((unsigned __int8 *)a3 + 64) >= 2u) {
          unint64_t v16 = 2;
        }
        else {
          unint64_t v16 = *((unsigned __int8 *)a3 + 64);
        }
        if (v15 >= v16) {
          return;
        }
      }
      re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, i, v14);
      _os_crash();
      __break(1u);
LABEL_16:
      re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v10, v10);
      _os_crash();
      __break(1u);
      goto LABEL_17;
    }
  }
}

uint64_t re::setViewportPercentsBuffer(re *this, id *a2, const re::mtl::ComputeCommandEncoder *a3)
{
  unsigned int v3 = a3;
  uint64_t v6 = (const re::ViewportPercentData *)re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)this + 146), *(void *)(*((void *)this + 5) + 48));
  if (!v6)
  {
    unint64_t v7 = *re::graphicsLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_233120000, v7, OS_LOG_TYPE_DEFAULT, "ViewportPercentsData is missing in blur pipeline. Using default values.", v9, 2u);
    }
  }
  re::allocViewportPercentsBuffer((re *)v9, *(re::RenderGraphContext **)this, v6);
  return [*a2 setBuffer:v11 offset:v10 atIndex:v3];
}

void re::SFBSystemShellDownsampleRawNodeCompute::setupEncoder(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  uint64_t v6 = (re::CameraStreamContext *)re::RenderGraphDataStore::tryGet<re::CameraStreamContext>(*(void *)(a2 + 1168), (int)"CameraStreamContext", "RenderFrame");
  if (v6)
  {
    unint64_t v7 = v6;
    uint64_t v61 = a1;
    if (*(unsigned char *)(a1 + 480))
    {
      if (*((void *)v6 + 227) && *((void *)v6 + 228))
      {
        objc_msgSend(*a3, "setTexture:atIndex:");
        uint64_t v8 = *((void *)v7 + 228);
LABEL_11:
        [*a3 setTexture:v8 atIndex:1];
LABEL_17:
        re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x410uLL, 4uLL, (uint64_t)buf);
        uint64_t v14 = *(void *)buf;
        uint64_t v15 = v68;
        uint64_t v65 = v69;
        re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x84uLL, 4uLL, (uint64_t)buf);
        uint64_t v16 = *(void *)buf;
        uint64_t v62 = v68;
        uint64_t v64 = v69;
        re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x30uLL, 0x10uLL, (uint64_t)buf);
        uint64_t v17 = *(void *)buf;
        uint64_t v63 = v68;
        uint64_t v60 = v69;
        re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x50uLL, 0x10uLL, (uint64_t)buf);
        uint64_t v18 = *(void *)buf;
        uint64_t v19 = v68;
        uint64_t v20 = v69;
        re::setViewportPercentsBuffer((re *)a2, a3, 0);
        if (*(unsigned char *)(v61 + 480))
        {
          uint64_t v21 = v18 + v19;
          long long v22 = *((_OWORD *)v7 + 109);
          long long v23 = *((_OWORD *)v7 + 110);
          long long v24 = *((_OWORD *)v7 + 112);
          *(_OWORD *)(v21 + 32) = *((_OWORD *)v7 + 111);
          *(_OWORD *)(v21 + 48) = v24;
          *(_OWORD *)uint64_t v21 = v22;
          *(_OWORD *)(v21 + 16) = v23;
          *(_DWORD *)(v21 + 64) = *((_DWORD *)v7 + 452);
          uint64_t v26 = v64;
          uint64_t v25 = v65;
          uint64_t v27 = v15;
          uint64_t v28 = v60;
          uint64_t v30 = v62;
          uint64_t v29 = v63;
        }
        else
        {
          uint64_t v59 = v14;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AA98, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_26AF9AA98))
          {
            qword_26AF9AA90 = re::getCombinedScopeHash((re *)"CameraTMData", v55, v56);
            __cxa_guard_release(&qword_26AF9AA98);
          }
          uint64_t v31 = *(void *)(a2 + 1168);
          unint64_t v32 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_12CameraTMDataEEE";
          uint64_t v27 = v15;
          if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_12CameraTMDataEEE" & 0x8000000000000000) != 0)
          {
            uint64_t v33 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_12CameraTMDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v34 = 5381;
            do
            {
              unint64_t v32 = v34;
              unsigned int v35 = *v33++;
              uint64_t v34 = (33 * v34) ^ v35;
            }
            while (v35);
          }
          *(void *)buf = (qword_26AF9AA90 + (v32 << 6) + (v32 >> 2) - 0x61C8864680B583E9) ^ v32;
          uint64_t v36 = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v31 + 16, (uint64_t *)buf);
          uint64_t v30 = v62;
          if (v36 && *(void *)v36) {
            memcpy((void *)(v59 + v15), (const void *)(*(void *)v36 + 8), 0x410uLL);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAA8, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_26AF9AAA8))
          {
            qword_26AF9AAA0 = re::getCombinedScopeHash((re *)"ToneMapping", v57, v58);
            __cxa_guard_release(&qword_26AF9AAA8);
          }
          uint64_t v37 = re::RenderGraphDataStore::tryGet<re::TonemapParametersData>(*(void *)(a2 + 1168), qword_26AF9AAA0);
          if (v37)
          {
            uint64_t v38 = v16 + v62;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)(v37 + 8);
            long long v39 = *(_OWORD *)(v37 + 24);
            long long v40 = *(_OWORD *)(v37 + 40);
            long long v41 = *(_OWORD *)(v37 + 72);
            *(_OWORD *)(v38 + 48) = *(_OWORD *)(v37 + 56);
            *(_OWORD *)(v38 + 64) = v41;
            *(_OWORD *)(v38 + 16) = v39;
            *(_OWORD *)(v38 + 32) = v40;
            long long v42 = *(_OWORD *)(v37 + 88);
            long long v43 = *(_OWORD *)(v37 + 104);
            long long v44 = *(_OWORD *)(v37 + 120);
            *(_DWORD *)(v38 + 128) = *(_DWORD *)(v37 + 136);
            *(_OWORD *)(v38 + 96) = v43;
            *(_OWORD *)(v38 + 112) = v44;
            *(_OWORD *)(v38 + 80) = v42;
          }
          uint64_t v45 = *(void *)(a2 + 1168);
          unint64_t v46 = (unint64_t)"N2re17TintConstantsDataE";
          if (((unint64_t)"N2re17TintConstantsDataE" & 0x8000000000000000) != 0)
          {
            uint64_t v47 = (unsigned __int8 *)((unint64_t)"N2re17TintConstantsDataE" & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v48 = 5381;
            do
            {
              unint64_t v46 = v48;
              unsigned int v49 = *v47++;
              uint64_t v48 = (33 * v48) ^ v49;
            }
            while (v49);
          }
          *(void *)buf = (*(void *)(*(void *)(a2 + 40) + 48) - 0x61C8864680B583E9 + (v46 << 6) + (v46 >> 2)) ^ v46;
          uint64_t v50 = (void *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v45 + 64, (uint64_t *)buf);
          if (v50)
          {
            __int8 v51 = (_OWORD *)*v50;
            uint64_t v26 = v64;
            uint64_t v25 = v65;
            uint64_t v28 = v60;
            uint64_t v29 = v63;
            if (*v50)
            {
              __int8 v52 = (_OWORD *)(v17 + v63);
              long long v53 = v51[1];
              long long v54 = v51[3];
              v52[1] = v51[2];
              uint64_t v52[2] = v54;
              *__int8 v52 = v53;
            }
          }
          else
          {
            uint64_t v26 = v64;
            uint64_t v25 = v65;
            uint64_t v28 = v60;
            uint64_t v29 = v63;
          }
        }
        objc_msgSend(*a3, "setBuffer:offset:atIndex:", v25, v27, 1, v59);
        [*a3 setBuffer:v26 offset:v30 atIndex:2];
        [*a3 setBuffer:v28 offset:v29 atIndex:3];
        [*a3 setBuffer:v20 offset:v19 atIndex:4];
        return;
      }
    }
    else
    {
      uint64_t v6 = (re::CameraStreamContext *)re::CameraStreamContext::leftMCAM(v6);
      uint64_t v10 = *((void *)v6 + 25);
      if (v10)
      {
        uint64_t v6 = (re::CameraStreamContext *)re::CameraStreamContext::rightMCAM(v7);
        if (*((void *)v6 + 25))
        {
          [*a3 setTexture:v10 atIndex:0];
          uint64_t v8 = *(void *)(re::CameraStreamContext::rightMCAM(v7) + 200);
          goto LABEL_11;
        }
      }
    }
    if (++_MergedGlobals_443 % 45 == 1)
    {
      uint64_t v11 = *re::graphicsLogObjects(v6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = _MergedGlobals_443;
        _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "No passthrough textures sent to blur CameraStreamManager for %i frame(s).", buf, 8u);
      }
    }
    unsigned int v12 = *(void **)(*(void *)(*(void *)(a2 + 8) + 64) + 224);
    uint64_t v66 = 93818879;
    uint64_t v13 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(v12 + 1, &v66);
    (*(void (**)(uint8_t *__return_ptr, void *, void))(*v12 + 24))(buf, v12, *(unsigned __int8 *)(v12[2] + 16 * v13 + 9));
    [*a3 setTexture:*(void *)buf atIndex:0];
    [*a3 setTexture:*(void *)buf atIndex:1];
    if (*(void *)buf) {

    }
    goto LABEL_17;
  }
  uint64_t v9 = *re::graphicsLogObjects(0);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Missing camera stream context.", buf, 2u);
  }
}

uint64_t re::CameraStreamContext::leftMCAM(re::CameraStreamContext *this)
{
  if (*((_DWORD *)this + 431))
  {
    unsigned int v1 = 0x7FFFFFFF;
    if (*((void *)this + 212))
    {
      unsigned int v2 = *(_DWORD *)(*((void *)this + 213) + 4 * (0xFDD4A52306A2329BLL % *((unsigned int *)this + 430)));
      if (v2 != 0x7FFFFFFF)
      {
        uint64_t v3 = *((void *)this + 214);
        unsigned int v1 = *(_DWORD *)(*((void *)this + 213) + 4 * (0xFDD4A52306A2329BLL % *((unsigned int *)this + 430)));
        if (*(void *)(v3 + 416 * v2 + 8) != 0x11844F475DLL)
        {
          while (1)
          {
            unsigned int v1 = *(_DWORD *)(v3
                           + 416
                           * *(unsigned int *)(*((void *)this + 213)
                                             + 4 * (0xFDD4A52306A2329BLL % *((unsigned int *)this + 430)))) & 0x7FFFFFFF;
            if (v1 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v3 + 416 * v1 + 8) == 0x11844F475DLL) {
              return *((void *)this + 214) + 416 * v1 + 16;
            }
          }
          unsigned int v1 = 0x7FFFFFFF;
        }
      }
    }
    return *((void *)this + 214) + 416 * v1 + 16;
  }
  else
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t result = (uint64_t)this + 48;
      uint64_t v6 = 416 * v4;
      while (*(void *)(result - 16) != 0x11844F475DLL)
      {
        result += 416;
        v6 -= 416;
        if (!v6) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::CameraStreamContext::rightMCAM(re::CameraStreamContext *this)
{
  if (*((_DWORD *)this + 431))
  {
    unsigned int v1 = 0x7FFFFFFF;
    if (*((void *)this + 212))
    {
      unsigned int v2 = *(_DWORD *)(*((void *)this + 213) + 4 * (0x753D5688F616C780uLL % *((unsigned int *)this + 430)));
      if (v2 != 0x7FFFFFFF)
      {
        uint64_t v3 = *((void *)this + 214);
        unsigned int v1 = *(_DWORD *)(*((void *)this + 213) + 4 * (0x753D5688F616C780uLL % *((unsigned int *)this + 430)));
        if (*(void *)(v3 + 416 * v2 + 8) != 0x21F05F00586)
        {
          while (1)
          {
            unsigned int v1 = *(_DWORD *)(v3
                           + 416
                           * *(unsigned int *)(*((void *)this + 213)
                                             + 4 * (0x753D5688F616C780uLL % *((unsigned int *)this + 430)))) & 0x7FFFFFFF;
            if (v1 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v3 + 416 * v1 + 8) == 0x21F05F00586) {
              return *((void *)this + 214) + 416 * v1 + 16;
            }
          }
          unsigned int v1 = 0x7FFFFFFF;
        }
      }
    }
    return *((void *)this + 214) + 416 * v1 + 16;
  }
  else
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t result = (uint64_t)this + 48;
      uint64_t v6 = 416 * v4;
      while (*(void *)(result - 16) != 0x21F05F00586)
      {
        result += 416;
        v6 -= 416;
        if (!v6) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  uint64_t v5 = (re::CameraStreamContext *)re::RenderGraphDataStore::tryGet<re::CameraStreamContext>(*(void *)(a2 + 1168), (int)"CameraStreamContext", "RenderFrame");
  uint64_t v6 = (void *)re::RenderGraphDataStore::tryGet<re::CameraMatrices>(*(void *)(a2 + 1168), *(void *)(*(void *)(a2 + 40) + 48));
  uint64_t v7 = *(void *)(a2 + 1168);
  unint64_t v8 = (unint64_t)"N2re18CameraProjFrustumsE";
  if (((unint64_t)"N2re18CameraProjFrustumsE" & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)((unint64_t)"N2re18CameraProjFrustumsE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  *(void *)buf = (*(void *)(*(void *)(a2 + 40) + 48) + (v8 << 6) + (v8 >> 2) - 0x61C8864680B583E9) ^ v8;
  unsigned int v12 = (re *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v7 + 64, (uint64_t *)buf);
  if (v12
    && (uint64_t v13 = *(void *)v12) != 0
    && (*(void *)(v13 + 16) ? (v14 = v5 == 0) : (v14 = 1), !v14 ? (BOOL v15 = v6 == 0) : (BOOL v15 = 1), !v15 && v6[8]))
  {
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x180uLL, 0x10uLL, (uint64_t)buf);
    uint64_t v16 = *(void *)buf;
    uint64_t v17 = *(unsigned int *)&buf[8];
    uint64_t v18 = *(unsigned int *)&buf[12];
    uint64_t v19 = (void *)v119;
    unint64_t v20 = *(unsigned int *)&buf[12] / 0xC0uLL;
    uint64_t v21 = (_OWORD *)re::CameraStreamContext::leftMCAM(v5);
    if (v18 <= 0xBF)
    {
LABEL_57:
      re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v20);
      _os_crash();
      __break(1u);
LABEL_58:
      re::internal::assertLog((re::internal *)6, v34, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v20);
      _os_crash();
      __break(1u);
    }
    uint64_t v107 = v16;
    long long v23 = (_OWORD *)(v16 + v17);
    long long v24 = v21[13];
    long long v25 = v21[14];
    long long v26 = v21[16];
    v23[2] = v21[15];
    void v23[3] = v26;
    *long long v23 = v24;
    v23[1] = v25;
    long long v27 = v21[17];
    long long v28 = v21[18];
    long long v29 = v21[20];
    v23[6] = v21[19];
    v23[7] = v29;
    unsigned char v23[4] = v27;
    v23[5] = v28;
    long long v30 = v21[21];
    long long v31 = v21[22];
    long long v32 = v21[24];
    v23[10] = v21[23];
    v23[11] = v32;
    v23[8] = v30;
    v23[9] = v31;
    uint64_t v33 = (_OWORD *)re::CameraStreamContext::rightMCAM(v5);
    if (v18 <= 0x17F) {
      goto LABEL_58;
    }
    long long v35 = v33[13];
    long long v36 = v33[14];
    long long v37 = v33[16];
    v23[14] = v33[15];
    v23[15] = v37;
    v23[12] = v35;
    v23[13] = v36;
    long long v38 = v33[17];
    long long v39 = v33[18];
    long long v40 = v33[20];
    v23[18] = v33[19];
    v23[19] = v40;
    unsigned char v23[16] = v38;
    v23[17] = v39;
    long long v41 = v33[21];
    long long v42 = v33[22];
    long long v43 = v33[24];
    v23[22] = v33[23];
    v23[23] = v43;
    v23[20] = v41;
    v23[21] = v42;
    if (*(void *)(v13 + 16))
    {
      uint64_t v44 = 0;
      char v45 = 1;
      while (v44 != v20)
      {
        uint64_t v46 = v13 + 32 + 16 * v44;
        v47.i32[0] = *(_DWORD *)v46;
        float32x2_t v48 = vabs_f32(*(float32x2_t *)(v46 + 4));
        v47.i32[1] = *(_DWORD *)(v46 + 12);
        float32x2_t v49 = vabs_f32(v47);
        *(float32x2_t *)&long long v50 = vadd_f32(v48, v49);
        *((void *)&v50 + 1) = __PAIR64__(v48.u32[1], v49.u32[0]);
        v23[12 * v44 + 1] = v50;
        LOBYTE(v46) = v45 & (*(void *)(v13 + 16) > (unint64_t)(v44 + 1));
        uint64_t v44 = 1;
        char v45 = 0;
        if ((v46 & 1) == 0) {
          goto LABEL_20;
        }
      }
      re::internal::assertLog((re::internal *)6, v34, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v20, v20);
      _os_crash();
      __break(1u);
      goto LABEL_56;
    }
LABEL_20:
    uint64_t v108 = v18;
    uint64_t v109 = v17;
    double v110 = a3;
    unint64_t v51 = 0;
    char v52 = 1;
    long long v53 = (_OWORD *)MEMORY[0x263EF89A8];
    do
    {
      char v54 = v52;
      uint64_t v55 = re::CameraStreamContext::camForEyeIndex(v5, v51);
      float32x4_t v113 = *(float32x4_t *)v55;
      float32x4_t v114 = *(float32x4_t *)(v55 + 16);
      float32x4_t v111 = *(float32x4_t *)(v55 + 48);
      float32x4_t v112 = *(float32x4_t *)(v55 + 32);
      simd_float4x4 v124 = __invert_f4(*(simd_float4x4 *)(v55 + 64));
      uint64_t v64 = 0;
      simd_float4x4 v117 = v124;
      do
      {
        *(float32x4_t *)&buf[v64 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v113, COERCE_FLOAT(*(_OWORD *)&v117.columns[v64])), v114, *(float32x2_t *)v117.columns[v64].f32, 1), v112, (float32x4_t)v117.columns[v64], 2), v111, (float32x4_t)v117.columns[v64], 3);
        ++v64;
      }
      while (v64 != 4);
      long long v65 = v119;
      long long v66 = v120[0];
      long long v67 = v120[1];
      unsigned int v68 = &__src[8 * v51];
      *unsigned int v68 = *(_OWORD *)buf;
      v68[1] = v65;
      v68[2] = v66;
      v68[3] = v67;
      uint64_t v69 = v53;
      if (v6[8] > v51) {
        uint64_t v69 = (_OWORD *)(v6[10] + (v51 << 6));
      }
      char v52 = 0;
      long long v71 = v69[2];
      long long v70 = v69[3];
      long long v72 = v69[1];
      unsigned char v68[8] = *v69;
      v68[9] = v72;
      v68[10] = v71;
      v68[11] = v70;
      unint64_t v51 = 1;
    }
    while ((v54 & 1) != 0);
    __src[32] = *(void *)(*(void *)a2 + 32) & 0xFFFFFFFFFFFFFFFLL;
    if (v6[3])
    {
      unint64_t v73 = 0;
      uint64_t v74 = v109 + v107 + 64;
      double v75 = (float32x4_t *)&__src[16];
      uint64_t v76 = 128;
      while (1)
      {
        uint64_t v77 = v6[5] + v76;
        WarpMatrixForSourceProjectiounint64_t n = re::createWarpMatrixForSourceProjection(*v75, v75[1], v75[2], v75[3], *(simd_float4 *)(v77 - 128), *(simd_float4 *)(v77 - 112), *(simd_float4 *)(v77 - 96), *(simd_float4 *)(v77 - 80), v56, v57, v58, v59, v60, v61, v62, v63, *v75, v75[1], v75[2],
                                          v75[3],
                                          (simd_float4)v75[-8],
                                          (simd_float4)v75[-7],
                                          (simd_float4)v75[-6],
                                          (simd_float4)v75[-5]);
        if (v20 == v73) {
          break;
        }
        *(_DWORD *)(v74 - 24) = v79;
        *(_DWORD *)(v74 - 8) = v81;
        *(double *)(v74 - 32) = WarpMatrixForSourceProjection;
        *(void *)(v74 - 16) = v80;
        *(_DWORD *)(v74 + 8) = v83;
        *(void *)uint64_t v74 = v82;
        v74 += 192;
        ++v73;
        v76 += 64;
        v75 += 4;
        if (v6[3] <= v73) {
          goto LABEL_30;
        }
      }
LABEL_56:
      re::internal::assertLog((re::internal *)6, v57, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v20, v20);
      _os_crash();
      __break(1u);
      goto LABEL_57;
    }
LABEL_30:
    id v84 = v19;
    [*v110 setBuffer:v84 offset:v109 atIndex:0];
    uint64_t v85 = *(void *)(*(void *)(a2 + 8) + 120);
    id v86 = v84;
    char v122 = 1;
    *(void *)buf = &unk_26E71A530;
    *(void *)&long long v119 = v86;
    *((void *)&v119 + 1) = v109 | (v108 << 32);
    memcpy(v120, __src, sizeof(v120));
    uint64_t v121 = v85;
    char v122 = 0;
    re::DynamicOverflowArray<re::InlineFunction<464ul,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>,5ul>::add(a2 + 1664, buf);
    re::setViewportPercentsBuffer((re *)a2, v110, (const re::mtl::ComputeCommandEncoder *)1);
    uint64_t v87 = *(void *)(a2 + 1168);
    unint64_t v88 = (unint64_t)"N2re25BlurBackgroundOpacityDataE";
    if (((unint64_t)"N2re25BlurBackgroundOpacityDataE" & 0x8000000000000000) != 0)
    {
      double v89 = (unsigned __int8 *)((unint64_t)"N2re25BlurBackgroundOpacityDataE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v90 = 5381;
      do
      {
        unint64_t v88 = v90;
        unsigned int v91 = *v89++;
        uint64_t v90 = (33 * v90) ^ v91;
      }
      while (v91);
    }
    v117.columns[0].i64[0] = (*(void *)(*(void *)(a2 + 40) + 48) - 0x61C8864680B583E9 + (v88 << 6) + (v88 >> 2)) ^ v88;
    double v92 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v87 + 64, (uint64_t *)&v117);
    if (v92 && (uint64_t v93 = *v92) != 0)
    {
      int v94 = *(_DWORD *)(v93 + 8);
      long long v115 = *(_OWORD *)(v93 + 16);
    }
    else
    {
      long long v115 = 0u;
      int v94 = 0;
    }
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x20uLL, 0x10uLL, (uint64_t)&v117);
    uint64_t v96 = v117.columns[1].i64[0];
    uint64_t v97 = v117.columns[0].i64[0] + v117.columns[0].u32[2];
    *(_DWORD *)uint64_t v97 = v94;
    *(_OWORD *)(v97 + 16) = v115;
    objc_msgSend(*v110, "setBuffer:offset:atIndex:", v96);
    uint64_t v98 = *(void *)(a2 + 1168);
    unint64_t v99 = (unint64_t)"N2re23ImmersiveEnvDimmingDataE";
    if (((unint64_t)"N2re23ImmersiveEnvDimmingDataE" & 0x8000000000000000) != 0)
    {
      uint64_t v100 = (unsigned __int8 *)((unint64_t)"N2re23ImmersiveEnvDimmingDataE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v101 = 5381;
      do
      {
        unint64_t v99 = v101;
        unsigned int v102 = *v100++;
        uint64_t v101 = (33 * v101) ^ v102;
      }
      while (v102);
    }
    v117.columns[0].i64[0] = (*(void *)(*(void *)(a2 + 40) + 48) - 0x61C8864680B583E9 + (v99 << 6) + (v99 >> 2)) ^ v99;
    uint64_t v103 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v98 + 64, (uint64_t *)&v117);
    if (v103) {
      uint64_t v104 = *v103;
    }
    else {
      uint64_t v104 = 0;
    }
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 4uLL, 4uLL, (uint64_t)&v117);
    uint64_t v105 = v117.columns[1].i64[0];
    if (v104) {
      float v106 = *(float *)(v104 + 8);
    }
    else {
      float v106 = 1.0;
    }
    *(float *)(v117.columns[0].i64[0] + v117.columns[0].u32[2]) = v106;
    objc_msgSend(*v110, "setBuffer:offset:atIndex:", v105);
    if (!v122) {
      (**(void (***)(uint8_t *))buf)(buf);
    }
    if (v86) {

    }
    if (v84) {
  }
    }
  else
  {
    double v95 = *re::graphicsLogObjects(v12);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_233120000, v95, OS_LOG_TYPE_ERROR, "Camera projection frustums were not properly set. Unable to initialize encoder in SFBSystemShellReprojectAndFilterNode.", buf, 2u);
    }
  }
}

uint64_t re::CameraStreamContext::camForEyeIndex(re::CameraStreamContext *this, int a2)
{
  unint64_t v2 = 0x21F05F00586;
  if (!a2) {
    unint64_t v2 = 0x11844F475DLL;
  }
  if (*((_DWORD *)this + 431))
  {
    LODWORD(v3) = 0x7FFFFFFF;
    if (*((void *)this + 212))
    {
      unint64_t v4 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
      uint64_t v5 = *(unsigned int *)(*((void *)this + 213) + 4 * ((v4 ^ (v4 >> 31)) % *((unsigned int *)this + 430)));
      if (v5 != 0x7FFFFFFF)
      {
        uint64_t v6 = *((void *)this + 214);
        LODWORD(v3) = v5;
        if (*(void *)(v6 + 416 * v5 + 8) != v2)
        {
          uint64_t v3 = v5;
          while (1)
          {
            LODWORD(v3) = *(_DWORD *)(v6 + 416 * v3) & 0x7FFFFFFF;
            if (v3 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v6 + 416 * v3 + 8) == v2) {
              return *((void *)this + 214) + 416 * v3 + 16;
            }
          }
          LODWORD(v3) = 0x7FFFFFFF;
        }
      }
    }
    return *((void *)this + 214) + 416 * v3 + 16;
  }
  else
  {
    uint64_t v7 = *((void *)this + 2);
    if (v7)
    {
      uint64_t result = (uint64_t)this + 48;
      uint64_t v9 = 416 * v7;
      while (*(void *)(result - 16) != v2)
      {
        result += 416;
        v9 -= 416;
        if (!v9) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t anonymous namespace'::setColorConstants(uint64_t a1, id *a2, unsigned int a3)
{
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)a1, 0xB0uLL, 0x10uLL, (uint64_t)&v27);
  uint64_t v6 = v28;
  uint64_t v7 = v29;
  uint64_t v8 = *(void *)(a1 + 1168);
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 48);
  unint64_t v10 = (unint64_t)"N2re24ColorFilterConstantsDataE";
  if (((unint64_t)"N2re24ColorFilterConstantsDataE" & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)((unint64_t)"N2re24ColorFilterConstantsDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  uint64_t v14 = v27;
  unint64_t v27 = (v9 + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583E9) ^ v10;
  BOOL v15 = (void *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v8 + 64, (uint64_t *)&v27);
  if (v15)
  {
    uint64_t v16 = (_OWORD *)*v15;
    if (*v15)
    {
      uint64_t v17 = (_OWORD *)(v14 + v6);
      long long v18 = v16[1];
      long long v19 = v16[3];
      v17[1] = v16[2];
      void v17[2] = v19;
      *uint64_t v17 = v18;
      long long v20 = v16[4];
      long long v21 = v16[5];
      long long v22 = v16[7];
      void v17[5] = v16[6];
      v17[6] = v22;
      void v17[3] = v20;
      v17[4] = v21;
      long long v23 = v16[8];
      long long v24 = v16[9];
      long long v25 = v16[11];
      v17[9] = v16[10];
      v17[10] = v25;
      unsigned char v17[7] = v23;
      unsigned char v17[8] = v24;
    }
  }
  return [*a2 setBuffer:v7 offset:v6 atIndex:a3];
}

uint64_t anonymous namespace'::setGammaLUTs(re::BufferTable *a1, id *a2, unsigned int a3)
{
  uint64_t v9 = 0x526A495CDE0FLL;
  uint64_t v6 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1, &v9);
  unint64_t v7 = re::BufferTable::bufferAt(a1, *(unsigned __int8 *)(*((void *)a1 + 1) + 16 * v6 + 8));
  return [*a2 setBuffer:*(void *)v7 offset:*(unsigned int *)(v7 + 8) atIndex:a3];
}

void re::SFBSystemShellCreateTextureAliasNode::setup(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 592) = 1;
}

void re::SFBSystemShellCreateTextureAliasNode::execute(re::SFBSystemShellCreateTextureAliasNode *this, re::RenderGraphContext *a2)
{
  if (!*((unsigned char *)this + 256)
  {
    if (*((void *)this + 24))
    {
      re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26), 0, 0, &v5);
      if (v5)
      {
        re::DynamicTextureTableAdd((void *)(*(void *)a2 + 368), (void *)this + 33, &v5);
        if (v5) {
      }
        }
    }
  }
}

void re::SFBSystemShellReprojectNode::setupEncoder(uint64_t a1, re *a2, id *a3)
{
  float v5 = (float)*(int *)(a1 + 484);
  float v6 = (float)*(int *)(a1 + 480);
  id v7 = *a3;
  id v12 = v7;

  re::setViewportPercentsBuffer(a2, a3, (const re::mtl::ComputeCommandEncoder *)1);
  id v8 = *a3;
  id v11 = v8;

  id v9 = *a3;
  id v10 = v9;
}

void anonymous namespace'::setReprojectionConstants(uint64_t a1, id *a2, float a3, float a4)
{
  __src[55] = *MEMORY[0x263EF8340];
  id v8 = (re::CameraStreamContext *)re::RenderGraphDataStore::tryGet<re::CameraStreamContext>(*(void *)(a1 + 1168), (int)"CameraStreamContext", "RenderFrame");
  uint64_t v9 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(a1 + 1168), *(void *)(*(void *)(a1 + 40) + 48));
  id v10 = (re *)re::RenderGraphDataStore::tryGet<re::CameraMatrices>(*(void *)(a1 + 1168), *(void *)(*(void *)(a1 + 40) + 48));
  if (v9) {
    BOOL v11 = v8 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11 && v10 != 0)
  {
    uint64_t v14 = v10;
    uint64_t v15 = *(void *)(a1 + 1168);
    unint64_t v16 = (unint64_t)"N2re20WorldToViewCacheDataE";
    if (((unint64_t)"N2re20WorldToViewCacheDataE" & 0x8000000000000000) != 0)
    {
      uint64_t v17 = (unsigned __int8 *)((unint64_t)"N2re20WorldToViewCacheDataE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        unint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    *(void *)buf = (*(void *)(*(void *)(a1 + 40) + 48) + (v16 << 6) + (v16 >> 2) - 0x61C8864680B583E9) ^ v16;
    long long v20 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v15 + 64, (uint64_t *)buf);
    if (v20) {
      uint64_t v21 = *v20;
    }
    else {
      uint64_t v21 = 0;
    }
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a1, 0x180uLL, 0x10uLL, (uint64_t)buf);
    uint64_t v22 = *(void *)buf;
    uint64_t v23 = *(unsigned int *)&buf[8];
    uint64_t v24 = *(unsigned int *)&buf[12];
    id v82 = *(id *)&v84[0];
    unint64_t v25 = *(unsigned int *)&buf[12] / 0xC0uLL;
    long long v26 = (_OWORD *)re::CameraStreamContext::leftMCAM(v8);
    if (v24 <= 0xBF)
    {
LABEL_45:
      re::internal::assertLog((re::internal *)6, v27, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v25);
      _os_crash();
      __break(1u);
    }
    else
    {
      int v81 = a2;
      unsigned int v28 = (float *)(v22 + v23);
      long long v29 = v26[13];
      long long v30 = v26[14];
      long long v31 = v26[16];
      *((_OWORD *)v28 + 2) = v26[15];
      *((_OWORD *)v28 + 3) = v31;
      *(_OWORD *)unsigned int v28 = v29;
      *((_OWORD *)v28 + 1) = v30;
      long long v32 = v26[17];
      long long v33 = v26[18];
      long long v34 = v26[20];
      *((_OWORD *)v28 + 6) = v26[19];
      *((_OWORD *)v28 + 7) = v34;
      *((_OWORD *)v28 + 4) = v32;
      *((_OWORD *)v28 + 5) = v33;
      long long v35 = v26[21];
      long long v36 = v26[22];
      long long v37 = v26[24];
      *((_OWORD *)v28 + 10) = v26[23];
      *((_OWORD *)v28 + 11) = v37;
      *((_OWORD *)v28 + 8) = v35;
      *((_OWORD *)v28 + 9) = v36;
      long long v38 = (_OWORD *)re::CameraStreamContext::rightMCAM(v8);
      if (v24 > 0x17F)
      {
        long long v40 = v38[13];
        long long v41 = v38[14];
        long long v42 = v38[16];
        *((_OWORD *)v28 + 14) = v38[15];
        *((_OWORD *)v28 + 15) = v42;
        *((_OWORD *)v28 + 12) = v40;
        *((_OWORD *)v28 + 13) = v41;
        long long v43 = v38[17];
        long long v44 = v38[18];
        long long v45 = v38[20];
        *((_OWORD *)v28 + 18) = v38[19];
        *((_OWORD *)v28 + 19) = v45;
        *((_OWORD *)v28 + 16) = v43;
        *((_OWORD *)v28 + 17) = v44;
        long long v46 = v38[21];
        long long v47 = v38[22];
        long long v48 = v38[24];
        *((_OWORD *)v28 + 22) = v38[23];
        *((_OWORD *)v28 + 23) = v48;
        *((_OWORD *)v28 + 20) = v46;
        *((_OWORD *)v28 + 21) = v47;
        uint64_t v49 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*(void *)(a1 + 1168), *(void *)(*(void *)(a1 + 40) + 48));
        if (v49) {
          float v53 = *(float *)(v49 + 20);
        }
        else {
          float v53 = 1.0;
        }
        unint64_t v54 = 0;
        unsigned char v28[44] = v53;
        v28[92] = v53;
        memset(&__src[48], 0, 32);
        unint64_t v55 = *((void *)v14 + 3);
        char v56 = 1;
        uint64_t v57 = (_OWORD *)MEMORY[0x263EF89A8];
        while (1)
        {
          uint64_t v58 = v21 + (v54 << 6);
          if (v21) {
            uint64_t v59 = (_OWORD *)(v58 + 16);
          }
          else {
            uint64_t v59 = v57;
          }
          long long v60 = v59[1];
          char v61 = v56;
          uint64_t v62 = &__src[8 * v54];
          *uint64_t v62 = *v59;
          v62[1] = v60;
          long long v63 = v59[3];
          v62[2] = v59[2];
          v62[3] = v63;
          uint64_t v64 = (_OWORD *)(v58 + 144);
          if (!v21) {
            uint64_t v64 = v57;
          }
          long long v65 = v64[1];
          v62[8] = *v64;
          v62[9] = v65;
          long long v66 = v64[3];
          v62[10] = v64[2];
          v62[11] = v66;
          long long v67 = v57;
          if (v55 > v54)
          {
            unint64_t v68 = *((void *)v14 + 8);
            if (v68 <= v54)
            {
              memset(v84, 0, 64);
              *(_OWORD *)buf = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              __dst[0] = 136315906;
              *(void *)&__dst[1] = "operator[]";
              LOWORD(__dst[3]) = 1024;
              *(_DWORD *)((char *)&__dst[3] + 2) = 797;
              HIWORD(__dst[4]) = 2048;
              *(void *)&__dst[5] = v54;
              LOWORD(__dst[7]) = 2048;
              *(void *)((char *)&__dst[7] + 2) = v68;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_45;
            }
            long long v67 = (_OWORD *)(*((void *)v14 + 10) + (v54 << 6));
          }
          long long v70 = v67[2];
          long long v69 = v67[3];
          long long v71 = v67[1];
          v62[16] = *v67;
          v62[17] = v71;
          v62[18] = v70;
          v62[19] = v69;
          long long v72 = xmmword_2343854A0;
          if (*(void *)(v9 + 16) > v54) {
            long long v72 = *(_OWORD *)(v9 + 32 + 16 * v54);
          }
          char v56 = 0;
          *(_OWORD *)&__src[2 * v54 + 48] = v72;
          unint64_t v54 = 1;
          if ((v61 & 1) == 0)
          {
            __src[52] = __PAIR64__(LODWORD(a3), LODWORD(a4));
            if (v55)
            {
              uint64_t v73 = 0;
              unint64_t v74 = 0;
              do
              {
                double v75 = (_OWORD *)(*((void *)v14 + 5) + v73);
                long long v76 = v75[1];
                long long v77 = v75[2];
                long long v78 = v75[3];
                *(_OWORD *)buf = *v75;
                v84[0] = v76;
                v84[1] = v77;
                v84[2] = v78;
                v73 += 64;
              }
              while (*((void *)v14 + 3) > v74);
            }
            id v79 = v82;
            [*v81 setBuffer:v79 offset:v23 atIndex:0];
            memcpy(__dst, __src, 0x1A8uLL);
            id v80 = v79;
            char v87 = 1;
            *(void *)buf = &unk_26E71A3B0;
            memcpy(v84, __dst, sizeof(v84));
            id v85 = v80;
            uint64_t v86 = v23 | (v24 << 32);
            char v87 = 0;
            re::DynamicOverflowArray<re::InlineFunction<464ul,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>,5ul>::add(a1 + 1664, buf);
            if (!v87) {
              (**(void (***)(uint8_t *))buf)(buf);
            }
            if (v80) {

            }
            if (v79) {
            return;
            }
          }
        }
      }
    }
    re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v25);
    _os_crash();
    __break(1u);
  }
  unsigned int v13 = *re::graphicsLogObjects(v10);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_233120000, v13, OS_LOG_TYPE_ERROR, "Missing data for Reprojection Constants in blur pipeline. Unable to setup encoder.", buf, 2u);
  }
}

void re::SFBSystemShellBlurTAANode::setupEncoder(uint64_t a1, re *a2, id *a3)
{
  float v6 = (float)*(int *)(a1 + 488);
  float v7 = (float)*(int *)(a1 + 484);
  id v8 = *a3;
  id v18 = v8;

  re::setViewportPercentsBuffer(a2, a3, (const re::mtl::ComputeCommandEncoder *)1);
  uint64_t v9 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  *(int32x2_t *)&double v11 = re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 4uLL, 4uLL, (uint64_t)&v19);
  if (v21 <= 3)
  {
    re::internal::assertLog((re::internal *)6, *(void *)&v10, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, 0);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v12 = v22;
    uint64_t v13 = 16;
    if (!*(unsigned char *)(a1 + 480)) {
      uint64_t v13 = 12;
    }
    *(_DWORD *)(v19 + v20) = *(_DWORD *)(v9 + v13);
    objc_msgSend(*a3, "setBuffer:offset:atIndex:", v12);
    id v14 = *a3;
    id v17 = v14;

    id v15 = *a3;
    id v16 = v15;
  }
}

void re::SFBSystemShellReprojectNode::execute(re::SFBSystemShellReprojectNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  {
    re::RenderGraphComputeNodeBase::execute(this, a2);
  }
}

BOOL re::SFBSystemShellComputeNode::skipNode(re::SFBSystemShellComputeNode *this, re::RenderGraphContext *a2)
{
  uint64_t v3 = this;
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 24);
  uint64_t v5 = 0;
  if (v4)
  {
    uint64_t v6 = *((void *)this + 26);
    uint64_t v7 = 32 * v4;
    do
    {
      re::RenderGraphContext::metalTexture((uint64_t)a2, v6, 0, 0, (id *)v17);
      unint64_t v8 = (unint64_t)objc_msgSend(*(id *)v17, sel_protectionOptions);
      this = *(re::SFBSystemShellComputeNode **)v17;
      if (*(void *)v17) {

      }
      v5 |= v8;
      v6 += 32;
      v7 -= 32;
    }
    while (v7);
  }
  uint64_t v9 = *((void *)v3 + 29);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *((void *)v3 + 31);
    uint64_t v12 = v9 << 6;
    do
    {
      re::RenderGraphContext::metalTexture((uint64_t)a2, v11, 0, 0, (id *)v17);
      unint64_t v13 = (unint64_t)objc_msgSend(*(id *)v17, sel_protectionOptions);
      this = *(re::SFBSystemShellComputeNode **)v17;
      if (*(void *)v17) {

      }
      v10 |= v13;
      v11 += 64;
      v12 -= 64;
    }
    while (v12);
  }
  else
  {
    uint64_t v10 = 0;
  }
  if ((v5 & ~v10) != 0)
  {
    id v14 = *re::graphicsLogObjects(this);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *((void *)v3 + 2);
      *(_DWORD *)id v17 = 136315650;
      *(void *)&v17[4] = v16;
      __int16 v18 = 2048;
      uint64_t v19 = v5;
      __int16 v20 = 2048;
      uint64_t v21 = v10;
      _os_log_error_impl(&dword_233120000, v14, OS_LOG_TYPE_ERROR, "[SFBSystemShellComputeNode] (%s) Mismatching protection options for input texture %llu and output texture %llu. Skipping compute for this frame.", v17, 0x20u);
    }
  }
  return (v5 & ~v10) != 0;
}

void re::SFBSystemShellTileDownsampleNode::execute(re::SFBSystemShellTileDownsampleNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  {
    re::RenderGraphMRCNode::execute(this, a2);
  }
}

id re::SFBSystemShellTileDownsampleNode::setupEncoder(re::SFBSystemShellTileDownsampleNode *this, re::RenderGraphContext *a2, id *a3)
{
  uint64_t v5 = (const re::ViewportPercentData *)re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!v5)
  {
    uint64_t v6 = *re::graphicsLogObjects(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v8 = 0;
      _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, "ViewportPercentsData is missing in blur pipeline. Using default values.", v8, 2u);
    }
  }
  re::allocViewportPercentsBuffer((re *)v8, *(re::RenderGraphContext **)a2, v5);
  return objc_msgSend(*a3, sel_setTileBuffer_offset_atIndex_, v10, v9, 0);
}

void re::SFBSystemShellComputeNode::execute(re::SFBSystemShellComputeNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  {
    re::RenderGraphComputeNodeBase::execute(this, a2);
  }
}

void re::SFBSystemShellComputeNode::~SFBSystemShellComputeNode(re::SFBSystemShellComputeNode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellBlurTAANode::~SFBSystemShellBlurTAANode(re::SFBSystemShellBlurTAANode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellStencilBlurMeshNode::~SFBSystemShellStencilBlurMeshNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellDownsampleRawNodeCompute::~SFBSystemShellDownsampleRawNodeCompute(re::SFBSystemShellDownsampleRawNodeCompute *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellReprojectAndRectifyNode::~SFBSystemShellReprojectAndRectifyNode(re::SFBSystemShellReprojectAndRectifyNode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellReprojectNode::~SFBSystemShellReprojectNode(re::SFBSystemShellReprojectNode *this)
{
  re::RenderGraphComputeNodeBase::~RenderGraphComputeNodeBase(this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellCreateTextureAliasNode::~SFBSystemShellCreateTextureAliasNode(id *this)
{
  this[33] = 0;
  re::RenderGraphNode::~RenderGraphNode(this);
}

void re::SFBSystemShellCreateTextureAliasNode::~SFBSystemShellCreateTextureAliasNode(re::SFBSystemShellCreateTextureAliasNode *this)
{
  *((void *)this + 33) = 0;
  re::RenderGraphNode::~RenderGraphNode((id *)this);
  JUMPOUT(0x237DBCBD0);
}

void re::SFBSystemShellTileDownsampleNode::~SFBSystemShellTileDownsampleNode(re::SFBSystemShellTileDownsampleNode *this)
{
  re::RenderGraphMRCNode::~RenderGraphMRCNode(this);
  JUMPOUT(0x237DBCBD0);
}

BOOL re::RenderGraphMRCNode::needsNewPipelineState(re::RenderGraphMRCNode *this, re::RenderGraphContext *a2)
{
  return *((void *)this + 49) == 0;
}

void re::MeshPassInfoData::~MeshPassInfoData(re::MeshPassInfoData *this)
{
}

re::CameraMatrices *re::CameraMatrices::CameraMatrices(re::CameraMatrices *this, re::Allocator *a2, unint64_t a3)
{
  *(void *)this = &unk_26E70E270;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 10) = 0;
  *((unsigned char *)this + 96) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((unsigned char *)this + 128) = 1;
  *((void *)this + 1) = a2;
  re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)this + 1, a3);
  ++*((_DWORD *)this + 8);
  *((void *)this + 6) = a2;
  re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)this + 6, a3);
  ++*((_DWORD *)this + 18);
  *((unsigned char *)this + 128) = a3;
  return this;
}

uint64_t re::RenderGraphContext::tryGetRenderGraphDataPipe(re::RenderGraphContext *this, const char *a2)
{
  unint64_t v2 = &re::mtl::introspect_BlendOperation(BOOL)::enumTable;
  {
    uint64_t v6 = a2;
    uint64_t v7 = this;
    unint64_t v2 = (void *)&re::mtl::introspect_BlendOperation(BOOL)::enumTable;
    int v5 = v4;
    a2 = v6;
    this = v7;
    if (v5)
    {
      re::RenderGraphContext::tryGetRenderGraphDataPipe(unsigned long)::kRenderGraphDataPipeDataunint64_t ScopeHash = re::hashString((re *)"RenderGraphDataPipeData", v6);
      unint64_t v2 = (void *)&re::mtl::introspect_BlendOperation(BOOL)::enumTable;
      a2 = v6;
      this = v7;
    }
  }
  uint64_t result = re::RenderGraphDataStore::tryGet<re::RenderGraphDataPipeData>(*((void *)this + 146), (unint64_t)&a2[64 * v2[94] - 0x61C8864680B583E9 + (v2[94] >> 2)] ^ v2[94]);
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_0,BOOL ()(re::MeshPartDrawContext const&)>::~Callable()
{
}

BOOL re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_0,BOOL ()(re::MeshPartDrawContext const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void **)(v2 + 32);
  uint64_t v4 = *(void *)(v2 + 16);
  int v5 = &v3[14 * v4];
  if (v4)
  {
    uint64_t v6 = 112 * v4;
    while (*v3 != *a2)
    {
      v3 += 14;
      v6 -= 112;
      if (!v6)
      {
        uint64_t v3 = v5;
        return v3 != v5;
      }
    }
  }
  return v3 != v5;
}

void *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_0,BOOL ()(re::MeshPartDrawContext const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E71A2F0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_0,BOOL ()(re::MeshPartDrawContext const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E71A2F0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_0,BOOL ()(re::MeshPartDrawContext const&)>::size()
{
  return 16;
}

uint64_t re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::operator=<32ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 40);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x21)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 32);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 40) = v6;
      (*(void (**)(void))(**(void **)(a2 + 40) + 24))(*(void *)(a2 + 40));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<32ul,BOOL ()(re::MeshPartDrawContext const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 40);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 40) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32));
    }
    *(void *)(a1 + 40) = 0;
  }
  return result;
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_2,BOOL ()(re::MeshPartDrawContext const&)>::~Callable()
{
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_2,BOOL ()(re::MeshPartDrawContext const&)>::operator()(uint64_t a1, float32x4_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 24);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = *(float32x4_t **)(v2 + 40);
  unint64_t v7 = a2 + 4;
  uint64_t v8 = &a2[9].i8[8];
  unsigned int v9 = a2 + 8;
  uint64_t v10 = v6 + 6;
  uint64_t v11 = 112 * v3;
  for (unint64_t i = v6 + 2; ; i += 7)
  {
    if (v13)
    {
      if ((a2[9].i8[9] & 1) != 0 && *(unsigned char *)(v13 + 1) && a2[10].f32[1] == *(float *)(v13 + 4)) {
        uint64_t v15 = a2[9].u8[11] == *(unsigned __int8 *)(v13 + 8) ? v10[-6].i64[1] : 0;
      }
      else {
        uint64_t v15 = 0;
      }
      __int32 v16 = a2[11].i32[1];
      if (re::isBoundingBoxInsideVCAPlanes(a2[1].i64[0] + 432, v7, v15, a2[11].i32[2], v8, v9, v10, v14, i, 4, v10[-6].i64[1], v10[-5].i32[0]))
      {
        if ((v16 & 0x4000000) == 0) {
          break;
        }
      }
    }
    v10 += 7;
    v11 -= 112;
    if (!v11) {
      return 0;
    }
  }
  return 1;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_2,BOOL ()(re::MeshPartDrawContext const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A358;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_2,BOOL ()(re::MeshPartDrawContext const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A358;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_2,BOOL ()(re::MeshPartDrawContext const&)>::size()
{
  return 24;
}

void anonymous namespace'::computeWarpTransforms(uint64_t a1, unint64_t a2, uint64_t a3, simd_float4 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v13 = (int)a5;
  uint64_t v14 = a3 + ((uint64_t)(int)a5 << 6);
  WarpMatrixForSourceProjectiounint64_t n = re::createWarpMatrixForSourceProjection(*(float32x4_t *)(v14 + 256), *(float32x4_t *)(v14 + 272), *(float32x4_t *)(v14 + 288), *(float32x4_t *)(v14 + 304), *a4, a4[1], a4[2], a4[3], a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(float32x4_t *)(v14 + 256), *(float32x4_t *)(v14 + 272), *(float32x4_t *)(v14 + 288),
                                    *(float32x4_t *)(v14 + 304),
                                    *(simd_float4 *)v14,
                                    *(simd_float4 *)(v14 + 16),
                                    *(simd_float4 *)(v14 + 32),
                                    *(simd_float4 *)(v14 + 48));
  if (a2 <= v8)
  {
    re::internal::assertLog((re::internal *)6, v15, WarpMatrixForSourceProjection, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v13, a2);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v23 = (float32x4_t *)(a1 + 192 * (int)v13);
    *(double *)v23[5].i64 = WarpMatrixForSourceProjection;
    v23[5].i32[2] = v17;
    v23[6].i64[0] = v18;
    v23[6].i32[2] = v19;
    v23[7].i64[0] = v20;
    v23[7].i32[2] = v21;
    LODWORD(v22) = *(_DWORD *)(a3 + 420);
    uint64_t v24 = a3 + 16 * v13;
    double ViewportToNDCReprojectionMatrix = re::createViewportToNDCReprojectionMatrix(*(void *)(v24 + 384), *(void *)(v24 + 392), v23[5], v23[6], v23[7], *(float *)(a3 + 416), v22);
    v23[5].i32[2] = v26;
    *(double *)v23[5].i64 = ViewportToNDCReprojectionMatrix;
    v23[6].i32[2] = v27;
    v23[6].i64[0] = v28;
    v23[7].i32[2] = v29;
    v23[7].i64[0] = v30;
    *(double *)v23[8].i64 = re::createWarpMatrixForSourceProjection(*(float32x4_t *)(v14 + 256), *(float32x4_t *)(v14 + 272), *(float32x4_t *)(v14 + 288), *(float32x4_t *)(v14 + 304), *a4, a4[1], a4[2], a4[3], v31, v32, v33, v34, v35, v36, v37, v38, *(float32x4_t *)(v14 + 256), *(float32x4_t *)(v14 + 272), *(float32x4_t *)(v14 + 288),
                              *(float32x4_t *)(v14 + 304),
                              *(simd_float4 *)(v14 + 128),
                              *(simd_float4 *)(v14 + 144),
                              *(simd_float4 *)(v14 + 160),
                              *(simd_float4 *)(v14 + 176));
    v23[8].i32[2] = v39;
    v23[9].i32[2] = v40;
    v23[9].i64[0] = v41;
    v23[10].i64[0] = v42;
    v23[10].i32[2] = v43;
    LODWORD(v44) = *(_DWORD *)(a3 + 420);
    double v45 = re::createViewportToNDCReprojectionMatrix(*(void *)(v24 + 384), *(void *)(v24 + 392), v23[8], v23[9], v23[10], *(float *)(a3 + 416), v44);
    v23[8].i32[2] = v46;
    *(double *)v23[8].i64 = v45;
    v23[9].i32[2] = v47;
    v23[9].i64[0] = v48;
    v23[10].i32[2] = v49;
    v23[10].i64[0] = v50;
  }
}

void *re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E71A3B0;
  uint64_t v2 = (void *)a1[56];
  if (v2)
  {

    a1[56] = 0;
  }
  return a1;
}

void re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E71A3B0;
  uint64_t v2 = (void *)a1[56];
  if (v2)
  {

    a1[56] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void *re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::operator()(uint64_t a1, simd_float4 *a2, simd_float4 *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v6 = a1 + 16;
  memcpy(__dst, (char *)objc_msgSend(*(id *)(a1 + 448), sel_contents) + *(unsigned int *)(a1 + 456), *(unsigned int *)(a1 + 460));
  uint64_t v10 = 0;
  char v11 = 1;
  do
  {
    int v12 = v11 & 1;
    if (v11) {
      uint64_t v13 = a2;
    }
    else {
      uint64_t v13 = a3;
    }
    simd_float4 v14 = v13[1];
    simd_float4 v15 = v13[2];
    simd_float4 v16 = v13[3];
    v18[0] = *v13;
    v18[1] = v14;
    void v18[2] = v15;
    void v18[3] = v16;
    char v11 = 0;
    uint64_t v10 = 1;
  }
  while (v12);
  return memcpy((char *)objc_msgSend(*(id *)(a1 + 448), sel_contents) + *(unsigned int *)(a1 + 456), __dst, *(unsigned int *)(a1 + 460));
}

void *re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E71A3B0;
  memcpy(a2 + 2, (const void *)(a1 + 16), 0x1B0uLL);
  a2[56] = *(id *)(a1 + 448);
  a2[57] = *(void *)(a1 + 456);
  return a2;
}

void *re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E71A3B0;
  memcpy(a2 + 2, (const void *)(a1 + 16), 0x1B0uLL);
  a2[56] = *(id *)(a1 + 448);
  a2[57] = *(void *)(a1 + 456);
  return a2;
}

uint64_t re::internal::Callable<anonymous namespace'::setReprojectionConstants(re::RenderGraphContext &,float,float,re::mtl::ComputeCommandEncoder,unsigned int)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::size()
{
  return 464;
}

void re::RenderGraphMeshNode::~RenderGraphMeshNode(id *this)
{
  *this = &unk_26E71F980;
  re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)(this + 37));
  re::DynamicString::deinit((re::DynamicString *)(this + 33));
  re::RenderGraphNode::~RenderGraphNode(this);
}

{
  uint64_t vars8;

  re::RenderGraphMeshNode::~RenderGraphMeshNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphMRCNode::~RenderGraphMRCNode(re::RenderGraphMRCNode *this)
{
  *(void *)this = &unk_26E71DED0;
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)this + 400);
  uint64_t v2 = (void *)*((void *)this + 49);
  if (v2)
  {

    *((void *)this + 49) = 0;
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 352);
  re::DynamicString::deinit((re::RenderGraphMRCNode *)((char *)this + 280));
  re::AssetHandle::~AssetHandle((re::RenderGraphMRCNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

{
  uint64_t vars8;

  re::RenderGraphMRCNode::~RenderGraphMRCNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::tryGet<re::BlurReprojectionState>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re21BlurReprojectionStateE";
  if (((unint64_t)"N2re21BlurReprojectionStateE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re21BlurReprojectionStateE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::RenderGraphDataStore::get<re::RendererGlobals>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re15RendererGlobalsE";
  if (((unint64_t)"N2re15RendererGlobalsE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re15RendererGlobalsE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

uint64_t re::RenderGraphDataStore::get<re::SceneScope>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re10SceneScopeE";
  if (((unint64_t)"N2re10SceneScopeE" & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re10SceneScopeE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unsigned int v6 = 0x7FFFFFFF;
  if (*(void *)(a1 + 64))
  {
    unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
    unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)));
      if (*(void *)(v9 + 24 * v8 + 8) != v7)
      {
        while (1)
        {
          unsigned int v6 = *(_DWORD *)(v9 + 24 * *(unsigned int *)(*(void *)(a1 + 72) + 4 * (v7 % *(unsigned int *)(a1 + 88)))) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 24 * v6 + 8) == v7) {
            return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
          }
        }
        unsigned int v6 = 0x7FFFFFFF;
      }
    }
  }
  return *(void *)(*(void *)(a1 + 80) + 24 * v6 + 16);
}

uint64_t re::DynamicInlineArray<re::FilteredMeshPass,1ul>::add(uint64_t *a1, uint64_t a2)
{
  uint64_t result = re::DynamicInlineArray<re::FilteredMeshPass,1ul>::ensureCapacity(a1, a2);
  if (result)
  {
    unsigned int v5 = a1 + 2;
    uint64_t v6 = *a1;
    uint64_t v7 = (uint64_t)&a1[3 * *a1 + 2];
    *(void *)uint64_t v7 = *(void *)a2;
    int v8 = *(unsigned __int8 *)(a2 + 8);
    *(unsigned char *)(v7 + 8) = v8;
    if (v8) {
      *(_DWORD *)((char *)&v5[3 * v6 + 1] + 1) = *(_DWORD *)(a2 + 9);
    }
    *(_DWORD *)((char *)&v5[3 * v6 + 1] + 5) = *(_DWORD *)(a2 + 13);
    ++*a1;
    ++*((_DWORD *)a1 + 2);
  }
  return result;
}

uint64_t re::DynamicInlineArray<re::FilteredMeshPass,1ul>::ensureCapacity(void *a1, uint64_t a2)
{
  if (!*a1) {
    return 1;
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_1,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::~Callable()
{
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_1,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator()(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = (int *)*((void *)a1 + 1);
  int v6 = *v5 + 1;
  *unsigned int v5 = v6;
  if (!*(unsigned char *)(a2 + 94)) {
    *(unsigned char *)(a2 + 94) = 1;
  }
  *(unsigned char *)(a2 + 95) = v6;
  uint64_t v7 = *(void *)(*((void *)a1 + 1) + 24);
  int v8 = (uint64_t *)(a2 + 80);
  v40[0].n128_u8[0] = v6;
  v40[0].n128_u8[1] = *(unsigned char *)(a3 + 153) & 1;
  v40[0].n128_u32[1] = *(_DWORD *)(a3 + 164);
  v40[0].n128_u8[8] = *(unsigned char *)(a3 + 155);
  v40[0].n128_u32[3] = *(_DWORD *)(a3 + 184);
  if (*(_DWORD *)(v7 + 444))
  {
    uint64_t v9 = v7 + 416;
LABEL_5:
LABEL_21:
    uint64_t v20 = *((void *)a1 + 1);
    uint64_t v21 = *(void *)(v20 + 16);
    if (*(void *)(v21 + 48))
    {
      uint64_t v22 = *v8;
      unint64_t v23 = 0xBF58476D1CE4E5B9 * (*v8 ^ ((unint64_t)*v8 >> 30));
      uint64_t v24 = *(unsigned int *)(*(void *)(v21 + 56)
                            + 4
                            * (((0x94D049BB133111EBLL * (v23 ^ (v23 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                               * (v23 ^ (v23 >> 27))) >> 31))
                             % *(unsigned int *)(v21 + 72)));
      if (v24 != 0x7FFFFFFF)
      {
        uint64_t v25 = *(void *)(v21 + 64);
        if (*(void *)(v25 + (v24 << 6) + 16) == v22)
        {
LABEL_26:
          __int32 v26 = (float32x4_t *)(v25 + (v24 << 6));
          __int32 v27 = (float32x4_t *)re::BucketArray<re::Matrix4x4<float>,128ul>::operator[](*(void *)(v20 + 8) + 56, *(unsigned int *)(a2 + 76));
          uint64_t v28 = 0;
          v29.n128_u32[0] = 0;
          v29.n128_u32[3] = 0;
          *(unint64_t *)((char *)v29.n128_u64 + 4) = v26[2].u32[1];
          v30.n128_u32[0] = v26[2].u32[0];
          v31.n128_u64[0] = 0;
          v31.n128_u64[1] = v26[2].u32[2];
          float32x4_t v32 = vnegq_f32(v26[3]);
          v32.i32[3] = 1.0;
          float32x4_t v33 = *v27;
          float32x4_t v34 = v27[1];
          float32x4_t v35 = v27[2];
          float32x4_t v36 = v27[3];
          v40[0] = v30;
          v40[1] = v29;
          void v40[2] = v31;
          v40[3] = (__n128)v32;
          do
          {
            v41[v28] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(*(_OWORD *)&v40[v28])), v34, (float32x2_t)v40[v28].n128_u64[0], 1), v35, (float32x4_t)v40[v28], 2), v36, (float32x4_t)v40[v28], 3);
            ++v28;
          }
          while (v28 != 4);
          float32x4_t v37 = (float32x4_t)v41[1];
          float32x4_t v38 = (float32x4_t)v41[2];
          float32x4_t v39 = (float32x4_t)v41[3];
          *__int32 v27 = (float32x4_t)v41[0];
          v27[1] = v37;
          id v27[2] = v38;
          v27[3] = v39;
        }
        else
        {
          while (1)
          {
            uint64_t v24 = *(_DWORD *)(v25 + (v24 << 6) + 8) & 0x7FFFFFFF;
            if (v24 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v25 + (v24 << 6) + 16) == v22) {
              goto LABEL_26;
            }
          }
        }
      }
    }
    return;
  }
  uint64_t v10 = v7 + 32;
  unint64_t v11 = *(void *)(v7 + 16);
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = *v8;
    while (*(void *)(v7 + v12 + 32) != v13)
    {
      v12 += 24;
      if (24 * v11 == v12)
      {
        if ((v11 & 0xFFFFFFF0) != 0)
        {
          uint64_t v9 = v7 + 416;
          if (*(void *)(v7 + 416)) {
            goto LABEL_15;
          }
          simd_float4 v14 = *(uint64_t **)v7;
          if (!*(void *)v7)
          {
          }
          re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(v7 + 416, (uint64_t)v14, 32);
          unint64_t v11 = *(void *)(v7 + 16);
          if (v11)
          {
LABEL_15:
            uint64_t v15 = v10 + 24 * v11;
            do
            {
              v10 += 24;
            }
            while (v10 != v15);
          }
          *(void *)(v7 + 16) = 0;
          ++*(_DWORD *)(v7 + 24);
          goto LABEL_5;
        }
        v41[0] = v40[0];
        if (v11 >= 0x10) {
          goto LABEL_31;
        }
        goto LABEL_20;
      }
    }
    goto LABEL_21;
  }
  uint64_t v13 = *v8;
  v41[0] = v40[0];
LABEL_20:
  uint64_t v16 = v10 + 24 * v11;
  *(void *)uint64_t v16 = v13;
  *(_OWORD *)(v16 + 8) = v41[0];
  uint64_t v17 = *(void *)(v7 + 16);
  ++*(_DWORD *)(v7 + 24);
  BOOL v18 = __CFADD__(v17, 1);
  uint64_t v19 = v17 + 1;
  *(void *)(v7 + 16) = v19;
  if (!v18) {
    goto LABEL_21;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 381, -1, v19);
  _os_crash();
  __break(1u);
LABEL_31:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
  _os_crash();
  __break(1u);
}

void *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_1,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E71A418;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_1,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E71A418;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_1,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::size()
{
  return 16;
}

void re::HashTable<unsigned long long,re::anonymous namespace'::SPlatterDrawInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::add(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)a1)
  {
    unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(a1 + 16);
      if (*(void *)(v11 + 32 * v10 + 8) == v6) {
        return;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v11 + 32 * v10) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + 32 * v10 + 8) == v6) {
          return;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  ++*(_DWORD *)(a1 + 40);
}

__n128 re::HashTable<unsigned long long,re::anonymous namespace'::SPlatterDrawInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, __n128 *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v8 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v29, 0, 36);
          *(void *)&v29[36] = 0x7FFFFFFFLL;
          re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v29, v13, v12);
          long long v15 = *(_OWORD *)v29;
          *(_OWORD *)__n128 v29 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v29[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v29[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v29[24];
          *(_OWORD *)&v29[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v29[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = (void *)(v17 + 8);
            do
            {
              if ((*(_DWORD *)(v21 - 1) & 0x80000000) != 0)
              {
                unint64_t v22 = 0xBF58476D1CE4E5B9 * (*v21 ^ (*v21 >> 30));
                unint64_t v23 = (0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) ^ ((0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) >> 31);
              }
              v21 += 4;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,re::RenderGraphTargetHandle,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit((uint64_t *)v29);
        }
      }
      else
      {
        if (v12) {
          signed int v26 = 2 * v11;
        }
        else {
          signed int v26 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 32 * v8);
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 32 * v8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  uint64_t v27 = 32 * v8;
  *(_DWORD *)(v24 + v27) = v25 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v27) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v8 + 8) = *a4;
  __n128 result = *a5;
  *(__n128 *)(*(void *)(a1 + 16) + 32 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void *re::DynamicInlineArray<re::DynamicInlineArray<re::PlaneF,6ul>,2ul>::copy(void *a1, uint64_t *a2)
{
  uint64_t v3 = a2 + 2;
  uint64_t v4 = *a2;
  unsigned int v5 = a1 + 2;
  if ((unint64_t)*a2 >= *a1)
  {
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul>*,0>(v3, &v3[14 * *a1], v5);
    if (*a1 != v4)
    {
      int v9 = &v3[14 * v4];
      uint64_t v10 = 14 * *a1;
      int v11 = &v3[v10];
      signed int v12 = &v5[v10];
      do
      {
        *signed int v12 = 0;
        *((_DWORD *)v12 + 2) = 0;
        uint64_t v13 = v11 + 2;
        uint64_t v14 = *v11;
        v11 += 14;
        __n128 result = memcpy(v12 + 2, v13, 16 * v14);
        *signed int v12 = v14;
        v12 += 14;
      }
      while (v11 != v9);
    }
  }
  else
  {
    __n128 result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul>*,0>(v3, &v3[14 * v4], v5);
    if (v4 != *a1)
    {
      unint64_t v7 = &v5[14 * *a1];
      uint64_t v8 = &v5[14 * v4];
      do
      {
        *uint64_t v8 = 0;
        ++*((_DWORD *)v8 + 2);
        v8 += 14;
      }
      while (v8 != v7);
    }
  }
  *a1 = v4;
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul> const*,re::DynamicInlineArray<re::PlaneF,6ul>*,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::DynamicInlineArray<re::Vector4<float>,2ul>::operator=(a3, v4);
      v4 += 14;
      a3 += 14;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void std::__introsort<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *,false>(unint64_t a1, float *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                float v33 = *(a2 - 4);
                float32x4_t v32 = a2 - 4;
                if (v33 > *(float *)v10)
                {
                  long long v87 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *(_OWORD *)v32;
                  *(_OWORD *)float32x4_t v32 = v87;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)v10, (float *)(v10 + 16), a2 - 4);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)v10, (float *)(v10 + 16), (float *)(v10 + 32), (unsigned __int32 *)a2 - 4);
                break;
              case 5uLL:
                float32x4_t v34 = (long long *)(v10 + 16);
                float32x4_t v35 = (long long *)(v10 + 32);
                float32x4_t v36 = (long long *)(v10 + 48);
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)v10, (float *)(v10 + 16), (float *)(v10 + 32), (unsigned __int32 *)(v10 + 48));
                float v38 = *(a2 - 4);
                float32x4_t v37 = a2 - 4;
                if (v38 > *(float *)(v10 + 48))
                {
                  long long v39 = *v36;
                  *float32x4_t v36 = *(_OWORD *)v37;
                  *(_OWORD *)float32x4_t v37 = v39;
                  if (*(float *)v36 > *(float *)v35)
                  {
                    long long v40 = *v35;
                    *float32x4_t v35 = *v36;
                    *float32x4_t v36 = v40;
                    if (*(float *)v35 > *(float *)v34)
                    {
                      long long v41 = *v34;
                      *float32x4_t v34 = *v35;
                      *float32x4_t v35 = v41;
                      if (*(float *)(v10 + 16) > *(float *)v10)
                      {
                        long long v88 = *(_OWORD *)v10;
                        *(_OWORD *)unint64_t v10 = *v34;
                        *float32x4_t v34 = v88;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v42 = (float *)(v10 + 16);
            BOOL v44 = (float *)v10 == a2 || v42 == a2;
            if (a4)
            {
              if (!v44)
              {
                uint64_t v45 = 0;
                unint64_t v46 = v10;
                do
                {
                  __int32 v47 = v42;
                  float v48 = *(float *)(v46 + 16);
                  if (v48 > *(float *)v46)
                  {
                    uint64_t v89 = *(void *)(v46 + 20);
                    int v93 = *(_DWORD *)(v46 + 28);
                    uint64_t v49 = v45;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v49 + 16) = *(_OWORD *)(v10 + v49);
                      if (!v49) {
                        break;
                      }
                      float v50 = *(float *)(v10 + v49 - 16);
                      v49 -= 16;
                      if (v48 <= v50)
                      {
                        uint64_t v51 = v10 + v49 + 16;
                        goto LABEL_80;
                      }
                    }
                    uint64_t v51 = v10;
LABEL_80:
                    *(float *)uint64_t v51 = v48;
                    *(_DWORD *)(v51 + 12) = v93;
                    *(void *)(v51 + 4) = v89;
                  }
                  uint64_t v42 = v47 + 4;
                  v45 += 16;
                  unint64_t v46 = (unint64_t)v47;
                }
                while (v47 + 4 != a2);
              }
            }
            else if (!v44)
            {
              do
              {
                unint64_t v74 = (unint64_t)v42;
                float v75 = *(float *)(a1 + 16);
                if (v75 > *(float *)a1)
                {
                  uint64_t v92 = *(void *)(a1 + 20);
                  int v95 = *(_DWORD *)(a1 + 28);
                  long long v76 = v42;
                  do
                  {
                    *(_OWORD *)long long v76 = *((_OWORD *)v76 - 1);
                    float v77 = *(v76 - 8);
                    v76 -= 4;
                  }
                  while (v75 > v77);
                  *long long v76 = v75;
                  *((_DWORD *)v76 + 3) = v95;
                  *(void *)(v76 + 1) = v92;
                }
                v42 += 4;
                a1 = v74;
              }
              while ((float *)(v74 + 16) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((float *)v10 != a2)
            {
              int64_t v52 = (v12 - 2) >> 1;
              int64_t v53 = v52;
              do
              {
                int64_t v54 = v53;
                if (v52 >= v53)
                {
                  uint64_t v55 = (2 * v53) | 1;
                  char v56 = (float *)(v10 + 16 * v55);
                  if (2 * v54 + 2 < (uint64_t)v12 && *v56 > v56[4])
                  {
                    v56 += 4;
                    uint64_t v55 = 2 * v54 + 2;
                  }
                  uint64_t v57 = (float *)(v10 + 16 * v54);
                  float v58 = *v57;
                  if (*v56 <= *v57)
                  {
                    int v94 = *((_DWORD *)v57 + 3);
                    uint64_t v90 = *(void *)(v57 + 1);
                    do
                    {
                      uint64_t v59 = v57;
                      uint64_t v57 = v56;
                      *(_OWORD *)uint64_t v59 = *(_OWORD *)v56;
                      if (v52 < v55) {
                        break;
                      }
                      uint64_t v60 = 2 * v55;
                      uint64_t v55 = (2 * v55) | 1;
                      char v56 = (float *)(v10 + 16 * v55);
                      uint64_t v61 = v60 + 2;
                      if (v61 < (uint64_t)v12 && *v56 > v56[4])
                      {
                        v56 += 4;
                        uint64_t v55 = v61;
                      }
                    }
                    while (*v56 <= v58);
                    *uint64_t v57 = v58;
                    *((_DWORD *)v57 + 3) = v94;
                    *(void *)(v57 + 1) = v90;
                  }
                }
                int64_t v53 = v54 - 1;
              }
              while (v54);
              uint64_t v62 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v63 = 0;
                long long v91 = *(_OWORD *)v10;
                uint64_t v64 = (float *)v10;
                do
                {
                  long long v65 = v64;
                  v64 += 4 * v63 + 4;
                  uint64_t v66 = 2 * v63;
                  uint64_t v63 = (2 * v63) | 1;
                  uint64_t v67 = v66 + 2;
                  if (v67 < v62 && *v64 > v64[4])
                  {
                    v64 += 4;
                    uint64_t v63 = v67;
                  }
                  *(_OWORD *)long long v65 = *(_OWORD *)v64;
                }
                while (v63 <= (uint64_t)((unint64_t)(v62 - 2) >> 1));
                a2 -= 4;
                if (v64 == a2)
                {
                  *(_OWORD *)uint64_t v64 = v91;
                }
                else
                {
                  *(_OWORD *)uint64_t v64 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v91;
                  uint64_t v68 = (uint64_t)v64 - v10 + 16;
                  if (v68 >= 17)
                  {
                    unint64_t v69 = (((unint64_t)v68 >> 4) - 2) >> 1;
                    long long v70 = (float *)(v10 + 16 * v69);
                    float v71 = *v64;
                    if (*v70 > *v64)
                    {
                      int v83 = *((_DWORD *)v64 + 3);
                      uint64_t v80 = *(void *)(v64 + 1);
                      do
                      {
                        long long v72 = v64;
                        uint64_t v64 = v70;
                        *(_OWORD *)long long v72 = *(_OWORD *)v70;
                        if (!v69) {
                          break;
                        }
                        unint64_t v69 = (v69 - 1) >> 1;
                        long long v70 = (float *)(v10 + 16 * v69);
                      }
                      while (*v70 > v71);
                      *uint64_t v64 = v71;
                      *((_DWORD *)v64 + 3) = v83;
                      *(void *)(v64 + 1) = v80;
                    }
                  }
                }
              }
              while (v62-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (float *)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)a1, (float *)(a1 + 16 * (v12 >> 1)), a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)(a1 + 16), v14 - 4, a2 - 8);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)(a1 + 32), (float *)(a1 + 16 + 16 * v13), a2 - 12);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(v14 - 4, v14, (float *)(a1 + 16 + 16 * v13));
            long long v84 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v84;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)(a1 + 16 * (v12 >> 1)), (float *)a1, a2 - 4);
          }
          --a3;
          float v15 = *(float *)a1;
          if ((a4 & 1) != 0 || *(float *)(a1 - 16) > v15) {
            break;
          }
          int v82 = *(_DWORD *)(a1 + 12);
          uint64_t v79 = *(void *)(a1 + 4);
          if (v15 <= *(a2 - 4))
          {
            unint64_t v27 = a1 + 16;
            do
            {
              unint64_t v10 = v27;
              if (v27 >= (unint64_t)a2) {
                break;
              }
              v27 += 16;
            }
            while (v15 <= *(float *)v10);
          }
          else
          {
            unint64_t v10 = a1;
            do
            {
              float v26 = *(float *)(v10 + 16);
              v10 += 16;
            }
            while (v15 <= v26);
          }
          uint64_t v28 = a2;
          if (v10 < (unint64_t)a2)
          {
            uint64_t v28 = a2;
            do
            {
              float v29 = *(v28 - 4);
              v28 -= 4;
            }
            while (v15 > v29);
          }
          while (v10 < (unint64_t)v28)
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v28;
            *(_OWORD *)uint64_t v28 = v86;
            do
            {
              float v30 = *(float *)(v10 + 16);
              v10 += 16;
            }
            while (v15 <= v30);
            do
            {
              float v31 = *(v28 - 4);
              v28 -= 4;
            }
            while (v15 > v31);
          }
          BOOL v4 = v10 - 16 >= a1;
          BOOL v5 = v10 - 16 == a1;
          if (v10 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(float *)(v10 - 16) = v15;
          *(_DWORD *)(v10 - 4) = v82;
          *(void *)(v10 - 12) = v79;
        }
        uint64_t v16 = 0;
        int v81 = *(_DWORD *)(a1 + 12);
        uint64_t v78 = *(void *)(a1 + 4);
        do
        {
          float v17 = *(float *)(a1 + v16 + 16);
          v16 += 16;
        }
        while (v17 > v15);
        unint64_t v18 = a1 + v16;
        long long v19 = a2;
        if (v16 == 16)
        {
          long long v19 = a2;
          do
          {
            if (v18 >= (unint64_t)v19) {
              break;
            }
            float v21 = *(v19 - 4);
            v19 -= 4;
          }
          while (v21 <= v15);
        }
        else
        {
          do
          {
            float v20 = *(v19 - 4);
            v19 -= 4;
          }
          while (v20 <= v15);
        }
        unint64_t v10 = a1 + v16;
        if (v18 < (unint64_t)v19)
        {
          unint64_t v22 = v19;
          do
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v22;
            *(_OWORD *)unint64_t v22 = v85;
            do
            {
              float v23 = *(float *)(v10 + 16);
              v10 += 16;
            }
            while (v23 > v15);
            do
            {
              float v24 = *(v22 - 4);
              v22 -= 4;
            }
            while (v24 <= v15);
          }
          while (v10 < (unint64_t)v22);
        }
        if (v10 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
        }
        *(float *)(v10 - 16) = v15;
        *(_DWORD *)(v10 - 4) = v81;
        *(void *)(v10 - 12) = v78;
        if (v18 >= (unint64_t)v19) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v25 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v25) {
        goto LABEL_30;
      }
    }
    a2 = (float *)(v10 - 16);
    if (!v25) {
      continue;
    }
    break;
  }
}

float *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(float *result, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a3;
  if (*a2 <= *result)
  {
    if (v4 > v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (*a2 > *result)
      {
        long long v7 = *(_OWORD *)result;
        *(_OWORD *)__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 <= v3)
    {
      long long v8 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*a3 <= *a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (_OWORD *)(a2 - 16);
      if (*(float *)(a2 - 16) > *(float *)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)a1, (float *)(a1 + 16), (float *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), (unsigned __int32 *)(a2 - 16));
      return 1;
    case 5:
      uint64_t v16 = (long long *)(a1 + 16);
      float v17 = (long long *)(a1 + 32);
      unint64_t v18 = (long long *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), (unsigned __int32 *)(a1 + 48));
      float v20 = *(float *)(a2 - 16);
      long long v19 = (long long *)(a2 - 16);
      if (v20 > *(float *)(a1 + 48))
      {
        long long v21 = *v18;
        long long *v18 = *v19;
        *long long v19 = v21;
        if (*(float *)v18 > *(float *)v17)
        {
          long long v22 = *v17;
          *float v17 = *v18;
          long long *v18 = v22;
          if (*(float *)v17 > *(float *)v16)
          {
            long long v23 = *v16;
            long long *v16 = *v17;
            *float v17 = v23;
            if (*(float *)(a1 + 16) > *(float *)a1)
            {
              long long v24 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v16;
              long long *v16 = v24;
            }
          }
        }
      }
      return 1;
    default:
      long long v8 = (float *)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32));
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    float v12 = *(float *)v9;
    if (*(float *)v9 > *v8)
    {
      uint64_t v25 = *(void *)(v9 + 4);
      int v26 = *(_DWORD *)(v9 + 12);
      uint64_t v13 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v13 + 48) = *(_OWORD *)(a1 + v13 + 32);
        if (v13 == -32) {
          break;
        }
        float v14 = *(float *)(a1 + v13 + 16);
        v13 -= 16;
        if (v12 <= v14)
        {
          uint64_t v15 = a1 + v13 + 48;
          goto LABEL_12;
        }
      }
      uint64_t v15 = a1;
LABEL_12:
      *(float *)uint64_t v15 = v12;
      *(void *)(v15 + 4) = v25;
      *(_DWORD *)(v15 + 12) = v26;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    long long v8 = (float *)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(float *a1, float *a2, float *a3, unsigned __int32 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_7 &,re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::StencilPortalSortInfo *>(a1, a2, a3);
  result.n128_u32[0] = *a4;
  if (*(float *)a4 > *a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_f32[0] = *a3;
    if (*a3 > *a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_f32[0] = *a2;
      if (*a2 > *a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_3,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::~Callable()
{
}

void *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_3,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator()(void *result, uint64_t a2, float32x4_t *a3)
{
  float v3 = (_OWORD *)a3[2].i64[0];
  if (v3)
  {
    long long v4 = v3[1];
    v24[0] = *v3;
    v24[1] = v4;
    uint64_t v5 = result[1];
    uint64_t v6 = *(void *)(v5 + 24);
    if (v6)
    {
      long long v7 = *(float32x4_t **)(v5 + 40);
      float v20 = &v7[7 * v6];
      long long v8 = &a3[9].i8[8];
      uint64_t v9 = a3 + 8;
      int v21 = a3[11].i32[2];
      unsigned __int8 v22 = -1;
      do
      {
        uint64_t v10 = result;
        if (v11)
        {
          float v12 = (float *)v11;
          if (a3[9].i8[9])
          {
            __n128 result = v10;
            if (*((unsigned char *)v12 + 1) && a3[10].f32[1] == v12[1])
            {
              if (a3[9].u8[11] == *((unsigned __int8 *)v12 + 8)) {
                uint64_t v13 = v7->i64[1];
              }
              else {
                uint64_t v13 = 0;
              }
            }
            else
            {
              uint64_t v13 = 0;
            }
          }
          else
          {
            uint64_t v13 = 0;
            __n128 result = v10;
          }
          if (*(unsigned char *)(a2 + 3) == 2) {
            int v14 = *(_DWORD *)(a2 + 32);
          }
          else {
            int v14 = 1;
          }
          if (v14 >= 1)
          {
            for (int i = 0; i != v14; ++i)
            {
              uint64_t v16 = (float32x4_t *)re::BucketArray<re::Matrix4x4<float>,128ul>::operator[](result[2] + 56, (i + *(_DWORD *)(a2 + 76)));
              if (re::isBoundingBoxInsideVCAPlanes((uint64_t)v24, v16, v13, v21, v8, v9, v7 + 6, v17, v7 + 2, 4, v7->i64[1], v7[1].i32[0]))
              {
                unsigned int v18 = *(unsigned __int8 *)v12;
                if (v22 < v18) {
                  LOBYTE(v18) = v22;
                }
                unsigned __int8 v22 = v18;
              }
              __n128 result = v10;
            }
          }
        }
        else
        {
          __n128 result = v10;
        }
        v7 += 7;
      }
      while (v7 != v20);
    }
    else
    {
      unsigned __int8 v22 = -1;
    }
    if (!*(unsigned char *)(a2 + 94)) {
      *(unsigned char *)(a2 + 94) = 1;
    }
    *(unsigned char *)(a2 + 95) = v22 - 1;
  }
  return result;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_3,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A480;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_3,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A480;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_3,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::size()
{
  return 32;
}

void re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_4,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::~Callable()
{
}

unsigned __int8 *re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_4,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::operator()(unsigned __int8 *result, uint64_t a2, float32x4_t *a3, unsigned __int8 *a4)
{
  long long v4 = (_OWORD *)a3[2].i64[0];
  if (v4)
  {
    uint64_t v6 = a2;
    long long v7 = result;
    if (result[32] != *a4
    {
      uint64_t v28 = v6;
      long long v9 = v4[1];
      v29[0] = *v4;
      v29[1] = v9;
      uint64_t v10 = *((void *)v7 + 1);
      uint64_t v11 = *(void *)(v10 + 24);
      if (v11)
      {
        float v12 = *(float32x4_t **)(v10 + 40);
        long long v24 = a3;
        uint64_t v25 = &v12[7 * v11];
        uint64_t v13 = &a3[9].i8[8];
        int v14 = a3 + 8;
        int v26 = a3[11].i32[2];
        unsigned __int8 v27 = -1;
        uint64_t v15 = v7;
        do
        {
          if (result)
          {
            if (v24[9].i8[9])
            {
              uint64_t v17 = v28;
              if (result[1] && v24[10].f32[1] == *((float *)result + 1)) {
                uint64_t v16 = v24[9].u8[11] == result[8] ? v12->i64[1] : 0;
              }
              else {
                uint64_t v16 = 0;
              }
            }
            else
            {
              uint64_t v16 = 0;
              uint64_t v17 = v28;
            }
            int v18 = *(unsigned char *)(v17 + 3) == 2 ? *(_DWORD *)(v17 + 32) : 1;
            if (v18 >= 1)
            {
              long long v19 = result;
              for (int i = 0; i != v18; ++i)
              {
                int v21 = (float32x4_t *)re::BucketArray<re::Matrix4x4<float>,128ul>::operator[](*((void *)v15 + 3) + 56, (i + *(_DWORD *)(v28 + 76)));
                __n128 result = (unsigned __int8 *)re::isBoundingBoxInsideVCAPlanes((uint64_t)v29, v21, v16, v26, v13, v14, v12 + 6, v22, v12 + 2, 4, v12->i64[1], v12[1].i32[0]);
                if (result)
                {
                  unsigned int v23 = *v19;
                  if (v27 < v23) {
                    LOBYTE(v23) = v27;
                  }
                  unsigned __int8 v27 = v23;
                }
              }
            }
          }
          v12 += 7;
          long long v7 = v15;
        }
        while (v12 != v25);
      }
      else
      {
        unsigned __int8 v27 = -1;
      }
      LOBYTE(v8) = v27 - 1;
      uint64_t v6 = v28;
    }
    if (!*(unsigned char *)(v6 + 94)) {
      *(unsigned char *)(v6 + 94) = 1;
    }
    *(unsigned char *)(v6 + 95) = v8;
  }
  return result;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_4,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A4D8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_4,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71A4D8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellStencilBlurMeshNode::executeWithRenderForBlurBitSet(re::RenderGraphContext &)::$_4,void ()(re::DrawCall &,re::MeshPartDrawContext const&,unsigned char)>::size()
{
  return 40;
}

uint64_t re::RenderGraphDataStore::tryGet<re::TonemapParametersData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re21TonemapParametersDataE";
  if (((unint64_t)"N2re21TonemapParametersDataE" & 0x8000000000000000) != 0)
  {
    float v3 = (unsigned __int8 *)((unint64_t)"N2re21TonemapParametersDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 64, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void *re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E71A530;
  unint64_t v2 = (void *)a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E71A530;
  unint64_t v2 = (void *)a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void *re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::operator()(uint64_t a1, simd_float4 *a2, simd_float4 *a3)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v6 = memcpy(__dst, (char *)objc_msgSend(*(id *)(a1 + 16), sel_contents) + *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
  uint64_t v14 = 0;
  char v15 = 1;
  do
  {
    int v16 = v15 & 1;
    if (v15) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = a3;
    }
    simd_float4 v18 = v17[1];
    simd_float4 v34 = v18;
    simd_float4 v35 = *v17;
    simd_float4 v19 = v17[3];
    simd_float4 v32 = v19;
    simd_float4 v33 = v17[2];
    float v20 = (float32x4_t *)(a1 + (v14 << 6));
    WarpMatrixForSourceProjectiounint64_t n = re::createWarpMatrixForSourceProjection(v20[10], v20[11], v20[12], v20[13], v35, v18, v33, v19, (uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, v20[10], v20[11], v20[12],
                                      v20[13],
                                      *(simd_float4 *)(a1 + 32 + (v14 << 6)),
                                      *(simd_float4 *)(a1 + 32 + (v14 << 6) + 16),
                                      *(simd_float4 *)(a1 + 32 + (v14 << 6) + 32),
                                      *(simd_float4 *)(a1 + 32 + (v14 << 6) + 48));
    char v15 = 0;
    uint64_t v22 = &__dst[12 * v14];
    *((_DWORD *)v22 + 10) = v23;
    *((double *)v22 + 4) = WarpMatrixForSourceProjection;
    *((_DWORD *)v22 + 14) = v24;
    *((void *)v22 + 6) = v25;
    *((_DWORD *)v22 + 18) = v26;
    *((void *)v22 + 8) = v27;
    uint64_t v28 = *(void *)(a1 + 304);
    uint64_t v29 = *(void *)(a1 + 288);
    float v30 = (simd_float4 *)(v28 + (v14 << 6));
    *float v30 = v35;
    v30[1] = v34;
    uint64_t v30[2] = v33;
    v30[3] = v32;
    *(void *)(v28 + 128) = v29;
    uint64_t v14 = 1;
  }
  while (v16);
  return memcpy((char *)objc_msgSend(*(id *)(a1 + 16), sel_contents) + *(unsigned int *)(a1 + 24), __dst, *(unsigned int *)(a1 + 28));
}

void *re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E71A530;
  a2[2] = *(id *)(a1 + 16);
  a2[3] = *(void *)(a1 + 24);
  memcpy(a2 + 4, (const void *)(a1 + 32), 0x118uLL);
  return a2;
}

void *re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E71A530;
  a2[2] = *(id *)(a1 + 16);
  a2[3] = *(void *)(a1 + 24);
  memcpy(a2 + 4, (const void *)(a1 + 32), 0x118uLL);
  return a2;
}

uint64_t re::internal::Callable<re::SFBSystemShellReprojectAndRectifyNode::setupEncoder(re::RenderGraphContext &,re::mtl::ComputeCommandEncoder)::$_0,void ()(re::Matrix4x4<float> const&,re::Matrix4x4<float> const&)>::size()
{
  return 320;
}

__n128 re::DynamicArray<re::TargetRead>::add(_anonymous_namespace_ *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::TargetRead>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unsigned int v5 = (__n128 *)(*((void *)this + 4) + 32 * v4);
  v5->n128_u64[0] = 0;
  v5->n128_u64[1] = -1;
  v5->n128_u64[0] = a2->n128_u64[0];
  v5->n128_u64[1] = a2->n128_u64[1];
  __n128 result = a2[1];
  v5[1] = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::DynamicArray<re::TargetWrite>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::TargetWrite>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + (v4 << 6);
  *(void *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = -1;
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)(v5 + 8) = *(void *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 48) = v7;
  *(__n128 *)(v5 + 16) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::RenderGraphNode::configure(re::RenderGraphNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v5 = 0x9E3779B97F4A7C17;
  long long v7 = (const char *)*((void *)this + 3);
  uint64_t v6 = (const char *)*((void *)this + 4);
  size_t v8 = strlen(v7);
  if (v8)
  {
    MurmurHash3_x64_128((uint64_t)v7, v8, 0, &v12);
    unint64_t v9 = (v13 - 0x61C8864680B583E9 + (v12 << 6) + (v12 >> 2)) ^ v12;
  }
  else
  {
    unint64_t v9 = 0;
  }
  size_t v10 = strlen(v6);
  if (v10)
  {
    MurmurHash3_x64_128((uint64_t)v6, v10, 0, &v12);
    unint64_t v5 = ((v13 - 0x61C8864680B583E9 + (v12 << 6) + (v12 >> 2)) ^ v12) - 0x61C8864680B583E9;
  }
  *((void *)this + 6) = ((v9 >> 2) + (v9 << 6) + v5) ^ v9;
  uint64_t v11 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
}

void re::RenderGraphNode::setup(re::RenderGraphNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v5 = *((void *)this + 14);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 16);
    uint64_t v7 = v6 + 32 * v5;
    do
    {
      re::RenderGraphBuilder::read((uint64_t)a2, v6, v6 + 16);
      v6 += 32;
    }
    while (v6 != v7);
  }
  uint64_t v8 = *((void *)this + 19);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 21);
    uint64_t v10 = v9 + (v8 << 6);
    do
    {
      re::RenderGraphBuilder::write(a2, v9, v9 + 16);
      v9 += 64;
    }
    while (v9 != v10);
  }
  uint64_t v11 = *((void *)this + 24);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 26);
    uint64_t v13 = v12 + 32 * v11;
    do
    {
      re::RenderGraphBuilder::read((uint64_t)a2, v12, v12 + 16);
      v12 += 32;
    }
    while (v12 != v13);
  }
  uint64_t v14 = *((void *)this + 29);
  if (v14)
  {
    uint64_t v15 = *((void *)this + 31);
    uint64_t v16 = v15 + (v14 << 6);
    do
    {
      re::RenderGraphBuilder::write((uint64_t)a2, v15, v15 + 16);
      v15 += 64;
    }
    while (v15 != v16);
  }
  *((void *)a2 + 75) = *((void *)this + 9);
  if (*((unsigned char *)this + 80)) {
    *((unsigned char *)a2 + 608) = *((unsigned char *)this + 80);
  }
}

void *re::RenderGraphNode::patch(void *this, re::RenderGraphContext *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (this[5])
  {
    uint64_t v2 = (uint64_t)this;
    uint64_t v3 = *((void *)a2 + 146);
    unint64_t v4 = (unint64_t)"N2re28RenderGraphNodeExecutionDataE";
    if (((unint64_t)"N2re28RenderGraphNodeExecutionDataE" & 0x8000000000000000) != 0)
    {
      uint64_t v5 = (unsigned __int8 *)((unint64_t)"N2re28RenderGraphNodeExecutionDataE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        unint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    unint64_t v20 = (((this[7] + (this[6] << 6) + (this[6] >> 2) - 0x61C8864680B583E9) ^ this[6])
         - 0x61C8864680B583E9
         + (v4 << 6)
         + (v4 >> 2)) ^ v4;
    this = (void *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v3 + 16, (uint64_t *)&v20);
    if (this && *this)
    {
      uint64_t v8 = *this + 8;
      size_t v9 = strlen(*(const char **)(v2 + 16));
      if (v9)
      {
        MurmurHash3_x64_128(*(void *)(v2 + 16), v9, 0, &v20);
        unint64_t v10 = (v21 - 0x61C8864680B583E9 + (v20 << 6) + (v20 >> 2)) ^ v20;
      }
      else
      {
        unint64_t v10 = 0;
      }
      unint64_t v20 = v10;
      this = (void *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v8, (uint64_t *)&v20);
      if (this)
      {
        uint64_t v11 = this[2];
        if (v11)
        {
          uint64_t v12 = (uint64_t *)this[4];
          uint64_t v13 = &v12[7 * v11];
          do
          {
            re::FixedArray<unsigned char>::FixedArray(&v20, v12);
            uint64_t v14 = re::FixedArray<unsigned int>::FixedArray(&v23, (uint64_t)(v12 + 3));
            int v26 = (const re::IntrospectionBase *)v12[6];
            uint64_t v17 = v26;
            simd_float4 v18 = (const re::IntrospectionBase **)v2;
            BOOL v15 = re::scanForCopy((uint64_t)v14, (uint64_t *)&v18, &v17);
            if (v15)
            {
              uint64_t v16 = v22;
              v19[1] = 0;
              uint64_t v19[2] = 0;
            }
            if (v23)
            {
              if (v24)
              {
                (*(void (**)(void))(*(void *)v23 + 40))();
                uint64_t v24 = 0;
                uint64_t v25 = 0;
              }
              uint64_t v23 = 0;
            }
            this = (void *)v20;
            if (v20)
            {
              if (v21) {
                this = (void *)(*(uint64_t (**)(void))(*(void *)v20 + 40))();
              }
            }
            v12 += 7;
          }
          while (v12 != v13);
        }
      }
    }
  }
  return this;
}

void *re::allocInfo_RenderGraphNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AAD0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9ACD8, "RenderGraphNode");
    __cxa_guard_release(&qword_26AF9AAD0);
  }
  return &unk_26AF9ACD8;
}

void re::initInfo_RenderGraphNode(re *this, re::IntrospectionBase *a2)
{
  unint64_t v72 = 0xA3C1F00635C716B4;
  uint64_t v73 = "RenderGraphNode";
  re::StringID::destroyString((re::StringID *)&v72);
  *((_OWORD *)this + 2) = v67;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAC8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AAC8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNodeBase((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNodeBase";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9AB98 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      unint64_t v10 = re::IntrospectionInfo<re::StringID>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "name";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9ABA0 = v11;
      uint64_t v12 = (re *)re::introspectionAllocator((re *)v11);
      uint64_t v13 = v12;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB38, memory_order_acquire) & 1) == 0)
      {
        uint64_t v12 = (re *)__cxa_guard_acquire(&qword_26AF9AB38);
        if (v12)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF9ABD8);
          qword_26AF9ABD8 = (uint64_t)&unk_26E71A670;
          __cxa_guard_release(&qword_26AF9AB38);
        }
      }
      if ((_MergedGlobals_444 & 1) == 0)
      {
        uint64_t v14 = (void *)qword_26AF9AAE8;
        if (qword_26AF9AAE8
          || (uint64_t v14 = re::allocInfo_TargetRead(v12),
              qword_26AF9AAE8 = (uint64_t)v14,
              re::initInfo_TargetRead((re *)v14, v15),
              (_MergedGlobals_444 & 1) == 0))
        {
          _MergedGlobals_444 = 1;
          int v16 = *((_DWORD *)v14 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF9ABD8, 0);
          qword_26AF9ABE8 = 0x2800000003;
          dword_26AF9ABF0 = v16;
          word_26AF9ABF4 = 0;
          *(void *)&xmmword_26AF9ABF8 = 0;
          *((void *)&xmmword_26AF9ABF8 + 1) = 0xFFFFFFFFLL;
          qword_26AF9AC08 = (uint64_t)v14;
          unk_26AF9AC10 = 0;
          qword_26AF9ABD8 = (uint64_t)&unk_26E71A670;
          re::IntrospectionRegistry::add(v17, v18);
          re::getPrettyTypeName((re *)&qword_26AF9ABD8, (const re::IntrospectionBase *)&v72);
          if (v73) {
            simd_float4 v19 = v74;
          }
          else {
            simd_float4 v19 = (char *)&v73 + 1;
          }
          if (v72 && (v73 & 1) != 0) {
            (*(void (**)(void))(*(void *)v72 + 40))();
          }
          long long v69 = *((_OWORD *)v14 + 2);
          unint64_t v20 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v70);
          if (v20)
          {
            uint64_t v21 = *v20;
            *((void *)&v68 + 1) = v21;
          }
          else
          {
            long long v71 = v69;
            re::TypeBuilder::beginListType((uint64_t)&v72, v70, 1, 0x28uLL, 8uLL, &v71);
            re::TypeBuilder::setConstructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v72, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v72, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v72, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v72, v22);
          }
          xmmword_26AF9ABF8 = v68;
          re::StringID::destroyString((re::StringID *)v70);
        }
      }
      uint64_t v23 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "TargetReads";
      *(void *)(v23 + 16) = &qword_26AF9ABD8;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0xB000000002;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF9ABA8 = v23;
      uint64_t v24 = (re *)re::introspectionAllocator((re *)v23);
      uint64_t v25 = v24;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB40, memory_order_acquire) & 1) == 0)
      {
        uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF9AB40);
        if (v24)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF9AC18);
          qword_26AF9AC18 = (uint64_t)&unk_26E71A708;
          __cxa_guard_release(&qword_26AF9AB40);
        }
      }
      if ((byte_26AF9AAC1 & 1) == 0)
      {
        int v26 = (void *)qword_26AF9AB00;
        if (qword_26AF9AB00
          || (int v26 = re::allocInfo_TargetWrite(v24),
              qword_26AF9AB00 = (uint64_t)v26,
              re::initInfo_TargetWrite((re *)v26, v27),
              (byte_26AF9AAC1 & 1) == 0))
        {
          byte_26AF9AAC1 = 1;
          int v28 = *((_DWORD *)v26 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF9AC18, 0);
          qword_26AF9AC28 = 0x2800000003;
          dword_26AF9AC30 = v28;
          word_26AF9AC34 = 0;
          *(void *)&xmmword_26AF9AC38 = 0;
          *((void *)&xmmword_26AF9AC38 + 1) = 0xFFFFFFFFLL;
          qword_26AF9AC48 = (uint64_t)v26;
          unk_26AF9AC50 = 0;
          qword_26AF9AC18 = (uint64_t)&unk_26E71A708;
          re::IntrospectionRegistry::add(v29, v30);
          re::getPrettyTypeName((re *)&qword_26AF9AC18, (const re::IntrospectionBase *)&v72);
          if (v73) {
            float v31 = v74;
          }
          else {
            float v31 = (char *)&v73 + 1;
          }
          if (v72 && (v73 & 1) != 0) {
            (*(void (**)(void))(*(void *)v72 + 40))();
          }
          long long v69 = *((_OWORD *)v26 + 2);
          simd_float4 v32 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v70);
          if (v32)
          {
            uint64_t v33 = *v32;
            *((void *)&v68 + 1) = v33;
          }
          else
          {
            long long v71 = v69;
            re::TypeBuilder::beginListType((uint64_t)&v72, v70, 1, 0x28uLL, 8uLL, &v71);
            re::TypeBuilder::setConstructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v72, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v72, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v72, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v72, v34);
          }
          xmmword_26AF9AC38 = v68;
          re::StringID::destroyString((re::StringID *)v70);
        }
      }
      uint64_t v35 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v35 = 1;
      *(void *)(v35 + 8) = "TargetWrites";
      *(void *)(v35 + 16) = &qword_26AF9AC18;
      *(void *)(v35 + 24) = 0;
      *(void *)(v35 + 32) = 0xD800000003;
      *(_DWORD *)(v35 + 40) = 0;
      *(void *)(v35 + 48) = 0;
      *(void *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_26AF9ABB0 = v35;
      float32x4_t v36 = (re *)re::introspectionAllocator((re *)v35);
      uint64_t v37 = v36;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB48, memory_order_acquire) & 1) == 0)
      {
        float32x4_t v36 = (re *)__cxa_guard_acquire(&qword_26AF9AB48);
        if (v36)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF9AC58);
          qword_26AF9AC58 = (uint64_t)&unk_26E71A7A0;
          __cxa_guard_release(&qword_26AF9AB48);
        }
      }
      if ((byte_26AF9AAC2 & 1) == 0)
      {
        float v38 = (void *)qword_26AF9AB18;
        if (qword_26AF9AB18
          || (float v38 = re::allocInfo_BufferRead(v36),
              qword_26AF9AB18 = (uint64_t)v38,
              re::initInfo_BufferRead((re *)v38, v39),
              (byte_26AF9AAC2 & 1) == 0))
        {
          byte_26AF9AAC2 = 1;
          int v40 = *((_DWORD *)v38 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF9AC58, 0);
          qword_26AF9AC68 = 0x2800000003;
          dword_26AF9AC70 = v40;
          word_26AF9AC74 = 0;
          *(void *)&xmmword_26AF9AC78 = 0;
          *((void *)&xmmword_26AF9AC78 + 1) = 0xFFFFFFFFLL;
          qword_26AF9AC88 = (uint64_t)v38;
          unk_26AF9AC90 = 0;
          qword_26AF9AC58 = (uint64_t)&unk_26E71A7A0;
          re::IntrospectionRegistry::add(v41, v42);
          re::getPrettyTypeName((re *)&qword_26AF9AC58, (const re::IntrospectionBase *)&v72);
          if (v73) {
            __int32 v43 = v74;
          }
          else {
            __int32 v43 = (char *)&v73 + 1;
          }
          if (v72 && (v73 & 1) != 0) {
            (*(void (**)(void))(*(void *)v72 + 40))();
          }
          long long v69 = *((_OWORD *)v38 + 2);
          BOOL v44 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v70);
          if (v44)
          {
            uint64_t v45 = *v44;
            *((void *)&v68 + 1) = v45;
          }
          else
          {
            long long v71 = v69;
            re::TypeBuilder::beginListType((uint64_t)&v72, v70, 1, 0x28uLL, 8uLL, &v71);
            re::TypeBuilder::setConstructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v72, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v72, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v72, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v72, v46);
          }
          xmmword_26AF9AC78 = v68;
          re::StringID::destroyString((re::StringID *)v70);
        }
      }
      uint64_t v47 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, 72, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = "BufferReads";
      *(void *)(v47 + 16) = &qword_26AF9AC58;
      *(void *)(v47 + 24) = 0;
      *(void *)(v47 + 32) = 0x6000000004;
      *(_DWORD *)(v47 + 40) = 0;
      *(void *)(v47 + 48) = 0;
      *(void *)(v47 + 56) = 0;
      *(_DWORD *)(v47 + 64) = 0;
      qword_26AF9ABB8 = v47;
      float v48 = (re *)re::introspectionAllocator((re *)v47);
      uint64_t v49 = v48;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB50, memory_order_acquire) & 1) == 0)
      {
        float v48 = (re *)__cxa_guard_acquire(&qword_26AF9AB50);
        if (v48)
        {
          re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF9AC98);
          qword_26AF9AC98 = (uint64_t)&unk_26E71A838;
          __cxa_guard_release(&qword_26AF9AB50);
        }
      }
      if ((byte_26AF9AAC3 & 1) == 0)
      {
        float v50 = (void *)qword_26AF9AB30;
        if (qword_26AF9AB30
          || (float v50 = re::allocInfo_BufferWrite(v48),
              qword_26AF9AB30 = (uint64_t)v50,
              re::initInfo_BufferWrite((re *)v50, v51),
              (byte_26AF9AAC3 & 1) == 0))
        {
          byte_26AF9AAC3 = 1;
          int v52 = *((_DWORD *)v50 + 6);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF9AC98, 0);
          qword_26AF9ACA8 = 0x2800000003;
          dword_26AF9ACB0 = v52;
          word_26AF9ACB4 = 0;
          *(void *)&xmmword_26AF9ACB8 = 0;
          *((void *)&xmmword_26AF9ACB8 + 1) = 0xFFFFFFFFLL;
          qword_26AF9ACC8 = (uint64_t)v50;
          qword_26AF9ACD0 = 0;
          qword_26AF9AC98 = (uint64_t)&unk_26E71A838;
          re::IntrospectionRegistry::add(v53, v54);
          re::getPrettyTypeName((re *)&qword_26AF9AC98, (const re::IntrospectionBase *)&v72);
          if (v73) {
            uint64_t v55 = v74;
          }
          else {
            uint64_t v55 = (char *)&v73 + 1;
          }
          if (v72 && (v73 & 1) != 0) {
            (*(void (**)(void))(*(void *)v72 + 40))();
          }
          long long v69 = *((_OWORD *)v50 + 2);
          char v56 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v70);
          if (v56)
          {
            uint64_t v57 = *v56;
            *((void *)&v68 + 1) = v57;
          }
          else
          {
            long long v71 = v69;
            re::TypeBuilder::beginListType((uint64_t)&v72, v70, 1, 0x28uLL, 8uLL, &v71);
            re::TypeBuilder::setConstructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
            re::TypeBuilder::setDestructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
            re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v72, 1);
            re::TypeBuilder::setListAccessors((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIndexer((uint64_t)&v72, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
            re::TypeBuilder::setListIterator((uint64_t)&v72, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
            re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v72, v58);
          }
          xmmword_26AF9ACB8 = v68;
          re::StringID::destroyString((re::StringID *)v70);
        }
      }
      uint64_t v59 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v49 + 32))(v49, 72, 8);
      *(_DWORD *)uint64_t v59 = 1;
      *(void *)(v59 + 8) = "BufferWrites";
      *(void *)(v59 + 16) = &qword_26AF9AC98;
      *(void *)(v59 + 24) = 0;
      *(void *)(v59 + 32) = 0x8800000005;
      *(_DWORD *)(v59 + 40) = 0;
      *(void *)(v59 + 48) = 0;
      *(void *)(v59 + 56) = 0;
      *(_DWORD *)(v59 + 64) = 0;
      qword_26AF9ABC0 = v59;
      uint64_t v60 = re::introspectionAllocator((re *)v59);
      uint64_t v62 = re::introspect_size_t((re *)1, v61);
      uint64_t v63 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 72, 8);
      *(_DWORD *)uint64_t v63 = 1;
      *(void *)(v63 + 8) = "ThreadgroupMemoryLength";
      *(void *)(v63 + 16) = v62;
      *(void *)(v63 + 24) = 0;
      *(void *)(v63 + 32) = 0x4800000006;
      *(_DWORD *)(v63 + 40) = 0;
      *(void *)(v63 + 48) = 0;
      *(void *)(v63 + 56) = 0;
      *(_DWORD *)(v63 + 64) = 0;
      qword_26AF9ABC8 = v63;
      uint64_t v64 = re::introspectionAllocator((re *)v63);
      uint64_t v65 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 16, 8);
      *(_DWORD *)uint64_t v65 = 2;
      *(void *)(v65 + 8) = 0;
      qword_26AF9ABD0 = v65;
      __cxa_guard_release(&qword_26AF9AAC8);
    }
  }
  *((void *)this + 2) = 0x10000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 8;
  *((void *)this + 8) = &qword_26AF9AB98;
  re::IntrospectionRegistry::add(this, v3);
  long long v66 = v67;
}

uint64_t re::introspect_RenderGraphNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphNode>, this);
}

void *re::allocInfo_TargetRead(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AAD8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9AD50, "TargetRead");
    __cxa_guard_release(&qword_26AF9AAD8);
  }
  return &unk_26AF9AD50;
}

void re::initInfo_TargetRead(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x10643527A3D5CELL;
  v13[1] = "TargetRead";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAE0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AAE0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_RenderGraphTargetHandle((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "targetHandle";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9AB58 = v8;
      size_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t Settings = re::introspect_ReadSettings((re::IntrospectionBase **)1);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "settings";
      *(void *)(v11 + 16) = Settings;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AB60 = v11;
      __cxa_guard_release(&qword_26AF9AAE0);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9AB58;
  *((void *)this + 9) = re::internal::defaultConstruct<re::TargetRead>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::TargetRead>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::TargetRead>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::TargetRead>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::TargetRead>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = -1;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 19) = 0;
  *(void *)&double result = 2;
  *(void *)(a3 + 24) = 2;
  return result;
}

double re::internal::defaultConstructV2<re::TargetRead>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = -1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 19) = 0;
  *(void *)&double result = 2;
  *(void *)(a1 + 24) = 2;
  return result;
}

void *re::allocInfo_TargetWrite(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AAF0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9ADC8, "TargetWrite");
    __cxa_guard_release(&qword_26AF9AAF0);
  }
  return &unk_26AF9ADC8;
}

void re::initInfo_TargetWrite(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x1FC226FCD6FE15CLL;
  v13[1] = "TargetWrite";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AAF8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AAF8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_RenderGraphTargetHandle((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "targetHandle";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9AB68 = v8;
      size_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v10 = re::introspect_WriteSettings((re::IntrospectionBase **)1);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "settings";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AB70 = v11;
      __cxa_guard_release(&qword_26AF9AAF8);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9AB68;
  *((void *)this + 9) = re::internal::defaultConstruct<re::TargetWrite>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::TargetWrite>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::TargetWrite>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::TargetWrite>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::TargetWrite>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(_OWORD *)(a3 + 8) = xmmword_23440DE80;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = xmmword_23435FBB0;
  *(_WORD *)(a3 + 48) = 0;
  *(_DWORD *)(a3 + 52) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::TargetWrite>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_23440DE80;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_23435FBB0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return result;
}

void *re::allocInfo_BufferRead(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AB08))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9AE40, "BufferRead");
    __cxa_guard_release(&qword_26AF9AB08);
  }
  return &unk_26AF9AE40;
}

void re::initInfo_BufferRead(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0xD20F3D0E03C2CLL;
  v13[1] = "BufferRead";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB10, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AB10);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_RenderGraphBufferHandle((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "bufferHandle";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9AB78 = v8;
      size_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t Settings = re::introspect_ReadSettings((re::IntrospectionBase **)1);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "settings";
      *(void *)(v11 + 16) = Settings;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AB80 = v11;
      __cxa_guard_release(&qword_26AF9AB10);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9AB78;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BufferRead>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BufferRead>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BufferRead>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BufferRead>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::BufferRead>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = -1;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 19) = 0;
  *(void *)&double result = 2;
  *(void *)(a3 + 24) = 2;
  return result;
}

double re::internal::defaultConstructV2<re::BufferRead>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = -1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 19) = 0;
  *(void *)&double result = 2;
  *(void *)(a1 + 24) = 2;
  return result;
}

void *re::allocInfo_BufferWrite(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AB20))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9AEB8, "BufferWrite");
    __cxa_guard_release(&qword_26AF9AB20);
  }
  return &unk_26AF9AEB8;
}

void re::initInfo_BufferWrite(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0x196FD864BC046BELL;
  v13[1] = "BufferWrite";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AB28, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AB28);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_RenderGraphBufferHandle((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "bufferHandle";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9AB88 = v8;
      size_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v10 = re::introspect_WriteSettings((re::IntrospectionBase **)1);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "settings";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AB90 = v11;
      __cxa_guard_release(&qword_26AF9AB28);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9AB88;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BufferWrite>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BufferWrite>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::BufferWrite>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BufferWrite>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

double re::internal::defaultConstruct<re::BufferWrite>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(_OWORD *)(a3 + 8) = xmmword_23440DE80;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = xmmword_23435FBB0;
  *(_WORD *)(a3 + 48) = 0;
  *(_DWORD *)(a3 + 52) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::BufferWrite>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_23440DE80;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_23435FBB0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return result;
}

void *re::DynamicArray<re::TargetRead>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::TargetRead>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::TargetRead>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::TargetRead>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::TargetRead>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 32 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = 0;
          v11[1] = -1;
          *uint64_t v11 = *(void *)v8;
          v11[1] = *(void *)(v8 + 8);
          *((_OWORD *)v11 + 1) = *(_OWORD *)(v8 + 16);
          v8 += 32;
          v11 += 4;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::TargetWrite>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::TargetWrite>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::TargetWrite>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::TargetWrite>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::TargetWrite>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 6;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 16);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + (v9 << 6);
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = 0;
          v11[1] = -1;
          *uint64_t v11 = *(void *)v8;
          v11[1] = *(void *)(v8 + 8);
          long long v12 = *(_OWORD *)(v8 + 16);
          long long v13 = *(_OWORD *)(v8 + 48);
          *((_OWORD *)v11 + 2) = *(_OWORD *)(v8 + 32);
          *((_OWORD *)v11 + 3) = v13;
          *((_OWORD *)v11 + 1) = v12;
          v8 += 64;
          v11 += 8;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::TargetRead>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::TargetRead>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::TargetRead>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::TargetRead>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::TargetRead>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  double result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::TargetRead>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    double result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::TargetRead>::resize((void *)a4, a5);
    }
  }
  else
  {
    double result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      double result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::TargetRead>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v11 = 0;
  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = -1;
  uint64_t v12 = 2;
  re::DynamicArray<re::TargetRead>::add(this, &v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 32 * *((void *)this + 2) - 32);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::TargetRead>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::TargetRead>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

void *re::DynamicArray<re::TargetRead>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      double result = re::DynamicArray<re::TargetRead>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 32 * v4;
      do
      {
        uint64_t v7 = v3[4] + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = -1;
        *(_DWORD *)(v7 + 16) = 0;
        *(_DWORD *)(v7 + 19) = 0;
        *(void *)(v7 + 24) = 2;
        v6 += 32;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  double result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::TargetRead>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::TargetRead>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      __n128 v10 = *(char **)(a1 + 32);
      uint64_t v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 32 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::TargetWrite>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::TargetWrite>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::TargetWrite>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::TargetWrite>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::TargetWrite>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::TargetWrite>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::TargetWrite>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::TargetWrite>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  v10[0] = 0;
  long long v11 = 0u;
  v10[1] = -1;
  DWORD1(v11) = 1;
  long long v12 = xmmword_23435FBB0;
  long long v13 = 0u;
  DWORD2(v13) = 0;
  re::DynamicArray<re::TargetWrite>::add(this, (uint64_t)v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::TargetWrite>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::TargetWrite>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

void *re::DynamicArray<re::TargetWrite>::resize(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      unint64_t v6 = v4 << 6;
      do
      {
        unint64_t v7 = v3[4] + v6;
        *(void *)unint64_t v7 = 0;
        *(_OWORD *)(v7 + 8) = xmmword_23440DE80;
        *(_OWORD *)(v7 + 32) = xmmword_23435FBB0;
        *(_WORD *)(v7 + 48) = 0;
        *(_DWORD *)(v7 + 52) = 0;
        *(_DWORD *)(v7 + 56) = 0;
        v6 += 64;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::TargetWrite>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::TargetWrite>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::TargetWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BufferRead>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BufferRead>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BufferRead>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BufferRead>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BufferRead>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::BufferRead>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::TargetRead>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BufferRead>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v11 = 0;
  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = -1;
  uint64_t v12 = 2;
  re::DynamicArray<re::TargetRead>::add(this, &v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 32 * *((void *)this + 2) - 32);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::BufferRead>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BufferRead>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 32 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::TargetRead>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::TargetRead>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::TargetRead>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      __n128 v10 = *(char **)(a1 + 32);
      uint64_t v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 32 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferRead>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BufferWrite>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BufferWrite>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BufferWrite>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BufferWrite>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BufferWrite>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::BufferWrite>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::TargetWrite>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BufferWrite>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  v10[0] = 0;
  long long v11 = 0u;
  v10[1] = -1;
  DWORD1(v11) = 1;
  long long v12 = xmmword_23435FBB0;
  long long v13 = 0u;
  DWORD2(v13) = 0;
  re::DynamicArray<re::TargetWrite>::add(this, (uint64_t)v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::BufferWrite>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BufferWrite>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::TargetWrite>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::TargetWrite>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::TargetWrite>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BufferWrite>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void processShadowsToGenerate(unint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, re::PerFrameAllocatorGPU *a7)
{
  uint64_t v273 = *MEMORY[0x263EF8340];
  uint64_t v201 = a5;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF38, memory_order_acquire) & 1) == 0)
  {
    unint64_t v191 = (re *)__cxa_guard_acquire(&qword_26AF9AF38);
    a5 = v201;
    if (v191)
    {
      _MergedGlobals_445 = re::hashString(v191, v192);
      __cxa_guard_release(&qword_26AF9AF38);
      a5 = v201;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF48, memory_order_acquire) & 1) == 0)
  {
    int v193 = __cxa_guard_acquire(&qword_26AF9AF48);
    a5 = v201;
    if (v193)
    {
      qword_26AF9AF40 = re::getCombinedScopeHash(_MergedGlobals_445, v194, v195);
      __cxa_guard_release(&qword_26AF9AF48);
      a5 = v201;
    }
  }
  uint64_t v13 = *(void *)(*(void *)(a5 + 8) + 88);
  if (v13) {
    goto LABEL_203;
  }
  do
  {
    while (1)
    {
      double v15 = re::WorldOrderedShadows::create((_anonymous_namespace_ *)a1, (uint64_t)v215);
      unint64_t v16 = v216;
      long long v214 = v216;
      uint64_t v213 = a6;
      uint64_t v211 = (re::MaterialParameterTableBuilder *)a6;
      if (!v216)
      {
LABEL_24:
        uint64_t v47 = (re::PerFrameAllocatorGPU **)a3 + 7;
        uint64_t v203 = *((void *)a3 + 7);
        __int32 v43 = (re::Allocator **)(a3 + 5);
        uint64_t v199 = re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable(*((re::Allocator **)a3 + 10), (re::MaterialParameterTableBuilder *)a6);
LABEL_25:
        unint64_t v8 = v216;
        if (!v216)
        {
          uint64_t v62 = *v47;
          uint64_t v63 = re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable(*v43, (re::MaterialParameterTableBuilder *)a6);
          goto LABEL_38;
        }
        if (v216 < 0x666666666666667)
        {
          unint64_t v49 = 40 * v216;
          float v50 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a6 + 32))(a6, 40 * v216, 8);
          if (v50)
          {
            a1 = (unint64_t)v50;
            uint64_t v209 = v43;
            int v52 = v50;
            if (v8 != 1)
            {
              bzero(v50, v49 - 40);
              int v52 = (void *)(a1 + v49 - 40);
            }
            unint64_t v206 = 40 * v8;
            unint64_t v9 = 0;
            unint64_t v7 = 0;
            void v52[4] = 0;
            *(_OWORD *)int v52 = 0u;
            *((_OWORD *)v52 + 1) = 0u;
            unint64_t v25 = (unint64_t)&v270[24];
            unint64_t v16 = a1 + 16;
            do
            {
              unint64_t v53 = v216;
              if (v216 <= v7)
              {
                *(void *)uint64_t v272 = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(v265[0]) = 136315906;
                *(void *)((char *)v265 + 4) = "operator[]";
                WORD6(v265[0]) = 1024;
                *(_DWORD *)((char *)v265 + 14) = 797;
                WORD1(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 4) = v7;
                WORD6(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 14) = v53;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_194:
                *(void *)uint64_t v272 = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(v265[0]) = 136315906;
                *(void *)((char *)v265 + 4) = "operator[]";
                WORD6(v265[0]) = 1024;
                *(_DWORD *)((char *)v265 + 14) = 468;
                WORD1(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 4) = v8;
                WORD6(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 14) = v8;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_195:
                uint64_t v243 = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(v265[0]) = 136315906;
                *(void *)((char *)v265 + 4) = "operator[]";
                WORD6(v265[0]) = 1024;
                *(_DWORD *)((char *)v265 + 14) = 797;
                WORD1(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 4) = a1;
                WORD6(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 14) = v53;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_196:
                uint64_t v243 = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(v265[0]) = 136315906;
                *(void *)((char *)v265 + 4) = "operator[]";
                WORD6(v265[0]) = 1024;
                *(_DWORD *)((char *)v265 + 14) = 468;
                WORD1(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 4) = a1;
                WORD6(v265[1]) = 2048;
                *(void *)((char *)&v265[1] + 14) = v7;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_197:
                v240[0] = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)int v270 = 136315906;
                *(void *)&v270[4] = "operator[]";
                *(_WORD *)&v270[12] = 1024;
                *(_DWORD *)&v270[14] = 797;
                *(_WORD *)&v270[18] = 2048;
                *(void *)&v270[20] = v7;
                *(_WORD *)&v270[28] = 2048;
                *(void *)&v270[30] = v8;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_198:
                v240[0] = 0;
                memset(buf, 0, 80);
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)int v270 = 136315906;
                *(void *)&v270[4] = "operator[]";
                *(_WORD *)&v270[12] = 1024;
                *(_DWORD *)&v270[14] = 468;
                *(_WORD *)&v270[18] = 2048;
                *(void *)&v270[20] = v16;
                *(_WORD *)&v270[28] = 2048;
                *(void *)&v270[30] = v16;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_199;
              }
              long long v54 = *(_OWORD *)(v217 + v9 + 16);
              *(_OWORD *)int v270 = *(_OWORD *)(v217 + v9);
              *(_OWORD *)&v270[16] = v54;
              uint64_t v55 = re::ShadowTileManager::dataForTile(a2, (unsigned __int16 *)&v270[24]);
              if (v8 == v7) {
                goto LABEL_194;
              }
              uint64_t v57 = *(void *)(v55 + 208);
              uint64_t v56 = *(void *)(v55 + 216);
              long long v58 = *(_OWORD *)(v55 + 192);
              *(_WORD *)(v16 - 16) = *(_WORD *)&v270[24];
              *(_OWORD *)(v16 - 8) = v58;
              *(void *)(v16 + 8) = v57;
              *(void *)(v16 + 16) = v56;
              ++v7;
              v16 += 40;
              v9 += 32;
            }
            while (v8 != v7);
            uint64_t v59 = *v209;
            *(void *)int v270 = 0x29BCD869CB9AA7DDLL;
            re::PerFrameAllocatorGPU::allocInternal(a7, v206, 0x10uLL, 0, buf);
            int v60 = *(_DWORD *)&buf[8];
            memcpy((void *)(*(void *)buf + *(void *)&buf[8]), (const void *)a1, v206);
            id v61 = **(id **)&buf[24];
            *(void *)&v265[0] = v61;
            DWORD2(v265[0]) = v60;
            HIDWORD(v265[0]) = 40 * v8;
            re::MaterialParameterBlock::setBuffer(v59, (uint64_t *)v270, (uint64_t)v265, (uint64_t)buf);
            *(void *)buf = 0;
            if (v61)
            {

              *(void *)&v265[0] = 0;
            }
            uint64_t v62 = *v47;
            uint64_t v63 = re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable(v59, (re::MaterialParameterTableBuilder *)a6);
            (*(void (**)(uint64_t, unint64_t))(*(void *)a6 + 40))(a6, a1);
LABEL_38:
            unint64_t v7 = v216;
            a7 = v62;
            long long v197 = v63;
            if (!v216)
            {
              uint64_t v210 = 0;
              goto LABEL_45;
            }
            if (v216 >> 61) {
              goto LABEL_209;
            }
            a1 = 8 * v216;
            uint64_t v65 = (void *)(*(uint64_t (**)(re::MaterialParameterTableBuilder *, unint64_t, uint64_t))(*(void *)v211 + 32))(v211, 8 * v216, 8);
            if (!v65) {
              goto LABEL_210;
            }
            a6 = (uint64_t)v65;
            long long v67 = v65;
            if (v7 != 1)
            {
              size_t v68 = a1 - 8;
              bzero(v65, v68);
              long long v67 = (void *)(a6 + v68);
            }
            uint64_t v210 = a6;
            *long long v67 = 0;
LABEL_45:
            long long v241 = 0uLL;
            uint64_t v242 = 0;
            uint64_t v69 = (uint64_t)v211;
            re::FixedArray<int>::init<>((uint64_t *)&v241, (uint64_t)v211, v7);
            memset(v272, 0, 36);
            *(void *)&v272[36] = 0x7FFFFFFFLL;
            re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v272, (uint64_t)v211, 3);
            if (v7)
            {
              a1 = 0;
              unint64_t v9 = (unint64_t)&buf[8];
              unint64_t v8 = 0xBF58476D1CE4E5B9;
              unint64_t v16 = 0x94D049BB133111EBLL;
              unint64_t v25 = 0x7FFFFFFFLL;
              while (1)
              {
                unint64_t v53 = v216;
                if (v216 <= a1) {
                  goto LABEL_195;
                }
                long long v70 = a3;
                a6 = v7;
                uint64_t v71 = v217 + 32 * a1;
                uint64_t v72 = re::ShadowTileManager::dataForTile(a2, (unsigned __int16 *)(v71 + 24));
                uint64_t v73 = (re::MaterialParameterBlock *)*((void *)v70 + 9);
                re::MaterialParameterBlock::setFloat(v73, "receiverPlaneHeight", *(float *)v72, (uint64_t)v240);
                v240[0] = 0;
                re::MaterialParameterBlock::setFloat(v73, "receiverDepthNormalization", *(float *)(v72 + 4), (uint64_t)&v237);
                id v237 = 0;
                re::MaterialParameterBlock::setFloat(v73, "floorPlaneHeight", *(float *)(v72 + 8), (uint64_t)v236);
                v236[0] = 0;
                re::MaterialParameterBlock::setInt(v73, "tileIndex", *(unsigned __int16 *)(v71 + 24), (uint64_t)v235);
                v235[0] = 0;
                long long v74 = *(_OWORD *)(v72 + 80);
                *(_OWORD *)int v270 = *(_OWORD *)(v72 + 64);
                *(_OWORD *)&v270[16] = v74;
                long long v75 = *(_OWORD *)(v72 + 112);
                *(_OWORD *)&v270[32] = *(_OWORD *)(v72 + 96);
                long long v271 = v75;
                re::MaterialParameterBlock::setMatrix4x4F(v73, "tileProj", v270, (uint64_t)v234);
                v234[0] = 0;
                LODWORD(v265[0]) = *((_DWORD *)v70 + 52);
                *(void *)buf = 0x2651C5BB725E4431;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v233);
                v233[0] = 0;
                LODWORD(v265[0]) = *((_DWORD *)v70 + 51);
                *(void *)buf = 0x58F744A8543328D7;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v232);
                v232[0] = 0;
                LODWORD(v265[0]) = *((_DWORD *)v70 + 58);
                *(void *)buf = 0x13276C0E66FCCEDLL;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v231);
                v231[0] = 0;
                LODWORD(v265[0]) = *((_DWORD *)v70 + 59);
                *(void *)buf = 0x76708FF238D5F0A6;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v230);
                v230[0] = 0;
                float v76 = cos(*((float *)v70 + 63) * 3.14159265 / 180.0);
                *(float *)unint64_t v265 = v76;
                *(void *)buf = 0x7DDA5D55C0FC4FA9;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v229);
                v229[0] = 0;
                a3 = v70;
                int v77 = *((_DWORD *)v70 + 64);
                uint64_t v69 = (uint64_t)v211;
                LODWORD(v265[0]) = v77;
                *(void *)buf = 0x17E9B59A609C84C2;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v228);
                v228[0] = 0;
                if (*(unsigned char *)(v72 + 40)) {
                  _ZF = 1;
                }
                else {
                  _ZF = re::internal::shadows::g_enableShadowFlattening == 0;
                }
                if (_ZF) {
                  int v79 = 1;
                }
                else {
                  int v79 = 2;
                }
                LODWORD(v265[0]) = v79;
                *(void *)buf = 0x5FE82A114F627B09;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 7, (uint64_t)v227);
                v227[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 12);
                *(void *)buf = 0x65BBCF6D7FDD200ALL;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v226);
                v226[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 16);
                *(void *)buf = 0x7300C2F63F7BC750;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v225);
                v225[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 20);
                *(void *)buf = 0x71A74BC906F47D1BLL;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v224);
                v224[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 44);
                *(void *)buf = 0x572BFF15FAD034E6;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v223);
                v223[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 48);
                *(void *)buf = 0x27F92942C5FF139DLL;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v222);
                v222[0] = 0;
                LODWORD(v265[0]) = *(_DWORD *)(v72 + 52);
                *(void *)buf = 0x521049A67D17C4ELL;
                re::MaterialParameterBlock::setConstant(v73, (uint64_t *)buf, 4uLL, v265, 1, (uint64_t)v221);
                v221[0] = 0;
                uint64_t v219 = 0x3559BD29F3DDB747;
                re::MaterialParameterBlock::setBinding(v73, &v219, "rendergraph", (uint64_t)"MeshShadowMippedReceiverDepthColorTexture", 2, (uint64_t)v220);
                uint64_t v219 = 0;
                v220[0] = 0;
                *(void *)(v210 + 8 * a1) = re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable(v73, v211);
                unint64_t v7 = *((void *)&v241 + 1);
                if (*((void *)&v241 + 1) <= a1) {
                  goto LABEL_196;
                }
                *(_DWORD *)(v242 + 4 * a1) = *(_DWORD *)(v72 + 24);
                uint64_t v80 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a2 + 128, (uint64_t *)(v72 + 32));
                uint64_t v81 = *(void *)(v80 + 16);
                if (v81) {
                  break;
                }
LABEL_69:
                ++a1;
                unint64_t v7 = a6;
                if (a1 == a6) {
                  goto LABEL_70;
                }
              }
              int v82 = *(void **)(v80 + 32);
              int v83 = &v82[2 * v81];
              while (2)
              {
                memset(&buf[8], 0, 20);
                *(void *)&uint8_t buf[32] = 0;
                *(void *)buf = v211;
                re::DynamicArray<int>::setCapacity(buf, 0);
                ++*(_DWORD *)&buf[24];
                unint64_t v84 = 0xBF58476D1CE4E5B9 * (*v82 ^ (*v82 >> 30));
                unint64_t v85 = (0x94D049BB133111EBLL * (v84 ^ (v84 >> 27))) ^ ((0x94D049BB133111EBLL * (v84 ^ (v84 >> 27))) >> 31);
                if (*(void *)v272)
                {
                  unint64_t v86 = v85 % *(unsigned int *)&v272[24];
                  uint64_t v87 = *(unsigned int *)(*(void *)&v272[8] + 4 * v86);
                  if (v87 != 0x7FFFFFFF)
                  {
                    while (*(void *)(*(void *)&v272[16] + (v87 << 6) + 16) != *v82)
                    {
                      uint64_t v87 = *(_DWORD *)(*(void *)&v272[16] + (v87 << 6) + 8) & 0x7FFFFFFF;
                      if (v87 == 0x7FFFFFFF) {
                        goto LABEL_63;
                      }
                    }
                    unint64_t v89 = *(void *)&v272[16] + (v87 << 6);
LABEL_65:
                    LODWORD(v265[0]) = a1;
                    re::DynamicArray<int>::add((void *)(v89 + 24), v265);
                    if (*(void *)buf && *(void *)&buf[32]) {
                      (*(void (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[32]);
                    }
                    v82 += 2;
                    if (v82 == v83) {
                      goto LABEL_69;
                    }
                    continue;
                  }
                }
                else
                {
                  LODWORD(v86) = 0;
                }
                break;
              }
LABEL_63:
              unsigned int v88 = re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove((uint64_t)v272, v86, v85, v82, (uint64_t)buf);
              ++*(_DWORD *)&v272[40];
              unint64_t v89 = *(void *)&v272[16] + ((unint64_t)v88 << 6);
              goto LABEL_65;
            }
LABEL_70:
            *(void *)&v265[0] = *((void *)a3 + 6);
            *((void *)&v265[0] + 1) = v69;
            *(void *)&v265[1] = v7;
            *((void *)&v265[1] + 1) = v210;
            v265[2] = v241;
            uint64_t v90 = v242;
            uint64_t v242 = 0;
            long long v241 = 0uLL;
            uint64_t v91 = *((void *)a3 + 12);
            *(void *)&long long v266 = v90;
            *((void *)&v266 + 1) = v91;
            int v269 = 0;
            *(_OWORD *)int v267 = *(_OWORD *)v272;
            memset(v272, 0, 24);
            *(void *)&v267[16] = *(void *)&v272[16];
            long long v268 = *(_OWORD *)&v272[24];
            *(_OWORD *)&v272[24] = xmmword_23436F740;
            double v92 = re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v272);
            if ((void)v241 && *((void *)&v241 + 1)) {
              (*(void (**)(double))(*(void *)v241 + 40))(v92);
            }
            a1 = v216;
            memset(v272, 0, 24);
            re::FixedArray<re::ShadowInfo::BlurInfo>::init<>((uint64_t *)v272, v69, v216);
            if (a1)
            {
              unint64_t v7 = 0;
              unint64_t v16 = *(void *)&v272[8];
              int v93 = *(char **)&v272[16];
              unint64_t v25 = 24;
              do
              {
                unint64_t v8 = v216;
                if (v216 <= v7) {
                  goto LABEL_197;
                }
                uint64_t v94 = re::ShadowTileManager::dataForTile(a2, (unsigned __int16 *)(v217 + v25));
                if (v16 == v7) {
                  goto LABEL_198;
                }
                memcpy(v93, (const void *)(v94 + 240), 0x394uLL);
                ++v7;
                v93 += 928;
                v25 += 32;
              }
              while (a1 != v7);
            }
            memset(v270, 0, 24);
            a1 = *(void *)v272;
            if (*(void *)v272)
            {
              uint64_t v95 = *(void *)&v272[8];
              re::FixedArray<re::ShadowInfo::BlurInfo>::init<>((uint64_t *)v270, *(uint64_t *)v272, *(unint64_t *)&v272[8]);
              if (*(void *)&v270[8] != v95) {
                goto LABEL_211;
              }
              if (v95)
              {
                uint64_t v97 = *(void *)&v272[16];
                memmove(*(void **)&v270[16], *(const void **)&v272[16], 928 * v95 - 12);
                (*(void (**)(unint64_t, uint64_t))(*(void *)a1 + 40))(a1, v97);
              }
            }
            *(void *)buf = 0;
            *(_OWORD *)&uint8_t buf[16] = 0u;
            a1 = (unint64_t)buf;
            a6 = (uint64_t)v211;
            *(void *)&uint8_t buf[8] = v211;
            *(void *)&uint8_t buf[32] = v211;
            *(_OWORD *)&buf[40] = 0u;
            *(_DWORD *)&buf[56] = -1;
            memset(&buf[60], 0, 40);
            *(void *)&buf[100] = 0x7FFFFFFFLL;
            a2 = (uint64_t)&buf[64];
            re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)&buf[64], (uint64_t)v211, 3);
            long long v246 = 0u;
            long long v247 = 0u;
            long long v245 = 0u;
            uint64_t v248 = 0;
            *(void *)&long long v247 = v211;
            *(_OWORD *)&v249[4] = xmmword_2343864E0;
            *(_DWORD *)long long v249 = 1065353216;
            *(_DWORD *)&v249[20] = 12;
            *(void *)&v249[24] = 0x3CF5C28F3F800000;
            LOWORD(v250) = 0;
            long long v251 = xmmword_2343864F0;
            *(void *)uint64_t v252 = 0x3EB333333F800000;
            v252[8] = 1;
            *(_OWORD *)&v252[12] = xmmword_234386500;
            *(_OWORD *)&v252[28] = xmmword_234386510;
            *(_DWORD *)&v252[44] = 1106247680;
            *(void *)&long long v253 = 0x4170475C3DCCCCCDLL;
            BYTE8(v253) = 1;
            long long v254 = xmmword_23435FD90;
            LOBYTE(v255) = 1;
            *(void *)&long long v256 = 0x3F8000003F2D42C4;
            *((void *)&v256 + 1) = 0xA3F800000;
            long long v257 = xmmword_234386520;
            *(void *)&long long v258 = 1056964608;
            DWORD2(v258) = 0x40000000;
            WORD6(v258) = 256;
            *(_WORD *)uint64_t v259 = 1;
            v259[2] = 0;
            *(_DWORD *)&v259[4] = 897988541;
            *(void *)&v259[8] = 0;
            *(void *)&v259[16] = 0x3DCCCCCD3E800000;
            *(_DWORD *)&v259[24] = 16;
            long long v261 = 0u;
            unint64_t v9 = (unint64_t)&v261;
            int v262 = 0;
            *(void *)&long long v263 = 0;
            unint64_t v260 = v211;
            re::DynamicArray<re::EvaluationRegister>::setCapacity(&v260, 0);
            ++v262;
            *((void *)&v263 + 1) = 0;
            long long v264 = 0u;
            *((void *)&v245 + 1) = v197;
            *(void *)&long long v246 = v203;
            *((void *)&v246 + 1) = v199;
            *(void *)&long long v245 = a7;
            *(void *)buf = *(void *)&v265[0];
            uint64_t v99 = *(void *)&buf[8];
            if (!*(void *)&buf[8] || *(void *)&buf[8] == *((void *)&v265[0] + 1))
            {
              uint64_t v100 = *(void *)&buf[16];
              uint64_t v101 = *(void *)&buf[24];
              *(void *)&uint8_t buf[8] = *((void *)&v265[0] + 1);
              *(_OWORD *)&uint8_t buf[16] = v265[1];
              *((void *)&v265[0] + 1) = v99;
              *(void *)&v265[1] = v100;
              *((void *)&v265[1] + 1) = v101;
              re::FixedArray<float>::operator=((uint64_t *)&buf[32], (uint64_t *)&v265[2]);
              uint64_t v103 = *(void *)v267;
              *(void *)&buf[56] = *((void *)&v266 + 1);
              if (!*(void *)&buf[64] || *(void *)&buf[64] == *(void *)v267)
              {
                *(void *)int v267 = *(void *)&buf[64];
                long long v117 = *(_OWORD *)&buf[72];
                *(void *)&buf[64] = v103;
                *(void *)&buf[72] = *(void *)&v267[8];
                *(void *)&buf[80] = *(void *)&v267[16];
                *(_OWORD *)&v267[8] = v117;
                long long v118 = *(_OWORD *)&buf[88];
                *(_OWORD *)&buf[88] = v268;
                long long v268 = v118;
                uint64_t v104 = v201;
              }
              else
              {
                uint64_t v104 = v201;
                if (*(_DWORD *)&buf[92])
                {
                  if (*(_DWORD *)&buf[88])
                  {
                    memset_pattern16(*(void **)&buf[72], &unk_2343655D0, 4 * *(unsigned int *)&buf[88]);
                    uint64_t v104 = v201;
                  }
                  unint64_t v105 = *(unsigned int *)&buf[96];
                  if (*(_DWORD *)&buf[96])
                  {
                    a1 = 0;
                    unint64_t v106 = 0;
                    do
                    {
                      unint64_t v107 = *(void *)&buf[80] + a1;
                      int v108 = *(_DWORD *)(*(void *)&buf[80] + a1 + 8);
                      if (v108 < 0)
                      {
                        *(_DWORD *)(v107 + 8) = v108 & 0x7FFFFFFF;
                        re::DynamicArray<unsigned long>::deinit(v107 + 24);
                        uint64_t v104 = v201;
                        unint64_t v105 = *(unsigned int *)&buf[96];
                      }
                      ++v106;
                      a1 += 64;
                    }
                    while (v106 < v105);
                  }
                  *(_DWORD *)&buf[96] = 0;
                  *(_DWORD *)&buf[92] = 0;
                  *(_DWORD *)&buf[100] = 0x7FFFFFFF;
                  ++*(_DWORD *)&buf[104];
                }
                if (v103)
                {
                  uint64_t v102 = DWORD1(v268);
                  if (*(_DWORD *)&buf[88] < DWORD1(v268))
                  {
                    re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)&buf[64], DWORD1(v268));
                    uint64_t v104 = v201;
                  }
                  unint64_t v109 = DWORD2(v268);
                  if (DWORD2(v268))
                  {
                    uint64_t v110 = 0;
                    unint64_t v111 = 0;
                    a6 = 0x7FFFFFFFLL;
                    do
                    {
                      float32x4_t v112 = (void *)(*(void *)&v267[16] + v110);
                      if ((*(_DWORD *)(*(void *)&v267[16] + v110 + 8) & 0x80000000) != 0)
                      {
                        a1 = (unint64_t)(v112 + 3);
                        unint64_t v8 = *v112;
                        uint64_t v113 = *(unsigned int *)&buf[100];
                        unint64_t v7 = *v112 % (unint64_t)*(unsigned int *)&buf[88];
                        if (*(_DWORD *)&buf[100] == 0x7FFFFFFF)
                        {
                          uint64_t v113 = *(unsigned int *)&buf[96];
                          int v114 = *(_DWORD *)&buf[96];
                          if (*(_DWORD *)&buf[96] == *(_DWORD *)&buf[88])
                          {
                            re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)&buf[64], 2 * *(_DWORD *)&buf[92]);
                            int v114 = *(_DWORD *)&buf[96];
                            unint64_t v7 = v8 % *(unsigned int *)&buf[88];
                          }
                          *(_DWORD *)&buf[96] = v114 + 1;
                          uint64_t v115 = *(void *)&buf[80];
                          int v116 = *(_DWORD *)(*(void *)&buf[80] + (v113 << 6) + 8);
                        }
                        else
                        {
                          uint64_t v115 = *(void *)&buf[80];
                          int v116 = *(_DWORD *)(*(void *)&buf[80]
                                           + ((unint64_t)*(unsigned int *)&buf[100] << 6)
                                           + 8);
                          *(_DWORD *)&buf[100] = v116 & 0x7FFFFFFF;
                        }
                        *(_DWORD *)(v115 + (v113 << 6) + 8) = v116 | 0x80000000;
                        *(_DWORD *)(*(void *)&buf[80] + (v113 << 6) + 8) = *(_DWORD *)(*(void *)&buf[80]
                                                                                       + (v113 << 6)
                                                                                       + 8) & 0x80000000 | *(_DWORD *)(*(void *)&buf[72] + 4 * v7);
                        *(void *)(*(void *)&buf[80] + (v113 << 6)) = v8;
                        *(void *)(*(void *)&buf[80] + (v113 << 6) + 16) = v112[2];
                        re::DynamicArray<float>::DynamicArray(*(void *)&buf[80] + (v113 << 6) + 24, v112 + 3);
                        *(_DWORD *)(*(void *)&buf[72] + 4 * v7) = v113;
                        ++*(_DWORD *)&buf[92];
                        unint64_t v109 = DWORD2(v268);
                        uint64_t v104 = v201;
                      }
                      ++v111;
                      v110 += 64;
                    }
                    while (v111 < v109);
                  }
                  ++*(_DWORD *)&buf[104];
                }
              }
              uint64_t v119 = v247;
              if ((void)v247) {
                BOOL v120 = (void)v247 == *(void *)v270;
              }
              else {
                BOOL v120 = 1;
              }
              if (!v120) {
                goto LABEL_213;
              }
              uint64_t v121 = *((void *)&v247 + 1);
              uint64_t v122 = v248;
              long long v247 = *(_OWORD *)v270;
              *(void *)int v270 = v119;
              *(void *)&v270[8] = v121;
              uint64_t v248 = *(void *)&v270[16];
              *(void *)&v270[16] = v122;
              if (v260)
              {
                if (v215[0])
                {
                  re::DynamicArray<re::AllocatedShadowHandle>::copy((void **)&v260, (uint64_t)v215);
                  uint64_t v104 = v201;
                }
                else
                {
                  *((void *)&v261 + 1) = 0;
                }
                ++v262;
              }
              else if (v215[0])
              {
                unint64_t v260 = (re::MaterialParameterTableBuilder *)v215[0];
                a1 = (unint64_t)&v260;
                re::DynamicArray<re::EvaluationRegister>::setCapacity(&v260, v216);
                ++v262;
                re::DynamicArray<re::AllocatedShadowHandle>::copy((void **)&v260, (uint64_t)v215);
                uint64_t v104 = v201;
              }
              long long v123 = a3[22];
              long long v258 = a3[21];
              *(_OWORD *)uint64_t v259 = v123;
              *(_OWORD *)&v259[12] = *(_OWORD *)((char *)a3 + 364);
              long long v124 = a3[18];
              long long v254 = a3[17];
              long long v255 = v124;
              long long v125 = a3[20];
              long long v256 = a3[19];
              long long v257 = v125;
              long long v126 = a3[14];
              *(_OWORD *)uint64_t v252 = a3[13];
              *(_OWORD *)&v252[16] = v126;
              long long v127 = a3[16];
              *(_OWORD *)&v252[32] = a3[15];
              long long v253 = v127;
              long long v128 = a3[10];
              *(_OWORD *)long long v249 = a3[9];
              *(_OWORD *)&v249[16] = v128;
              long long v129 = a3[12];
              long long v250 = a3[11];
              long long v251 = v129;
              uint64_t v130 = *((void *)&v263 + 1);
              if (*((void *)&v263 + 1) && *((void *)&v263 + 1) != v213) {
                goto LABEL_214;
              }
              long long v131 = v264;
              *((void *)&v263 + 1) = v213;
              long long v264 = v214;
              uint64_t v213 = v130;
              long long v214 = v131;
              unint64_t v132 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE";
              if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE" & 0x8000000000000000) != 0)
              {
                uint64_t v133 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_24MeshShadowGenerationDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v134 = 5381;
                do
                {
                  unint64_t v132 = v134;
                  unsigned int v135 = *v133++;
                  uint64_t v134 = (33 * v134) ^ v135;
                }
                while (v135);
              }
              unint64_t v136 = (qword_26AF9AF40 + (v132 << 6) + (v132 >> 2) - 0x61C8864680B583E9) ^ v132;
              uint64_t v137 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v104 + 40) + 32))(*(void *)(v104 + 40), 496, 16);
              uint64_t v138 = v201;
              uint64_t v139 = v137;
              *(void *)uint64_t v137 = &unk_26E71A8E8;
              *(_OWORD *)(v137 + 16) = *(_OWORD *)buf;
              uint64_t v140 = *(void *)&buf[16];
              *(_OWORD *)&uint8_t buf[8] = 0u;
              *(void *)(v137 + 32) = v140;
              *(void *)(v137 + 40) = 0;
              *(_OWORD *)(v137 + 40) = *(_OWORD *)&buf[24];
              *(_OWORD *)&unsigned char buf[24] = 0u;
              uint64_t v141 = *(void *)&buf[48];
              *(void *)(v137 + 56) = *(void *)&buf[40];
              *(void *)(v137 + 64) = v141;
              *(void *)&buf[40] = 0;
              *(void *)&buf[48] = 0;
              *(void *)(v137 + 72) = *(void *)&buf[56];
              *(_DWORD *)(v137 + 112) = 0;
              *(_DWORD *)(v137 + 120) = 0;
              *(_OWORD *)(v137 + 80) = *(_OWORD *)&buf[64];
              *(_OWORD *)(v137 + 96) = 0u;
              *(_OWORD *)&buf[64] = 0u;
              *(void *)(v137 + 96) = *(void *)&buf[80];
              *(_OWORD *)(v137 + 104) = *(_OWORD *)&buf[88];
              *(_OWORD *)&buf[88] = xmmword_23436F740;
              long long v142 = v246;
              *(_OWORD *)(v137 + 128) = v245;
              *(_OWORD *)(v137 + 144) = v142;
              unint64_t v144 = *((void *)&v247 + 1);
              unint64_t v143 = v247;
              long long v247 = 0u;
              *(_OWORD *)(v137 + 160) = __PAIR128__(v144, v143);
              *(void *)(v137 + 176) = 0;
              *(void *)(v137 + 176) = v248;
              *(void *)&buf[80] = 0;
              uint64_t v248 = 0;
              long long v145 = *(_OWORD *)v249;
              long long v146 = v250;
              *(_OWORD *)(v137 + 208) = *(_OWORD *)&v249[16];
              *(_OWORD *)(v137 + 224) = v146;
              *(_OWORD *)(v137 + 192) = v145;
              long long v147 = v251;
              long long v148 = *(_OWORD *)v252;
              long long v149 = *(_OWORD *)&v252[32];
              *(_OWORD *)(v137 + 272) = *(_OWORD *)&v252[16];
              *(_OWORD *)(v137 + 288) = v149;
              *(_OWORD *)(v137 + 240) = v147;
              *(_OWORD *)(v137 + 256) = v148;
              long long v150 = v253;
              long long v151 = v254;
              long long v152 = v256;
              *(_OWORD *)(v137 + 336) = v255;
              *(_OWORD *)(v137 + 352) = v152;
              *(_OWORD *)(v137 + 304) = v150;
              *(_OWORD *)(v137 + 320) = v151;
              long long v153 = v257;
              long long v154 = v258;
              long long v155 = *(_OWORD *)&v259[16];
              *(_OWORD *)(v137 + 400) = *(_OWORD *)v259;
              *(_OWORD *)(v137 + 416) = v155;
              *(_OWORD *)(v137 + 368) = v153;
              *(_OWORD *)(v137 + 384) = v154;
              *(_DWORD *)(v137 + 456) = 0;
              *(void *)(v137 + 448) = 0;
              *(void *)(v137 + 432) = v260;
              *(_OWORD *)(v137 + 464) = v263;
              *(void *)(v137 + 488) = *((void *)&v264 + 1);
              unint64_t v156 = *(void *)(v201 + 96);
              uint64_t v207 = v201 + 96;
              unint64_t v260 = 0;
              *(_OWORD *)(v137 + 440) = v261;
              long long v261 = 0u;
              ++v262;
              *(_DWORD *)(v137 + 456) = 1;
              long long v263 = 0u;
              *(void *)(v137 + 480) = v264;
              long long v264 = 0uLL;
              if (!v156
                || (unint64_t v156 = v136 % *(unsigned int *)(v201 + 120),
                    uint64_t v157 = *(unsigned int *)(*(void *)(v201 + 104) + 4 * v156),
                    v157 == 0x7FFFFFFF))
              {
LABEL_133:
                uint64_t v159 = *(unsigned int *)(v201 + 132);
                if (v159 == 0x7FFFFFFF)
                {
                  uint64_t v159 = *(unsigned int *)(v201 + 128);
                  int v160 = v159;
                  if (v159 == *(_DWORD *)(v201 + 120))
                  {
                    re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v207, 2 * *(_DWORD *)(v201 + 124));
                    uint64_t v138 = v201;
                    LODWORD(v156) = v136 % *(unsigned int *)(v201 + 120);
                    int v160 = *(_DWORD *)(v201 + 128);
                  }
                  *(_DWORD *)(v138 + 128) = v160 + 1;
                  uint64_t v161 = *(void *)(v138 + 112);
                  int v162 = *(_DWORD *)(v161 + 24 * v159);
                }
                else
                {
                  uint64_t v161 = *(void *)(v201 + 112);
                  int v162 = *(_DWORD *)(v161 + 24 * v159);
                  *(_DWORD *)(v201 + 132) = v162 & 0x7FFFFFFF;
                }
                uint64_t v163 = 24 * v159;
                *(_DWORD *)(v161 + v163) = v162 | 0x80000000;
                *(_DWORD *)(*(void *)(v138 + 112) + v163) = *(_DWORD *)(*(void *)(v138 + 112) + 24 * v159) & 0x80000000 | *(_DWORD *)(*(void *)(v138 + 104) + 4 * v156);
                *(void *)(*(void *)(v138 + 112) + 24 * v159 + 8) = v136;
                *(void *)(*(void *)(v138 + 112) + 24 * v159 + 16) = v139;
                *(_DWORD *)(*(void *)(v138 + 104) + 4 * v156) = v159;
                ++*(_DWORD *)(v138 + 124);
                ++*(_DWORD *)(v138 + 136);
              }
              else
              {
                uint64_t v158 = *(void *)(v201 + 112);
                while (*(void *)(v158 + 24 * v157 + 8) != v136)
                {
                  LODWORD(v157) = *(_DWORD *)(v158 + 24 * v157) & 0x7FFFFFFF;
                  if (v157 == 0x7FFFFFFF) {
                    goto LABEL_133;
                  }
                }
              }
              re::FixedArray<re::MeshShadowDepthPrepassReceiverParametersCPU>::deinit((uint64_t *)&v263 + 1);
              if (v260)
              {
                if ((void)v263) {
                  (*(void (**)(re::MaterialParameterTableBuilder *, void))(*(void *)v260 + 40))(v260, v263);
                }
                *(void *)&long long v263 = 0;
                long long v261 = 0uLL;
                unint64_t v260 = 0;
                ++v262;
              }
              if ((void)v247)
              {
                if (*((void *)&v247 + 1))
                {
                  (*(void (**)(void, uint64_t))(*(void *)v247 + 40))(v247, v248);
                  *((void *)&v247 + 1) = 0;
                  uint64_t v248 = 0;
                }
                *(void *)&long long v247 = 0;
              }
              v164.n128_f64[0] = re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)&buf[64]);
              if (*(void *)&buf[32])
              {
                if (*(void *)&buf[40])
                {
                  (*(void (**)(double))(**(void **)&buf[32] + 40))(v164.n128_f64[0]);
                  *(void *)&buf[40] = 0;
                  *(void *)&buf[48] = 0;
                }
                *(void *)&uint8_t buf[32] = 0;
              }
              if (*(void *)&buf[8] && *(void *)&buf[16]) {
                (*(void (**)(__n128))(**(void **)&buf[8] + 40))(v164);
              }
              if (*(void *)v270 && *(void *)&v270[8]) {
                (*(void (**)(__n128))(**(void **)v270 + 40))(v164);
              }
              v165.n128_f64[0] = re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v267);
              if (*(void *)&v265[2])
              {
                if (*((void *)&v265[2] + 1))
                {
                  (*(void (**)(double))(**(void **)&v265[2] + 40))(v165.n128_f64[0]);
                  *((void *)&v265[2] + 1) = 0;
                  *(void *)&long long v266 = 0;
                }
                *(void *)&v265[2] = 0;
              }
              if (*((void *)&v265[0] + 1) && *(void *)&v265[1]) {
                (*(void (**)(__n128))(**((void **)&v265[0] + 1) + 40))(v165);
              }
              re::FixedArray<re::MeshShadowDepthPrepassReceiverParametersCPU>::deinit(&v213);
              if (*((void *)a3 + 2))
              {
                unint64_t v16 = 0;
                a1 = (unint64_t)v218;
                a2 = 134217984;
                do
                {
                  unint64_t v8 = *(void *)(*((void *)a3 + 4) + 24 * v16 + 16);
                  uint64_t v166 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)v218, v8);
                  if (v166)
                  {
                    unint64_t v9 = v166;
                    uint64_t v167 = re::HashTable<re::ecs2::Scene const*,re::HashTable<unsigned long long,re::SharedPtr<re::AudioSourceState>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(a4 + 368, v8);
                    if (v167)
                    {
                      uint64_t v168 = v167;
                      memset(v265, 0, 36);
                      *(void *)((char *)&v265[2] + 4) = 0x7FFFFFFFLL;
                      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v265, (uint64_t)v211, 3);
                      *(void *)&long long v266 = 0;
                      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)buf, v168);
                      *(void *)&buf[48] = *(void *)v9;
                      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v265, (uint64_t *)buf);
                      *(void *)&long long v266 = *(void *)&buf[48];
                      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)buf);
                      unint64_t v7 = *((void *)a3 + 2);
                      if (v7 <= v16) {
                        goto LABEL_202;
                      }
                      unint64_t v169 = _MergedGlobals_445;
                      size_t v170 = strlen(*(const char **)(*((void *)a3 + 4) + 24 * v16));
                      uint64_t v171 = 0x9E3779B97F4A7C17;
                      if (v170)
                      {
                        MurmurHash3_x64_128(*(void *)(*((void *)a3 + 4) + 24 * v16), v170, 0, (unint64_t *)buf);
                        uint64_t v171 = ((*(void *)&buf[8]
                               - 0x61C8864680B583E9
                               + (*(void *)buf << 6)
                               + (*(void *)buf >> 2)) ^ *(void *)buf)
                             - 0x61C8864680B583E9;
                      }
                      unint64_t v172 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPerSceneGenerationDataEEE";
                      if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPerSceneGenerationDataEEE" & 0x8000000000000000) != 0)
                      {
                        uint64_t v173 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_32MeshShadowPe"
                                                                     "rSceneGenerationDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
                        uint64_t v174 = 5381;
                        do
                        {
                          unint64_t v172 = v174;
                          unsigned int v175 = *v173++;
                          uint64_t v174 = (33 * v174) ^ v175;
                        }
                        while (v175);
                      }
                      unint64_t v176 = ((((v169 >> 2) + (v169 << 6) + v171) ^ v169)
                            - 0x61C8864680B583E9
                            + (v172 << 6)
                            + (v172 >> 2)) ^ v172;
                      uint64_t v177 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v201 + 40) + 32))(*(void *)(v201 + 40), 64, 8);
                      uint64_t v178 = v201;
                      uint64_t v179 = v177;
                      *(void *)uint64_t v177 = &unk_26E71A928;
                      *(_DWORD *)(v177 + 40) = 0;
                      *(void *)(v177 + 24) = 0;
                      *(void *)(v177 + 32) = 0;
                      *(_DWORD *)(v177 + 48) = 0;
                      *(void *)(v177 + 8) = *(void *)&v265[0];
                      *(void *)(v177 + 16) = 0;
                      *(void *)(v177 + 16) = *((void *)&v265[0] + 1);
                      v265[0] = 0uLL;
                      *(void *)(v177 + 24) = *(void *)&v265[1];
                      *(void *)&v265[1] = 0;
                      *(void *)(v177 + 32) = *((void *)&v265[1] + 1);
                      *(void *)(v177 + 40) = *(void *)&v265[2];
                      *(_OWORD *)((char *)&v265[1] + 8) = xmmword_23436F740;
                      *(void *)(v177 + 56) = v266;
                      unint64_t v180 = *(void *)(v201 + 96);
                      if (!v180
                        || (unint64_t v180 = v176 % *(unsigned int *)(v201 + 120),
                            uint64_t v181 = *(unsigned int *)(*(void *)(v201 + 104) + 4 * v180),
                            v181 == 0x7FFFFFFF))
                      {
LABEL_179:
                        uint64_t v183 = *(unsigned int *)(v201 + 132);
                        if (v183 == 0x7FFFFFFF)
                        {
                          uint64_t v183 = *(unsigned int *)(v201 + 128);
                          int v184 = v183;
                          if (v183 == *(_DWORD *)(v201 + 120))
                          {
                            re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v207, 2 * *(_DWORD *)(v201 + 124));
                            uint64_t v178 = v201;
                            unint64_t v180 = v176 % *(unsigned int *)(v201 + 120);
                            int v184 = *(_DWORD *)(v201 + 128);
                          }
                          *(_DWORD *)(v178 + 128) = v184 + 1;
                          uint64_t v185 = *(void *)(v178 + 112);
                          int v186 = *(_DWORD *)(v185 + 24 * v183);
                        }
                        else
                        {
                          uint64_t v185 = *(void *)(v201 + 112);
                          int v186 = *(_DWORD *)(v185 + 24 * v183);
                          *(_DWORD *)(v201 + 132) = v186 & 0x7FFFFFFF;
                        }
                        uint64_t v188 = 24 * v183;
                        *(_DWORD *)(v185 + v188) = v186 | 0x80000000;
                        *(_DWORD *)(*(void *)(v178 + 112) + v188) = *(_DWORD *)(*(void *)(v178 + 112) + 24 * v183) & 0x80000000 | *(_DWORD *)(*(void *)(v178 + 104) + 4 * v180);
                        *(void *)(*(void *)(v178 + 112) + 24 * v183 + 8) = v176;
                        *(void *)(*(void *)(v178 + 112) + 24 * v183 + 16) = v179;
                        *(_DWORD *)(*(void *)(v178 + 104) + 4 * v180) = v183;
                        ++*(_DWORD *)(v178 + 124);
                        ++*(_DWORD *)(v178 + 136);
                      }
                      else
                      {
                        uint64_t v182 = *(void *)(v201 + 112);
                        while (*(void *)(v182 + 24 * v181 + 8) != v176)
                        {
                          LODWORD(v181) = *(_DWORD *)(v182 + 24 * v181) & 0x7FFFFFFF;
                          if (v181 == 0x7FFFFFFF) {
                            goto LABEL_179;
                          }
                        }
                      }
                      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v265);
                    }
                    else
                    {
                      __n128 v187 = *re::shadowLogObjects(0);
                      if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(void *)&uint8_t buf[4] = v8;
                        _os_log_error_impl(&dword_233120000, v187, OS_LOG_TYPE_ERROR, "MeshShadowBuilder: In generate data, world %llu has no receivers but the world still exists", buf, 0xCu);
                      }
                    }
                  }
                  ++v16;
                }
                while (*((void *)a3 + 2) > v16);
              }
              double v189 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v218);
              if (v215[0])
              {
                if (v217) {
                  (*(void (**)(double))(*(void *)v215[0] + 40))(v189);
                }
              }
              return;
            }
LABEL_212:
            re::internal::assertLog((re::internal *)4, v98, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
            _os_crash();
            __break(1u);
LABEL_213:
            re::internal::assertLog((re::internal *)4, v102, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
            _os_crash();
            __break(1u);
LABEL_214:
            re::internal::assertLog((re::internal *)4, v102, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
            _os_crash();
            __break(1u);
LABEL_215:
            re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 96, v9);
            _os_crash();
            __break(1u);
LABEL_216:
            re::internal::assertLog((re::internal *)4, v22, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
            _os_crash();
            __break(1u);
            break;
          }
LABEL_208:
          re::internal::assertLog((re::internal *)4, v51, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
          _os_crash();
          __break(1u);
LABEL_209:
          re::internal::assertLog((re::internal *)6, v64, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 8, v7);
          _os_crash();
          __break(1u);
LABEL_210:
          re::internal::assertLog((re::internal *)4, v66, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
          _os_crash();
          __break(1u);
LABEL_211:
          re::internal::assertLog((re::internal *)4, v96, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
          _os_crash();
          __break(1u);
          goto LABEL_212;
        }
LABEL_207:
        re::internal::assertLog((re::internal *)6, v48, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 40, v8);
        _os_crash();
        __break(1u);
        goto LABEL_208;
      }
      if (v216 >= 0x24924924924924ALL)
      {
        re::internal::assertLog((re::internal *)6, v14, v15, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 112, v216);
        _os_crash();
        __break(1u);
LABEL_206:
        re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
        _os_crash();
        __break(1u);
        goto LABEL_207;
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, double))(*(void *)a6 + 32))(a6, 112 * v216, 16, v15);
      *((void *)&v214 + 1) = v17;
      if (!v17) {
        goto LABEL_206;
      }
      unint64_t v19 = v16 - 1;
      if (v16 != 1)
      {
        do
        {
          *(void *)uint64_t v17 = 0;
          *(_DWORD *)(v17 + 8) = 0;
          v17 += 112;
          --v19;
        }
        while (v19);
      }
      *(void *)uint64_t v17 = 0;
      *(_DWORD *)(v17 + 8) = 0;
      unint64_t v9 = v216;
      if (!v216) {
        goto LABEL_24;
      }
      if (v216 >= 0x2AAAAAAAAAAAAABLL) {
        goto LABEL_215;
      }
      unint64_t v20 = 96 * v216;
      uint64_t v21 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a6 + 32))(a6, 96 * v216, 16);
      if (!v21) {
        goto LABEL_216;
      }
      a1 = (unint64_t)v21;
      uint64_t v23 = v21;
      if (v9 != 1)
      {
        bzero(v21, v20 - 96);
        uint64_t v23 = (_OWORD *)(a1 + v20 - 96);
      }
      unint64_t v198 = 96 * v9;
      unint64_t v8 = 0;
      unsigned char v23[4] = 0u;
      v23[5] = 0u;
      v23[2] = 0u;
      void v23[3] = 0u;
      *uint64_t v23 = 0u;
      v23[1] = 0u;
      unint64_t v7 = 1;
      uint64_t v24 = *((void *)&v214 + 1);
      while (1)
      {
        unint64_t v25 = v216;
        if (v216 <= v8) {
          break;
        }
        unint64_t v26 = a1;
        uint64_t v27 = (unsigned __int16 *)(v217 + 32 * v8 + 24);
        a1 = a2;
        uint64_t v28 = re::ShadowTileManager::dataForTile(a2, v27);
        long long v29 = *(_OWORD *)(v28 + 144);
        *(_OWORD *)int v270 = *(_OWORD *)(v28 + 128);
        *(_OWORD *)&v270[16] = v29;
        long long v30 = *(_OWORD *)(v28 + 176);
        *(_OWORD *)&v270[32] = *(_OWORD *)(v28 + 160);
        long long v271 = v30;
        *(_OWORD *)uint64_t v205 = *(_OWORD *)&v270[16];
        long long v208 = *(_OWORD *)v270;
        long long v202 = v30;
        long long v204 = *(_OWORD *)&v270[32];
        _S8 = *(_DWORD *)(v28 + 224);
        unsigned __int16 v32 = *v27;
        uint64_t v33 = re::ShadowTileManager::dataForTile(a2, v27);
        if (v9 <= v8) {
          goto LABEL_200;
        }
        __n128 v35 = *(__n128 *)(v33 + 1264);
        __asm { FCVT            H1, S8 }
        a1 = v26;
        unint64_t v40 = v26 + 96 * v8;
        *(_OWORD *)unint64_t v40 = v208;
        *(_OWORD *)(v40 + 16) = *(_OWORD *)v205;
        *(_OWORD *)(v40 + 32) = v204;
        *(_OWORD *)(v40 + 48) = v202;
        *(_WORD *)(v40 + 64) = _H1;
        *(_WORD *)(v40 + 66) = v32;
        *(__n128 *)(v40 + 80) = v35;
        re::buildCullingPlanes((uint64_t)v270, v34, (uint64_t)buf, v35);
        if (v16 <= v8) {
          goto LABEL_201;
        }
        uint64_t v41 = v24 + 112 * v8;
        if ((uint8_t *)v41 != buf)
        {
          re::DynamicInlineArray<re::PlaneF,6ul>::move((unint64_t *)(v24 + 112 * v8), (unint64_t *)buf);
          ++*(_DWORD *)(v41 + 8);
        }
        unint64_t v8 = v7;
        BOOL v42 = v9 > v7;
        unint64_t v7 = (v7 + 1);
        a6 = (uint64_t)v211;
        if (!v42)
        {
          __int32 v43 = (re::Allocator **)(a3 + 5);
          BOOL v44 = (re::MaterialParameterBlock *)*((void *)a3 + 10);
          v235[0] = 0x31EF696315A95E84;
          re::PerFrameAllocatorGPU::allocInternal(a7, v198, 0x10uLL, 0, buf);
          int v45 = *(_DWORD *)&buf[8];
          memcpy((void *)(*(void *)buf + *(void *)&buf[8]), (const void *)a1, v198);
          id v46 = **(id **)&buf[24];
          id v237 = v46;
          int v238 = v45;
          int v239 = 96 * v9;
          re::MaterialParameterBlock::setBuffer(v44, v235, (uint64_t)&v237, (uint64_t)v240);
          v240[0] = 0;
          if (v46)
          {

            id v237 = 0;
          }
          uint64_t v47 = (re::PerFrameAllocatorGPU **)a3 + 7;
          uint64_t v203 = *((void *)a3 + 7);
          uint64_t v199 = re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable(v44, v211);
          (*(void (**)(re::MaterialParameterTableBuilder *, unint64_t))(*(void *)v211 + 40))(v211, a1);
          goto LABEL_25;
        }
      }
LABEL_199:
      *(void *)int v270 = 0;
      memset(buf, 0, 80);
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v265[0]) = 136315906;
      *(void *)((char *)v265 + 4) = "operator[]";
      WORD6(v265[0]) = 1024;
      *(_DWORD *)((char *)v265 + 14) = 797;
      WORD1(v265[1]) = 2048;
      *(void *)((char *)&v265[1] + 4) = v8;
      WORD6(v265[1]) = 2048;
      *(void *)((char *)&v265[1] + 14) = v25;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_200:
      *(void *)uint64_t v272 = 0;
      memset(buf, 0, 80);
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v265[0]) = 136315906;
      *(void *)((char *)v265 + 4) = "operator[]";
      WORD6(v265[0]) = 1024;
      *(_DWORD *)((char *)v265 + 14) = 468;
      WORD1(v265[1]) = 2048;
      *(void *)((char *)&v265[1] + 4) = v8;
      WORD6(v265[1]) = 2048;
      *(void *)((char *)&v265[1] + 14) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_201:
      v236[0] = 0;
      a3 = v265;
      long long v266 = 0u;
      *(_OWORD *)int v267 = 0u;
      memset(v265, 0, sizeof(v265));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v272 = 136315906;
      *(void *)&v272[4] = "operator[]";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 468;
      *(_WORD *)&v272[18] = 2048;
      *(void *)&v272[20] = v8;
      *(_WORD *)&v272[28] = 2048;
      *(void *)&v272[30] = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_202:
      *(void *)uint64_t v272 = 0;
      memset(buf, 0, 80);
      a6 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int v270 = 136315906;
      *(void *)&v270[4] = "operator[]";
      *(_WORD *)&v270[12] = 1024;
      *(_DWORD *)&v270[14] = 789;
      *(_WORD *)&v270[18] = 2048;
      *(void *)&v270[20] = v16;
      *(_WORD *)&v270[28] = 2048;
      *(void *)&v270[30] = v7;
      _os_log_send_and_compose_impl();
      uint64_t v13 = _os_crash_msg();
      __break(1u);
LABEL_203:
      *(void *)buf = 0xAD90622DE24C6320;
      *(void *)&uint8_t buf[8] = "meshshadow:enableShadow";
      LOBYTE(v265[0]) = 0;
      if (!re::DebugSettingsManager::getWithErrorCode<BOOL>(v13, buf, v265)) {
        break;
      }
      re::StringID::destroyString((re::StringID *)buf);
    }
    int v190 = LOBYTE(v265[0]);
    re::StringID::destroyString((re::StringID *)buf);
  }
  while (v190);
}

uint64_t regenerateRenderingData@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, id *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v121 = *MEMORY[0x263EF8340];
  re::WorldOrderedShadows::create(a1 + 80, (uint64_t)&v78);
  unint64_t v12 = *((void *)&v79 + 1);
  if (*((void *)&v79 + 1))
  {
    uint64_t v104 = 0;
    unint64_t v105 = 0;
    uint64_t v106 = 0;
    re::FixedArray<re::Matrix4x4<float>>::init<>((uint64_t *)&v104, a4, *((unint64_t *)&v79 + 1));
    if (v12 >= 0x2AAAAAAAAAAAAABLL)
    {
LABEL_53:
      re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 96, v12);
      _os_crash();
      __break(1u);
LABEL_54:
      re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    uint64_t v14 = 96 * v12;
    uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a4 + 32))(a4, 96 * v12, 16);
    if (!v15) {
      goto LABEL_54;
    }
    uint64_t v17 = v15;
    uint64_t v18 = v15;
    unint64_t v19 = v12 - 1;
    if (v12 != 1)
    {
      uint64_t v18 = v15;
      do
      {
        *(_OWORD *)(v18 + 64) = 0uLL;
        *(_OWORD *)(v18 + 80) = 0uLL;
        *(_OWORD *)(v18 + 32) = 0uLL;
        *(_OWORD *)(v18 + 48) = 0uLL;
        *(void *)(v18 + 8) = 0;
        *(void *)(v18 + 16) = 0;
        *(void *)uint64_t v18 = 0;
        *(_WORD *)(v18 + 24) = 0;
        v18 += 96;
        --v19;
      }
      while (v19);
    }
    uint64_t v75 = a3;
    uint64_t v76 = a6;
    *(_OWORD *)(v18 + 64) = 0u;
    *(_OWORD *)(v18 + 80) = 0u;
    *(_OWORD *)(v18 + 32) = 0u;
    *(_OWORD *)(v18 + 48) = 0u;
    *(void *)(v18 + 8) = 0;
    *(void *)(v18 + 16) = 0;
    *(void *)uint64_t v18 = 0;
    *(_WORD *)(v18 + 24) = 0;
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    uint64_t v103 = 0;
    re::FixedArray<half>::init<>(&v101, a4, v12);
    if (*((void *)&v79 + 1))
    {
      uint64_t v73 = a5;
      unint64_t v20 = 0;
      unsigned int v21 = 1;
      id v23 = v102;
      uint64_t v22 = v103;
      do
      {
        uint64_t v24 = (unsigned __int16 *)(v81 + 32 * v20 + 24);
        uint64_t v25 = re::ShadowTileManager::dataForTile(a1, v24);
        unint64_t v26 = v105;
        if (v105 <= v20) {
          goto LABEL_50;
        }
        uint64_t v27 = (_OWORD *)(v106 + (v20 << 6));
        long long v28 = *(_OWORD *)(v25 + 1184);
        long long v29 = *(_OWORD *)(v25 + 1200);
        long long v30 = *(_OWORD *)(v25 + 1232);
        id v27[2] = *(_OWORD *)(v25 + 1216);
        v27[3] = v30;
        *uint64_t v27 = v28;
        v27[1] = v29;
        if (v12 <= v20) {
          goto LABEL_51;
        }
        unint64_t v31 = v17 + 96 * v20;
        *(_DWORD *)(v31 + 16) = *(_DWORD *)(v25 + 1248);
        *(_DWORD *)(v31 + 20) = *(_DWORD *)(v25 + 1252);
        *(_OWORD *)unint64_t v31 = *(_OWORD *)(v25 + 1264);
        *(_WORD *)(v31 + 24) = *v24;
        long long v32 = *(_OWORD *)(v25 + 1296);
        long long v33 = *(_OWORD *)(v25 + 1312);
        long long v34 = *(_OWORD *)(v25 + 1328);
        *(_OWORD *)(v31 + 32) = *(_OWORD *)(v25 + 1280);
        *(_OWORD *)(v31 + 48) = v32;
        *(_OWORD *)(v31 + 64) = v33;
        *(_OWORD *)(v31 + 80) = v34;
        if ((unint64_t)v23 <= v20) {
          goto LABEL_52;
        }
        _S0 = *(_DWORD *)(v25 + 1168);
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v22 + 2 * v20) = _S0;
        unint64_t v20 = v21;
        BOOL v40 = *((void *)&v79 + 1) > (unint64_t)v21++;
      }
      while (v40);
      a5 = v73;
      uint64_t v14 = 96 * v12;
    }
    else
    {
      uint64_t v22 = v103;
    }
    id v43 = objc_msgSend(*a5, sel_newBufferWithBytes_length_options_, v106, v12 << 6, 0);
    id v23 = objc_msgSend(*a5, sel_newBufferWithBytes_length_options_, v17, v14, 0);
    id v44 = objc_msgSend(*a5, sel_newBufferWithBytes_length_options_, v22, 2 * v12, 0);
    unint64_t v12 = *(void *)(a2 + 40);
    if (v12) {
      id v45 = (id)(v12 + 8);
    }
    uint64_t v100 = 0x26B98E39084D2FA1;
    id v46 = v43;
    uint64_t v47 = v43;
    id v48 = v46;
    id v97 = v46;
    int v98 = 0;
    id v74 = v47;
    unsigned int v99 = objc_msgSend(v47, sel_length);
    re::MaterialParameterBlock::setBuffer((re::MaterialParameterBlock *)v12, &v100, (uint64_t)&v97, (uint64_t)&v116);
    *(void *)&long long v116 = 0;
    if (v48)
    {

      id v97 = 0;
    }
    uint64_t v100 = 0;
    uint64_t v96 = 0x5A438D3F6E44D7FFLL;
    id v49 = v23;
    id v93 = v49;
    int v94 = 0;
    unsigned int v95 = objc_msgSend(v23, sel_length);
    re::MaterialParameterBlock::setBuffer((re::MaterialParameterBlock *)v12, &v96, (uint64_t)&v93, (uint64_t)v109);
    *(void *)unint64_t v109 = 0;
    if (v49)
    {

      id v93 = 0;
    }
    uint64_t v96 = 0;
    uint64_t v89 = 0x41AA1904683CFD85;
    id v50 = v44;
    id v86 = v50;
    int v87 = 0;
    unsigned int v88 = objc_msgSend(v44, sel_length);
    re::MaterialParameterBlock::setBuffer((re::MaterialParameterBlock *)v12, &v89, (uint64_t)&v86, (uint64_t)&v90);
    uint64_t v90 = 0;
    if (v50)
    {

      id v86 = 0;
    }
    uint64_t v89 = 0;
    LODWORD(v107) = *(_DWORD *)(a2 + 160);
    v84[0] = 0x2651C5BB725E4431;
    re::MaterialParameterBlock::setConstant((re::MaterialParameterBlock *)v12, v84, 4uLL, &v107, 1, (uint64_t)v85);
    v85[0] = 0;
    float v51 = cos(*(float *)(a2 + 200) * 3.14159265 / 180.0);
    float v108 = v51;
    uint64_t v107 = 0x7DDA5D55C0FC4FA9;
    v52.n128_f64[0] = re::MaterialParameterBlock::setConstant((re::MaterialParameterBlock *)v12, &v107, 4uLL, &v108, 1, (uint64_t)v84);
    v84[0] = 0;
    if (v12)
    {
      id v53 = (id)(v12 + 8);
    }
    if (v44) {

    }
    if (v23) {
    if (v74)
    }

    if (v101 && v102) {
      (*(void (**)(__n128))(*(void *)v101 + 40))(v52);
    }
    (*(void (**)(uint64_t, uint64_t, __n128))(*(void *)a4 + 40))(a4, v17, v52);
    long long v54 = v104;
    if (v104 && v105) {
      long long v54 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v104 + 40))();
    }
    unint64_t v91 = 0;
    uint64_t v92 = 0;
    uint64_t v90 = 0;
    if (*((void *)&v79 + 1))
    {
      unint64_t v20 = 0;
      unsigned int v55 = 1;
      unint64_t v56 = v91;
      uint64_t v57 = v92;
      while (1)
      {
        long long v58 = (unsigned __int16 *)(v81 + 32 * v20 + 24);
        uint64_t v59 = re::ShadowTileManager::dataForTile(a1, v58);
        if (v56 <= v20) {
          break;
        }
        int v60 = *(_DWORD *)(v59 + 1768);
        unsigned __int16 v61 = *v58;
        int v62 = *(_DWORD *)(v59 + 1760);
        long long v63 = *(_OWORD *)(v59 + 1744);
        uint64_t v64 = v57 + 96 * v20;
        long long v65 = *(_OWORD *)(v59 + 1680);
        long long v66 = *(_OWORD *)(v59 + 1696);
        long long v67 = *(_OWORD *)(v59 + 1728);
        *(_OWORD *)(v64 + 32) = *(_OWORD *)(v59 + 1712);
        *(_OWORD *)(v64 + 48) = v67;
        *(_OWORD *)uint64_t v64 = v65;
        *(_OWORD *)(v64 + 16) = v66;
        *(_OWORD *)(v64 + 64) = v63;
        *(_DWORD *)(v64 + 80) = v62;
        *(_WORD *)(v64 + 84) = v61;
        *(_DWORD *)(v64 + 88) = v60;
        unint64_t v20 = v55;
        BOOL v40 = *((void *)&v79 + 1) > (unint64_t)v55++;
        if (!v40) {
          goto LABEL_44;
        }
      }
      v85[0] = 0;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      long long v116 = 0u;
      unint64_t v26 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v109 = 136315906;
      *(void *)&v109[4] = "operator[]";
      __int16 v110 = 1024;
      int v111 = 468;
      __int16 v112 = 2048;
      unint64_t v113 = v20;
      __int16 v114 = 2048;
      unint64_t v115 = v56;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_50:
      uint64_t v90 = 0;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      long long v116 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v109 = 136315906;
      *(void *)&v109[4] = "operator[]";
      __int16 v110 = 1024;
      int v111 = 468;
      __int16 v112 = 2048;
      unint64_t v113 = v20;
      __int16 v114 = 2048;
      unint64_t v115 = v26;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_51:
      uint64_t v90 = 0;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      long long v116 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v109 = 136315906;
      *(void *)&v109[4] = "operator[]";
      __int16 v110 = 1024;
      int v111 = 468;
      __int16 v112 = 2048;
      unint64_t v113 = v20;
      __int16 v114 = 2048;
      unint64_t v115 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      uint64_t v90 = 0;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      long long v116 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v109 = 136315906;
      *(void *)&v109[4] = "operator[]";
      __int16 v110 = 1024;
      int v111 = 468;
      __int16 v112 = 2048;
      unint64_t v113 = v20;
      __int16 v114 = 2048;
      unint64_t v115 = (unint64_t)v23;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_53;
    }
    unint64_t v56 = v91;
    uint64_t v57 = v92;
LABEL_44:
    uint64_t v68 = v90;
    uint64_t v69 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v76, v75 + 368);
    *(void *)(v69 + 48) = v78;
    uint64_t v78 = 0;
    *(_OWORD *)(v69 + 56) = v79;
    long long v79 = 0u;
    ++v80;
    *(_DWORD *)(v69 + 72) = 1;
    *(_DWORD *)(v69 + 128) = 0;
    *(_OWORD *)(v69 + 80) = v81;
    uint64_t v70 = *((void *)&v82 + 1);
    *(void *)(v69 + 96) = v82;
    *(void *)(v69 + 104) = v70;
    long long v81 = 0u;
    long long v82 = 0u;
    *(_OWORD *)(v69 + 112) = v83;
    long long v83 = xmmword_23436F740;
    *(void *)(v69 + 136) = v12;
    *(void *)(v69 + 144) = v68;
    *(void *)(v69 + 152) = v56;
    *(void *)(v69 + 160) = v57;
  }
  else
  {
    *(_DWORD *)(a6 + 32) = 0;
    *(_OWORD *)a6 = 0u;
    *(_OWORD *)(a6 + 16) = 0u;
    *(void *)(a6 + 36) = 0x7FFFFFFFLL;
    *(void *)(a6 + 48) = v78;
    uint64_t v78 = 0;
    *(_OWORD *)(a6 + 56) = v79;
    long long v79 = 0u;
    ++v80;
    *(_DWORD *)(a6 + 72) = 1;
    *(_DWORD *)(a6 + 128) = 0;
    *(_OWORD *)(a6 + 80) = v81;
    uint64_t v41 = *((void *)&v82 + 1);
    *(void *)(a6 + 96) = v82;
    *(void *)(a6 + 104) = v41;
    long long v81 = 0u;
    long long v82 = 0u;
    *(_OWORD *)(a6 + 112) = v83;
    long long v83 = xmmword_23436F740;
    *(void *)(a6 + 136) = 0;
    *(_OWORD *)(a6 + 152) = 0u;
  }
  double v71 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v81 + 1);
  uint64_t result = v78;
  if (v78)
  {
    if ((void)v81) {
      return (*(uint64_t (**)(double))(*(void *)v78 + 40))(v71);
    }
  }
  return result;
}

void re::ProjectiveMeshShadowBuilder::buildShadowGenerationData(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, _OWORD *a5@<X5>, uint64_t a6@<X6>, unsigned char *a7@<X8>)
{
  uint64_t v13 = *(void *)(a6 + 8);
  uint64_t v14 = *(void *)(a2 + 64);
  if (v14)
  {
    uint64_t v16 = *(void *)(v13 + 104);
    if (v16) {
      uint64_t v17 = *(void *)(v16 + 336);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = (re::PerFrameAllocatorGPU *)re::PerFrameAllocatorGPUManager::perFrameAllocatorGPU(v17, *(void *)(*(void *)(v13 + 136) + 24) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)*(void *)(*(void *)(v13 + 136) + 16) << 60));
    processShadowsToGenerate(a2 + 48, a1, a5, a3, a6, a4, v18);
    LODWORD(v14) = *(void *)(a2 + 64) != 0;
  }
  if (*(_DWORD *)(a2 + 28)) {
    BOOL v19 = 0;
  }
  else {
    BOOL v19 = v14 == 0;
  }
  if (v19)
  {
    *a7 = 0;
  }
  else
  {
    regenerateRenderingData(a1, (uint64_t)(a5 + 3), a3, a4, (id *)(v13 + 184), (uint64_t)v21);
    re::Optional<re::PersistentShadowRenderingData>::Optional((uint64_t)a7, (uint64_t)v21);
    if (v29)
    {
      if (v30)
      {
        (*(void (**)(void))(*(void *)v29 + 40))();
        uint64_t v30 = 0;
        uint64_t v31 = 0;
      }
      uint64_t v29 = 0;
    }
    if (v28)
    {

      uint64_t v28 = 0;
    }
    double v20 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v27);
    if (v22)
    {
      if (v26) {
        (*(void (**)(double))(*(void *)v22 + 40))(v20);
      }
      uint64_t v26 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v22 = 0;
      ++v25;
    }
    re::HashTable<unsigned long long,re::HashSet<re::ecs2::Entity *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v21);
  }
}

void re::ProjectiveMeshShadowBuilder::buildShadowRenderingData(uint64_t a1, re::PersistentShadowState *a2, uint64_t a3, re::MaterialParameterTableBuilder *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v148 = *MEMORY[0x263EF8340];
  unint64_t v10 = *(void **)(a7 + 8);
  uint64_t v11 = v10[13];
  if (v11) {
    uint64_t v12 = *(void *)(v11 + 336);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = re::PerFrameAllocatorGPUManager::perFrameAllocatorGPU(v12, *(void *)(v10[17] + 24) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)*(void *)(v10[17] + 16) << 60));
  LODWORD(v14) = *(_DWORD *)(a3 + 64);
  if (v14)
  {
    uint64_t v15 = v13;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF58, memory_order_acquire) & 1) == 0)
    {
      long long v120 = (re *)__cxa_guard_acquire(&qword_26AF9AF58);
      if (v120)
      {
        qword_26AF9AF50 = re::hashString(v120, v121);
        __cxa_guard_release(&qword_26AF9AF58);
      }
    }
    unint64_t v16 = a5;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF68, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF9AF68))
    {
      qword_26AF9AF60 = re::getCombinedScopeHash(qword_26AF9AF50, v122, v123);
      __cxa_guard_release(&qword_26AF9AF68);
    }
    long long v127 = v10;
    unint64_t v17 = v10[11];
    if (v17) {
      goto LABEL_143;
    }
    while (1)
    {
      int v130 = v14;
      unint64_t v126 = v17;
      long long v134 = 0u;
      memset(v135, 0, 20);
      *(void *)&v135[20] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)&v134, (uint64_t)a4, 3);
      uint64_t v18 = *(void *)(a6 + 344);
      if (v18)
      {
        uint64_t v19 = *(void *)(a6 + 360);
        uint64_t v20 = v19 + 16 * v18;
        do
        {
          unint64_t v21 = 0xBF58476D1CE4E5B9 * (*(void *)v19 ^ (*(void *)v19 >> 30));
          unint64_t v22 = (0x94D049BB133111EBLL * (v21 ^ (v21 >> 27))) ^ ((0x94D049BB133111EBLL * (v21 ^ (v21 >> 27))) >> 31);
          if ((void)v134)
          {
            unint64_t v23 = v22 % *(unsigned int *)&v135[8];
            uint64_t v24 = *(unsigned int *)(*((void *)&v134 + 1) + 4 * v23);
            if (v24 != 0x7FFFFFFF)
            {
              while (*(void *)(*(void *)v135 + 32 * v24 + 16) != *(void *)v19)
              {
                uint64_t v24 = *(_DWORD *)(*(void *)v135 + 32 * v24 + 8) & 0x7FFFFFFF;
                if (v24 == 0x7FFFFFFF) {
                  goto LABEL_16;
                }
              }
              goto LABEL_17;
            }
          }
          else
          {
            LODWORD(v23) = 0;
          }
LABEL_16:
          re::HashTable<unsigned long long,float,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy((uint64_t)&v134, v23, v22, (void *)v19, (_DWORD *)(v19 + 12));
          ++*(_DWORD *)&v135[24];
LABEL_17:
          v19 += 16;
        }
        while (v19 != v20);
      }
      int v25 = *(_DWORD *)(v16 + 40);
      uint64_t v26 = *(void *)(a3 + 64);
      a6 = *(void *)(a3 + 136);
      uint64_t v136 = 0;
      uint64_t v137 = 0;
      __dst = 0;
      re::FixedArray<half>::init<>(&v136, (uint64_t)a4, v26);
      if (!*(void *)(a3 + 64)) {
        break;
      }
      uint64_t v124 = v15;
      unint64_t v16 = 0;
      uint64_t v15 = 0;
      unint64_t v14 = (unint64_t)v137;
      uint64_t v27 = __dst;
      unint64_t v17 = (unint64_t)a2;
      while (1)
      {
        unint64_t v28 = *(void *)(re::ShadowTileManager::dataForTile((uint64_t)a2, (unsigned __int16 *)(*(void *)(a3 + 80) + 32 * v16 + 24))+ 32);
        BOOL v29 = re::HashTable<unsigned long,re::RenderGraphResourceOperation const*,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::containsKey((uint64_t)&v134, v28);
        _S0 = 0;
        if (!v29) {
          goto LABEL_29;
        }
        if ((void)v134)
        {
          unint64_t v31 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v28 ^ (v28 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v28 ^ (v28 >> 30))) >> 27));
          unint64_t v32 = (v31 ^ (v31 >> 31)) % *(unsigned int *)&v135[8];
          uint64_t v33 = *(void *)v135;
          uint64_t v34 = *(unsigned int *)(*((void *)&v134 + 1) + 4 * v32);
          if (v34 != 0x7FFFFFFF)
          {
            while (*(void *)(*(void *)v135 + 32 * v34 + 16) != v28)
            {
              uint64_t v34 = *(_DWORD *)(*(void *)v135 + 32 * v34 + 8) & 0x7FFFFFFF;
              if (v34 == 0x7FFFFFFF) {
                goto LABEL_27;
              }
            }
            goto LABEL_28;
          }
        }
        else
        {
          uint64_t v33 = *(void *)v135;
        }
LABEL_27:
        uint64_t v34 = 0x7FFFFFFFLL;
LABEL_28:
        _S0 = *(_DWORD *)(v33 + 32 * v34 + 24);
LABEL_29:
        if (v14 <= v16) {
          break;
        }
        __asm { FCVT            H0, S0 }
        v27[v16] = _H0;
        unint64_t v16 = (v15 + 1);
        uint64_t v15 = v16;
        if (*(void *)(a3 + 64) <= v16)
        {
          uint64_t v15 = v124;
          goto LABEL_34;
        }
      }
      uint64_t v139 = 0;
      long long v143 = 0u;
      memset(v144, 0, 48);
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v145 = 136315906;
      *(void *)&v145[4] = "operator[]";
      *(_WORD *)&v145[12] = 1024;
      *(_DWORD *)&v145[14] = 468;
      *(_WORD *)&v145[18] = 2048;
      *(void *)&v145[20] = v16;
      __int16 v146 = 2048;
      unint64_t v147 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_140:
      uint64_t v139 = 0;
      long long v143 = 0u;
      memset(v144, 0, 48);
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v145 = 136315906;
      *(void *)&v145[4] = "operator[]";
      *(_WORD *)&v145[12] = 1024;
      *(_DWORD *)&v145[14] = 468;
      *(_WORD *)&v145[18] = 2048;
      *(void *)&v145[20] = v14;
      __int16 v146 = 2048;
      unint64_t v147 = a6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_141:
      uint64_t v139 = 0;
      long long v143 = 0u;
      memset(v144, 0, 48);
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v145 = 136315906;
      *(void *)&v145[4] = "operator[]";
      *(_WORD *)&v145[12] = 1024;
      *(_DWORD *)&v145[14] = 468;
      *(_WORD *)&v145[18] = 2048;
      *(void *)&v145[20] = v14;
      __int16 v146 = 2048;
      unint64_t v147 = a6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_142:
      uint64_t v136 = 0;
      long long v143 = 0u;
      memset(v144, 0, 48);
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v145 = 136315906;
      *(void *)&v145[4] = "operator[]";
      *(_WORD *)&v145[12] = 1024;
      *(_DWORD *)&v145[14] = 789;
      *(_WORD *)&v145[18] = 2048;
      *(void *)&v145[20] = v14;
      __int16 v146 = 2048;
      unint64_t v147 = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_143:
      *(void *)buf = 0xAD90622DE24C6320;
      *(void *)&uint8_t buf[8] = "meshshadow:enableShadow";
      LOBYTE(v134) = 0;
      if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v17, buf, &v134))
      {
        re::StringID::destroyString((re::StringID *)buf);
        continue;
      }
LABEL_146:
      int v119 = v134;
      re::StringID::destroyString((re::StringID *)buf);
      if (!v119)
      {
LABEL_110:
        *(void *)buf = 0x3C62BE4765422600;
        *(void *)&uint8_t buf[8] = "meshshadow:visualizeClusters";
        LOBYTE(v134) = 0;
        int v105 = re::DebugSettingsManager::getWithErrorCode<BOOL>(v17, buf, &v134);
        int v106 = v134;
        *(void *)&long long v134 = 0x26DCF6608CA13E42;
        *((void *)&v134 + 1) = "meshshadow:visualizeClusterInfo";
        v145[0] = 0;
        int v107 = re::DebugSettingsManager::getWithErrorCode<BOOL>(v17, &v134, v145);
        uint64_t v108 = v17;
        int v109 = v145[0];
        *(void *)long long v145 = 0x3C62BEC2F3809D42;
        *(void *)&v145[8] = "meshshadow:visualizeMatrices";
        LOBYTE(v136) = 0;
        int v110 = re::DebugSettingsManager::getWithErrorCode<BOOL>(v108, v145, &v136);
        int v111 = v136;
        uint64_t v136 = 0x572C0E956CDDF93CLL;
        uint64_t v137 = "meshshadow:visualizePlanes";
        LOBYTE(v139) = 0;
        int v112 = re::DebugSettingsManager::getWithErrorCode<BOOL>(v108, &v136, &v139);
        int v113 = v139;
        uint64_t v139 = 0x5A213028C6E74578;
        uint64_t v140 = "meshshadow:visualizeCullBoundingBoxes";
        LOBYTE(v141) = 0;
        if (re::DebugSettingsManager::getWithErrorCode<BOOL>(v108, &v139, &v141)) {
          int v114 = 0;
        }
        else {
          int v114 = v141;
        }
        re::StringID::destroyString((re::StringID *)&v139);
        re::StringID::destroyString((re::StringID *)&v136);
        re::StringID::destroyString((re::StringID *)v145);
        re::StringID::destroyString((re::StringID *)&v134);
        re::StringID::destroyString((re::StringID *)buf);
        if (v105) {
          int v106 = 0;
        }
        if (v107) {
          int v115 = 0;
        }
        else {
          int v115 = v109;
        }
        if (v110) {
          int v116 = 0;
        }
        else {
          int v116 = v111;
        }
        if (v112) {
          LODWORD(v17) = 0;
        }
        else {
          LODWORD(v17) = v113;
        }
        goto LABEL_125;
      }
    }
    unint64_t v14 = (unint64_t)v137;
    unint64_t v17 = (unint64_t)a2;
    if (v137)
    {
      uint64_t v27 = __dst;
LABEL_34:
      re::PerFrameAllocatorGPU::allocInternal((re::PerFrameAllocatorGPU *)v15, 2 * v14, 0x10uLL, 0, buf);
      int v40 = *(_DWORD *)&buf[8];
      memcpy((void *)(*(void *)buf + *(void *)&buf[8]), v27, 2 * v14);
      uint64_t v15 = (uint64_t)**((id **)&v143 + 1);
      uint64_t v139 = v15;
      LODWORD(v140) = v40;
      HIDWORD(v140) = 2 * v14;
      re::MaterialParameterBlock::setBuffer((re::MaterialParameterBlock *)a6, "patchFadeOpacityArray", (uint64_t)&v139, (uint64_t)buf);
      *(void *)buf = 0;
      if (v15) {

      }
      unint64_t v16 = a5;
    }
    if (v136 && v137)
    {
      (*(void (**)(uint64_t, void *))(*(void *)v136 + 40))(v136, __dst);
      uint64_t v137 = 0;
      __dst = 0;
    }
    int v141 = v25;
    uint64_t v136 = 0x114714ADE9B09C5FLL;
    re::MaterialParameterBlock::setConstant((re::MaterialParameterBlock *)a6, &v136, 4uLL, &v141, 1, (uint64_t)v145);
    *(void *)long long v145 = 0;
    unint64_t v14 = *(void *)(v16 + 64);
    unint64_t v16 = (unint64_t)re::MaterialParameterBlock::copyCurrentStateAsMaterialParameterTable((re::Allocator *)a6, a4);
    a6 = *(void *)(a3 + 152);
    uint64_t v41 = *(const void **)(a3 + 160);
    uint64_t v137 = 0;
    __dst = 0;
    uint64_t v136 = 0;
    re::FixedArray<re::MeshReceiverPerShadowConstants>::init<>((uint64_t)&v136, (uint64_t)a4, a6);
    if (v137 != (const char *)a6)
    {
      re::internal::assertLog((re::internal *)4, v42, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
      _os_crash();
      __break(1u);
      goto LABEL_146;
    }
    unint64_t v125 = v16;
    unint64_t v129 = v14;
    id v43 = (float *)__dst;
    if (a6) {
      memmove(__dst, v41, 96 * a6 - 4);
    }
    if (*(void *)(a3 + 64))
    {
      unint64_t v14 = 0;
      unsigned int v44 = 0;
      unint64_t v16 = 0x7FFFFFFFLL;
      uint64_t v15 = 96;
      do
      {
        unint64_t v45 = *(void *)(re::ShadowTileManager::dataForTile(v17, (unsigned __int16 *)(*(void *)(a3 + 80) + 32 * v14 + 24))+ 32);
        if (re::HashTable<unsigned long,re::RenderGraphResourceOperation const*,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::containsKey((uint64_t)&v134, v45))
        {
          if ((void)v134
            && (unint64_t v46 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v45 ^ (v45 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v45 ^ (v45 >> 30))) >> 27)),
                uint64_t v47 = *(unsigned int *)(*((void *)&v134 + 1) + 4 * ((v46 ^ (v46 >> 31)) % *(unsigned int *)&v135[8])),
                v47 != 0x7FFFFFFF))
          {
            uint64_t v49 = *(void *)(*(void *)v135 + 32 * v47 + 16);
            for (uint64_t i = v47; v49 != v45; v47 = i)
            {
              uint64_t i = *(_DWORD *)(*(void *)v135 + 32 * i + 8) & 0x7FFFFFFF;
              uint64_t v47 = 0x7FFFFFFFLL;
              if (i == 0x7FFFFFFF) {
                break;
              }
              uint64_t v49 = *(void *)(*(void *)v135 + 32 * i + 16);
            }
          }
          else
          {
            uint64_t v47 = 0x7FFFFFFFLL;
          }
          if (a6 <= v14) {
            goto LABEL_140;
          }
          float v48 = *(float *)(*(void *)v135 + 32 * v47 + 24);
        }
        else
        {
          float v48 = 1.0;
          if (a6 <= v14) {
            goto LABEL_141;
          }
        }
        v43[24 * v14 + 22] = v48;
        unint64_t v14 = ++v44;
      }
      while (*(void *)(a3 + 64) > (unint64_t)v44);
    }
    *(void *)long long v145 = v136;
    *(void *)&v145[8] = a6;
    *(void *)&v145[16] = v43;
    *(void *)&buf[5] = 0;
    *(void *)buf = 0;
    long long v143 = (unint64_t)a4;
    *(void *)&v144[0] = 0;
    *(_OWORD *)((char *)&v144[2] + 4) = xmmword_2343864E0;
    LODWORD(v144[2]) = 1065353216;
    DWORD1(v144[3]) = 12;
    *((void *)&v144[3] + 1) = 0x3CF5C28F3F800000;
    LOWORD(v144[4]) = 0;
    v144[5] = xmmword_2343864F0;
    *(void *)&v144[6] = 0x3EB333333F800000;
    BYTE8(v144[6]) = 1;
    *(_OWORD *)((char *)&v144[6] + 12) = xmmword_234386500;
    *(_OWORD *)((char *)&v144[7] + 12) = xmmword_234386510;
    *(void *)((char *)&v144[8] + 12) = 0x3DCCCCCD41F00000;
    DWORD1(v144[9]) = 1097877340;
    BYTE8(v144[9]) = 1;
    v144[10] = xmmword_23435FD90;
    LOBYTE(v144[11]) = 1;
    *(void *)&v144[12] = 0x3F8000003F2D42C4;
    *((void *)&v144[12] + 1) = 0xA3F800000;
    v144[13] = xmmword_234386520;
    *(void *)&v144[14] = 1056964608;
    DWORD2(v144[14]) = 0x40000000;
    WORD6(v144[14]) = 256;
    LOWORD(v144[15]) = 1;
    BYTE2(v144[15]) = 0;
    DWORD1(v144[15]) = 897988541;
    *((void *)&v144[15] + 1) = 0;
    *(void *)&v144[16] = 0x3DCCCCCD3E800000;
    DWORD2(v144[16]) = 16;
    *((void *)&v144[0] + 1) = v129;
    *(void *)&v144[1] = v125;
    re::FixedArray<float>::operator=((uint64_t *)&v143, (uint64_t *)v145);
    unint64_t v51 = a5;
    *(_OWORD *)((char *)&v144[15] + 12) = *(_OWORD *)(a5 + 364);
    long long v52 = *(_OWORD *)(a5 + 320);
    long long v53 = *(_OWORD *)(a5 + 352);
    v144[14] = *(_OWORD *)(a5 + 336);
    v144[15] = v53;
    long long v54 = *(_OWORD *)(a5 + 256);
    long long v55 = *(_OWORD *)(a5 + 288);
    long long v56 = *(_OWORD *)(a5 + 304);
    v144[10] = *(_OWORD *)(a5 + 272);
    v144[11] = v55;
    v144[12] = v56;
    v144[13] = v52;
    long long v57 = *(_OWORD *)(a5 + 192);
    long long v58 = *(_OWORD *)(a5 + 224);
    long long v59 = *(_OWORD *)(a5 + 240);
    v144[6] = *(_OWORD *)(a5 + 208);
    v144[7] = v58;
    v144[8] = v59;
    v144[9] = v54;
    long long v60 = *(_OWORD *)(a5 + 160);
    long long v61 = *(_OWORD *)(a5 + 176);
    v144[2] = *(_OWORD *)(a5 + 144);
    v144[3] = v60;
    uint64_t v62 = *(void *)(v17 + 56);
    int v63 = *(_DWORD *)(a5 + 152);
    *(_DWORD *)&uint8_t buf[4] = v130;
    *(_DWORD *)&uint8_t buf[8] = v62;
    *(_DWORD *)buf = v63;
    buf[12] = *(unsigned char *)(a5 + 177);
    v144[4] = v61;
    v144[5] = v57;
    unint64_t v64 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE";
    if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE" & 0x8000000000000000) != 0)
    {
      long long v65 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_23MeshShadowRenderingDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v66 = 5381;
      do
      {
        unint64_t v64 = v66;
        unsigned int v67 = *v65++;
        uint64_t v66 = (33 * v66) ^ v67;
      }
      while (v67);
    }
    unint64_t v68 = (qword_26AF9AF60 + (v64 << 6) + (v64 >> 2) - 0x61C8864680B583E9) ^ v64;
    uint64_t v69 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 40) + 32))(*(void *)(a7 + 40), 320, 16);
    *(void *)uint64_t v69 = &unk_26E71A968;
    *(void *)(v69 + 21) = *(void *)&buf[5];
    *(void *)(v69 + 16) = *(void *)buf;
    *(_OWORD *)(v69 + 32) = v143;
    long long v143 = 0uLL;
    *(void *)(v69 + 48) = *(void *)&v144[0];
    *(void *)&v144[0] = 0;
    memcpy((void *)(v69 + 56), (char *)v144 + 8, 0x104uLL);
    unint64_t v70 = *(void *)(a7 + 96);
    if (v70
      && (unint64_t v70 = v68 % *(unsigned int *)(a7 + 120),
          uint64_t v71 = *(unsigned int *)(*(void *)(a7 + 104) + 4 * v70),
          v71 != 0x7FFFFFFF))
    {
      uint64_t v77 = *(void *)(a7 + 112);
      while (*(void *)(v77 + 24 * v71 + 8) != v68)
      {
        LODWORD(v71) = *(_DWORD *)(v77 + 24 * v71) & 0x7FFFFFFF;
        if (v71 == 0x7FFFFFFF) {
          goto LABEL_63;
        }
      }
    }
    else
    {
LABEL_63:
      uint64_t v72 = *(unsigned int *)(a7 + 132);
      if (v72 == 0x7FFFFFFF)
      {
        uint64_t v72 = *(unsigned int *)(a7 + 128);
        int v73 = v72;
        if (v72 == *(_DWORD *)(a7 + 120))
        {
          re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a7 + 96, 2 * *(_DWORD *)(a7 + 124));
          LODWORD(v70) = v68 % *(unsigned int *)(a7 + 120);
          int v73 = *(_DWORD *)(a7 + 128);
        }
        *(_DWORD *)(a7 + 128) = v73 + 1;
        uint64_t v74 = *(void *)(a7 + 112);
        int v75 = *(_DWORD *)(v74 + 24 * v72);
      }
      else
      {
        uint64_t v74 = *(void *)(a7 + 112);
        int v75 = *(_DWORD *)(v74 + 24 * v72);
        *(_DWORD *)(a7 + 132) = v75 & 0x7FFFFFFF;
      }
      uint64_t v76 = 24 * v72;
      *(_DWORD *)(v74 + v76) = v75 | 0x80000000;
      *(_DWORD *)(*(void *)(a7 + 112) + v76) = *(_DWORD *)(*(void *)(a7 + 112) + 24 * v72) & 0x80000000 | *(_DWORD *)(*(void *)(a7 + 104) + 4 * v70);
      *(void *)(*(void *)(a7 + 112) + 24 * v72 + 8) = v68;
      *(void *)(*(void *)(a7 + 112) + 24 * v72 + 16) = v69;
      *(_DWORD *)(*(void *)(a7 + 104) + 4 * v70) = v72;
      ++*(_DWORD *)(a7 + 124);
      ++*(_DWORD *)(a7 + 136);
      if ((void)v143 && *((void *)&v143 + 1)) {
        (*(void (**)(void, void))(*(void *)v143 + 40))(v143, *(void *)&v144[0]);
      }
    }
    if (*(void *)v145 && *(void *)&v145[8]) {
      (*(void (**)(void, void))(**(void **)v145 + 40))(*(void *)v145, *(void *)&v145[16]);
    }
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v134);
    unint64_t v78 = *(void *)(a5 + 16);
    if (v78)
    {
      unint64_t v14 = 0;
      uint64_t v15 = a3 + 88;
      a6 = (unint64_t)v135;
      long long v131 = (unint64_t *)(a7 + 48);
      while (1)
      {
        unint64_t v79 = *(void *)(*(void *)(v51 + 32) + 24 * v14 + 16);
        if (re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet(a3 + 88, v79))
        {
          break;
        }
LABEL_108:
        if (v78 <= ++v14) {
          goto LABEL_109;
        }
      }
      if (*(void *)v15)
      {
        unint64_t v80 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v79 ^ (v79 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v79 ^ (v79 >> 30))) >> 27));
        unint64_t v81 = (v80 ^ (v80 >> 31)) % *(unsigned int *)(a3 + 112);
        uint64_t v82 = *(void *)(a3 + 104);
        uint64_t v83 = *(unsigned int *)(*(void *)(a3 + 96) + 4 * v81);
        if (v83 != 0x7FFFFFFF)
        {
          while (*(void *)(v82 + 32 * v83 + 16) != v79)
          {
            uint64_t v83 = *(_DWORD *)(v82 + 32 * v83 + 8) & 0x7FFFFFFF;
            if (v83 == 0x7FFFFFFF) {
              goto LABEL_86;
            }
          }
          goto LABEL_87;
        }
      }
      else
      {
        uint64_t v82 = *(void *)(a3 + 104);
      }
LABEL_86:
      uint64_t v83 = 0x7FFFFFFFLL;
LABEL_87:
      unint64_t v16 = v82 + 32 * v83;
      memset(v135, 0, 36);
      *(void *)&long long v134 = 0;
      BYTE8(v134) = 0;
      *(void *)&v135[36] = 0x7FFFFFFFLL;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v135, (uint64_t)a4, 3);
      *(void *)&long long v134 = *(void *)(v16 + 24);
      BYTE8(v134) = v79 != 0;
      uint64_t v84 = re::HashTable<re::ecs2::Scene const*,re::HashTable<unsigned long long,re::SharedPtr<re::AudioSourceState>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(a3, v79);
      if (v84)
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v135, v84);
        unint64_t v17 = *(void *)(a5 + 16);
        if (v17 <= v14) {
          goto LABEL_142;
        }
        unint64_t v85 = qword_26AF9AF50;
        id v86 = (re *)strlen(*(const char **)(*(void *)(a5 + 32) + 24 * v14));
        uint64_t v87 = 0x9E3779B97F4A7C17;
        if (v86)
        {
          id v86 = (re *)MurmurHash3_x64_128(*(void *)(*(void *)(a5 + 32) + 24 * v14), (int)v86, 0, (unint64_t *)buf);
          uint64_t v87 = ((*(void *)&buf[8] - 0x61C8864680B583E9 + (*(void *)buf << 6) + (*(void *)buf >> 2)) ^ *(void *)buf)
              - 0x61C8864680B583E9;
        }
        unint64_t v88 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE";
        if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE" & 0x8000000000000000) != 0)
        {
          uint64_t v89 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_31MeshShadowPerSceneRenderingDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v90 = 5381;
          do
          {
            unint64_t v88 = v90;
            unsigned int v91 = *v89++;
            uint64_t v90 = (33 * v90) ^ v91;
          }
          while (v91);
        }
        unint64_t v92 = ((((v85 >> 2) + (v85 << 6) + v87) ^ v85) - 0x61C8864680B583E9 + (v88 << 6) + (v88 >> 2)) ^ v88;
        id v93 = re::globalAllocators(v86);
        uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v93[2] + 32))(v93[2], 72, 8);
        *(void *)uint64_t v94 = &unk_26E71A9A8;
        char v95 = BYTE8(v134);
        *(void *)(v94 + 8) = v134;
        *(unsigned char *)(v94 + 16) = v95;
        *(_DWORD *)(v94 + 56) = 0;
        *(void *)(v94 + 40) = 0;
        *(void *)(v94 + 48) = 0;
        *(_DWORD *)(v94 + 64) = 0;
        *(void *)(v94 + 24) = *(void *)v135;
        *(void *)(v94 + 32) = 0;
        *(void *)(v94 + 32) = *(void *)&v135[8];
        *(_OWORD *)unsigned int v135 = 0uLL;
        *(void *)(v94 + 40) = *(void *)&v135[16];
        *(void *)&v135[16] = 0;
        *(_OWORD *)(v94 + 48) = *(_OWORD *)&v135[24];
        *(_OWORD *)&v135[24] = xmmword_23436F740;
        unint64_t v96 = *v131;
        if (!*v131
          || (unint64_t v96 = v92 % *(unsigned int *)(a7 + 72),
              uint64_t v97 = *(unsigned int *)(*(void *)(a7 + 56) + 4 * v96),
              v97 == 0x7FFFFFFF))
        {
LABEL_99:
          uint64_t v99 = *(unsigned int *)(a7 + 84);
          if (v99 == 0x7FFFFFFF)
          {
            uint64_t v99 = *(unsigned int *)(a7 + 80);
            int v100 = v99;
            if (v99 == *(_DWORD *)(a7 + 72))
            {
              re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity((uint64_t)v131, 2 * *(_DWORD *)(a7 + 76));
              unint64_t v96 = v92 % *(unsigned int *)(a7 + 72);
              int v100 = *(_DWORD *)(a7 + 80);
            }
            *(_DWORD *)(a7 + 80) = v100 + 1;
            uint64_t v101 = *(void *)(a7 + 64);
            int v102 = *(_DWORD *)(v101 + 24 * v99);
          }
          else
          {
            uint64_t v101 = *(void *)(a7 + 64);
            int v102 = *(_DWORD *)(v101 + 24 * v99);
            *(_DWORD *)(a7 + 84) = v102 & 0x7FFFFFFF;
          }
          uint64_t v104 = 24 * v99;
          *(_DWORD *)(v101 + v104) = v102 | 0x80000000;
          *(_DWORD *)(*(void *)(a7 + 64) + v104) = *(_DWORD *)(*(void *)(a7 + 64) + 24 * v99) & 0x80000000 | *(_DWORD *)(*(void *)(a7 + 56) + 4 * v96);
          *(void *)(*(void *)(a7 + 64) + 24 * v99 + 8) = v92;
          *(void *)(*(void *)(a7 + 64) + 24 * v99 + 16) = v94;
          *(_DWORD *)(*(void *)(a7 + 56) + 4 * v96) = v99;
          ++*(_DWORD *)(a7 + 76);
          ++*(_DWORD *)(a7 + 88);
        }
        else
        {
          uint64_t v98 = *(void *)(a7 + 64);
          while (*(void *)(v98 + 24 * v97 + 8) != v92)
          {
            LODWORD(v97) = *(_DWORD *)(v98 + 24 * v97) & 0x7FFFFFFF;
            if (v97 == 0x7FFFFFFF) {
              goto LABEL_99;
            }
          }
        }
      }
      else
      {
        uint64_t v103 = *re::shadowLogObjects(0);
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = v79;
          _os_log_error_impl(&dword_233120000, v103, OS_LOG_TYPE_ERROR, "MeshShadowBuilder: In render data generation, world %llu has no receivers but the world still exists", buf, 0xCu);
        }
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v135);
      unint64_t v51 = a5;
      unint64_t v78 = *(void *)(a5 + 16);
      goto LABEL_108;
    }
LABEL_109:
    unint64_t v17 = v126;
    if (v126) {
      goto LABEL_110;
    }
    int v106 = 0;
    int v115 = 0;
    int v116 = 0;
    int v114 = 0;
LABEL_125:
    uint64_t v117 = v127[13];
    if (v117)
    {
      long long v118 = *(os_unfair_lock_s **)(v117 + 304);
      if (v118)
      {
        if (v115 && *(unsigned char *)(a5 + 104)) {
          re::PersistentShadowState::visualizeShadowClusterInfo((uint64_t)a2, *(os_unfair_lock_s **)(v117 + 304), (const StringID *)(a5 + 112), a5 + 144);
        }
        if (v106) {
          re::PersistentShadowState::visualizeShadowClusters(a2, v118);
        }
        if (v116) {
          re::PersistentShadowState::visualizeShadowMatrices(a2, v118);
        }
        if (v17) {
          re::PersistentShadowState::visualizeShadowPlanes(a2, v118);
        }
        if (v114) {
          re::PersistentShadowState::visualizeCullBoundingBoxes(a2, v118);
        }
      }
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + (v9 << 6) + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v9 << 6)) = a3;
  *(void *)(*(void *)(a1 + 16) + (v9 << 6) + 16) = *a4;
  uint64_t v13 = *(void *)(a1 + 16) + (v9 << 6);
  *(void *)(v13 + 56) = 0;
  *(_DWORD *)(v13 + 48) = 0;
  *(void *)(v13 + 32) = 0;
  *(void *)(v13 + 40) = 0;
  *(void *)(v13 + 24) = 0;
  uint64_t v14 = *(void *)(a5 + 8);
  *(void *)(v13 + 24) = *(void *)a5;
  *(void *)(v13 + 32) = v14;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  uint64_t v15 = *(void *)(v13 + 40);
  *(void *)(v13 + 40) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v15;
  uint64_t v16 = *(void *)(v13 + 56);
  *(void *)(v13 + 56) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v16;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v13 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      uint64_t v7 = *(void *)(a1 + 16);
      *(void *)&v13[16] = v7;
      *(void *)(a1 + 16) = v6;
      long long v9 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        uint64_t v11 = v7 + 16;
        do
        {
          if ((*(_DWORD *)(v11 - 8) & 0x80000000) != 0) {
            re::HashTable<unsigned long long,re::DynamicArray<unsigned int>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v11 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v11 - 16), v11, v11 + 8);
          }
          v11 += 64;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::FixedArray<re::ShadowInfo::BlurInfo>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >= 0x469EE58469EE59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 928, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 928 * a3, 16);
  a1[2] = v5;
  if (!v5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v7 = (char *)v5;
  unint64_t v8 = a3 - 1;
  if (v8)
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      bzero(v7, 0x3A0uLL);
      for (uint64_t j = 0; j != 896; j += 224)
      {
        uint64_t v11 = &v7[j];
        *((_OWORD *)v11 + 7) = 0uLL;
        *((_OWORD *)v11 + 8) = 0uLL;
        *((_OWORD *)v11 + 5) = 0uLL;
        *((_OWORD *)v11 + 6) = 0uLL;
        *((_OWORD *)v11 + 3) = 0uLL;
        *((_OWORD *)v11 + 4) = 0uLL;
        *((_OWORD *)v11 + 10) = 0uLL;
        *((_OWORD *)v11 + 11) = 0uLL;
        *((_OWORD *)v11 + 12) = 0uLL;
        *((_OWORD *)v11 + 13) = 0uLL;
      }
      v7 += 928;
    }
  }
  bzero(v7, 0x3A0uLL);
  for (uint64_t k = 0; k != 896; k += 224)
  {
    uint64_t v13 = &v7[k];
    *((_OWORD *)v13 + 7) = 0uLL;
    *((_OWORD *)v13 + 8) = 0uLL;
    *((_OWORD *)v13 + 5) = 0uLL;
    *((_OWORD *)v13 + 6) = 0uLL;
    *((_OWORD *)v13 + 3) = 0uLL;
    *((_OWORD *)v13 + 4) = 0uLL;
    *((_OWORD *)v13 + 10) = 0uLL;
    *((_OWORD *)v13 + 11) = 0uLL;
    *((_OWORD *)v13 + 12) = 0uLL;
    *((_OWORD *)v13 + 13) = 0uLL;
  }
}

void re::FixedArray<half>::init<>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 < 0)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 2, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 2 * a3;
  uint64_t v6 = (_WORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 2 * a3, 2);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  unint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 2);
    unint64_t v8 = (_WORD *)((char *)v8 + v5 - 2);
  }
  *unint64_t v8 = 0;
}

uint64_t re::Optional<re::PersistentShadowRenderingData>::Optional(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 1;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 44) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 8), (uint64_t *)a2);
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 48);
  *(void *)(a1 + 64) = v4;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v5 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v5;
  uint64_t v6 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v6;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(a1 + 80);
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 132) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 96), (uint64_t *)(a2 + 88));
  *(void *)(a1 + 144) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  uint64_t v7 = *(void *)(a2 + 152);
  *(void *)(a1 + 152) = *(void *)(a2 + 144);
  *(void *)(a1 + 160) = v7;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  uint64_t v8 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = *(void *)(a2 + 160);
  *(void *)(a2 + 160) = v8;
  return a1;
}

uint64_t re::FixedArray<re::MeshReceiverPerShadowConstants>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (!a3) {
    return result;
  }
  if (a3 >= 0x2AAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 96, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = result;
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 96 * a3, 16);
  *(void *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_DWORD *)(result + 88) = 0;
      *(_OWORD *)uint64_t result = 0uLL;
      *(_OWORD *)(result + 16) = 0uLL;
      *(_OWORD *)(result + 32) = 0uLL;
      *(_OWORD *)(result + 48) = 0uLL;
      *(_OWORD *)(result + 64) = 0uLL;
      *(void *)(result + 78) = 0;
      result += 96;
      --v6;
    }
    while (v6);
  }
  *(_DWORD *)(result + 88) = 0;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(void *)(result + 78) = 0;
  return result;
}

uint64_t re::FixedArray<re::MeshShadowDepthPrepassReceiverParametersCPU>::deinit(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t v3 = a1[1];
    if (v3)
    {
      uint64_t v4 = a1[2] + 112 * v3;
      uint64_t v5 = a1[2];
      do
      {
        *(void *)uint64_t v5 = 0;
        ++*(_DWORD *)(v5 + 8);
        v5 += 112;
      }
      while (v5 != v4);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return result;
}

uint64_t *re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>::~RenderGraphDataStoreWrapper(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E71A8E8;
  uint64_t v2 = a1 + 20;
  re::FixedArray<re::MeshShadowDepthPrepassReceiverParametersCPU>::deinit(a1 + 59);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::FixedArray<CoreIKTransform>::deinit(v2);
  re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 10);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 6);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 3);
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::MeshShadowGenerationData>::~RenderGraphDataStoreWrapper(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E71A8E8;
  uint64_t v2 = a1 + 20;
  re::FixedArray<re::MeshShadowDepthPrepassReceiverParametersCPU>::deinit(a1 + 59);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::FixedArray<CoreIKTransform>::deinit(v2);
  re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 10);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 6);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 3);
  JUMPOUT(0x237DBCBD0);
}

void *re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneGenerationData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A928;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 1);
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneGenerationData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A928;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::RenderGraphDataStoreWrapper<re::MeshShadowRenderingData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A968;
  re::FixedArray<CoreIKTransform>::deinit(a1 + 4);
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::MeshShadowRenderingData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A968;
  re::FixedArray<CoreIKTransform>::deinit(a1 + 4);
  JUMPOUT(0x237DBCBD0);
}

void *re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneRenderingData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A9A8;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 3);
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::MeshShadowPerSceneRenderingData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71A9A8;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 3);
  JUMPOUT(0x237DBCBD0);
}

re *re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::ARSegmentationEmitterCache *this, re::RenderGraphManager *a2)
{
  void v17[5] = *MEMORY[0x263EF8340];
  uint64_t result = (re *)re::FontID::isValid((re::ARSegmentationEmitterCache *)((char *)this + 64));
  if ((result & 1) == 0)
  {
    uint64_t v5 = re::globalAllocators(result);
    uint64_t v6 = v5[2];
    v17[0] = &unk_26E71AC70;
    void v17[3] = v6;
    v17[4] = v17;
    uint64_t v7 = re::globalAllocators((re *)v5)[2];
    v16[0] = &unk_26E71ACC8;
    void v16[3] = v7;
    v16[4] = v16;
    re::RenderGraphManager::addProvider(a2, "ARSegmentationCache", (uint64_t)v17, (uint64_t)v16, 0, (uint64_t)&v12);
    uint64_t v8 = v12;
    long long v9 = v13;
    uint64_t v12 = 0;
    uint64_t v13 = "";
    uint64_t v10 = *((void *)this + 8);
    uint64_t v11 = *((void *)this + 9);
    *((void *)this + 8) = v8;
    *((void *)this + 9) = v9;
    v15[0] = v8 & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
    v15[1] = v11;
    re::StringID::destroyString((re::StringID *)v15);
    *((void *)this + 10) = v14;
    re::StringID::destroyString((re::StringID *)&v12);
    re::FunctionBase<24ul,void ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v16);
    return (re *)re::FunctionBase<24ul,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v17);
  }
  return result;
}

void re::ARSegmentationEmitterCache::unregisterRenderGraphProvider(re::ARSegmentationEmitterCache *this, re::RenderGraphManager *a2)
{
  uint64_t v4 = (StringID *)((char *)this + 64);
  if (re::FontID::isValid((re::ARSegmentationEmitterCache *)((char *)this + 64)))
  {
    re::StringID::StringID((re::StringID *)v5, v4);
    uint64_t v6 = *((void *)this + 10);
    re::RenderGraphManager::removeProvider((uint64_t)a2, (uint64_t)v5);
    re::StringID::destroyString((re::StringID *)v5);
    re::ProviderHandle::invalidate((re::ProviderHandle *)v4);
  }
}

void re::ARSegmentationEmitterCache::applyCachedDataToGraph(void **this, const re::ARSegmentationConnectionData *a2, id **a3, const char *a4)
{
  if (re::ARSegmentationEmitterCache::changeSpecification((int32x4_t *)this, (uint64_t)a2)) {
    re::ARSegmentationEmitterCache::reallocateCachedData(this, a3[1]);
  }
  re::ARSegmentationEmitterCache::setTexturesOnLanes(this, (re::RenderFrame *)a3, a4);
}

BOOL re::ARSegmentationEmitterCache::changeSpecification(int32x4_t *a1, uint64_t a2)
{
  *(int32x2_t *)v2.unint64_t i8 = vrev64_s32(*(int32x2_t *)(a2 + 16));
  v3.i64[0] = v2.i64[0];
  v3.i64[1] = *(void *)(a2 + 36);
  int8x16_t v4 = (int8x16_t)vceqq_s32(a1[3], v3);
  char v5 = vaddvq_s32((int32x4_t)vbicq_s8((int8x16_t)xmmword_2343978C0, v4));
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8(v4))))
  {
    v2.i64[1] = *(void *)(a2 + 36);
    a1[3] = v2;
  }
  return (v5 & 0xF) != 0;
}

void re::ARSegmentationEmitterCache::reallocateCachedData(void **this, id *a2)
{
  int32x4_t v3 = a2 + 23;
  id v4 = a2[23];
  id v5 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v5, sel_setWidth_, *((unsigned int *)this + 13));
  objc_msgSend(v5, sel_setHeight_, *((unsigned int *)this + 12));
  objc_msgSend(v5, sel_setUsage_, 3);
  objc_msgSend(v5, sel_setStorageMode_, 2);
  objc_msgSend(v5, sel_setPixelFormat_, *((int *)this + 14));
  re::mtl::Device::makeTexture(v5, v3, &v6);
  NS::SharedPtr<MTL::Texture>::operator=(this + 3, &v6);
  if (v6) {

  }
  objc_msgSend(v5, sel_setPixelFormat_, *((int *)this + 14));
  re::mtl::Device::makeTexture(v5, v3, &v6);
  NS::SharedPtr<MTL::Texture>::operator=(this + 4, &v6);
  if (v6) {

  }
  objc_msgSend(v5, sel_setPixelFormat_, *((int *)this + 15));
  re::mtl::Device::makeTexture(v5, v3, &v6);
  NS::SharedPtr<MTL::Texture>::operator=(this + 5, &v6);
  if (v6) {

  }
  if (v5) {
}
  }

void re::ARSegmentationEmitterCache::setTexturesOnLanes(id *this, re::RenderFrame *a2, const char *a3)
{
  if (a3)
  {
    uint64_t v6 = *a3;
    if (*a3)
    {
      char v7 = a3[1];
      if (v7)
      {
        uint64_t v8 = a3 + 2;
        do
        {
          uint64_t v6 = 31 * v6 + v7;
          int v9 = *(unsigned __int8 *)v8++;
          char v7 = v9;
        }
        while (v9);
      }
      v6 &= ~0x8000000000000000;
    }
  }
  else
  {
    uint64_t v6 = 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v17 = v6;
  id v10 = this[3];
  uint64_t v15 = re::kARSegmentationTextureFG & 0x7FFFFFFFFFFFFFFFLL;
  id v16 = v10;
  re::RenderFrame::registerExternalTexture((uint64_t)a2, &v16, &v15, &v17, 0);
  if (v10) {

  }
  id v11 = this[4];
  id v14 = v11;
  uint64_t v15 = re::kARSegmentationTextureBG & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::registerExternalTexture((uint64_t)a2, &v14, &v15, &v17, 0);
  if (v11) {

  }
  id v12 = this[5];
  id v13 = v12;
  uint64_t v15 = re::kARSegmentationTextureDilatedDepth & 0x7FFFFFFFFFFFFFFFLL;
  re::RenderFrame::registerExternalTexture((uint64_t)a2, &v13, &v15, &v17, 0);
  if (v12) {

  }
  re::RenderFrame::emitGraph(a2, "ARSegmentationCache", a3);
}

uint64_t re::createARSegmentationGenerateGuideData@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void v15[2] = *MEMORY[0x263EF8340];
  {
    id v13 = a2;
    a2 = v13;
    if (v14)
    {
      re::createARSegmentationGenerateGuideData(re::RenderFrame &,re::RenderSceneContext &)::kARSegmentationDataTypeunint64_t ScopeHash = re::hashString((re *)"ARSegmentationData", v13);
      a2 = v13;
    }
  }
  unint64_t v5 = 0x9E3779B97F4A7C17;
  unint64_t v6 = re::createARSegmentationGenerateGuideData(re::RenderFrame &,re::RenderSceneContext &)::kARSegmentationDataTypeScopeHash;
  char v7 = (const char *)*((void *)a2 + 7);
  size_t v8 = strlen(v7);
  if (v8)
  {
    MurmurHash3_x64_128((uint64_t)v7, v8, 0, v15);
    unint64_t v5 = ((v15[1] - 0x61C8864680B583E9 + (v15[0] << 6) + (v15[0] >> 2)) ^ v15[0]) - 0x61C8864680B583E9;
  }
  uint64_t v9 = re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(a1 + 32, ((v6 >> 2) + (v6 << 6) + v5) ^ v6);
  *(void *)a3 = &unk_26E71AD20;
  *(void *)(a3 + 32) = 0x7300000046;
  *(_DWORD *)(a3 + 40) = 25;
  if (v9)
  {
    uint64_t v10 = v9;
    *(_DWORD *)(a3 + 8) = objc_msgSend(*(id *)(v9 + 8), sel_width);
    *(_DWORD *)(a3 + 12) = objc_msgSend(*(id *)(v10 + 32), sel_height);
    *(_DWORD *)(a3 + 16) = objc_msgSend(*(id *)(v10 + 8), sel_width);
    uint64_t result = (uint64_t)objc_msgSend(*(id *)(v10 + 8), sel_height);
    int v12 = -1;
  }
  else
  {
    *(void *)(a3 + 8) = 0x100000001;
    uint64_t result = 1;
    *(_DWORD *)(a3 + 16) = 1;
    int v12 = 1;
  }
  *(_DWORD *)(a3 + 20) = result;
  *(_DWORD *)(a3 + 24) = v12;
  *(_DWORD *)(a3 + 28) = v12;
  return result;
}

uint64_t re::ARSegmentationDilationNode::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  v10[0] = 0;
  uint64_t v16 = 0;
  memset(v14, 0, sizeof(v14));
  int v15 = 0;
  __int16 v17 = 257;
  char v18 = 0;
  uint64_t v19 = 0;
  char v20 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v10);
  NS::SharedPtr<MTL::Texture>::operator=(this + 37, ComputePipelineState);
  re::RenderGraphNode::configure((re::RenderGraphNode *)this, a2, a3, a4);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v14);
  uint64_t result = v13[0];
  if (v13[0])
  {
    if (v13[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v13[0] + 40))();
    }
    memset(v13, 0, sizeof(v13));
  }
  if (v10[0])
  {
    uint64_t result = v11;
    if (v11)
    {
      if (v12) {
        return (*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  return result;
}

void re::ARSegmentationDilationNode::setup(re::ARSegmentationDilationNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0x500000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  int v9 = 0;
  int v10 = 0;
  re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 280, (uint64_t)&v6);
  re::RenderGraphNode::setup(this, a2, a3);
}

void re::ARSegmentationDilationNode::execute(id *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::get<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v5 = re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  uint64_t v6 = re::RenderGraphDataStore::tryGet<re::ARSegmentationExecuteData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  if (v5)
  {
    uint64_t v7 = v6;
    unsigned int v8 = objc_msgSend(this[37], sel_threadExecutionWidth);
    uint64_t v9 = objc_msgSend(this[37], sel_maxTotalThreadsPerThreadgroup) / v8;
    int v10 = *(_DWORD *)(v7 + 8);
    void v16[2] = v10;
    unsigned __int16 v11 = v9 - 2 * v10;
    v16[1] = v11;
    v16[0] = v8 - 2 * v10;
    unint64_t v12 = (objc_msgSend(*(id *)(v5 + 8), sel_width) + v16[0] - 1) / v16[0];
    unint64_t v13 = (objc_msgSend(*(id *)(v5 + 8), sel_height) + v11 - 1) / v11;
    int v14 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
    re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v14, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v15);
    [v15 setComputePipelineState:this[37]];
    [v15 setTexture:*(void *)(v5 + 8) atIndex:0];
    [v15 setTexture:*(void *)(v5 + 16) atIndex:1];
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)(this + 35), 0, 0, v18);
    [v15 setTexture:v18[0] atIndex:2];
    if (v18[0]) {

    }
    [v15 setBytes:v16 length:8 atIndex:0];
    [v15 setThreadgroupMemoryLength:4 * v9 * v8 atIndex:0];
    [v15 setThreadgroupMemoryLength:2 * v9 * v8 atIndex:1];
    v18[0] = (id)v12;
    v18[1] = (id)v13;
    void v18[2] = (id)1;
    v17[0] = v8;
    v17[1] = v9;
    void v17[2] = 1;
    [v15 dispatchThreadgroups:v18 threadsPerThreadgroup:v17];
  }
}

void re::ARSegmentationGenerateGuideNode::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  v11[0] = 0;
  uint64_t v20 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  int v19 = 0;
  __int16 v21 = 257;
  char v22 = 0;
  uint64_t v23 = 0;
  char v24 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v11);
  NS::SharedPtr<MTL::Texture>::operator=(this + 39, ComputePipelineState);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v16);
  uint64_t v9 = (_anonymous_namespace_ *)v14;
  if ((void)v14)
  {
    if (BYTE8(v14)) {
      uint64_t v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = 0u;
    long long v15 = 0u;
  }
  if (v11[0])
  {
    uint64_t v9 = v12;
    if (v12)
    {
      if (v13) {
        uint64_t v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v12 + 40))();
      }
    }
  }
  v11[0] = 0;
  uint64_t v20 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  int v19 = 0;
  __int16 v21 = 257;
  char v22 = 0;
  uint64_t v23 = 0;
  char v24 = 0;
  int v10 = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v11);
  NS::SharedPtr<MTL::Texture>::operator=(this + 40, v10);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v16);
  if ((void)v14)
  {
    if (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = 0u;
    long long v15 = 0u;
  }
  if (v11[0] && v12 && (v13 & 1) != 0) {
    (*(void (**)(void))(*(void *)v12 + 40))();
  }
  re::RenderGraphNode::configure((re::RenderGraphNode *)this, a2, a3, a4);
}

uint64_t re::ARSegmentationGenerateGuideNode::setup(re::ARSegmentationGenerateGuideNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v5 = (char *)this + 280;
  v7[0] = 0x500000000;
  long long v8 = xmmword_23435FBB0;
  __int16 v9 = 0;
  uint64_t v10 = 0;
  re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 280, (uint64_t)v7);
  *(_DWORD *)((char *)v7 + 3) = 0;
  LODWORD(v7[0]) = 0;
  v7[1] = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)v5, (uint64_t)v7);
  v7[0] = 0x500000000;
  long long v8 = xmmword_23435FBB0;
  __int16 v9 = 0;
  uint64_t v10 = 0;
  uint64_t result = re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 296, (uint64_t)v7);
  *((unsigned char *)a2 + 593) = 1;
  return result;
}

void re::ARSegmentationGenerateGuideNode::execute(re::ARSegmentationGenerateGuideNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::get<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v5 = (id *)re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  uint64_t v6 = re::RenderGraphDataStore::tryGet<re::ARSegmentationExecuteData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  if (v5)
  {
    uint64_t v19 = v6;
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 280, 0, 0, &v23);
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 296, 0, 0, &v22);
    re::RenderGraphContext::makeComputeCommandEncoder(a2, 0, &v21);
    float v7 = (float)(unint64_t)objc_msgSend(v5[3], sel_width);
    id v8 = objc_msgSend(v5[4], sel_width);
    if ((float)(unint64_t)v8 < v7) {
      float v7 = (float)(unint64_t)v8;
    }
    unsigned int v20 = vcvtps_u32_f32(v7 / (float)(unint64_t)objc_msgSend(v5[1], sel_width));
    [v21 setComputePipelineState:*((void *)this + 39)];
    [v21 setTexture:v5[3] atIndex:0];
    [v21 setTexture:v5[4] atIndex:1];
    [v21 setTexture:v23 atIndex:2];
    [v21 setBytes:&v20 length:4 atIndex:0];
    unsigned int v9 = objc_msgSend(*((id *)this + 39), sel_threadExecutionWidth);
    uint64_t v10 = objc_msgSend(*((id *)this + 39), sel_maxTotalThreadsPerThreadgroup) / v9;
    uint64_t v11 = (v9 + objc_msgSend(v23, sel_width) - 1) / v9;
    unsigned int v12 = objc_msgSend(v23, sel_height);
    uint64_t v27 = v11;
    uint64_t v28 = (v10 + v12 - 1) / v10;
    uint64_t v29 = 1;
    uint64_t v24 = v9;
    uint64_t v25 = v10;
    uint64_t v26 = 1;
    [v21 dispatchThreadgroups:&v27 threadsPerThreadgroup:&v24];
    [v21 setComputePipelineState:*((void *)this + 40)];
    [v21 setTexture:v23 atIndex:0];
    [v21 setTexture:v22 atIndex:1];
    [v21 setBytes:&v20 length:4 atIndex:0];
    unsigned int v13 = objc_msgSend(*((id *)this + 40), sel_threadExecutionWidth);
    uint64_t v14 = objc_msgSend(*((id *)this + 40), sel_maxTotalThreadsPerThreadgroup) / v13;
    uint64_t v15 = (v13 + objc_msgSend(v22, sel_width) - 1) / v13;
    unsigned int v16 = objc_msgSend(v22, sel_height);
    uint64_t v27 = v15;
    uint64_t v28 = (v14 + v16 - 1) / v14;
    uint64_t v29 = 1;
    uint64_t v24 = v13;
    uint64_t v25 = v14;
    uint64_t v26 = 1;
    [v21 dispatchThreadgroups:&v27 threadsPerThreadgroup:&v24];
    re::RenderGraphContext::finishEncoding<re::mtl::ComputeCommandEncoder &>((uint64_t)a2, &v21);
    id v17 = objc_retain(*(id *)(re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1)
                                                                                              + 104))
                            + 16));
    uint64_t v18 = *(void *)(v19 + 32);
    ++**(void **)(v19 + 40);
    objc_msgSend(v17, "encodeSignalEvent:value:", v18);

    if (v22) {
    if (v23)
    }
  }
}

uint64_t re::ARSegmentationDualGuidedFilterNode::setup(re::ARSegmentationDualGuidedFilterNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  *((unsigned char *)a2 + 593) = 1;
  *(_DWORD *)((char *)v6 + 3) = 0;
  LODWORD(v6[0]) = 0;
  v6[1] = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)this + 256, (uint64_t)v6);
  v6[0] = 0x500000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 272, (uint64_t)v6);
  v6[0] = 0x500000000;
  long long v7 = xmmword_23435FBB0;
  __int16 v8 = 0;
  uint64_t v9 = 0;
  return re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 288, (uint64_t)v6);
}

void re::ARSegmentationDualGuidedFilterNode::execute(re::ARSegmentationDualGuidedFilterNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::get<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v5 = re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  uint64_t v6 = re::RenderGraphDataStore::tryGet<re::ARSegmentationExecuteData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  if (v5)
  {
    uint64_t v7 = v6;
    __int16 v8 = (void **)(v6 + 24);
    id v9 = objc_retain(*(id *)(re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1)
                                                                                             + 104))
                           + 16));
    uint64_t v14 = v9;
    [v9 encodeWaitForEvent:*(void *)(v7 + 32) value:**(void **)(v7 + 40)];
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 256, 0, 0, &v13);
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 272, 0, 0, &v12);
    re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 288, 0, 0, &v11);
    re::ar::DualGuidedFilter::encodeDualCoefficients(v8, &v14, &v13, (void **)(v5 + 8), &v12, (uint64_t *)&v11);
    uint64_t v10 = *(void *)(v7 + 32);
    ++**(void **)(v7 + 40);
    objc_msgSend(v9, "encodeSignalEvent:value:", v10);
    if (v11) {

    }
    if (v12) {
    if (v13)
    }
  }
}

void re::ARSegmentationCompositeNode::execute(re::ARSegmentationCompositeNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = re::RenderGraphDataStore::get<re::SceneScope>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  uint64_t v5 = re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  uint64_t v6 = re::RenderGraphDataStore::tryGet<re::ARSegmentationExecuteData>(*((void *)a2 + 146), *(const char **)(v4 + 8));
  if (v5)
  {
    uint64_t v7 = v6;
    id v8 = objc_retain(*(id *)(re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1)
                                                                                             + 104))
                           + 16));
    [v8 encodeWaitForEvent:*(void *)(v7 + 32) value:**(void **)(v7 + 40)];
    id v9 = (void *)(*(void *)a2 + 368);
    uint64_t v20 = 0x5739F99E7C0200E3;
    re::DynamicTextureTableAdd(v9, &v20, (id *)(v5 + 24));
    uint64_t v10 = (void *)(*(void *)a2 + 368);
    uint64_t v20 = 0x239F7200ED1CA884;
    re::DynamicTextureTableAdd(v10, &v20, (id *)(v5 + 32));
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 8uLL, 8uLL, (uint64_t)&v20);
    uint64_t v11 = v22;
    unint64_t v12 = v21 | ((unint64_t)HIDWORD(v21) << 32);
    *(void *)(v20 + v21) = *(void *)(v7 + 16);
    id v13 = (re::BufferTable *)(*(void *)a2 + 480);
    uint64_t v19 = 0x3A4249E1C0094FBALL;
    uint64_t v20 = v11;
    unint64_t v21 = v12;
    re::BufferTable::setBuffer(v13, (const re::WeakStringID *)&v19, (const BufferView *)&v20);
    re::RenderGraphFullscreenNode::executeInternal(this, a2, (re::ARSegmentationCompositeNode *)((char *)this + 264));
    uint64_t v14 = (re *)(*(void *)a2 + 368);
    uint64_t v20 = 0x5739F99E7C0200E3;
    re::DynamicTextureTableRemove(v14, (re::TextureTable *)&v20, v15);
    unsigned int v16 = (re *)(*(void *)a2 + 368);
    uint64_t v20 = 0x239F7200ED1CA884;
    re::DynamicTextureTableRemove(v16, (re::TextureTable *)&v20, v17);
    uint64_t v18 = (re::BufferTable *)(*(void *)a2 + 480);
    uint64_t v20 = 0x3A4249E1C0094FBALL;
    re::BufferTable::removeBuffer(v18, (const re::WeakStringID *)&v20);
  }
}

void *re::allocInfo_ARSegmentationConnectionData(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_446, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_446))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B070, "ARSegmentationConnectionData");
    __cxa_guard_release(&_MergedGlobals_446);
  }
  return &unk_26AF9B070;
}

void re::initInfo_ARSegmentationConnectionData(re *this, re::IntrospectionBase *a2)
{
  v45[0] = 0x938F17887DE011F6;
  v45[1] = "ARSegmentationConnectionData";
  re::StringID::destroyString((re::StringID *)v45);
  *((_OWORD *)this + 2) = v46;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF78, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AF78);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphData((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphData";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B020 = v7;
      id v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_uint32_t((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "guideScratchWidth";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9B028 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_uint32_t((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "guideScratchHeight";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0xC00000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9B030 = v15;
      unsigned int v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_uint32_t((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "guideWidth";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x1000000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9B038 = v19;
      uint64_t v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_uint32_t((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "guideHeight";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x1400000004;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF9B040 = v23;
      uint64_t v24 = re::introspectionAllocator((re *)v23);
      uint64_t v26 = re::introspect_uint32_t((re *)1, v25);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "compositionAlphaWidth";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x1800000005;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF9B048 = v27;
      uint64_t v28 = re::introspectionAllocator((re *)v27);
      uint64_t v30 = re::introspect_uint32_t((re *)1, v29);
      uint64_t v31 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v28 + 32))(v28, 72, 8);
      *(_DWORD *)uint64_t v31 = 1;
      *(void *)(v31 + 8) = "compositionAlphaHeight";
      *(void *)(v31 + 16) = v30;
      *(void *)(v31 + 24) = 0;
      *(void *)(v31 + 32) = 0x1C00000006;
      *(_DWORD *)(v31 + 40) = 0;
      *(void *)(v31 + 48) = 0;
      *(void *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_26AF9B050 = v31;
      unint64_t v32 = re::introspectionAllocator((re *)v31);
      uint64_t v34 = re::mtl::introspect_PixelFormat((re::mtl *)1, v33);
      uint64_t v35 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 72, 8);
      *(_DWORD *)uint64_t v35 = 1;
      *(void *)(v35 + 8) = "guideFormat";
      *(void *)(v35 + 16) = v34;
      *(void *)(v35 + 24) = 0;
      *(void *)(v35 + 32) = 0x2000000007;
      *(_DWORD *)(v35 + 40) = 0;
      *(void *)(v35 + 48) = 0;
      *(void *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_26AF9B058 = v35;
      float32x4_t v36 = re::introspectionAllocator((re *)v35);
      float v38 = re::mtl::introspect_PixelFormat((re::mtl *)1, v37);
      uint64_t v39 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 72, 8);
      *(_DWORD *)uint64_t v39 = 1;
      *(void *)(v39 + 8) = "coefficientsFormat";
      *(void *)(v39 + 16) = v38;
      *(void *)(v39 + 24) = 0;
      *(void *)(v39 + 32) = 0x2400000008;
      *(_DWORD *)(v39 + 40) = 0;
      *(void *)(v39 + 48) = 0;
      *(void *)(v39 + 56) = 0;
      *(_DWORD *)(v39 + 64) = 0;
      qword_26AF9B060 = v39;
      int v40 = re::introspectionAllocator((re *)v39);
      uint64_t v42 = re::mtl::introspect_PixelFormat((re::mtl *)1, v41);
      uint64_t v43 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 72, 8);
      *(_DWORD *)uint64_t v43 = 1;
      *(void *)(v43 + 8) = "dilatedFormat";
      *(void *)(v43 + 16) = v42;
      *(void *)(v43 + 24) = 0;
      *(void *)(v43 + 32) = 0x2800000009;
      *(_DWORD *)(v43 + 40) = 0;
      *(void *)(v43 + 48) = 0;
      *(void *)(v43 + 56) = 0;
      *(_DWORD *)(v43 + 64) = 0;
      qword_26AF9B068 = v43;
      __cxa_guard_release(&qword_26AF9AF78);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 10;
  *((void *)this + 8) = &qword_26AF9B020;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ARSegmentationConnectionData>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ARSegmentationConnectionData>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ARSegmentationConnectionData>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ARSegmentationConnectionData>;
  re::IntrospectionRegistry::add(this, v3);
  long long v44 = v46;
}

void re::internal::defaultConstruct<re::ARSegmentationConnectionData>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = &unk_26E71AD20;
}

void *re::internal::defaultConstructV2<re::ARSegmentationConnectionData>(void *result)
{
  re *result = &unk_26E71AD20;
  return result;
}

uint64_t re::introspect_ARSegmentationConnectionData(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ARSegmentationConnectionData", (uint64_t (*)(re::internal *))re::allocInfo_ARSegmentationConnectionData, (re::IntrospectionBase *(*)(void))re::initInfo_ARSegmentationConnectionData, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ARSegmentationConnectionData>, this);
}

void *re::allocInfo_ARSegmentationDilationNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF80, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AF80))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B0E8, "ARSegmentationDilationNode");
    __cxa_guard_release(&qword_26AF9AF80);
  }
  return &unk_26AF9B0E8;
}

void re::initInfo_ARSegmentationDilationNode(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0xCBB585821370F806;
  v17[1] = "ARSegmentationDilationNode";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF88, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AF88);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9AFC8 = v7;
      id v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "library";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AFD0 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_RenderGraphTargetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "dilatedDepthTexture";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11800000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9AFD8 = v15;
      __cxa_guard_release(&qword_26AF9AF88);
    }
  }
  *((void *)this + 2) = 0x13000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF9AFC8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ARSegmentationDilationNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ARSegmentationDilationNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ARSegmentationDilationNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ARSegmentationDilationNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

double re::internal::defaultConstruct<re::ARSegmentationDilationNode>(int a1, int a2, re::RenderGraphNode *this)
{
  int32x4_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)int32x4_t v3 = &unk_26E71A9D0;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  double result = NAN;
  *((void *)v3 + 36) = -1;
  *((void *)v3 + 37) = 0;
  return result;
}

void re::internal::defaultDestruct<re::ARSegmentationDilationNode>(int a1, int a2, re::ARSegmentationDilationNode *this)
{
}

double re::internal::defaultConstructV2<re::ARSegmentationDilationNode>(re::RenderGraphNode *a1)
{
  unsigned int v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)unsigned int v1 = &unk_26E71A9D0;
  *((_OWORD *)v1 + 16) = 0u;
  *((_OWORD *)v1 + 17) = 0u;
  double result = NAN;
  *((void *)v1 + 36) = -1;
  *((void *)v1 + 37) = 0;
  return result;
}

uint64_t re::introspect_ARSegmentationDilationNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ARSegmentationDilationNode", (uint64_t (*)(re::internal *))re::allocInfo_ARSegmentationDilationNode, (re::IntrospectionBase *(*)(void))re::initInfo_ARSegmentationDilationNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ARSegmentationDilationNode>, this);
}

void *re::allocInfo_ARSegmentationGenerateGuideNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF90, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AF90))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B160, "ARSegmentationGenerateGuideNode");
    __cxa_guard_release(&qword_26AF9AF90);
  }
  return &unk_26AF9B160;
}

void re::initInfo_ARSegmentationGenerateGuideNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0x475A9A5066DB65ECLL;
  v21[1] = "ARSegmentationGenerateGuideNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AF98, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AF98);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9AFE0 = v7;
      id v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_AssetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "library";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9AFE8 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_RenderGraphTargetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "guideScratchTexture";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11800000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9AFF0 = v15;
      long long v16 = re::introspectionAllocator((re *)v15);
      long long v18 = re::introspect_RenderGraphTargetHandle((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "guideTexture";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x12800000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9AFF8 = v19;
      __cxa_guard_release(&qword_26AF9AF98);
    }
  }
  *((void *)this + 2) = 0x14800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9AFE0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ARSegmentationGenerateGuideNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ARSegmentationGenerateGuideNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ARSegmentationGenerateGuideNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ARSegmentationGenerateGuideNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

double re::internal::defaultConstruct<re::ARSegmentationGenerateGuideNode>(int a1, int a2, re::RenderGraphNode *this)
{
  int32x4_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)int32x4_t v3 = &unk_26E71AA78;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  double result = NAN;
  *((void *)v3 + 36) = -1;
  *((void *)v3 + 37) = 0;
  *((void *)v3 + 38) = -1;
  *((void *)v3 + 39) = 0;
  *((void *)v3 + 40) = 0;
  return result;
}

void re::internal::defaultDestruct<re::ARSegmentationGenerateGuideNode>(int a1, int a2, re::ARSegmentationGenerateGuideNode *this)
{
}

double re::internal::defaultConstructV2<re::ARSegmentationGenerateGuideNode>(re::RenderGraphNode *a1)
{
  unsigned int v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)unsigned int v1 = &unk_26E71AA78;
  *((_OWORD *)v1 + 16) = 0u;
  *((_OWORD *)v1 + 17) = 0u;
  double result = NAN;
  *((void *)v1 + 36) = -1;
  *((void *)v1 + 37) = 0;
  *((void *)v1 + 38) = -1;
  *((void *)v1 + 39) = 0;
  *((void *)v1 + 40) = 0;
  return result;
}

uint64_t re::introspect_ARSegmentationGenerateGuideNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ARSegmentationGenerateGuideNode", (uint64_t (*)(re::internal *))re::allocInfo_ARSegmentationGenerateGuideNode, (re::IntrospectionBase *(*)(void))re::initInfo_ARSegmentationGenerateGuideNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ARSegmentationGenerateGuideNode>, this);
}

void *re::allocInfo_ARSegmentationDualGuidedFilterNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AFA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AFA0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B1D8, "ARSegmentationDualGuidedFilterNode");
    __cxa_guard_release(&qword_26AF9AFA0);
  }
  return &unk_26AF9B1D8;
}

void re::initInfo_ARSegmentationDualGuidedFilterNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0x9399778B94A360A2;
  v21[1] = "ARSegmentationDualGuidedFilterNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AFA8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AFA8);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B000 = v7;
      id v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_RenderGraphTargetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "guideTexture";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9B008 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_RenderGraphTargetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "coefficientsTextureFG";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x11000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9B010 = v15;
      long long v16 = re::introspectionAllocator((re *)v15);
      long long v18 = re::introspect_RenderGraphTargetHandle((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "coefficientsTextureBG";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x12000000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9B018 = v19;
      __cxa_guard_release(&qword_26AF9AFA8);
    }
  }
  *((void *)this + 2) = 0x13000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9B000;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ARSegmentationDualGuidedFilterNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ARSegmentationDualGuidedFilterNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ARSegmentationDualGuidedFilterNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ARSegmentationDualGuidedFilterNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

double re::internal::defaultConstruct<re::ARSegmentationDualGuidedFilterNode>(int a1, int a2, re::RenderGraphNode *this)
{
  int32x4_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)int32x4_t v3 = &unk_26E71AB20;
  *((void *)v3 + 32) = 0;
  double result = NAN;
  *((void *)v3 + 33) = -1;
  *((void *)v3 + 34) = 0;
  *((void *)v3 + 35) = -1;
  *((void *)v3 + 36) = 0;
  *((void *)v3 + 37) = -1;
  return result;
}

void re::internal::defaultDestruct<re::ARSegmentationDualGuidedFilterNode>(int a1, int a2, id *this)
{
}

double re::internal::defaultConstructV2<re::ARSegmentationDualGuidedFilterNode>(re::RenderGraphNode *a1)
{
  unsigned int v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)unsigned int v1 = &unk_26E71AB20;
  *((void *)v1 + 32) = 0;
  double result = NAN;
  *((void *)v1 + 33) = -1;
  *((void *)v1 + 34) = 0;
  *((void *)v1 + 35) = -1;
  *((void *)v1 + 36) = 0;
  *((void *)v1 + 37) = -1;
  return result;
}

uint64_t re::introspect_ARSegmentationDualGuidedFilterNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ARSegmentationDualGuidedFilterNode", (uint64_t (*)(re::internal *))re::allocInfo_ARSegmentationDualGuidedFilterNode, (re::IntrospectionBase *(*)(void))re::initInfo_ARSegmentationDualGuidedFilterNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ARSegmentationDualGuidedFilterNode>, this);
}

void *re::allocInfo_ARSegmentationCompositeNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AFB0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9AFB0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B250, "ARSegmentationCompositeNode");
    __cxa_guard_release(&qword_26AF9AFB0);
  }
  return &unk_26AF9B250;
}

void re::initInfo_ARSegmentationCompositeNode(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0x9962540693657AECLL;
  v9[1] = "ARSegmentationCompositeNode";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9AFC0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9AFC0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9AFB8 = v7;
      __cxa_guard_release(&qword_26AF9AFC0);
    }
  }
  *((void *)this + 2) = 0x1E800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF9AFB8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ARSegmentationCompositeNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ARSegmentationCompositeNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ARSegmentationCompositeNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ARSegmentationCompositeNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

double re::internal::defaultConstruct<re::ARSegmentationCompositeNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  int32x4_t v3 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)int32x4_t v3 = &unk_26E71ABC8;
  *((void *)v3 + 57) = 0;
  double result = NAN;
  *((void *)v3 + 58) = -1;
  *((void *)v3 + 59) = 0;
  *((void *)v3 + 60) = -1;
  return result;
}

void re::internal::defaultDestruct<re::ARSegmentationCompositeNode>(int a1, int a2, id *this)
{
}

double re::internal::defaultConstructV2<re::ARSegmentationCompositeNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unsigned int v1 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)unsigned int v1 = &unk_26E71ABC8;
  *((void *)v1 + 57) = 0;
  double result = NAN;
  *((void *)v1 + 58) = -1;
  *((void *)v1 + 59) = 0;
  *((void *)v1 + 60) = -1;
  return result;
}

uint64_t re::introspect_ARSegmentationCompositeNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ARSegmentationCompositeNode", (uint64_t (*)(re::internal *))re::allocInfo_ARSegmentationCompositeNode, (re::IntrospectionBase *(*)(void))re::initInfo_ARSegmentationCompositeNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ARSegmentationCompositeNode>, this);
}

void re::ARSegmentationDilationNode::~ARSegmentationDilationNode(re::ARSegmentationDilationNode *this)
{
  re::ARSegmentationDilationNode::~ARSegmentationDilationNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  void *v2;
  uint64_t vars8;

  int32x4_t v2 = (void *)*((void *)this + 37);
  if (v2)
  {

    *((void *)this + 37) = 0;
  }
  re::AssetHandle::~AssetHandle((re::ARSegmentationDilationNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

void re::ARSegmentationGenerateGuideNode::~ARSegmentationGenerateGuideNode(re::ARSegmentationGenerateGuideNode *this)
{
  re::ARSegmentationGenerateGuideNode::~ARSegmentationGenerateGuideNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  int32x4_t v2 = (void *)*((void *)this + 40);
  if (v2)
  {

    *((void *)this + 40) = 0;
  }
  int32x4_t v3 = (void *)*((void *)this + 39);
  if (v3)
  {

    *((void *)this + 39) = 0;
  }
  re::AssetHandle::~AssetHandle((re::ARSegmentationGenerateGuideNode *)((char *)this + 256));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

void re::ARSegmentationDualGuidedFilterNode::~ARSegmentationDualGuidedFilterNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::ARSegmentationCompositeNode::~ARSegmentationCompositeNode(id *this)
{
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_0,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::~Callable()
{
}

uint64_t re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_0,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::operator()()
{
  return 0x1A4E9E909310CFLL;
}

void *re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_0,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E71AC70;
  return result;
}

void *re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_0,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E71AC70;
  return result;
}

uint64_t re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_0,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::size()
{
  return 16;
}

void re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_1,void ()(char const*,char const*,re::RenderFrame &)>::~Callable()
{
}

void re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_1,void ()(char const*,char const*,re::RenderFrame &)>::operator()(uint64_t a1, uint64_t a2, char **a3, re::RenderFrame *a4)
{
  uint64_t v5 = *a3;
  if (*a3)
  {
    uint64_t v6 = 0x9E3779B97F4A7C17;
    uint64_t v7 = *v5;
    if (*v5)
    {
      char v8 = v5[1];
      if (v8)
      {
        id v9 = (unsigned __int8 *)(v5 + 2);
        do
        {
          uint64_t v7 = 31 * v7 + v8;
          int v10 = *v9++;
          char v8 = v10;
        }
        while (v10);
      }
      uint64_t v6 = (v7 & 0x7FFFFFFFFFFFFFFFLL) - 0x61C8864680B583E9;
    }
  }
  else
  {
    uint64_t v6 = 0x1E3779B97F4A7C16;
  }
  int v18 = 2;
  uint64_t v19 = -1;
  uint64_t v20 = -1;
  uint64_t v21 = -1;
  char v22 = 0;
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v23 = _D0;
  long long v24 = xmmword_2343AEB90;
  long long v25 = xmmword_2343AEBA0;
  int v26 = -1;
  char v29 = 0;
  uint64_t v17 = 2;
  uint64_t v30 = 2 * re::kARSegmentationTextureFG;
  uint64_t v31 = off_268796308;
  uint64_t v27 = -1;
  unint64_t v28 = (v6 + (re::kARSegmentationTextureFG << 6) + ((re::kARSegmentationTextureFG & 0x7FFFFFFFFFFFFFFFuLL) >> 2)) ^ re::kARSegmentationTextureFG & 0x7FFFFFFFFFFFFFFFLL;
  re::StringID::destroyString((re::StringID *)&v30);
  re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v17, off_268796308, &v30);
  uint64_t v16 = 0x3A41DA2B27DFFE0CLL;
  re::RenderFrame::addTargetOutput(a4, &v16, (double *)&v30, v5);
  uint64_t v30 = 2 * re::kARSegmentationTextureBG;
  uint64_t v31 = off_268796318;
  unint64_t v28 = (v6 + (re::kARSegmentationTextureBG << 6) + ((re::kARSegmentationTextureBG & 0x7FFFFFFFFFFFFFFFuLL) >> 2)) ^ re::kARSegmentationTextureBG & 0x7FFFFFFFFFFFFFFFLL;
  re::StringID::destroyString((re::StringID *)&v30);
  re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v17, off_268796318, &v30);
  uint64_t v16 = 0x3A41DA2B27DFFD90;
  re::RenderFrame::addTargetOutput(a4, &v16, (double *)&v30, v5);
  uint64_t v30 = 2 * re::kARSegmentationTextureDilatedDepth;
  uint64_t v31 = off_268796328;
  unint64_t v28 = (v6
       + (re::kARSegmentationTextureDilatedDepth << 6)
       + ((re::kARSegmentationTextureDilatedDepth & 0x7FFFFFFFFFFFFFFFuLL) >> 2)) ^ re::kARSegmentationTextureDilatedDepth & 0x7FFFFFFFFFFFFFFFLL;
  re::StringID::destroyString((re::StringID *)&v30);
  re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v17, off_268796328, &v30);
  uint64_t v16 = 0x5F7D65B7480CA957;
  re::RenderFrame::addTargetOutput(a4, &v16, (double *)&v30, v5);
}

void *re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_1,void ()(char const*,char const*,re::RenderFrame &)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E71ACC8;
  return result;
}

void *re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_1,void ()(char const*,char const*,re::RenderFrame &)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E71ACC8;
  return result;
}

uint64_t re::internal::Callable<re::ARSegmentationEmitterCache::registerRenderGraphProvider(re::RenderGraphManager &)::$_1,void ()(char const*,char const*,re::RenderFrame &)>::size()
{
  return 16;
}

void re::ARSegmentationConnectionData::~ARSegmentationConnectionData(re::ARSegmentationConnectionData *this)
{
}

uint64_t re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re23ARSegmentationInputDataE";
  if (((unint64_t)"N2re23ARSegmentationInputDataE" & 0x8000000000000000) != 0)
  {
    int32x4_t v3 = (unsigned __int8 *)((unint64_t)"N2re23ARSegmentationInputDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(uint64_t a1, const char *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  MurmurHash3_x64_128((uint64_t)"ARSegmentationData", 18, 0, &v10);
  unint64_t v4 = v10;
  uint64_t v5 = v11;
  size_t v6 = strlen(a2);
  if (v6)
  {
    MurmurHash3_x64_128((uint64_t)a2, v6, 0, &v10);
    unint64_t v7 = ((v11 - 0x61C8864680B583E9 + (v10 << 6) + (v10 >> 2)) ^ v10) - 0x61C8864680B583E9;
  }
  else
  {
    unint64_t v7 = 0x9E3779B97F4A7C17;
  }
  unint64_t v8 = (v5 - 0x61C8864680B583E9 + (v4 << 6) + (v4 >> 2)) ^ v4;
  return re::RenderGraphDataStore::tryGet<re::ARSegmentationInputData>(a1, ((v8 >> 2) + (v8 << 6) + v7) ^ v8);
}

uint64_t re::RenderGraphDataStore::tryGet<re::ARSegmentationExecuteData>(uint64_t a1, const char *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  MurmurHash3_x64_128((uint64_t)"ARSegmentationData", 18, 0, &v13);
  unint64_t v4 = (v14 + (v13 << 6) + (v13 >> 2) - 0x61C8864680B583E9) ^ v13;
  size_t v5 = strlen(a2);
  if (v5)
  {
    MurmurHash3_x64_128((uint64_t)a2, v5, 0, &v13);
    unint64_t v6 = ((v14 - 0x61C8864680B583E9 + (v13 << 6) + (v13 >> 2)) ^ v13) - 0x61C8864680B583E9;
  }
  else
  {
    unint64_t v6 = 0x9E3779B97F4A7C17;
  }
  unint64_t v7 = ((v4 >> 2) + (v4 << 6) + v6) ^ v4;
  unint64_t v8 = (unint64_t)"N2re25ARSegmentationExecuteDataE";
  if (((unint64_t)"N2re25ARSegmentationExecuteDataE" & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)((unint64_t)"N2re25ARSegmentationExecuteDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  unint64_t v13 = (v7 - 0x61C8864680B583E9 + (v8 << 6) + (v8 >> 2)) ^ v8;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, (uint64_t *)&v13);
  if (result) {
    return *(void *)result;
  }
  return result;
}

void re::RenderGraphUploadPostParams::setup(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 592) = 1;
}

void re::RenderGraphUploadPostParams::execute(re::RenderGraphUploadPostParams *this, re::RenderGraphContext *a2)
{
  if (*((unsigned char *)this + 256) && !*((unsigned char *)this + 257))
  {
    uint64_t v4 = re::RenderGraphDataStore::add<re::TonemapParametersData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
    re::TonemapUserParameters::computeRenderParameters((re::RenderGraphUploadPostParams *)((char *)this + 260), (uint64_t)&v22);
    *(_OWORD *)(v4 + 88) = v27;
    *(_OWORD *)(v4 + 104) = v28;
    *(_OWORD *)(v4 + 120) = v29;
    *(_DWORD *)(v4 + 136) = v30;
    *(_OWORD *)(v4 + 24) = v23;
    *(_OWORD *)(v4 + 40) = v24;
    *(_OWORD *)(v4 + 56) = v25;
    *(_OWORD *)(v4 + 72) = v26;
    *(_OWORD *)(v4 + 8) = v22;
  }
  if (*((unsigned char *)this + 258))
  {
    uint64_t v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    re::BloomUserParameters::computeRenderParameters((re::RenderGraphUploadPostParams *)((char *)this + 320), (uint64_t)&v22);
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x98uLL, 4uLL, (uint64_t)&v32);
    size_t v5 = v34;
    uint64_t v20 = v33;
    unint64_t v6 = &v32[v33];
    *((_OWORD *)v6 + 6) = v28;
    *((_OWORD *)v6 + 7) = v29;
    *((_OWORD *)v6 + 8) = v30;
    *((void *)v6 + 18) = v31;
    *((_OWORD *)v6 + 2) = v24;
    *((_OWORD *)v6 + 3) = v25;
    *((_OWORD *)v6 + 4) = v26;
    *((_OWORD *)v6 + 5) = v27;
    *(_OWORD *)unint64_t v6 = v22;
    *((_OWORD *)v6 + 1) = v23;
    uint64_t v7 = re::RenderGraphDataStore::add<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(*((re **)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
    *(_DWORD *)(v7 + 24) = HIDWORD(v22);
    unint64_t v32 = v5;
    uint64_t v33 = v20;
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v7 + 8), (void **)&v32);
    unint64_t v8 = v32;
    *(void *)(v7 + 16) = v33;
    if (v8) {
  }
    }
  if (*((unsigned char *)this + 259))
  {
    id v9 = (unsigned __int8 *)*((void *)a2 + 2);
    long long v10 = xmmword_23435FD80;
    long long v11 = xmmword_23435FD60;
    long long v12 = xmmword_23435FD50;
    if (v9[64] && *v9 != v9[1] && v9[65])
    {
      long long v12 = *((_OWORD *)v9 + 1);
      long long v11 = *((_OWORD *)v9 + 2);
      long long v10 = *((_OWORD *)v9 + 3);
    }
    long long v17 = v12;
    long long v18 = v11;
    long long v19 = v10;
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x30uLL, 0x10uLL, (uint64_t)&v22);
    unint64_t v13 = (void *)v23;
    uint64_t v21 = *((void *)&v22 + 1);
    uint64_t v14 = (long long *)(v22 + DWORD2(v22));
    *uint64_t v14 = v17;
    v14[1] = v18;
    void v14[2] = v19;
    uint64_t v15 = re::RenderGraphDataStore::add<re::RenderGraphDataStoreWrapper<re::ColorExecData>>(*((re **)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
    *(void *)&long long v22 = v13;
    *((void *)&v22 + 1) = v21;
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v15 + 8), (void **)&v22);
    uint64_t v16 = (void *)v22;
    *(void *)(v15 + 16) = *((void *)&v22 + 1);
    if (v16) {
  }
    }
}

void re::RenderGraphCombinedPostProcessNode::configure(re::RenderGraphCombinedPostProcessNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  unint64_t v8 = *((void *)this + 53);
  if (v8)
  {
    unint64_t v9 = 0;
    uint64_t v10 = 8;
    do
    {
      long long v11 = (uint64_t *)(*((void *)this + 55) + v10);
      uint64_t v13 = *v11;
      long long v12 = (re::AssetHandle *)(v11 - 1);
      if (v13)
      {
        if (v8 <= v9)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        re::AssetHandle::loadAsync(v12);
        unint64_t v8 = *((void *)this + 53);
      }
      if (v9 > 0xE) {
        break;
      }
      ++v9;
      v10 += 24;
    }
    while (v8 > v9);
  }
  unint64_t v14 = *((void *)this + 32);
  if (v14 > 0xF)
  {
    if (v14 == 16) {
      goto LABEL_12;
    }
  }
  else
  {
    bzero((char *)this + 8 * v14 + 272, 128 - 8 * v14);
  }
  *((void *)this + 32) = 16;
  ++*((_DWORD *)this + 66);
LABEL_12:
  re::RenderGraphNode::configure(this, a2, a3, a4);
}

uint64_t re::RenderGraphCombinedPostProcessNode::setup(re::RenderGraphCombinedPostProcessNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!*((void *)this + 24))
  {
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v7 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_7;
  }
  re::RenderGraphBuilder::read((uint64_t)a2, *((void *)this + 26), *((void *)this + 26) + 16);
  if (*((unsigned char *)this + 402))
  {
    *(_DWORD *)((char *)&v7 + 3) = 0;
    LODWORD(v7) = 0;
    *((void *)&v7 + 1) = 2;
    re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)this + 448, (uint64_t)&v7);
  }
  if (!*((void *)this + 29))
  {
LABEL_7:
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v7 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v5 = *((void *)this + 31);
  *(void *)&long long v7 = 0x100000000;
  long long v8 = xmmword_23435FBB0;
  LOWORD(v9) = 0;
  *(void *)((char *)&v9 + 4) = 0;
  return re::RenderGraphBuilder::write((uint64_t)a2, v5, (uint64_t)&v7);
}

void re::RenderGraphCombinedPostProcessNode::execute(re::RenderGraphCombinedPostProcessNode *this, re::RenderGraphContext *a2)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v89, 5042, 0);
  if (*((unsigned char *)this + 400))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B2D0, memory_order_acquire) & 1) == 0)
    {
      unint64_t v64 = (re *)__cxa_guard_acquire(&qword_26AF9B2D0);
      if (v64)
      {
        _MergedGlobals_447 = re::getCombinedScopeHash(v64, v65, v66);
        __cxa_guard_release(&qword_26AF9B2D0);
      }
    }
    if (*((unsigned char *)this + 401))
    {
      uint64_t v6 = _MergedGlobals_447;
      uint64_t v7 = *((void *)a2 + 146);
    }
    else
    {
      uint64_t v7 = *((void *)a2 + 146);
      uint64_t v6 = *(void *)(*((void *)a2 + 5) + 48);
    }
    uint64_t v8 = re::RenderGraphDataStore::tryGet<re::TonemapParametersData>(v7, v6);
    if (!v8)
    {
      unint64_t v32 = *re::graphicsLogObjects(0);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_83;
      }
      *(_WORD *)buf = 0;
      uint64_t v33 = "RenderGraphCombinedPostProcessNode expects TonemapParametersData from the render graph data store but there "
            "isn't any. Will skip the execution.";
LABEL_48:
      _os_log_impl(&dword_233120000, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 2u);
      goto LABEL_83;
    }
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x84uLL, 4uLL, (uint64_t)buf);
    uint64_t v9 = v98;
    unint64_t v10 = *(unsigned int *)&buf[8] | ((unint64_t)*(unsigned int *)&buf[12] << 32);
    uint64_t v11 = *(void *)buf + *(unsigned int *)&buf[8];
    *(_OWORD *)uint64_t v11 = *(_OWORD *)(v8 + 8);
    long long v12 = *(_OWORD *)(v8 + 24);
    long long v13 = *(_OWORD *)(v8 + 40);
    long long v14 = *(_OWORD *)(v8 + 72);
    *(_OWORD *)(v11 + 48) = *(_OWORD *)(v8 + 56);
    *(_OWORD *)(v11 + 64) = v14;
    *(_OWORD *)(v11 + 16) = v12;
    *(_OWORD *)(v11 + 32) = v13;
    long long v15 = *(_OWORD *)(v8 + 88);
    long long v16 = *(_OWORD *)(v8 + 104);
    long long v17 = *(_OWORD *)(v8 + 120);
    *(_DWORD *)(v11 + 128) = *(_DWORD *)(v8 + 136);
    *(_OWORD *)(v11 + 96) = v16;
    *(_OWORD *)(v11 + 112) = v17;
    *(_OWORD *)(v11 + 80) = v15;
    long long v18 = (re::BufferTable *)(*(void *)a2 + 480);
    *(void *)unsigned int v91 = 0x1C6D7B14F4E32CD0;
    *(void *)buf = v9;
    *(void *)&uint8_t buf[8] = v10;
    re::BufferTable::setBuffer(v18, (const re::WeakStringID *)v91, (const BufferView *)buf);
  }
  if (!*((unsigned char *)this + 402)) {
    goto LABEL_15;
  }
  uint64_t v19 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::BloomExecData>>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!v19)
  {
    unint64_t v32 = *re::graphicsLogObjects(0);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_83;
    }
    *(_WORD *)buf = 0;
    uint64_t v33 = "RenderGraphCombinedPostProcessNode expects BloomExecDataWrapper from the render graph data store but there isn"
          "'t any. Will skip the execution. Did you forget to add a upload node?";
    goto LABEL_48;
  }
  uint64_t v20 = v19;
  uint64_t v2 = *(void *)a2 + 368;
  *(void *)buf = 0x12DFD1912E60118;
  re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 448, 0, 0, v69);
  re::makeView2DTo2DArray(v69, v91);
  re::DynamicTextureTableAdd((void *)v2, buf, (id *)v91);
  if (*(void *)v91)
  {

    *(void *)unsigned int v91 = 0;
  }
  if (v69[0]) {

  }
  uint64_t v21 = (re::BufferTable *)(*(void *)a2 + 480);
  *(void *)buf = 0x127DBE076EDDD69;
  re::BufferTable::setBuffer(v21, (const re::WeakStringID *)buf, v20 + 8);
LABEL_15:
  if (!*((unsigned char *)this + 404)) {
    goto LABEL_18;
  }
  uint64_t v22 = re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::ColorExecData>>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!v22)
  {
    unint64_t v32 = *re::graphicsLogObjects(0);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_83;
    }
    *(_WORD *)buf = 0;
    uint64_t v33 = "RenderGraphCombinedPostProcessNode expects ColorExecDataWrapper from the render graph data store but there isn"
          "'t any. Will skip the execution. Did you forget to add a upload node?";
    goto LABEL_48;
  }
  long long v23 = (re::BufferTable *)(*(void *)a2 + 480);
  *(void *)buf = 0x775E00AD509B0A76;
  re::BufferTable::setBuffer(v23, (const re::WeakStringID *)buf, v22 + 8);
LABEL_18:
  unint64_t v24 = (unint64_t)v91;
  uint64_t v25 = *(void *)a2;
  v90[0] = 0xA3521511A35B9;
  if (!*((void *)this + 24))
  {
LABEL_87:
    v69[0] = 0;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int v91 = 136315906;
    *(void *)(v24 + 4) = "operator[]";
    *(_WORD *)&v91[12] = 1024;
    *(_DWORD *)(v24 + 14) = 789;
    *(_WORD *)&v91[18] = 2048;
    *(void *)(v24 + 20) = 0;
    *(_WORD *)&v91[28] = 2048;
    *(void *)(v24 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_88:
    v69[0] = 0;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    *(_OWORD *)buf = 0u;
    a2 = (re::RenderGraphContext *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int v91 = 136315906;
    *(void *)&v91[4] = "operator[]";
    *(_WORD *)&v91[12] = 1024;
    *(_DWORD *)&v91[14] = 789;
    *(_WORD *)&v91[18] = 2048;
    *(void *)&v91[20] = v24;
    *(_WORD *)&v91[28] = 2048;
    *(void *)&v91[30] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_89:
    re::internal::assertLog((re::internal *)6, v50, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_90:
    uint64_t v56 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::RenderGraphContext *)((char *)a2 + 1336), *((const char **)this + 2), (const char *)v2);
LABEL_71:
    uint64_t v76 = v56;
    char v77 = 0;
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs(a2, v90);
    re::RenderGraphContext::encodeDrawCalls(a2, v90, v69);
    long long v57 = (re *)(*(void *)a2 + 368);
    v90[0] = v3;
    re::DynamicTextureTableRemove(v57, (re::TextureTable *)v90, v58);
    if (*((unsigned char *)this + 400))
    {
      long long v60 = (re::BufferTable *)(*(void *)a2 + 480);
      v90[0] = 0x1C6D7B14F4E32CD0;
      re::BufferTable::removeBuffer(v60, (const re::WeakStringID *)v90);
    }
    if (*((unsigned char *)this + 402))
    {
      long long v61 = (re *)(*(void *)a2 + 368);
      v90[0] = 0x12DFD1912E60118;
      re::DynamicTextureTableRemove(v61, (re::TextureTable *)v90, v59);
      uint64_t v62 = (re::BufferTable *)(*(void *)a2 + 480);
      v90[0] = 0x127DBE076EDDD69;
      re::BufferTable::removeBuffer(v62, (const re::WeakStringID *)v90);
    }
    if (*((unsigned char *)this + 404))
    {
      int v63 = (re::BufferTable *)(*(void *)a2 + 480);
      v90[0] = 0x775E00AD509B0A76;
      re::BufferTable::removeBuffer(v63, (const re::WeakStringID *)v90);
    }
    if (v83[0] && v85) {
      (*(void (**)(void))(*(void *)v83[0] + 40))();
    }
    uint64_t v42 = v86[0];
    if (!v86[0]) {
      goto LABEL_83;
    }
    uint64_t v43 = v88;
    if (!v88) {
      goto LABEL_83;
    }
LABEL_82:
    (*(void (**)(uint64_t, void *))(*(void *)v42 + 40))(v42, v43);
    goto LABEL_83;
  }
  long long v26 = (void *)(v25 + 368);
  re::RenderGraphContext::metalTexture((uint64_t)a2, *((void *)this + 26), 0, 0, (id *)v91);
  re::makeView2DTo2DArray((id *)v91, buf);
  re::DynamicTextureTableAdd(v26, v90, (id *)buf);
  if (*(void *)buf)
  {

    *(void *)buf = 0;
  }
  if (*(void *)v91) {

  }
  uint64_t v2 = *((unsigned __int8 *)this + 400);
  int v27 = *((unsigned __int8 *)this + 402);
  int v28 = *((unsigned __int8 *)this + 403);
  int v29 = *((unsigned __int8 *)this + 404);
  uint64_t v30 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (v30) {
    BOOL v31 = *(unsigned char *)(v30 + 65) != 0;
  }
  else {
    BOOL v31 = 0;
  }
  BOOL v68 = v31;
  uint64_t v67 = v30;
  if (!*((void *)this + 53))
  {
    unint64_t v3 = 0;
    unint64_t v38 = *((void *)this + 32);
LABEL_39:
    if (v38 <= (v2 | (2 * v27) | (4 * v28) | (8 * v29)))
    {
      re::DynamicString::format((re::DynamicString *)"%s: Permutation %du was requested but only %lu materials exist.", (re::DynamicString *)buf, *((void *)this + 2), v2 | (2 * v27) | (4 * v28) | (8 * v29), v38);
      re::RenderGraphExecutable::addError(*((void *)a2 + 147), (uint64_t)buf);
      uint64_t v42 = *(void *)buf;
      if (!*(void *)buf || (buf[8] & 1) == 0) {
        goto LABEL_83;
      }
      uint64_t v43 = (void *)v98;
      goto LABEL_82;
    }
    unint64_t v24 = (v2 | (2 * v27) | (4 * v28) | (8 * v29));
    if (v3 <= v24) {
      goto LABEL_88;
    }
    uint64_t v39 = *(void *)(*((void *)this + v24 + 34) + 1664);
    unint64_t v40 = *(void *)(*((void *)this + 55) + 24 * v24 + 8);
    if (v40) {
      uint64_t v41 = *(void *)(v40 + 664);
    }
    else {
      uint64_t v41 = 0;
    }
    unint64_t v44 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v40 ^ (v40 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v40 ^ (v40 >> 30))) >> 27));
    *(void *)buf = v41 ^ (v44 >> 31) ^ v44;
    unint64_t v45 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet((uint64_t)a2 + 1568, (uint64_t *)buf);
    if (v45) {
      uint64_t v46 = *v45;
    }
    else {
      uint64_t v46 = 0;
    }
    re::RenderGraphContext::makeFullscreenDrawCall(a2, v39, v46, 0, 0, 0, (int32x2_t *)buf);
    if (v68) {
      uint64_t v2 = (uint64_t)"fullscreenarray";
    }
    else {
      uint64_t v2 = (uint64_t)"fullscreen";
    }
    uint64_t v47 = (re::MaterialParameterTableLayers *)v101;
    if (v68) {
      int v48 = 15;
    }
    else {
      int v48 = 10;
    }
    MurmurHash3_x64_128(v2, v48, 0, (unint64_t *)v91);
    uint64_t v49 = re::MaterialParameterTableLayers::resolveTechniqueIndices(v47, (*(void *)&v91[8] + (*(void *)v91 << 6) + (*(void *)v91 >> 2) - 0x61C8864680B583E9) ^ *(void *)v91);
    if (!v50) {
      goto LABEL_89;
    }
    HIDWORD(v99) = *v49;
    if (HIDWORD(v99) == -1) {
      goto LABEL_83;
    }
    uint64_t v51 = re::RenderGraphDataStore::tryGet<re::CameraData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
    unint64_t v88 = 0;
    unint64_t v85 = 0;
    memset(v86, 0, sizeof(v86));
    int v87 = 0;
    memset(v83, 0, sizeof(v83));
    int v84 = 0;
    if (v51)
    {
      uint64_t v52 = v51;
      if (*(void *)(v51 + 128))
      {
        unint64_t v34 = 0;
        unint64_t v24 = 0;
        unint64_t v3 = v51 + 64;
        while (1)
        {
          re::Projection::computeMatrix4x4F((re::Projection *)(v52 + 144 + (v34 << 6)), (uint64_t)v91);
          re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v83, (uint64_t)v91);
          unint64_t v54 = *(void *)(v52 + 48);
          if (v54 <= v34) {
            break;
          }
          re::RenderCamera::computeInverseTransform((float32x4_t *)(v3 + 32 * v34), (uint64_t)v91);
          re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v86, (uint64_t)v91);
          unint64_t v24 = (v24 + 1);
          unint64_t v34 = v24;
          if (*(void *)(v52 + 128) <= (unint64_t)v24) {
            goto LABEL_66;
          }
        }
LABEL_86:
        re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v34, v54);
        _os_crash();
        __break(1u);
        goto LABEL_87;
      }
LABEL_66:
      int v55 = *(unsigned __int8 *)(v52 + 490);
    }
    else
    {
      *(_OWORD *)unsigned int v91 = xmmword_23435FD50;
      *(_OWORD *)&v91[16] = xmmword_23435FD60;
      *(_OWORD *)&v91[32] = xmmword_23435FD80;
      *(_OWORD *)unint64_t v92 = xmmword_23435FBB0;
      re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v83, (uint64_t)v91);
      *(_OWORD *)unsigned int v91 = xmmword_23435FD50;
      *(_OWORD *)&v91[16] = xmmword_23435FD60;
      *(_OWORD *)&v91[32] = xmmword_23435FD80;
      *(_OWORD *)unint64_t v92 = xmmword_23435FBB0;
      re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v86, (uint64_t)v91);
      if (v68)
      {
        int v55 = *(unsigned __int8 *)(v67 + 64);
        *(_OWORD *)unsigned int v91 = xmmword_23435FD50;
        *(_OWORD *)&v91[16] = xmmword_23435FD60;
        *(_OWORD *)&v91[32] = xmmword_23435FD80;
        *(_OWORD *)unint64_t v92 = xmmword_23435FBB0;
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v83, (uint64_t)v91);
        *(_OWORD *)unsigned int v91 = xmmword_23435FD50;
        *(_OWORD *)&v91[16] = xmmword_23435FD60;
        *(_OWORD *)&v91[32] = xmmword_23435FD80;
        *(_OWORD *)unint64_t v92 = xmmword_23435FBB0;
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)v86, (uint64_t)v91);
      }
      else
      {
        int v55 = 1;
      }
    }
    unint64_t v3 = 0xA3521511A35B9;
    DWORD1(v99) = v55;
    re::DrawCallRef::DrawCallRef(&v78, (const re::DrawCall *)buf);
    uint64_t v56 = 0;
    *(void *)unsigned int v91 = &v78;
    *(void *)&v91[24] = &v79;
    *(void *)unint64_t v92 = &v80;
    id v93 = &v81;
    *(int64x2_t *)&v91[8] = vdupq_n_s64(1uLL);
    *(_OWORD *)&v91[32] = *(_OWORD *)&v91[8];
    *(_OWORD *)&v92[8] = *(_OWORD *)&v91[8];
    long long v94 = *(_OWORD *)&v91[8];
    char v95 = &v82;
    long long v96 = *(_OWORD *)&v91[8];
    v69[0] = (id)v2;
    v69[1] = v91;
    v69[2] = v88;
    v69[3] = v85;
    v69[4] = 0;
    char v70 = v55;
    __int16 v71 = 2;
    __int16 v72 = 0;
    long long v73 = 0u;
    long long v74 = 0u;
    char v75 = 0;
    if (!*((unsigned char *)a2 + 1332)) {
      goto LABEL_71;
    }
    goto LABEL_90;
  }
  unint64_t v34 = 0;
  unint64_t v35 = 0;
  unint64_t v24 = (unint64_t)this + 272;
  while (re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(*((void *)this + 55) + v34)))
  {
    unint64_t v3 = *((void *)this + 53);
    if (v3 <= v35)
    {
      v69[0] = 0;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unsigned int v91 = 136315906;
      *(void *)&v91[4] = "operator[]";
      *(_WORD *)&v91[12] = 1024;
      *(_DWORD *)&v91[14] = 789;
      *(_WORD *)&v91[18] = 2048;
      *(void *)&v91[20] = v35;
      *(_WORD *)&v91[28] = 2048;
      *(void *)&v91[30] = v3;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_85:
      re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 381, v35, v38);
      _os_crash();
      __break(1u);
      goto LABEL_86;
    }
    uint64_t v36 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(*((void *)this + 55) + v34));
    unint64_t v38 = *((void *)this + 32);
    if (v38 <= v35) {
      goto LABEL_85;
    }
    *(void *)(v24 + 8 * v35) = v36;
    unint64_t v3 = *((void *)this + 53);
    if (v35 <= 0xE)
    {
      ++v35;
      v34 += 24;
      if (v3 > v35) {
        continue;
      }
    }
    goto LABEL_39;
  }
LABEL_83:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v89);
}

void re::RenderGraphCombinedPostProcessNode::getMaterialParameterTables(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  unint64_t v2 = *(unsigned __int8 *)(a1 + 400) | (2 * *(unsigned __int8 *)(a1 + 402)) | (4 * *(unsigned __int8 *)(a1 + 403)) | (8 * *(unsigned __int8 *)(a1 + 404));
  if (*(void *)(a1 + 424) > v2)
  {
    uint64_t v4 = *(void *)(a1 + 440);
    if (*(void *)(v4 + 24 * v2 + 8))
    {
      uint64_t v6 = re::AssetHandle::loadedAsset<re::MaterialAsset>((re::MaterialAsset *)(v4 + 24 * v2));
      if (v6)
      {
        uint64_t v7 = *(re::MaterialParameterBlock **)(v6 + 1672);
        if (v7)
        {
          unint64_t v8 = *(void *)(a1 + 424);
          if (v8 <= v2)
          {
            memset(v20, 0, sizeof(v20));
            unint64_t v12 = v8;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v13 = 136315906;
            *(void *)&void v13[4] = "operator[]";
            __int16 v14 = 1024;
            int v15 = 797;
            __int16 v16 = 2048;
            unint64_t v17 = v2;
            __int16 v18 = 2048;
            unint64_t v19 = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          unint64_t v9 = *(void *)(*(void *)(a1 + 440) + 24 * v2 + 8);
          if (v9) {
            uint64_t v10 = *(void *)(v9 + 664);
          }
          else {
            uint64_t v10 = 0;
          }
          unint64_t v11 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
          *(void *)&v20[0] = v10 ^ (v11 >> 31) ^ v11;
          re::MaterialParameterBlock::createMaterialParameterTableIfNeeded(v7, v13);
          re::HashTable<unsigned long,re::SharedPtr<re::MaterialParameterTable>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a2, (unint64_t *)v20, v13);
          if (*(void *)v13) {
        }
          }
      }
    }
  }
}

void *re::allocInfo_RenderGraphUploadPostParams(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B2D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9B2D8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B370, "RenderGraphUploadPostParams");
    __cxa_guard_release(&qword_26AF9B2D8);
  }
  return &unk_26AF9B370;
}

void re::initInfo_RenderGraphUploadPostParams(re *this, re::IntrospectionBase *a2)
{
  v31[0] = 0x5202598F4D5E78FELL;
  v31[1] = "RenderGraphUploadPostParams";
  re::StringID::destroyString((re::StringID *)v31);
  *((_OWORD *)this + 2) = v32;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B2E0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B2E0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B2F8 = v7;
      unint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_BOOL((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "tonemappingEnabled";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x10000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9B300 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      __int16 v14 = re::introspect_BOOL((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "bloomEnabled";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x10200000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9B308 = v15;
      __int16 v16 = re::introspectionAllocator((re *)v15);
      uint64_t v17 = re::introspect_TonemapUserParameters((re::IntrospectionBase **)1);
      uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "tonemapUserParameters";
      *(void *)(v18 + 16) = v17;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0x10400000003;
      *(_DWORD *)(v18 + 40) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF9B310 = v18;
      unint64_t v19 = re::introspectionAllocator((re *)v18);
      uint64_t v20 = re::introspect_BloomUserParameters((re::IntrospectionBase **)1);
      uint64_t v21 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v19 + 32))(v19, 72, 8);
      *(_DWORD *)uint64_t v21 = 1;
      *(void *)(v21 + 8) = "bloomUserParameters";
      *(void *)(v21 + 16) = v20;
      *(void *)(v21 + 24) = 0;
      *(void *)(v21 + 32) = 0x14000000004;
      *(_DWORD *)(v21 + 40) = 0;
      *(void *)(v21 + 48) = 0;
      *(void *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_26AF9B318 = v21;
      uint64_t v22 = re::introspectionAllocator((re *)v21);
      unint64_t v24 = re::introspect_BOOL((re *)1, v23);
      uint64_t v25 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v22 + 32))(v22, 72, 8);
      *(_DWORD *)uint64_t v25 = 1;
      *(void *)(v25 + 8) = "colorConvertEnabled";
      *(void *)(v25 + 16) = v24;
      *(void *)(v25 + 24) = 0;
      *(void *)(v25 + 32) = 0x10300000005;
      *(_DWORD *)(v25 + 40) = 0;
      *(void *)(v25 + 48) = 0;
      *(void *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_26AF9B320 = v25;
      long long v26 = re::introspectionAllocator((re *)v25);
      int v28 = re::introspect_BOOL((re *)1, v27);
      uint64_t v29 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v26 + 32))(v26, 72, 8);
      *(_DWORD *)uint64_t v29 = 1;
      *(void *)(v29 + 8) = "tonemappingSharedParamsEnabled";
      *(void *)(v29 + 16) = v28;
      *(void *)(v29 + 24) = 0;
      *(void *)(v29 + 32) = 0x10100000006;
      *(_DWORD *)(v29 + 40) = 0;
      *(void *)(v29 + 48) = 0;
      *(void *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_26AF9B328 = v29;
      __cxa_guard_release(&qword_26AF9B2E0);
    }
  }
  *((void *)this + 2) = 0x15000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 7;
  *((void *)this + 8) = &qword_26AF9B2F8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphUploadPostParams>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphUploadPostParams>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphUploadPostParams>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphUploadPostParams>;
  re::IntrospectionRegistry::add(this, v3);
  long long v30 = v32;
}

double re::internal::defaultConstruct<re::RenderGraphUploadPostParams>(int a1, int a2, re::RenderGraphUploadPostParams *this)
{
  return re::RenderGraphUploadPostParams::RenderGraphUploadPostParams(this);
}

uint64_t re::internal::defaultDestruct<re::RenderGraphUploadPostParams>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphUploadPostParams>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphUploadPostParams(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphUploadPostParams", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphUploadPostParams, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphUploadPostParams, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphUploadPostParams>, this);
}

void *re::allocInfo_RenderGraphCombinedPostProcessNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B2E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9B2E8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B3E8, "RenderGraphCombinedPostProcessNode");
    __cxa_guard_release(&qword_26AF9B2E8);
  }
  return &unk_26AF9B3E8;
}

void re::initInfo_RenderGraphCombinedPostProcessNode(re *this, re::IntrospectionBase *a2)
{
  v37[0] = 0x41FFC6ACD6032468;
  v37[1] = "RenderGraphCombinedPostProcessNode";
  re::StringID::destroyString((re::StringID *)v37);
  *((_OWORD *)this + 2) = v38;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B2F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B2F0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B330 = v7;
      unint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_BOOL((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "tonemappingEnabled";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x19000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9B338 = v11;
      unint64_t v12 = re::introspectionAllocator((re *)v11);
      __int16 v14 = re::introspect_BOOL((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "bloomEnabled";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x19200000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9B340 = v15;
      __int16 v16 = re::introspectionAllocator((re *)v15);
      uint64_t v18 = re::introspect_BOOL((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "vignetteEnabled";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x19300000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9B348 = v19;
      uint64_t v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::introspect_RenderGraphTargetHandle((re *)1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "downsampledTarget";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x1C000000004;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF9B350 = v23;
      unint64_t v24 = re::introspectionAllocator((re *)v23);
      long long v26 = re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(1, v25);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "combinedMaterialPermutations";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0x19800000005;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF9B358 = v27;
      int v28 = re::introspectionAllocator((re *)v27);
      long long v30 = re::introspect_BOOL((re *)1, v29);
      uint64_t v31 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v28 + 32))(v28, 72, 8);
      *(_DWORD *)uint64_t v31 = 1;
      *(void *)(v31 + 8) = "colorConvertEnabled";
      *(void *)(v31 + 16) = v30;
      *(void *)(v31 + 24) = 0;
      *(void *)(v31 + 32) = 0x19400000006;
      *(_DWORD *)(v31 + 40) = 0;
      *(void *)(v31 + 48) = 0;
      *(void *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_26AF9B360 = v31;
      long long v32 = re::introspectionAllocator((re *)v31);
      unint64_t v34 = re::introspect_BOOL((re *)1, v33);
      uint64_t v35 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 72, 8);
      *(_DWORD *)uint64_t v35 = 1;
      *(void *)(v35 + 8) = "tonemappingSharedParamsEnabled";
      *(void *)(v35 + 16) = v34;
      *(void *)(v35 + 24) = 0;
      *(void *)(v35 + 32) = 0x19100000007;
      *(_DWORD *)(v35 + 40) = 0;
      *(void *)(v35 + 48) = 0;
      *(void *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_26AF9B368 = v35;
      __cxa_guard_release(&qword_26AF9B2F0);
    }
  }
  *((void *)this + 2) = 0x1D000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 8;
  *((void *)this + 8) = &qword_26AF9B330;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphCombinedPostProcessNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphCombinedPostProcessNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphCombinedPostProcessNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphCombinedPostProcessNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v36 = v38;
}

double re::internal::defaultConstruct<re::RenderGraphCombinedPostProcessNode>(int a1, int a2, re::RenderGraphNode *this)
{
  unint64_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)unint64_t v3 = &unk_26E71AE08;
  *((void *)v3 + 32) = 0;
  *((_DWORD *)v3 + 66) = 0;
  *((void *)v3 + 52) = 0;
  *((void *)v3 + 53) = 0;
  *((void *)v3 + 51) = 0;
  *((_DWORD *)v3 + 108) = 0;
  *((_DWORD *)v3 + 100) = 0;
  *((unsigned char *)v3 + 404) = 0;
  *((void *)v3 + 55) = 0;
  *((void *)v3 + 56) = 0;
  double result = NAN;
  *((void *)v3 + 57) = -1;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphCombinedPostProcessNode>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::RenderGraphCombinedPostProcessNode>(re::RenderGraphNode *a1)
{
  unsigned int v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)unsigned int v1 = &unk_26E71AE08;
  *((void *)v1 + 32) = 0;
  *((_DWORD *)v1 + 66) = 0;
  *((void *)v1 + 52) = 0;
  *((void *)v1 + 53) = 0;
  *((void *)v1 + 51) = 0;
  *((_DWORD *)v1 + 108) = 0;
  *((_DWORD *)v1 + 100) = 0;
  *((unsigned char *)v1 + 404) = 0;
  *((void *)v1 + 55) = 0;
  *((void *)v1 + 56) = 0;
  double result = NAN;
  *((void *)v1 + 57) = -1;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphCombinedPostProcessNode>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphCombinedPostProcessNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphCombinedPostProcessNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphCombinedPostProcessNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphCombinedPostProcessNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphCombinedPostProcessNode>, this);
}

void re::RenderGraphUploadPostParams::~RenderGraphUploadPostParams(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphCombinedPostProcessNode::~RenderGraphCombinedPostProcessNode(re::RenderGraphCombinedPostProcessNode *this)
{
  *(void *)this = &unk_26E71AE08;
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 408);
  *((void *)this + 32) = 0;
  ++*((_DWORD *)this + 66);
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E71AE08;
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 408);
  *((void *)this + 32) = 0;
  ++*((_DWORD *)this + 66);
  re::RenderGraphNode::~RenderGraphNode((id *)this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::add<re::TonemapParametersData>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re21TonemapParametersDataE";
  if (((unint64_t)"N2re21TonemapParametersDataE" & 0x8000000000000000) != 0)
  {
    unint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re21TonemapParametersDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  uint64_t v10 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t v6 = a1 + 64;
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 144, 8);
  *(_OWORD *)(v7 + 120) = 0u;
  *(_OWORD *)(v7 + 8) = 0u;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 104) = 0u;
  *(void *)(v7 + 136) = 0;
  *(void *)uint64_t v7 = &unk_26E71AEC8;
  *(unsigned char *)(v7 + 128) = 1;
  uint64_t v9 = v7;
  return *(void *)re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addNew<re::CameraData *>(v6, (unint64_t *)&v10, &v9);
}

void re::TonemapParametersData::~TonemapParametersData(re::TonemapParametersData *this)
{
}

uint64_t re::RenderGraphDataStore::add<re::RenderGraphDataStoreWrapper<re::ColorExecData>>(re *a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE" & 0x8000000000000000) != 0)
  {
    unint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  uint64_t v11 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t v6 = (uint64_t)a1 + 16;
  uint64_t v7 = re::globalAllocators(a1);
  unint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 24, 8);
  v8[1] = 0;
  uint64_t v8[2] = 0;
  *unint64_t v8 = &unk_26E71AF08;
  uint64_t v10 = v8;
  return *(void *)re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::addNew<re::CameraData *>(v6, (unint64_t *)&v11, &v10);
}

void *re::RenderGraphDataStoreWrapper<re::ColorExecData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71AF08;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::ColorExecData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71AF08;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphDataStore::tryGet<re::RenderGraphDataStoreWrapper<re::ColorExecData>>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE" & 0x8000000000000000) != 0)
  {
    unint64_t v3 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_13ColorExecDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v4 = 5381;
    do
    {
      unint64_t v2 = v4;
      unsigned int v5 = *v3++;
      uint64_t v4 = (33 * v4) ^ v5;
    }
    while (v5);
  }
  unint64_t v7 = (a2 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, (uint64_t *)&v7);
  if (result) {
    return *(void *)result;
  }
  return result;
}

double re::RenderGraphUploadPostParams::RenderGraphUploadPostParams(re::RenderGraphUploadPostParams *this)
{
  unsigned int v1 = (char *)this + 260;
  unint64_t v2 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)unint64_t v2 = &unk_26E71AD60;
  *((_DWORD *)v2 + 64) = 0;
  *(_OWORD *)unsigned int v1 = xmmword_23436C470;
  *((_OWORD *)v1 + 1) = xmmword_2343679C0;
  *((unsigned char *)v2 + 292) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)v2 + 37) = _D0;
  *((unsigned char *)v2 + 304) = 0;
  *((void *)v1 + 6) = 0x3F80000000000000;
  *((unsigned char *)v2 + 316) = 0;
  double result = 0.00781250182;
  *((void *)v2 + 40) = 0x3F8000003E800000;
  *((void *)v2 + 41) = 0x13F800000;
  return result;
}

uint64_t re::RenderFrameContextBuilder::build@<X0>(uint64_t a1@<X1>, unint64_t a2@<X2>, unint64_t a3@<X8>)
{
  unint64_t v6 = a3;
  uint64_t v389 = *MEMORY[0x263EF8340];
  long long v257 = *(void **)(a1 + 8);
  uint64_t v7 = v257[4];
  *(_OWORD *)(a3 + 16) = 0u;
  long long v258 = (long long *)(a3 + 16);
  uint64_t v259 = v7;
  unint64_t v8 = *(re::Allocator **)(a1 + 376);
  *(void *)(v6 + 24) = v8;
  unint64_t v9 = v6 + 24;
  *(void *)unint64_t v6 = 0;
  *(unsigned char *)(v6 + 8) = 0;
  *(_OWORD *)(v6 + 32) = 0u;
  uint64_t v331 = 0;
  unint64_t v329 = 0;
  int v330 = 0;
  v328[1] = 0;
  unint64_t v265 = v8;
  v328[0] = v8;
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v328, 0);
  ++v330;
  uint64_t v10 = *(unsigned int *)(a1 + 296);
  long long v256 = (void *)a2;
  uint64_t v11 = 0;
  if (v10)
  {
    unint64_t v12 = *(int **)(a1 + 280);
    while (1)
    {
      int v13 = *v12;
      v12 += 18;
      if (v13 < 0) {
        break;
      }
      if (v10 == ++v11)
      {
        LODWORD(v11) = *(_DWORD *)(a1 + 296);
        break;
      }
    }
  }
  if (v10 != v11)
  {
    uint64_t v3 = v11;
    uint64_t v14 = *(void *)(a1 + 280);
    a2 = 72;
    do
    {
      if ((*(uint64_t (**)(void))(**(void **)(v14 + 72 * v3 + 64) + 512))(*(void *)(v14 + 72 * v3 + 64))) {
        re::DynamicArray<re::WeakStringID>::add(v328, (void *)(v14 + 72 * v3 + 8));
      }
      unsigned int v15 = *(_DWORD *)(a1 + 296);
      uint64_t v14 = *(void *)(a1 + 280);
      if (v15 <= (int)v11 + 1) {
        unsigned int v15 = v11 + 1;
      }
      while (1)
      {
        uint64_t v3 = (v11 + 1);
        if (v15 - 1 == v11) {
          break;
        }
        LODWORD(v11) = v11 + 1;
        int v16 = v3;
        if ((*(_DWORD *)(v14 + 72 * v3) & 0x80000000) != 0) {
          goto LABEL_16;
        }
      }
      int v16 = v15;
LABEL_16:
      LODWORD(v11) = v16;
    }
    while (v10 != v16);
  }
  if (!v329) {
    return re::DynamicArray<re::WeakStringID>::deinit((uint64_t)v328);
  }
  uint64_t v18 = (__n128 *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 160))(*(void *)(a1 + 320));
  unint64_t v19 = v329;
  *(void *)&v383[1] = 0;
  *(void *)&v383[0] = v265;
  *((void *)&v383[0] + 1) = v329;
  if (v329)
  {
    if (v329 >= 0x2C0B02C0B02C0CLL)
    {
LABEL_418:
      re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 1488, v19);
      _os_crash();
      __break(1u);
    }
    else
    {
      uint64_t v20 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)v265 + 32))(v265, 1488 * v329, 16);
      *(void *)&v383[1] = v20;
      if (v20)
      {
        unint64_t v22 = v19 - 1;
        if (v22)
        {
          a2 = (unint64_t)v265;
          do
          {
            uint64_t v20 = re::RenderFrameContextBuilder::Result::PerSceneData::PerSceneData(v20, v265) + 1488;
            --v22;
          }
          while (v22);
        }
        else
        {
          a2 = (unint64_t)v265;
        }
        re::RenderFrameContextBuilder::Result::PerSceneData::PerSceneData(v20, (re::Allocator *)a2);
        goto LABEL_27;
      }
    }
    re::internal::assertLog((re::internal *)4, v21, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_420:
    re::internal::assertLog((re::internal *)6, v30, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 3040, v31);
    _os_crash();
    __break(1u);
    goto LABEL_421;
  }
LABEL_27:
  unint64_t v19 = (unint64_t)v265;
  if ((_OWORD *)v9 != v383)
  {
    uint64_t v23 = *(void *)v9;
    if (*(void *)v9 && v23 != *(void *)&v383[0])
    {
      re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      _os_crash();
      __break(1u);
LABEL_427:
      re::StringID::destroyString((re::StringID *)&v332);
      v332.n128_u64[0] = 0xAD1A32C714F7C026;
      v332.n128_u64[1] = (unint64_t)"meshshadow:textureGenerationWorkDivisionFactor";
      *(_DWORD *)double v370 = 0;
      re::DebugSettingsManager::getWithErrorCode<int>((uint64_t)v260, &v332, v370);
      re::StringID::destroyString((re::StringID *)&v332);
      goto LABEL_219;
    }
    uint64_t v24 = *(void *)(v6 + 32);
    uint64_t v25 = *(void *)(v6 + 40);
    uint64_t v26 = *((void *)&v383[0] + 1);
    uint64_t v27 = *(void *)&v383[1];
    *(void *)(v6 + 24) = *(void *)&v383[0];
    *(void *)(v6 + 32) = v26;
    *(void *)&v383[0] = v23;
    *((void *)&v383[0] + 1) = v24;
    *(void *)(v6 + 40) = v27;
    *(void *)&v383[1] = v25;
  }
  int v28 = (_anonymous_namespace_ *)re::FixedArray<re::RenderFrameContextBuilder::Result::PerSceneData>::deinit(v383);
  v305[0] = 0;
  memset(v306, 0, sizeof(v306));
  int v307 = 0;
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  int v310 = 0;
  uint64_t v311 = 0x1FFFFFFFFLL;
  __int16 v313 = 0;
  char v315 = 0;
  uint64_t v318 = 0;
  uint64_t v316 = 0;
  uint64_t v317 = 0;
  int v319 = 0;
  uint64_t v321 = 0;
  uint64_t v320 = 0;
  int v322 = 0;
  uint64_t v323 = 0x1FFFFFFFFLL;
  __int16 v325 = 0;
  char v327 = 0;
  uint64_t v312 = 0x80000000800;
  StringID v314 = v265;
  uint64_t v324 = 0x80000000800;
  long long v326 = v265;
  unint64_t v9 = v329;
  unint64_t v267 = v9;
  if (!v9)
  {
    unint64_t v19 = 0;
    goto LABEL_39;
  }
  unint64_t v31 = v9;
  if (v9 >= 0x158ED2308158EELL) {
    goto LABEL_420;
  }
  if (!v29)
  {
LABEL_421:
    re::internal::assertLog((re::internal *)4, v32, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_422:
    re::internal::assertLog((re::internal *)6, v36, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element std::string::size_type size = %zu, count = %zu", "!overflow", "init", 324, 56, v9);
    _os_crash();
    __break(1u);
    goto LABEL_423;
  }
  unint64_t v19 = (unint64_t)v29;
  uint64_t v33 = v29;
  unint64_t v34 = v9 - 1;
  if (v9 != 1)
  {
    uint64_t v33 = v29;
    do
    {
      *(void *)uint64_t v33 = 0;
      *((void *)v33 + 1) = 0;
      *((_DWORD *)v33 + 6) = 0;
      *((void *)v33 + 2) = 0;
      *((void *)v33 + 13) = 0;
      *((_DWORD *)v33 + 28) = 0;
      *((_DWORD *)v33 + 742) = 0;
      *(_OWORD *)((char *)v33 + 2936) = 0uLL;
      *(_OWORD *)((char *)v33 + 2952) = 0uLL;
      *((_OWORD *)v33 + 2) = 0uLL;
      *((_OWORD *)v33 + 3) = 0uLL;
      *((_OWORD *)v33 + 4) = 0uLL;
      *((_OWORD *)v33 + 5) = 0uLL;
      *((_DWORD *)v33 + 24) = 0;
      *(void *)((char *)v33 + 2972) = 0x7FFFFFFFLL;
      *((void *)v33 + 373) = v305;
      *((unsigned char *)v33 + 2992) = 1;
      uint64_t v35 = (_OWORD *)((char *)v33 + 3000);
      *((unsigned char *)v33 + 3032) = 0;
      uint64_t v33 = (_anonymous_namespace_ *)((char *)v33 + 3040);
      *uint64_t v35 = 0uLL;
      v35[1] = 0uLL;
      --v34;
    }
    while (v34);
  }
  *(void *)uint64_t v33 = 0;
  *((void *)v33 + 1) = 0;
  *((_DWORD *)v33 + 6) = 0;
  *((void *)v33 + 2) = 0;
  *((void *)v33 + 13) = 0;
  *((_DWORD *)v33 + 28) = 0;
  *((_DWORD *)v33 + 742) = 0;
  *(_OWORD *)((char *)v33 + 2936) = 0u;
  *(_OWORD *)((char *)v33 + 2952) = 0u;
  *((_OWORD *)v33 + 2) = 0u;
  *((_OWORD *)v33 + 3) = 0u;
  *((_OWORD *)v33 + 4) = 0u;
  *((_OWORD *)v33 + 5) = 0u;
  *((_DWORD *)v33 + 24) = 0;
  *(void *)((char *)v33 + 2972) = 0x7FFFFFFFLL;
  *((void *)v33 + 373) = v305;
  *((unsigned char *)v33 + 2992) = 1;
  *((unsigned char *)v33 + 3032) = 0;
  *(_OWORD *)((char *)v33 + 3000) = 0u;
  *(_OWORD *)((char *)v33 + 3016) = 0u;
LABEL_39:
  unint64_t v385 = 0;
  int v384 = 0;
  uint64_t v386 = 0;
  char v387 = 0;
  unint64_t v9 = v329;
  unint64_t v385 = v9;
  if (!v9) {
    goto LABEL_45;
  }
  if (v9 >= 0x492492492492493) {
    goto LABEL_422;
  }
  uint64_t v386 = v37;
  if (!v37)
  {
LABEL_423:
    re::internal::assertLog((re::internal *)4, v38, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_424:
    re::internal::assertLog((re::internal *)4, v161, "assertion failure: '%s' (%s:line %i) Mesh Shadow Global Data should not be nullptr if mesh shadow per frame update data exists", "meshShadowGlobalData", "build", 368);
    uint64_t v162 = _os_crash();
    __break(1u);
LABEL_425:
    v332.n128_u64[0] = 0x6F2CA1B2EF949A36;
    v332.n128_u64[1] = (unint64_t)"meshshadow:textureGenerationNominalDequeueSize";
    *(_DWORD *)double v370 = 0;
    re::DebugSettingsManager::getWithErrorCode<int>(v162, &v332, v370);
    goto LABEL_427;
  }
  unint64_t v39 = v9 - 1;
  if (v9 != 1)
  {
    do
    {
      *(_OWORD *)(v37 + 16) = 0uLL;
      *(_OWORD *)(v37 + 32) = 0uLL;
      *(void *)(v37 + 40) = 0;
      *(void *)(v37 + 48) = 0;
      *(_OWORD *)uint64_t v37 = 0uLL;
      *(_DWORD *)(v37 + 16) = 1;
      *(void *)(v37 + 24) = 0;
      *(void *)(v37 + 32) = 0;
      *(_DWORD *)(v37 + 48) = 0;
      v37 += 56;
      --v39;
    }
    while (v39);
  }
  *(_OWORD *)(v37 + 16) = 0u;
  *(_OWORD *)(v37 + 32) = 0u;
  *(void *)(v37 + 40) = 0;
  *(void *)(v37 + 48) = 0;
  *(_OWORD *)uint64_t v37 = 0u;
  *(_DWORD *)(v37 + 16) = 1;
  *(void *)(v37 + 24) = 0;
  *(void *)(v37 + 32) = 0;
  *(_DWORD *)(v37 + 48) = 0;
LABEL_45:
  unint64_t v268 = v19;
  unint64_t v269 = v6;
  uint64_t v40 = *(void *)(a1 + 320);
  *(void *)long long v258 = v40;
  uint64_t v41 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v40 + 312))(v40);
  if (v41)
  {
    uint64_t v42 = v41;
    memcpy((char *)v383 + 15, v41, 0x110uLL);
    if (v387)
    {
      memmove(v388, v42, 0x108uLL);
    }
    else
    {
      char v387 = 1;
      memcpy(v388, (char *)v383 + 15, 0x110uLL);
    }
  }
  int v270 = (re::RenderFrameData *)(a1 + 264);
  *(void *)&v383[2] = 0;
  memset((char *)v383 + 8, 0, 20);
  *(void *)&v383[0] = v265;
  uint64_t v43 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v383, 0);
  ++DWORD2(v383[1]);
  DWORD2(v383[2]) = 1065353216;
  memset((char *)&v383[4] + 8, 0, 24);
  *(void *)&v383[6] = 0xFFFFFFFFLL;
  BYTE8(v383[6]) = 0;
  *(_OWORD *)((char *)&v383[9] + 4) = xmmword_2343864E0;
  LODWORD(v383[9]) = 1065353216;
  DWORD1(v383[10]) = 12;
  *((void *)&v383[10] + 1) = 0x3CF5C28F3F800000;
  LOWORD(v383[11]) = 0;
  v383[12] = xmmword_2343864F0;
  *(void *)&v383[13] = 0x3EB333333F800000;
  a2 = 1;
  BYTE8(v383[13]) = 1;
  *(_OWORD *)((char *)&v383[13] + 12) = xmmword_234386500;
  *(_OWORD *)((char *)&v383[14] + 12) = xmmword_234386510;
  *(void *)((char *)&v383[15] + 12) = 0x3DCCCCCD41F00000;
  DWORD1(v383[16]) = 1097877340;
  BYTE8(v383[16]) = 1;
  v383[17] = xmmword_23435FD90;
  LOBYTE(v383[18]) = 1;
  *(void *)&v383[19] = 0x3F8000003F2D42C4;
  *((void *)&v383[19] + 1) = 0xA3F800000;
  v383[20] = xmmword_234386520;
  *(void *)&v383[21] = 1056964608;
  DWORD2(v383[21]) = 0x40000000;
  WORD6(v383[21]) = 256;
  LOWORD(v383[22]) = 1;
  BYTE2(v383[22]) = 0;
  DWORD1(v383[22]) = 897988541;
  *((void *)&v383[22] + 1) = 0;
  *(void *)&v383[23] = 0x3DCCCCCD3E800000;
  DWORD2(v383[23]) = 16;
  LOBYTE(v383[24]) = 1;
  *((void *)&v383[24] + 1) = 0;
  uint64_t v262 = a1;
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 88);
  signed int v44 = v329;
  long long v301 = 0u;
  long long v302 = 0u;
  int v303 = 0;
  uint64_t v304 = 0x7FFFFFFFLL;
  memset(v300, 0, 36);
  *(void *)&v300[36] = 0x7FFFFFFFLL;
  char v299 = 1;
  if (v3) {
    goto LABEL_416;
  }
  while (1)
  {
    unint64_t v260 = (long long *)v3;
    if (!v329) {
      break;
    }
    unint64_t v19 = 0;
    unint64_t v46 = 0x7FFFFFFFLL;
    uint64_t v3 = 24;
    do
    {
      unint64_t v47 = *(void *)(v269 + 32);
      if (v47 <= v19) {
        goto LABEL_402;
      }
      a2 = v331 + 8 * v19;
      v332.n128_u64[0] = *(void *)(v269 + 40) + 1488 * v19;
      unint64_t v48 = 0xBF58476D1CE4E5B9 * (*(void *)a2 ^ (*(void *)a2 >> 30));
      unint64_t v49 = (0x94D049BB133111EBLL * (v48 ^ (v48 >> 27))) ^ ((0x94D049BB133111EBLL * (v48 ^ (v48 >> 27))) >> 31);
      if (!(void)v301)
      {
        LODWORD(v50) = 0;
LABEL_59:
        re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addAsMove((uint64_t)&v301, v50, v49, (void *)(v331 + 8 * v19), &v332);
        ++HIDWORD(v304);
        unint64_t v47 = *(void *)(v269 + 32);
        goto LABEL_60;
      }
      unint64_t v50 = v49 % DWORD2(v302);
      uint64_t v51 = *(unsigned int *)(*((void *)&v301 + 1) + 4 * v50);
      if (v51 == 0x7FFFFFFF) {
        goto LABEL_59;
      }
      while (*(void *)(v302 + 24 * v51 + 8) != *(void *)a2)
      {
        LODWORD(v51) = *(_DWORD *)(v302 + 24 * v51) & 0x7FFFFFFF;
        if (v51 == 0x7FFFFFFF) {
          goto LABEL_59;
        }
      }
LABEL_60:
      if (v47 <= v19) {
        goto LABEL_403;
      }
      uint64_t v52 = *(void *)(v269 + 40);
      uint64_t v53 = *(void *)(re::RenderFrameData::stream(v270, (const re::WeakStringID *)a2) + 48);
      *(void *)(v52 + 1488 * v19 + 1480) = v53;
      if (v18) {
        BOOL v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 888))(v53) != 0;
      }
      else {
        BOOL v54 = 0;
      }
      *(unsigned char *)(v52 + 1488 * v19++ + 1456) = v54;
    }
    while (v19 < v329);
    if (!v329) {
      break;
    }
    unint64_t v46 = 0;
    uint64_t v3 = 1488;
    uint64_t v18 = &v332;
    unint64_t v6 = (unint64_t)v370;
LABEL_67:
    unint64_t v55 = v267;
    if (v46 == v267) {
      goto LABEL_407;
    }
    unint64_t v19 = v385;
    if (v385 <= v46) {
      goto LABEL_408;
    }
    a2 = v269;
    unint64_t v19 = *(void *)(v269 + 32);
    if (v19 <= v46) {
      goto LABEL_409;
    }
    uint64_t v56 = v331;
    uint64_t v261 = v386;
    unint64_t v19 = *(void *)(v269 + 40);
    unint64_t v57 = v19 + 1488 * v46;
    uint64_t v58 = (*(uint64_t (**)(void))(**(void **)(v57 + 1480) + 512))(*(void *)(v57 + 1480));
    *(void *)unint64_t v57 = v58;
    if (!*(unsigned char *)(v269 + 8))
    {
      char v59 = *(unsigned char *)(v58 + 32);
      *(unsigned char *)(v269 + 8) = 1;
      *(unsigned char *)(v269 + 9) = v59;
    }
    long long v60 = (const re::WeakStringID *)(v56 + 8 * v46);
    long long v61 = (re::LightContextBuilder *)(v268 + 3040 * v46);
    int v276 = (uint64_t **)(v19 + 1488 * v46);
    unint64_t v264 = v46;
    v276[1] = *(uint64_t **)v60;
    long long v266 = v60;
    a2 = re::RenderFrameData::stream(v270, v60);
    v276[14] = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v57 + 1480) + 640))(*(void *)(v57 + 1480), v62);
    uint64_t v278 = (uint64_t *)(v276 + 14);
    v276[15] = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v57 + 1480) + 672))(*(void *)(v57 + 1480), v63);
    unint64_t v46 = (unint64_t)(v276 + 15);
    uint64_t v280 = (uint64_t *)(v276 + 15);
    v276[89] = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v57 + 1480) + 840))(*(void *)(v57 + 1480), v64);
    v381[0] = &unk_26E71AF30;
    v381[1] = v61;
    int v382 = v381;
    uint64_t v263 = a2;
    long long v65 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(a2, (uint64_t *)&v332);
    unint64_t v47 = 0xBF58476D1CE4E5B9;
    if (v65)
    {
      if (v9)
      {
        a2 = *(void *)(v9 + 40);
        if (a2)
        {
          uint64_t v3 = 0;
          do
          {
            uint64_t v67 = re::BucketArray<re::LightInfoArrays,4ul>::operator[](v9, v3);
            if (!v382) {
              goto LABEL_417;
            }
            (*(void (**)(void *, uint64_t))(*v382 + 48))(v382, v67);
          }
          while (a2 != ++v3);
        }
      }
    }
    if (v382 == v381)
    {
      (*(void (**)(void *))(v381[0] + 32))(v381);
    }
    else if (v382)
    {
      (*(void (**)(void *, uint64_t))(*v382 + 40))(v382, v66);
    }
    uint64_t v68 = re::RenderFrameData::stream(v270, v266);
    uint64_t v69 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v68, (uint64_t *)&v332);
    if (v69)
    {
      unsigned __int8 v298 = 0;
      if (v70)
      {
        if (*((void *)v70 + 5))
        {
          if (!*((void *)v70 + 1)) {
            goto LABEL_414;
          }
          if (v70[16]) {
            v70 += 24;
          }
          else {
            char v70 = (unsigned __int8 *)*((void *)v70 + 4);
          }
          LODWORD(v70) = **(unsigned __int8 **)v70;
          if (v70)
          {
            LODWORD(v70) = 1;
            unsigned __int8 v298 = 1;
          }
        }
        else
        {
          LODWORD(v70) = 0;
        }
      }
    }
    else
    {
      LODWORD(v70) = 0;
      unsigned __int8 v298 = 0;
    }
    float v297 = 5.0;
    if (v260)
    {
      v332.n128_u64[0] = 0xDE63B48E3B4B8A1ELL;
      v332.n128_u64[1] = (unint64_t)"globaldirectionallight";
      re::DebugSettingsManager::getWithErrorCode<BOOL>((uint64_t)v260, &v332, &v298);
      re::StringID::destroyString((re::StringID *)&v332);
      v332.n128_u64[0] = 0xB06DDEFED9D91CB8;
      v332.n128_u64[1] = (unint64_t)"iblshadow:distanceforglobaldirectionallight";
      re::DebugSettingsManager::getWithErrorCode<float>((uint64_t)v260, &v332, &v297);
      re::StringID::destroyString((re::StringID *)&v332);
      LODWORD(v70) = v298;
    }
    if (v70) {
      re::LightContextBuilder::addGlobalDirectionalLight(v61, v297);
    }
    uint64_t v272 = (uint64_t)v276[89];
    if (v272)
    {
      uint64_t v271 = *(void *)(v272 + 40);
      if (v271)
      {
        unint64_t v71 = 0;
        uint64_t v274 = (unsigned char *)(v19 + 1488 * v264 + 1456);
        do
        {
          unint64_t v273 = v71;
          uint64_t v72 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v272, v71);
          uint64_t v73 = *(void *)(v72 + 16);
          if (v73)
          {
            a2 = *(void *)(v72 + 32);
            unint64_t v281 = a2 + 736 * v73;
            do
            {
              long long v74 = (uint64_t *)re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::tryGet((uint64_t)&v301, *(void *)a2 >> 1);
              if (v74)
              {
                uint64_t v3 = (uint64_t)v74;
                uint64_t v75 = *v74;
                uint64_t v76 = *v278;
                if (*v278)
                {
                  uint64_t v77 = *(void *)(v76 + 40);
                  if (v77)
                  {
                    unint64_t v78 = 0;
                    unint64_t v46 = v75 + 504;
                    do
                    {
                      unint64_t v19 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v76, v78);
                      *(void *)re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::addUninitialized(v75 + 504) = v19;
                      ++v78;
                    }
                    while (v77 != v78);
                  }
                }
                uint64_t v79 = *v280;
                if (*v280)
                {
                  uint64_t v80 = *(void *)(v79 + 40);
                  if (v80)
                  {
                    unint64_t v81 = 0;
                    unint64_t v46 = v75 + 560;
                    do
                    {
                      unint64_t v19 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v79, v81);
                      *(void *)re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::addUninitialized(v75 + 560) = v19;
                      ++v81;
                    }
                    while (v80 != v81);
                  }
                }
                if (*(unsigned char *)(a2 + 721)) {
                  *(void *)(*(void *)v3 + 1464) = **v276;
                }
                if (*(unsigned char *)(a2 + 722)) {
                  *(unsigned char *)(*(void *)v3 + 1456) = *v274;
                }
                *(unsigned char *)(v75 + 616) = *(unsigned char *)(a2 + 720);
                unint64_t v47 = 0xBF58476D1CE4E5B9;
              }
              a2 += 736;
            }
            while (a2 != v281);
          }
          unint64_t v71 = v273 + 1;
        }
        while (v273 + 1 != v271);
      }
    }
    uint64_t v82 = operator new(0x20uLL);
    uint64_t v83 = v263;
    *uint64_t v82 = &unk_26E71B000;
    v82[1] = v263;
    v82[2] = v276;
    void v82[3] = &v301;
    uint64_t v380 = v82;
    int v84 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v263, (uint64_t *)&v332);
    if (!v84
    {
LABEL_128:
      if (v380 == v379)
      {
        (*(void (**)(void *))(v379[0] + 32))(v379);
      }
      else if (v380)
      {
        (*(void (**)(void *, uint64_t))(*v380 + 40))(v380, v85);
      }
      uint64_t v88 = re::RenderFrameData::stream(v270, v266);
      uint64_t v89 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v88, (uint64_t *)&v332);
      if (v89)
      {
        uint64_t v91 = *(void *)v90;
        if (*(void *)v90)
        {
          if (*(void *)(v91 + 40))
          {
            if (!*(void *)(v91 + 8)) {
              goto LABEL_415;
            }
            if (*(unsigned char *)(v91 + 16)) {
              unint64_t v92 = (char **)(v91 + 24);
            }
            else {
              unint64_t v92 = *(char ***)(v91 + 32);
            }
            id v93 = *v276;
            uint64_t v277 = **v276;
            char v275 = **v92;
            unint64_t v282 = v93[3];
            unint64_t v296 = v282;
            if (v299)
            {
              uint64_t v94 = *v278;
              if (*v278)
              {
                a2 = *(void *)(v94 + 40);
                if (a2)
                {
                  unint64_t v19 = 0;
                  while (1)
                  {
                    uint64_t v90 = (_anonymous_namespace_ *)re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v94, v19);
                    uint64_t v95 = *((void *)v90 + 2);
                    if (v95) {
                      break;
                    }
LABEL_157:
                    if (++v19 == a2) {
                      goto LABEL_158;
                    }
                  }
                  long long v96 = (float32x4_t *)*((void *)v90 + 4);
                  uint64_t v97 = &v96[42 * v95];
                  while (2)
                  {
                    re::Projection::computeMatrix4x4F((re::Projection *)&v96[4], (uint64_t)&v284);
                    re::RenderCamera::computeInverseTransform(v96 + 2, (uint64_t)&v292);
                    uint64_t v99 = 0;
                    float32x4_t v100 = v284;
                    float32x4_t v101 = v285;
                    float32x4_t v102 = v286;
                    float32x4_t v103 = v287;
                    *(_OWORD *)double v370 = v292;
                    *(_OWORD *)&v370[16] = v293;
                    *(_OWORD *)&v370[32] = v294;
                    float32x4_t v371 = v295;
                    do
                    {
                      *(float32x4_t *)((char *)&v332 + v99) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v100, COERCE_FLOAT(*(_OWORD *)&v370[v99])), v101, *(float32x2_t *)&v370[v99], 1), v102, *(float32x4_t *)&v370[v99], 2), v103, *(float32x4_t *)&v370[v99], 3);
                      v99 += 16;
                    }
                    while (v99 != 64);
                    *(__n128 *)double v370 = v332;
                    *(float32x4_t *)&v370[16] = v333;
                    *(float32x4_t *)&v370[32] = v334;
                    float32x4_t v371 = v335;
                    re::buildCullingPlanes((uint64_t)v370, v98, (uint64_t)&v332, v332);
                    unint64_t v104 = v296;
                    if (!re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)v300, v296))
                    {
                      v286.i64[0] = 0;
                      v285.i64[0] = 0;
                      float32x4_t v284 = 0uLL;
                      v285.i32[2] = 0;
                      re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v300, (uint64_t *)&v296, (uint64_t)&v284);
                      re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::deinit((uint64_t)&v284);
                    }
                    if (*(void *)v300)
                    {
                      unint64_t v105 = 0x94D049BB133111EBLL
                           * ((0xBF58476D1CE4E5B9 * (v104 ^ (v104 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                               * (v104 ^ (v104 >> 30))) >> 27));
                      unint64_t v106 = (v105 ^ (v105 >> 31)) % *(unsigned int *)&v300[24];
                      uint64_t v107 = *(void *)&v300[16];
                      uint64_t v108 = *(unsigned int *)(*(void *)&v300[8] + 4 * v106);
                      if (v108 != 0x7FFFFFFF)
                      {
                        while (*(void *)(*(void *)&v300[16] + (v108 << 6) + 16) != v104)
                        {
                          uint64_t v108 = *(_DWORD *)(*(void *)&v300[16] + (v108 << 6) + 8) & 0x7FFFFFFF;
                          if (v108 == 0x7FFFFFFF) {
                            goto LABEL_155;
                          }
                        }
LABEL_156:
                        uint64_t v90 = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::add(v107 + (v108 << 6) + 24, v332.n128_u64);
                        v96 += 42;
                        if (v96 == v97) {
                          goto LABEL_157;
                        }
                        continue;
                      }
                    }
                    else
                    {
                      uint64_t v107 = *(void *)&v300[16];
                    }
                    break;
                  }
LABEL_155:
                  uint64_t v108 = 0x7FFFFFFFLL;
                  goto LABEL_156;
                }
              }
LABEL_158:
              uint64_t v109 = *v280;
              if (*v280)
              {
                unint64_t v19 = *(void *)(v109 + 40);
                if (v19)
                {
                  for (unint64_t i = 0; i != v19; ++i)
                  {
                    uint64_t v90 = (_anonymous_namespace_ *)re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v109, i);
                    uint64_t v111 = *((void *)v90 + 2);
                    if (!v111) {
                      continue;
                    }
                    uint64_t v112 = *((void *)v90 + 4);
                    uint64_t v113 = v112 + 1360 * v111;
                    do
                    {
                      uint64_t v114 = 0;
                      char v115 = 1;
                      do
                      {
                        char v116 = v115;
                        uint64_t v117 = (float32x4_t *)(v112 + 672 * v114);
                        re::Projection::computeMatrix4x4F((re::Projection *)&v117[4], (uint64_t)&v284);
                        re::RenderCamera::computeInverseTransform(v117 + 2, (uint64_t)&v292);
                        uint64_t v119 = 0;
                        float32x4_t v120 = v284;
                        float32x4_t v121 = v285;
                        float32x4_t v122 = v286;
                        float32x4_t v123 = v287;
                        *(_OWORD *)double v370 = v292;
                        *(_OWORD *)&v370[16] = v293;
                        *(_OWORD *)&v370[32] = v294;
                        float32x4_t v371 = v295;
                        do
                        {
                          *(float32x4_t *)((char *)&v332 + v119) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v120, COERCE_FLOAT(*(_OWORD *)&v370[v119])), v121, *(float32x2_t *)&v370[v119], 1), v122, *(float32x4_t *)&v370[v119], 2), v123, *(float32x4_t *)&v370[v119], 3);
                          v119 += 16;
                        }
                        while (v119 != 64);
                        *(__n128 *)double v370 = v332;
                        *(float32x4_t *)&v370[16] = v333;
                        *(float32x4_t *)&v370[32] = v334;
                        float32x4_t v371 = v335;
                        re::buildCullingPlanes((uint64_t)v370, v118, (uint64_t)&v332, v332);
                        a2 = v296;
                        if (!re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)v300, v296))
                        {
                          v286.i64[0] = 0;
                          v285.i64[0] = 0;
                          float32x4_t v284 = 0uLL;
                          v285.i32[2] = 0;
                          re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v300, (uint64_t *)&v296, (uint64_t)&v284);
                          re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::deinit((uint64_t)&v284);
                        }
                        if (!*(void *)v300)
                        {
                          uint64_t v126 = *(void *)&v300[16];
LABEL_174:
                          uint64_t v127 = 0x7FFFFFFFLL;
                          goto LABEL_175;
                        }
                        unint64_t v124 = 0x94D049BB133111EBLL
                             * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
                        unint64_t v125 = (v124 ^ (v124 >> 31)) % *(unsigned int *)&v300[24];
                        uint64_t v126 = *(void *)&v300[16];
                        uint64_t v127 = *(unsigned int *)(*(void *)&v300[8] + 4 * v125);
                        if (v127 == 0x7FFFFFFF) {
                          goto LABEL_174;
                        }
                        while (*(void *)(*(void *)&v300[16] + (v127 << 6) + 16) != a2)
                        {
                          uint64_t v127 = *(_DWORD *)(*(void *)&v300[16] + (v127 << 6) + 8) & 0x7FFFFFFF;
                          if (v127 == 0x7FFFFFFF) {
                            goto LABEL_174;
                          }
                        }
LABEL_175:
                        uint64_t v90 = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::add(v126 + (v127 << 6) + 24, v332.n128_u64);
                        char v115 = 0;
                        uint64_t v114 = 1;
                      }
                      while ((v116 & 1) != 0);
                      v112 += 1360;
                    }
                    while (v112 != v113);
                  }
                }
              }
            }
            uint64_t v128 = *(void *)&v383[1];
            uint64_t v83 = v263;
            if (*(void *)&v383[1] >= *((void *)&v383[0] + 1))
            {
              unint64_t v129 = *(void *)&v383[1] + 1;
              if (*((void *)&v383[0] + 1) < (unint64_t)(*(void *)&v383[1] + 1))
              {
                if (*(void *)&v383[0])
                {
                  unint64_t v130 = 8;
                  if (*((void *)&v383[0] + 1)) {
                    unint64_t v130 = 2 * *((void *)&v383[0] + 1);
                  }
                  if (v130 <= v129) {
                    unint64_t v131 = *(void *)&v383[1] + 1;
                  }
                  else {
                    unint64_t v131 = v130;
                  }
                  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v383, v131);
                }
                else
                {
                  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v383, v129);
                  ++DWORD2(v383[1]);
                }
              }
              uint64_t v128 = *(void *)&v383[1];
            }
            uint64_t v132 = *(void *)&v383[2] + 24 * v128;
            *(void *)uint64_t v132 = v277;
            *(unsigned char *)(v132 + 8) = v275;
            *(_DWORD *)(v132 + 9) = v332.n128_u32[0];
            *(_DWORD *)(v132 + 12) = *(unsigned __int32 *)((char *)v332.n128_u32 + 3);
            *(void *)(v132 + 16) = v282;
            ++*(void *)&v383[1];
            ++DWORD2(v383[1]);
            if (!v282) {
              DWORD2(v383[2]) = 1065353216;
            }
          }
        }
      }
      v377[0] = &unk_26E71B090;
      v377[1] = v261 + 56 * v264;
      int v378 = v377;
      uint64_t v133 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v83, (uint64_t *)&v332);
      uint64_t v3 = 1488;
      if (!v133
      {
LABEL_197:
        if (v378 == v377)
        {
          (*(void (**)(void *))(v377[0] + 32))(v377);
        }
        else if (v378)
        {
          (*(void (**)(void *, uint64_t))(*v378 + 40))(v378, v134);
        }
        unint64_t v46 = v264 + 1;
        if (v264 + 1 >= v329) {
          break;
        }
        goto LABEL_67;
      }
      a2 = 0;
      while (1)
      {
        uint64_t v135 = re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::operator[](v9, a2);
        if (!v378) {
          break;
        }
        (*(void (**)(void *, uint64_t))(*v378 + 48))(v378, v135);
        if (v19 == ++a2) {
          goto LABEL_197;
        }
      }
LABEL_417:
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_418;
    }
    unint64_t v19 = 0;
    uint64_t v3 = v9 + 24;
    while (1)
    {
      unint64_t v86 = *(void *)(v9 + 40);
      if (v86 <= v19) {
        break;
      }
      unint64_t v46 = v19 >> 2;
      unint64_t v47 = *(void *)(v9 + 8);
      if (v47 <= v19 >> 2) {
        goto LABEL_401;
      }
      unint64_t v87 = v9 + 24;
      if ((*(unsigned char *)(v9 + 16) & 1) == 0) {
        unint64_t v87 = *(void *)(v9 + 32);
      }
      unint64_t v47 = 0xBF58476D1CE4E5B9;
      if (!v380) {
        goto LABEL_417;
      }
      (*(void (**)(void *, unint64_t))(*v380 + 48))(v380, *(void *)(v87 + 8 * v46) + 736 * (v19++ & 3));
      if (a2 == v19) {
        goto LABEL_128;
      }
    }
    re::internal::assertLog((re::internal *)6, v85, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1011, v19, v86);
    _os_crash();
    __break(1u);
LABEL_401:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 858;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v46;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v47;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_402:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v19;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v47;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_403:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v19;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v47;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_404:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    unint64_t v203 = v202;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v203;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v203;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_405:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v47;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v203;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_406:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v47;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v203;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_407:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    unint64_t v19 = v55;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v19;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_408:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v46;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_409:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 468;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = v46;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_410:
    re::internal::assertLog((re::internal *)4, v233, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
    _os_crash();
    __break(1u);
LABEL_411:
    re::internal::assertLog((re::internal *)4, v236, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
    _os_crash();
    __break(1u);
LABEL_412:
    re::internal::assertLog((re::internal *)4, v239, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
    _os_crash();
    __break(1u);
LABEL_413:
    re::internal::assertLog((re::internal *)4, v243, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
    _os_crash();
    __break(1u);
LABEL_414:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 866;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = 0;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_415:
    v284.i64[0] = 0;
    float32x4_t v335 = 0u;
    float32x4_t v336 = 0u;
    float32x4_t v333 = 0u;
    float32x4_t v334 = 0u;
    __n128 v332 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v370 = 136315906;
    *(void *)&v370[4] = "operator[]";
    *(_WORD *)&v370[12] = 1024;
    *(_DWORD *)&v370[14] = 866;
    *(_WORD *)&v370[18] = 2048;
    *(void *)&v370[20] = 0;
    *(_WORD *)&v370[28] = 2048;
    *(void *)&v370[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_416:
    v332.n128_u64[0] = 0xBEE9CE6A024C1838;
    v332.n128_u64[1] = (unint64_t)"meshshadow:textureGenerationEnableViewFrustumCulling";
    re::DebugSettingsManager::getWithErrorCode<BOOL>(v3, &v332, &v299);
    re::StringID::destroyString((re::StringID *)&v332);
  }
  re::LightContextAtlasContainer::allocateTiles((re::LightContextAtlasContainer *)v305);
  re::ProjectiveShadowBuilder::build(*(re::RenderManager **)(v262 + 8), (uint64_t)&v384, (uint64_t)v256, (uint64_t)&v292);
  *(void *)unint64_t v269 = v292;
  unint64_t v137 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v269 + 16) + 280))(*(void *)(v269 + 16), v136);
  if (v137)
  {
    a2 = v137;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B468, memory_order_acquire) & 1) == 0)
    {
      unint64_t v137 = __cxa_guard_acquire(&qword_26AF9B468);
      if (v137)
      {
        _MergedGlobals_448 = re::hashString((re *)v137, v253);
        __cxa_guard_release(&qword_26AF9B468);
      }
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B478, memory_order_acquire) & 1) == 0)
    {
      unint64_t v137 = __cxa_guard_acquire(&qword_26AF9B478);
      if (v137)
      {
        qword_26AF9B470 = re::getCombinedScopeHash(_MergedGlobals_448, v254, v255);
        __cxa_guard_release(&qword_26AF9B478);
      }
    }
    unint64_t v138 = (unint64_t)"N2re27RenderGraphDataStoreWrapperINS_11OpenSkyDataEEE";
    if (((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_11OpenSkyDataEEE" & 0x8000000000000000) != 0)
    {
      uint64_t v139 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperINS_11OpenSkyDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v140 = 5381;
      do
      {
        unint64_t v138 = v140;
        unsigned int v141 = *v139++;
        uint64_t v140 = (33 * v140) ^ v141;
      }
      while (v141);
    }
    unint64_t v142 = (qword_26AF9B470 + (v138 << 6) + (v138 >> 2) - 0x61C8864680B583E9) ^ v138;
    long long v143 = re::globalAllocators((re *)v137);
    uint64_t v144 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v143[2] + 32))(v143[2], 224, 16);
    *(void *)uint64_t v144 = &unk_26E71B138;
    long long v145 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v144 + 16) = *(_OWORD *)a2;
    *(_OWORD *)(v144 + 32) = v145;
    long long v146 = *(_OWORD *)(a2 + 32);
    long long v147 = *(_OWORD *)(a2 + 48);
    long long v148 = *(_OWORD *)(a2 + 64);
    *(_DWORD *)(v144 + 96) = *(_DWORD *)(a2 + 80);
    *(_OWORD *)(v144 + 64) = v147;
    *(_OWORD *)(v144 + 80) = v148;
    *(_OWORD *)(v144 + 48) = v146;
    *(void *)(v144 + 136) = 0;
    *(void *)(v144 + 112) = 0;
    *(void *)(v144 + 120) = 0;
    *(void *)(v144 + 104) = 0;
    *(_DWORD *)(v144 + 128) = 0;
    *(void *)(v144 + 104) = *(void *)(a2 + 88);
    *(void *)(a2 + 88) = 0;
    *(void *)(v144 + 112) = *(void *)(a2 + 96);
    *(void *)(a2 + 96) = 0;
    uint64_t v149 = *(void *)(v144 + 120);
    *(void *)(v144 + 120) = *(void *)(a2 + 104);
    *(void *)(a2 + 104) = v149;
    uint64_t v150 = *(void *)(v144 + 136);
    *(void *)(v144 + 136) = *(void *)(a2 + 120);
    *(void *)(a2 + 120) = v150;
    ++*(_DWORD *)(a2 + 112);
    ++*(_DWORD *)(v144 + 128);
    *(void *)(v144 + 176) = 0;
    *(void *)(v144 + 152) = 0;
    *(void *)(v144 + 160) = 0;
    *(void *)(v144 + 144) = 0;
    *(_DWORD *)(v144 + 168) = 0;
    *(void *)(v144 + 144) = *(void *)(a2 + 128);
    *(void *)(a2 + 128) = 0;
    *(void *)(v144 + 152) = *(void *)(a2 + 136);
    *(void *)(a2 + 136) = 0;
    uint64_t v151 = *(void *)(v144 + 160);
    *(void *)(v144 + 160) = *(void *)(a2 + 144);
    *(void *)(a2 + 144) = v151;
    uint64_t v152 = *(void *)(v144 + 176);
    *(void *)(v144 + 176) = *(void *)(a2 + 160);
    *(void *)(a2 + 160) = v152;
    ++*(_DWORD *)(a2 + 152);
    ++*(_DWORD *)(v144 + 168);
    long long v153 = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(v144 + 193) = *(_OWORD *)(a2 + 177);
    *(_OWORD *)(v144 + 184) = v153;
    unint64_t v154 = *(void *)(v262 + 48);
    if (!v154) {
      goto LABEL_210;
    }
    unint64_t v154 = v142 % *(unsigned int *)(v262 + 72);
    uint64_t v155 = *(unsigned int *)(*(void *)(v262 + 56) + 4 * v154);
    if (v155 == 0x7FFFFFFF) {
      goto LABEL_210;
    }
    uint64_t v171 = *(void *)(v262 + 64);
    if (*(void *)(v171 + 24 * v155 + 8) != v142)
    {
      while (1)
      {
        LODWORD(v155) = *(_DWORD *)(v171 + 24 * v155) & 0x7FFFFFFF;
        if (v155 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v171 + 24 * v155 + 8) == v142) {
          goto LABEL_216;
        }
      }
LABEL_210:
      unint64_t v19 = *(unsigned int *)(v262 + 84);
      if (v19 == 0x7FFFFFFF)
      {
        unint64_t v19 = *(unsigned int *)(v262 + 80);
        int v156 = v19;
        if (v19 == *(_DWORD *)(v262 + 72))
        {
          re::HashTable<unsigned long,re::RenderGraphData *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(v262 + 48, 2 * *(_DWORD *)(v262 + 76));
          LODWORD(v154) = v142 % *(unsigned int *)(v262 + 72);
          int v156 = *(_DWORD *)(v262 + 80);
        }
        *(_DWORD *)(v262 + 80) = v156 + 1;
        uint64_t v157 = *(void *)(v262 + 64);
        int v158 = *(_DWORD *)(v157 + 24 * v19);
      }
      else
      {
        uint64_t v157 = *(void *)(v262 + 64);
        int v158 = *(_DWORD *)(v157 + 24 * v19);
        *(_DWORD *)(v262 + 84) = v158 & 0x7FFFFFFF;
      }
      uint64_t v159 = 24 * v19;
      *(_DWORD *)(v157 + v159) = v158 | 0x80000000;
      *(_DWORD *)(*(void *)(v262 + 64) + v159) = *(_DWORD *)(*(void *)(v262 + 64) + 24 * v19) & 0x80000000 | *(_DWORD *)(*(void *)(v262 + 56) + 4 * v154);
      *(void *)(*(void *)(v262 + 64) + 24 * v19 + 8) = v142;
      *(void *)(*(void *)(v262 + 64) + 24 * v19 + 16) = v144;
      *(_DWORD *)(*(void *)(v262 + 56) + 4 * v154) = v19;
      ++*(_DWORD *)(v262 + 76);
      ++*(_DWORD *)(v262 + 88);
    }
  }
LABEL_216:
  uint64_t v18 = (__n128 *)(*(uint64_t (**)(void))(**(void **)v258 + 376))(*(void *)v258);
  uint64_t v160 = (*(uint64_t (**)(void))(**(void **)v258 + 344))(*(void *)v258);
  if (!v18) {
    goto LABEL_286;
  }
  unint64_t v6 = v160;
  if (!v160) {
    goto LABEL_424;
  }
  a2 = (unint64_t)&v383[4] + 8;
  unint64_t v19 = v257[21];
  uint64_t v3 = v19 + 336;
  uint64_t v162 = (uint64_t)v260;
  if (v260) {
    goto LABEL_425;
  }
LABEL_219:
  v370[0] = 0;
  if (v299)
  {
    uint64_t v163 = *(float32x4_t **)(v19 + 256);
    float32x4_t v164 = v163[28];
    float32x4_t v284 = v163[27];
    float32x4_t v285 = v164;
    __n128 v165 = *(float32x4_t **)(v19 + 296);
    float32x4_t v166 = v165[28];
    float32x4_t v286 = v165[27];
    float32x4_t v287 = v166;
    int v291 = 0;
    uint64_t v167 = *(void *)&v300[16];
    v332.n128_u8[0] = 1;
    float32x4_t v335 = v286;
    float32x4_t v336 = v166;
    float32x4_t v333 = v284;
    float32x4_t v334 = v164;
    LODWORD(v340) = 0;
    long long v288 = 0u;
    uint64_t v289 = 0;
    long long v290 = xmmword_23436F740;
    v370[0] = 1;
    *(float32x4_t *)&v370[16] = v284;
    *(float32x4_t *)&v370[32] = v164;
    float32x4_t v371 = v286;
    float32x4_t v372 = v166;
    int v376 = 0;
    long long v168 = *(_OWORD *)v300;
    memset(v300, 0, 24);
    long long v373 = v168;
    long long v337 = 0u;
    uint64_t v374 = v167;
    uint64_t v338 = 0;
    long long v169 = *(_OWORD *)&v300[24];
    *(_OWORD *)&v300[24] = xmmword_23436F740;
    long long v375 = v169;
    long long v339 = xmmword_23436F740;
    re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v337);
    re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v288);
  }
  re::PersistentShadowState::consumeMeshShadowUpdate(v3);
  atomic_store(*(void *)(v6 + 344), (unint64_t *)(v19 + 888));
  long long v170 = *(_OWORD *)v6;
  *(void *)&v383[4] = *(void *)(v6 + 16);
  v383[3] = v170;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)a2, *(void *)(v6 + 24));
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)&v383[5], *(void *)(v6 + 32));
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)&v383[5] + 1, *(void *)(v6 + 40));
  *(void *)&v383[6] = *(void *)(v6 + 48);
  if (BYTE8(v383[6]) || *(unsigned char *)(v6 + 56))
  {
    if (!BYTE8(v383[6]) || *(unsigned char *)(v6 + 56))
    {
      if (BYTE8(v383[6]) || !*(unsigned char *)(v6 + 56))
      {
        re::StringID::operator=((unint64_t *)&v383[7], (uint64_t *)(v6 + 64));
      }
      else
      {
        BYTE8(v383[6]) = 1;
        re::StringID::StringID((re::StringID *)&v383[7], (const StringID *)(v6 + 64));
      }
    }
    else
    {
      re::StringID::destroyString((re::StringID *)&v383[7]);
      BYTE8(v383[6]) = 0;
    }
  }
  memcpy(&v383[8], (const void *)(v6 + 80), 0x110uLL);
  uint64_t v172 = v262;
  re::ProjectiveMeshShadowBuilder::buildShadowGenerationData(v3, (uint64_t)&v284, (uint64_t)v18, (uint64_t)v265, v383, v262, &v332);
  if (v332.n128_u8[0])
  {
    uint64_t v174 = (float32x4_t *)(v19 + 776);
    a2 = v19 + 720;
    re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v19 + 720, &v332.n128_i64[1]);
    if ((__int8 *)(v19 + 720) != &v332.n128_i8[8])
    {
      uint64_t v176 = *(void *)(v19 + 768);
      if (v176 && v335.i64[1] && v176 != v335.i64[1])
      {
        re::internal::assertLog((re::internal *)4, v175, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
        _os_crash();
        __break(1u);
      }
      *(void *)(v19 + 768) = v335.i64[1];
      v335.i64[1] = v176;
      float32x4_t v177 = *v174;
      *uint64_t v174 = v336;
      float32x4_t v336 = v177;
      uint64_t v178 = *(void *)(v19 + 800);
      *(void *)(v19 + 800) = *((void *)&v337 + 1);
      *((void *)&v337 + 1) = v178;
      LODWORD(v337) = v337 + 1;
      ++*(_DWORD *)(v19 + 792);
    }
    if ((__int8 *)a2 != &v332.n128_i8[8])
    {
      uint64_t v179 = *(void *)(v19 + 808);
      uint64_t v180 = v338;
      if (!v179 || v179 == v338)
      {
        *(void *)(v19 + 808) = v338;
        uint64_t v338 = v179;
        uint64_t v197 = *((void *)&v339 + 1);
        long long v198 = *(_OWORD *)(v19 + 816);
        long long v199 = *(_OWORD *)(v19 + 832);
        *(void *)(v19 + 816) = v339;
        *(void *)(v19 + 824) = v197;
        long long v339 = v198;
        *(_OWORD *)(v19 + 832) = v340;
        long long v340 = v199;
      }
      else
      {
        if (*(_DWORD *)(v19 + 836))
        {
          uint64_t v181 = *(unsigned int *)(v19 + 832);
          if (v181) {
            memset_pattern16(*(void **)(v19 + 816), &unk_2343655D0, 4 * v181);
          }
          uint64_t v182 = *(unsigned int *)(v19 + 840);
          if (v182)
          {
            uint64_t v183 = 0;
            uint64_t v184 = 32 * v182;
            do
            {
              uint64_t v185 = *(void *)(v19 + 824) + v183;
              int v186 = *(_DWORD *)(v185 + 8);
              if (v186 < 0) {
                *(_DWORD *)(v185 + 8) = v186 & 0x7FFFFFFF;
              }
              v183 += 32;
            }
            while (v184 != v183);
          }
          *(_DWORD *)(v19 + 844) = 0x7FFFFFFF;
          *(_DWORD *)(v19 + 836) = 0;
          *(_DWORD *)(v19 + 840) = 0;
          ++*(_DWORD *)(v19 + 848);
        }
        if (v180)
        {
          if (*(_DWORD *)(v19 + 832) < DWORD1(v340)) {
            re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v19 + 808, DWORD1(v340));
          }
          unint64_t v187 = DWORD2(v340);
          if (DWORD2(v340))
          {
            a2 = 0;
            unint64_t v188 = 0;
            do
            {
              double v189 = (unint64_t *)(*((void *)&v339 + 1) + a2);
              if ((*(_DWORD *)(*((void *)&v339 + 1) + a2 + 8) & 0x80000000) != 0)
              {
                unint64_t v190 = *v189;
                unint64_t v191 = *(unsigned int *)(v19 + 832);
                unint64_t v192 = *v189 % v191;
                uint64_t v193 = *(unsigned int *)(v19 + 844);
                if (v193 == 0x7FFFFFFF)
                {
                  uint64_t v193 = *(unsigned int *)(v19 + 840);
                  int v194 = v193;
                  if (v193 == v191)
                  {
                    re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v19 + 808, 2 * *(_DWORD *)(v19 + 836));
                    unint64_t v192 = v190 % *(unsigned int *)(v19 + 832);
                    int v194 = *(_DWORD *)(v19 + 840);
                  }
                  *(_DWORD *)(v19 + 840) = v194 + 1;
                  uint64_t v195 = *(void *)(v19 + 824);
                  int v196 = *(_DWORD *)(v195 + 32 * v193 + 8);
                }
                else
                {
                  uint64_t v195 = *(void *)(v19 + 824);
                  int v196 = *(_DWORD *)(v195 + 32 * v193 + 8);
                  *(_DWORD *)(v19 + 844) = v196 & 0x7FFFFFFF;
                }
                *(_DWORD *)(v195 + 32 * v193 + 8) = v196 | 0x80000000;
                *(_DWORD *)(*(void *)(v19 + 824) + 32 * v193 + 8) = *(_DWORD *)(*(void *)(v19 + 824) + 32 * v193 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v19 + 816) + 4 * v192);
                *(void *)(*(void *)(v19 + 824) + 32 * v193) = v190;
                *(void *)(*(void *)(v19 + 824) + 32 * v193 + 16) = v189[2];
                *(void *)(*(void *)(v19 + 824) + 32 * v193 + 24) = v189[3];
                *(_DWORD *)(*(void *)(v19 + 816) + 4 * v192) = v193;
                ++*(_DWORD *)(v19 + 836);
                unint64_t v187 = DWORD2(v340);
              }
              ++v188;
              a2 += 32;
            }
            while (v188 < v187);
          }
          ++*(_DWORD *)(v19 + 848);
        }
      }
    }
    uint64_t v200 = *(void *)(v19 + 856);
    *(void *)(v19 + 856) = v342;
    uint64_t v342 = v200;
    re::FixedArray<float>::operator=((uint64_t *)(v19 + 864), &v343);
    uint64_t v172 = v262;
    if (v332.n128_u8[0])
    {
      a2 = (unint64_t)&v338;
      if (v343)
      {
        if (v344)
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v343 + 40))(v343, v345);
          uint64_t v344 = 0;
          uint64_t v345 = 0;
        }
        uint64_t v343 = 0;
      }
      if (v342)
      {

        uint64_t v342 = 0;
      }
      double v201 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(&v338);
      if (v335.i64[1])
      {
        if (*((void *)&v337 + 1)) {
          (*(void (**)(double))(*(void *)v335.i64[1] + 40))(v201);
        }
        *((void *)&v337 + 1) = 0;
        float32x4_t v336 = 0uLL;
        v335.i64[1] = 0;
        LODWORD(v337) = v337 + 1;
      }
      v173.n128_f64[0] = re::HashTable<unsigned long long,re::HashSet<re::ecs2::Entity *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(&v332.n128_i64[1]);
    }
  }
  if (v287.i64[0])
  {
    if (v289) {
      (*(void (**)(__n128))(*(void *)v287.i64[0] + 40))(v173);
    }
    uint64_t v289 = 0;
    *(void *)&long long v288 = 0;
    float32x4_t v287 = 0uLL;
    ++DWORD2(v288);
  }
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v284);
  if (v370[0]) {
    re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v373);
  }
  re::ProjectiveMeshShadowBuilder::buildShadowRenderingData((uint64_t)&v297, (re::PersistentShadowState *)(v257[21] + 336), v257[21] + 720, *(re::MaterialParameterTableBuilder **)(v172 + 376), (unint64_t)v383, (unint64_t)v18, v172);
LABEL_286:
  uint64_t v3 = v269;
  uint64_t v18 = (__n128 *)v270;
  unint64_t v202 = v267;
  if (v329)
  {
    unint64_t v47 = 0;
    int v279 = 0;
    unint64_t v260 = &v362;
    long long v257 = v361;
    long long v258 = &v364;
    long long v256 = v359;
    unint64_t v46 = (unint64_t)v368;
    while (v47 != v202)
    {
      unint64_t v203 = *(void *)(v3 + 32);
      if (v203 <= v47) {
        goto LABEL_405;
      }
      long long v204 = (const re::WeakStringID *)(v331 + 8 * v47);
      unint64_t v19 = *(void *)(v3 + 40);
      a2 = re::RenderFrameData::stream((re::RenderFrameData *)v18, v204);
      uint64_t v205 = *(void *)(re::RenderFrameData::stream((re::RenderFrameData *)v18, v204) + 48);
      uint64_t v18 = (__n128 *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v205 + 552))(v205, v206);
      v333.i64[0] = 0;
      v333.i32[2] = 0;
      v334.i64[0] = 0;
      __n128 v332 = (__n128)(unint64_t)v265;
      re::DynamicArray<re::MeshScene>::setCapacity(&v332, 0);
      ++v333.i32[2];
      v368[0] = &unk_26E71B160;
      v368[1] = &v332;
      double v369 = v368;
      uint64_t v207 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(a2, (uint64_t *)v370);
      if (v207)
      {
        if (v209)
        {
          unint64_t v9 = *(void *)(v209 + 40);
          if (v9)
          {
            unint64_t v6 = 0;
            do
            {
              uint64_t v210 = re::BucketArray<re::MeshScene,4ul>::operator[](v209, v6);
              if (!v369) {
                goto LABEL_417;
              }
              (*(void (**)(void *, uint64_t))(*v369 + 48))(v369, v210);
            }
            while (v9 != ++v6);
          }
        }
      }
      if (v369 == v368)
      {
        (*(void (**)(void *))(v368[0] + 32))(v368);
        unint64_t v46 = v262;
        unint64_t v6 = 1488;
      }
      else
      {
        unint64_t v46 = v262;
        unint64_t v6 = 1488;
        if (v369) {
          (*(void (**)(void *, uint64_t))(*v369 + 40))(v369, v208);
        }
      }
      unint64_t v283 = v19;
      uint64_t v211 = v19 + 1488 * v47 + 40;
      if (v333.i64[0])
      {
        uint64_t v212 = re::BucketArray<re::MeshSceneCollection,16ul>::addUninitialized(v19 + 1488 * v47 + 40);
        *(void *)(v212 + 32) = 0;
        *(_DWORD *)(v212 + 24) = 0;
        *(void *)(v212 + 8) = 0;
        *(void *)(v212 + 16) = 0;
        *(void *)uint64_t v212 = 0;
        *(__n128 *)uint64_t v212 = v332;
        *(void *)(v212 + 16) = v333.i64[0];
        __n128 v332 = 0uLL;
        v333.i64[0] = 0;
        *(void *)(v212 + 32) = v334.i64[0];
        v334.i64[0] = 0;
        ++v333.i32[2];
        ++*(_DWORD *)(v212 + 24);
      }
      re::DynamicArray<re::MeshScene>::deinit((uint64_t)&v332);
      uint64_t v3 = v269;
      if (v18)
      {
        unint64_t v213 = v18[2].n128_u64[1];
        if (v213)
        {
          for (unint64_t j = 0; j != v213; ++j)
          {
            uint64_t v215 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)v18, j);
            re::BucketArray<re::MeshSceneCollection,16ul>::add(v211, v215);
          }
        }
      }
      unint64_t v19 = (unint64_t)v366;
      v366[0] = &unk_26E71B1F0;
      v366[1] = v211;
      double v367 = v366;
      unint64_t v216 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(a2, (uint64_t *)&v332);
      if (v216)
      {
        if (v18)
        {
          unint64_t v9 = v18[2].n128_u64[1];
          if (v9)
          {
            a2 = 0;
            do
            {
              uint64_t v218 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[]((uint64_t)v18, a2);
              if (!v367) {
                goto LABEL_417;
              }
              (*(void (**)(void *, uint64_t))(*v367 + 48))(v367, v218);
            }
            while (v9 != ++a2);
          }
        }
      }
      if (v367 == v366)
      {
        (*(void (**)(void *))(v366[0] + 32))(v366);
      }
      else if (v367)
      {
        (*(void (**)(void *, uint64_t))(*v367 + 40))(v367, v217);
      }
      unint64_t v219 = v283 + 1488 * v47;
      *(void *)(v219 + 96) = (*(uint64_t (**)(void))(**(void **)(v219 + 1480) + 600))(*(void *)(v219 + 1480));
      *(void *)(v219 + 104) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v219 + 1480) + 768))(*(void *)(v219 + 1480), v220);
      uint64_t v18 = (__n128 *)(v219 + 104);
      *(void *)(v219 + 696) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v219 + 1480) + 704))(*(void *)(v219 + 1480), v221);
      *(void *)(v219 + 704) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v219 + 1480) + 736))(*(void *)(v219 + 1480), v222);
      if (!*(unsigned char *)(v268 + 3040 * v47 + 2992))
      {
        long long v223 = (void *)(v219 + 1480);
        long long v224 = *(re::Allocator **)(v46 + 376);
        uint64_t v18 = (__n128 *)v18->n128_u64[0];
        unint64_t v225 = v283 + 1488 * v47;
        a2 = *(void *)(v225 + 112);
        unint64_t v46 = *(void *)(v225 + 120);
        uint64_t v226 = (*(uint64_t (**)(void))(*(void *)*v223 + 872))(*v223);
        re::LightContextBuilder::build(v268 + 3040 * v47, v224, v259, v211, (uint64_t)v18, a2, v46, v225 + 504, (uint64_t)&v332, v226);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v225 + 128, (uint64_t)&v332);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v225 + 168, (uint64_t)&v334.i64[1]);
        re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator=((void *)(v225 + 208), &v337);
        re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::operator=(v225 + 264, &v341);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 312), &v346);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 336), &v349);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 360), &v352);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 384), &v355);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 408), &v358);
        re::FixedArray<float>::operator=((uint64_t *)(v225 + 432), &v360);
        long long v227 = v362;
        *(unsigned char *)(v225 + 472) = v363;
        *(_OWORD *)(v225 + 456) = v227;
        char v228 = v365;
        *(_OWORD *)(v225 + 480) = v364;
        *(unsigned char *)(v225 + 496) = v228;
        if (v360)
        {
          if (v361[0])
          {
            (*(void (**)(void))(*(void *)v360 + 40))();
            v361[0] = 0;
            v361[1] = 0;
          }
          uint64_t v360 = 0;
        }
        uint64_t v3 = v269;
        if (v358)
        {
          if (v359[0])
          {
            (*(void (**)(void))(*(void *)v358 + 40))();
            v359[0] = 0;
            v359[1] = 0;
          }
          uint64_t v358 = 0;
        }
        if (v355)
        {
          if (v356)
          {
            (*(void (**)(void))(*(void *)v355 + 40))();
            uint64_t v356 = 0;
            uint64_t v357 = 0;
          }
          uint64_t v355 = 0;
        }
        if (v352)
        {
          if (v353)
          {
            (*(void (**)(void))(*(void *)v352 + 40))();
            uint64_t v353 = 0;
            uint64_t v354 = 0;
          }
          uint64_t v352 = 0;
        }
        if (v349)
        {
          if (v350)
          {
            (*(void (**)(void))(*(void *)v349 + 40))();
            uint64_t v350 = 0;
            uint64_t v351 = 0;
          }
          uint64_t v349 = 0;
        }
        if (v346)
        {
          if (v347)
          {
            (*(void (**)(void))(*(void *)v346 + 40))();
            uint64_t v347 = 0;
            uint64_t v348 = 0;
          }
          uint64_t v346 = 0;
        }
        re::HashTable<re::ecs2::Scene const*,re::HashTable<re::ecs2::Entity *,re::ecs2::ImageBasedLightReceiverComponent *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit(&v341);
        re::BucketArray<re::LightContext,16ul>::deinit((uint64_t)&v337);
        if ((void)v337)
        {
          int v229 = v338;
          if ((v338 & 1) == 0)
          {
            (*(void (**)(void))(*(void *)v337 + 40))();
            int v229 = v338;
          }
          long long v337 = 0uLL;
          LODWORD(v338) = (v229 | 1) + 2;
        }
        re::DynamicArray<re::FilterView>::deinit((uint64_t)&v334.i64[1]);
        re::DynamicArray<re::ShadowView>::deinit((uint64_t)&v332);
      }
      unint64_t v203 = v293;
      if ((unint64_t)v293 <= v47) {
        goto LABEL_406;
      }
      uint64_t v230 = *((void *)&v293 + 1);
      uint64_t v18 = (__n128 *)v270;
      uint64_t v231 = re::RenderFrameData::stream(v270, v204);
      uint64_t v232 = re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v231, (uint64_t *)&v332);
      if (v232)
      {
        unint64_t v46 = (unint64_t)v368;
        unint64_t v19 = v283;
        if (v232)
        {
          if (!*(void *)(v232 + 40)) {
            goto LABEL_410;
          }
          uint64_t v232 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v232, 0);
        }
      }
      else
      {
        unint64_t v46 = (unint64_t)v368;
        unint64_t v19 = v283;
      }
      *(void *)(v19 + 1488 * v47 + 16) = v232;
      uint64_t v234 = re::RenderFrameData::stream(v270, v204);
      uint64_t v235 = re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v234, (uint64_t *)&v332);
      if (v235)
      {
        if (v235)
        {
          if (!*(void *)(v235 + 40)) {
            goto LABEL_411;
          }
          uint64_t v235 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v235, 0);
        }
      }
      *(void *)(v19 + 1488 * v47 + 24) = v235;
      uint64_t v237 = re::RenderFrameData::stream(v270, v204);
      uint64_t v238 = re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v237, (uint64_t *)&v332);
      if (v238)
      {
        if (v238)
        {
          if (!*(void *)(v238 + 40)) {
            goto LABEL_412;
          }
          uint64_t v238 = re::BucketArray<re::SceneUnderstandingGuidedFilterOcclusionData,4ul>::operator[](v238, 0);
        }
      }
      a2 = 72;
      v19 += 1488 * v47;
      *(void *)(v19 + 32) = v238;
      re::FixedArray<float>::operator=((uint64_t *)(v19 + 624), (uint64_t *)(v230 + 72 * v47));
      re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v19 + 648, (uint64_t *)(v230 + 72 * v47 + 24));
      uint64_t v240 = re::RenderFrameData::stream(v270, v204);
      long long v241 = (uint64_t (**)(void, void, void, void, void))re::HashTable<std::type_index,re::RenderFrameDataArrayWrapper,re::Hash<std::type_index>,re::EqualTo<std::type_index>,true,false>::tryGet(v240, (uint64_t *)&v332);
      if (v241)
      {
        if (v242)
        {
          if (!*(void *)(v242 + 40)) {
            goto LABEL_413;
          }
          re::BucketArray<unsigned long,4ul>::operator[](v242, 0);
          unint64_t v244 = v283 + 1488 * v47;
          if (!*(unsigned char *)(v244 + 1472)) {
            *(unsigned char *)(v244 + 1472) = 1;
          }
          *(unsigned char *)(v283 + 1488 * v47 + 1473) = v279++;
        }
      }
      ++v47;
      unint64_t v202 = v267;
      if (v47 >= v329) {
        goto LABEL_367;
      }
    }
    goto LABEL_404;
  }
LABEL_367:
  if (*((void *)&v292 + 1) && (void)v293)
  {
    long long v245 = (void *)*((void *)&v293 + 1);
    uint64_t v246 = 72 * v293;
    do
    {
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v245 + 3);
      re::FixedArray<re::PlanarReceiverData::Bucket>::deinit(v245);
      v245 += 9;
      v246 -= 72;
    }
    while (v246);
    (*(void (**)(void, void))(**((void **)&v292 + 1) + 40))(*((void *)&v292 + 1), *((void *)&v293 + 1));
  }
  re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v300);
  v247.n128_f64[0] = re::HashTable<re::WeakStringID,re::TextureBlockResolution,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)&v301);
  if (BYTE8(v383[6])) {
    re::StringID::destroyString((re::StringID *)&v383[7]);
  }
  if (*((void *)&v383[5] + 1))
  {

    *((void *)&v383[5] + 1) = 0;
  }
  if (*(void *)&v383[5])
  {

    *(void *)&v383[5] = 0;
  }
  if (*((void *)&v383[4] + 1))
  {

    *((void *)&v383[4] + 1) = 0;
  }
  if (*(void *)&v383[0] && *(void *)&v383[2]) {
    (*(void (**)(__n128))(**(void **)&v383[0] + 40))(v247);
  }
  if (v384 && v385)
  {
    uint64_t v248 = v386;
    uint64_t v249 = 56 * v385;
    do
    {
      re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::deinit(v248);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v248);
      v248 += 56;
      v249 -= 56;
    }
    while (v249);
    (*(void (**)(uint64_t *, uint64_t))(*v384 + 40))(v384, v386);
  }
  if (v267)
  {
    uint64_t v250 = 0;
    do
    {
      uint64_t v251 = v268 + v250;
      re::ObjectHelper::destroy<re::KeyValuePair<unsigned short,re::LightContextBuilder::LightArrays>>(v268 + v250 + 120, v268 + v250 + 352 * *(void *)(v268 + v250 + 104) + 120);
      *(void *)(v251 + 104) = 0;
      ++*(_DWORD *)(v251 + 112);
      re::HashTable<unsigned short,re::LightContextBuilder::LightArrays,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,true>::deinit((uint64_t *)(v268 + v250 + 2936));
      *(void *)(v251 + 88) = 0;
      *(_DWORD *)(v251 + 96) = 0;
      re::HashTable<unsigned short,re::LightContextBuilder::LightArrays,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,true>::deinit((uint64_t *)(v268 + v250 + 2936));
      re::ObjectHelper::destroy<re::KeyValuePair<unsigned short,re::LightContextBuilder::LightArrays>>(v268 + v250 + 120, v268 + v250 + 352 * *(void *)(v268 + v250 + 104) + 120);
      *(void *)(v251 + 104) = 0;
      ++*(_DWORD *)(v251 + 112);
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v268 + v250 + 64));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v268 + v250 + 40));
      re::DynamicArray<re::RectAreaLightInfo>::deinit(v268 + v250);
      v250 += 3040;
    }
    while (3040 * v267 != v250);
  }
  re::DataArray<re::TextureAtlasTile>::deinit((uint64_t)&v316);
  if (v316)
  {
    if (v320) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v316 + 40))(v316, v320);
    }
    uint64_t v320 = 0;
    uint64_t v317 = 0;
    uint64_t v318 = 0;
    uint64_t v316 = 0;
    ++v319;
  }
  re::DataArray<re::TextureAtlasTile>::deinit((uint64_t)v306);
  if (v306[0] && v308) {
    (*(void (**)(void, uint64_t))(*(void *)v306[0] + 40))(v306[0], v308);
  }
  return re::DynamicArray<re::WeakStringID>::deinit((uint64_t)v328);
}

uint64_t re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 24 * v3 + 8) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 24 * v3 + 8) == a2) {
        return v5 + 24 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

BOOL re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + (v3 << 6) + 16) == a2) {
    return 1;
  }
  do
  {
    uint64_t v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
    BOOL result = v3 != 0x7FFFFFFF;
  }
  while (v3 != 0x7FFFFFFF && *(void *)(v5 + (v3 << 6) + 16) != a2);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(void *)(v11 + (v10 << 6) + 16) == v6) {
        return result;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + (v10 << 6) + 16) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  BOOL result = re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

unint64_t *re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::add(uint64_t a1, unint64_t *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 112 * v5;
  *(void *)uint64_t v11 = 0;
  *(_DWORD *)(v11 + 8) = 0;
  BOOL result = re::DynamicInlineArray<re::PlaneF,6ul>::move((unint64_t *)v11, a2);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::BucketArray<re::MeshSceneCollection,16ul>::add(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::BucketArray<re::MeshSceneCollection,16ul>::addUninitialized(a1);
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)uint64_t result = *(void *)a2;
  *(void *)(result + 8) = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::clear(a1);
    }
  }
  return a1;
}

void re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v6 + 24));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 72;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (_WORD *)(v8 + 12), (_DWORD *)(v8 + 16));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 72;
    }
  }
}

void re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (_WORD *)(*(void *)&v13[16] + v10 + 12), (uint64_t *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 72;
        }
        while (v11 < v9);
      }
      re::HashTable<re::ecs2::Scene const*,re::HashTable<re::ecs2::Entity *,re::ecs2::ImageBasedLightReceiverComponent *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _WORD *a4, _DWORD *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * v10) = a3;
  *(_WORD *)(*(void *)(a1 + 16) + 72 * v10 + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 72 * v10;
  *(_DWORD *)(v14 + 16) = *a5;
  re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v14 + 24, (uint64_t)(a5 + 2));
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _WORD *a4, uint64_t *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned short,re::LightContexts::LightContextContents,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * v10) = a3;
  *(_WORD *)(*(void *)(a1 + 16) + 72 * v10 + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 72 * v10;
  int v15 = *(_DWORD *)a5;
  *(_OWORD *)(v14 + 24) = 0u;
  v14 += 24;
  *(_DWORD *)(v14 - 8) = v15;
  *(_OWORD *)(v14 + 16) = 0u;
  *(_DWORD *)(v14 + 32) = 0;
  *(void *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, a5 + 1);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,unsigned int,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (_DWORD *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

uint64_t re::BucketArray<re::LightContext,16ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      unsigned int v4 = (uint64_t *)re::BucketArray<re::LightContext,16ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 15);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 12);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 9);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 6);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 3);
      re::FixedArray<CoreIKTransform>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::DynamicArray<re::FilterView>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    unint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 352 * v4;
        do
        {
          re::DynamicArray<re::MeshScene>::deinit((uint64_t)v3 + 304);
          re::DynamicString::deinit(v3);
          unint64_t v3 = (re::DynamicString *)((char *)v3 + 352);
          v5 -= 352;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        unint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::ShadowView>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    unint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 320 * v4;
        do
        {
          re::DynamicString::deinit(v3);
          unint64_t v3 = (re::DynamicString *)((char *)v3 + 320);
          v5 -= 320;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        unint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
    }
  }
  return a1;
}

void re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (void *)(v8 + 16), (void *)(v8 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

void re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (void *)(*(void *)&v13[16] + v10 + 16), (void *)(*(void *)&v13[16] + v10 + 24));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PlanarReceiverEntry,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void *re::FixedArray<re::PlanarReceiverData::Bucket>::deinit(void *result)
{
  if (*result)
  {
    unsigned int v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (void *)result[2];
      uint64_t v5 = 24 * v2;
      do
      {
        re::FixedArray<re::PlanarReceiverInfo>::deinit(v4);
        v4 += 3;
        v5 -= 24;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *unsigned int v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::PlanarReceiverInfo>::deinit(void *result)
{
  if (*result)
  {
    unsigned int v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = result[2];
      uint64_t v5 = 96 * v2;
      do
      {
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v4 + 48));
        re::DynamicArray<re::MeshScene>::deinit(v4);
        v4 += 96;
        v5 -= 96;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *unsigned int v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::RenderFrameContextBuilder::Result::PerSceneData>::deinit(void *result)
{
  if (*result)
  {
    unsigned int v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (re::RenderFrameContextBuilder::Result::PerSceneData *)result[2];
      uint64_t v5 = 1488 * v2;
      do
      {
        re::RenderFrameContextBuilder::Result::PerSceneData::~PerSceneData(v4);
        uint64_t v4 = (re::RenderFrameContextBuilder::Result::PerSceneData *)(v6 + 1488);
        v5 -= 1488;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *unsigned int v1 = 0;
  }
  return result;
}

void re::RenderFrameContextBuilder::Result::PerSceneData::~PerSceneData(re::RenderFrameContextBuilder::Result::PerSceneData *this)
{
  uint64_t v2 = (re::RenderFrameContextBuilder::Result::PerSceneData *)((char *)this + 720);
  re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 1008);
  re::StringID::destroyString(v2);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 81);
  re::FixedArray<re::PlanarReceiverData::Bucket>::deinit((void *)this + 78);
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 560);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 560);
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 504);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 504);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 54);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 51);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 48);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 45);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 42);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 39);
  re::HashTable<re::ecs2::Scene const*,re::HashTable<re::ecs2::Entity *,re::ecs2::ImageBasedLightReceiverComponent *,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit((uint64_t *)this + 33);
  re::BucketArray<re::LightContext,16ul>::deinit((uint64_t)this + 208);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 208);
  re::DynamicArray<re::FilterView>::deinit((uint64_t)this + 168);
  re::DynamicArray<re::ShadowView>::deinit((uint64_t)this + 128);
  re::BucketArray<re::MeshSceneCollection,16ul>::deinit((uint64_t)this + 40);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 40);
  *((void *)this + 1) = 0;
}

uint64_t re::BucketArray<re::MeshSceneCollection,16ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::MeshSceneCollection,16ul>::operator[](a1, i);
      re::DynamicArray<re::MeshScene>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::RenderFrameContextBuilder::Result::PerSceneData::PerSceneData(uint64_t a1, re::Allocator *a2)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 56) = 1;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  re::BucketArray<re::MeshSceneCollection,16ul>::init(a1 + 40, (uint64_t)a2, 1uLL);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = a2;
  re::DynamicArray<re::ShadowView>::setCapacity((void *)(a1 + 128), 0);
  ++*(_DWORD *)(a1 + 152);
  *(void *)(a1 + 168) = a2;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  re::DynamicArray<re::FilterView>::setCapacity((void *)(a1 + 168), 0);
  ++*(_DWORD *)(a1 + 192);
  re::LightContexts::LightContexts((re::LightContexts *)(a1 + 208), a2);
  re::PortalInfo::PortalInfo((re::PortalInfo *)(a1 + 504), a2);
  *(void *)(a1 + 632) = 0;
  *(void *)(a1 + 640) = 0;
  *(void *)(a1 + 624) = a2;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_DWORD *)(a1 + 680) = 0;
  *(void *)(a1 + 684) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 648) = 0u;
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 648, (uint64_t)a2, 3);
  bzero((void *)(a1 + 696), 0x2F8uLL);
  *(void *)(a1 + 728) = "";
  *(unsigned char *)(a1 + 1080) = 0;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(void *)(a1 + 784) = 0;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(unsigned char *)(a1 + 928) = 0;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_OWORD *)(a1 + 1048) = 0u;
  *(_OWORD *)(a1 + 1060) = 0u;
  if (re::MaterialParameterTable::kDefaultNameHash(void)::once != -1) {
    dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
  }
  *(void *)(a1 + 1120) = re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 1128) = _D0;
  *(_DWORD *)(a1 + 1136) = 1065353216;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 1160) = 0u;
  *(_DWORD *)(a1 + 1175) = 0;
  *(void *)(a1 + 1180) = 0xFFFFFFFF00000001;
  *(int32x4_t *)(a1 + 1200) = vdupq_n_s32(0x7F800000u);
  *(void *)&long long v9 = 0x7F0000007FLL;
  *((void *)&v9 + 1) = 0x7F0000007FLL;
  *(_OWORD *)(a1 + 1216) = v9;
  *(void *)(a1 + 1232) = 0;
  *(unsigned char *)(a1 + 1248) = 0;
  *(void *)(a1 + 1296) = 0;
  *(unsigned char *)(a1 + 1312) = 0;
  *(void *)(a1 + 1392) = 0x10100010001;
  *(_OWORD *)(a1 + 1408) = 0u;
  *(_OWORD *)(a1 + 1424) = 0u;
  *(_WORD *)(a1 + 1440) = 1;
  *(unsigned char *)(a1 + 1442) = 0;
  *(unsigned char *)(a1 + 1456) = 0;
  *(void *)(a1 + 1464) = 0;
  *(unsigned char *)(a1 + 1472) = 0;
  *(void *)(a1 + 1480) = 0;
  return a1;
}

uint64_t re::BucketArray<re::MeshSceneCollection,16ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::MeshSceneCollection,16ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::MeshSceneCollection,16ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 16 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 640, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::DynamicArray<re::ShadowView>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::ShadowView>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x140uLL))
        {
          uint64_t v2 = 320 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 320 * a2, 16);
          if (result)
          {
            unsigned int v7 = result;
            if (!v5[1]) {
              goto LABEL_22;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 320, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unsigned int v7 = 0;
      if (!v3)
      {
LABEL_22:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        int v10 = (char *)(v8 + 320 * v9);
        uint64_t v11 = (char *)v7 + 162;
        int v12 = (char *)(v8 + 162);
        do
        {
          *(_OWORD *)(v11 - 162) = 0u;
          int v13 = v11 - 162;
          *((_OWORD *)v13 + 1) = 0u;
          uint64_t v14 = v12 - 162;
          *(void *)int v13 = *(void *)(v12 - 162);
          *(void *)uint64_t v14 = 0;
          *((void *)v13 + 3) = *(void *)(v12 - 138);
          *((void *)v14 + 3) = 0;
          uint64_t v16 = *(void *)(v11 - 154);
          uint64_t v15 = *(void *)(v11 - 146);
          uint64_t v17 = *(void *)(v12 - 146);
          *((void *)v13 + 1) = *(void *)(v12 - 154);
          *((void *)v13 + 2) = v17;
          *((void *)v14 + 1) = v16;
          *((void *)v14 + 2) = v15;
          long long v18 = *(_OWORD *)(v12 - 66);
          long long v19 = *(_OWORD *)(v12 - 50);
          long long v20 = *(_OWORD *)(v12 - 34);
          *(void *)(v13 + 142) = *(void *)(v12 - 20);
          *((_OWORD *)v13 + 7) = v19;
          *((_OWORD *)v13 + 8) = v20;
          *((_OWORD *)v13 + 6) = v18;
          long long v21 = *(_OWORD *)(v12 - 130);
          long long v22 = *(_OWORD *)(v12 - 114);
          long long v23 = *(_OWORD *)(v12 - 82);
          *((_OWORD *)v13 + 4) = *(_OWORD *)(v12 - 98);
          *((_OWORD *)v13 + 5) = v23;
          *((_OWORD *)v13 + 2) = v21;
          *((_OWORD *)v13 + 3) = v22;
          v13[160] = *(v12 - 2);
          LODWORD(v15) = *(v12 - 1);
          v13[161] = v15;
          if (v15) {
            *uint64_t v11 = *v12;
          }
          int v24 = v12[2];
          void v11[2] = v24;
          if (v24) {
            *(_DWORD *)(v11 + 6) = *(_DWORD *)(v12 + 6);
          }
          long long v25 = *(_OWORD *)(v12 + 14);
          long long v26 = *(_OWORD *)(v12 + 30);
          long long v27 = *(_OWORD *)(v12 + 62);
          *(_OWORD *)(v11 + 46) = *(_OWORD *)(v12 + 46);
          *(_OWORD *)(v11 + 62) = v27;
          *(_OWORD *)(v11 + 14) = v25;
          *(_OWORD *)(v11 + 30) = v26;
          long long v28 = *(_OWORD *)(v12 + 78);
          long long v29 = *(_OWORD *)(v12 + 94);
          long long v30 = *(_OWORD *)(v12 + 126);
          *(_OWORD *)(v11 + 110) = *(_OWORD *)(v12 + 110);
          *(_OWORD *)(v11 + 126) = v30;
          *(_OWORD *)(v11 + 78) = v28;
          *(_OWORD *)(v11 + 94) = v29;
          int v31 = v12[142];
          v11[142] = v31;
          if (v31) {
            v11[143] = v12[143];
          }
          int v32 = *(_DWORD *)(v12 + 146);
          v11[150] = v12[150];
          *(_DWORD *)(v11 + 146) = v32;
          re::DynamicString::deinit((re::DynamicString *)(v12 - 162));
          v11 += 320;
          v12 += 320;
        }
        while (v14 + 320 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_22;
    }
  }
  return result;
}

void *re::DynamicArray<re::FilterView>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::FilterView>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x160uLL))
        {
          uint64_t v2 = 352 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 352 * a2, 16);
          if (result)
          {
            unsigned int v7 = result;
            if (!v5[1]) {
              goto LABEL_20;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 352, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unsigned int v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        int v10 = (void *)(v8 + 352 * v9);
        uint64_t v11 = v7 + 21;
        uint64_t v12 = v8 + 168;
        do
        {
          *(_OWORD *)(v11 - 21) = 0u;
          int v13 = v11 - 21;
          *((_OWORD *)v13 + 1) = 0u;
          uint64_t v14 = (void *)(v12 - 168);
          *int v13 = *(void *)(v12 - 168);
          *uint64_t v14 = 0;
          v13[3] = *(void *)(v12 - 144);
          void v14[3] = 0;
          uint64_t v16 = *(v11 - 20);
          uint64_t v15 = *(v11 - 19);
          uint64_t v17 = *(void *)(v12 - 152);
          v13[1] = *(void *)(v12 - 160);
          void v13[2] = v17;
          v14[1] = v16;
          void v14[2] = v15;
          long long v18 = *(_OWORD *)(v12 - 72);
          long long v19 = *(_OWORD *)(v12 - 56);
          long long v20 = *(_OWORD *)(v12 - 40);
          *(void *)((char *)v13 + 142) = *(void *)(v12 - 26);
          *((_OWORD *)v13 + 7) = v19;
          *((_OWORD *)v13 + 8) = v20;
          *((_OWORD *)v13 + 6) = v18;
          long long v21 = *(_OWORD *)(v12 - 136);
          long long v22 = *(_OWORD *)(v12 - 120);
          long long v23 = *(_OWORD *)(v12 - 88);
          *((_OWORD *)v13 + 4) = *(_OWORD *)(v12 - 104);
          *((_OWORD *)v13 + 5) = v23;
          *((_OWORD *)v13 + 2) = v21;
          *((_OWORD *)v13 + 3) = v22;
          *((unsigned char *)v13 + 160) = *(unsigned char *)(v12 - 8);
          LODWORD(v15) = *(unsigned __int8 *)(v12 - 7);
          *((unsigned char *)v13 + 161) = v15;
          if (v15) {
            *((unsigned char *)v11 - 6) = *(unsigned char *)(v12 - 6);
          }
          int v24 = *(unsigned __int8 *)(v12 - 4);
          *((unsigned char *)v11 - 4) = v24;
          if (v24) {
            *(_DWORD *)uint64_t v11 = *(_DWORD *)v12;
          }
          long long v25 = *(_OWORD *)(v12 + 8);
          long long v26 = *(_OWORD *)(v12 + 24);
          long long v27 = *(_OWORD *)(v12 + 56);
          *(_OWORD *)(v11 + 5) = *(_OWORD *)(v12 + 40);
          *(_OWORD *)(v11 + 7) = v27;
          *(_OWORD *)(v11 + 1) = v25;
          *(_OWORD *)(v11 + 3) = v26;
          long long v28 = *(_OWORD *)(v12 + 72);
          long long v29 = *(_OWORD *)(v12 + 88);
          long long v30 = *(_OWORD *)(v12 + 120);
          *(_OWORD *)(v11 + 13) = *(_OWORD *)(v12 + 104);
          *(_OWORD *)(v11 + 15) = v30;
          *(_OWORD *)(v11 + 9) = v28;
          *(_OWORD *)(v11 + 11) = v29;
          v11[21] = 0;
          v11[18] = 0;
          v11[19] = 0;
          v11[17] = 0;
          *((_DWORD *)v11 + 40) = 0;
          uint64_t v31 = *(void *)(v12 + 144);
          v11[17] = *(void *)(v12 + 136);
          v11[18] = v31;
          *(void *)(v12 + 136) = 0;
          *(void *)(v12 + 144) = 0;
          uint64_t v32 = v11[19];
          v11[19] = *(void *)(v12 + 152);
          *(void *)(v12 + 152) = v32;
          uint64_t v33 = v11[21];
          uint64_t v34 = *(void *)(v12 + 176);
          v11[21] = *(void *)(v12 + 168);
          *(void *)(v12 + 168) = v33;
          ++*(_DWORD *)(v12 + 160);
          ++*((_DWORD *)v11 + 40);
          v11[22] = v34;
          re::DynamicArray<re::MeshScene>::deinit(v12 + 136);
          re::DynamicString::deinit((re::DynamicString *)(v12 - 168));
          v11 += 44;
          v12 += 352;
        }
        while (v14 + 44 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

re::LightContexts *re::LightContexts::LightContexts(re::LightContexts *this, re::Allocator *a2)
{
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 4) = 1;
  *((void *)this + 3) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  re::BucketArray<re::LightContext,16ul>::init((uint64_t)this, (uint64_t)a2, 1uLL);
  *((_DWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(void *)((char *)this + 92) = 0x7FFFFFFFLL;
  *((void *)this + 13) = a2;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = a2;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 19) = a2;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = a2;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 25) = a2;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 28) = a2;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((unsigned char *)this + 264) = 0;
  *((unsigned char *)this + 288) = 0;
  *((_OWORD *)this + 17) = 0u;
  return this;
}

uint64_t *re::BucketArray<re::LightContext,16ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::LightContext,16ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::LightContext,16ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 16 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 2688, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

re::PortalInfo *re::PortalInfo::PortalInfo(re::PortalInfo *this, re::Allocator *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 1;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::init((uint64_t)this, (uint64_t)a2, 1uLL);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 1;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 26) = 0;
  re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::init((uint64_t)this + 56, (uint64_t)a2, 1uLL);
  *((unsigned char *)this + 112) = 0;
  return this;
}

uint64_t re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 32, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 32, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

double re::HashTable<unsigned short,re::LightContextBuilder::LightArrays,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,true>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<unsigned short,re::LightContextBuilder::LightArrays,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,true>::EntryWithoutHash::free((_DWORD *)(a1[2] + v3));
        ++v4;
        v3 += 352;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::ObjectHelper::destroy<re::KeyValuePair<unsigned short,re::LightContextBuilder::LightArrays>>(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    do
    {
      re::BucketArray<re::LightContextBuilder::RectAreaLightBucket,4ul>::deinit(v3 + 288);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 288);
      re::BucketArray<re::LightContextBuilder::PointLightBucket,4ul>::deinit(v3 + 232);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 232);
      re::BucketArray<re::LightContextBuilder::SpotLightBucket,4ul>::deinit(v3 + 176);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 176);
      re::BucketArray<re::LightContextBuilder::RealWorldProxyLightBucket,4ul>::deinit(v3 + 120);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 120);
      re::BucketArray<re::LightContextBuilder::DirectionalLightBucket,4ul>::deinit(v3 + 64);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 64);
      re::BucketArray<re::LightContextBuilder::AmbientLightBucket,4ul>::deinit(v3 + 8);
      double result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3 + 8);
      v3 += 352;
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::RectAreaLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](a1, i);
      re::DynamicArray<re::RectAreaLightInfo>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::PointLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 12);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 9);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 5);
      re::DynamicArray<re::PointLightInfo>::deinit((uint64_t)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::SpotLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 12);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 9);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 5);
      re::DynamicArray<re::SpotLightInfo>::deinit((uint64_t)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::RealWorldProxyLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 12);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 9);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 5);
      re::DynamicArray<re::RectAreaLightInfo>::deinit((uint64_t)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::DirectionalLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + 64));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v4 + 40));
      re::DynamicArray<re::RectAreaLightInfo>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::LightContextBuilder::AmbientLightBucket,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](a1, i);
      re::DynamicArray<unsigned long>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_DWORD *re::HashTable<unsigned short,re::LightContextBuilder::LightArrays,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,true>::EntryWithoutHash::free(_DWORD *result)
{
  if ((*result & 0x80000000) != 0)
  {
    uint64_t v1 = (uint64_t)result;
    *result &= ~0x80000000;
    uint64_t v2 = (uint64_t)(result + 58);
    uint64_t v3 = (uint64_t)(result + 2);
    uint64_t v4 = (uint64_t)(result + 72);
    re::BucketArray<re::LightContextBuilder::RectAreaLightBucket,4ul>::deinit((uint64_t)(result + 72));
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
    re::BucketArray<re::LightContextBuilder::PointLightBucket,4ul>::deinit(v2);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v2);
    re::BucketArray<re::LightContextBuilder::SpotLightBucket,4ul>::deinit(v1 + 176);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v1 + 176);
    re::BucketArray<re::LightContextBuilder::RealWorldProxyLightBucket,4ul>::deinit(v1 + 120);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v1 + 120);
    v1 += 64;
    re::BucketArray<re::LightContextBuilder::DirectionalLightBucket,4ul>::deinit(v1);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v1);
    re::BucketArray<re::LightContextBuilder::AmbientLightBucket,4ul>::deinit(v3);
    return (_DWORD *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v3);
  }
  return result;
}

double re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::deinit(v6 + 24);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v8 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(void *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v28, v13, v12);
          long long v15 = *(_OWORD *)v28;
          *(_OWORD *)long long v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v28[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v28[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            long long v21 = (void *)(v17 + 8);
            do
            {
              if ((*(_DWORD *)(v21 - 1) & 0x80000000) != 0)
              {
                unint64_t v22 = 0xBF58476D1CE4E5B9 * (*v21 ^ (*v21 >> 30));
                unint64_t v23 = (0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) ^ ((0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) >> 31);
                re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addAsMove(a1, v23 % *(unsigned int *)(a1 + 24), v23, v21, v21 + 1);
              }
              v21 += 3;
              --v20;
            }
            while (v20);
          }
          re::HashTable<re::WeakStringID,re::TextureBlockResolution,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v12) {
          signed int v26 = 2 * v11;
        }
        else {
          signed int v26 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 24 * v8);
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  uint64_t v27 = 24 * v8;
  *(_DWORD *)(v24 + v27) = v25 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v27) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
}

void std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::~__func()
{
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26E71AF30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E71AF30;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::operator()(uint64_t a1, __int16 *a2)
{
  uint64_t v4 = (uint64_t)(a2 + 104);
  unsigned int v5 = (unsigned __int16)*a2;
  re::LightContextBuilder::addAmbientLights(*(void **)(a1 + 8), *a2, (uint64_t)(a2 + 4));
  re::LightContextBuilder::addDirectionalLights(*(void *)(a1 + 8), v5, (uint64_t)(a2 + 24));
  re::LightContextBuilder::addRealWorldProxyLights(*(void *)(a1 + 8), v5, (uint64_t)(a2 + 44));
  re::LightContextBuilder::addSpotLights(*(void *)(a1 + 8), v5, (uint64_t)(a2 + 64));
  re::LightContextBuilder::addPointLights(*(void *)(a1 + 8), v5, (uint64_t)(a2 + 84));
  uint64_t v6 = *(void *)(a1 + 8);
  return re::LightContextBuilder::addRectAreaLights(v6, v5, v4);
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_0>,void ()(re::LightInfoArrays &)>::target_type()
{
}

uint64_t re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

uint64_t re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

void std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::~__func()
{
}

__n128 std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_26E71B000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E71B000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::operator()(uint64_t a1, void *a2)
{
  __n128 result = (uint64_t *)re::HashTable<re::WeakStringID,re::RenderFrameContextBuilder::Result::PerSceneData *,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::tryGet(*(void *)(a1 + 24), *a2 >> 1);
  if (result)
  {
    uint64_t v4 = *result;
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(v5 + 112);
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 40);
      if (v7)
      {
        for (unint64_t i = 0; i != v7; ++i)
        {
          uint64_t v9 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v6, i);
          __n128 result = (uint64_t *)re::BucketArray<re::DynamicArray<re::CameraView> const*,4ul>::addUninitialized(v4 + 504);
          uint64_t *result = v9;
        }
        uint64_t v5 = *(void *)(a1 + 16);
      }
    }
    uint64_t v10 = *(void *)(v5 + 120);
    if (v10)
    {
      uint64_t v11 = *(void *)(v10 + 40);
      if (v11)
      {
        for (unint64_t j = 0; j != v11; ++j)
        {
          uint64_t v13 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](v10, j);
          __n128 result = (uint64_t *)re::BucketArray<re::DynamicArray<re::CameraMultiView> const*,4ul>::addUninitialized(v4 + 560);
          uint64_t *result = v13;
        }
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_1>,void ()(re::StencilPortal &)>::target_type()
{
}

uint64_t re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v3 + 112 * v4;
        uint64_t v6 = *(void *)(a1 + 32);
        do
        {
          *(void *)uint64_t v6 = 0;
          ++*(_DWORD *)(v6 + 8);
          v6 += 112;
        }
        while (v6 != v5);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + (v9 << 6) + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v9 << 6)) = a3;
  *(void *)(*(void *)(a1 + 16) + (v9 << 6) + 16) = *a4;
  uint64_t v13 = *(void *)(a1 + 16) + (v9 << 6);
  *(void *)(v13 + 56) = 0;
  *(_DWORD *)(v13 + 48) = 0;
  *(void *)(v13 + 32) = 0;
  *(void *)(v13 + 40) = 0;
  *(void *)(v13 + 24) = 0;
  uint64_t v14 = *(void *)(a5 + 8);
  *(void *)(v13 + 24) = *(void *)a5;
  *(void *)(v13 + 32) = v14;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  uint64_t v15 = *(void *)(v13 + 40);
  *(void *)(v13 + 40) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v15;
  uint64_t v16 = *(void *)(v13 + 56);
  *(void *)(v13 + 56) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v16;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v13 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      uint64_t v7 = *(void *)(a1 + 16);
      *(void *)&v13[16] = v7;
      *(void *)(a1 + 16) = v6;
      long long v9 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        uint64_t v11 = v7 + 16;
        do
        {
          if ((*(_DWORD *)(v11 - 8) & 0x80000000) != 0) {
            re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v11 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v11 - 16), v11, v11 + 8);
          }
          v11 += 64;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void *re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::DynamicInlineArray<re::PlaneF,6ul>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x70uLL))
        {
          uint64_t v2 = 112 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 112 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element std::string::size_type size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 112, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 112 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = 0;
          *((_DWORD *)v11 + 2) = 0;
          re::DynamicInlineArray<re::PlaneF,6ul>::move(v11, (unint64_t *)v8);
          *(void *)uint64_t v8 = 0;
          ++*(_DWORD *)(v8 + 8);
          v8 += 112;
          v11 += 14;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::~__func()
{
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26E71B090;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E71B090;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::operator()(uint64_t a1, uint64_t a2)
{
  return re::BucketArray<re::ProjectiveShadowBuilder::Input::PerSceneData,4ul>::add(*(void *)(a1 + 8), a2);
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_2>,void ()(re::ProjectiveShadowBuilder::Input::PerSceneData &)>::target_type()
{
}

void *re::RenderGraphDataStoreWrapper<re::OpenSkyData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71B138;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 18));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 13));
  return a1;
}

void re::RenderGraphDataStoreWrapper<re::OpenSkyData>::~RenderGraphDataStoreWrapper(void *a1)
{
  *a1 = &unk_26E71B138;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 18));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 13));
  JUMPOUT(0x237DBCBD0);
}

void std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::~__func()
{
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26E71B160;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E71B160;
  a2[1] = v2;
  return result;
}

uint64_t *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::operator()(uint64_t a1, long long *a2)
{
  uint64_t result = *(uint64_t **)(a1 + 8);
  if (*result) {
    return re::DynamicArray<re::MeshScene>::add((_anonymous_namespace_ *)result, a2);
  }
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_3>,void ()(re::MeshScene &)>::target_type()
{
}

uint64_t re::BucketArray<re::MeshSceneCollection,16ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 16 * v3)
  {
    re::BucketArray<re::MeshSceneCollection,16ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 16) >> 4);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 4));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 40 * (v2 & 0xF);
}

void std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::~__func()
{
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26E71B1F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E71B1F0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::operator()(uint64_t a1, uint64_t a2)
{
  return re::BucketArray<re::MeshSceneCollection,16ul>::add(*(void *)(a1 + 8), a2);
}

uint64_t std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4,std::allocator<re::RenderFrameContextBuilder::build(re::RenderFrame &,re::RenderFrameContextBuilder::MutableState &)::$_4>,void ()(re::RayTracedShadowReceiverCollection &)>::target_type()
{
}

void re::RenderGraphMotionBlurNode::configure(re::RenderGraphMotionBlurNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  *((void *)this + 58) = re::AssetHandle::asset<re::MaterialAsset>((re::RenderGraphMotionBlurNode *)((char *)this + 504));
  *((void *)this + 59) = re::AssetHandle::asset<re::MaterialAsset>((re::RenderGraphMotionBlurNode *)((char *)this + 528));
  *((void *)this + 60) = re::AssetHandle::asset<re::MaterialAsset>((re::RenderGraphMotionBlurNode *)((char *)this + 552));
  *((void *)this + 57) = re::AssetHandle::asset<re::MaterialAsset>((re::RenderGraphMotionBlurNode *)((char *)this + 576));
  re::RenderGraphFullscreenNode::configure(this, a2, a3, a4);
}

void re::RenderGraphMotionBlurNode::execute(re::RenderGraphMotionBlurNode *this, re::RenderGraphContext *a2)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29, 5054, 0);
  uint64_t v4 = re::RenderGraphDataStore::get<re::CameraData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
  if (!*(void *)(v4 + 272))
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v6 = (float32x4_t *)v4;
  if (!*(void *)(v4 + 128))
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  long long v27 = *(_OWORD *)(v4 + 304);
  long long v28 = *(_OWORD *)(v4 + 288);
  long long v25 = *(_OWORD *)(v4 + 320);
  long long v26 = *(_OWORD *)(v4 + 336);
  *(float32x2_t *)&double v8 = re::Projection::computeMatrix4x4F((re::Projection *)(v4 + 144), (uint64_t)v31);
  if (!v6[3].i64[0])
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, *(void *)&v7, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, 0, 0);
    _os_crash();
    __break(1u);
    return;
  }
  re::RenderCamera::computeInverseTransform(v6 + 4, (uint64_t)v30);
  uint64_t v9 = 0;
  float32x4_t v10 = (float32x4_t)v31[0];
  float32x4_t v11 = (float32x4_t)v31[1];
  float32x4_t v12 = (float32x4_t)v31[2];
  float32x4_t v13 = (float32x4_t)v31[3];
  v32[0] = v30[0];
  v32[1] = v30[1];
  void v32[2] = v30[2];
  v32[3] = v30[3];
  do
  {
    v33.columns[v9] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(v32[v9])), v11, *(float32x2_t *)&v32[v9], 1), v12, (float32x4_t)v32[v9], 2), v13, (float32x4_t)v32[v9], 3);
    ++v9;
  }
  while (v9 != 4);
  simd_float4x4 v34 = __invert_f4(v33);
  simd_float4 v23 = v34.columns[1];
  simd_float4 v24 = v34.columns[0];
  simd_float4 v21 = v34.columns[3];
  simd_float4 v22 = v34.columns[2];
  float v14 = *((float *)this + 122) * (float)*((unsigned int *)this + 123);
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)a2, 0x90uLL, 0x10uLL, (uint64_t)&v33);
  uint64_t v15 = (void *)v33.columns[1].i64[0];
  uint64_t v20 = v33.columns[0].i64[1];
  uint64_t v16 = v33.columns[0].i64[0] + v33.columns[0].u32[2];
  *(simd_float4 *)uint64_t v16 = v24;
  *(simd_float4 *)(v16 + 16) = v23;
  *(simd_float4 *)(v16 + 32) = v22;
  *(simd_float4 *)(v16 + 48) = v21;
  *(_OWORD *)(v16 + 64) = v28;
  *(_OWORD *)(v16 + 80) = v27;
  *(_OWORD *)(v16 + 96) = v25;
  *(_OWORD *)(v16 + 112) = v26;
  *(float *)(v16 + 128) = v14;
  v33.columns[0].i64[0] = (uint64_t)v15;
  v33.columns[0].i64[1] = v20;
  if (*((unsigned char *)this + 496))
  {
    uint64_t v17 = *((void *)this + 57);
  }
  else if (v14 >= 0.25)
  {
    if (v14 >= 0.6) {
      uint64_t v17 = *((void *)this + 60);
    }
    else {
      uint64_t v17 = *((void *)this + 59);
    }
  }
  else
  {
    uint64_t v17 = *((void *)this + 58);
  }
  *((void *)this + 40) = v17;
  unsigned int v18 = (re::BufferTable *)(*(void *)a2 + 480);
  *(void *)&v32[0] = 0x64A435BF9C14DD23;
  re::BufferTable::setBuffer(v18, (const re::WeakStringID *)v32, (uint64_t)&v33);
  re::RenderGraphFullscreenNode::executeInternal(this, a2, (re::RenderGraphMotionBlurNode *)((char *)this + 264));
  long long v19 = (re::BufferTable *)(*(void *)a2 + 480);
  *(void *)&v32[0] = 0x64A435BF9C14DD23;
  re::BufferTable::removeBuffer(v19, (const re::WeakStringID *)v32);
  if (v33.columns[0].i64[0]) {

  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29);
}

void *re::allocInfo_MotionBlurUserParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_449, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_449))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B4F0, "MotionBlurUserParameters");
    __cxa_guard_release(&_MergedGlobals_449);
  }
  return &unk_26AF9B4F0;
}

void re::initInfo_MotionBlurUserParameters(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xD00187F985DB45A4;
  v14[1] = "MotionBlurUserParameters";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B488, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B488);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      float32x2_t v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "exposureTime";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF9B4A8 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      float32x4_t v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "frameRate";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF9B4B0 = v12;
      __cxa_guard_release(&qword_26AF9B488);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF9B4A8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::MotionBlurUserParameters>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::MotionBlurUserParameters>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::MotionBlurUserParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::MotionBlurUserParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void re::internal::defaultConstruct<re::MotionBlurUserParameters>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0x3C3C888F86;
}

void *re::internal::defaultConstructV2<re::MotionBlurUserParameters>(void *result)
{
  void *result = 0x3C3C888F86;
  return result;
}

void *re::allocInfo_RenderGraphMotionBlurNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B498, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9B498))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B568, "RenderGraphMotionBlurNode");
    __cxa_guard_release(&qword_26AF9B498);
  }
  return &unk_26AF9B568;
}

void re::initInfo_RenderGraphMotionBlurNode(re *this, re::IntrospectionBase *a2)
{
  v34[0] = 0x642F8AC82BD1C86ELL;
  v34[1] = "RenderGraphMotionBlurNode";
  re::StringID::destroyString((re::StringID *)v34);
  *((_OWORD *)this + 2) = v35;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B4A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B4A0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphFullscreenNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphFullscreenNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B4B8 = v7;
      uint64_t v8 = (re *)re::introspectionAllocator((re *)v7);
      uint64_t v9 = v8;
      float32x4_t v10 = (re *)qword_26AF9B490;
      if (!qword_26AF9B490)
      {
        float32x4_t v10 = (re *)re::allocInfo_MotionBlurUserParameters(v8);
        qword_26AF9B490 = (uint64_t)v10;
        re::initInfo_MotionBlurUserParameters(v10, v11);
      }
      uint64_t v12 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "motionBlurUserParameters";
      *(void *)(v12 + 16) = v10;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x1E800000001;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF9B4C0 = v12;
      long long v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::introspect_BOOL((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "debugPassthrough";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x1F000000002;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF9B4C8 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      long long v19 = re::introspect_AssetHandle((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "motionBlurLowSampleCountMaterial";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x1F800000003;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF9B4D0 = v20;
      simd_float4 v21 = re::introspectionAllocator((re *)v20);
      simd_float4 v23 = re::introspect_AssetHandle((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "motionBlurMediumSampleCountMaterial";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x21000000004;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF9B4D8 = v24;
      long long v25 = re::introspectionAllocator((re *)v24);
      long long v27 = re::introspect_AssetHandle((re *)1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "motionBlurHighSampleCountMaterial";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x22800000005;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF9B4E0 = v28;
      long long v29 = re::introspectionAllocator((re *)v28);
      uint64_t v31 = re::introspect_AssetHandle((re *)1, v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 72, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = "debugPassthroughMaterial";
      *(void *)(v32 + 16) = v31;
      *(void *)(v32 + 24) = 0;
      *(void *)(v32 + 32) = 0x24000000006;
      *(_DWORD *)(v32 + 40) = 0;
      *(void *)(v32 + 48) = 0;
      *(void *)(v32 + 56) = 0;
      *(_DWORD *)(v32 + 64) = 0;
      qword_26AF9B4E8 = v32;
      __cxa_guard_release(&qword_26AF9B4A0);
    }
  }
  *((void *)this + 2) = 0x25800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 7;
  *((void *)this + 8) = &qword_26AF9B4B8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphMotionBlurNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphMotionBlurNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphMotionBlurNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphMotionBlurNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v33 = v35;
}

double re::internal::defaultConstruct<re::RenderGraphMotionBlurNode>(int a1, int a2, re::RenderGraphFullscreenNode *this)
{
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v3 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(this);
  *(void *)uint64_t v3 = &unk_26E71B280;
  double result = 0.0;
  *(_OWORD *)((char *)v3 + 456) = 0u;
  *(_OWORD *)((char *)v3 + 472) = 0u;
  *((void *)v3 + 61) = 0x3C3C888F86;
  *(_OWORD *)((char *)v3 + 504) = 0u;
  *(_OWORD *)((char *)v3 + 520) = 0u;
  *(_OWORD *)((char *)v3 + 536) = 0u;
  *(_OWORD *)((char *)v3 + 552) = 0u;
  *(_OWORD *)((char *)v3 + 568) = 0u;
  *(_OWORD *)((char *)v3 + 584) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphMotionBlurNode>(int a1, int a2, id *this)
{
}

double re::internal::defaultConstructV2<re::RenderGraphMotionBlurNode>(uint64_t a1)
{
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v1 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode((re::RenderGraphFullscreenNode *)a1);
  *(void *)uint64_t v1 = &unk_26E71B280;
  double result = 0.0;
  *(_OWORD *)((char *)v1 + 456) = 0u;
  *(_OWORD *)((char *)v1 + 472) = 0u;
  *((void *)v1 + 61) = 0x3C3C888F86;
  *(_OWORD *)((char *)v1 + 504) = 0u;
  *(_OWORD *)((char *)v1 + 520) = 0u;
  *(_OWORD *)((char *)v1 + 536) = 0u;
  *(_OWORD *)((char *)v1 + 552) = 0u;
  *(_OWORD *)((char *)v1 + 568) = 0u;
  *(_OWORD *)((char *)v1 + 584) = 0u;
  return result;
}

uint64_t re::introspect_RenderGraphMotionBlurNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphMotionBlurNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphMotionBlurNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphMotionBlurNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphMotionBlurNode>, this);
}

void re::RenderGraphMotionBlurNode::~RenderGraphMotionBlurNode(id *this)
{
  re::RenderGraphMotionBlurNode::~RenderGraphMotionBlurNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t vars8;

  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 72));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 69));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 66));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 63));
  re::RenderGraphFullscreenNode::~RenderGraphFullscreenNode(this);
}

uint64_t re::RenderGraphVRRUnwarpNode::configure(void **this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  v10[0] = 0;
  uint64_t v16 = 0;
  memset(v14, 0, sizeof(v14));
  int v15 = 0;
  char v17 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  char v20 = 0;
  ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)a4 + 1), (uint64_t)v10);
  NS::SharedPtr<MTL::Texture>::operator=(this + 41, ComputePipelineState);
  re::RenderGraphNode::configure((re::RenderGraphNode *)this, a2, a3, a4);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v14);
  uint64_t result = v13[0];
  if (v13[0])
  {
    if (v13[1]) {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v13[0] + 40))();
    }
    memset(v13, 0, sizeof(v13));
  }
  if (v10[0])
  {
    uint64_t result = v11;
    if (v11)
    {
      if (v12) {
        return (*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  return result;
}

void re::RenderGraphVRRUnwarpNode::setup(re::RenderGraphVRRUnwarpNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  *(_DWORD *)((char *)&v6 + 3) = 0;
  LODWORD(v6) = 0;
  uint64_t v7 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)this + 256, (uint64_t)&v6);
  *(_DWORD *)((char *)&v6 + 3) = 0;
  LODWORD(v6) = 0;
  uint64_t v7 = 2;
  re::RenderGraphBuilder::read((uint64_t)a2, (uint64_t)this + 288, (uint64_t)&v6);
  uint64_t v6 = 0x500000000;
  long long v8 = xmmword_23435FBB0;
  __int16 v9 = 0;
  int v10 = 0;
  int v11 = 0;
  re::RenderGraphBuilder::write((uint64_t)a2, (uint64_t)this + 272, (uint64_t)&v6);
  re::RenderGraphNode::setup(this, a2, a3);
}

void re::RenderGraphVRRUnwarpNode::execute(re::RenderGraphVRRUnwarpNode *this, re::RenderGraphContext *a2)
{
  uint64_t v4 = *((void *)a2 + 146);
  unint64_t v5 = (unint64_t)"N2re13VRRUnwarpDataE";
  if (((unint64_t)"N2re13VRRUnwarpDataE" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"N2re13VRRUnwarpDataE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  id v32 = (id)((*(void *)(*((void *)a2 + 5) + 48) + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583E9) ^ v5);
  __int16 v9 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v4 + 64, (uint64_t *)&v32);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (*v9)
    {
      uint64_t v11 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*((void *)a2 + 146), *(void *)(*((void *)a2 + 5) + 48));
      if (v11) {
        BOOL v12 = *(unsigned char *)(v11 + 65) != 0;
      }
      else {
        BOOL v12 = 0;
      }
      long long v13 = (id *)re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*((void *)a2 + 1) + 104));
      re::RenderGraphContext::acquireManagedComputeEncoder((uint64_t)a2, v13, *((re::RenderGraphNodeBase **)a2 + 5), 0, &v28);
      [v28 setComputePipelineState:*((void *)this + 41)];
      re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 256, 0, 0, &v27);
      re::RenderGraphContext::metalTexture((uint64_t)a2, (uint64_t)this + 272, 0, 0, &v26);
      id v25 = v27;
      id v24 = v26;
      if (!v12)
      {
        re::makeView2DTo2DArray(&v27, &v32);
        NS::SharedPtr<MTL::Texture>::operator=(&v25, &v32);
        if (v32) {

        }
        re::makeView2DTo2DArray(&v26, &v32);
        NS::SharedPtr<MTL::Texture>::operator=(&v24, &v32);
        if (v32) {
      }
        }
      uint64_t v14 = re::RenderGraphContext::metalBuffer((uint64_t)a2, (uint64_t)this + 288);
      [v28 setTexture:v25 atIndex:0];
      [v28 setTexture:v24 atIndex:1];
      [v28 setBuffer:*(void *)v14 offset:*(unsigned int *)(v14 + 8) atIndex:0];
      unsigned int v15 = objc_msgSend(v26, sel_width);
      unsigned int v16 = objc_msgSend(v26, sel_height);
      unsigned int v17 = objc_msgSend(*((id *)this + 41), sel_threadExecutionWidth);
      unsigned int v18 = objc_msgSend(*((id *)this + 41), sel_maxTotalThreadsPerThreadgroup);
      uint64_t v19 = *((void *)a2 + 1);
      uint64_t v20 = v18 / v17;
      id v23 = v28;
      re::RenderManager::sampleComputeEncoderMTLCounterBegin(v19, &v23, 1u);

      [v28 setBytes:v10 + 8 length:2 atIndex:1];
      id v32 = (id)v15;
      uint64_t v33 = v16;
      uint64_t v34 = 1;
      uint64_t v29 = v17;
      uint64_t v30 = v20;
      uint64_t v31 = 1;
      [v28 dispatchThreads:&v32 threadsPerThreadgroup:&v29];
      if (v12)
      {
        [v28 setBytes:v10 + 10 length:2 atIndex:1];
        id v32 = (id)v15;
        uint64_t v33 = v16;
        uint64_t v34 = 1;
        uint64_t v29 = v17;
        uint64_t v30 = v20;
        uint64_t v31 = 1;
        [v28 dispatchThreads:&v32 threadsPerThreadgroup:&v29];
      }
      uint64_t v21 = *((void *)a2 + 1);
      id v22 = v28;
      re::RenderManager::sampleComputeEncoderMTLCounterEnd(v21, &v22, 1u);

      if (v24) {
      if (v25)
      }

      if (v26) {
      if (v27)
      }
    }
  }
}

void *re::allocInfo_RenderGraphVRRUnwarpNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_450, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_450))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B610, "RenderGraphVRRUnwarpNode");
    __cxa_guard_release(&_MergedGlobals_450);
  }
  return &unk_26AF9B610;
}

void re::initInfo_RenderGraphVRRUnwarpNode(re *this, re::IntrospectionBase *a2)
{
  v21[0] = 0x602B7219C45EA382;
  v21[1] = "RenderGraphVRRUnwarpNode";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B5E8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B5E8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B5F0 = v7;
      unsigned int v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::introspect_RenderGraphTargetHandle((re *)1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "unwarpedColorHandle";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x11000000001;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF9B5F8 = v11;
      BOOL v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::introspect_RenderGraphTargetHandle((re *)1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "warpedColorHandle";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x10000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF9B600 = v15;
      unsigned int v16 = re::introspectionAllocator((re *)v15);
      unsigned int v18 = re::introspect_AssetHandle((re *)1, v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "library";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0x13000000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF9B608 = v19;
      __cxa_guard_release(&qword_26AF9B5E8);
    }
  }
  *((void *)this + 2) = 0x15000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF9B5F0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphVRRUnwarpNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphVRRUnwarpNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphVRRUnwarpNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphVRRUnwarpNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v20 = v22;
}

double re::internal::defaultConstruct<re::RenderGraphVRRUnwarpNode>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t v3 = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t v3 = &unk_26E71B328;
  *((void *)v3 + 32) = 0;
  *((void *)v3 + 33) = -1;
  *((void *)v3 + 34) = 0;
  *((void *)v3 + 35) = -1;
  *((void *)v3 + 36) = 0;
  *((void *)v3 + 37) = -1;
  *((unsigned char *)v3 + 67) = 0;
  double result = 0.0;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphVRRUnwarpNode>(int a1, int a2, re::RenderGraphVRRUnwarpNode *this)
{
}

double re::internal::defaultConstructV2<re::RenderGraphVRRUnwarpNode>(re::RenderGraphNode *a1)
{
  uint64_t v1 = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t v1 = &unk_26E71B328;
  *((void *)v1 + 32) = 0;
  *((void *)v1 + 33) = -1;
  *((void *)v1 + 34) = 0;
  *((void *)v1 + 35) = -1;
  *((void *)v1 + 36) = 0;
  *((void *)v1 + 37) = -1;
  *((unsigned char *)v1 + 67) = 0;
  double result = 0.0;
  *((_OWORD *)v1 + 19) = 0u;
  *((_OWORD *)v1 + 20) = 0u;
  return result;
}

uint64_t re::introspect_RenderGraphVRRUnwarpNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphVRRUnwarpNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphVRRUnwarpNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphVRRUnwarpNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphVRRUnwarpNode>, this);
}

void re::RenderGraphVRRUnwarpNode::~RenderGraphVRRUnwarpNode(re::RenderGraphVRRUnwarpNode *this)
{
  re::RenderGraphVRRUnwarpNode::~RenderGraphVRRUnwarpNode(this);
  JUMPOUT(0x237DBCBD0);
}

{
  void *v2;
  uint64_t vars8;

  uint64_t v2 = (void *)*((void *)this + 41);
  if (v2)
  {

    *((void *)this + 41) = 0;
  }
  re::AssetHandle::~AssetHandle((re::RenderGraphVRRUnwarpNode *)((char *)this + 304));
  re::RenderGraphNode::~RenderGraphNode((id *)this);
}

void re::SyncMechanism::resetWithNewEvent(id *this)
{
  uint64_t v2 = this + 2;
  id v3 = objc_msgSend(*this, sel_newEvent);
  NS::SharedPtr<MTL::Texture>::operator=(v2, &v3);
  if (v3) {

  }
  this[4] = (id)1;
}

uint64_t re::SyncMechanism::sync(re::SyncMechanism *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (!*((unsigned char *)this + 24))
  {
    if ((v2 & 3) != 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (!v2) {
LABEL_3:
  }
    re::SyncMechanism::resetWithNewEvent((id *)this);
LABEL_4:
  [*((id *)this + 1) encodeSignalEvent:*((void *)this + 2) value:(*((void *)this + 4))++];
  uint64_t result = objc_msgSend(*((id *)this + 1), "encodeWaitForEvent:value:", *((void *)this + 2));
  ++*((void *)this + 5);
  return result;
}

void re::RenderGraphVFXNode::setup(re::RenderGraphNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  *((unsigned char *)a2 + 592) = 1;
  re::RenderGraphNode::setup(this, a2, a3);
}

void re::RenderGraphVFXNode::execute(re::RenderGraphVFXNode *this, re::RenderGraphContext *a2)
{
  void (***TextureTableByName)(void *__return_ptr);
  void (***v14)(void *__return_ptr);
  void *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  re *v32;
  uint64_t v33;
  re **v34;
  void *v35;
  re *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  id v42;
  id v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int64x2_t *v49;
  uint64_t v50;
  uint64_t v51;
  int64x2_t v52;
  uint64_t v53;
  uint64_t v54;
  long long v55;
  long long v56;
  _OWORD v58[4];
  unsigned char v59[16];
  id v60[4];
  long long v61;
  long long v62;
  id v63;
  uint64_t v64;
  _OWORD *v65;
  void v66[7];

  v66[5] = *MEMORY[0x263EF8340];
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(this);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v4 = re::profilerThreadContext(isStatisticCollectionEnabled);
    if (*(void *)(v4 + 152)) {
      uint64_t v53 = mach_absolute_time();
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v59, 5085, 0);
  *((unsigned char *)a2 + 1512) = 3;
  uint64_t v5 = *((void *)a2 + 146);
  unint64_t v6 = (unint64_t)"N2re27RenderGraphDataStoreWrapperIPNS_23ActiveVFXSimulationDataEEE";
  if (((unint64_t)"N2re27RenderGraphDataStoreWrapperIPNS_23ActiveVFXSimulationDataEEE" & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)((unint64_t)"N2re27RenderGraphDataStoreWrapperIPNS_23ActiveVFXSimulationDataEEE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  uint64_t v10 = *(void *)(*((void *)a2 + 1) + 80);
  v60[0] = (id)((*(void *)(*((void *)a2 + 5) + 48) + (v6 << 6) + (v6 >> 2) - 0x61C8864680B583E9) ^ v6);
  uint64_t v11 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v5 + 16, (uint64_t *)v60);
  if (v11)
  {
    uint64_t v12 = *v11;
    if (*v11)
    {
      TextureTableByName = (void (***)(void *__return_ptr))re::MaterialManager::findTextureTableByName(*(re::MaterialManager **)(*((void *)a2 + 1)+ 24), "VFXTextureTable");
      BOOL v54 = v4;
      if (TextureTableByName)
      {
        uint64_t v14 = TextureTableByName;
        v60[0] = (id)0xC10C601B47401E3;
        (**TextureTableByName)(v66);
        ((void (*)(id *__return_ptr, void (***)(void *__return_ptr), void))(*v14)[3])(v60, v14, BYTE2(v66[0]));
        uint64_t v15 = (void *)(*(void *)a2 + 368);
        *(void *)&v58[0] = 0x6C456FCA259980DELL;
        re::DynamicTextureTableAdd(v15, v58, v60);
        if (v60[0]) {
      }
        }
      else if ((atomic_exchange(_MergedGlobals_451, 1u) & 1) == 0)
      {
        unsigned int v16 = *re::graphicsLogObjects(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v60[0]) = 0;
          _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_DEFAULT, "Cannot retrieve VFX texture table, VFX couldn't be rendered", (uint8_t *)v60, 2u);
        }
      }
      unsigned int v17 = *(void *)(v12 + 8);
      unint64_t v55 = *(_OWORD *)(v17 + 48);
      uint64_t v56 = *(_OWORD *)(v17 + 64);
      memset(v58, 0, sizeof(v58));
      re::Projection::computeMatrix4x4F((re::Projection *)(v17 + 80), (uint64_t)v58);
      unsigned int v18 = *(void *)(v17 + 16);
      if (v18)
      {
        uint64_t v19 = *(uint64_t **)(v17 + 32);
        long long v20 = &v19[v18];
        do
        {
          uint64_t v21 = *v19;
          if (*(unsigned char *)(*v19 + 794)) {
            long long v22 = 1;
          }
          else {
            long long v22 = *(float *)(*v19 + 772) == -1.0;
          }
          if (!v22)
          {
            id v23 = *(id *)(v21 + 664);
            id v24 = [v23 uuid];
            *(unsigned char *)(v10 + 18) = 1;
            id v25 = *(void *)(v10 + 112);
            id v26 = *(void *)(v10 + 96);
            if (v26)
            {
              id v27 = 8 * v26;
              id v28 = *(void **)(v10 + 112);
              while (*v28 != v24)
              {
                ++v28;
                v27 -= 8;
                if (!v27)
                {
                  id v28 = (void *)(v25 + 8 * v26);
                  break;
                }
              }
            }
            else
            {
              id v28 = *(void **)(v10 + 112);
            }
            if (v26 != ((uint64_t)v28 - v25) >> 3)
            {
              uint64_t v29 = [v23 scene];
              [v29 restart];
            }
            uint64_t v30 = [v23 scene];
            v60[0] = (id)MEMORY[0x263EF8330];
            v60[1] = (id)3221225472;
            v60[2] = ___ZN2re12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4b_block_invoke;
            v60[3] = &unk_264BE8330;
            uint64_t v63 = v23;
            uint64_t v64 = v21;
            long long v61 = v56;
            uint64_t v62 = v55;
            long long v65 = v58;
            uint64_t v31 = v23;
            [v30 performTransaction:v60];

            re::globalAllocators(v32);
            uint64_t v33 = *(void *)(*(void *)a2 + 24);
            uint64_t v34 = (re **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 8, 8);
            long long v35 = [v31 recycleBuffersGetCompletion];
            uint64_t v36 = (re *)_Block_copy(v35);
            *uint64_t v34 = v36;
            v66[3] = re::globalAllocators(v36)[2];
            v66[4] = v66;
            v66[0] = &unk_26E71B4B8;
            (*(void (**)(uint64_t, re **, void *))(*(void *)v33 + 16))(v33, v34, v66);
            re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v66);
          }
          ++v19;
        }
        while (v19 != v20);
        uint64_t v37 = *(void *)(v17 + 16);
        if (v37)
        {
          uint64_t v38 = 8 * v37;
          unint64_t v39 = *(uint64_t **)(v17 + 32);
          do
          {
            uint64_t v40 = *v39;
            uint64_t v41 = *((unsigned __int8 *)this + 256);
            uint64_t v42 = *(id *)(*v39 + 664);
            *(unsigned char *)(v40 + 794) = 1;
            uint64_t v43 = v42;
            *(void *)(v40 + 784) = [v43 drawCallCount];
            if (v41)
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B6A8, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_26AF9B6A8))
              {
                qword_26AF9B6E0 = 0;
                qword_26AF9B6E8 = 0;
                qword_26AF9B6D8 = 0;
                __cxa_atexit((void (*)(void *))re::FixedArray<re::MaterialParameterTable const*>::~FixedArray, &qword_26AF9B6D8, &dword_233120000);
                __cxa_guard_release(&qword_26AF9B6A8);
              }
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B6B0, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_26AF9B6B0))
              {
                qword_26AF9B6F8 = 0;
                unk_26AF9B700 = 0;
                qword_26AF9B6F0 = 0;
                __cxa_atexit((void (*)(void *))re::FixedArray<re::SharedPtr<re::MaterialParameterTable>>::~FixedArray, &qword_26AF9B6F0, &dword_233120000);
                __cxa_guard_release(&qword_26AF9B6B0);
              }
              if (qword_26AF9B6B8 == -1)
              {
                signed int v44 = &qword_26AF9B6E8;
                unint64_t v45 = &qword_26AF9B6E0;
              }
              else
              {
                dispatch_once(&qword_26AF9B6B8, &__block_literal_global_41);
                unint64_t v45 = &qword_26AF9B6E0;
                signed int v44 = &qword_26AF9B6E8;
              }
            }
            else
            {
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B6C0, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_26AF9B6C0))
              {
                qword_26AF9B710 = 0;
                qword_26AF9B718 = 0;
                qword_26AF9B708 = 0;
                __cxa_atexit((void (*)(void *))re::FixedArray<re::MaterialParameterTable const*>::~FixedArray, &qword_26AF9B708, &dword_233120000);
                __cxa_guard_release(&qword_26AF9B6C0);
              }
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B6C8, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_26AF9B6C8))
              {
                qword_26AF9B728 = 0;
                unk_26AF9B730 = 0;
                qword_26AF9B720 = 0;
                __cxa_atexit((void (*)(void *))re::FixedArray<re::SharedPtr<re::MaterialParameterTable>>::~FixedArray, &qword_26AF9B720, &dword_233120000);
                __cxa_guard_release(&qword_26AF9B6C8);
              }
              if (qword_26AF9B6D0 == -1)
              {
                signed int v44 = &qword_26AF9B718;
                unint64_t v45 = &qword_26AF9B710;
              }
              else
              {
                dispatch_once(&qword_26AF9B6D0, &__block_literal_global_12_1);
                unint64_t v45 = &qword_26AF9B710;
                signed int v44 = &qword_26AF9B718;
              }
            }
            unint64_t v46 = *v45;
            unint64_t v47 = *v44;

            *(void *)(v40 + 184) = v47;
            *(void *)(v40 + 192) = v46;
            ++v39;
            v38 -= 8;
          }
          while (v38);
        }
      }
      *((unsigned char *)a2 + 1512) = 0;
      uint64_t v4 = v54;
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v59);
  if (v4)
  {
    if (*(void *)(v4 + 152))
    {
      unint64_t v48 = mach_absolute_time();
      unint64_t v49 = *(int64x2_t **)(v4 + 152);
      if (v49)
      {
        unint64_t v50 = v49[604].u64[0];
        if (v50 >= v48 - v53) {
          unint64_t v50 = v48 - v53;
        }
        v49[604].i64[0] = v50;
        uint64_t v51 = v49[604].u64[1];
        if (v51 <= v48 - v53) {
          uint64_t v51 = v48 - v53;
        }
        v49[604].i64[1] = v51;
        uint64_t v52 = vdupq_n_s64(1uLL);
        v52.i64[0] = v48 - v53;
        v49[605] = vaddq_s64(v49[605], v52);
        *(unsigned char *)(v4 + 184) = 0;
      }
    }
  }
}

void *re::allocInfo_RenderGraphVFXNode(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B690, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF9B690))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF9B738, "RenderGraphVFXNode");
    __cxa_guard_release(&qword_26AF9B690);
  }
  return &unk_26AF9B738;
}

void re::initInfo_RenderGraphVFXNode(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0xA5BAE2AEEC3D8B24;
  v9[1] = "RenderGraphVFXNode";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B6A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF9B6A0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RenderGraphNode((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "RenderGraphNode";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(_DWORD *)(v7 + 40) = 3;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF9B698 = v7;
      __cxa_guard_release(&qword_26AF9B6A0);
    }
  }
  *((void *)this + 2) = 0x10800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF9B698;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphVFXNode>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphVFXNode>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RenderGraphVFXNode>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphVFXNode>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

re::RenderGraphNode *re::internal::defaultConstruct<re::RenderGraphVFXNode>(int a1, int a2, re::RenderGraphNode *this)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(this);
  *(void *)uint64_t result = &unk_26E71B3D0;
  *((unsigned char *)result + 256) = 0;
  return result;
}

void re::internal::defaultDestruct<re::RenderGraphVFXNode>(int a1, int a2, id *this)
{
}

re::RenderGraphNode *re::internal::defaultConstructV2<re::RenderGraphVFXNode>(re::RenderGraphNode *a1)
{
  uint64_t result = re::RenderGraphNode::RenderGraphNode(a1);
  *(void *)uint64_t result = &unk_26E71B3D0;
  *((unsigned char *)result + 256) = 0;
  return result;
}

uint64_t re::introspect_RenderGraphVFXNode(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphVFXNode", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphVFXNode, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphVFXNode, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphVFXNode>, this);
}

void re::RenderGraphVFXNode::~RenderGraphVFXNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::FixedArray<re::MaterialParameterTable const*>::~FixedArray(uint64_t *a1)
{
  return a1;
}

void *re::FixedArray<re::SharedPtr<re::MaterialParameterTable>>::~FixedArray(void *a1)
{
  if (*a1)
  {
    uint64_t v2 = a1[1];
    if (v2)
    {
      uint64_t v3 = a1[2];
      uint64_t v4 = 8 * v2;
      do
      {
        if (*(void *)v3)
        {

          *(void *)uint64_t v3 = 0;
        }
        v3 += 8;
        v4 -= 8;
      }
      while (v4);
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return a1;
}

void ___ZN2re12_GLOBAL__N_122materialParameterTableEb_block_invoke()
{
}

void re::anonymous namespace'::buildMaterialTables(uint64_t *a1, void *a2, unint64_t a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  MurmurHash3_x64_128((uint64_t)"Opaque", 6, 0, (unint64_t *)&v36);
  long long v8 = (re::MaterialParameterTable *)*((void *)&v36 + 1);
  unint64_t v7 = v36;
  MurmurHash3_x64_128((uint64_t)"Transparent", 11, 0, (unint64_t *)&v36);
  uint64_t v10 = *((void *)&v36 + 1);
  unsigned int v9 = (re::MaterialParameterTable *)v36;
  uint64_t v11 = (_anonymous_namespace_ *)MurmurHash3_x64_128((uint64_t)"VFXDepthWrite", 13, 0, (unint64_t *)&v36);
  unint64_t v12 = *((void *)&v36 + 1);
  unint64_t v13 = v36;
  a2[1] = 3;
  a2[2] = v14;
  if (v14)
  {
    LOBYTE(v25) = a3;
    a3 = 0;
    unint64_t v3 = ((unint64_t)v8 + 64 * v7 + (v7 >> 2) - 0x61C8864680B583E9) ^ v7;
    unint64_t v7 = (v10 + ((void)v9 << 6) + ((unint64_t)v9 >> 2) - 0x61C8864680B583E9) ^ (unint64_t)v9;
    unint64_t v12 = (v12 + (v13 << 6) + (v13 >> 2) - 0x61C8864680B583E9) ^ v13;
    *(void *)uint64_t v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    do
    {
      re::make::shared::object<re::MaterialParameterTable>(v14, &v26);
      long long v8 = (re::MaterialParameterTable *)a2[1];
      if ((unint64_t)v8 <= a3)
      {
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        uint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 468;
        __int16 v32 = 2048;
        uint64_t v33 = a3;
        __int16 v34 = 2048;
        uint64_t v35 = (uint64_t)v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_36:
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        uint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 468;
        __int16 v32 = 2048;
        uint64_t v33 = a3;
        __int16 v34 = 2048;
        uint64_t v35 = a3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_37:
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        uint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 468;
        __int16 v32 = 2048;
        uint64_t v33 = v7;
        __int16 v34 = 2048;
        uint64_t v35 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_38;
      }
      uint64_t v16 = a2[2];
      uint64_t v17 = *(void *)(v16 + 8 * a3);
      *(void *)(v16 + 8 * a3) = v26;
      uint64_t v26 = v17;
      if (v17) {

      }
      ++a3;
    }
    while (a3 != 3);
    uint64_t v18 = a2[1];
    if (!v18) {
      goto LABEL_39;
    }
    if (v18 != 1)
    {
      uint64_t v19 = (re::MaterialParameterTable **)a2[2];
      unsigned int v9 = *v19;
      long long v8 = v19[1];
      a3 = (unint64_t)&unk_26879F000;
      if (re::MaterialParameterTable::kDefaultNameHash(void)::once != -1) {
        goto LABEL_41;
      }
      goto LABEL_10;
    }
  }
  else
  {
LABEL_38:
    re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_39:
    uint64_t v27 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v36 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v28 = 136315906;
    uint64_t v29 = "operator[]";
    __int16 v30 = 1024;
    int v31 = 468;
    __int16 v32 = 2048;
    uint64_t v33 = 0;
    __int16 v34 = 2048;
    uint64_t v35 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v27 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  a2 = (void *)&_os_log_internal;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  int v28 = 136315906;
  uint64_t v29 = "operator[]";
  __int16 v30 = 1024;
  int v31 = 468;
  __int16 v32 = 2048;
  uint64_t v33 = 1;
  __int16 v34 = 2048;
  uint64_t v35 = 1;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_41:
  dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
LABEL_10:
  if (*(void *)(a3 + 3320) != -1) {
    dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
  }
  if (*(void *)(a3 + 3320) != -1) {
    dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v9, v3, 0, re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash);
  if (*(void *)(a3 + 3320) != -1) {
    dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v8, v7, 0, re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash);
  if (*(void *)(a3 + 3320) != -1) {
    dispatch_once(&re::MaterialParameterTable::kDefaultNameHash(void)::once, &__block_literal_global_29);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v8, v12, 0, re::MaterialParameterTable::kDefaultNameHash(void)::_kDefaultNameHash);
  unint64_t v21 = v7;
  unint64_t v3 = v12;
  if (v25)
  {
    unint64_t v25 = v12;
    MurmurHash3_x64_128((uint64_t)"FadeDepthPrepass", 16, 0, (unint64_t *)&v36);
    unint64_t v22 = (*((void *)&v36 + 1) - 0x61C8864680B583E9 + ((void)v36 << 6) + ((unint64_t)v36 >> 2)) ^ v36;
    MurmurHash3_x64_128((uint64_t)"FadeOpaque", 10, 0, (unint64_t *)&v36);
    unint64_t v21 = (*((void *)&v36 + 1) - 0x61C8864680B583E9 + ((void)v36 << 6) + ((unint64_t)v36 >> 2)) ^ v36;
    MurmurHash3_x64_128((uint64_t)"VFXFadeOpaqueDepthWrite", 23, 0, (unint64_t *)&v36);
    unint64_t v3 = (*((void *)&v36 + 1) - 0x61C8864680B583E9 + ((void)v36 << 6) + ((unint64_t)v36 >> 2)) ^ v36;
    if (re::MaterialParameterTable::kFadeNameHash(void)::once != -1) {
      dispatch_once(&re::MaterialParameterTable::kFadeNameHash(void)::once, &__block_literal_global_4_1);
    }
    re::MaterialParameterTable::addPassTechniqueMapping(v9, v22, 0, re::MaterialParameterTable::kFadeNameHash(void)::_kFadeNameHash);
    unint64_t v12 = v25;
  }
  if (re::MaterialParameterTable::kFadeNameHash(void)::once != -1) {
    dispatch_once(&re::MaterialParameterTable::kFadeNameHash(void)::once, &__block_literal_global_4_1);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v9, v21, 0, re::MaterialParameterTable::kFadeNameHash(void)::_kFadeNameHash);
  if (re::MaterialParameterTable::kFadeNameHash(void)::once != -1) {
    dispatch_once(&re::MaterialParameterTable::kFadeNameHash(void)::once, &__block_literal_global_4_1);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v9, v3, 0, re::MaterialParameterTable::kFadeNameHash(void)::_kFadeNameHash);
  if (re::MaterialParameterTable::kFadeNameHash(void)::once != -1) {
    dispatch_once(&re::MaterialParameterTable::kFadeNameHash(void)::once, &__block_literal_global_4_1);
  }
  re::MaterialParameterTable::addPassTechniqueMapping(v8, v7, 0, re::MaterialParameterTable::kFadeNameHash(void)::_kFadeNameHash);
  if (re::MaterialParameterTable::kFadeNameHash(void)::once != -1) {
    dispatch_once(&re::MaterialParameterTable::kFadeNameHash(void)::once, &__block_literal_global_4_1);
  }
  id v23 = (_anonymous_namespace_ *)re::MaterialParameterTable::addPassTechniqueMapping(v8, v12, 0, re::MaterialParameterTable::kFadeNameHash(void)::_kFadeNameHash);
  id v24 = 0;
  a3 = a2[1];
  unint64_t v7 = a1[1];
  do
  {
    if ((void *)a3 == v24) {
      goto LABEL_36;
    }
    if ((void *)v7 == v24) {
      goto LABEL_37;
    }
    *(void *)(a1[2] + 8 * (void)v24) = *(void *)(a2[2] + 8 * (void)v24);
    id v24 = (char *)v24 + 1;
  }
  while (v24 != (void *)3);
}

void ___ZN2re12_GLOBAL__N_122materialParameterTableEb_block_invoke_2()
{
}

uint64_t ___ZN2re12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4b_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a1 + 72) + 792);
  unint64_t v3 = [*(id *)(a1 + 64) scene];
  [v3 setIsPlaying:v2];

  uint64_t v4 = [*(id *)(a1 + 64) scene];
  LODWORD(v5) = *(_DWORD *)(*(void *)(a1 + 72) + 768);
  [v4 setTimeScale:v5];

  __asm { FMOV            V0.4S, #1.0 }
  [*(id *)(a1 + 64) setCameraEntityTransformProjection:*(double *)&_Q0 :*(double *)(a1 + 32) :*(double *)(a1 + 48) :**(double **)(a1 + 80) :*(double *)(*(void *)(a1 + 80) + 16) :*(double *)(*(void *)(a1 + 80) + 32) :*(double *)(*(void *)(a1 + 80) + 48)];
  LODWORD(v11) = *(_DWORD *)(*(void *)(a1 + 72) + 776);
  [*(id *)(a1 + 64) setSceneScale:v11];
  [*(id *)(a1 + 64) setSceneTransform:*(double *)(*(void *)(a1 + 72) + 720) :*(double *)(*(void *)(a1 + 72) + 736) :*(double *)(*(void *)(a1 + 72) + 752)];
  [*(id *)(a1 + 64) setRootTransform:*(double *)(*(void *)(a1 + 72) + 672) :*(double *)(*(void *)(a1 + 72) + 688) :*(double *)(*(void *)(a1 + 72) + 704)];
  unint64_t v12 = *(void **)(a1 + 64);
  double v13 = *(float *)(*(void *)(a1 + 72) + 772);
  return [v12 tickWithDeltaTime:v13];
}

void _ZN2re8internal8CallableIZNS_12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4bE3__0FvPvEJEED0Ev()
{
}

void _ZNK2re8internal8CallableIZNS_12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4bE3__0FvPvEJEEclEOSG_(uint64_t a1, void (****a2)(void))
{
  uint64_t v2 = *a2;
  unint64_t v3 = **a2;
  if (v3)
  {
    v3[2]();
    unint64_t v3 = *v2;
  }
}

void *_ZNK2re8internal8CallableIZNS_12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4bE3__0FvPvEJEE9cloneIntoESG_(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E71B4B8;
  return result;
}

void *_ZN2re8internal8CallableIZNS_12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4bE3__0FvPvEJEE8moveIntoESG_(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E71B4B8;
  return result;
}

uint64_t _ZNK2re8internal8CallableIZNS_12_GLOBAL__N_116simulateVFXSceneERNS_18RenderGraphContextERKNS_8VFXSceneERNS_10VFXManagerEDv4_fDv3_fRK13simd_float4x4bE3__0FvPvEJEE4sizeEv()
{
  return 16;
}

uint64_t re::BucketArray<re::DynamicArray<re::VFXScene>,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 40 * (a2 & 3);
}

unint64_t re::ProfilerOverlayRenderGraphProvider::prepareFrame(re::ProfilerOverlayRenderGraphProvider *this, char *a2, const char *a3, re::RenderFrame *a4)
{
  v5[0] = 0x25D31770DB1DF3E2;
  v5[1] = (unint64_t)"ProfilerOverlayRenderGraphProvider";
  return re::RenderGraphProviderBase::generateScopeHash(v5, a2, a3);
}

double re::ProfilerOverlayRenderGraphProvider::provide(re::ProfilerOverlayRenderGraphProvider *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  int v15 = 2;
  uint64_t v16 = -1;
  uint64_t v17 = -1;
  uint64_t v18 = -1;
  char v19 = 0;
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v20 = _D0;
  long long v21 = xmmword_2343AEB90;
  long long v22 = xmmword_2343AEBA0;
  int v23 = -1;
  long long v24 = xmmword_234378E20;
  char v25 = 0;
  uint64_t v14 = 3;
  re::RenderFrame::createTarget(a4, (const re::RenderGraphTargetDescription *)&v14, "Profiler Overlay Output", v13);
  v26[0] = 65290051;
  re::RenderFrame::addTargetOutput(a4, v26, v13, 0);
  RenderGraph = (re *)re::RenderFrame::makeRenderGraph(a4, "ProfilerOverlay", 0);
  double v11 = re::RenderGraph::addNode<re::RenderGraphProfilerOverlayNode>(RenderGraph, "Profiler Overlay Render Node");
  *(double *)uint64_t v26 = v13[0];
  *(double *)&v26[1] = v13[1];
  void v26[2] = 0x100000000;
  long long v27 = xmmword_23435FBB0;
  __int16 v28 = 0;
  uint64_t v29 = 0;
  *(void *)&double result = re::DynamicArray<re::TargetWrite>::add((re::RenderGraphProfilerOverlayNode *)((char *)v11 + 216), (uint64_t)v26).n128_u64[0];
  return result;
}

__n128 re::RenderGraphProfilerOverlayNode::RenderGraphProfilerOverlayNode(re::RenderGraphProfilerOverlayNode *this, const char *a2)
{
  unint64_t v2 = re::RenderGraphNode::RenderGraphNode(this, a2);
  *((_DWORD *)v2 + 64) = 1;
  *(void *)unint64_t v2 = &unk_26E71B510;
  *(_OWORD *)((char *)v2 + 264) = 0u;
  *(_OWORD *)((char *)v2 + 280) = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  *((__n128 *)v2 + 19) = result;
  *((_OWORD *)v2 + 20) = xmmword_23440EAE0;
  *((void *)v2 + 42) = 0x3F33333341A00000;
  *((_DWORD *)v2 + 86) = 1061997773;
  *((_OWORD *)v2 + 22) = xmmword_234396400;
  *((_OWORD *)v2 + 23) = xmmword_23440EAF0;
  *((__n128 *)v2 + 24) = result;
  *((_DWORD *)v2 + 100) = 1050253722;
  return result;
}

void re::RenderGraphProfilerOverlayNode::configure(re::RenderGraphProfilerOverlayNode *this, const char *a2, const char *a3, re::RenderFrame *a4)
{
  if (*((void *)this + 34))
  {
    long long v8 = *(re::DrawingManager **)(*((void *)a4 + 1) + 104);
    if (v8)
    {
      if (re::DrawingManager::shouldRenderProfilerNode(v8)) {
        *((void *)this + 36) = re::AssetHandle::asset<re::MaterialAsset>((re::RenderGraphProfilerOverlayNode *)((char *)this + 264));
      }
    }
  }
  re::RenderGraphNode::configure(this, a2, a3, a4);
}

void re::RenderGraphProfilerOverlayNode::setup(re::RenderGraphProfilerOverlayNode *this, re::RenderGraphBuilder *a2, re::RenderGraphDataStore *a3)
{
  if (*((void *)this + 36))
  {
    if (!*((void *)this + 24))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::RenderGraphBuilder::read((uint64_t)a2, *((void *)this + 26), *((void *)this + 26) + 16);
  }
  re::RenderGraphNode::setup(this, a2, a3);
}

uint64_t re::RenderGraphProfilerOverlayNode::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,id a37,uint64_t a38,uint64_t a39,uint64_t a40,id a41,uint64_t a42,id a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,id a55,uint64_t a56,re::DynamicString *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v77 = a2;
  uint64_t v78 = a1;
  unint64_t v79 = (unint64_t)&STACK[0xD60];
  uint64_t v80 = (uint64_t)&STACK[0xAE0];
  unint64_t v81 = (unint64_t)&a83;
  STACK[0xE58] = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 288)) {
    goto LABEL_44;
  }
  uint64_t v82 = *(re::DrawingManager **)(*(void *)(a2 + 8) + 104);
  if (!v82 || !re::DrawingManager::shouldRenderProfilerNode(v82)) {
    goto LABEL_44;
  }
  uint64_t v83 = 0xA3521516DAFB1;
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard((uint64_t *)&__p);
  uint64_t v84 = *(void *)v77;
  STACK[0xAE0] = 0xA3521516DAFB1;
  if (!*(void *)(v78 + 192))
  {
LABEL_443:
    STACK[0xA70] = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    uint64_t v77 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    *(void *)(v79 + 4) = "operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    *(_DWORD *)(v79 + 14) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    *(void *)(v79 + 20) = 0;
    LOWORD(STACK[0xD7C]) = 2048;
    *(void *)(v79 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_444:
    re::internal::assertLog((re::internal *)6, v98, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_445;
  }
  uint64_t v85 = (void *)(v84 + 368);
  re::RenderGraphContext::metalTexture(v77, *(void *)(v78 + 208), 0, 0, (id *)&STACK[0xD60]);
  re::makeView2DTo2DArray((id *)&STACK[0xD60], &STACK[0xB60]);
  re::DynamicTextureTableAdd(v85, &STACK[0xAE0], (id *)&STACK[0xB60]);
  if (STACK[0xB60])
  {

    STACK[0xB60] = 0;
  }
  if (STACK[0xD60]) {

  }
  uint64_t v76 = v78;
  uint64_t v86 = *(void *)(*(void *)(v78 + 288) + 1664);
  uint64_t v87 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
  unint64_t v75 = v87;
  unsigned __int8 v88 = 1;
  if (v87)
  {
    BOOL v89 = *(unsigned char *)(v87 + 65) != 0;
    if (*(unsigned char *)(v87 + 65)) {
      unsigned __int8 v88 = 2;
    }
    else {
      unsigned __int8 v88 = 1;
    }
  }
  else
  {
    BOOL v89 = 0;
  }
  unint64_t v90 = *(void *)(v76 + 272);
  if (v90) {
    uint64_t v91 = *(void *)(v90 + 664);
  }
  else {
    uint64_t v91 = 0;
  }
  unint64_t v92 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v90 ^ (v90 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v90 ^ (v90 >> 30))) >> 27));
  STACK[0xB60] = v91 ^ (v92 >> 31) ^ v92;
  id v93 = (uint64_t *)re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(v77 + 1568, (uint64_t *)&STACK[0xB60]);
  if (v93) {
    uint64_t v94 = *v93;
  }
  else {
    uint64_t v94 = 0;
  }
  re::RenderGraphContext::makeFullscreenDrawCall((void *)v77, v86, v94, 0, 0, 0, (int32x2_t *)&STACK[0xB60]);
  uint64_t v95 = (re::MaterialParameterTableLayers *)STACK[0xBA0];
  if (v89) {
    uint64_t v83 = (uint64_t)"fullscreenarray";
  }
  else {
    uint64_t v83 = (uint64_t)"fullscreen";
  }
  if (v89) {
    int v96 = 15;
  }
  else {
    int v96 = 10;
  }
  MurmurHash3_x64_128(v83, v96, 0, &STACK[0xD60]);
  uint64_t v97 = (int *)re::MaterialParameterTableLayers::resolveTechniqueIndices(v95, (STACK[0xD68] + (STACK[0xD60] << 6) + (STACK[0xD60] >> 2) - 0x61C8864680B583E9) ^ STACK[0xD60]);
  if (!v98) {
    goto LABEL_444;
  }
  int v99 = *v97;
  LODWORD(STACK[0xB8C]) = *v97;
  if (v99 == -1) {
    goto LABEL_43;
  }
  uint64_t v100 = re::RenderGraphDataStore::tryGet<re::CameraData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
  STACK[0xA10] = 0;
  STACK[0xA00] = 0;
  a83 = 0uLL;
  LODWORD(STACK[0xA08]) = 0;
  STACK[0xB50] = 0;
  STACK[0xB38] = 0;
  STACK[0xB40] = 0;
  STACK[0xB30] = 0;
  LODWORD(STACK[0xB48]) = 0;
  if (v100)
  {
    uint64_t v101 = v100;
    if (*(void *)(v100 + 128))
    {
      unint64_t v79 = 0;
      unint64_t v75 = 0;
      while (1)
      {
        re::Projection::computeMatrix4x4F((re::Projection *)(v101 + 144 + (v79 << 6)), (uint64_t)&STACK[0xD60]);
        *(void *)&double v103 = re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&STACK[0xB30], (uint64_t)&STACK[0xD60]).n128_u64[0];
        unint64_t v104 = *(void *)(v101 + 48);
        if (v104 <= v79) {
          break;
        }
        re::RenderCamera::computeInverseTransform((float32x4_t *)(v101 + 64 + 32 * v79), (uint64_t)&STACK[0xD60]);
        re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&a83, (uint64_t)&STACK[0xD60]);
        unint64_t v75 = (v75 + 1);
        unint64_t v79 = v75;
        if (*(void *)(v101 + 128) <= (unint64_t)v75) {
          goto LABEL_33;
        }
      }
      re::internal::assertLog((re::internal *)6, v102, v103, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < m_size", "operator[]", 389, v79, v104);
      _os_crash();
      __break(1u);
      goto LABEL_443;
    }
LABEL_33:
    unsigned __int8 v88 = *(unsigned char *)(v101 + 490);
    unint64_t v79 = (unint64_t)&STACK[0xD60];
  }
  else
  {
    *(_OWORD *)&STACK[0xD60] = xmmword_23435FD50;
    *(_OWORD *)&STACK[0xD70] = xmmword_23435FD60;
    *(_OWORD *)&STACK[0xD80] = xmmword_23435FD80;
    *(_OWORD *)&STACK[0xD90] = xmmword_23435FBB0;
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&STACK[0xB30], (uint64_t)&STACK[0xD60]);
    *(_OWORD *)&STACK[0xD60] = xmmword_23435FD50;
    *(_OWORD *)&STACK[0xD70] = xmmword_23435FD60;
    *(_OWORD *)&STACK[0xD80] = xmmword_23435FD80;
    *(_OWORD *)&STACK[0xD90] = xmmword_23435FBB0;
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&a83, (uint64_t)&STACK[0xD60]);
    if (v89)
    {
      unsigned __int8 v88 = *(unsigned char *)(v75 + 64);
      *(_OWORD *)&STACK[0xD60] = xmmword_23435FD50;
      *(_OWORD *)&STACK[0xD70] = xmmword_23435FD60;
      *(_OWORD *)&STACK[0xD80] = xmmword_23435FD80;
      *(_OWORD *)&STACK[0xD90] = xmmword_23435FBB0;
      re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&STACK[0xB30], (uint64_t)&STACK[0xD60]);
      *(_OWORD *)&STACK[0xD60] = xmmword_23435FD50;
      *(_OWORD *)&STACK[0xD70] = xmmword_23435FD60;
      *(_OWORD *)&STACK[0xD80] = xmmword_23435FD80;
      *(_OWORD *)&STACK[0xD90] = xmmword_23435FBB0;
      re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)&a83, (uint64_t)&STACK[0xD60]);
    }
  }
  LODWORD(STACK[0xB84]) = v88;
  unint64_t v75 = (unint64_t)&STACK[0xA38];
  re::DrawCallRef::DrawCallRef(&STACK[0xA38], (const re::DrawCall *)&STACK[0xB60]);
  uint64_t v105 = 0;
  STACK[0xD60] = (unint64_t)&STACK[0xA38];
  int64x2_t v106 = vdupq_n_s64(1uLL);
  *(int64x2_t *)&STACK[0xD68] = v106;
  STACK[0xD78] = (unint64_t)&STACK[0xA40];
  *(int64x2_t *)&STACK[0xD80] = v106;
  STACK[0xD90] = (unint64_t)&STACK[0xA48];
  *(int64x2_t *)&STACK[0xD98] = v106;
  STACK[0xDA8] = (unint64_t)&STACK[0xA50];
  *(int64x2_t *)&STACK[0xDB0] = v106;
  STACK[0xDC0] = (unint64_t)&STACK[0xA58];
  *(int64x2_t *)&STACK[0xDC8] = v106;
  STACK[0xA70] = v83;
  STACK[0xA78] = (unint64_t)&STACK[0xD60];
  unint64_t v107 = STACK[0xB50];
  STACK[0xA80] = STACK[0xA10];
  STACK[0xA88] = v107;
  STACK[0xA90] = 0;
  LOBYTE(STACK[0xA98]) = v88;
  LOWORD(STACK[0xA99]) = 2;
  LOWORD(STACK[0xA9C]) = 0;
  *(_OWORD *)&STACK[0xAAF] = 0u;
  *(_OWORD *)&STACK[0xABF] = 0u;
  LOBYTE(STACK[0xACF]) = 0;
  if (*(unsigned char *)(v77 + 1332)) {
    goto LABEL_451;
  }
  while (1)
  {
    *(void *)(v81 + 224) = v105;
    LOBYTE(STACK[0xAD8]) = 0;
    re::RenderGraphContext::getDefaultEncodeDrawCallDataStoreArgs((re::RenderGraphContext *)v77, (uint64_t *)&STACK[0xAE0]);
    re::RenderGraphContext::encodeDrawCalls(v77, &STACK[0xAE0], &STACK[0xA70]);
    uint64_t v108 = (re *)(*(void *)v77 + 368);
    *(void *)(v81 + 240) = 0xA3521516DAFB1;
    re::DynamicTextureTableRemove(v108, (re::TextureTable *)&STACK[0xAE0], v109);
    if (STACK[0xB30] && STACK[0xB50]) {
      (*(void (**)(unint64_t))(*(void *)STACK[0xB30] + 40))(STACK[0xB30]);
    }
    if ((void)a83 && *(void *)(v81 + 32)) {
      (*(void (**)(void))(*(void *)a83 + 40))();
    }
LABEL_43:
    re::ProfilerTimeGuard<(re::ProfilerStatistic)23>::end((uint64_t)&__p);
    uint64_t v78 = v76;
LABEL_44:
    uint64_t result = *(void *)(*(void *)(v77 + 8) + 104);
    if (!result) {
      return result;
    }
    uint64_t result = re::DrawingManager::shouldRenderProfilerNode((re::DrawingManager *)result);
    if (!result) {
      return result;
    }
    uint64_t v111 = *(void *)(*(void *)(v77 + 8) + 104);
    if (!v111 || !*(void *)(v111 + 1664)) {
      return result;
    }
    re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard((uint64_t *)&STACK[0xA60]);
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA28], 5074, 0);
    uint64_t v112 = *(void *)(v77 + 8);
    if (*(void *)(v112 + 8) < 2uLL) {
      goto LABEL_156;
    }
    uint64_t v113 = *(void *)(v112 + 104);
    if (v113) {
      unint64_t v75 = *(void *)(v113 + 1664);
    }
    else {
      unint64_t v75 = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v75 + 16));
    STACK[0xB60] = re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>();
    uint64_t v114 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((void *)(v75 + 480), &STACK[0xB60]);
    if (!v114)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 16));
      goto LABEL_156;
    }
    uint64_t v115 = v114[3];
    os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 16));
    if (!v115 || !*(unsigned char *)(v115 + 8)) {
      goto LABEL_156;
    }
    uint64_t v503 = v78;
    *(void *)(v81 + 72) = 0;
    *(void *)(v81 + 80) = 0;
    *(void *)(v81 + 88) = 0;
    os_unfair_lock_lock((os_unfair_lock_t)(v115 + 12));
    unint64_t v75 = 0xCCCCCCCCCCCCCCCDLL;
    std::vector<re::ProfilerFlameChartBlock>::reserve(&STACK[0xA38], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v115 + 48) - *(void *)(v115 + 40)) >> 6));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>,0>(*(char **)(v115 + 40), *(char **)(v115 + 48), (uint64_t)&STACK[0xA38]);
    os_unfair_lock_unlock((os_unfair_lock_t)(v115 + 12));
    uint64_t v117 = *(void *)(v81 + 72);
    unint64_t v116 = *(void *)(v81 + 80);
    uint64_t v118 = v116 - v117;
    if (v116 == v117) {
      goto LABEL_154;
    }
    uint64_t v119 = re::RenderGraphContext::rtResolution((re::RenderGraphContext *)v77);
    unint64_t v121 = v119;
    unint64_t v122 = HIDWORD(v119);
    if ((int)v119 >= 0) {
      uint64_t v123 = v119;
    }
    else {
      uint64_t v123 = (v119 + 1);
    }
    if (v119 >= 0) {
      unint64_t v124 = HIDWORD(v119);
    }
    else {
      unint64_t v124 = (HIDWORD(v119) + 1);
    }
    unint64_t v125 = *(re::DrawingManager **)(*(void *)(v77 + 8) + 104);
    if (v125) {
      float LayerContentsScale = re::DrawingManager::getLayerContentsScale(v125, 0, v120);
    }
    else {
      float LayerContentsScale = 0.0;
    }
    float v127 = (float)(int)v121;
    float v128 = (float)(int)v122;
    if ((int)v121 >= (int)v122)
    {
      _NF = (float)(v128 / v127) < 0.65;
      float v130 = 2.0;
      if ((float)(v128 / v127) < 0.65) {
        float v130 = 3.0;
      }
      float v131 = 10.0;
      float v132 = 5.0;
    }
    else
    {
      _NF = (float)(v127 / v128) < 0.65;
      float v130 = 2.0;
      if ((float)(v127 / v128) < 0.65) {
        float v130 = 3.0;
      }
      float v131 = 16.0;
      float v132 = 12.0;
    }
    if (_NF) {
      float v131 = v132;
    }
    if (LayerContentsScale == 1.0) {
      float v133 = v130;
    }
    else {
      float v133 = LayerContentsScale;
    }
    *(float *)(v503 + 336) = v131;
    uint64_t v134 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
    if (v134)
    {
      BOOL v501 = *(unsigned char *)(v134 + 65) != 0;
      if (*(unsigned char *)(v134 + 65)) {
        char v135 = 2;
      }
      else {
        char v135 = 1;
      }
    }
    else
    {
      BOOL v501 = 0;
      char v135 = 1;
    }
    unsigned __int8 v468 = v135;
    LOBYTE(a73) = v135;
    *(void *)(v81 + 272) = 0;
    *(void *)(v81 + 248) = 0;
    *(void *)(v81 + 256) = 0;
    *(void *)(v81 + 240) = 0;
    LODWORD(STACK[0xAF8]) = 0;
    unint64_t v79 = 2;
    re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&STACK[0xAE0], 2uLL);
    if (!*(void *)(v81 + 256)) {
      goto LABEL_456;
    }
    uint64_t v136 = *(_OWORD **)(v81 + 272);
    *uint64_t v136 = xmmword_23435FD50;
    v136[1] = xmmword_23435FD60;
    _OWORD v136[2] = xmmword_23435FD80;
    v136[3] = xmmword_23435FBB0;
    unint64_t v79 = *(void *)(v81 + 256);
    if (v79 <= 1) {
      goto LABEL_457;
    }
    unint64_t v137 = *(_OWORD **)(v81 + 272);
    v137[4] = xmmword_23435FD50;
    v137[5] = xmmword_23435FD60;
    v137[6] = xmmword_23435FD80;
    unsigned char v137[7] = xmmword_23435FBB0;
    *(void *)(v81 + 32) = 0;
    *(void *)(v81 + 16) = 0;
    a83 = 0uLL;
    LODWORD(STACK[0xA08]) = 0;
    unint64_t v79 = 2;
    re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&a83, 2uLL);
    long long v138 = 0uLL;
    if (!*(void *)(v81 + 16)) {
      goto LABEL_458;
    }
    DWORD1(v139) = 0;
    *((void *)&v139 + 1) = 0;
    *((float *)&v138 + 1) = 2.0 / v128;
    uint64_t v140 = *(_OWORD **)(v81 + 32);
    *uint64_t v140 = COERCE_UNSIGNED_INT(2.0 / v127);
    v140[1] = v138;
    void v140[2] = xmmword_2343E6830;
    v140[3] = xmmword_2343E1EE0;
    unint64_t v79 = *(void *)(v81 + 16);
    if (v79 <= 1) {
      goto LABEL_459;
    }
    unint64_t v141 = 0xCCCCCCCCCCCCCCCDLL * (v118 >> 6);
    unint64_t v142 = *(_OWORD **)(v81 + 32);
    *(float *)&long long v139 = 2.0 / v127;
    v142[4] = v139;
    v142[5] = v138;
    v142[6] = xmmword_2343E6830;
    v142[7] = xmmword_2343E1EE0;
    uint64_t v143 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v77 + 8) + 104));
    re::RenderGraphContext::acquireManagedRenderEncoder(&a74, v77, v143, 0);
    float v500 = (re::DynamicString *)re::RenderGraphDataStore::tryGet<re::StencilInfoData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
    a77 = 0;
    std::string __p = 0;
    a78 = 0;
    if (v141 >> 57) {
      abort();
    }
    uint64_t v144 = (SHIDWORD(v121) / 18);
    uint64_t v473 = 6 * v141 + 12;
    unsigned int v493 = v144 - ((int)v124 >> 1);
    unint64_t v81 = (100 - ((int)v123 >> 1));
    unint64_t v79 = (v121 - 200);
    int v498 = -((int)v124 >> 1);
    STACK[0xB80] = (unint64_t)&a78;
    unint64_t v121 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<re::RenderText>>(v141);
    STACK[0xB60] = v121;
    STACK[0xB68] = v121;
    STACK[0xB78] = v121 + (v145 << 7);
    unint64_t v146 = v121 + (v141 << 7);
    uint64_t v123 = 0x3F8000003F800000;
    unint64_t v124 = -1;
    do
    {
      *(_OWORD *)(v121 + 96) = 0u;
      *(_OWORD *)(v121 + 112) = 0u;
      *(_OWORD *)(v121 + 64) = 0u;
      *(_OWORD *)(v121 + 80) = 0u;
      *(_OWORD *)(v121 + 32) = 0u;
      *(_OWORD *)(v121 + 48) = 0u;
      *(_OWORD *)unint64_t v121 = 0u;
      *(_OWORD *)(v121 + 16) = 0u;
      re::StringID::invalid((re::StringID *)v121);
      *(void *)(v121 + 16) = 0x3F8000003F800000;
      *(void *)(v121 + 24) = 0x3F8000003F800000;
      *(_OWORD *)(v121 + 32) = 0u;
      *(_OWORD *)(v121 + 48) = 0u;
      *(_OWORD *)(v121 + 64) = 0u;
      *(_OWORD *)(v121 + 80) = 0u;
      *(_OWORD *)(v121 + 96) = 0u;
      *(void *)(v121 + 112) = -1;
      v121 += 128;
    }
    while (v121 != v146);
    STACK[0xB70] = v146;
    std::vector<re::RenderText>::__swap_out_circular_buffer((uint64_t *)&__p, &STACK[0xB60]);
    std::__split_buffer<re::RenderText>::~__split_buffer((uint64_t)&STACK[0xB60]);
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 32 * v473, 0x10uLL, (uint64_t)&STACK[0xB60]);
    unint64_t v150 = LODWORD(STACK[0xB6C]);
    unint64_t v75 = v150 >> 5;
    if (v150 <= 0x1F) {
      goto LABEL_460;
    }
    uint64_t v151 = LODWORD(STACK[0xB68]);
    unint64_t v152 = STACK[0xB70];
    *(float *)&long long v148 = (float)((int)v81 + (int)v79);
    long long v153 = (const float *)&dword_234366B94;
    float32x4_t v154 = vld1q_dup_f32(v153);
    float32x4_t v155 = v154;
    v155.i32[3] = *(_DWORD *)(v503 + 340);
    unint64_t v121 = STACK[0xB60] + v151;
    if ((v122 & 0x80000000) == 0) {
      int v156 = v122;
    }
    else {
      int v156 = v122 + 1;
    }
    *(void *)&long long v157 = v148;
    DWORD2(v157) = 0;
    HIDWORD(v157) = 1.0;
    long long v158 = v157;
    *((float *)&v158 + 1) = (float)(v156 >> 1);
    *(_OWORD *)unint64_t v121 = v158;
    *(float32x4_t *)(v121 + 16) = v155;
    if (v150 <= 0x3F) {
      goto LABEL_461;
    }
    *(float *)&uint64_t v149 = (float)(int)v81;
    v154.i32[3] = *(_DWORD *)(v503 + 340);
    *(void *)&long long v159 = v149;
    DWORD2(v159) = 0;
    HIDWORD(v159) = 1.0;
    long long v160 = v159;
    *((float *)&v160 + 1) = (float)(v156 >> 1);
    *(_OWORD *)(v121 + 32) = v160;
    *(float32x4_t *)(v121 + 48) = v154;
    if (v150 <= 0x5F) {
      goto LABEL_462;
    }
    *(void *)&long long v161 = v149;
    DWORD2(v161) = 0;
    HIDWORD(v161) = 1.0;
    *(void *)&long long v162 = 0;
    DWORD2(v162) = 0;
    HIDWORD(v162) = *(_DWORD *)(v503 + 344);
    *(void *)&long long v163 = 0;
    DWORD2(v163) = 0;
    *(_OWORD *)(v121 + 64) = v161;
    *(_OWORD *)(v121 + 80) = v162;
    if (v150 <= 0x7F) {
      goto LABEL_463;
    }
    DWORD1(v148) = 0;
    DWORD2(v148) = 0;
    HIDWORD(v148) = 1.0;
    HIDWORD(v163) = *(_DWORD *)(v503 + 344);
    *(_OWORD *)(v121 + 96) = v148;
    *(_OWORD *)(v121 + 112) = v163;
    if (v150 <= 0x9F) {
      goto LABEL_464;
    }
    long long v164 = *(_OWORD *)(v121 + 16);
    *(_OWORD *)(v121 + 128) = *(_OWORD *)v121;
    *(_OWORD *)(v121 + 144) = v164;
    if (v150 <= 0xBF) {
      goto LABEL_465;
    }
    long long v165 = *(_OWORD *)(v121 + 80);
    *(_OWORD *)(v121 + 160) = *(_OWORD *)(v121 + 64);
    *(_OWORD *)(v121 + 176) = v165;
    if (v150 <= 0xDF) {
      goto LABEL_467;
    }
    *(_OWORD *)(v121 + 192) = v148;
    *(_OWORD *)(v121 + 208) = xmmword_23440EB00;
    if (v150 <= 0xFF) {
      goto LABEL_469;
    }
    *(_OWORD *)(v121 + 224) = v161;
    *(_OWORD *)(v121 + 240) = xmmword_23440EB00;
    if (v150 <= 0x11F) {
      goto LABEL_471;
    }
    *((float *)&v159 + 1) = (float)v498;
    *(_OWORD *)(v121 + 256) = v159;
    *(_OWORD *)(v121 + 272) = xmmword_23435FBB0;
    if (v150 <= 0x13F) {
      goto LABEL_473;
    }
    *((float *)&v157 + 1) = (float)v498;
    *(_OWORD *)(v121 + 288) = v157;
    *(_OWORD *)(v121 + 304) = xmmword_23435FBB0;
    if (v150 <= 0x15F) {
      goto LABEL_475;
    }
    unint64_t v462 = v152;
    uint64_t v464 = v151;
    float v466 = (float)(int)v81;
    long long v166 = *(_OWORD *)(v121 + 208);
    *(_OWORD *)(v121 + 320) = *(_OWORD *)(v121 + 192);
    *(_OWORD *)(v121 + 336) = v166;
    if (v150 <= 0x17F) {
      goto LABEL_477;
    }
    long long v167 = *(_OWORD *)(v121 + 272);
    *(_OWORD *)(v121 + 352) = *(_OWORD *)(v121 + 256);
    *(_OWORD *)(v121 + 368) = v167;
    ((void (*)(void, char *, id))a75[19])(*a75, sel_pushDebugGroup_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "FlameChart", 4));
    unint64_t v170 = STACK[0xA38];
    unint64_t v169 = STACK[0xA40];
    __asm { FMOV            V0.4S, #1.0 }
    long long v495 = _Q0;
    uint64_t v175 = v493;
    if (STACK[0xA38] == STACK[0xA40]) {
      break;
    }
    uint64_t v83 = 0;
    double v176 = (double)(int)v81;
    double v177 = (double)(int)v79;
    float v178 = (float)(int)v144;
    float v179 = (float)(int)v79 / v133;
    unint64_t v79 = 12;
    uint64_t v76 = 16;
    float v180 = 1.0;
    id v483 = (id)STACK[0xA40];
    while (1)
    {
      uint64_t v181 = v83;
      uint64_t v182 = *(void *)(v170 + 136);
      uint64_t v83 = v144;
      if (v182)
      {
        uint64_t v83 = v175;
        if (v182 != 1) {
          uint64_t v83 = v181;
        }
      }
      if (v79 >= v75) {
        break;
      }
      long long v183 = *(_OWORD *)(v170 + 164);
      *(float *)&long long v184 = v176 + v177 * *(double *)(v170 + 152);
      *((float *)&v184 + 1) = (float)(int)(v144 + v144 * *(unsigned __int16 *)(v170 + 160) + v83);
      DWORD2(v184) = 0;
      *((float *)&v184 + 3) = v180;
      *(_OWORD *)(v121 + 384) = v184;
      *(_OWORD *)(v121 + 400) = v183;
      unint64_t v185 = v79 + 1;
      if (v79 + 1 >= v75) {
        goto LABEL_446;
      }
      *(float *)&long long v186 = v176 + v177 * *(double *)(v170 + 144);
      *((float *)&v186 + 1) = (float)(int)(v144 + v144 * *(unsigned __int16 *)(v170 + 160) + v83);
      DWORD2(v186) = 0;
      *((float *)&v186 + 3) = v180;
      *(_OWORD *)(v121 + 416) = v186;
      *(_OWORD *)(v121 + 432) = v183;
      unint64_t v187 = v79 + 2;
      if (v79 + 2 >= v75) {
        goto LABEL_447;
      }
      *(float *)&long long v188 = v176 + v177 * *(double *)(v170 + 144);
      *((float *)&v188 + 1) = (float)(int)(v83 + v144 * *(unsigned __int16 *)(v170 + 160));
      DWORD2(v188) = 0;
      *((float *)&v188 + 3) = v180;
      *(_OWORD *)(v121 + 448) = v188;
      *(_OWORD *)(v121 + 464) = v183;
      unint64_t v189 = v79 + 3;
      if (v79 + 3 >= v75) {
        goto LABEL_448;
      }
      *(float *)&long long v190 = v176 + v177 * *(double *)(v170 + 152);
      *((float *)&v190 + 1) = (float)(int)(v83 + v144 * *(unsigned __int16 *)(v170 + 160));
      DWORD2(v190) = 0;
      *((float *)&v190 + 3) = v180;
      *(_OWORD *)(v121 + 480) = v190;
      *(_OWORD *)(v121 + 496) = v183;
      unint64_t v191 = v79 + 4;
      if (v79 + 4 >= v75) {
        goto LABEL_449;
      }
      long long v192 = *(_OWORD *)(v121 + 400);
      *(_OWORD *)(v121 + 512) = *(_OWORD *)(v121 + 384);
      *(_OWORD *)(v121 + 528) = v192;
      if (v79 + 5 >= v75) {
        goto LABEL_450;
      }
      long long v193 = *(_OWORD *)(v121 + 464);
      *(_OWORD *)(v121 + 544) = *(_OWORD *)(v121 + 448);
      *(_OWORD *)(v121 + 560) = v193;
      if (*(unsigned __int16 *)(v170 + 160) <= 8u && *(double *)(v170 + 152) - *(double *)(v170 + 144) > 0.00999999978)
      {
        unint64_t v81 = v144;
        re::StringID::invalid((re::StringID *)&STACK[0xB60]);
        *(_OWORD *)&STACK[0xBA0] = 0u;
        *(_OWORD *)&STACK[0xBB0] = 0u;
        *(_OWORD *)&STACK[0xB80] = 0u;
        *(_OWORD *)&STACK[0xB90] = 0u;
        STACK[0xBD0] = -1;
        *(_OWORD *)&STACK[0xB70] = *(_OWORD *)(v503 + 304);
        STACK[0xBC0] = v170;
        STACK[0xBC8] = strlen((const char *)v170);
        re::StringID::operator=(&STACK[0xB60], (uint64_t *)(*(void *)(v77 + 8) + 8));
        STACK[0xBD0] = -1;
        uint64_t v194 = v503;
        v195.i32[0] = *(_DWORD *)(v503 + 320);
        double v196 = *(double *)(v170 + 144);
        float v197 = *(double *)(v170 + 152) - v196;
        float v198 = *(float *)(v503 + 332);
        if (v198 >= v197)
        {
          float v200 = *(float *)(v503 + 324);
        }
        else
        {
          float v199 = *(float *)(v503 + 328);
          float v200 = *(float *)(v503 + 324);
          if (v199 <= v197)
          {
            v195.i32[0] = *(_DWORD *)(v503 + 324);
          }
          else
          {
            float v198 = (float)(v197 - v198) / (float)(v199 - v198);
            *(float *)v195.i32 = *(float *)v195.i32 + (float)((float)(v200 - *(float *)v195.i32) * v198);
          }
          uint64_t v194 = v503;
        }
        LOWORD(v198) = *(_WORD *)(v170 + 160);
        float v201 = (float)(v179 * v197) / (float)((float)(*(float *)v195.i32 * *(float *)(v194 + 336)) / v200);
        if (v201 < (float)STACK[0xBC8]) {
          STACK[0xBC8] = (unint64_t)v201;
        }
        *(float *)&unsigned int v202 = v176 + v177 * v196;
        *(float *)v195.i32 = (float)(*(float *)v195.i32 * v178) * *(float *)(v503 + 372);
        *((void *)&v203 + 1) = *((void *)&v495 + 1);
        *(void *)&long long v203 = __PAIR64__((float)(int)v83 + (float)(v178 * (float)((float)LODWORD(v198) + 0.75)), v202);
        *(float32x4_t *)&STACK[0xB80] = vmulq_n_f32((float32x4_t)xmmword_23435FD50, *(float *)v195.i32);
        *(float32x4_t *)&STACK[0xB90] = vmulq_n_f32((float32x4_t)xmmword_23435FD60, *(float *)vshrq_n_u64((uint64x2_t)vdupq_lane_s32(v195, 0), 0x20uLL).i32);
        *(_OWORD *)&STACK[0xBA0] = xmmword_23435FD80;
        *(_OWORD *)&STACK[0xBB0] = v203;
        long long v204 = (char *)__p + v76;
        re::StringID::operator=((unint64_t *)((char *)__p + v76 - 16), (uint64_t *)&STACK[0xB60]);
        long long v205 = *(_OWORD *)&STACK[0xB70];
        long long v206 = *(_OWORD *)&STACK[0xB90];
        *((_OWORD *)v204 + 1) = *(_OWORD *)&STACK[0xB80];
        *((_OWORD *)v204 + 2) = v206;
        *(_OWORD *)long long v204 = v205;
        long long v207 = *(_OWORD *)&STACK[0xBA0];
        long long v208 = *(_OWORD *)&STACK[0xBB0];
        long long v209 = *(_OWORD *)&STACK[0xBC0];
        *((void *)v204 + 12) = STACK[0xBD0];
        *((_OWORD *)v204 + 4) = v208;
        *((_OWORD *)v204 + 5) = v209;
        *((_OWORD *)v204 + 3) = v207;
        uint64_t v80 = (uint64_t)&STACK[0xAE0];
        re::StringID::destroyString((re::StringID *)&STACK[0xB60]);
        uint64_t v175 = v493;
        unint64_t v169 = (unint64_t)v483;
        float v180 = 1.0;
      }
      v170 += 320;
      v121 += 192;
      v76 += 128;
      v79 += 6;
      if (v170 == v169) {
        goto LABEL_128;
      }
    }
LABEL_445:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v79, v75);
    _os_crash();
    __break(1u);
LABEL_446:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v185, v75);
    _os_crash();
    __break(1u);
LABEL_447:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v187, v75);
    _os_crash();
    __break(1u);
LABEL_448:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v189, v75);
    _os_crash();
    __break(1u);
LABEL_449:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, v191, v75);
    _os_crash();
    __break(1u);
LABEL_450:
    re::internal::assertLog((re::internal *)6, v168, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()");
    _os_crash();
    __break(1u);
LABEL_451:
    uint64_t v105 = re::DrawCallRecorder::allocateDrawCallRecorderGroup((re::DrawCallRecorder *)(v77 + 1336), *(const char **)(v76 + 16), (const char *)v83);
  }
LABEL_128:
  uint64_t v210 = *(re::RenderManager **)(v77 + 8);
  uint64_t v211 = *((void *)v210 + 13);
  if (v211) {
    unint64_t v121 = *(void *)(v211 + 304);
  }
  else {
    unint64_t v121 = 0;
  }
  unint64_t v81 = (unint64_t)&a83;
  unint64_t v124 = (unint64_t)&STACK[0xD60];
  re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xB60]);
  id v212 = *(id *)re::DebugRenderer::pipelineStateWithAlphaBlending((re::DebugRenderer *)v121, v210, (RenderTargetInfo *)&STACK[0xB60]);
  ((void (*)(void, char *, id))a75[7])(*a75, sel_setRenderPipelineState_, v212);
  unint64_t v213 = STACK[0xA00];
  if (!STACK[0xA00]) {
    goto LABEL_484;
  }
  id v499 = v212;
  long long v214 = (_OWORD *)STACK[0xA10];
  *(_OWORD *)&STACK[0xB60] = *(_OWORD *)STACK[0xA10];
  *(_OWORD *)&STACK[0xB70] = v214[1];
  *(_OWORD *)&STACK[0xB80] = v214[2];
  *(_OWORD *)&STACK[0xB90] = v214[3];
  if (v213 == 1)
  {
LABEL_485:
    *(void *)(v80 + 80) = 0;
    *(_OWORD *)(v124 + 48) = 0u;
    *(_OWORD *)(v124 + 64) = 0u;
    *(_OWORD *)(v124 + 16) = 0u;
    *(_OWORD *)(v124 + 32) = 0u;
    *(_OWORD *)unint64_t v124 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xA70]) = 136315906;
    *(void *)(v81 + 132) = "operator[]";
    LOWORD(STACK[0xA7C]) = 1024;
    *(_DWORD *)(v81 + 142) = 789;
    LOWORD(STACK[0xA82]) = 2048;
    *(void *)(v81 + 148) = 1;
    LOWORD(STACK[0xA8C]) = 2048;
    *(void *)(v81 + 158) = 1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_486;
  }
  *(_OWORD *)&STACK[0xBA0] = v214[4];
  *(_OWORD *)&STACK[0xBB0] = v214[5];
  *(_OWORD *)&STACK[0xBC0] = v214[6];
  *(_OWORD *)&STACK[0xBD0] = v214[7];
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x100uLL, 0x100uLL, (uint64_t)&STACK[0xD60]);
  uint64_t v215 = LODWORD(STACK[0xD68]);
  id v484 = (id)STACK[0xD70];
  uint64_t v216 = STACK[0xD60] + v215;
  *(_OWORD *)(v216 + 64) = *(_OWORD *)&STACK[0xBA0];
  *(_OWORD *)(v216 + 80) = *(_OWORD *)&STACK[0xBB0];
  *(_OWORD *)(v216 + 96) = *(_OWORD *)&STACK[0xBC0];
  *(_OWORD *)(v216 + 112) = *(_OWORD *)&STACK[0xBD0];
  *(_OWORD *)uint64_t v216 = *(_OWORD *)&STACK[0xB60];
  *(_OWORD *)(v216 + 16) = *(_OWORD *)&STACK[0xB70];
  *(_OWORD *)(v216 + 32) = *(_OWORD *)&STACK[0xB80];
  *(_OWORD *)(v216 + 48) = *(_OWORD *)&STACK[0xB90];
  *(_DWORD *)(v216 + 128) = 1065353216;
  *(_OWORD *)(v216 + 240) = 0u;
  *(_OWORD *)(v216 + 228) = 0u;
  *(_OWORD *)(v216 + 212) = 0u;
  *(_OWORD *)(v216 + 196) = 0u;
  *(_OWORD *)(v216 + 180) = 0u;
  *(_OWORD *)(v216 + 164) = 0u;
  *(_OWORD *)(v216 + 148) = 0u;
  *(_OWORD *)(v216 + 132) = 0u;
  *(_OWORD *)&STACK[0xD80] = 0u;
  *(_OWORD *)&STACK[0xD90] = 0u;
  *(_OWORD *)&STACK[0xD70] = 0u;
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x80uLL, 0x80uLL, (uint64_t)&STACK[0xA70]);
  uint64_t v217 = LODWORD(STACK[0xA78]);
  unint64_t v479 = STACK[0xA80];
  uint64_t v218 = STACK[0xA70] + v217;
  *(_DWORD *)(v218 + 16) = 0;
  *(_DWORD *)(v218 + 28) = 1;
  *(_OWORD *)(v218 + 32) = *(_OWORD *)&STACK[0xD60];
  *(_OWORD *)(v218 + 48) = *(_OWORD *)&STACK[0xD70];
  *(_OWORD *)(v218 + 64) = *(_OWORD *)&STACK[0xD80];
  *(_OWORD *)(v218 + 80) = *(_OWORD *)&STACK[0xD90];
  *(_OWORD *)&STACK[0xA80] = 0u;
  *(_OWORD *)&STACK[0xA90] = 0u;
  re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x400uLL, 0x100uLL, (uint64_t)&STACK[0xB30]);
  uint64_t v219 = LODWORD(STACK[0xB38]);
  unint64_t v220 = STACK[0xB40];
  uint64_t v221 = STACK[0xB30] + v219;
  *(_OWORD *)uint64_t v221 = xmmword_23435FD50;
  *(_OWORD *)(v221 + 16) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 32) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 48) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 64) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 80) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 96) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 112) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 128) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 144) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 160) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 176) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 192) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 208) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 224) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 240) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 256) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 272) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 288) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 304) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 320) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 336) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 352) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 368) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 384) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 400) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 416) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 432) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 448) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 464) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 480) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 496) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 512) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 528) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 544) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 560) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 576) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 592) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 608) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 624) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 640) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 656) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 672) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 688) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 704) = xmmword_23435FD50;
  *(_OWORD *)(v221 + 720) = xmmword_23435FD60;
  *(_OWORD *)(v221 + 736) = xmmword_23435FD80;
  *(_OWORD *)(v221 + 752) = xmmword_23435FBB0;
  *(_OWORD *)(v221 + 880) = 0u;
  *(_OWORD *)(v221 + 896) = 0u;
  *(_OWORD *)(v221 + 848) = 0u;
  *(_OWORD *)(v221 + 864) = 0u;
  *(_OWORD *)(v221 + 816) = 0u;
  *(_OWORD *)(v221 + 832) = 0u;
  *(_OWORD *)(v221 + 784) = 0u;
  *(_OWORD *)(v221 + 800) = 0u;
  *(_OWORD *)(v221 + 768) = 0u;
  *(_DWORD *)(v221 + 940) = v468;
  *(_DWORD *)(v221 + 944) = v501;
  *(_OWORD *)(v221 + 960) = 0u;
  *(_OWORD *)(v221 + 976) = *(_OWORD *)&STACK[0xA70];
  *(_OWORD *)(v221 + 992) = *(_OWORD *)&STACK[0xA80];
  *(_OWORD *)(v221 + 1008) = *(_OWORD *)&STACK[0xA90];
  ((void (*)(void, char *, unint64_t, uint64_t, void))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v462, v464, 0);
  ((void (*)(void, char *, id, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v484, v215, 1);
  ((void (*)(void, char *, unint64_t, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v479, v217, 2);
  ((void (*)(void, char *, unint64_t, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v220, v219, 3);
  ((void (*)(void, char *, uint64_t, void, uint64_t))a75[25])(*a75, sel_drawPrimitives_vertexStart_vertexCount_, 3, 0, v473);
  ((void (*)(void, char *))a75[20])(*a75, sel_popDebugGroup);
  if (v499) {

  }
  float v223 = *(float *)(v503 + 372);
  *(float *)&uint64_t v222 = (float)((float)(int)v144 * 0.75) * v223;
  id v485 = v222;
  float v224 = (float)((float)(int)v144 * 0.25) * v223;
  STACK[0xB30] = *(void *)"Simulation";
  LODWORD(STACK[0xB37]) = 7237481;
  re::StringID::invalid((re::StringID *)&STACK[0xB60]);
  *(_OWORD *)&STACK[0xBA0] = 0u;
  *(_OWORD *)&STACK[0xBB0] = 0u;
  *(_OWORD *)&STACK[0xB80] = 0u;
  *(_OWORD *)&STACK[0xB90] = 0u;
  *(_OWORD *)&STACK[0xB70] = *(_OWORD *)(v503 + 304);
  STACK[0xBC0] = (unint64_t)&STACK[0xB30];
  STACK[0xBC8] = 11;
  STACK[0xBD0] = -1;
  re::StringID::operator=(&STACK[0xB60], (uint64_t *)(*(void *)(v77 + 8) + 8));
  STACK[0xBD0] = -1;
  uint64x2_t v225 = (uint64x2_t)vdupq_lane_s32((int32x2_t)v485, 0);
  float32x4_t v486 = vmulq_n_f32((float32x4_t)xmmword_23435FD50, *(float *)&v485);
  float32x4_t v491 = vmulq_n_f32((float32x4_t)xmmword_23435FD60, *(float *)vshrq_n_u64(v225, 0x20uLL).i32);
  long long v226 = v495;
  *(float *)&long long v226 = v466;
  long long v496 = v226;
  long long v227 = v226;
  *((float *)&v227 + 1) = (float)(int)v144 - v224;
  *(float32x4_t *)&STACK[0xB80] = v486;
  *(float32x4_t *)&STACK[0xB90] = v491;
  *(_OWORD *)&STACK[0xBA0] = xmmword_23435FD80;
  *(_OWORD *)&STACK[0xBB0] = v227;
  std::vector<re::RenderText>::push_back[abi:nn180100]((uint64_t *)&__p, (StringID *)&STACK[0xB60]);
  strcpy((char *)&a69, "Render");
  *(_OWORD *)&STACK[0xB70] = *(_OWORD *)(v503 + 304);
  STACK[0xBC0] = (unint64_t)&a69;
  STACK[0xBC8] = 7;
  re::StringID::operator=(&STACK[0xB60], (uint64_t *)(*(void *)(v77 + 8) + 8));
  STACK[0xBD0] = -1;
  long long v228 = v496;
  *((float *)&v228 + 1) = (float)(int)v493 - v224;
  *(float32x4_t *)&STACK[0xB80] = v486;
  *(float32x4_t *)&STACK[0xB90] = v491;
  *(_OWORD *)&STACK[0xBA0] = xmmword_23435FD80;
  *(_OWORD *)&STACK[0xBB0] = v228;
  std::vector<re::RenderText>::push_back[abi:nn180100]((uint64_t *)&__p, (StringID *)&STACK[0xB60]);
  int v229 = (re::StringID *)__p;
  uint64_t v230 = a77;
  unint64_t v79 = (unint64_t)&STACK[0xD60];
  if (__p != a77)
  {
    do
    {
      if (*((void *)v229 + 13))
      {
        uint64_t v231 = *(re::TextManager **)(*(void *)(v77 + 8) + 72);
        re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xD60]);
        if (v500)
        {
          long long v232 = *(_OWORD *)((char *)v500 + 8);
          LOBYTE(STACK[0xA80]) = *((unsigned char *)v500 + 24);
          *(_OWORD *)&STACK[0xA70] = v232;
        }
        else
        {
          STACK[0xA70] = 0;
          STACK[0xA78] = 0;
          LOBYTE(STACK[0xA80]) = 0;
          LOWORD(STACK[0xA71]) = -1;
          LOBYTE(STACK[0xA73]) = 7;
          LOWORD(STACK[0xA79]) = -1;
          LOBYTE(STACK[0xA7B]) = 7;
        }
        *(void *)&long long v507 = &STACK[0xAE0];
        *((void *)&v507 + 1) = &a83;
        re::TextManager::render(v231, (unsigned int *)&STACK[0xD60], (uint64_t)&STACK[0xA70], (uint64_t)&a74, *(void *)v77, v507, &a73, (uint64_t)v229, v501, 0);
      }
      int v229 = (re::StringID *)((char *)v229 + 128);
    }
    while (v229 != v230);
  }
  re::StringID::destroyString((re::StringID *)&STACK[0xB60]);
  unint64_t v75 = (unint64_t)__p;
  if (__p)
  {
    uint64_t v233 = a77;
    uint64_t v234 = __p;
    if (a77 != __p)
    {
      do
      {
        uint64_t v233 = (re::StringID *)((char *)v233 - 128);
        re::StringID::destroyString(v233);
      }
      while (v233 != (re::StringID *)v75);
      uint64_t v234 = __p;
    }
    a77 = (re::StringID *)v75;
    operator delete(v234);
  }
  re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)&a74);
  if ((void)a83 && STACK[0xA10]) {
    (*(void (**)(void))(*(void *)a83 + 40))();
  }
  if (STACK[0xAE0] && STACK[0xB00]) {
    (*(void (**)(unint64_t))(*(void *)STACK[0xAE0] + 40))(STACK[0xAE0]);
  }
  unint64_t v116 = STACK[0xA38];
LABEL_154:
  uint64_t v78 = v503;
  if (v116)
  {
    *(void *)(v81 + 80) = v116;
    MEMORY[0x237DBCBC0]();
  }
LABEL_156:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA28]);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)23>::end((uint64_t)&STACK[0xA60]);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard((uint64_t *)&STACK[0xA60]);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA28], 5074, 0);
  uint64_t v235 = *(void *)(v77 + 8);
  uint64_t v236 = *(void *)(v235 + 104);
  if (v236)
  {
    uint64_t v237 = *(void *)(v236 + 1664);
    if (v237)
    {
      if (*(void *)(v235 + 8) >= 2uLL)
      {
        uint64_t v238 = (_anonymous_namespace_ *)re::ProfilerManager::getProcessor<re::ProfilerMiniHUDProcessor,void>(v237);
        if (v238)
        {
          unint64_t v75 = (unint64_t)v238;
          if (*((unsigned char *)v238 + 8))
          {
            STACK[0xBB0] = 0;
            *(_OWORD *)&STACK[0xB90] = 0u;
            *(_OWORD *)&STACK[0xBA0] = 0u;
            *(_OWORD *)&STACK[0xB70] = 0u;
            *(_OWORD *)&STACK[0xB80] = 0u;
            *(_OWORD *)&STACK[0xB60] = 0u;
            uint64_t v239 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xB98], 0);
            *(_OWORD *)&STACK[0xBC8] = 0u;
            *(_OWORD *)&STACK[0xBB8] = 0u;
            uint64_t v240 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBB8], 0);
            *(_OWORD *)&STACK[0xBE8] = 0u;
            *(_OWORD *)&STACK[0xBD8] = 0u;
            long long v241 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBD8], 0);
            *(_OWORD *)&STACK[0xC08] = 0u;
            *(_OWORD *)&STACK[0xBF8] = 0u;
            uint64_t v242 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBF8], 0);
            *(_OWORD *)&STACK[0xC28] = 0u;
            *(_OWORD *)&STACK[0xC18] = 0u;
            uint64_t v243 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xC18], 0);
            *(_OWORD *)&STACK[0xC48] = 0u;
            *(_OWORD *)&STACK[0xC38] = 0u;
            unint64_t v244 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xC38], 0);
            *(_OWORD *)&STACK[0xC68] = 0u;
            *(_OWORD *)&STACK[0xC58] = 0u;
            long long v245 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xC58], 0);
            uint64_t v123 = (uint64_t)&STACK[0xC78];
            *(_OWORD *)&STACK[0xC78] = 0u;
            *(_OWORD *)&STACK[0xC88] = 0u;
            uint64_t v246 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xC78], 0);
            *(_OWORD *)&STACK[0xC98] = 0u;
            *(_OWORD *)&STACK[0xCA8] = 0u;
            __n128 v247 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xC98], 0);
            uint64_t v80 = (uint64_t)&STACK[0xCB8];
            *(_OWORD *)&STACK[0xCB8] = 0u;
            *(_OWORD *)&STACK[0xCC8] = 0u;
            uint64_t v248 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xCB8], 0);
            *(_OWORD *)&STACK[0xCD8] = 0u;
            *(_OWORD *)&STACK[0xCE8] = 0u;
            re::DynamicString::setCapacity(&STACK[0xCD8], 0);
            os_unfair_lock_lock((os_unfair_lock_t)(v75 + 12));
            re::ProfilerMiniHudStatistics::copy((uint64_t)&STACK[0xB60], v75 + 424);
            os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 12));
            unint64_t v124 = re::RenderGraphContext::rtResolution((re::RenderGraphContext *)v77);
            uint64_t v249 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
            if (v249)
            {
              unsigned __int8 v250 = *(unsigned char *)(v249 + 65);
              if (v250) {
                char v251 = 2;
              }
              else {
                char v251 = 1;
              }
            }
            else
            {
              unsigned __int8 v250 = 0;
              char v251 = 1;
            }
            a82 = v250;
            a81 = v251;
            *(void *)(v81 + 104) = 0;
            *(void *)(v81 + 80) = 0;
            *(void *)(v81 + 88) = 0;
            *(void *)(v81 + 72) = 0;
            LODWORD(STACK[0xA50]) = 0;
            unint64_t v121 = 2;
            re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&STACK[0xA38], 2uLL);
            if (!*(void *)(v81 + 88))
            {
LABEL_466:
              *(void *)(v81 + 240) = 0;
              *(_OWORD *)(v79 + 48) = 0u;
              *(_OWORD *)(v79 + 64) = 0u;
              *(_OWORD *)(v79 + 16) = 0u;
              *(_OWORD *)(v79 + 32) = 0u;
              *(_OWORD *)unint64_t v79 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 0;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_467:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 6, v75);
              _os_crash();
              __break(1u);
LABEL_468:
              *(void *)(v81 + 240) = 0;
              *(_OWORD *)(v79 + 48) = 0u;
              *(_OWORD *)(v79 + 64) = 0u;
              *(_OWORD *)(v79 + 16) = 0u;
              *(_OWORD *)(v79 + 32) = 0u;
              *(_OWORD *)unint64_t v79 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 1;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = v121;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_469:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 7, v75);
              _os_crash();
              __break(1u);
              goto LABEL_470;
            }
            uint64_t v252 = *(_OWORD **)(v81 + 104);
            *uint64_t v252 = xmmword_23435FD50;
            v252[1] = xmmword_23435FD60;
            v252[2] = xmmword_23435FD80;
            v252[3] = xmmword_23435FBB0;
            unint64_t v121 = *(void *)(v81 + 88);
            if (v121 <= 1) {
              goto LABEL_468;
            }
            long long v253 = *(_OWORD **)(v81 + 104);
            v253[4] = xmmword_23435FD50;
            v253[5] = xmmword_23435FD60;
            v253[6] = xmmword_23435FD80;
            v253[7] = xmmword_23435FBB0;
            a80 = 0;
            a78 = 0;
            std::string __p = 0;
            a77 = 0;
            a79 = 0;
            unint64_t v121 = 2;
            re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&__p, 2uLL);
            long long v254 = 0uLL;
            if (!a78)
            {
LABEL_470:
              *(void *)(v81 + 240) = 0;
              *(_OWORD *)(v79 + 48) = v254;
              *(_OWORD *)(v79 + 64) = v254;
              *(_OWORD *)(v79 + 16) = v254;
              *(_OWORD *)(v79 + 32) = v254;
              *(_OWORD *)unint64_t v79 = v254;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 0;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_471:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 8, v75);
              _os_crash();
              __break(1u);
LABEL_472:
              *(void *)(v81 + 240) = 0;
              *(_OWORD *)&STACK[0xD90] = 0u;
              *(_OWORD *)&STACK[0xDA0] = 0u;
              *(_OWORD *)&STACK[0xD70] = 0u;
              *(_OWORD *)&STACK[0xD80] = 0u;
              *(_OWORD *)&STACK[0xD60] = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 1;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = v121;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_473:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 9, v75);
              _os_crash();
              __break(1u);
              goto LABEL_474;
            }
            uint64_t v504 = v78;
            uint64_t v123 = HIDWORD(v124);
            DWORD1(v255) = 0;
            *((void *)&v255 + 1) = 0;
            *(float *)&long long v255 = 2.0 / (float)(int)v124;
            *((float *)&v254 + 1) = 2.0 / (float)SHIDWORD(v124);
            long long v256 = a80;
            *a80 = v255;
            v256[1] = v254;
            v256[2] = xmmword_2343E6830;
            v256[3] = xmmword_2343E1EE0;
            unint64_t v121 = a78;
            if (a78 <= 1) {
              goto LABEL_472;
            }
            long long v257 = a80;
            a80[4] = v255;
            v257[5] = v254;
            v257[6] = xmmword_2343E6830;
            v257[7] = xmmword_2343E1EE0;
            uint64_t v258 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v77 + 8) + 104));
            re::RenderGraphContext::acquireManagedRenderEncoder(&a74, v77, v258, 0);
            a73 = re::RenderGraphDataStore::tryGet<re::StencilInfoData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
            float v259 = (float)(SHIDWORD(v124) / 4);
            LODWORD(STACK[0xA24]) = 1107296256;
            if ((v124 & 0x80000000) == 0) {
              int v260 = v124;
            }
            else {
              int v260 = v124 + 3;
            }
            float v261 = *(float *)&STACK[0xB6C];
            if (*(float *)&STACK[0xB70] <= 0.0) {
              float v262 = -0.0;
            }
            else {
              float v262 = *(float *)&STACK[0xB6C];
            }
            if (*(float *)&STACK[0xB70] > 0.0) {
              float v261 = *(float *)&STACK[0xB70];
            }
            float v487 = v261;
            float v263 = *(float *)&STACK[0xB74];
            float v264 = *(float *)&STACK[0xB68];
            float v265 = 1.0 / (float)((float)(1000.0 / *(float *)&STACK[0xB60]) / 16.667);
            unint64_t v266 = STACK[0xB78];
            uint64_t v80 = (uint64_t)&STACK[0xB60];
            unint64_t v121 = STACK[0xB90];
            float v267 = 0.0;
            if (v265 <= 1.0) {
              float v267 = 1.0 - v265;
            }
            float v268 = v267 + (float)(*(float *)(v504 + 400) * (float)(1.0 - v267));
            unint64_t v79 = (unint64_t)&_MergedGlobals_452;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF9B7B8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_26AF9B7B8))
            {
              _MergedGlobals_452 = *(_DWORD *)(v504 + 400);
              __cxa_guard_release(&qword_26AF9B7B8);
            }
            *(float *)&_MergedGlobals_452 = (float)(v268 * 0.1) + (float)(*(float *)&_MergedGlobals_452 * 0.9);
            *(float *)&STACK[0xA20] = v259 / 5.0;
            a72 = 1090519040;
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x480uLL, 0x10uLL, (uint64_t)&STACK[0xD60]);
            uint64_t v272 = LODWORD(STACK[0xD68]);
            unint64_t v273 = LODWORD(STACK[0xD6C]);
            unint64_t v274 = STACK[0xD70];
            char v275 = (_OWORD *)(STACK[0xD60] + v272);
            unint64_t v276 = v273 >> 5;
            a69 = v275;
            a70 = v273 >> 5;
            if ((v124 & 0x80000000) == 0) {
              int v277 = v124;
            }
            else {
              int v277 = v124 + 1;
            }
            *(float *)&long long v270 = (float)-(v277 >> 1) + 10.0;
            a68 = *(float *)&v270;
            if ((v124 & 0x8000000000000000) == 0) {
              int v278 = HIDWORD(v124);
            }
            else {
              int v278 = HIDWORD(v124) + 1;
            }
            float v279 = (float)-(v278 >> 1) + 10.0;
            float v280 = v279 + v259;
            a67 = v279 + v259;
            if (v273 <= 0x1F)
            {
LABEL_474:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, 0);
              _os_crash();
              __break(1u);
LABEL_475:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 10, v75);
              _os_crash();
              __break(1u);
LABEL_476:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v276);
              _os_crash();
              __break(1u);
LABEL_477:
              re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 11, v75);
              _os_crash();
              __break(1u);
              goto LABEL_478;
            }
            float v281 = (float)(v260 >> 2);
            *(void *)&long long v282 = 0;
            DWORD2(v282) = 0;
            HIDWORD(v282) = _MergedGlobals_452;
            *(float *)&long long v271 = *(float *)&v270 + v281;
            DWORD2(v271) = 0;
            HIDWORD(v271) = 1.0;
            long long v283 = v271;
            *((float *)&v283 + 1) = v280;
            *char v275 = v283;
            v275[1] = v282;
            if (v273 <= 0x3F) {
              goto LABEL_476;
            }
            DWORD2(v270) = 0;
            HIDWORD(v270) = 1.0;
            long long v284 = v270;
            *((float *)&v284 + 1) = v280;
            v275[2] = v284;
            v275[3] = v282;
            uint64_t v123 = (uint64_t)&STACK[0xD60];
            if (v276 == 2)
            {
LABEL_478:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 2, 2);
              _os_crash();
              __break(1u);
              goto LABEL_479;
            }
            *((float *)&v270 + 1) = (float)-(v278 >> 1) + 10.0;
            v275[4] = v270;
            v275[5] = v282;
            float32x4_t v285 = v275 + 4;
            if (v273 <= 0x7F)
            {
LABEL_479:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 3, v276);
              _os_crash();
              __break(1u);
              goto LABEL_480;
            }
            *((float *)&v271 + 1) = v279;
            v275[6] = v271;
            v275[7] = v282;
            if (v276 == 4)
            {
LABEL_480:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 4, 4);
              _os_crash();
              __break(1u);
              goto LABEL_481;
            }
            id v476 = (id)v274;
            uint64_t v480 = v272;
            long long v286 = *v275;
            long long v287 = v275[1];
            v275[8] = *v275;
            v275[9] = v287;
            if (v273 <= 0xBF)
            {
LABEL_481:
              re::internal::assertLog((re::internal *)6, v269, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 5, v276);
              _os_crash();
              __break(1u);
LABEL_482:
              *(void *)(v81 + 240) = 0;
              *(_OWORD *)(v123 + 48) = 0u;
              *(_OWORD *)(v123 + 64) = 0u;
              *(_OWORD *)(v123 + 16) = 0u;
              *(_OWORD *)(v123 + 32) = 0u;
              *(_OWORD *)uint64_t v123 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 0;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_483;
            }
            *(float *)&long long v286 = (float)(v264 + v262) / 16.667;
            float v288 = (float)(v263 / 1000000.0) / 16.667;
            long long v289 = *v285;
            long long v290 = v275[5];
            v275[10] = *v285;
            v275[11] = v290;
            *(void *)&a83 = v75 + 848;
            *((void *)&a83 + 1) = v75 + 864;
            *(void *)(v81 + 16) = &a69;
            *(void *)(v81 + 24) = &a68;
            *(void *)(v81 + 32) = &a67;
            *(void *)(v81 + 40) = &STACK[0xA20];
            a66 = 6;
            a65 = 1008981770;
            *(float *)&long long v289 = 1.0 - *(float *)&v286;
            re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t)&a83, 0, &a66, &a65, *(double *)&v286, *(double *)&v289, *(float *)&v286 * v281);
            *(float *)&double v291 = 1.0 - (float)(v487 / 16.667);
            *(float *)&double v292 = v487 / 16.667;
            re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t)&a83, 1, &a66, &a65, v292, v291, (float)(v487 / 16.667) * v281);
            *(float *)&double v293 = 1.0 - v288;
            *(float *)&double v294 = v288;
            re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t)&a83, 2, &a66, &a65, v294, v293, v288 * v281);
            *(float *)&double v295 = 1.0 - v265;
            *(float *)&double v296 = v265;
            re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t)&a83, 3, &a66, &a65, v295, v296, (float)(v260 >> 2));
            if ((uint64_t)STACK[0xB90] >= 1)
            {
              *(float *)&double v298 = (float)((float)((float)v266 * 0.00097656) * 0.00097656) / (float)(uint64_t)v121;
              *(float *)&double v297 = 1.0 - *(float *)&v298;
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t)&a83, 4, &a66, &a65, v297, v298, (float)(v260 >> 2));
            }
            ((void (*)(void, char *, id))a75[19])(*a75, sel_pushDebugGroup_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "MiniHUDRect", 4));
            unint64_t v124 = *(void *)(v77 + 8);
            uint64_t v299 = *(void *)(v124 + 104);
            if (v299) {
              long long v300 = *(re::DebugRenderer **)(v299 + 304);
            }
            else {
              long long v300 = 0;
            }
            uint64_t v80 = (uint64_t)&STACK[0xAE0];
            re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xD60]);
            id v488 = *(id *)re::DebugRenderer::pipelineStateWithAlphaBlending(v300, (re::RenderManager *)v124, (RenderTargetInfo *)&STACK[0xD60]);
            ((void (*)(void, char *))a75[7])(*a75, sel_setRenderPipelineState_);
            unint64_t v301 = a78;
            if (!a78) {
              goto LABEL_482;
            }
            long long v302 = a80;
            *(_OWORD *)&STACK[0xD60] = *a80;
            *(_OWORD *)&STACK[0xD70] = v302[1];
            *(_OWORD *)&STACK[0xD80] = v302[2];
            *(_OWORD *)&STACK[0xD90] = v302[3];
            if (v301 == 1)
            {
LABEL_483:
              *(void *)(v80 + 80) = 0;
              *(_OWORD *)(v81 + 176) = 0u;
              *(_OWORD *)(v81 + 192) = 0u;
              *(_OWORD *)(v81 + 144) = 0u;
              *(_OWORD *)(v81 + 160) = 0u;
              *(_OWORD *)(v81 + 128) = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xAE0]) = 136315906;
              *(void *)(v81 + 244) = "operator[]";
              LOWORD(STACK[0xAEC]) = 1024;
              *(_DWORD *)(v81 + 254) = 789;
              LOWORD(STACK[0xAF2]) = 2048;
              *(void *)(v80 + 20) = 1;
              LOWORD(STACK[0xAFC]) = 2048;
              *(void *)(v80 + 30) = 1;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_484:
              *(void *)(v81 + 128) = 0;
              *(_OWORD *)(v80 + 176) = 0u;
              *(_OWORD *)(v80 + 192) = 0u;
              *(_OWORD *)(v80 + 144) = 0u;
              *(_OWORD *)(v80 + 160) = 0u;
              *(_OWORD *)(v80 + 128) = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xD60]) = 136315906;
              *(void *)(v124 + 4) = "operator[]";
              LOWORD(STACK[0xD6C]) = 1024;
              *(_DWORD *)(v124 + 14) = 789;
              LOWORD(STACK[0xD72]) = 2048;
              *(void *)(v124 + 20) = 0;
              LOWORD(STACK[0xD7C]) = 2048;
              *(void *)(v124 + 30) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_485;
            }
            *(_OWORD *)&STACK[0xDA0] = v302[4];
            *(_OWORD *)&STACK[0xDB0] = v302[5];
            *(_OWORD *)&STACK[0xDC0] = v302[6];
            *(_OWORD *)&STACK[0xDD0] = v302[7];
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x100uLL, 0x100uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v303 = LODWORD(STACK[0xA78]);
            uint64_t v474 = *(void *)(v81 + 144);
            uint64_t v304 = *(void *)(v81 + 128) + v303;
            *(_OWORD *)(v304 + 64) = *(_OWORD *)&STACK[0xDA0];
            *(_OWORD *)(v304 + 80) = *(_OWORD *)&STACK[0xDB0];
            *(_OWORD *)(v304 + 96) = *(_OWORD *)&STACK[0xDC0];
            *(_OWORD *)(v304 + 112) = *(_OWORD *)&STACK[0xDD0];
            *(_OWORD *)uint64_t v304 = *(_OWORD *)&STACK[0xD60];
            *(_OWORD *)(v304 + 16) = *(_OWORD *)&STACK[0xD70];
            *(_OWORD *)(v304 + 32) = *(_OWORD *)&STACK[0xD80];
            *(_OWORD *)(v304 + 48) = *(_OWORD *)&STACK[0xD90];
            *(_DWORD *)(v304 + 128) = 1065353216;
            *(_OWORD *)(v304 + 240) = 0u;
            *(_OWORD *)(v304 + 228) = 0u;
            *(_OWORD *)(v304 + 212) = 0u;
            *(_OWORD *)(v304 + 196) = 0u;
            *(_OWORD *)(v304 + 180) = 0u;
            *(_OWORD *)(v304 + 164) = 0u;
            *(_OWORD *)(v304 + 148) = 0u;
            *(_OWORD *)(v304 + 132) = 0u;
            *(_OWORD *)&STACK[0xB00] = 0u;
            *(_OWORD *)&STACK[0xB10] = 0u;
            *(_OWORD *)&STACK[0xAF0] = 0u;
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x80uLL, 0x80uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v305 = LODWORD(STACK[0xA78]);
            uint64_t v306 = *(void *)(v81 + 144);
            uint64_t v307 = *(void *)(v81 + 128) + v305;
            *(_DWORD *)(v307 + 16) = 0;
            *(_DWORD *)(v307 + 28) = 1;
            *(_OWORD *)(v307 + 32) = *(_OWORD *)&STACK[0xAE0];
            *(_OWORD *)(v307 + 48) = *(_OWORD *)&STACK[0xAF0];
            *(_OWORD *)(v307 + 64) = *(_OWORD *)&STACK[0xB00];
            *(_OWORD *)(v307 + 80) = *(_OWORD *)&STACK[0xB10];
            *(_OWORD *)&STACK[0xB40] = 0u;
            *(_OWORD *)&STACK[0xB50] = 0u;
            int v308 = a81;
            int v309 = a82;
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x400uLL, 0x100uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v310 = LODWORD(STACK[0xA78]);
            uint64_t v311 = *(void *)(v81 + 144);
            uint64_t v312 = *(void *)(v81 + 128) + v310;
            *(_OWORD *)uint64_t v312 = xmmword_23435FD50;
            *(_OWORD *)(v312 + 16) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 32) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 48) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 64) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 80) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 96) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 112) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 128) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 144) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 160) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 176) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 192) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 208) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 224) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 240) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 256) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 272) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 288) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 304) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 320) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 336) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 352) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 368) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 384) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 400) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 416) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 432) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 448) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 464) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 480) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 496) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 512) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 528) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 544) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 560) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 576) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 592) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 608) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 624) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 640) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 656) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 672) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 688) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 704) = xmmword_23435FD50;
            *(_OWORD *)(v312 + 720) = xmmword_23435FD60;
            *(_OWORD *)(v312 + 736) = xmmword_23435FD80;
            *(_OWORD *)(v312 + 752) = xmmword_23435FBB0;
            *(_OWORD *)(v312 + 880) = 0u;
            *(_OWORD *)(v312 + 896) = 0u;
            *(_OWORD *)(v312 + 848) = 0u;
            *(_OWORD *)(v312 + 864) = 0u;
            *(_OWORD *)(v312 + 816) = 0u;
            *(_OWORD *)(v312 + 832) = 0u;
            *(_OWORD *)(v312 + 784) = 0u;
            *(_OWORD *)(v312 + 800) = 0u;
            *(_OWORD *)(v312 + 768) = 0u;
            *(_DWORD *)(v312 + 940) = v308;
            *(_DWORD *)(v312 + 944) = v309;
            *(_OWORD *)(v312 + 960) = 0u;
            *(_OWORD *)(v312 + 976) = *(_OWORD *)&STACK[0xB30];
            *(_OWORD *)(v312 + 992) = *(_OWORD *)&STACK[0xB40];
            *(_OWORD *)(v312 + 1008) = *(_OWORD *)&STACK[0xB50];
            ((void (*)(void, char *, id, uint64_t, void))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v476, v480, 0);
            ((void (*)(void, char *, uint64_t, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v474, v303, 1);
            ((void (*)(void, char *, uint64_t, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v306, v305, 2);
            ((void (*)(void, char *, uint64_t, uint64_t, uint64_t))a75[2])(*a75, sel_setVertexBuffer_offset_atIndex_, v311, v310, 3);
            ((void (*)(void, char *, uint64_t, void, unint64_t))a75[25])(*a75, sel_drawPrimitives_vertexStart_vertexCount_, 3, 0, a66);
            ((void (*)(void, char *))a75[20])(*a75, sel_popDebugGroup);
            *(void *)(v81 + 144) = &a68;
            *(void *)(v81 + 152) = &a72;
            *(void *)(v81 + 160) = &a67;
            *(void *)(v81 + 168) = &STACK[0xA20];
            *(void *)(v81 + 176) = &STACK[0xA24];
            *(void *)(v81 + 184) = &a73;
            *(void *)(v81 + 192) = &a74;
            *(void *)(v81 + 200) = &STACK[0xA38];
            *(void *)(v81 + 208) = &__p;
            *(void *)(v81 + 216) = &a81;
            unint64_t v313 = STACK[0xBA0];
            unint64_t v314 = STACK[0xBA0] >> 1;
            uint64_t v78 = v504;
            *(void *)(v81 + 128) = v504;
            *(void *)(v81 + 136) = v77;
            _ZF = (v313 & 1) == 0;
            unint64_t v315 = v313 >> 1;
            if (!_ZF) {
              unint64_t v315 = v314;
            }
            *(void *)(v81 + 224) = &a82;
            if (v315) {
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_1::operator()((uint64_t *)&STACK[0xA70], 0, &STACK[0xB98]);
            }
            unint64_t v316 = STACK[0xBC0];
            if (STACK[0xBC0]) {
              unint64_t v317 = v316 >> 1;
            }
            else {
              unint64_t v317 = v316 >> 1;
            }
            unint64_t v75 = (unint64_t)&STACK[0xBD8];
            if (v317) {
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_1::operator()((uint64_t *)&STACK[0xA70], 1, &STACK[0xBB8]);
            }
            unint64_t v318 = STACK[0xBE0];
            if (STACK[0xBE0]) {
              unint64_t v319 = v318 >> 1;
            }
            else {
              unint64_t v319 = v318 >> 1;
            }
            uint64_t v80 = (uint64_t)&STACK[0xAE0];
            unint64_t v79 = (unint64_t)&STACK[0xD60];
            if (v319) {
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_1::operator()((uint64_t *)&STACK[0xA70], 2, &STACK[0xBD8]);
            }
            unint64_t v320 = STACK[0xC00];
            if (STACK[0xC00]) {
              unint64_t v321 = v320 >> 1;
            }
            else {
              unint64_t v321 = v320 >> 1;
            }
            if (v321) {
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_1::operator()((uint64_t *)&STACK[0xA70], 3, &STACK[0xBF8]);
            }
            unint64_t v322 = STACK[0xC20];
            if (STACK[0xC20]) {
              unint64_t v323 = v322 >> 1;
            }
            else {
              unint64_t v323 = v322 >> 1;
            }
            if (v323) {
              re::RenderGraphProfilerOverlayNode::executeMiniHUDRendering(re::RenderGraphContext &)::$_1::operator()((uint64_t *)&STACK[0xA70], 4, &STACK[0xC18]);
            }
            if (v488) {

            }
            re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)&a74);
            if (__p && a80) {
              (*(void (**)(void))(*(void *)__p + 40))();
            }
            uint64_t v324 = *(void *)(v81 + 72);
            if (v324 && *(void *)(v81 + 104)) {
              (*(void (**)(uint64_t))(*(void *)v324 + 40))(v324);
            }
            if (STACK[0xCD8])
            {
              if (STACK[0xCE0]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xCD8] + 40))(STACK[0xCD8], STACK[0xCE8]);
              }
              *(_OWORD *)&STACK[0xCD8] = 0u;
              *(_OWORD *)&STACK[0xCE8] = 0u;
            }
            if (STACK[0xCB8])
            {
              if (STACK[0xCC0]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xCB8] + 40))(STACK[0xCB8], STACK[0xCC8]);
              }
              *(_OWORD *)&STACK[0xCB8] = 0u;
              *(_OWORD *)&STACK[0xCC8] = 0u;
            }
            if (STACK[0xC98])
            {
              if (STACK[0xCA0]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC98] + 40))(STACK[0xC98], STACK[0xCA8]);
              }
              *(_OWORD *)&STACK[0xC98] = 0u;
              *(_OWORD *)&STACK[0xCA8] = 0u;
            }
            if (STACK[0xC78])
            {
              if (STACK[0xC80]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC78] + 40))(STACK[0xC78], STACK[0xC88]);
              }
              *(_OWORD *)&STACK[0xC78] = 0u;
              *(_OWORD *)&STACK[0xC88] = 0u;
            }
            if (STACK[0xC58])
            {
              if (STACK[0xC60]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC58] + 40))(STACK[0xC58], STACK[0xC68]);
              }
              *(_OWORD *)&STACK[0xC58] = 0u;
              *(_OWORD *)&STACK[0xC68] = 0u;
            }
            if (STACK[0xC38])
            {
              if (STACK[0xC40]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC38] + 40))(STACK[0xC38], STACK[0xC48]);
              }
              *(_OWORD *)&STACK[0xC38] = 0u;
              *(_OWORD *)&STACK[0xC48] = 0u;
            }
            if (STACK[0xC18])
            {
              if (STACK[0xC20]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC18] + 40))(STACK[0xC18], STACK[0xC28]);
              }
              *(_OWORD *)&STACK[0xC18] = 0u;
              *(_OWORD *)&STACK[0xC28] = 0u;
            }
            if (STACK[0xBF8])
            {
              if (STACK[0xC00]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBF8] + 40))(STACK[0xBF8], STACK[0xC08]);
              }
              *(_OWORD *)&STACK[0xBF8] = 0u;
              *(_OWORD *)&STACK[0xC08] = 0u;
            }
            if (STACK[0xBD8])
            {
              if (STACK[0xBE0]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBD8] + 40))(STACK[0xBD8], STACK[0xBE8]);
              }
              *(_OWORD *)&STACK[0xBD8] = 0u;
              *(_OWORD *)&STACK[0xBE8] = 0u;
            }
            if (STACK[0xBB8])
            {
              if (STACK[0xBC0]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBB8] + 40))(STACK[0xBB8], STACK[0xBC8]);
              }
              *(_OWORD *)&STACK[0xBB8] = 0u;
              *(_OWORD *)&STACK[0xBC8] = 0u;
            }
            if (STACK[0xB98] && (STACK[0xBA0] & 1) != 0) {
              (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xB98] + 40))(STACK[0xB98], STACK[0xBA8]);
            }
          }
        }
      }
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA28]);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)23>::end((uint64_t)&STACK[0xA60]);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard((uint64_t *)&__p);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA60], 5074, 0);
  uint64_t v325 = *(void *)(v77 + 8);
  uint64_t v326 = *(void *)(v325 + 104);
  if (v326)
  {
    unint64_t v75 = *(void *)(v326 + 1664);
    if (v75)
    {
      if (*(void *)(v325 + 8) >= 2uLL)
      {
        char v327 = (os_unfair_lock_s *)(v75 + 16);
        os_unfair_lock_lock((os_unfair_lock_t)(v75 + 16));
        STACK[0xB60] = re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>();
        int v328 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((void *)(v75 + 480), &STACK[0xB60]);
        if (v328)
        {
          unint64_t v75 = v328[3];
          os_unfair_lock_unlock(v327);
          if (v75 && *(unsigned char *)(v75 + 8))
          {
            *(_OWORD *)&STACK[0xB60] = 0u;
            *(_OWORD *)&STACK[0xB70] = 0u;
            int v330 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xB60], 0);
            *(_OWORD *)&STACK[0xB80] = 0u;
            *(_OWORD *)&STACK[0xB90] = 0u;
            uint64_t v331 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xB80], 0);
            *(_OWORD *)&STACK[0xBA0] = 0u;
            *(_OWORD *)&STACK[0xBB0] = 0u;
            __n128 v332 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBA0], 0);
            *(_OWORD *)&STACK[0xBC0] = 0u;
            *(_OWORD *)&STACK[0xBD0] = 0u;
            float32x4_t v333 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBC0], 0);
            *(_OWORD *)&STACK[0xBE0] = 0u;
            *(_OWORD *)&STACK[0xBF0] = 0u;
            float32x4_t v334 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&STACK[0xBE0], 0);
            *(_OWORD *)&STACK[0xC00] = 0u;
            *(_OWORD *)&STACK[0xC10] = 0u;
            re::DynamicString::setCapacity(&STACK[0xC00], 0);
            os_unfair_lock_lock((os_unfair_lock_t)(v75 + 12));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xB60], (re::DynamicString *)(v75 + 64));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xB80], (re::DynamicString *)(v75 + 96));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xBC0], (re::DynamicString *)(v75 + 160));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xBA0], (re::DynamicString *)(v75 + 128));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xBE0], (re::DynamicString *)(v75 + 192));
            re::DynamicString::operator=((re::DynamicString *)&STACK[0xC00], (re::DynamicString *)(v75 + 224));
            os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 12));
            unint64_t v335 = re::RenderGraphContext::rtResolution((re::RenderGraphContext *)v77);
            int v336 = v335;
            unint64_t v337 = HIDWORD(v335);
            LODWORD(a73) = HIDWORD(v335);
            LODWORD(a69) = v335;
            uint64_t v338 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
            if (v338)
            {
              int v339 = *(unsigned __int8 *)(v338 + 65);
              if (*(unsigned char *)(v338 + 65)) {
                unsigned __int8 v340 = 2;
              }
              else {
                unsigned __int8 v340 = 1;
              }
            }
            else
            {
              int v339 = 0;
              unsigned __int8 v340 = 1;
            }
            uint64_t v80 = (uint64_t)&STACK[0xAE0];
            LOBYTE(a72) = v339;
            LOBYTE(a68) = v340;
            STACK[0xB50] = 0;
            STACK[0xB38] = 0;
            STACK[0xB40] = 0;
            STACK[0xB30] = 0;
            LODWORD(STACK[0xB48]) = 0;
            unint64_t v121 = 2;
            re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&STACK[0xB30], 2uLL);
            if (!STACK[0xB40]) {
              goto LABEL_494;
            }
            double v406 = (_OWORD *)STACK[0xB50];
            *double v406 = xmmword_23435FD50;
            v406[1] = xmmword_23435FD60;
            v406[2] = xmmword_23435FD80;
            v406[3] = xmmword_23435FBB0;
            unint64_t v121 = STACK[0xB40];
            if (STACK[0xB40] <= 1)
            {
LABEL_495:
              *(void *)uint64_t v80 = 0;
              *(_OWORD *)(v79 + 48) = 0u;
              *(_OWORD *)(v79 + 64) = 0u;
              *(_OWORD *)(v79 + 16) = 0u;
              *(_OWORD *)(v79 + 32) = 0u;
              *(_OWORD *)unint64_t v79 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 1;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = v121;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_496;
            }
            float v407 = (_OWORD *)STACK[0xB50];
            v407[4] = xmmword_23435FD50;
            v407[5] = xmmword_23435FD60;
            v407[6] = xmmword_23435FD80;
            v407[7] = xmmword_23435FBB0;
            *(void *)(v81 + 104) = 0;
            *(void *)(v81 + 80) = 0;
            *(void *)(v81 + 88) = 0;
            *(void *)(v81 + 72) = 0;
            LODWORD(STACK[0xA50]) = 0;
            unint64_t v121 = 2;
            re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&STACK[0xA38], 2uLL);
            long long v408 = 0uLL;
            if (!*(void *)(v81 + 88))
            {
LABEL_496:
              *(void *)uint64_t v80 = 0;
              *(_OWORD *)(v79 + 48) = v408;
              *(_OWORD *)(v79 + 64) = v408;
              *(_OWORD *)(v79 + 16) = v408;
              *(_OWORD *)(v79 + 32) = v408;
              *(_OWORD *)unint64_t v79 = v408;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 0;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_497;
            }
            DWORD1(v409) = 0;
            *((void *)&v409 + 1) = 0;
            *(float *)&long long v409 = 2.0 / (float)v336;
            *((float *)&v408 + 1) = 2.0 / (float)(int)v337;
            unsigned int v410 = *(_OWORD **)(v81 + 104);
            *unsigned int v410 = v409;
            v410[1] = v408;
            v410[2] = xmmword_2343E6830;
            v410[3] = xmmword_2343E1EE0;
            unint64_t v121 = *(void *)(v81 + 88);
            if (v121 <= 1)
            {
LABEL_497:
              *(void *)uint64_t v80 = 0;
              *(_OWORD *)(v79 + 48) = 0u;
              *(_OWORD *)(v79 + 64) = 0u;
              *(_OWORD *)(v79 + 16) = 0u;
              *(_OWORD *)(v79 + 32) = 0u;
              *(_OWORD *)unint64_t v79 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 1;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = v121;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_498:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v417);
              _os_crash();
              __break(1u);
LABEL_499:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v417);
              _os_crash();
              __break(1u);
LABEL_500:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 2, v417);
              _os_crash();
              __break(1u);
LABEL_501:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 3, v417);
              _os_crash();
              __break(1u);
              goto LABEL_502;
            }
            float v411 = *(_OWORD **)(v81 + 104);
            v411[4] = v409;
            v411[5] = v408;
            v411[6] = xmmword_2343E6830;
            v411[7] = xmmword_2343E1EE0;
            uint64_t v412 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v77 + 8) + 104));
            re::RenderGraphContext::acquireManagedRenderEncoder(&STACK[0xA28], v77, v412, 0);
            a74 = re::RenderGraphDataStore::tryGet<re::StencilInfoData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
            LODWORD(a66) = 3;
            LODWORD(STACK[0xA24]) = 3;
            LODWORD(STACK[0xA20]) = 1065353216;
            if (v336 < (int)v337)
            {
              if ((double)v336 / (double)(int)v337 <= 0.699999988)
              {
                LODWORD(a66) = 6;
                int v413 = 1;
              }
              else
              {
                LODWORD(a66) = 3;
                int v413 = 2;
              }
              LODWORD(STACK[0xA24]) = v413;
            }
            *(int32x2_t *)&long long v415 = re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0xC0uLL, 0x10uLL, (uint64_t)&STACK[0xD60]);
            unint64_t v416 = LODWORD(STACK[0xD6C]);
            unint64_t v417 = v416 >> 5;
            if (v416 <= 0x1F) {
              goto LABEL_498;
            }
            uint64_t v418 = (char *)LODWORD(STACK[0xD68]);
            uint64_t v419 = *(void *)(v79 + 16);
            if (v336 >= 0) {
              int v420 = v336;
            }
            else {
              int v420 = v336 + 1;
            }
            *(float *)&long long v415 = (float)(v420 >> 1);
            *(void *)&long long v421 = 0;
            DWORD2(v421) = 0;
            HIDWORD(v421) = *(_DWORD *)(v78 + 368);
            unint64_t v422 = &v418[*(void *)v79];
            if ((v337 & 0x80000000) == 0) {
              int v423 = v337;
            }
            else {
              int v423 = v337 + 1;
            }
            DWORD2(v415) = 0;
            HIDWORD(v415) = 1.0;
            long long v424 = v415;
            *((float *)&v424 + 1) = (float)(v423 >> 1);
            *(void *)&long long v425 = 0;
            DWORD2(v425) = 0;
            *(_OWORD *)unint64_t v422 = v424;
            *((_OWORD *)v422 + 1) = v421;
            if (v416 <= 0x3F) {
              goto LABEL_499;
            }
            HIDWORD(v425) = *(_DWORD *)(v78 + 368);
            if (v336 >= 0) {
              int v426 = v336;
            }
            else {
              int v426 = v336 + 1;
            }
            *(float *)&long long v421 = (float)-(v426 >> 1);
            DWORD2(v421) = 0;
            HIDWORD(v421) = 1.0;
            long long v427 = v421;
            *((float *)&v427 + 1) = (float)(v423 >> 1);
            *((_OWORD *)v422 + 2) = v427;
            *((_OWORD *)v422 + 3) = v425;
            if (v416 <= 0x5F) {
              goto LABEL_500;
            }
            *(void *)&long long v428 = 0;
            DWORD2(v428) = 0;
            HIDWORD(v428) = *(_DWORD *)(v78 + 368);
            if ((v337 & 0x80000000) == 0) {
              int v429 = v337;
            }
            else {
              int v429 = v337 + 1;
            }
            *((float *)&v421 + 1) = (float)-(v429 >> 1);
            *(void *)&long long v430 = 0;
            DWORD2(v430) = 0;
            *((_OWORD *)v422 + 4) = v421;
            *((_OWORD *)v422 + 5) = v428;
            if (v416 <= 0x7F) {
              goto LABEL_501;
            }
            HIDWORD(v430) = *(_DWORD *)(v78 + 368);
            *((float *)&v415 + 1) = (float)-(v429 >> 1);
            *((_OWORD *)v422 + 6) = v415;
            *((_OWORD *)v422 + 7) = v430;
            if (v416 <= 0x9F)
            {
LABEL_502:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 4, v417);
              _os_crash();
              __break(1u);
              goto LABEL_503;
            }
            uint64_t v482 = v419;
            long long v431 = *((_OWORD *)v422 + 1);
            *((_OWORD *)v422 + 8) = *(_OWORD *)v422;
            *((_OWORD *)v422 + 9) = v431;
            if (v416 <= 0xBF)
            {
LABEL_503:
              re::internal::assertLog((re::internal *)6, *(void *)&v414, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 5, v417);
              _os_crash();
              __break(1u);
LABEL_504:
              *(void *)uint64_t v80 = 0;
              *(_OWORD *)(v79 + 48) = 0u;
              *(_OWORD *)(v79 + 64) = 0u;
              *(_OWORD *)(v79 + 16) = 0u;
              *(_OWORD *)(v79 + 32) = 0u;
              *(_OWORD *)unint64_t v79 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xA70]) = 136315906;
              *(void *)(v81 + 132) = "operator[]";
              LOWORD(STACK[0xA7C]) = 1024;
              *(_DWORD *)(v81 + 142) = 789;
              LOWORD(STACK[0xA82]) = 2048;
              *(void *)(v81 + 148) = 0;
              LOWORD(STACK[0xA8C]) = 2048;
              *(void *)(v81 + 158) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_505:
              *(void *)&a83 = 0;
              *(_OWORD *)(v81 + 176) = 0u;
              *(_OWORD *)(v81 + 192) = 0u;
              *(_OWORD *)(v81 + 144) = 0u;
              *(_OWORD *)(v81 + 160) = 0u;
              *(_OWORD *)(v81 + 128) = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              LODWORD(STACK[0xAE0]) = 136315906;
              *(void *)(v80 + 4) = "operator[]";
              LOWORD(STACK[0xAEC]) = 1024;
              *(_DWORD *)(v80 + 14) = 789;
              LOWORD(STACK[0xAF2]) = 2048;
              *(void *)(v80 + 20) = 1;
              LOWORD(STACK[0xAFC]) = 2048;
              *(void *)(v80 + 30) = 1;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            long long v432 = *((_OWORD *)v422 + 5);
            *((_OWORD *)v422 + 10) = *((_OWORD *)v422 + 4);
            *((_OWORD *)v422 + 11) = v432;
            (*(void (**)(void, char *, id))(*(void *)(v81 + 64) + 152))(**(void **)(v81 + 64), sel_pushDebugGroup_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "SystemHUDRect", 4));
            unint64_t v433 = *(re::RenderManager **)(v77 + 8);
            uint64_t v434 = *((void *)v433 + 13);
            if (v434) {
              double v435 = *(re::DebugRenderer **)(v434 + 304);
            }
            else {
              double v435 = 0;
            }
            uint64_t v80 = (uint64_t)&STACK[0xAE0];
            re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xD60]);
            id v478 = *(id *)re::DebugRenderer::pipelineStateWithAlphaBlending(v435, v433, (RenderTargetInfo *)&STACK[0xD60]);
            (*(void (**)(void, char *))(*(void *)(v81 + 64) + 56))(**(void **)(v81 + 64), sel_setRenderPipelineState_);
            uint64_t v436 = *(void *)(v81 + 88);
            if (!v436) {
              goto LABEL_504;
            }
            id v472 = v418;
            int v475 = v339;
            uint64_t v506 = v78;
            float v437 = *(_OWORD **)(v81 + 104);
            *(_OWORD *)unint64_t v79 = *v437;
            *(_OWORD *)(v79 + 16) = v437[1];
            *(_OWORD *)(v79 + 32) = v437[2];
            *(_OWORD *)(v79 + 48) = v437[3];
            if (v436 == 1) {
              goto LABEL_505;
            }
            *(_OWORD *)(v79 + 64) = v437[4];
            *(_OWORD *)(v79 + 80) = v437[5];
            *(_OWORD *)(v79 + 96) = v437[6];
            *(_OWORD *)(v79 + 112) = v437[7];
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x100uLL, 0x100uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v438 = LODWORD(STACK[0xA78]);
            uint64_t v470 = *(void *)(v81 + 144);
            uint64_t v439 = *(void *)(v81 + 128) + v438;
            *(_OWORD *)(v439 + 64) = *(_OWORD *)(v79 + 64);
            *(_OWORD *)(v439 + 80) = *(_OWORD *)(v79 + 80);
            *(_OWORD *)(v439 + 96) = *(_OWORD *)(v79 + 96);
            *(_OWORD *)(v439 + 112) = *(_OWORD *)(v79 + 112);
            *(_OWORD *)uint64_t v439 = *(_OWORD *)v79;
            *(_OWORD *)(v439 + 16) = *(_OWORD *)(v79 + 16);
            *(_OWORD *)(v439 + 32) = *(_OWORD *)(v79 + 32);
            *(_OWORD *)(v439 + 48) = *(_OWORD *)(v79 + 48);
            *(_DWORD *)(v439 + 128) = 1065353216;
            *(_OWORD *)(v439 + 240) = 0u;
            *(_OWORD *)(v439 + 228) = 0u;
            *(_OWORD *)(v439 + 212) = 0u;
            *(_OWORD *)(v439 + 196) = 0u;
            *(_OWORD *)(v439 + 180) = 0u;
            *(_OWORD *)(v439 + 164) = 0u;
            *(_OWORD *)(v439 + 148) = 0u;
            *(_OWORD *)(v439 + 132) = 0u;
            *(_OWORD *)&STACK[0xB00] = 0u;
            *(_OWORD *)&STACK[0xB10] = 0u;
            *(_OWORD *)&STACK[0xAF0] = 0u;
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x80uLL, 0x80uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v440 = LODWORD(STACK[0xA78]);
            uint64_t v441 = *(void *)(v81 + 144);
            uint64_t v442 = *(void *)(v81 + 128) + v440;
            *(_DWORD *)(v442 + 16) = 0;
            *(_DWORD *)(v442 + 28) = 1;
            *(_OWORD *)(v442 + 32) = *(_OWORD *)&STACK[0xAE0];
            *(_OWORD *)(v442 + 48) = *(_OWORD *)&STACK[0xAF0];
            *(_OWORD *)(v442 + 64) = *(_OWORD *)&STACK[0xB00];
            *(_OWORD *)(v442 + 80) = *(_OWORD *)&STACK[0xB10];
            *(_OWORD *)(v81 + 16) = 0u;
            *(_OWORD *)(v81 + 32) = 0u;
            int v443 = v340;
            re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x400uLL, 0x100uLL, (uint64_t)&STACK[0xA70]);
            uint64_t v444 = LODWORD(STACK[0xA78]);
            uint64_t v445 = *(void *)(v81 + 144);
            uint64_t v446 = *(void *)(v81 + 128) + v444;
            *(_OWORD *)uint64_t v446 = xmmword_23435FD50;
            *(_OWORD *)(v446 + 16) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 32) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 48) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 64) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 80) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 96) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 112) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 128) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 144) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 160) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 176) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 192) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 208) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 224) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 240) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 256) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 272) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 288) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 304) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 320) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 336) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 352) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 368) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 384) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 400) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 416) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 432) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 448) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 464) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 480) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 496) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 512) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 528) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 544) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 560) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 576) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 592) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 608) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 624) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 640) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 656) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 672) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 688) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 704) = xmmword_23435FD50;
            *(_OWORD *)(v446 + 720) = xmmword_23435FD60;
            *(_OWORD *)(v446 + 736) = xmmword_23435FD80;
            *(_OWORD *)(v446 + 752) = xmmword_23435FBB0;
            *(_OWORD *)(v446 + 880) = 0u;
            *(_OWORD *)(v446 + 896) = 0u;
            *(_OWORD *)(v446 + 848) = 0u;
            *(_OWORD *)(v446 + 864) = 0u;
            *(_OWORD *)(v446 + 816) = 0u;
            *(_OWORD *)(v446 + 832) = 0u;
            *(_OWORD *)(v446 + 784) = 0u;
            *(_OWORD *)(v446 + 800) = 0u;
            *(_OWORD *)(v446 + 768) = 0u;
            *(_DWORD *)(v446 + 940) = v443;
            *(_DWORD *)(v446 + 944) = v475;
            *(_OWORD *)(v446 + 960) = 0u;
            *(_OWORD *)(v446 + 976) = a83;
            *(_OWORD *)(v446 + 992) = *(_OWORD *)(v81 + 16);
            *(_OWORD *)(v446 + 1008) = *(_OWORD *)(v81 + 32);
            (*(void (**)(void, char *, uint64_t, id, void))(*(void *)(v81 + 64) + 16))(**(void **)(v81 + 64), sel_setVertexBuffer_offset_atIndex_, v482, v472, 0);
            (*(void (**)(void, char *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 + 64) + 16))(**(void **)(v81 + 64), sel_setVertexBuffer_offset_atIndex_, v470, v438, 1);
            (*(void (**)(void, char *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 + 64) + 16))(**(void **)(v81 + 64), sel_setVertexBuffer_offset_atIndex_, v441, v440, 2);
            (*(void (**)(void, char *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 + 64) + 16))(**(void **)(v81 + 64), sel_setVertexBuffer_offset_atIndex_, v445, v444, 3);
            (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)(v81 + 64) + 200))(**(void **)(v81 + 64), sel_drawPrimitives_vertexStart_vertexCount_, 3, 0, 6);
            (*(void (**)(void, char *))(*(void *)(v81 + 64) + 160))(**(void **)(v81 + 64), sel_popDebugGroup);
            *(void *)(v81 + 144) = &STACK[0xA24];
            *(void *)(v81 + 152) = &a69;
            *(void *)(v81 + 160) = &a73;
            *(void *)(v81 + 168) = &a66;
            *(void *)(v81 + 176) = &STACK[0xA20];
            *(void *)(v81 + 184) = &a74;
            *(void *)(v81 + 192) = &STACK[0xA28];
            *(void *)(v81 + 200) = &STACK[0xB30];
            *(void *)(v81 + 208) = &STACK[0xA38];
            *(void *)(v81 + 216) = &a68;
            unint64_t v447 = STACK[0xB68];
            unint64_t v448 = STACK[0xB68] >> 1;
            uint64_t v78 = v506;
            *(void *)(v81 + 128) = v506;
            *(void *)(v81 + 136) = v77;
            _ZF = (v447 & 1) == 0;
            unint64_t v449 = v447 >> 1;
            if (!_ZF) {
              unint64_t v449 = v448;
            }
            *(void *)(v81 + 224) = &a72;
            if (v449) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 10, 40, 0, &STACK[0xB60]);
            }
            unint64_t v450 = STACK[0xB88];
            if (STACK[0xB88]) {
              unint64_t v451 = v450 >> 1;
            }
            else {
              unint64_t v451 = v450 >> 1;
            }
            unint64_t v75 = (unint64_t)&STACK[0xBA0];
            if (v451) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 11, 45, 1, &STACK[0xB80]);
            }
            unint64_t v452 = STACK[0xBC8];
            if (STACK[0xBC8]) {
              unint64_t v453 = v452 >> 1;
            }
            else {
              unint64_t v453 = v452 >> 1;
            }
            uint64_t v80 = (uint64_t)&STACK[0xAE0];
            if (v453) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 11, 40, 2, &STACK[0xBC0]);
            }
            unint64_t v454 = STACK[0xBA8];
            if (STACK[0xBA8]) {
              unint64_t v455 = v454 >> 1;
            }
            else {
              unint64_t v455 = v454 >> 1;
            }
            if (v455) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 8, 40, 3, &STACK[0xBA0]);
            }
            unint64_t v456 = STACK[0xBE8];
            if (STACK[0xBE8]) {
              unint64_t v457 = v456 >> 1;
            }
            else {
              unint64_t v457 = v456 >> 1;
            }
            if (v457) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 8, 40, 4, &STACK[0xBE0]);
            }
            unint64_t v458 = STACK[0xC08];
            if (STACK[0xC08]) {
              unint64_t v459 = v458 >> 1;
            }
            else {
              unint64_t v459 = v458 >> 1;
            }
            if (v459) {
              re::RenderGraphProfilerOverlayNode::executeSystemHUDRendering(re::RenderGraphContext &)::$_0::operator()((uint64_t *)&STACK[0xA70], 8, 40, 5, &STACK[0xC00]);
            }
            if (v478) {

            }
            re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)&STACK[0xA28]);
            uint64_t v460 = *(void *)(v81 + 72);
            if (v460 && *(void *)(v81 + 104)) {
              (*(void (**)(uint64_t))(*(void *)v460 + 40))(v460);
            }
            if (STACK[0xB30] && STACK[0xB50]) {
              (*(void (**)(unint64_t))(*(void *)STACK[0xB30] + 40))(STACK[0xB30]);
            }
            if (STACK[0xC00])
            {
              if (STACK[0xC08]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xC00] + 40))(STACK[0xC00], STACK[0xC10]);
              }
              *(_OWORD *)&STACK[0xC00] = 0u;
              *(_OWORD *)&STACK[0xC10] = 0u;
            }
            if (STACK[0xBE0])
            {
              if (STACK[0xBE8]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBE0] + 40))(STACK[0xBE0], STACK[0xBF0]);
              }
              *(_OWORD *)&STACK[0xBE0] = 0u;
              *(_OWORD *)&STACK[0xBF0] = 0u;
            }
            if (STACK[0xBC0])
            {
              if (STACK[0xBC8]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBC0] + 40))(STACK[0xBC0], STACK[0xBD0]);
              }
              *(_OWORD *)&STACK[0xBC0] = 0u;
              *(_OWORD *)&STACK[0xBD0] = 0u;
            }
            if (STACK[0xBA0])
            {
              if (STACK[0xBA8]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xBA0] + 40))(STACK[0xBA0], STACK[0xBB0]);
              }
              *(_OWORD *)&STACK[0xBA0] = 0u;
              *(_OWORD *)&STACK[0xBB0] = 0u;
            }
            if (STACK[0xB80])
            {
              if (STACK[0xB88]) {
                (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xB80] + 40))(STACK[0xB80], STACK[0xB90]);
              }
              *(_OWORD *)&STACK[0xB80] = 0u;
              *(_OWORD *)&STACK[0xB90] = 0u;
            }
            if (STACK[0xB60] && (STACK[0xB68] & 1) != 0) {
              (*(void (**)(unint64_t, unint64_t))(*(void *)STACK[0xB60] + 40))(STACK[0xB60], STACK[0xB70]);
            }
          }
        }
        else
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 16));
        }
      }
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&STACK[0xA60]);
  uint64_t result = re::ProfilerTimeGuard<(re::ProfilerStatistic)23>::end((uint64_t)&__p);
  uint64_t v341 = *(void *)(*(void *)(v77 + 8) + 104);
  if (!v341) {
    return result;
  }
  uint64_t v342 = *(void *)(v341 + 1648);
  if (!v342 || !*(unsigned char *)(v342 + 204) || *(unsigned char *)(v342 + 17)) {
    return result;
  }
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard((uint64_t *)&STACK[0xA38]);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&__p, 5074, 0);
  unint64_t v121 = re::RenderGraphContext::rtResolution((re::RenderGraphContext *)v77);
  uint64_t v343 = re::RenderGraphDataStore::tryGet<re::ViewportPercentData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
  if (v343)
  {
    BOOL v502 = *(unsigned char *)(v343 + 65) != 0;
    if (*(unsigned char *)(v343 + 65)) {
      uint64_t v123 = 2;
    }
    else {
      uint64_t v123 = 1;
    }
  }
  else
  {
    BOOL v502 = 0;
    uint64_t v123 = 1;
  }
  LOBYTE(STACK[0xA28]) = v123;
  STACK[0xB00] = 0;
  STACK[0xAE8] = 0;
  STACK[0xAF0] = 0;
  STACK[0xAE0] = 0;
  LODWORD(STACK[0xAF8]) = 0;
  unint64_t v124 = 2;
  re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&STACK[0xAE0], 2uLL);
  if (!STACK[0xAF0])
  {
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    *(void *)(v79 + 4) = "operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    *(_DWORD *)(v79 + 14) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    *(void *)(v79 + 20) = 0;
    LOWORD(STACK[0xD7C]) = 2048;
    *(void *)(v79 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_453;
  }
  uint64_t v344 = (_OWORD *)STACK[0xB00];
  *uint64_t v344 = xmmword_23435FD50;
  v344[1] = xmmword_23435FD60;
  v344[2] = xmmword_23435FD80;
  v344[3] = xmmword_23435FBB0;
  unint64_t v124 = STACK[0xAF0];
  if (STACK[0xAF0] <= 1)
  {
LABEL_453:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    *(void *)(v79 + 4) = "operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    *(_DWORD *)(v79 + 14) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    *(void *)(v79 + 20) = 1;
    LOWORD(STACK[0xD7C]) = 2048;
    *(void *)(v79 + 30) = v124;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_454;
  }
  uint64_t v345 = (_OWORD *)STACK[0xB00];
  v345[4] = xmmword_23435FD50;
  v345[5] = xmmword_23435FD60;
  v345[6] = xmmword_23435FD80;
  v345[7] = xmmword_23435FBB0;
  *(void *)(v81 + 32) = 0;
  *(void *)(v81 + 16) = 0;
  a83 = 0uLL;
  LODWORD(STACK[0xA08]) = 0;
  unint64_t v124 = 2;
  re::DynamicArray<re::Matrix4x4<float>>::resize((uint64_t)&a83, 2uLL);
  long long v346 = 0uLL;
  if (!*(void *)(v81 + 16))
  {
LABEL_454:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = v346;
    *(_OWORD *)&STACK[0xBA0] = v346;
    *(_OWORD *)&STACK[0xB70] = v346;
    *(_OWORD *)&STACK[0xB80] = v346;
    *(_OWORD *)&STACK[0xB60] = v346;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    *(void *)(v79 + 4) = "operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    *(_DWORD *)(v79 + 14) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    *(void *)(v79 + 20) = 0;
    LOWORD(STACK[0xD7C]) = 2048;
    *(void *)(v79 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_455;
  }
  unint64_t v75 = HIDWORD(v121);
  DWORD1(v347) = 0;
  *((void *)&v347 + 1) = 0;
  *(float *)&long long v347 = 2.0 / (float)(int)v121;
  *((float *)&v346 + 1) = 2.0 / (float)SHIDWORD(v121);
  uint64_t v348 = *(_OWORD **)(v81 + 32);
  *uint64_t v348 = v347;
  v348[1] = v346;
  v348[2] = xmmword_2343E6830;
  v348[3] = xmmword_2343E1EE0;
  unint64_t v124 = *(void *)(v81 + 16);
  if (v124 <= 1)
  {
LABEL_455:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    *(void *)(v79 + 4) = "operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    *(_DWORD *)(v79 + 14) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    *(void *)(v79 + 20) = 1;
    LOWORD(STACK[0xD7C]) = 2048;
    *(void *)(v79 + 30) = v124;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_456:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    STACK[0xD64] = (unint64_t)"operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    LODWORD(STACK[0xD6E]) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    STACK[0xD74] = 0;
    LOWORD(STACK[0xD7C]) = 2048;
    STACK[0xD7E] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_457:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    STACK[0xD64] = (unint64_t)"operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    LODWORD(STACK[0xD6E]) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    STACK[0xD74] = 1;
    LOWORD(STACK[0xD7C]) = 2048;
    STACK[0xD7E] = v79;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_458:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = v138;
    *(_OWORD *)&STACK[0xBA0] = v138;
    *(_OWORD *)&STACK[0xB70] = v138;
    *(_OWORD *)&STACK[0xB80] = v138;
    *(_OWORD *)&STACK[0xB60] = v138;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    STACK[0xD64] = (unint64_t)"operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    LODWORD(STACK[0xD6E]) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    STACK[0xD74] = 0;
    LOWORD(STACK[0xD7C]) = 2048;
    STACK[0xD7E] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_459:
    *(void *)(v81 + 128) = 0;
    *(_OWORD *)&STACK[0xB90] = 0u;
    *(_OWORD *)&STACK[0xBA0] = 0u;
    *(_OWORD *)&STACK[0xB70] = 0u;
    *(_OWORD *)&STACK[0xB80] = 0u;
    *(_OWORD *)&STACK[0xB60] = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(STACK[0xD60]) = 136315906;
    STACK[0xD64] = (unint64_t)"operator[]";
    LOWORD(STACK[0xD6C]) = 1024;
    LODWORD(STACK[0xD6E]) = 789;
    LOWORD(STACK[0xD72]) = 2048;
    STACK[0xD74] = 1;
    LOWORD(STACK[0xD7C]) = 2048;
    STACK[0xD7E] = v79;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_460:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v75);
    _os_crash();
    __break(1u);
LABEL_461:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v75);
    _os_crash();
    __break(1u);
LABEL_462:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 2, v75);
    _os_crash();
    __break(1u);
LABEL_463:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 3, v75);
    _os_crash();
    __break(1u);
LABEL_464:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 4, v75);
    _os_crash();
    __break(1u);
LABEL_465:
    re::internal::assertLog((re::internal *)6, v147, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 5, v75);
    _os_crash();
    __break(1u);
    goto LABEL_466;
  }
  uint64_t v349 = *(_OWORD **)(v81 + 32);
  v349[4] = v347;
  v349[5] = v346;
  v349[6] = xmmword_2343E6830;
  v349[7] = xmmword_2343E1EE0;
  uint64_t v350 = re::RenderGraphDataStore::tryGet<re::DynamicArray<re::RenderProfilerText>>(*(void *)(v77 + 1168), (int)"ProfilerOverlay", "RenderFrame");
  if (v350)
  {
    uint64_t v351 = (void *)v350;
    unsigned __int8 v481 = v123;
    uint64_t v352 = re::DrawingManager::currentCommandBuffer(*(re::DrawingManager **)(*(void *)(v77 + 8) + 104));
    re::RenderGraphContext::acquireManagedRenderEncoder(&STACK[0xA60], v77, v352, 0);
    uint64_t v497 = re::RenderGraphDataStore::tryGet<re::StencilInfoData>(*(void *)(v77 + 1168), *(void *)(*(void *)(v77 + 40) + 48));
    double v353 = (double)(int)v121;
    double v354 = (double)SHIDWORD(v121);
    if ((int)v121 >= SHIDWORD(v121))
    {
      int v356 = 3;
      unsigned int v494 = 9;
      uint64_t v80 = 3;
    }
    else
    {
      if (v353 / v354 <= 0.699999988) {
        int v355 = 6;
      }
      else {
        int v355 = 10;
      }
      unsigned int v494 = v355;
      if (v353 / v354 <= 0.699999988) {
        int v356 = 1;
      }
      else {
        int v356 = 2;
      }
      if (v353 / v354 <= 0.699999988) {
        uint64_t v80 = 6;
      }
      else {
        uint64_t v80 = 5;
      }
    }
    float v489 = v351;
    uint64_t v357 = v351[2];
    unint64_t v490 = HIDWORD(v121);
    if ((v121 & 0x8000000000000000) != 0) {
      LODWORD(v75) = HIDWORD(v121) + 1;
    }
    re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0xC0uLL, 0x10uLL, (uint64_t)&STACK[0xB60]);
    unint64_t v360 = LODWORD(STACK[0xB6C]);
    unint64_t v361 = v360 >> 5;
    if (v360 > 0x1F)
    {
      double v362 = (double)(int)v80;
      int v363 = -((int)v75 >> 1);
      uint64_t v364 = LODWORD(STACK[0xB68]);
      unint64_t v365 = STACK[0xB70];
      double v366 = (_OWORD *)(STACK[0xB60] + v364);
      if ((v121 & 0x80000000) == 0) {
        int v367 = v121;
      }
      else {
        int v367 = v121 + 1;
      }
      *(float *)&long long v359 = (float)(v367 >> 1);
      *(void *)&long long v368 = 0;
      DWORD2(v368) = 0;
      HIDWORD(v368) = *(_DWORD *)(v78 + 368);
      int v369 = (int)v357 / v356;
      if ((int)v357 % v356 > 0) {
        ++v369;
      }
      float v370 = (double)v369 / v362;
      float v371 = (float)v363 + (float)((float)SHIDWORD(v121) * v370);
      DWORD2(v359) = 0;
      HIDWORD(v359) = 1.0;
      long long v372 = v359;
      *((float *)&v372 + 1) = v371;
      *(void *)&long long v373 = 0;
      DWORD2(v373) = 0;
      *double v366 = v372;
      v366[1] = v368;
      if (v360 > 0x3F)
      {
        HIDWORD(v373) = *(_DWORD *)(v78 + 368);
        *(float *)&long long v368 = (float)-(v367 >> 1);
        DWORD2(v368) = 0;
        HIDWORD(v368) = 1.0;
        long long v374 = v368;
        *((float *)&v374 + 1) = v371;
        v366[2] = v374;
        void v366[3] = v373;
        if (v360 > 0x5F)
        {
          *(void *)&long long v375 = 0;
          DWORD2(v375) = 0;
          HIDWORD(v375) = *(_DWORD *)(v78 + 368);
          *((float *)&v368 + 1) = (float)v363;
          *(void *)&long long v376 = 0;
          DWORD2(v376) = 0;
          v366[4] = v368;
          v366[5] = v375;
          if (v360 > 0x7F)
          {
            HIDWORD(v376) = *(_DWORD *)(v78 + 368);
            *((float *)&v359 + 1) = (float)v363;
            v366[6] = v359;
            v366[7] = v376;
            if (v360 > 0x9F)
            {
              int v461 = -(v367 >> 1);
              int v463 = v363;
              int v465 = v80;
              int v467 = v121;
              long long v377 = v366[1];
              v366[8] = *v366;
              v366[9] = v377;
              if (v360 > 0xBF)
              {
                id v477 = (id)v365;
                long long v378 = v366[5];
                v366[10] = v366[4];
                v366[11] = v378;
                (*(void (**)(void, char *, id))(*(void *)(v81 + 120) + 152))(**(void **)(v81 + 120), sel_pushDebugGroup_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "ProfilerOverlay", 4));
                unint64_t v121 = *(void *)(v77 + 8);
                uint64_t v379 = *(void *)(v121 + 104);
                if (v379) {
                  uint64_t v380 = *(re::DebugRenderer **)(v379 + 304);
                }
                else {
                  uint64_t v380 = 0;
                }
                uint64_t v80 = (uint64_t)&STACK[0xAE0];
                re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xB60]);
                id v381 = *(id *)re::DebugRenderer::pipelineStateWithAlphaBlending(v380, (re::RenderManager *)v121, (RenderTargetInfo *)&STACK[0xB60]);
                (*(void (**)(void, char *, id))(*(void *)(v81 + 120) + 56))(**(void **)(v81 + 120), sel_setRenderPipelineState_, v381);
                uint64_t v382 = *(void *)(v81 + 16);
                if (v382)
                {
                  id v471 = v381;
                  uint64_t v383 = *(_OWORD **)(v81 + 32);
                  *(_OWORD *)&STACK[0xB60] = *v383;
                  *(_OWORD *)&STACK[0xB70] = v383[1];
                  *(_OWORD *)&STACK[0xB80] = v383[2];
                  *(_OWORD *)&STACK[0xB90] = v383[3];
                  if (v382 != 1)
                  {
                    unsigned int v505 = (float *)v78;
                    *(_OWORD *)&STACK[0xBA0] = v383[4];
                    *(_OWORD *)&STACK[0xBB0] = v383[5];
                    *(_OWORD *)&STACK[0xBC0] = v383[6];
                    *(_OWORD *)&STACK[0xBD0] = v383[7];
                    re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x100uLL, 0x100uLL, (uint64_t)&STACK[0xD60]);
                    uint64_t v384 = LODWORD(STACK[0xD68]);
                    uint64_t v385 = *(void *)(v79 + 16);
                    uint64_t v386 = *(void *)v79 + v384;
                    *(_OWORD *)(v386 + 64) = *(_OWORD *)&STACK[0xBA0];
                    *(_OWORD *)(v386 + 80) = *(_OWORD *)&STACK[0xBB0];
                    *(_OWORD *)(v386 + 96) = *(_OWORD *)&STACK[0xBC0];
                    *(_OWORD *)(v386 + 112) = *(_OWORD *)&STACK[0xBD0];
                    *(_OWORD *)uint64_t v386 = *(_OWORD *)&STACK[0xB60];
                    *(_OWORD *)(v386 + 16) = *(_OWORD *)&STACK[0xB70];
                    *(_OWORD *)(v386 + 32) = *(_OWORD *)&STACK[0xB80];
                    *(_OWORD *)(v386 + 48) = *(_OWORD *)&STACK[0xB90];
                    *(_DWORD *)(v386 + 128) = 1065353216;
                    *(_OWORD *)(v386 + 240) = 0u;
                    *(_OWORD *)(v386 + 228) = 0u;
                    *(_OWORD *)(v386 + 212) = 0u;
                    *(_OWORD *)(v386 + 196) = 0u;
                    *(_OWORD *)(v386 + 180) = 0u;
                    *(_OWORD *)(v386 + 164) = 0u;
                    *(_OWORD *)(v386 + 148) = 0u;
                    *(_OWORD *)(v386 + 132) = 0u;
                    *(_OWORD *)(v79 + 32) = 0u;
                    *(_OWORD *)(v79 + 48) = 0u;
                    *(_OWORD *)(v79 + 16) = 0u;
                    re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x80uLL, 0x80uLL, (uint64_t)&STACK[0xA70]);
                    uint64_t v387 = LODWORD(STACK[0xA78]);
                    uint64_t v469 = *(void *)(v81 + 144);
                    uint64_t v388 = *(void *)(v81 + 128) + v387;
                    *(_DWORD *)(v388 + 16) = 0;
                    *(_DWORD *)(v388 + 28) = 1;
                    *(_OWORD *)(v388 + 32) = *(_OWORD *)v79;
                    *(_OWORD *)(v388 + 48) = *(_OWORD *)(v79 + 16);
                    *(_OWORD *)(v388 + 64) = *(_OWORD *)(v79 + 32);
                    *(_OWORD *)(v388 + 80) = *(_OWORD *)(v79 + 48);
                    *(_OWORD *)(v81 + 144) = 0u;
                    *(_OWORD *)(v81 + 160) = 0u;
                    re::FrameContext::perFrameAlloc(*(re::FrameContext **)v77, 0x400uLL, 0x100uLL, (uint64_t)&STACK[0xB30]);
                    uint64_t v389 = LODWORD(STACK[0xB38]);
                    unint64_t v390 = STACK[0xB40];
                    uint64_t v391 = STACK[0xB30] + v389;
                    *(_OWORD *)uint64_t v391 = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 16) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 32) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 48) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 64) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 80) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 96) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 112) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 128) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 144) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 160) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 176) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 192) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 208) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 224) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 240) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 256) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 272) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 288) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 304) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 320) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 336) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 352) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 368) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 384) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 400) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 416) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 432) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 448) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 464) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 480) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 496) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 512) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 528) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 544) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 560) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 576) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 592) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 608) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 624) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 640) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 656) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 672) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 688) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 704) = xmmword_23435FD50;
                    *(_OWORD *)(v391 + 720) = xmmword_23435FD60;
                    *(_OWORD *)(v391 + 736) = xmmword_23435FD80;
                    *(_OWORD *)(v391 + 752) = xmmword_23435FBB0;
                    *(_OWORD *)(v391 + 880) = 0u;
                    *(_OWORD *)(v391 + 896) = 0u;
                    *(_OWORD *)(v391 + 848) = 0u;
                    *(_OWORD *)(v391 + 864) = 0u;
                    *(_OWORD *)(v391 + 816) = 0u;
                    *(_OWORD *)(v391 + 832) = 0u;
                    *(_OWORD *)(v391 + 784) = 0u;
                    *(_OWORD *)(v391 + 800) = 0u;
                    *(_OWORD *)(v391 + 768) = 0u;
                    *(_DWORD *)(v391 + 940) = v481;
                    *(_DWORD *)(v391 + 944) = v502;
                    *(_OWORD *)(v391 + 960) = 0u;
                    *(_OWORD *)(v391 + 976) = *(_OWORD *)(v81 + 128);
                    *(_OWORD *)(v391 + 992) = *(_OWORD *)(v81 + 144);
                    *(_OWORD *)(v391 + 1008) = *(_OWORD *)(v81 + 160);
                    (*(void (**)(void, char *, id, uint64_t, void))(*(void *)(v81 + 120) + 16))(**(void **)(v81 + 120), sel_setVertexBuffer_offset_atIndex_, v477, v364, 0);
                    (*(void (**)(void, char *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 + 120) + 16))(**(void **)(v81 + 120), sel_setVertexBuffer_offset_atIndex_, v385, v384, 1);
                    (*(void (**)(void, char *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 + 120) + 16))(**(void **)(v81 + 120), sel_setVertexBuffer_offset_atIndex_, v469, v387, 2);
                    (*(void (**)(void, char *, unint64_t, uint64_t, uint64_t))(*(void *)(v81 + 120)
                                                                                               + 16))(**(void **)(v81 + 120), sel_setVertexBuffer_offset_atIndex_, v390, v389, 3);
                    (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)(v81 + 120) + 200))(**(void **)(v81 + 120), sel_drawPrimitives_vertexStart_vertexCount_, 3, 0, 6);
                    (*(void (**)(void, char *))(*(void *)(v81 + 120) + 160))(**(void **)(v81 + 120), sel_popDebugGroup);
                    if (v471) {

                    }
                    uint64_t v393 = v489[2];
                    if (v393)
                    {
                      unsigned int v394 = 0;
                      uint64_t v395 = v489[4];
                      double v396 = 1.0 / (double)v356 * v353;
                      double v397 = 1.0 / v362 * v354;
                      int v398 = (int)v490 / v465;
                      uint64_t v399 = (v393 << 7) - 128;
                      __asm { FMOV            V0.4S, #1.0 }
                      uint64_t v492 = *((void *)&_Q0 + 1);
                      do
                      {
                        *(float *)v392.i32 = v505[95] * (float)(v467 / v356 / *(_DWORD *)(v395 + 124));
                        if (*(float *)v392.i32 > (float)(v505[94] * (float)(v398 / *(_DWORD *)(v395 + 120)))) {
                          *(float *)v392.i32 = v505[94] * (float)(v398 / *(_DWORD *)(v395 + 120));
                        }
                        *(float *)v392.i32 = v505[93] * *(float *)v392.i32;
                        *((void *)&v403 + 1) = v492;
                        float v401 = (double)v461 + v396 * (double)(int)(v394 % v356);
                        *(float *)&long long v403 = v401;
                        float v402 = (double)v463 + v397 * (double)(int)(v394 / v356 + 1);
                        *((float *)&v403 + 1) = v402;
                        *(float32x4_t *)(v395 + 32) = vmulq_n_f32((float32x4_t)xmmword_23435FD50, *(float *)v392.i32);
                        *(float32x4_t *)(v395 + 48) = vmulq_n_f32((float32x4_t)xmmword_23435FD60, *(float *)vshrq_n_u64((uint64x2_t)vdupq_lane_s32(v392, 0), 0x20uLL).i32);
                        *(_OWORD *)(v395 + 64) = xmmword_23435FD80;
                        *(_OWORD *)(v395 + 80) = v403;
                        unint64_t v404 = *(re::TextManager **)(*(void *)(v77 + 8) + 72);
                        re::RenderGraphContext::rtInfo((re::RenderGraphContext *)v77, *(re::RenderGraphNodeBase **)(v77 + 40), (uint64_t)&STACK[0xB60]);
                        if (v497)
                        {
                          long long v405 = *(_OWORD *)(v497 + 8);
                          LOBYTE(STACK[0xD70]) = *(unsigned char *)(v497 + 24);
                          *(_OWORD *)&STACK[0xD60] = v405;
                        }
                        else
                        {
                          STACK[0xD60] = 0;
                          STACK[0xD68] = 0;
                          LOBYTE(STACK[0xD70]) = 0;
                          LOWORD(STACK[0xD61]) = -1;
                          LOBYTE(STACK[0xD63]) = 7;
                          LOWORD(STACK[0xD69]) = -1;
                          LOBYTE(STACK[0xD6B]) = 7;
                        }
                        *(void *)&long long v508 = &STACK[0xAE0];
                        *((void *)&v508 + 1) = &a83;
                        re::TextManager::render(v404, (unsigned int *)&STACK[0xB60], (uint64_t)&STACK[0xD60], (uint64_t)&STACK[0xA60], *(void *)v77, v508, &STACK[0xA28], v395, v502, 0);
                        if (!v399) {
                          break;
                        }
                        ++v394;
                        v395 += 128;
                        v399 -= 128;
                      }
                      while (v394 < v494);
                    }
                    re::mtl::RenderCommandEncoder::~RenderCommandEncoder((re::mtl::RenderCommandEncoder *)&STACK[0xA60]);
                    unint64_t v81 = (unint64_t)&a83;
                    goto LABEL_341;
                  }
                  goto LABEL_493;
                }
LABEL_492:
                *(void *)(v81 + 128) = 0;
                *(_OWORD *)&STACK[0xB90] = 0u;
                *(_OWORD *)&STACK[0xBA0] = 0u;
                *(_OWORD *)&STACK[0xB70] = 0u;
                *(_OWORD *)&STACK[0xB80] = 0u;
                *(_OWORD *)&STACK[0xB60] = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(STACK[0xD60]) = 136315906;
                *(void *)(v79 + 4) = "operator[]";
                LOWORD(STACK[0xD6C]) = 1024;
                *(_DWORD *)(v79 + 14) = 789;
                LOWORD(STACK[0xD72]) = 2048;
                *(void *)(v79 + 20) = 0;
                LOWORD(STACK[0xD7C]) = 2048;
                *(void *)(v79 + 30) = 0;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_493:
                *(void *)(v80 + 80) = 0;
                *(_OWORD *)(v79 + 48) = 0u;
                *(_OWORD *)(v79 + 64) = 0u;
                *(_OWORD *)(v79 + 16) = 0u;
                *(_OWORD *)(v79 + 32) = 0u;
                *(_OWORD *)unint64_t v79 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(STACK[0xA70]) = 136315906;
                *(void *)(v81 + 132) = "operator[]";
                LOWORD(STACK[0xA7C]) = 1024;
                *(_DWORD *)(v81 + 142) = 789;
                LOWORD(STACK[0xA82]) = 2048;
                *(void *)(v81 + 148) = 1;
                LOWORD(STACK[0xA8C]) = 2048;
                *(void *)(v81 + 158) = 1;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_494:
                *(void *)uint64_t v80 = 0;
                *(_OWORD *)(v79 + 48) = 0u;
                *(_OWORD *)(v79 + 64) = 0u;
                *(_OWORD *)(v79 + 16) = 0u;
                *(_OWORD *)(v79 + 32) = 0u;
                *(_OWORD *)unint64_t v79 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                LODWORD(STACK[0xA70]) = 136315906;
                *(void *)(v81 + 132) = "operator[]";
                LOWORD(STACK[0xA7C]) = 1024;
                *(_DWORD *)(v81 + 142) = 789;
                LOWORD(STACK[0xA82]) = 2048;
                *(void *)(v81 + 148) = 0;
                LOWORD(STACK[0xA8C]) = 2048;
                *(void *)(v81 + 158) = 0;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_495;
              }
LABEL_491:
              re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 5, v361);
              _os_crash();
              __break(1u);
              goto LABEL_492;
            }
LABEL_490:
            re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 4, v361);
            _os_crash();
            __break(1u);
            goto LABEL_491;
          }
LABEL_489:
          re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 3, v361);
          _os_crash();
          __break(1u);
          goto LABEL_490;
        }
LABEL_488:
        re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 2, v361);
        _os_crash();
        __break(1u);
        goto LABEL_489;
      }
LABEL_487:
      re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 1, v361);
      _os_crash();
      __break(1u);
      goto LABEL_488;
    }
LABEL_486:
    re::internal::assertLog((re::internal *)6, v358, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, std::string::size_type size = %zu", "index < size()", "operator[]", 658, 0, v361);
    _os_crash();
    __break(1u);
    goto LABEL_487;
  }
LABEL_341:
  if ((void)a83 && *(void *)(v81 + 32)) {
    (*(void (**)(void))(*(void *)a83 + 40))();
  }
  if (STACK[0xAE0])
  {
    if (STACK[0xB00]) {
      (*(void (**)(unint64_t))(*(void *)STACK[0xAE0] + 40))(STACK[0xAE0]);
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&__p);
  return re::ProfilerTimeGuard<(re::ProfilerStatistic)23>::end((uint64_t)&STACK[0xA38]);
}