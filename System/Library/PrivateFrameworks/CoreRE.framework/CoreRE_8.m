uint64_t re::PhysXDebugRenderer::setScene(uint64_t a1, uint64_t a2)
{
  uint64_t (*v3)(__n128);
  __n128 v4;
  uint64_t vars8;

  *(void *)a1 = a2;
  (*(void (**)(uint64_t, void, float))(*(void *)a2 + 552))(a2, 0, 0.5);
  (*(void (**)(float))(**(void **)a1 + 552))(0.5);
  (*(void (**)(float))(**(void **)a1 + 552))(0.5);
  (*(void (**)(float))(**(void **)a1 + 552))(0.5);
  (*(void (**)(float))(**(void **)a1 + 552))(0.5);
  (*(void (**)(float))(**(void **)a1 + 552))(0.5);
  v3 = *(uint64_t (**)(__n128))(**(void **)a1 + 552);
  v4.n128_u32[0] = 0.5;
  return v3(v4);
}

float re::PhysXDebugRenderer::setRenderingTransform(uint64_t a1, _OWORD *a2)
{
  int32x4_t v3 = *((int32x4_t *)a2 + 2);
  float32x4_t v2 = *((float32x4_t *)a2 + 3);
  int32x4_t v4 = *((int32x4_t *)a2 + 1);
  *(_OWORD *)(a1 + 16) = *a2;
  *(int32x4_t *)(a1 + 32) = v4;
  *(int32x4_t *)(a1 + 48) = v3;
  *(float32x4_t *)(a1 + 64) = v2;
  v2.i64[0] = *(void *)(a1 + 16);
  v3.i64[0] = *(void *)(a1 + 32);
  v4.i64[0] = *(void *)(a1 + 48);
  v2.i32[2] = *(_DWORD *)(a1 + 24);
  v3.i32[2] = *(_DWORD *)(a1 + 40);
  v4.i32[2] = *(_DWORD *)(a1 + 56);
  float32x4_t v5 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL), (int8x16_t)v4, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL)));
  float32x4_t v6 = vmulq_f32(v2, v2);
  float v7 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0]);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0] <= 0.0)float v7 = -v7; {
  float result = v7 * 0.1;
  }
  *(float *)(a1 + 112) = result;
  return result;
}

uint64_t re::PhysXDebugRenderer::draw(re::PhysXDebugRenderer *this)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)this + 584))(*(void *)this);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 16))(v2))
  {
    unint64_t v4 = 0;
    uint64_t v5 = v3 + 12;
    do
    {
      v5 += 16;
      (*(void (**)(float))(*((void *)this + 11) + 16))(*((float *)this + 28));
      ++v4;
    }
    while (v4 < (*(unsigned int (**)(uint64_t))(*(void *)v2 + 16))(v2));
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2))
  {
    unint64_t v7 = 0;
    uint64_t v8 = v6 + 12;
    do
    {
      v8 += 32;
      (*(void (**)(void))(*((void *)this + 10) + 16))();
      ++v7;
    }
    while (v7 < (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2));
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 48))(v2))
  {
    unint64_t v10 = 0;
    uint64_t v11 = v9 + 24;
    do
    {
      (*(void (**)(void))(*((void *)this + 10) + 16))();
      (*(void (**)(void))(*((void *)this + 10) + 16))();
      (*(void (**)(void))(*((void *)this + 10) + 16))();
      ++v10;
      v11 += 48;
    }
    while (v10 < (*(unsigned int (**)(uint64_t))(*(void *)v2 + 48))(v2));
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72))(v2);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
  if (result)
  {
    unint64_t v14 = 0;
    do
    {
      (*(void (**)(void))(*((void *)this + 12) + 16))();
      ++v14;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
      v12 += 32;
    }
    while (v14 < result);
  }
  return result;
}

uint64_t re::CompoundShape::CompoundShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26E6DD290;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 32) = a6;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = a2;
  if (a6)
  {
    if (a6 >= 0x111111111111112)
    {
LABEL_27:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 240, a6);
      _os_crash();
      __break(1u);
LABEL_28:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 240 * a6, 16);
    *(void *)(a1 + 40) = v13;
    if (!v13) {
      goto LABEL_28;
    }
    unint64_t v15 = a6 - 1;
    if (a6 != 1)
    {
      uint64_t v16 = v13;
      do
      {
        *(_OWORD *)(v13 + 144) = 0uLL;
        *(_OWORD *)(v13 + 160) = 0uLL;
        *(_OWORD *)(v13 + 208) = 0uLL;
        *(_OWORD *)(v13 + 224) = 0uLL;
        *(_OWORD *)(v13 + 176) = 0uLL;
        *(_OWORD *)(v13 + 192) = 0uLL;
        *(_OWORD *)(v13 + 112) = 0uLL;
        *(_OWORD *)(v13 + 64) = 0uLL;
        *(_OWORD *)(v13 + 80) = 0uLL;
        *(_OWORD *)(v13 + 48) = 0uLL;
        *(_OWORD *)uint64_t v13 = 0uLL;
        *(_OWORD *)(v13 + 16) = 0uLL;
        *(void *)(v13 + 32) = 0;
        *(void *)(v13 + 40) = 0x3F80000000000000;
        *(void *)uint64_t v13 = &unk_26E6DD0A8;
        *(void *)(v13 + 96) = 0;
        *(void *)(v13 + 104) = 0x3F80000000000000;
        *(void *)(v13 + 128) = 0;
        *(void *)(v13 + 136) = 0x3F80000000000000;
        *(void *)(v13 + 144) = 0;
        *(void *)(v13 + 152) = 0;
        *(_DWORD *)(v13 + 168) = 0;
        *(void *)(v13 + 160) = 0;
        *(_DWORD *)(v13 + 208) = 0;
        *(_OWORD *)(v13 + 176) = 0uLL;
        *(_OWORD *)(v13 + 192) = 0uLL;
        v13 += 240;
        v16 += 240;
        --v15;
      }
      while (v15);
    }
    *(_OWORD *)(v13 + 144) = 0u;
    *(_OWORD *)(v13 + 160) = 0u;
    *(_OWORD *)(v13 + 208) = 0u;
    *(_OWORD *)(v13 + 224) = 0u;
    *(_OWORD *)(v13 + 176) = 0u;
    *(_OWORD *)(v13 + 192) = 0u;
    *(_OWORD *)(v13 + 112) = 0u;
    *(_OWORD *)(v13 + 64) = 0u;
    *(_OWORD *)(v13 + 80) = 0u;
    *(_OWORD *)(v13 + 48) = 0u;
    *(_OWORD *)uint64_t v13 = 0u;
    *(_OWORD *)(v13 + 16) = 0u;
    *(void *)(v13 + 32) = 0;
    *(void *)(v13 + 40) = 0x3F80000000000000;
    *(void *)uint64_t v13 = &unk_26E6DD0A8;
    *(void *)(v13 + 96) = 0;
    *(void *)(v13 + 104) = 0x3F80000000000000;
    *(void *)(v13 + 128) = 0;
    *(void *)(v13 + 136) = 0x3F80000000000000;
    *(void *)(v13 + 144) = 0;
    *(void *)(v13 + 152) = 0;
    *(_DWORD *)(v13 + 168) = 0;
    *(void *)(v13 + 160) = 0;
    *(_DWORD *)(v13 + 208) = 0;
    *(_OWORD *)(v13 + 176) = 0u;
    *(_OWORD *)(v13 + 192) = 0u;
  }
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)(a1 + 56), 0);
  ++*(_DWORD *)(a1 + 80);
  if (a6)
  {
    unint64_t v17 = 0;
    uint64_t v18 = 232;
    while (*(void *)(a1 + 32) > v17)
    {
      uint64_t v19 = *(void *)(a4 + 8 * v17);
      v20 = (void *)(*(void *)(a1 + 40) + v18);
      long long v21 = *a5;
      *(_OWORD *)(v20 - 25) = a5[1];
      *(_OWORD *)(v20 - 27) = v21;
      *(v20 - 21) = v19;
      long long v22 = *a5;
      *(_OWORD *)(v20 - 13) = a5[1];
      *(_OWORD *)(v20 - 15) = v22;
      *(v20 - 11) = a2;
      re::DynamicArray<re::EvaluationRegister>::setCapacity(v20 - 11, 0);
      ++*((_DWORD *)v20 - 16);
      void *v20 = a7;
      if (*(void *)(a1 + 32) <= v17) {
        goto LABEL_24;
      }
      v23 = (_DWORD *)(*(void *)(a1 + 40) + v18 - 88);
      v41.i64[0] = a1;
      v41.i64[1] = (uint64_t)re::CompoundShape::onChildPoseDidChange;
      v42.i64[0] = 0;
      v42.i64[1] = (uint64_t)re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
      double v24 = re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(v23, (uint64_t)&v41);
      if (*(void *)(a1 + 32) <= v17) {
        goto LABEL_25;
      }
      uint64_t v25 = *(void *)(*(void *)(a1 + 40) + v18 - 168);
      if ((*(unsigned int (**)(uint64_t, double))(*(void *)v25 + 24))(v25, v24) == 7)
      {
        if (*(void *)(a1 + 32) <= v17) {
          goto LABEL_26;
        }
        v26 = (_DWORD *)(*(void *)(*(void *)(a1 + 40) + v18 - 168) + 56);
        v41.i64[0] = a1;
        v41.i64[1] = (uint64_t)re::CompoundShape::onChildPoseDidChange;
        v42.i64[0] = 0;
        v42.i64[1] = (uint64_t)re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
        re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(v26, (uint64_t)&v41);
      }
      ++v17;
      v18 += 240;
      a5 += 2;
      if (a6 == v17) {
        goto LABEL_17;
      }
    }
    long long v44 = 0u;
    long long v45 = 0u;
    float32x4_t v42 = 0u;
    long long v43 = 0u;
    float32x4_t v41 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    long long v44 = 0u;
    long long v45 = 0u;
    float32x4_t v42 = 0u;
    long long v43 = 0u;
    float32x4_t v41 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_25:
    long long v44 = 0u;
    long long v45 = 0u;
    float32x4_t v42 = 0u;
    long long v43 = 0u;
    float32x4_t v41 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    long long v44 = 0u;
    long long v45 = 0u;
    float32x4_t v42 = 0u;
    long long v43 = 0u;
    float32x4_t v41 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
LABEL_17:
  uint64_t v27 = *(void *)(a1 + 32);
  if (v27)
  {
    v28 = *(re::GeometricObjectBase **)(a1 + 40);
    uint64_t v29 = 240 * v27;
    float32x4_t v30 = (float32x4_t)vdupq_n_s32(0x7F800000u);
    v31.i64[0] = 0x7F0000007FLL;
    v31.i64[1] = 0x7F0000007FLL;
    do
    {
      float32x4_t v39 = v31;
      float32x4_t v40 = v30;
      re::GeometricObjectBase::aabb((uint64_t *)&v41, v28);
      float32x4_t v33 = v39;
      float32x4_t v32 = v40;
      v32.i32[3] = 0;
      float32x4_t v34 = v41;
      float32x4_t v35 = v42;
      v34.i32[3] = 0;
      v33.i32[3] = 0;
      float32x4_t v30 = vminnmq_f32(v32, v34);
      v35.i32[3] = 0;
      float32x4_t v31 = vmaxnmq_f32(v33, v35);
      v28 = (re::GeometricObjectBase *)((char *)v28 + 240);
      v29 -= 240;
    }
    while (v29);
    float32x4_t v36 = vsubq_f32(v31, v30);
  }
  else
  {
    v36.i64[0] = 0x7F0000007FLL;
    v36.i32[2] = 127;
  }
  v36.i32[3] = 0;
  float32x4_t v37 = vmaxnmq_f32(v36, (float32x4_t)0);
  *(float *)(a1 + 16) = fminf(fminf(v37.f32[0], v37.f32[2]), v37.f32[1]);
  return a1;
}

uint64_t re::CompoundShape::onChildPoseDidChange(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 72))();
}

void re::CompoundShape::~CompoundShape(re::CompoundShape *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26E6DD290;
  uint64_t v3 = (void *)((char *)this + 32);
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v4 = 240 * v2;
    uint64_t v5 = *((void *)this + 5) + 144;
    do
    {
      *(void *)&long long v9 = this;
      *((void *)&v9 + 1) = re::CompoundShape::onChildPoseDidChange;
      uint64_t v10 = 0;
      uint64_t v11 = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
      re::Event<re::GeometricObjectBase>::removeSubscription(v5, &v9);
      if ((*(unsigned int (**)(void))(**(void **)(v5 - 80) + 24))(*(void *)(v5 - 80)) == 7)
      {
        uint64_t v6 = *(void *)(v5 - 80) + 56;
        *(void *)&long long v9 = this;
        *((void *)&v9 + 1) = re::CompoundShape::onChildPoseDidChange;
        uint64_t v10 = 0;
        uint64_t v11 = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
        re::Event<re::GeometricObjectBase>::removeSubscription(v6, &v9);
      }
      v5 += 240;
      v4 -= 240;
    }
    while (v4);
  }
  re::Event<re::GeometricObjectBase>::~Event((void *)this + 7);
  if (*((void *)this + 3))
  {
    if (*v3)
    {
      uint64_t v7 = *((void *)this + 5);
      uint64_t v8 = 240 * *v3;
      do
      {
        re::GeometricObject::deinit(v7);
        re::Event<re::GeometricObjectBase>::~Event((void *)(v7 + 144));
        v7 += 240;
        v8 -= 240;
      }
      while (v8);
      (*(void (**)(void, void))(**((void **)this + 3) + 40))(*((void *)this + 3), *((void *)this + 5));
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *((void *)this + 3) = 0;
  }
}

uint64_t re::CompoundShape::onChildPoseDidChange(re::CompoundShape *this, re::GeometricObjectBase *a2)
{
  return 0;
}

uint64_t re::CompoundShape::isStaticShape(re::CompoundShape *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = 240 * v1 - 240;
  uint64_t v3 = (uint64_t *)(*((void *)this + 5) + 64);
  do
  {
    uint64_t v4 = *v3;
    v3 += 30;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 56))(v4);
    if (result) {
      BOOL v6 = v2 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    v2 -= 240;
  }
  while (!v6);
  return result;
}

double re::CompoundShape::massProperties(uint64_t a1, _DWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v8 = MEMORY[0x270FA5388](a1);
  uint64_t v11 = (char *)&v30 - v10;
  if (v9)
  {
    float32x4_t v31 = a2;
    float32x4_t v32 = a3;
    float32x4_t v33 = a4;
    uint64_t v12 = (char *)&v30 - v10;
    do
    {
      *(_OWORD *)uint64_t v12 = xmmword_23435FD50;
      *((_OWORD *)v12 + 1) = xmmword_23435FD50;
      *((_OWORD *)v12 + 2) = xmmword_23435FD50;
      *((_DWORD *)v12 + 12) = 1065353216;
      v12 += 52;
    }
    while (v12 != &v11[52 * v9]);
    MEMORY[0x270FA5388](v8);
    uint64_t v14 = (char *)&v30 - v13;
    unint64_t v15 = 0;
    uint64_t v16 = *(void *)(a1 + 40);
    unint64_t v17 = v14 + 24;
    uint64_t v18 = v11 + 24;
    uint64_t v19 = 128;
    do
    {
      int v38 = 0;
      long long v37 = 0u;
      long long v36 = 0u;
      long long v35 = 0u;
      long long v34 = 0u;
      (*(void (**)(void, int *, long long *, long long *))(**(void **)(v16 + v19 - 64) + 32))(*(void *)(v16 + v19 - 64), &v38, &v37, &v34);
      *(void *)&long long v20 = *(void *)((char *)&v34 + 4);
      uint64_t v21 = v35;
      int v22 = DWORD2(v35);
      *(void *)&long long v23 = v36;
      *((_DWORD *)v18 - 6) = v34;
      *((void *)&v20 + 1) = v21;
      *(_OWORD *)(v18 - 20) = v20;
      *((_DWORD *)v18 - 1) = v22;
      *((void *)&v23 + 1) = __PAIR64__(v37, DWORD2(v36));
      *(_OWORD *)uint64_t v18 = v23;
      *((void *)v18 + 2) = *(void *)((char *)&v37 + 4);
      *((_DWORD *)v18 + 6) = v38;
      unint64_t v24 = *(void *)(a1 + 32);
      if (v24 <= v15)
      {
        uint64_t v39 = 0;
        memset(v49, 0, sizeof(v49));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v41 = 136315906;
        float32x4_t v42 = "operator[]";
        __int16 v43 = 1024;
        int v44 = 476;
        __int16 v45 = 2048;
        unint64_t v46 = v15;
        __int16 v47 = 2048;
        unint64_t v48 = v24;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v16 = *(void *)(a1 + 40);
      int v25 = *(_DWORD *)(v16 + v19 - 8);
      uint64_t v26 = *(void *)(v16 + v19 - 16);
      *(_OWORD *)(v17 - 6) = *(_OWORD *)(v16 + v19);
      ++v15;
      *((void *)v17 - 1) = v26;
      *unint64_t v17 = v25;
      v17 += 7;
      v19 += 240;
      v18 += 52;
    }
    while (v15 < v24);
    a4 = v33;
    a3 = v32;
    a2 = v31;
  }
  else
  {
    LODWORD(v24) = 0;
    uint64_t v14 = &v40;
  }
  physx::PxMassProperties::sum((uint64_t)v11, (uint64_t)v14, v24, (float *)v49);
  *a2 = v49[3];
  *a3 = *(_OWORD *)((char *)&v49[2] + 4);
  double result = *(double *)v49;
  long long v28 = *(_OWORD *)((char *)v49 + 12);
  long long v29 = *(_OWORD *)((char *)&v49[1] + 8);
  *a4 = v49[0];
  a4[1] = v28;
  a4[2] = v29;
  return result;
}

uint64_t physx::PxMassProperties::sum@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, float *a4@<X8>)
{
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = (float *)(a2 + 12);
    BOOL v6 = (float *)(result + 48);
    float v7 = 0.0;
    uint64_t v8 = a3;
    float v9 = 0.0;
    float v10 = 0.0;
    float v11 = 0.0;
    do
    {
      float v12 = *(v6 - 3) + *(v6 - 3);
      float v13 = *(v6 - 2) + *(v6 - 2);
      float v14 = *(v6 - 1) + *(v6 - 1);
      float v15 = *(v5 - 3);
      float v16 = *(v5 - 2);
      float v17 = (float)(*v5 * *v5) + -0.5;
      float v18 = *(v5 - 1);
      float v19 = (float)((float)(v13 * v16) + (float)(v15 * v12)) + (float)(v18 * v14);
      float v20 = *v6;
      v6 += 13;
      float v7 = v7 + v20;
      float v11 = v11
          + (float)(v20
                  * (float)(v5[1]
                          + (float)((float)((float)(*v5 * (float)((float)(v16 * v14) - (float)(v18 * v13)))
                                          + (float)(v12 * v17))
                                  + (float)(v15 * v19))));
      float v10 = v10
          + (float)(v20
                  * (float)(v5[2]
                          + (float)((float)((float)(*v5 * (float)((float)(v18 * v12) - (float)(v15 * v14)))
                                          + (float)(v13 * v17))
                                  + (float)(v16 * v19))));
      float v9 = v9
         + (float)(v20
                 * (float)(v5[3]
                         + (float)((float)((float)(*v5 * (float)((float)(v15 * v13) - (float)(v16 * v12)))
                                         + (float)(v14 * v17))
                                 + (float)(v18 * v19))));
      v5 += 7;
      --v8;
    }
    while (v8);
    float v21 = 1.0;
    if (v7 <= 0.0) {
      float v22 = v11;
    }
    else {
      float v22 = (float)(1.0 / v7) * v11;
    }
    if (v7 <= 0.0) {
      float v23 = v10;
    }
    else {
      float v23 = (float)(1.0 / v7) * v10;
    }
    if (v7 <= 0.0) {
      float v24 = v9;
    }
    else {
      float v24 = (float)(1.0 / v7) * v9;
    }
    int v25 = (float *)(result + 24);
    uint64_t v26 = (float *)(a2 + 12);
    float v27 = 0.0;
    float v28 = 0.0;
    float v29 = 0.0;
    float v30 = 0.0;
    float v31 = 0.0;
    float v32 = 0.0;
    float v33 = 0.0;
    float v34 = 0.0;
    float v35 = 0.0;
    float v147 = v24;
    float v145 = v7;
    float v146 = v23;
    do
    {
      float v148 = v31;
      float v149 = v34;
      float v150 = v35;
      float v36 = v25[2];
      float v37 = v25[3] + v25[3];
      float v38 = v25[4] + v25[4];
      float v39 = v25[5] + v25[5];
      float v40 = v22;
      float v41 = (float)(*v26 * *v26) + -0.5;
      float v42 = *(v26 - 3);
      float v43 = *(v26 - 2);
      float v44 = *(v26 - 1);
      float v45 = (float)((float)(v38 * v43) + (float)(v42 * v37)) + (float)(v44 * v39);
      float v46 = (float)(*v26 * (float)((float)(v43 * v39) - (float)(v44 * v38))) + (float)(v37 * v41);
      float v47 = *v26 * (float)((float)(v44 * v37) - (float)(v42 * v39));
      float v48 = *v26 * (float)((float)(v42 * v38) - (float)(v43 * v37));
      float v49 = v47 + (float)(v38 * v41);
      float v50 = v48 + (float)(v39 * v41);
      float v51 = v42 + v42;
      float v52 = v43 + v43;
      float v53 = v42 * (float)(v42 + v42);
      float v54 = v46 + (float)(v42 * v45);
      float v55 = v43 * (float)(v43 + v43);
      float v56 = v44 * (float)(v44 + v44);
      float v57 = v51 * v43;
      float v58 = v51 * v44;
      float v59 = *v26 * v51;
      float v60 = v49 + (float)(v43 * v45);
      float v61 = (float)(v43 + v43) * v44;
      float v62 = *v26 * v52;
      float v63 = *v26 * (float)(v44 + v44);
      float v64 = (float)(v21 - v55) - v56;
      float v65 = v50 + (float)(v44 * v45);
      float v66 = v57 + v63;
      float v67 = v58 - v62;
      float v68 = v57 - v63;
      float v69 = (float)(v21 - v53) - v56;
      float v70 = v59 + v61;
      float v71 = v58 + v62;
      float v72 = v61 - v59;
      float v74 = *(v25 - 6);
      float v73 = *(v25 - 5);
      float v75 = (float)(v21 - v53) - v55;
      float v76 = v66 * v74;
      float v77 = v69 * v73;
      float v78 = (float)(v64 * v74) + (float)(v68 * v73);
      float v79 = (float)(v67 * v74) + (float)(v70 * v73);
      float v80 = *(v25 - 4);
      float v81 = *(v25 - 3);
      float v82 = v76 + v77;
      float v83 = v78 + (float)(v71 * v80);
      float v84 = v79 + (float)(v75 * v80);
      float v85 = v82 + (float)(v72 * v80);
      float v86 = v64 * v81;
      float v87 = v66 * v81;
      float v88 = v67 * v81;
      float v89 = v33;
      float v91 = *(v25 - 2);
      float v90 = *(v25 - 1);
      float v92 = v26[1] + v54;
      float v93 = v87 + (float)(v69 * v91);
      float v94 = (float)(v88 + (float)(v70 * v91)) + (float)(v75 * v90);
      float v95 = v26[3] + v65;
      float v96 = v25[1];
      float v97 = (float)(v86 + (float)(v68 * v91)) + (float)(v71 * v90);
      float v98 = (float)(v66 * *v25) + (float)(v69 * v96);
      float v99 = v93 + (float)(v72 * v90);
      float v100 = (float)(v67 * *v25) + (float)(v70 * v96);
      float v101 = (float)((float)(v64 * *v25) + (float)(v68 * v96)) + (float)(v71 * v36);
      float v102 = v98 + (float)(v72 * v36);
      float v103 = v100 + (float)(v75 * v36);
      float v104 = (float)(v64 * v85) + (float)(v68 * v99);
      float v105 = (float)((float)(v64 * v83) + (float)(v68 * v97)) + (float)(v71 * v101);
      float v106 = (float)((float)(v64 * v84) + (float)(v68 * v94)) + (float)(v71 * v103);
      float v107 = v104 + (float)(v71 * v102);
      float v108 = (float)((float)(v66 * v83) + (float)(v69 * v97)) + (float)(v72 * v101);
      float v109 = (float)((float)(v66 * v85) + (float)(v69 * v99)) + (float)(v72 * v102);
      float v110 = (float)((float)(v66 * v84) + (float)(v69 * v94)) + (float)(v72 * v103);
      float v111 = v70 * v97;
      float v112 = v70 * v99;
      float v113 = v70 * v94;
      float v22 = v40;
      float v114 = (float)(v67 * v83) + v111;
      float v115 = (float)(v67 * v85) + v112;
      float v116 = v75 * v101;
      float v117 = v75 * v102;
      float v118 = v75 * v103;
      float v119 = v147;
      float v120 = v114 + v116;
      float v121 = v115 + v117;
      float v122 = (float)((float)(v67 * v84) + v113) + v118;
      float v123 = v40 - v92;
      float v124 = v146;
      float v125 = v146 - (float)(v26[2] + v60);
      float v126 = v147 - v95;
      float v127 = v125 * 0.0;
      float v128 = v126 * v126;
      float v129 = (float)((float)(v126 * 0.0) - (float)(v126 * 0.0)) - (float)(v125 * v123);
      float v130 = (float)(v125 * 0.0) - (float)(v126 * v123);
      float v131 = v126 * v125;
      float v132 = v125 * v125;
      float v133 = v130 - v127;
      float v134 = v123 * v123;
      float v135 = (float)(v123 * 0.0) + (float)((float)(v123 * -0.0) - v131);
      float v136 = v128 + v132;
      float v137 = v128 + v134;
      float v138 = v132 + v134;
      float v139 = v25[6];
      float v140 = v129 * v139;
      float v141 = v133 * v139;
      float v142 = v135 * v139;
      float v27 = v27 + (float)((float)(v136 * v139) + v105);
      float v143 = v89;
      float v21 = 1.0;
      float v28 = v28 + (float)(v140 + v107);
      float v29 = v29 + (float)(v141 + v106);
      float v30 = v30 + (float)(v140 + v108);
      float v31 = v148 + (float)((float)(v137 * v139) + v109);
      float v32 = v32 + (float)(v142 + v110);
      float v33 = v143 + (float)(v141 + v120);
      float v34 = v149 + (float)(v142 + v121);
      float v35 = v150 + (float)((float)(v138 * v139) + v122);
      v25 += 13;
      v26 += 7;
      --v4;
    }
    while (v4);
    float v144 = v145;
  }
  else
  {
    float v119 = 0.0;
    float v124 = 0.0;
    float v22 = 0.0;
    float v144 = 0.0;
    float v35 = 0.0;
    float v34 = 0.0;
    float v33 = 0.0;
    float v32 = 0.0;
    float v31 = 0.0;
    float v30 = 0.0;
    float v29 = 0.0;
    float v28 = 0.0;
    float v27 = 0.0;
  }
  *a4 = v27;
  a4[1] = v28;
  a4[2] = v29;
  a4[3] = v30;
  a4[4] = v31;
  a4[5] = v32;
  a4[6] = v33;
  a4[7] = v34;
  a4[8] = v35;
  a4[9] = v22;
  a4[10] = v124;
  a4[11] = v119;
  a4[12] = v144;
  return result;
}

uint64_t re::CompoundShape::type(re::CompoundShape *this)
{
  return 7;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

void re::Event<re::GeometricObjectBase>::removeSubscription(uint64_t a1, long long *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      long long v4 = a2[1];
      long long v6 = *a2;
      long long v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 40), (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((void *)a1, a2);
    }
  }
}

float re::PhysXConeShape::height(re::PhysXConeShape *this)
{
  return *((float *)this + 8);
}

float re::PhysXConeShape::radius(re::PhysXConeShape *this)
{
  return *((float *)this + 7);
}

double re::PhysXConeShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  long long v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((void *)&v18 + 1);
  uint64_t v19 = *a2;
  int v20 = *((_DWORD *)a2 + 2);
  v15.i64[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  double result = *(double *)v21;
  *(void *)&long long v17 = *(void *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXConeShape::~PhysXConeShape(re::PhysXConeShape *this)
{
}

uint64_t re::ConeShape::type(re::ConeShape *this)
{
  return 9;
}

float re::CapsuleShape::massProperties(uint64_t a1, _DWORD *a2, void *a3, uint64_t a4)
{
  (*(void (**)(float32x4_t *__return_ptr))(*(void *)a1 + 16))(v11);
  float32x4_t v7 = vsubq_f32(v11[1], v11[0]);
  v7.i32[3] = 0;
  float32x4_t v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  float32x4_t v9 = vmulq_f32(v8, v8);
  v8.f32[0] = vmulq_laneq_f32(vmulq_lane_f32(v8, *(float32x2_t *)v8.f32, 1), v8, 2).f32[0];
  *a2 = v8.i32[0];
  v8.f32[0] = v8.f32[0] / 12.0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 4) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = (float)(v9.f32[1] + v9.f32[2]) * v8.f32[0];
  *(float *)(a4 + 20) = (float)(v9.f32[0] + v9.f32[2]) * v8.f32[0];
  float result = vaddv_f32(*(float32x2_t *)v9.f32) * v8.f32[0];
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::PhysXIndexedTriangleMesh::PhysXIndexedTriangleMesh(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  uint64_t v5 = (*(unsigned int (**)(uint64_t))(*(void *)a2 + 48))(a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
  uint64_t v7 = 3 * (*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a2 + 96))(&v10, a2);
  if ((v10 & 2) != 0) {
    char v8 = 1;
  }
  else {
    char v8 = 2;
  }
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = 12;
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 58) = v8;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v6;
  *(void *)a1 = &unk_26E6DD398;
  *(void *)(a1 + 64) = a2;
  return a1;
}

uint64_t re::PhysXIndexedTriangleMesh::materialIndexForTriangle(re::PhysXIndexedTriangleMesh *this)
{
  (*(uint64_t (**)(void))(**((void **)this + 8) + 104))(*((void *)this + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**((void **)this + 8) + 112);
  return v2();
}

void re::PhysXIndexedTriangleMesh::~PhysXIndexedTriangleMesh(re::PhysXIndexedTriangleMesh *this)
{
  *(void *)this = &unk_26E6DD398;
  uint64_t v2 = (void (***)(void))*((void *)this + 8);
  if (v2) {
    (**v2)(v2);
  }
  re::IndexedTriangleMesh::~IndexedTriangleMesh(this);
}

{
  void (***v2)(void);
  uint64_t vars8;

  *(void *)this = &unk_26E6DD398;
  uint64_t v2 = (void (***)(void))*((void *)this + 8);
  if (v2) {
    (**v2)(v2);
  }
  re::IndexedTriangleMesh::~IndexedTriangleMesh(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6DD3D8;
  if (a2)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a2 + 112))(&v7, a2);
    float v4 = v9 - *(float *)&v7;
    float v5 = v10 - *((float *)&v7 + 1);
    if ((float)(v10 - *((float *)&v7 + 1)) >= (float)(v11 - v8)) {
      float v5 = v11 - v8;
    }
    if (v4 >= v5) {
      float v4 = v5;
    }
  }
  else
  {
    float v4 = 0.0;
  }
  *(float *)(a1 + 16) = v4;
  *(void *)a1 = &unk_26E6DD3D8;
  *(void *)(a1 + 8) = a1 + 24;
  *(_DWORD *)(a1 + 24) = 4;
  *(_OWORD *)(a1 + 28) = xmmword_2343679C0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 1065353216;
  *(void *)(a1 + 56) = a2;
  *(unsigned char *)(a1 + 64) = 1;
  *(_WORD *)(a1 + 65) = 0;
  *(unsigned char *)(a1 + 67) = 0;
  return a1;
}

void re::PhysXConvexPolyhedronShape::aabb(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, int32x4_t *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  if (*(void *)(a1 + 56))
  {
    long long v18 = *((_OWORD *)a2 + 1);
    v15.i64[1] = *((void *)&v18 + 1);
    uint64_t v19 = *a2;
    int v20 = *((_DWORD *)a2 + 2);
    v15.i64[0] = 0;
    a8.i32[0] = 1.0;
    physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
    int32x4_t v16 = *(int32x4_t *)v21;
    v17.i64[0] = *(void *)&v21[12];
    v17.i32[2] = v22;
  }
  else
  {
    int32x4_t v16 = vdupq_n_s32(0x7F800000u);
    v17.i64[0] = 0x7F0000007FLL;
    v17.i64[1] = 0x7F0000007FLL;
  }
  *a7 = v16;
  a7[1] = v17;
}

double re::PhysXConvexPolyhedronShape::massProperties(uint64_t a1, _DWORD *a2, uint64_t a3, _OWORD *a4)
{
  if (*(void *)(a1 + 56))
  {
    physx::PxMassProperties::PxMassProperties((uint64_t)v10, a1 + 24);
    *a2 = *(_DWORD *)&v10[48];
    long long v7 = *(_OWORD *)&v10[12];
    long long v8 = *(_OWORD *)&v10[24];
    *a4 = *(_OWORD *)v10;
    a4[1] = v7;
    a4[2] = v8;
    double result = *(double *)&v10[36];
    *(_OWORD *)a3 = *(_OWORD *)&v10[36];
  }
  else
  {
    double result = 0.0;
    a4[1] = 0u;
    a4[2] = 0u;
    *a4 = 0u;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *a2 = 897988541;
  }
  return result;
}

uint64_t re::PhysXConvexPolyhedronShape::vertices(re::PhysXConvexPolyhedronShape *this)
{
  uint64_t result = *((void *)this + 7);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t re::PhysXConvexPolyhedronShape::vertexStride(re::PhysXConvexPolyhedronShape *this)
{
  if (*((void *)this + 7)) {
    return 12;
  }
  else {
    return 0;
  }
}

uint64_t re::PhysXConvexPolyhedronShape::vertexCount(re::PhysXConvexPolyhedronShape *this)
{
  uint64_t result = *((void *)this + 7);
  if (result) {
    return (*(unsigned int (**)(uint64_t))(*(void *)result + 48))(result);
  }
  return result;
}

unint64_t re::PhysXConvexPolyhedronShape::dumpTriangles(re::PhysXConvexPolyhedronShape *this, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t v4 = *((void *)this + 7);
  if (!v4) {
    return 0;
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 72))(v4);
  if (v7)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    do
    {
      (*(void (**)(void, uint64_t, unsigned char *))(**((void **)this + 7) + 80))(*((void *)this + 7), v8, v22);
      int v9 = v9 + v23 - 2;
      uint64_t v8 = (v8 + 1);
    }
    while (v7 != v8);
    unint64_t v10 = (3 * v9);
    if (!a2) {
      return v10;
    }
  }
  else
  {
    unint64_t v10 = 0;
    if (!a2) {
      return v10;
    }
  }
  if (v10 > a3) {
    return 0;
  }
  uint64_t v12 = (*(uint64_t (**)(void))(**((void **)this + 7) + 64))(*((void *)this + 7));
  if (v7)
  {
    uint64_t v13 = v12;
    uint64_t v14 = 0;
    int v15 = 0;
    uint64_t v16 = v12 + 2;
    do
    {
      (*(void (**)(void, uint64_t, unsigned char *))(**((void **)this + 7) + 80))(*((void *)this + 7), v14, v22);
      if (v23 >= 3uLL)
      {
        uint64_t v17 = v24;
        int v18 = 3 * v15;
        uint64_t v19 = (unsigned __int8 *)(v16 + v24);
        uint64_t v20 = v23 - 1 - 1;
        int v15 = v15 + v23 - 2;
        do
        {
          a2[v18] = *(unsigned __int8 *)(v13 + v17);
          a2[v18 + 1] = *(v19 - 1);
          unsigned __int16 v21 = *v19++;
          a2[v18 + 2] = v21;
          v18 += 3;
          --v20;
        }
        while (v20);
      }
      uint64_t v14 = (v14 + 1);
    }
    while (v14 != v7);
  }
  return v10;
}

void re::PhysXConvexPolyhedronShape::~PhysXConvexPolyhedronShape(re::PhysXConvexPolyhedronShape *this)
{
}

uint64_t re::ConvexPolyhedronShape::type(re::ConvexPolyhedronShape *this)
{
  return 5;
}

uint64_t physx::PxMassProperties::PxMassProperties(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0xFFFFFFFF:
    case 1:
    case 5:
    case 6:
    case 7:
      *(_OWORD *)a1 = xmmword_23435FD50;
      *(_OWORD *)(a1 + 16) = xmmword_23435FD50;
      *(_OWORD *)(a1 + 32) = xmmword_23435FD50;
      *(_DWORD *)(a1 + 48) = 1065353216;
      break;
    case 0:
      float v4 = *(float *)(a2 + 4);
      float v5 = v4 * (float)(v4 * (float)(v4 * 4.1888));
      *(float *)(a1 + 48) = v5;
      float v6 = v4 * (float)(v4 * (float)(v5 * 0.4));
      *(float *)a1 = v6;
      *(void *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(float *)(a1 + 16) = v6;
      *(void *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(float *)(a1 + 32) = v6;
      *(void *)(a1 + 36) = 0;
      goto LABEL_5;
    case 2:
      float v7 = *(float *)(a2 + 4);
      float v8 = *(float *)(a2 + 8);
      *(float *)(a1 + 48) = v7 * (float)(v7 * (float)((float)((float)(v8 + v8) + (float)(v7 * 1.3333)) * 3.1416));
      float v9 = v7 * (float)(v7 * v7);
      float v10 = v7 * (float)(v7 * v8);
      *(float *)a1 = v7 * (float)(v7 * (float)((float)(v10 + (float)(v9 * 0.53333)) * 3.1416));
      *(void *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      float v11 = v7
          * (float)(v7
                  * (float)((float)((float)((float)((float)(v10 * 1.5) + (float)(v9 * 0.53333))
                                          + (float)((float)(v7 * (float)(v8 * v8)) * 1.3333))
                                  + (float)((float)(v8 * (float)(v8 * v8)) * 0.66667))
                          * 3.1416));
      *(float *)(a1 + 16) = v11;
      *(void *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(float *)(a1 + 32) = v11;
      *(void *)(a1 + 36) = 0;
LABEL_5:
      *(_DWORD *)(a1 + 44) = 0;
      break;
    case 3:
      float v12 = *(float *)(a2 + 4);
      float v13 = *(float *)(a2 + 8);
      float v14 = *(float *)(a2 + 12);
      float v15 = (float)((float)(v12 * v13) * v14) * 8.0;
      *(float *)(a1 + 48) = v15;
      float v16 = v12 * v12;
      float v17 = v13 * v13;
      float v18 = v14 * v14;
      float v19 = v15 / 3.0;
      *(float *)a1 = (float)(v17 + v18) * v19;
      *(float *)(a1 + 4) = v19 * 0.0;
      *(float *)(a1 + 8) = v19 * 0.0;
      *(float *)(a1 + 12) = v19 * 0.0;
      *(float *)(a1 + 16) = (float)(v16 + v18) * v19;
      *(float *)(a1 + 20) = v19 * 0.0;
      *(float *)(a1 + 24) = v19 * 0.0;
      *(float *)(a1 + 28) = v19 * 0.0;
      *(float *)(a1 + 32) = (float)(v16 + v17) * v19;
      *(void *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 36) = 0;
      break;
    case 4:
      float v47 = 0.0;
      (*(void (**)(void, float *, float *, float *))(**(void **)(a2 + 32) + 104))(*(void *)(a2 + 32), &v47, v57, &v58);
      float v21 = v59;
      float v20 = v60;
      float v22 = v58;
      float v56 = v57[8] - (float)(v47 * (float)((float)(v21 * v21) + (float)(v22 * v22)));
      float v48 = v57[0] - (float)(v47 * (float)((float)(v20 * v20) + (float)(v21 * v21)));
      float v49 = v57[1] + (float)(v47 * (float)(v59 * v58));
      float v52 = v57[4] - (float)(v47 * (float)((float)(v22 * v22) + (float)(v20 * v20)));
      float v53 = v57[5] + (float)(v47 * (float)(v59 * v60));
      float v54 = v57[2] + (float)(v47 * (float)(v60 * v58));
      float v55 = v53;
      float v24 = *(float *)(a2 + 16);
      unsigned __int16 v23 = (float *)(a2 + 16);
      float v25 = *(v23 - 3);
      float v50 = v54;
      float v51 = v49;
      float v26 = *(v23 - 2);
      float v27 = *(v23 - 1);
      *(float *)(a1 + 48) = (float)((float)(v47 * v25) * v26) * v27;
      float v28 = v22 + v22;
      float v29 = v21 + v21;
      float v30 = v20 + v20;
      float v32 = v23[2];
      float v31 = v23[3];
      float v33 = (float)(v31 * v31) + -0.5;
      float v34 = v23[1];
      float v35 = (float)((float)(v29 * v34) + (float)(v24 * v28)) + (float)(v32 * v30);
      float v36 = (float)((float)(v31 * (float)((float)(v34 * v30) - (float)(v32 * v29))) + (float)(v28 * v33))
          + (float)(v24 * v35);
      float v37 = (float)((float)(v31 * (float)((float)(v32 * v28) - (float)(v24 * v30))) + (float)(v29 * v33))
          + (float)(v34 * v35);
      float v38 = (float)((float)(v31 * (float)((float)(v24 * v29) - (float)(v34 * v28))) + (float)(v30 * v33))
          + (float)(v32 * v35);
      float v39 = (float)(v25 * v36) + (float)(v25 * v36);
      float v40 = (float)(v26 * v37) + (float)(v26 * v37);
      float v41 = (float)(v27 * v38) + (float)(v27 * v38);
      float v42 = (float)((float)(v34 * v40) + (float)(v24 * v39)) + (float)(v32 * v41);
      *(float *)(a1 + 36) = (float)((float)(v39 * v33) - (float)((float)((float)(v34 * v41) - (float)(v32 * v40)) * v31))
                          + (float)(v24 * v42);
      *(float *)(a1 + 40) = (float)((float)(v40 * v33) - (float)((float)((float)(v32 * v39) - (float)(v24 * v41)) * v31))
                          + (float)(v34 * v42);
      *(float *)(a1 + 44) = (float)((float)(v41 * v33) - (float)((float)((float)(v24 * v40) - (float)(v34 * v39)) * v31))
                          + (float)(v32 * v42);
      physx::PxMassProperties::scaleInertia(&v48, v23, v23 - 3, (float *)v45);
      long long v43 = v45[1];
      *(_OWORD *)a1 = v45[0];
      *(_OWORD *)(a1 + 16) = v43;
      *(_DWORD *)(a1 + 32) = v46;
      break;
    default:
      return a1;
  }
  return a1;
}

float physx::PxMassProperties::scaleInertia@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X8>)
{
  float v4 = *a2;
  float v5 = a2[1];
  float v7 = a2[2];
  float v6 = a2[3];
  float v8 = v5 * (float)(v5 + v5);
  float v9 = v7 * (float)(v7 + v7);
  float v10 = (float)(v4 + v4) * v5;
  float v11 = (float)(v4 + v4) * v7;
  float v12 = (float)(v4 + v4) * v6;
  float v13 = (float)(v5 + v5) * v7;
  float v14 = (float)(v5 + v5) * v6;
  float v15 = (float)(v7 + v7) * v6;
  float v16 = (float)(1.0 - v8) - v9;
  float v17 = v10 + v15;
  float v18 = v11 - v14;
  float v19 = v10 - v15;
  float v20 = 1.0 - (float)(v4 * (float)(v4 + v4));
  float v21 = v20 - v9;
  float v22 = v13 + v12;
  float v23 = v11 + v14;
  float v24 = v13 - v12;
  float v25 = v20 - v8;
  float v26 = a1[1];
  float v27 = (float)(*a1 * v16) + (float)(v19 * v26);
  float v28 = (float)(*a1 * v17) + (float)(v21 * v26);
  float v29 = (float)(*a1 * v18) + (float)(v22 * v26);
  float v30 = a1[2];
  float v31 = a1[3];
  float v32 = v27 + (float)(v23 * v30);
  float v33 = v28 + (float)(v24 * v30);
  float v34 = v29 + (float)(v25 * v30);
  float v35 = a1[4];
  float v36 = a1[5];
  float v37 = (float)((float)(v16 * v31) + (float)(v19 * v35)) + (float)(v23 * v36);
  float v38 = (float)((float)(v17 * v31) + (float)(v21 * v35)) + (float)(v24 * v36);
  float v39 = (float)((float)(v18 * v31) + (float)(v22 * v35)) + (float)(v25 * v36);
  float v40 = a1[6];
  float v41 = a1[7];
  float v42 = (float)(v16 * v40) + (float)(v19 * v41);
  float v43 = (float)(v17 * v40) + (float)(v21 * v41);
  float v44 = (float)(v18 * v40) + (float)(v22 * v41);
  float v45 = a1[8];
  float v46 = v43 + (float)(v24 * v45);
  float v47 = v44 + (float)(v25 * v45);
  float v48 = (float)(v16 * v32) + (float)(v19 * v37);
  float v49 = (float)(v16 * v33) + (float)(v19 * v38);
  float v50 = (float)(v16 * v34) + (float)(v19 * v39);
  float v51 = v48 + (float)(v23 * (float)(v42 + (float)(v23 * v45)));
  float v52 = v49 + (float)(v23 * v46);
  float v53 = v50 + (float)(v23 * v47);
  float v54 = v17 * v33;
  float v55 = (float)(v17 * v34) + (float)(v21 * v39);
  float v56 = (float)(v54 + (float)(v21 * v38)) + (float)(v24 * v46);
  float v57 = v55 + (float)(v24 * v47);
  float v58 = (float)((float)(v18 * v34) + (float)(v22 * v39)) + (float)(v25 * v47);
  float v59 = (float)((float)(v56 * 0.5) + (float)(v51 * 0.5)) + (float)(v58 * 0.5);
  float v60 = v59 - v56;
  float v61 = a3[1];
  float v62 = a3[2];
  float v63 = *a3 * (float)(*a3 * (float)(v59 - v51));
  float v64 = v61 * (float)(v61 * v60);
  float v65 = v62 * (float)(v62 * (float)(v59 - v58));
  float v66 = v64 + v65;
  float v67 = v65 + v63;
  float v68 = v63 + v64;
  float v69 = v61 * (float)(*a3 * v52);
  float v70 = v62 * (float)(v61 * v57);
  float v71 = (float)(*a3 * v61) * v62;
  float v72 = v71 * v66;
  float v73 = v71 * v69;
  float v74 = v71 * (float)(v62 * (float)(*a3 * v53));
  float v75 = v71 * v67;
  float v76 = v71 * v70;
  float v77 = v71 * v68;
  float v78 = (float)-*a2 - *a2;
  float v79 = (float)-v5 - v5;
  float v80 = (float)-v7 - v7;
  float v81 = -(float)(v5 * v79);
  float v82 = -(float)(v7 * v80);
  float v83 = -(float)(v5 * v78);
  float v84 = -(float)(v7 * v78);
  float v85 = v78 * v6;
  float v86 = -(float)(v7 * v79);
  float v87 = v79 * v6;
  float v88 = v80 * v6;
  float v89 = (float)(1.0 - v81) - v82;
  float v90 = v83 + v88;
  float v91 = v84 - v87;
  float v92 = v83 - v88;
  float v93 = (float)(*a2 * v78) + 1.0;
  float v94 = v93 - v82;
  float v95 = v86 + v85;
  float v96 = v84 + v87;
  float v97 = v86 - v85;
  float v98 = v93 - v81;
  float v99 = (float)((float)(v84 + v87) * v74) + (float)((float)(v92 * v73) + (float)(v89 * v72));
  float v100 = (float)((float)(v86 - v85) * v74) + (float)((float)(v94 * v73) + (float)(v90 * v72));
  float v101 = (float)(v98 * v74) + (float)((float)((float)(v86 + v85) * v73) + (float)((float)(v84 - v87) * v72));
  float v102 = (float)(v89 * v73) + (float)(v92 * v75);
  float v103 = (float)(v90 * v73) + (float)(v94 * v75);
  float v104 = (float)(v91 * v73) + (float)(v95 * v75);
  float v105 = (float)(v96 * v76) + v102;
  float v106 = (float)(v97 * v76) + v103;
  float v107 = (float)(v98 * v76) + v104;
  float v108 = v90 * v74;
  float v109 = v94 * v76;
  float v110 = (float)(v89 * v74) + (float)(v92 * v76);
  float v111 = (float)(v91 * v74) + (float)(v95 * v76);
  float v112 = v110 + (float)(v96 * v77);
  float v113 = (float)(v108 + v109) + (float)(v97 * v77);
  float v114 = v111 + (float)(v98 * v77);
  float v115 = (float)(v96 * v112) + (float)((float)(v89 * v99) + (float)(v92 * v105));
  float v116 = (float)(v96 * v113) + (float)((float)(v89 * v100) + (float)(v92 * v106));
  float v117 = (float)(v96 * v114) + (float)((float)(v89 * v101) + (float)(v92 * v107));
  float v118 = (float)(v90 * v99) + (float)(v94 * v105);
  float v119 = (float)(v90 * v100) + (float)(v94 * v106);
  float v120 = (float)(v90 * v101) + (float)(v94 * v107);
  float v121 = (float)(v97 * v112) + v118;
  float v122 = (float)(v97 * v113) + v119;
  float v123 = (float)(v97 * v114) + v120;
  float v124 = v91 * v99;
  float v125 = v91 * v100;
  float v126 = v91 * v101;
  float v127 = v95 * v105;
  float v128 = v95 * v106;
  float v129 = v126 + (float)(v95 * v107);
  float v130 = (float)(v98 * v112) + (float)(v124 + v127);
  float v131 = (float)(v98 * v113) + (float)(v125 + v128);
  *a4 = v115;
  a4[1] = v116;
  a4[2] = v117;
  a4[3] = v121;
  a4[4] = v122;
  a4[5] = v123;
  float result = (float)(v98 * v114) + v129;
  a4[6] = v130;
  a4[7] = v131;
  a4[8] = result;
  return result;
}

void *re::IndexedTriangleMesh::freeData(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[6];
  if (v2)
  {
    uint64_t v3 = re::globalAllocators((re *)this);
    this = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3[2] + 40))(v3[2], v2);
  }
  uint64_t v4 = v1[2];
  if (v4)
  {
    float v5 = re::globalAllocators((re *)this);
    this = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5[2] + 40))(v5[2], v4);
  }
  if (v1[1])
  {
    float v6 = *(uint64_t (**)(void))(*(void *)re::globalAllocators((re *)this)[2] + 40);
    return (void *)v6();
  }
  return this;
}

BOOL re::IndexedTriangleMesh::isValid(re::IndexedTriangleMesh *this)
{
  if (!*((void *)this + 1)) {
    return 0;
  }
  if (!*((void *)this + 2)) {
    return 0;
  }
  unint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  BOOL result = 0;
  unint64_t v4 = *((void *)this + 5);
  if (v4 && !(v4 % 3))
  {
    int v5 = *((unsigned __int8 *)this + 58);
    BOOL v6 = HIDWORD(v2) == 0;
    BOOL v7 = v2 < 0x10000;
    if (v5 != 1) {
      BOOL v7 = 0;
    }
    if (v5 == 2) {
      return v6;
    }
    else {
      return v7;
    }
  }
  return result;
}

void re::IndexedTriangleMesh::~IndexedTriangleMesh(re::IndexedTriangleMesh *this)
{
  *(void *)this = &unk_26E6DD478;
  if (*((void *)this + 1))
  {
    if (*((_WORD *)this + 28)) {
      re::IndexedTriangleMesh::freeData(this);
    }
  }
}

float re::BoxShape::massProperties(uint64_t a1, float *a2, void *a3, uint64_t a4)
{
  v7.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  v7.i64[1] = v8;
  float32x4_t v9 = vmulq_f32(v7, v7);
  float v10 = vmuls_lane_f32(vmuls_lane_f32(v7.f32[0], *(float32x2_t *)v7.f32, 1), v7, 2);
  *a2 = v10;
  float v11 = v10 / 12.0;
  *(void *)(a4 + 4) = 0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = (float)(v9.f32[1] + v9.f32[2]) * v11;
  *(float *)(a4 + 20) = (float)(v9.f32[0] + v9.f32[2]) * v11;
  float result = vaddv_f32(*(float32x2_t *)v9.f32) * v11;
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::BoxShape::type(re::BoxShape *this)
{
  return 3;
}

float re::CylinderShape::massProperties(uint64_t a1, float *a2, void *a3, uint64_t a4)
{
  float v8 = (*(float (**)(uint64_t))(*(void *)a1 + 64))(a1);
  float v9 = (*(float (**)(uint64_t))(*(void *)a1 + 72))(a1);
  float v10 = v9 * v9;
  float v11 = v8 * (float)(v10 * 3.1416);
  *a2 = v11;
  float v12 = (float)((float)(v8 * v8) + (float)(v10 * 3.0)) * (float)(v11 * 0.083333);
  *(void *)(a4 + 4) = 0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = v12;
  float result = v10 * (float)(v11 * 0.5);
  *(float *)(a4 + 20) = result;
  *(float *)(a4 + 40) = v12;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::CylinderShape::type(re::CylinderShape *this)
{
  return 8;
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::addHit(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(*(void *)(a1 + 96));
  *(void *)uint64_t v4 = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_DWORD *)(v4 + 48) = 2139095039;
  *(void *)(v4 + 52) = 0xFFFFFFFF00000000;
  *(void *)(v4 + 64) = 0;
  uint64_t v6 = *(void *)(a1 + 96);
  uint64_t v7 = *(void *)(v6 + 40);
  if (v7)
  {
    unint64_t v8 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v6, v7 - 1);
    *(float *)(v8 + 48) = *(float *)(a2 + 48) / *(float *)(a1 + 2156);
    *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 36);
    uint64_t v9 = *(void *)(*(void *)a2 + 16);
    *(void *)unint64_t v8 = v9;
    *(_DWORD *)(v8 + 52) = re::internal::nvphysx::findShapeIndex(v9, *(void *)(a2 + 8));
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 64))(*(void *)(a2 + 8));
    if (result == 5)
    {
      int v12 = 5;
      long long v13 = xmmword_2343679C0;
      int v14 = 0;
      int v15 = 0;
      uint64_t v16 = 1065353216;
      uint64_t v17 = 0;
      (*(void (**)(void, int *))(**(void **)(a2 + 8) + 128))(*(void *)(a2 + 8), &v12);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 104))(v17);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 104))(v17);
        float v11 = (_DWORD *)(result + 4 * *(unsigned int *)(a2 + 16));
      }
      else
      {
        float v11 = (_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v8 + 56) = *v11;
      *(void *)(v8 + 64) = *(void *)(a2 + 52);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::PhysXCollisionWorld(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)(a1 + 44) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 108) = 0x7FFFFFFFLL;
  *(void *)(a1 + 120) = a1;
  *(void *)(a1 + 128) = a1;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = a3;
  *(void *)a1 = &unk_26E6DD4E0;
  uint64_t v6 = a1 + 176;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 1;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 200) = 0;
  re::BucketArray<re::PhysXManifold,256ul>::init(a1 + 176, a2, 1uLL);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32, 8);
  *(void *)uint64_t v7 = &unk_26E6DE168;
  *(void *)(v7 + 8) = v6;
  *(void *)(v7 + 16) = v5;
  *(unsigned char *)(v7 + 24) = 0;
  *(void *)(a1 + 232) = v7;
  *(void *)(a1 + 240) = a2;
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 272) = xmmword_23435FD50;
  *(_OWORD *)(a1 + 288) = xmmword_23435FD60;
  *(_OWORD *)(a1 + 304) = xmmword_23435FD80;
  *(_OWORD *)(a1 + 320) = xmmword_23435FBB0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_DWORD *)(a1 + 368) = 1036831949;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 387) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  return a1;
}

void re::PhysXCollisionWorld::~PhysXCollisionWorld(re::PhysXCollisionWorld *this)
{
  re::PhysXCollisionWorld::deinit(this);
  (*(void (**)(void, void))(**((void **)this + 30) + 40))(*((void *)this + 30), *((void *)this + 29));
  re::PhysXDebugRenderer::deinit((const void **)this + 32);
  uint64_t v2 = *((void *)this + 27);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::PhysXManifold,256ul>::operator[]((uint64_t)this + 176, i);
      re::DynamicArray<unsigned long>::deinit(v4 + 16);
    }
  }
  while (*((void *)this + 23))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 22);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 176);
  *((void *)this + 27) = 0;
  ++*((_DWORD *)this + 56);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 176);
  uint64_t v5 = (void (***)(void))*((void *)this + 20);
  if (v5) {
    (**v5)(v5);
  }
  uint64_t v6 = *((void *)this + 19);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  re::CollisionWorld::~CollisionWorld(this);
}

{
  uint64_t vars8;

  re::PhysXCollisionWorld::~PhysXCollisionWorld(this);
  JUMPOUT(0x237DBCBD0);
}

void re::PhysXCollisionWorld::deinit(re::PhysXCollisionWorld *this)
{
  if (*((void *)this + 7))
  {
    re::PhysXDebugRenderer::deinit((const void **)this + 32);
    uint64_t v2 = (void (***)(void))*((void *)this + 20);
    if (v2) {
      (**v2)(v2);
    }
    *((void *)this + 20) = 0;
    uint64_t v3 = *((void *)this + 21);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 7);
      (*(void (**)(void))(*(void *)v3 + 16))(*((void *)this + 21));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v3);
      uint64_t v5 = *((void *)this + 19);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
    }
    *((void *)this + 19) = 0;
    if (*((void *)this + 7))
    {
      if (*((void *)this + 9)) {
        re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this + 9);
      }
      *((void *)this + 7) = 0;
    }
  }
}

uint64_t re::QueryFilterCallback::preFilter(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a3 + 192))(&v5, a3);
  if ((v7 & a1[4]) != 0 && (a1[5] & v6) != 0) {
    return a1[6];
  }
  else {
    return 0;
  }
}

uint64_t re::PhysXCollisionWorld::setCollisionFlags(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 384) != a2)
  {
    uint64_t v3 = result;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(result + 152) + 488))(&v5);
    v4.i64[0] = v5;
    v4.i32[2] = v6;
    float32x4_t v7 = v4;
    return re::PhysXCollisionWorld::createScene(v3, &v7, a2);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::createScene(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  if (physx::shdfnd::g_isLockingEnabled) {
    int v6 = 1;
  }
  else {
    int v6 = physx::shdfnd::g_alwaysUseLocking;
  }
  int v63 = v6;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  float v97 = 0;
  unint64_t v98 = 0;
  int v99 = 1;
  unint64_t v100 = 0;
  float v101 = 0;
  uint64_t v7 = *(void *)(a1 + 160);
  if (v7)
  {
    unint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
    if (v8)
    {
      unint64_t v9 = v8;
      re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(&v97, v9);
      char v10 = v99;
      v99 += 2;
      BOOL v11 = (v10 & 1) == 0;
      unint64_t v12 = 4;
      if (v11) {
        unint64_t v12 = v100;
      }
      if (v12 < v9) {
        re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(&v97, v9);
      }
      unint64_t v13 = v9 - v98;
      if (v9 > v98)
      {
        unint64_t v14 = v98 << 6;
        do
        {
          if (v99) {
            int v15 = &v100;
          }
          else {
            int v15 = v101;
          }
          uint64_t v16 = (char *)v15 + v14;
          *(void *)uint64_t v16 = 0;
          *((_OWORD *)v16 + 1) = 0uLL;
          *((_OWORD *)v16 + 2) = 0uLL;
          *((void *)v16 + 6) = 0;
          v14 += 64;
          --v13;
        }
        while (v13);
      }
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      unint64_t v98 = v9;
      v99 += 2;
      while (1)
      {
        uint64_t v19 = (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 160) + 24))(*(void *)(a1 + 160), v18);
        uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 160))(v19);
        unint64_t v21 = v98;
        if (v98 <= v18) {
          break;
        }
        if (v99) {
          float v22 = &v100;
        }
        else {
          float v22 = v101;
        }
        v22[v17] = v20;
        if (v99) {
          float v23 = &v100;
        }
        else {
          float v23 = v101;
        }
        float v24 = &v23[v17];
        uint64_t v25 = *(void *)(v23[v17] + 56);
        unint64_t v66 = 0;
        (*(void (**)(uint64_t, unint64_t *, uint64_t, void))(*(void *)v25 + 216))(v25, &v66, 1, 0);
        v24[6] = v66;
        if (v99) {
          float v26 = &v100;
        }
        else {
          float v26 = v101;
        }
        float v27 = &v26[v17];
        v27[2] = (*(uint64_t (**)(unint64_t))(*(void *)v26[v17] + 88))(v26[v17]);
        v27[3] = v28;
        unint64_t v21 = v98;
        if (v98 <= v18) {
          goto LABEL_93;
        }
        if (v99) {
          float v29 = &v100;
        }
        else {
          float v29 = v101;
        }
        float v30 = &v29[v17];
        v30[4] = (*(uint64_t (**)(unint64_t))(*(void *)v29[v17] + 160))(v29[v17]);
        v30[5] = v31;
        ++v18;
        v17 += 8;
        if (v9 == v18) {
          goto LABEL_35;
        }
      }
      uint64_t v67 = 0;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v68 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v95 = 136315906;
      *(void *)&v95[4] = "operator[]";
      *(_WORD *)&v95[12] = 1024;
      *(_DWORD *)&v95[14] = 858;
      *(_WORD *)&v95[18] = 2048;
      *(void *)float v96 = v18;
      *(_WORD *)&v96[8] = 2048;
      *(void *)&v96[10] = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_93:
      uint64_t v67 = 0;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v68 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v95 = 136315906;
      *(void *)&v95[4] = "operator[]";
      *(_WORD *)&v95[12] = 1024;
      *(_DWORD *)&v95[14] = 858;
      *(_WORD *)&v95[18] = 2048;
      *(void *)float v96 = v18;
      *(_WORD *)&v96[8] = 2048;
      *(void *)&v96[10] = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_35:
    (*(void (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160));
    float v32 = *(void (****)(void))(a1 + 160);
    if (v32) {
      (**v32)(v32);
    }
    *(void *)(a1 + 160) = 0;
  }
  *(void *)float v95 = 0;
  *(void *)&v95[8] = 0;
  *(_DWORD *)&v95[16] = 1;
  *(void *)&v96[4] = 0;
  *(void *)&v96[12] = 0;
  uint64_t v33 = *(void *)(a1 + 152);
  if (v33)
  {
    __int16 v65 = 3;
    float v34 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v33 + 152))(v33, &v65);
    unint64_t v35 = v34;
    if (*(void *)&v95[8] >= (unint64_t)v34)
    {
      if (*(void *)&v95[8] <= (unint64_t)v34)
      {
        char v37 = v95[16];
LABEL_55:
        uint64_t v41 = *(void *)(a1 + 152);
        __int16 v64 = 3;
        if (v37) {
          float v42 = &v96[4];
        }
        else {
          float v42 = *(unsigned char **)&v96[12];
        }
        (*(void (**)(uint64_t, __int16 *, unsigned char *, unint64_t, void))(*(void *)v41 + 160))(v41, &v64, v42, v35, 0);
        if (v95[16]) {
          float v43 = &v96[4];
        }
        else {
          float v43 = *(unsigned char **)&v96[12];
        }
        (*(void (**)(void, unsigned char *, unint64_t, uint64_t))(**(void **)(a1 + 152) + 120))(*(void *)(a1 + 152), v43, v35, 1);
        uint64_t v44 = *(void *)(a1 + 152);
        if (v44) {
          (*(void (**)(uint64_t))(*(void *)v44 + 16))(v44);
        }
        *(void *)(a1 + 152) = 0;
        goto LABEL_64;
      }
    }
    else
    {
      if (*(void *)v95)
      {
        char v36 = v95[16];
      }
      else
      {
        re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v95, v35);
        char v36 = v95[16] + 2;
        *(_DWORD *)&v95[16] += 2;
      }
      BOOL v11 = (v36 & 1) == 0;
      unint64_t v38 = 32;
      if (v11) {
        unint64_t v38 = *(void *)&v96[4];
      }
      if (v38 < v35) {
        re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v95, v35);
      }
      uint64_t v39 = *(void *)&v95[8];
      if (*(void *)&v95[8] < v35)
      {
        do
        {
          if (v95[16]) {
            float v40 = &v96[4];
          }
          else {
            float v40 = *(unsigned char **)&v96[12];
          }
          *(void *)&v40[8 * v39++] = 0;
        }
        while (v35 != v39);
      }
    }
    *(void *)&v95[8] = v35;
    char v37 = v95[16] + 2;
    *(_DWORD *)&v95[16] += 2;
    goto LABEL_55;
  }
LABEL_64:
  float v45 = (float32x2_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 144) + 40))(*(void *)(a1 + 144));
  *(void *)&long long v68 = 0;
  DWORD2(v68) = 0;
  long long v69 = 0u;
  long long v70 = 0u;
  LODWORD(v71) = 0;
  *((void *)&v71 + 1) = 0;
  *(void *)&long long v72 = 0;
  *((void *)&v72 + 1) = 0x100000001;
  int v73 = 2;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  int32x2_t v46 = (int32x2_t)vmul_f32(*v45, (float32x2_t)0x3E4CCCCD3D23D70ALL);
  int32x2_t v77 = vrev64_s32(v46);
  __int32 v78 = v46.i32[0];
  int v79 = 0;
  int v80 = 64;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  long long v83 = xmmword_23437C030;
  uint64_t v84 = 0;
  uint64_t v85 = 0x1000000080;
  uint64_t v86 = 0x1000000000000;
  int v87 = 2139095039;
  uint64_t v88 = 0x100002000;
  long long v89 = xmmword_23437C040;
  long long v90 = xmmword_23437C050;
  long long v91 = xmmword_23437C060;
  long long v92 = xmmword_23437C070;
  uint64_t v93 = 8;
  float32x2_t v94 = *v45;
  uint64_t v81 = *(void *)(a1 + 168);
  int v80 = 17474;
  HIDWORD(v76) = 1;
  uint64_t v47 = *(void *)(a1 + 232);
  *((void *)&v71 + 1) = SimulationFilterShader;
  *(void *)&long long v69 = v47;
  HIDWORD(v86) = 64;
  *(void *)&long long v68 = a2->i64[0];
  DWORD2(v68) = a2->i32[2];
  float32x4_t v48 = vmulq_f32(*a2, *a2);
  *(float *)v77.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).f32[0])* 0.2;
  if (a3) {
    HIDWORD(v72) = 0;
  }
  if ((a3 & 2) != 0) {
    DWORD2(v72) = 0;
  }
  *(_DWORD *)(a1 + 384) = a3;
  float v49 = (physx::shdfnd::Foundation *)(*(uint64_t (**)(void, long long *))(**(void **)(a1 + 144) + 144))(*(void *)(a1 + 144), &v68);
  uint64_t ControllerManager = PxCreateControllerManager(v49, 0, v50, v51, v52, v53, v54, v55);
  float v57 = *(void (****)(void))(a1 + 160);
  if (v57) {
    (**v57)(v57);
  }
  *(void *)(a1 + 160) = ControllerManager;
  (*(void (**)(uint64_t, uint64_t))(*(void *)ControllerManager + 104))(ControllerManager, 1);
  uint64_t v58 = *(void *)(a1 + 152);
  if (v58) {
    (*(void (**)(uint64_t))(*(void *)v58 + 16))(v58);
  }
  *(void *)(a1 + 152) = v49;
  if (v95[16]) {
    float v59 = &v96[4];
  }
  else {
    float v59 = *(unsigned char **)&v96[12];
  }
  (*(void (**)(physx::shdfnd::Foundation *, unsigned char *, void))(*(void *)v49 + 96))(v49, v59, *(unsigned int *)&v95[8]);
  if (v99) {
    float v60 = &v100;
  }
  else {
    float v60 = v101;
  }
  if (v98)
  {
    float v61 = &v60[8 * v98];
    do
    {
      re::internal::PhysXCapsuleController::recreateUnderlying((void *)*v60, (float32x2_t *)v60 + 2, (uint64_t *)v60 + 4, a1, v60[6]);
      v60 += 8;
    }
    while (v60 != v61);
  }
  if (*(void *)(a1 + 256)) {
    re::PhysXDebugRenderer::setScene(a1 + 256, *(void *)(a1 + 152));
  }
  if (*(void *)v95 && (v95[16] & 1) == 0) {
    (*(void (**)(void))(**(void **)v95 + 40))();
  }
  uint64_t result = (uint64_t)v97;
  if (v97 && (v99 & 1) == 0) {
    uint64_t result = (*(uint64_t (**)(void))(*v97 + 40))();
  }
  if (physx::shdfnd::g_isLockingEnabled != v63) {
    physx::shdfnd::g_isLockingEnabled = v63;
  }
  return result;
}

uint64_t SimulationFilterShader@<X0>(uint64_t result@<X0>, _DWORD *a2@<X1>, int a3@<W2>, _DWORD *a4@<X3>, __int16 *a5@<X4>, _WORD *a6@<X8>)
{
  if ((a4[3] & a2[2]) != 0 && (a2[3] & a4[2]) != 0)
  {
    if (((a3 | result) & 0x20) != 0)
    {
      __int16 v6 = 1044;
    }
    else if ((*a4 | *a2))
    {
      if (((*a4 | *a2) & 2) != 0) {
        __int16 v6 = 3597;
      }
      else {
        __int16 v6 = 1549;
      }
      if ((result & a3 & 0x10) != 0) {
        __int16 v6 = 1548;
      }
      if ((*a2 & *a4 & 4) == 0) {
        __int16 v6 = 1548;
      }
    }
    else
    {
      __int16 v6 = 1548;
    }
    *a5 = v6;
  }
  *a6 = 0;
  return result;
}

uint64_t re::PhysXCollisionWorld::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, physx::shdfnd::Foundation *a5)
{
  *(void *)(a1 + 56) = a2;
  re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init(a1 + 72, a2, 3);
  *(void *)(a1 + 392) = a4;
  *(void *)(a1 + 400) = 0;
  if (a5)
  {
    uint64_t v16 = *(void *)(a1 + 152);
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
    }
    *(void *)(a1 + 152) = a5;
    uint64_t ControllerManager = PxCreateControllerManager(a5, 0, v10, v11, v12, v13, v14, v15);
    unint64_t v18 = *(void (****)(void))(a1 + 160);
    if (v18) {
      (**v18)(v18);
    }
    *(void *)(a1 + 160) = ControllerManager;
    uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)ControllerManager + 104);
    return v19(ControllerManager, 1);
  }
  else
  {
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
    *(void *)uint64_t v21 = &unk_26E6DD1A8;
    *(void *)(v21 + 8) = a3;
    *(unsigned char *)(v21 + 16) = 0;
    *(void *)(v21 + 56) = 0;
    *(_DWORD *)(v21 + 64) = 0;
    *(_OWORD *)(v21 + 20) = 0u;
    *(_OWORD *)(v21 + 36) = 0u;
    *(void *)(a1 + 168) = v21;
    float32x4_t v22 = 0uLL;
    return re::PhysXCollisionWorld::createScene(a1, &v22, *(_DWORD *)(a1 + 384));
  }
}

uint64_t re::PhysXCollisionWorld::isMultithreadingEnabled(re::PhysXCollisionWorld *this)
{
  uint64_t result = *((void *)this + 21);
  if (result) {
    return (*(unsigned int (**)(uint64_t))(*(void *)result + 8))(result) != 0;
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::setIsMultithreadingEnabled(uint64_t this, int a2)
{
  *(unsigned char *)(this + 388) = a2;
  if (!a2)
  {
    uint64_t v2 = *(void *)(this + 168);
    if (!v2) {
      return this;
    }
    BOOL v3 = *(unsigned char *)(this + 389) != 0;
    goto LABEL_8;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0) {
    physx::shdfnd::g_alwaysUseLocking = 1;
  }
  uint64_t v2 = *(void *)(this + 168);
  if (v2)
  {
    BOOL v3 = 1;
LABEL_8:
    *(unsigned char *)(v2 + 16) = v3;
  }
  return this;
}

void re::PhysXCollisionWorld::reportCollisions(re::PhysXCollisionWorld *this)
{
  v2[0] = &unk_26E6DD7D0;
  v2[1] = (char *)this + 176;
  re::ContactSetCollection::set((uint64_t)this + 72, (uint64_t)v2);
  re::CollisionWorld::reportTriggerEvents(this);
}

BOOL re::PhysXCollisionWorld::canRecreateScene(re::PhysXCollisionWorld *this)
{
  uint64_t v2 = *((void *)this + 19);
  __int16 v6 = 3;
  int v3 = (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 152))(v2, &v6);
  if (*((void *)this + 21)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  return v4
      && !(*(unsigned int (**)(void))(**((void **)this + 20) + 16))(*((void *)this + 20))
      && (*(unsigned int (**)(void))(**((void **)this + 20) + 64))(*((void *)this + 20)) == 0;
}

void re::PhysXCollisionWorld::update(re::PhysXCollisionWorld *this)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v2 = 1;
  }
  else {
    int v2 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  re::BucketArray<re::PhysXManifold,256ul>::clear((uint64_t)this + 176);
  re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity((uint64_t *)this + 22, (unint64_t)(*((void *)this + 27) + 255) >> 8);
  (*(void (**)(float))(**((void **)this + 19) + 400))(0.016667);
  (*(void (**)(void))(**((void **)this + 19) + 440))();
  int v3 = (re *)*((void *)this + 21);
  if (v3) {
    re::PhysXCPUDispatcher::reset(v3);
  }
  v4[0] = &unk_26E6DD7D0;
  v4[1] = (char *)this + 176;
  re::ContactSetCollection::set((uint64_t)this + 72, (uint64_t)v4);
  re::CollisionWorld::reportTriggerEvents(this);
  re::PhysXCollisionWorld::updateCharacterControllerVelocities(this);
  if (physx::shdfnd::g_isLockingEnabled != v2) {
    physx::shdfnd::g_isLockingEnabled = v2;
  }
}

uint64_t re::BucketArray<re::PhysXManifold,256ul>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v1, i);
      uint64_t result = re::DynamicArray<unsigned long>::deinit(v4 + 16);
    }
  }
  *(void *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

void re::PhysXCollisionWorld::updateCharacterControllerVelocities(re::PhysXCollisionWorld *this)
{
  int v2 = (*(uint64_t (**)(void))(**((void **)this + 20) + 16))(*((void *)this + 20));
  if (v2 >= 1)
  {
    int v3 = v2;
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 20) + 24))(*((void *)this + 20), v4);
      __int16 v6 = (re::internal::PhysXCapsuleController *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 160))(v5);
      re::internal::PhysXCapsuleController::updateVelocity(v6, v7);
      uint64_t v4 = (v4 + 1);
    }
    while (v3 != v4);
  }
}

void re::PhysXCollisionWorld::updateFromPhysics(re::PhysXCollisionWorld *this)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v4, 7022, (uint64_t)this);
  if (physx::shdfnd::g_isLockingEnabled) {
    int v2 = 1;
  }
  else {
    int v2 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  re::BucketArray<re::PhysXManifold,256ul>::clear((uint64_t)this + 176);
  re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity((uint64_t *)this + 22, (unint64_t)(*((void *)this + 27) + 255) >> 8);
  (*(void (**)(void))(**((void **)this + 19) + 440))();
  int v3 = (re *)*((void *)this + 21);
  if (v3) {
    re::PhysXCPUDispatcher::reset(v3);
  }
  if (physx::shdfnd::g_isLockingEnabled != v2) {
    physx::shdfnd::g_isLockingEnabled = v2;
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v4);
}

BOOL re::PhysXCollisionWorld::doContactTest(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  v27[6] = *MEMORY[0x263EF8340];
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  v24[0] = 0;
  v24[1] = 0;
  int v25 = -1;
  v19[1] = 0;
  v19[2] = 0;
  int v20 = -1;
  char v21 = 0;
  float32x4_t v22 = v24;
  uint64_t v23 = 1;
  v19[0] = &unk_26E6DD750;
  v17[0] = 0;
  v17[1] = 0;
  __int16 v18 = 7;
  uint64_t v5 = *((void *)a2 + 3);
  uint64_t v6 = *((void *)a2 + 4);
  v15[0] = &unk_26E6DD5E8;
  v15[1] = 0;
  v15[2] = v6;
  int v16 = 1;
  unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 184))(v5);
  if (v7)
  {
    unsigned int v8 = v7;
    uint64_t v9 = 0;
    BOOL v10 = 1;
    do
    {
      uint64_t v11 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v9, v14);
      uint64_t v12 = *((void *)this + 19);
      (*(void (**)(void *__return_ptr))(*(void *)v11 + 80))(v27);
      float v26 = v27;
      if ((*(unsigned int (**)(uint64_t, void *, float *, void *, void *, void *))(*(void *)v12 + 712))(v12, v27, v14, v19, v17, v15))
      {
        break;
      }
      uint64_t v9 = (v9 + 1);
      BOOL v10 = v9 < v8;
    }
    while (v8 != v9);
  }
  else
  {
    BOOL v10 = 0;
  }
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return v10;
}

uint64_t re::PhysXCollisionWorld::doContactPairTest(re::PhysXCollisionWorld *this, re::GeometricObjectBase **a2, re::GeometricObjectBase **a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  re::GeometricObjectBase::aabb((uint64_t *)v20, a2[2]);
  re::GeometricObjectBase::aabb((uint64_t *)v19, a3[2]);
  uint32x4_t v5 = (uint32x4_t)vcgtq_f32(v20[0], v19[1]);
  v5.i32[3] = v5.i32[2];
  if ((vmaxvq_u32(v5) & 0x80000000) != 0) {
    return 0;
  }
  uint32x4_t v6 = (uint32x4_t)vcgtq_f32(v19[0], v20[1]);
  v6.i32[3] = v6.i32[2];
  if ((vmaxvq_u32(v6) & 0x80000000) != 0) {
    return 0;
  }
  int v7 = (*(uint64_t (**)(re::GeometricObjectBase *))(*(void *)a2[3] + 184))(a2[3]);
  int v8 = (*(uint64_t (**)(re::GeometricObjectBase *))(*(void *)a3[3] + 184))(a3[3]);
  if (!v7) {
    return 0;
  }
  int v9 = v8;
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v11 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v10, v17);
    if (v9) {
      break;
    }
LABEL_9:
    uint64_t result = 0;
    uint64_t v10 = (v10 + 1);
    if (v10 == v7) {
      return result;
    }
  }
  uint64_t v12 = v11;
  uint64_t v13 = 0;
  while (1)
  {
    uint64_t v14 = re::PhysXCollisionObject::pxShape((uint64_t)a3, v13, v16);
    (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(void *)v12 + 80))(v20, v12);
    v19[0].i64[0] = (uint64_t)v20;
    (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(void *)v14 + 80))(v19, v14);
    __int16 v18 = v19;
    if (physx::PxGeometryQuery::overlap((int *)v20, (uint64_t)v17, (int *)v19, (uint64_t)v16)) {
      return 1;
    }
    uint64_t v13 = (v13 + 1);
    if (v9 == v13) {
      goto LABEL_9;
    }
  }
}

uint64_t re::PhysXCollisionWorld::rayCast(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v8 = 1;
  }
  else {
    int v8 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  re::BucketArray<re::CollisionCastHit,10ul>::clear(a4);
  unsigned int v10 = *a3;
  int v11 = *(_DWORD *)(a2 + 32);
  v15[1] = 0;
  v15[2] = 0;
  int v16 = -1;
  __int16 v17 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  uint64_t v21 = 2139095039;
  int v22 = 0;
  char v23 = 0;
  float v24 = &v28;
  int v25 = 32 * (v10 == 1);
  int v26 = 0;
  v15[0] = &unk_26E6DD648;
  uint64_t v12 = 13;
  unint64_t v27 = a4;
  do
  {
    uint64_t v13 = &v15[v12];
    *uint64_t v13 = 0;
    v13[1] = 0;
    *((_DWORD *)v13 + 4) = -1;
    *((_WORD *)v13 + 10) = 0;
    v13[4] = 0;
    v13[5] = 0;
    v13[3] = 0;
    v13[6] = 2139095039;
    v12 += 8;
    *((_DWORD *)v13 + 14) = 0;
  }
  while (v13 + 8 != (void *)&v29);
  char v29 = v10;
  int v30 = v11;
  if (v10 >= 3)
  {
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 696))();
    if (physx::shdfnd::g_isLockingEnabled != v8) {
      physx::shdfnd::g_isLockingEnabled = v8;
    }
  }
  return result;
}

unint64_t re::BucketArray<re::CollisionCastHit,10ul>::clear(unint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      uint64_t result = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v1, i);
  }
  *(void *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t re::PhysXCollisionWorld::convexCast(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, unsigned __int8 *a5, unint64_t a6)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v10 = 1;
  }
  else {
    int v10 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  float32x4_t v11 = vsubq_f32(*a4, *a3);
  float32x4_t v12 = vmulq_f32(v11, v11);
  float v13 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
  float32x4_t v34 = vmulq_n_f32(v11, 1.0 / v13);
  uint64_t result = re::BucketArray<re::CollisionCastHit,10ul>::clear(a6);
  uint64_t v15 = *(void *)(a2 + 8);
  if (v15)
  {
    unsigned int v16 = *a5;
    v19[1] = 0;
    v19[2] = 0;
    int v20 = -1;
    __int16 v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    int v25 = 2139095039;
    char v26 = 0;
    unint64_t v27 = &v31;
    int v28 = 32 * (v16 == 1);
    int v29 = 0;
    v19[0] = &unk_26E6DD690;
    unint64_t v30 = a6;
    uint64_t v17 = 12;
    do
    {
      uint64_t v18 = &v19[v17];
      *uint64_t v18 = 0;
      v18[1] = 0;
      *((_DWORD *)v18 + 4) = -1;
      *((_WORD *)v18 + 10) = 0;
      v18[4] = 0;
      v18[5] = 0;
      v18[3] = 0;
      v17 += 7;
      *((_DWORD *)v18 + 12) = 2139095039;
    }
    while (v18 + 7 != (void *)&v32);
    char v32 = v16;
    float v33 = v13;
    if (v16 >= 3)
    {
      re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
      uint64_t result = _os_crash();
      __break(1u);
      return result;
    }
    uint64_t result = (*(uint64_t (**)(float, double))(**(void **)(a1 + 152) + 704))(v13, 0.0);
  }
  if (physx::shdfnd::g_isLockingEnabled != v10) {
    physx::shdfnd::g_isLockingEnabled = v10;
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::contacts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v34[6] = *MEMORY[0x263EF8340];
  v32[1] = 0;
  v32[0] = 0;
  __int16 v33 = 7;
  uint64_t v5 = *(void *)(a2 + 32);
  v30[0] = &unk_26E6DD5E8;
  v30[1] = 0;
  v30[2] = v5;
  int v31 = 1;
  v17[1] = 0;
  void v17[2] = 0;
  int v18 = -1;
  __int16 v19 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  int v23 = 2139095039;
  char v24 = 0;
  int v25 = &v29;
  uint64_t v26 = 32;
  v17[0] = &unk_26E6DD6E8;
  uint64_t v27 = a2;
  uint64_t v28 = a3;
  uint64_t v6 = 13;
  do
  {
    int v7 = &v17[v6];
    *int v7 = 0;
    v7[1] = 0;
    *((_DWORD *)v7 + 4) = -1;
    *((_WORD *)v7 + 10) = 0;
    v7[4] = 0;
    v7[5] = 0;
    v7[3] = 0;
    v6 += 7;
    *((_DWORD *)v7 + 12) = 2139095039;
  }
  while (v7 + 7 != v30);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a2 + 24) + 184))(*(void *)(a2 + 24));
  if (result)
  {
    int v9 = result;
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = re::PhysXCollisionObject::pxShape(a2, v10, v16);
      uint64_t v12 = *(void *)(a1 + 152);
      (*(void (**)(void *__return_ptr))(*(void *)v11 + 80))(v34);
      uint64_t v14 = 0;
      int v15 = 1065353216;
      __int16 v13 = 512;
      uint64_t result = (*(uint64_t (**)(uint64_t, void *, float *, uint64_t *, void *, __int16 *, void *, void *, double, double, void))(*(void *)v12 + 704))(v12, v34, v16, &v14, v17, &v13, v32, v30, 0.0, 0.0, 0);
      uint64_t v10 = (v10 + 1);
    }
    while (v9 != v10);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::overlap@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v10 = *(void *)(a1 + 152);
  __int16 v49 = 2;
  uint64_t v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v10 + 152))(v10, &v49);
  int v12 = (int)v11;
  uint64_t v13 = v11;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v14 = v48;
  v40[0] = 0;
  v40[1] = 0;
  int v41 = -1;
  unsigned __int8 v42 = 0;
  uint64_t v43 = v48;
  int v44 = v12;
  unsigned int v45 = 0;
  uint64_t v39 = &unk_26E6DD750;
  uint64_t v15 = *(void *)(a1 + 152);
  v37[0] = 0;
  v37[1] = 0;
  __int16 v38 = 3;
  uint64_t v17 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void **, void *, void, uint64_t))(*(void *)v15 + 712))(v15, a2, a3, &v39, v37, 0, v16);
  *(void *)(a5 + 32) = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 24) = 0;
  unsigned int v23 = v45;
  int v24 = v42;
  if (v45 + v42)
  {
    uint64_t v25 = 0;
    int v26 = 0;
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    unint64_t v29 = 0;
    do
    {
      unint64_t v30 = (void *)(v43 + v25);
      if (v29 >= v23) {
        unint64_t v30 = v40;
      }
      uint64_t v31 = *(void *)(*v30 + 16);
      if ((*(_DWORD *)(v31 + 32) & a4) != 0)
      {
        unint64_t v32 = *(void *)(a5 + 8);
        if (v28 >= v32)
        {
          unint64_t v33 = v28 + 1;
          if (v32 < v28 + 1)
          {
            if (*(void *)a5)
            {
              unint64_t v34 = 2 * v32;
              if (!v32) {
                unint64_t v34 = 8;
              }
              if (v34 <= v33) {
                unint64_t v35 = v28 + 1;
              }
              else {
                unint64_t v35 = v34;
              }
              uint64_t v17 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((void *)a5, v35);
              int v26 = *(_DWORD *)(a5 + 24);
            }
            else
            {
              uint64_t v17 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((void *)a5, v33);
              int v26 = *(_DWORD *)(a5 + 24) + 1;
            }
          }
          unint64_t v28 = *(void *)(a5 + 16);
          uint64_t v27 = *(void *)(a5 + 32);
          unsigned int v23 = v45;
          int v24 = v42;
        }
        *(void *)(v27 + 8 * v28++) = v31;
        *(void *)(a5 + 16) = v28;
        *(_DWORD *)(a5 + 24) = ++v26;
      }
      ++v29;
      v25 += 24;
    }
    while (v29 < v23 + v24);
  }
  uint64_t result = v46;
  if (v46)
  {
    if (v47) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v46 + 40))(v46, v14, v18, v19, v20, v21, v22);
    }
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::overlaps(re::PhysXCollisionWorld *this, re::CollisionObject *a2, re::ContactSetCollection *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)this + 19);
  __int16 v42 = 3;
  int v7 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v6 + 152))(v6, &v42);
  int v8 = (int)v7;
  uint64_t v9 = v7;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v10 = v41;
  v33[0] = 0;
  v33[1] = 0;
  int v34 = -1;
  unsigned __int8 v35 = 0;
  uint64_t v36 = v41;
  int v37 = v8;
  unsigned int v38 = 0;
  unint64_t v32 = &unk_26E6DD750;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  __int16 v31 = 7;
  uint64_t v11 = *((void *)a2 + 4);
  uint64_t v25 = &unk_26E6DD5E8;
  uint64_t v26 = 0;
  uint64_t v27 = v11;
  int v28 = 1;
  uint64_t v12 = *(void *)((*(uint64_t (**)(void))(**((void **)a2 + 2) + 16))(*((void *)a2 + 2)) + 8);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)a2 + 2) + 40))(&v43);
  long long v22 = v45;
  uint64_t v23 = v43;
  int v24 = (int)v44;
  (*(void (**)(void, uint64_t, long long *, void **))(**((void **)this + 19) + 712))(*((void *)this + 19), v12, &v22, &v32);
  unsigned int v15 = v38;
  if (v38 + v35)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    do
    {
      if (v17 >= v15) {
        uint64_t v18 = v33;
      }
      else {
        uint64_t v18 = (void *)(v36 + v16);
      }
      uint64_t v19 = *(void *)(*v18 + 16);
      unint64_t v20 = *(void *)a3;
      long long v49 = 0u;
      long long v50 = 0u;
      int v51 = 0;
      uint64_t v46 = 0;
      int v47 = 0;
      v48[0] = 0;
      *(_DWORD *)((char *)v48 + 7) = 0;
      uint64_t v52 = 0;
      uint64_t v53 = 0;
      uint64_t v43 = v19;
      int v44 = a2;
      long long v45 = v20;
      re::DynamicArray<re::RigSplineIKJoint>::setCapacity(&v45, 0);
      ++v47;
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew((uint64_t)a3, &v43);
      re::ContactSet::~ContactSet((re::ContactSet *)&v43);
      ++v17;
      unsigned int v15 = v38;
      v16 += 24;
    }
    while (v17 < v38 + v35);
  }
  uint64_t result = v39;
  if (v39)
  {
    if (v40) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v39 + 40))(v39, v10, v13, v14);
    }
  }
  return result;
}

void re::PhysXCollisionWorld::contacts(re::PhysXCollisionWorld *this, re::CollisionObject *a2, re::CollisionObject *a3, re::ContactSet *a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  *((void *)a4 + 4) = 0;
  ++*((_DWORD *)a4 + 10);
  unint64_t v4 = *((void *)a2 + 4);
  unint64_t v5 = *((void *)a3 + 4);
  unint64_t v6 = v5 & HIDWORD(v4);
  unint64_t v7 = v4 & HIDWORD(v5);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    *(void *)a4 = a2;
    *((void *)a4 + 1) = a3;
    re::GeometricObjectBase::aabb((uint64_t *)&v30, *((re::GeometricObjectBase **)a2 + 2));
    re::GeometricObjectBase::aabb((uint64_t *)v36, *((re::GeometricObjectBase **)a3 + 2));
    uint32x4_t v12 = (uint32x4_t)vcgtq_f32(v30, v36[1]);
    v12.i32[3] = v12.i32[2];
    if ((vmaxvq_u32(v12) & 0x80000000) == 0)
    {
      uint32x4_t v13 = (uint32x4_t)vcgtq_f32(v36[0], v31);
      v13.i32[3] = v13.i32[2];
      if ((vmaxvq_u32(v13) & 0x80000000) == 0)
      {
        int v14 = (*(uint64_t (**)(void))(**((void **)a2 + 3) + 184))(*((void *)a2 + 3));
        int v15 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 184))(*((void *)a3 + 3));
        if (v14)
        {
          int v16 = v15;
          uint64_t v17 = 0;
          uint64_t v18 = (re::ContactSet *)((char *)a4 + 16);
          while (1)
          {
            uint64_t v19 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v17, v29);
            if (v16) {
              break;
            }
LABEL_13:
            uint64_t v17 = (v17 + 1);
            if (v17 == v14) {
              return;
            }
          }
          uint64_t v20 = v19;
          uint64_t v21 = 0;
          while (1)
          {
            uint64_t v22 = re::PhysXCollisionObject::pxShape((uint64_t)a3, v21, v28);
            float v25 = 0.0;
            (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(void *)v20 + 80))(&v30, v20);
            v36[0].i64[0] = (uint64_t)&v30;
            (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(void *)v22 + 80))(v36, v22);
            v24[0].i64[0] = (uint64_t)v36;
            if (!physx::PxGeometryQuery::computePenetration(&v26, (uint64_t)&v25, (int *)&v30, (uint64_t)v29, (int *)v36, (uint64_t)v28))break; {
            (*(void (**)(float32x4_t *__return_ptr))(**((void **)a2 + 2) + 40))(v36);
            }
            (*(void (**)(float32x4_t *__return_ptr))(**((void **)a3 + 2) + 40))(v24);
            *(float32x2_t *)&long long v23 = v26;
            DWORD2(v23) = v27;
            float32x4_t v31 = v24[0];
            float32x4_t v30 = v36[0];
            long long v32 = v23;
            uint64_t v33 = 0;
            uint64_t v34 = 0;
            float v35 = -v25;
            re::DynamicArray<re::GeomInstance>::add(v18, (uint64_t)&v30);
            uint64_t v21 = (v21 + 1);
            if (v16 == v21) {
              goto LABEL_13;
            }
          }
        }
      }
    }
  }
}

float re::PhysXCollisionWorld::closestPoint(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t a4)
{
  v27[6] = *MEMORY[0x263EF8340];
  *(_OWORD *)a4 = *(_OWORD *)a2->f32;
  if (physx::shdfnd::g_isLockingEnabled) {
    int v7 = 1;
  }
  else {
    int v7 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  int v8 = (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 184))(*(void *)(a3 + 24));
  if (v8)
  {
    int v9 = v8;
    uint64_t v10 = 0;
    float v11 = INFINITY;
    do
    {
      uint64_t v12 = re::PhysXCollisionObject::pxShape(a3, v10, v26);
      float32x2_t v24 = *a2;
      __int32 v25 = a2[1].i32[0];
      (*(void (**)(void *__return_ptr))(*(void *)v12 + 80))(v27);
      uint64_t v22 = v27;
      physx::PxGeometryQuery::pointDistance(&v24, (uint64_t)v27, (uint64_t)v26, (float32x2_t *)&v22, v13, v14, v15, v16);
      if (v17 < 0.0) {
        float v17 = INFINITY;
      }
      if (v17 < v11)
      {
        if (v17 <= 0.0)
        {
          float32x2_t v20 = *a2;
          float32x2_t v19 = a2[1];
        }
        else
        {
          v18.i32[0] = v23;
          float32x2_t v19 = v18;
          float32x2_t v20 = (float32x2_t)v22;
        }
        *(float32x2_t *)a4 = v20;
        *(float32x2_t *)(a4 + 8) = v19;
        float v11 = v17;
      }
      uint64_t v10 = (v10 + 1);
    }
    while (v9 != v10);
  }
  else
  {
    float v11 = INFINITY;
  }
  if (physx::shdfnd::g_isLockingEnabled != v7) {
    physx::shdfnd::g_isLockingEnabled = v7;
  }
  return v11;
}

void re::PhysXCollisionWorld::closestPointToRayRadian(uint64_t a1, float32x4_t *a2, uint64_t a3, int8x16_t *a4)
{
  int v7 = (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 184))(*(void *)(a3 + 24));
  if (v7)
  {
    int v9 = v7;
    uint64_t v10 = 0;
    v8.i64[0] = 0;
    float32x4_t v62 = v8;
    int8x16_t v61 = 0u;
    do
    {
      uint64_t v11 = re::PhysXCollisionObject::pxShape(a3, v10, v76);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 64))(v11) == 3)
      {
        int v73 = 3;
        float32x2_t v74 = 0;
        float v75 = 0.0;
        (*(void (**)(uint64_t, int *))(*(void *)v11 + 88))(v11, &v73);
        float32x4_t v12 = a2[1];
        int32x4_t v13 = (int32x4_t)vmulq_f32(v12, v12);
        v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
        float32x2_t v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
        float32x2_t v15 = vmul_f32(v14, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)));
        float32x4_t v70 = vmulq_n_f32(v12, vmul_f32(v15, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v15, v15))).f32[0]);
        int8x16_t v72 = 0u;
        float32x4_t v81 = v70;
        re::internal::nvphysx::fromPhysX((uint64_t)v76, &v79);
        float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v80, v80), (int8x16_t)v80, 0xCuLL);
        float32x4_t v17 = vnegq_f32((float32x4_t)v80);
        float32x4_t v18 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_23437C080), (float32x4_t)xmmword_23435FD50, v16);
        int8x16_t v19 = (int8x16_t)vaddq_f32(v18, v18);
        float32x4_t v20 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), v19, 0xCuLL);
        int8x16_t v21 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v17), v20, v16);
        float32x4_t v22 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v20, (float32x4_t)v80, 3), (float32x4_t)xmmword_23435FD50), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL));
        float32x4_t v23 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_23437C090), (float32x4_t)xmmword_23435FD60, v16);
        int8x16_t v24 = (int8x16_t)vaddq_f32(v23, v23);
        float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL);
        int8x16_t v26 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v17), v25, v16);
        float32x4_t v27 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v25, (float32x4_t)v80, 3), (float32x4_t)xmmword_23435FD60), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), v26, 0xCuLL));
        float32x4_t v28 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_23437C0A0), (float32x4_t)xmmword_23435FD80, v16);
        int8x16_t v29 = (int8x16_t)vaddq_f32(v28, v28);
        float32x4_t v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), v29, 0xCuLL);
        int8x16_t v31 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), v17), v30, v16);
        float32x4_t v32 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v30, (float32x4_t)v80, 3), (float32x4_t)xmmword_23435FD80), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), v31, 0xCuLL));
        float32x4_t v33 = *a2;
        float v34 = 0.0;
        int v35 = -1;
        do
        {
          int v36 = v35;
          float32x4_t v37 = vaddq_f32(v79, vmulq_n_f32(v22, v74.f32[0] * (float)v35));
          int v38 = -1;
          do
          {
            int v39 = v38;
            float32x4_t v40 = vaddq_f32(v37, vmulq_n_f32(v27, v74.f32[1] * (float)v38));
            int v41 = -3;
            do
            {
              float32x4_t v42 = vaddq_f32(v40, vmulq_n_f32(v32, v75 * (float)(v41 + 2)));
              float32x4_t v43 = vsubq_f32(v42, v33);
              int32x4_t v44 = (int32x4_t)vmulq_f32(v43, v43);
              v44.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v44, 2), vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v44.i8, 1))).u32[0];
              float32x2_t v45 = vrsqrte_f32((float32x2_t)v44.u32[0]);
              float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v45, v45)));
              float32x4_t v47 = vmulq_f32(v70, vmulq_n_f32(v43, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v46, v46))).f32[0]));
              float v48 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
              if (v48 > v34)
              {
                int8x16_t v72 = (int8x16_t)v42;
                float v34 = v48;
              }
              v41 += 2;
            }
            while (v41 < 0);
            int v38 = v39 + 2;
          }
          while (v39 < 0);
          int v35 = v36 + 2;
        }
        while (v36 < 0);
        float v78 = v34;
        v77[0] = a2;
        v77[1] = &v81;
        v77[2] = a2;
        v77[3] = &v78;
        v77[4] = &v72;
        float32x4_t v68 = v22;
        float32x4_t v71 = vmulq_n_f32(v22, v74.f32[0]);
        float32x4_t v65 = vmulq_n_f32(v27, -v74.f32[1]);
        float32x2_t v66 = v74;
        float32x4_t v49 = vaddq_f32(v65, vaddq_f32(v79, v71));
        float32x4_t v63 = vmulq_n_f32(v32, v75);
        float32x4_t v64 = vmulq_n_f32(v32, -v75);
        float32x4_t v60 = v27;
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, v49), vaddq_f32(v64, v49));
        float32x4_t v69 = vmulq_n_f32(v68, -v66.f32[0]);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, vaddq_f32(v71, v79))), vaddq_f32(v64, vaddq_f32(v65, vaddq_f32(v69, v79))));
        float32x4_t v50 = vaddq_f32(v65, vaddq_f32(v69, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, v50), vaddq_f32(v63, v50));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, vaddq_f32(v69, v79))), vaddq_f32(v63, vaddq_f32(v65, vaddq_f32(v71, v79))));
        float32x4_t v51 = vaddq_f32(v71, v79);
        float32x4_t v67 = vmulq_lane_f32(v60, v66, 1);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, v51)), vaddq_f32(v63, vaddq_f32(v67, v51)));
        float32x4_t v52 = vaddq_f32(v71, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, v52)), vaddq_f32(v64, vaddq_f32(v67, v52)));
        float32x4_t v53 = vaddq_f32(v69, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, v53)), vaddq_f32(v64, vaddq_f32(v67, v53)));
        float32x4_t v54 = vaddq_f32(v69, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, v54)), vaddq_f32(v63, vaddq_f32(v67, v54)));
        float32x4_t v55 = vaddq_f32(v67, vaddq_f32(v71, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, v55), vaddq_f32(v64, v55));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v67, vaddq_f32(v71, v79))), vaddq_f32(v64, vaddq_f32(v67, vaddq_f32(v69, v79))));
        float32x4_t v56 = vaddq_f32(v67, vaddq_f32(v69, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, v56), vaddq_f32(v63, v56));
        float32x4_t v57 = boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v67, vaddq_f32(v69, v79))), vaddq_f32(v63, vaddq_f32(v67, vaddq_f32(v71, v79))));
        v57.f32[0] = v78;
        float32x4_t v58 = v62;
        int8x16_t v59 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v57, v62), 0), v72, v61);
        if (v78 > v62.f32[0]) {
          v58.f32[0] = v78;
        }
        int8x16_t v61 = v59;
        float32x4_t v62 = v58;
      }
      uint64_t v10 = (v10 + 1);
    }
    while (v10 != v9);
    if (v62.f32[0] > 0.0) {
      *a4 = v61;
    }
  }
}

void *re::PhysXCollisionWorld::initDebugRenderer(uint64_t a1, const void *a2, const void *a3, const void *a4, const void *a5)
{
  return re::PhysXDebugRenderer::init((void *)(a1 + 256), *(void *)(a1 + 152), a2, a3, a4, a5);
}

float re::PhysXCollisionWorld::setRenderingFromPhysicsTransform(uint64_t a1, _OWORD *a2)
{
  return re::PhysXDebugRenderer::setRenderingTransform(a1 + 256, a2);
}

uint64_t re::PhysXCollisionWorld::draw(re::PhysXCollisionWorld *this)
{
  return re::PhysXDebugRenderer::draw((re::PhysXCollisionWorld *)((char *)this + 256));
}

uint64_t re::PhysXCollisionWorld::numCollisionObjects(re::PhysXCollisionWorld *this)
{
  uint64_t v2 = *((void *)this + 19);
  __int16 v7 = 1;
  int v3 = (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 152))(v2, &v7);
  uint64_t v4 = *((void *)this + 19);
  __int16 v6 = 2;
  return (*(unsigned int (**)(uint64_t, __int16 *))(*(void *)v4 + 152))(v4, &v6) + v3;
}

uint64_t re::PhysXCollisionWorld::collisionObjectAtIndex(re::PhysXCollisionWorld *this, unint64_t a2)
{
  uint64_t v4 = *((void *)this + 19);
  __int16 v13 = 1;
  unsigned int v5 = (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v4 + 152))(v4, &v13);
  BOOL v6 = v5 > a2;
  if (v5 <= a2) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v12 = 0;
  uint64_t v8 = *((void *)this + 19);
  if (v6) {
    __int16 v9 = 1;
  }
  else {
    __int16 v9 = 2;
  }
  __int16 v11 = v9;
  if ((*(unsigned int (**)(uint64_t, __int16 *, uint64_t *, uint64_t, void))(*(void *)v8 + 160))(v8, &v11, &v12, 1, a2 - v7))
  {
    return *(void *)(v12 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t re::PhysXCollisionWorld::addCollisionObject(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  if (*((unsigned char *)this + 390))
  {
    *((unsigned char *)this + 390) = 0;
    if (re::PhysXCollisionWorld::canRecreateScene(this))
    {
      (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 19) + 488))(&v9);
      v5.i64[0] = v9;
      v5.i32[2] = v10;
      float32x4_t v11 = v5;
      re::PhysXCollisionWorld::createScene((uint64_t)this, &v11, *((_DWORD *)this + 96));
    }
  }
  uint64_t v6 = *((void *)a2 + 3);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 19) + 88))(*((void *)this + 19), v6, 0);
  if (*(_WORD *)(v6 + 8) == 5 && v6 != 0) {
    ++*((void *)this + 50);
  }
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return result;
}

BOOL re::PhysXCollisionWorld::removeCollisionObject(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  uint64_t v5 = *((void *)this + 8);
  if (v5)
  {
    uint64_t v6 = *((unsigned int *)this + 10);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = (int *)(*((void *)this + 3) + 8);
      while (1)
      {
        int v9 = *v8;
        v8 += 10;
        if (v9 < 0) {
          break;
        }
        if (v6 == ++v7)
        {
          LODWORD(v7) = *((_DWORD *)this + 10);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if (v6 != v7)
    {
      uint64_t v10 = v7;
      unsigned int v11 = *((_DWORD *)this + 10);
      do
      {
        uint64_t v12 = *((void *)this + 3) + 40 * v10;
        __int16 v13 = *(re::CollisionObject **)(v12 + 16);
        float32x2_t v14 = *(re::CollisionObject **)(v12 + 24);
        float32x2_t v15 = (uint64_t *)(v12 + 16);
        if (v13 == a2 || v14 == a2)
        {
          (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
          re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove((uint64_t)this + 8, v15);
          unsigned int v11 = *((_DWORD *)this + 10);
        }
        if (v11 <= (int)v7 + 1) {
          unsigned int v17 = v7 + 1;
        }
        else {
          unsigned int v17 = v11;
        }
        while (1)
        {
          uint64_t v10 = (v7 + 1);
          if (v17 - 1 == v7) {
            break;
          }
          LODWORD(v7) = v7 + 1;
          unsigned int v18 = v10;
          if ((*(_DWORD *)(*((void *)this + 3) + 40 * v10 + 8) & 0x80000000) != 0) {
            goto LABEL_29;
          }
        }
        unsigned int v18 = v17;
LABEL_29:
        LODWORD(v7) = v18;
      }
      while (v6 != v18);
    }
  }
  int8x16_t v19 = (_WORD *)*((void *)a2 + 3);
  if ((*(uint64_t (**)(_WORD *))(*(void *)v19 + 56))(v19)) {
    (*(void (**)(void, _WORD *, uint64_t))(**((void **)this + 19) + 112))(*((void *)this + 19), v19, 1);
  }
  if (v19[4] == 5) {
    --*((void *)this + 50);
  }
  BOOL result = re::PhysXCollisionWorld::canRecreateScene(this);
  *((unsigned char *)this + 390) = result;
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return result;
}

uint64_t re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = ((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = 0x7FFFFFFFLL;
  while (1)
  {
    uint64_t v10 = v8 + 40 * v7;
    uint64_t v13 = *(void *)(v10 + 16);
    uint64_t v12 = v10 + 16;
    uint64_t v11 = v13;
    if (v13 == v3 && *(void *)(v12 + 8) == v4) {
      break;
    }
    if (v11 == v4 && *(void *)(v12 + 8) == v3) {
      break;
    }
    uint64_t v9 = v7;
    uint64_t v7 = *(_DWORD *)(v8 + 40 * v7 + 8) & 0x7FFFFFFF;
    if (v7 == 0x7FFFFFFF) {
      return 0;
    }
  }
  int v15 = *(_DWORD *)(v8 + 40 * v7 + 8) & 0x7FFFFFFF;
  if (v9 == 0x7FFFFFFF) {
    *(_DWORD *)(v6 + 4 * v5) = v15;
  }
  else {
    *(_DWORD *)(v8 + 40 * v9 + 8) = *(_DWORD *)(v8 + 40 * v9 + 8) & 0x80000000 | v15;
  }
  uint64_t v16 = *(void *)(a1 + 16);
  uint64_t v17 = v16 + 40 * v7;
  int v20 = *(_DWORD *)(v17 + 8);
  int8x16_t v19 = (int *)(v17 + 8);
  int v18 = v20;
  if (v20 < 0)
  {
    *int8x16_t v19 = v18 & 0x7FFFFFFF;
    uint64_t v16 = *(void *)(a1 + 16);
    int v18 = *(_DWORD *)(v16 + 40 * v7 + 8);
  }
  int v21 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v16 + 40 * v7 + 8) = *(_DWORD *)(a1 + 36) | v18 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v21 + 1;
  return 1;
}

uint64_t re::QueryFilterCallback::postFilter()
{
  return 0;
}

void re::QueryFilterCallback::~QueryFilterCallback(re::QueryFilterCallback *this)
{
}

uint64_t re::PhysXCollisionWorld::collisionFlags(re::PhysXCollisionWorld *this)
{
  return *((unsigned int *)this + 96);
}

uint64_t re::PhysXCollisionWorld::parentPhysicsSimulation(re::PhysXCollisionWorld *this)
{
  return *((void *)this + 49);
}

uint64_t re::PhysXCollisionWorld::setSimulationEventCallbackContext(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(result + 232) + 24) = *a2;
  return result;
}

float32x4_t boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()(uint64_t a1, float32x4_t result, float32x4_t a3)
{
  uint64_t v3 = *(float32x4_t **)(a1 + 16);
  float32x4_t v4 = v3[1];
  float32x4_t v5 = vsubq_f32(result, *v3);
  int32x4_t v6 = (int32x4_t)vmulq_f32(v5, v5);
  v6.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))).u32[0];
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
  float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)));
  float32x4_t v9 = vmulq_n_f32(v5, vmul_f32(v8, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]);
  float32x4_t v10 = vmulq_f32(v9, v4);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0] > 0.00001)
  {
    float32x4_t v11 = vsubq_f32(a3, *v3);
    int32x4_t v12 = (int32x4_t)vmulq_f32(v11, v11);
    v12.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))).u32[0];
    float32x2_t v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
    float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
    float32x4_t v15 = vmulq_n_f32(v11, vmul_f32(v14, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v14, v14))).f32[0]);
    float32x4_t v16 = vmulq_f32(v4, v15);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0] > 0.00001)
    {
      float32x4_t v17 = vmulq_f32(v9, v15);
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0] < 0.99999)
      {
        float32x4_t v18 = *(float32x4_t *)*(void *)a1;
        float32x4_t v19 = vsubq_f32(result, v18);
        float32x4_t v20 = vsubq_f32(a3, v18);
        float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL);
        float32x4_t v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL);
        float32x4_t v23 = vmlaq_f32(vmulq_f32(v22, vnegq_f32(v19)), v20, v21);
        float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL);
        int32x4_t v25 = (int32x4_t)vmulq_f32(v23, v23);
        v25.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v25, 2), *(float32x2_t *)v25.i8)).u32[0];
        float32x2_t v26 = vrsqrte_f32((float32x2_t)v25.u32[0]);
        float32x2_t v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v26, v26)));
        float32x4_t v28 = vmulq_n_f32(v24, vmul_f32(v27, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v27, v27))).f32[0]);
        float32x4_t v29 = *(float32x4_t *)*(void *)(a1 + 8);
        float32x4_t v30 = vmulq_f32(v29, v28);
        float32x4_t v31 = vsubq_f32(v29, vmulq_n_f32(v28, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]));
        int32x4_t v32 = (int32x4_t)vmulq_f32(v31, v31);
        v32.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))).u32[0];
        float32x2_t v33 = vrsqrte_f32((float32x2_t)v32.u32[0]);
        float32x2_t v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v33, v33)));
        float32x4_t v35 = vmulq_n_f32(v31, vmul_f32(v34, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v34, v34))).f32[0]);
        float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL);
        int32x4_t v37 = (int32x4_t)vmlaq_f32(vmulq_f32(v21, vnegq_f32(v35)), v19, v36);
        float32x4_t v38 = vmulq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v37, v37), (int8x16_t)v37, 0xCuLL));
        v34.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0];
        float v39 = 0.0;
        if (v34.f32[0] <= 0.0)
        {
          int32x4_t v41 = (int32x4_t)vmlaq_f32(vmulq_f32(v36, vnegq_f32(v20)), v35, v22);
          float32x4_t v42 = vmulq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL));
          BOOL v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0] <= 0.0;
          float v40 = 0.0;
          if (v43)
          {
            int8x16_t v44 = (int8x16_t)vmulq_f32(v19, v19);
            int8x16_t v45 = (int8x16_t)vmulq_f32(v20, v20);
            *(float32x2_t *)v44.i8 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v44.i8, *(int32x2_t *)v45.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v44.i8, *(int32x2_t *)v45.i8))));
            _Q4 = (int32x4_t)vmulq_f32(vdivq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 0)), v35);
            int32x4_t v47 = (int32x4_t)vmulq_f32(vdivq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 1)), v35);
            *(float32x2_t *)v47.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(_Q4, v47), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)_Q4.i8, *(int32x2_t *)v47.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)_Q4.i8, *(int32x2_t *)v47.i8)));
            __asm { FMOV            V4.2S, #1.0 }
            *(float32x2_t *)_Q4.i8 = vmls_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v47.i8, *(float32x2_t *)v47.i8);
            *(float32x2_t *)v47.i8 = vmul_f32(*(float32x2_t *)v44.i8, vsqrt_f32((float32x2_t)vbic_s8(*(int8x8_t *)_Q4.i8, (int8x8_t)vcltz_f32(*(float32x2_t *)_Q4.i8))));
            LODWORD(v39) = vdiv_f32(*(float32x2_t *)v47.i8, vadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v47.i8, 1))).u32[0];
            float32x4_t v52 = vmulq_f32(v29, v35);
            LODWORD(v40) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).u32[0];
          }
        }
        else
        {
          float v40 = 0.0;
        }
        if (v40 > **(float **)(a1 + 24))
        {
          BOOL result = vaddq_f32(vmulq_n_f32(a3, v39), vmulq_n_f32(result, 1.0 - v39));
          *(float32x4_t *)*(void *)(a1 + 32) = result;
          **(float **)(a1 + 24) = v40;
        }
      }
    }
  }
  return result;
}

uint64_t re::BucketArray<re::PhysXManifold,256ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 8) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 8)) + 56 * a2;
}

uint64_t re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (10 * v3 < v2 + 1)
  {
    re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 10) / 0xA);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 / 0xA)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 / 0xA));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 % 0xA);
}

uint64_t *re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (10 * a2 > result[5])
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        BOOL result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 800, 0);
        BOOL result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::CollisionCastHit,10ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::PhysXManifold,256ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 8)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 14336, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  uint64_t v4 = *result;
  if (a2 && !v4)
  {
    uint64_t result = (void *)re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(v3, a2);
    int v5 = *((_DWORD *)v3 + 4) + 2;
LABEL_4:
    *((_DWORD *)v3 + 4) = v5;
    return result;
  }
  int v6 = *((_DWORD *)result + 4);
  if (v6) {
    uint64_t v7 = 4;
  }
  else {
    uint64_t v7 = result[4];
  }
  if (v7 != a2)
  {
    unint64_t v8 = result[1];
    if (v8 <= a2 && (a2 > 4 || (v6 & 1) == 0))
    {
      if (a2 < 5)
      {
        float32x2_t v13 = result + 4;
        uint64_t v14 = v3[5];
        if (v6) {
          float32x4_t v15 = v3 + 4;
        }
        else {
          float32x4_t v15 = (const void *)v3[5];
        }
        memcpy(v13, v15, v8 << 6);
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v14);
        int v5 = *((_DWORD *)v3 + 4) | 1;
        goto LABEL_4;
      }
      float32x4_t v9 = (void *)(*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v4 + 32))(*result, a2 << 6, 16);
      if (v9)
      {
        float32x4_t v11 = v9;
        if (v3[2]) {
          int32x4_t v12 = v3 + 4;
        }
        else {
          int32x4_t v12 = (const void *)v3[5];
        }
        uint64_t result = memcpy(v9, v12, v3[1] << 6);
        int v16 = *((_DWORD *)v3 + 4);
        if ((v16 & 1) == 0)
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v3[5]);
          int v16 = *((_DWORD *)v3 + 4);
        }
        *((_DWORD *)v3 + 4) = v16 & 0xFFFFFFFE;
        v3[4] = a2;
        v3[5] = v11;
      }
      else
      {
        re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, a2 << 6, *(void *)(*v3 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
    }
  }
  return result;
}

void *re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  uint64_t v4 = *result;
  if (a2 && !v4)
  {
    uint64_t result = (void *)re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v3, a2);
    int v5 = *((_DWORD *)v3 + 4) + 2;
LABEL_4:
    *((_DWORD *)v3 + 4) = v5;
    return result;
  }
  int v6 = *((_DWORD *)result + 4);
  if (v6) {
    uint64_t v7 = 32;
  }
  else {
    uint64_t v7 = result[3];
  }
  if (v7 != a2)
  {
    unint64_t v8 = result[1];
    if (v8 <= a2 && (a2 > 0x20 || (v6 & 1) == 0))
    {
      if (a2 < 0x21)
      {
        float32x2_t v13 = result + 3;
        uint64_t v14 = v3[4];
        if (v6) {
          float32x4_t v15 = v3 + 3;
        }
        else {
          float32x4_t v15 = (const void *)v3[4];
        }
        memcpy(v13, v15, 8 * v8);
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v14);
        int v5 = *((_DWORD *)v3 + 4) | 1;
        goto LABEL_4;
      }
      float32x4_t v9 = (void *)(*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v4 + 32))(*result, 8 * a2, 8);
      if (v9)
      {
        float32x4_t v11 = v9;
        if (v3[2]) {
          int32x4_t v12 = v3 + 3;
        }
        else {
          int32x4_t v12 = (const void *)v3[4];
        }
        uint64_t result = memcpy(v9, v12, 8 * v3[1]);
        int v16 = *((_DWORD *)v3 + 4);
        if ((v16 & 1) == 0)
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v3[4]);
          int v16 = *((_DWORD *)v3 + 4);
        }
        *((_DWORD *)v3 + 4) = v16 & 0xFFFFFFFE;
        v3[3] = a2;
        v3[4] = v11;
      }
      else
      {
        re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, 8 * a2, *(void *)(*v3 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
    }
  }
  return result;
}

uint64_t physx::PxHitBuffer<physx::PxOverlapHit>::processTouches()
{
  return 0;
}

void physx::PxHitBuffer<physx::PxOverlapHit>::~PxHitBuffer()
{
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      re::CastHitCallback<physx::PxRaycastHit>::addHit(a1, a2);
      a2 += 64;
      --v5;
    }
    while (v5);
  }
  return 1;
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::finalizeQuery(uint64_t result)
{
  if (*(unsigned char *)(result + 72)) {
    return re::CastHitCallback<physx::PxRaycastHit>::addHit(result, result + 8);
  }
  return result;
}

void re::CastHitCallback<physx::PxRaycastHit>::~CastHitCallback()
{
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      re::CastHitCallback<physx::PxSweepHit>::addHit(a1, a2);
      a2 += 56;
      --v5;
    }
    while (v5);
  }
  return 1;
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::finalizeQuery(uint64_t result)
{
  if (*(unsigned char *)(result + 64)) {
    return re::CastHitCallback<physx::PxSweepHit>::addHit(result, result + 8);
  }
  return result;
}

void re::CastHitCallback<physx::PxSweepHit>::~CastHitCallback()
{
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::addHit(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(*(void *)(a1 + 88));
  *(void *)uint64_t v4 = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_DWORD *)(v4 + 48) = 2139095039;
  *(void *)(v4 + 52) = 0xFFFFFFFF00000000;
  *(void *)(v4 + 64) = 0;
  uint64_t v6 = *(void *)(a1 + 88);
  uint64_t v7 = *(void *)(v6 + 40);
  if (v7)
  {
    unint64_t v8 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v6, v7 - 1);
    *(float *)(v8 + 48) = *(float *)(a2 + 48) / *(float *)(a1 + 1892);
    *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 36);
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(*(void *)a2 + 16);
    *(void *)unint64_t v8 = v10;
    uint64_t result = re::internal::nvphysx::findShapeIndex(v10, v9);
    *(_DWORD *)(v8 + 52) = result;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::ContactHitCallback<physx::PxSweepHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = (_DWORD *)(a2 + 48);
    do
    {
      uint64_t v6 = *(void *)(*((void *)v5 - 6) + 16);
      uint64_t v7 = *(void *)(a1 + 96);
      v15.i64[0] = *(void *)(a1 + 88);
      v15.i64[1] = v6;
      uint64_t v8 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(v7, (uint64_t *)&v15);
      if (!v8)
      {
        float32x4_t v11 = *(unint64_t **)(a1 + 96);
        unint64_t v12 = *v11;
        int v22 = 0;
        long long v20 = 0u;
        long long v21 = 0u;
        *(void *)&long long v19 = 0;
        *(_DWORD *)((char *)&v19 + 7) = 0;
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        v18.i64[0] = 0;
        v18.i32[2] = 0;
        float32x4_t v16 = v15;
        float32x4_t v17 = (float32x4_t)v12;
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity(&v17, 0);
        ++v18.i32[2];
        uint64_t v8 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew((uint64_t)v11, (uint64_t *)&v16);
        re::ContactSet::~ContactSet((re::ContactSet *)&v16);
      }
      v9.i64[0] = *((void *)v5 - 3);
      v9.i32[2] = *(v5 - 4);
      v10.i64[0] = *(void *)(v5 - 3);
      v10.i32[2] = *(v5 - 1);
      float v13 = *(float *)v5;
      v5 += 14;
      float32x4_t v16 = vaddq_f32(v9, vmulq_n_f32(v10, v13));
      float32x4_t v17 = v9;
      float32x4_t v18 = v10;
      long long v19 = 0uLL;
      *(float *)&long long v20 = v13;
      re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)(v8 + 16), (uint64_t)&v16);
      --v4;
    }
    while (v4);
  }
  return 1;
}

void re::ContactHitCallback<physx::PxSweepHit>::~ContactHitCallback()
{
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  unint64_t v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v10 = v9 ^ (v9 >> 31);
  if (v8 == v10) {
    unint64_t v10 = 0;
  }
  uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v10 ^ v8) % v2));
  if (v11 != 0x7FFFFFFF)
  {
    uint64_t v12 = *(void *)(a1 + 16);
    while (1)
    {
      uint64_t v13 = v12 + 144 * v11;
      uint64_t v15 = *(void *)(v13 + 16);
      uint64_t result = v13 + 16;
      uint64_t v14 = v15;
      if (v15 == v5 && *(void *)(result + 8) == v6) {
        break;
      }
      if (v14 == v6 && *(void *)(result + 8) == v5) {
        break;
      }
      uint64_t v11 = *(_DWORD *)(v12 + 144 * v11) & 0x7FFFFFFF;
      if (v11 == 0x7FFFFFFF) {
        return 0;
      }
    }
  }
  return result;
}

void *re::FixedArray<physx::PxOverlapHit>::init<>(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  if (a3)
  {
    uint64_t v4 = result;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 24 * a3, 8);
    void v4[2] = result;
    if (result)
    {
      uint64_t v6 = a3 - 1;
      if (a3 != 1)
      {
        do
        {
          *uint64_t result = 0;
          result[1] = 0;
          result[2] = 0xFFFFFFFFLL;
          result += 3;
          --v6;
        }
        while (v6);
      }
      *uint64_t result = 0;
      result[1] = 0;
      result[2] = 0xFFFFFFFFLL;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      uint64_t result = (void *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

re::Allocator *re::internal::nvphysx::initPhysX(re::internal::nvphysx *this)
{
  uint64_t v1 = re::globalAllocators(this);
  unint64_t v2 = (re::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 24, 8);
  uint64_t result = re::Allocator::Allocator(v2, "PhysX", 1);
  *(void *)uint64_t result = &unk_26E6DEC70;
  return result;
}

re *re::internal::destroyPersistent<re::MallocAllocator>(re *result, uint64_t a2, re::Allocator *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::Allocator::~Allocator(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, re::Allocator *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

uint64_t re::internal::nvphysx::findShapeIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 184))(v3) == 1) {
    return 0;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v3 + 184))(v3)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t v6 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v3 + 192))(v3, &v6, 1, v4);
    if (v6 == a2) {
      break;
    }
    uint64_t v4 = (v4 + 1);
    if (v4 >= (*(unsigned int (**)(uint64_t))(*(void *)v3 + 184))(v3)) {
      return 0xFFFFFFFFLL;
    }
  }
  return v4;
}

double re::TriangleMeshShape::massProperties(uint64_t a1, _DWORD *a2, void *a3, _OWORD *a4)
{
  double result = 0.0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  *a3 = 0;
  a3[1] = 0;
  *a2 = 0;
  return result;
}

uint64_t re::TriangleMeshShape::type(re::TriangleMeshShape *this)
{
  return 12;
}

uint64_t re::TriangleMeshShape::isStaticShape(re::TriangleMeshShape *this)
{
  return 1;
}

uint64_t *re::introspect_ShapeType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F788, memory_order_acquire) & 1) == 0)
  {
    float32x4_t v31 = (re *)__cxa_guard_acquire(&qword_26AF7F788);
    if (v31)
    {
      int32x4_t v32 = re::introspectionAllocator(v31);
      float32x2_t v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)float32x2_t v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Unknown";
      qword_26AF7F808 = (uint64_t)v33;
      float32x2_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 3;
      *((void *)v35 + 2) = "Box";
      qword_26AF7F810 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      int32x4_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)int32x4_t v37 = 1;
      *((void *)v37 + 1) = 4;
      *((void *)v37 + 2) = "Capsule";
      qword_26AF7F818 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float v39 = 1;
      *((void *)v39 + 1) = 7;
      *((void *)v39 + 2) = "Compound";
      qword_26AF7F820 = (uint64_t)v39;
      float v40 = re::introspectionAllocator(v39);
      int32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)int32x4_t v41 = 1;
      *((void *)v41 + 1) = 9;
      *((void *)v41 + 2) = "Cone";
      qword_26AF7F828 = (uint64_t)v41;
      float32x4_t v42 = re::introspectionAllocator(v41);
      BOOL v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)BOOL v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "ConvexPolyhedron";
      qword_26AF7F830 = (uint64_t)v43;
      int8x16_t v44 = re::introspectionAllocator(v43);
      int8x16_t v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)int8x16_t v45 = 1;
      *((void *)v45 + 1) = 8;
      *((void *)v45 + 2) = "Cylinder";
      qword_26AF7F838 = (uint64_t)v45;
      float32x2_t v46 = re::introspectionAllocator(v45);
      int32x4_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)int32x4_t v47 = 1;
      *((void *)v47 + 1) = 1;
      *((void *)v47 + 2) = "Empty";
      qword_26AF7F840 = (uint64_t)v47;
      float v48 = re::introspectionAllocator(v47);
      float32x4_t v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)float32x4_t v49 = 1;
      *((void *)v49 + 1) = 6;
      *((void *)v49 + 2) = "Plane";
      qword_26AF7F848 = (uint64_t)v49;
      float32x4_t v50 = re::introspectionAllocator(v49);
      float32x4_t v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)float32x4_t v51 = 1;
      *((void *)v51 + 1) = 11;
      *((void *)v51 + 2) = "Rectangle";
      qword_26AF7F850 = (uint64_t)v51;
      float32x4_t v52 = re::introspectionAllocator(v51);
      float32x4_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)float32x4_t v53 = 1;
      *((void *)v53 + 1) = 2;
      *((void *)v53 + 2) = "Sphere";
      qword_26AF7F858 = (uint64_t)v53;
      float32x4_t v54 = re::introspectionAllocator(v53);
      uint64_t v55 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)uint64_t v55 = 1;
      *(void *)(v55 + 8) = 12;
      *(void *)(v55 + 16) = "TriangleMesh";
      qword_26AF7F860 = v55;
      __cxa_guard_release(&qword_26AF7F788);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F790, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7F790))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF7F7C0, "ShapeType", 4, 4, 1, 1);
    qword_26AF7F7C0 = (uint64_t)&unk_26E715E00;
    qword_26AF7F800 = (uint64_t)&re::introspect_ShapeType(BOOL)::enumTable;
    dword_26AF7F7D0 = 9;
    __cxa_guard_release(&qword_26AF7F790);
  }
  if (v2)
  {
    if (_MergedGlobals_126) {
      return &qword_26AF7F7C0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v61);
    char v3 = _MergedGlobals_126;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v61);
    if (v3) {
      return &qword_26AF7F7C0;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_126)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF7F7C0;
    }
  }
  _MergedGlobals_126 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF7F7C0, a2);
  uint64_t v57 = 0x86222B7974B6;
  float32x4_t v58 = "ShapeType";
  v61[0] = 208862;
  v61[1] = "int";
  unint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v61);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v61);
    unint64_t v9 = (unsigned int *)qword_26AF7F800;
    v60[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v61, &v57, 1, 1, (uint64_t)v60);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                float32x4_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v59.var0 = 2 * v15;
          v59.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v61, v19, &v59);
          re::StringID::destroyString((re::StringID *)&v59);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            int v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  uint64_t v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v59.var0 = 2 * v23;
            v59.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v61, v27, &v59);
            re::StringID::destroyString((re::StringID *)&v59);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v61, v28);
    xmmword_26AF7F7E0 = (__int128)v59;
    re::StringID::destroyString((re::StringID *)&v57);
    if (v2) {
      return &qword_26AF7F7C0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v61);
  re::internal::assertLog((re::internal *)5, v56, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ShapeType", v57, v58);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::CollisionShape::localTransform(re::CollisionShape *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F798, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7F798))
  {
    qword_26AF7F7A0 = 0;
    unk_26AF7F7A8 = 0;
    qword_26AF7F7B0 = 0;
    unk_26AF7F7B8 = 0x3F80000000000000;
    __cxa_guard_release(&qword_26AF7F798);
  }
  return &qword_26AF7F7A0;
}

uint64_t re::PhysXManifoldContainer::size(re::PhysXManifoldContainer *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 40);
}

uint64_t re::PhysXManifoldContainer::rawManifold(re::PhysXManifoldContainer *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (*(void *)(v2 + 40) <= (unint64_t)a2) {
    return 0;
  }
  if (*(void *)(v2 + 8) <= (unint64_t)a2 >> 8)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(v2 + 16)) {
    uint64_t v3 = v2 + 24;
  }
  else {
    uint64_t v3 = *(void *)(v2 + 32);
  }
  return *(void *)(v3 + 8 * ((unint64_t)a2 >> 8)) + 56 * a2;
}

uint64_t re::PhysXManifoldContainer::numContacts(re::PhysXManifoldContainer *this, unsigned int *a2)
{
  return a2[8];
}

uint64_t re::PhysXManifoldContainer::collisionObjectA(re::PhysXManifoldContainer *this, const void *a2)
{
  return *(void *)a2;
}

uint64_t re::PhysXManifoldContainer::collisionObjectB(re::PhysXManifoldContainer *this, void *a2)
{
  return a2[1];
}

float32_t re::PhysXManifoldContainer::setContacts(re::PhysXManifoldContainer *this, void *a2, re::ContactSet *a3, signed __int32 a4, int a5, char a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, float32x4_t a13, float32x4_t a14)
{
  if (a5)
  {
    if (!a2[4]) {
      goto LABEL_22;
    }
    a7.i32[0] = 0;
    float v14 = -*(float *)(a2[6] + 12);
    a9.i32[0] = a4;
    float32x4_t v15 = (float32x4_t)vandq_s8(*((int8x16_t *)a3 + 5), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a9, a7)), 0));
    if (a4) {
      float v14 = *((float *)a3 + 24);
    }
    if (a5 >= 1)
    {
      uint64_t v16 = 0;
      unint64_t v17 = 0;
      uint64_t v18 = 80 * a4;
      float32x4_t v19 = 0uLL;
      while (a2[4] > v17)
      {
        uint64_t v20 = a2[6] + v16;
        if (a6)
        {
          a12.i64[0] = *(void *)v20;
          a10.i64[0] = *(void *)(v20 + 12);
          float32x4_t v21 = a10;
          v21.i32[1] = *(_DWORD *)(v20 + 20);
          *(float32x2_t *)a11.f32 = vadd_f32(vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a10.f32), *(float32x2_t *)v21.f32), *(float32x2_t *)v20);
          a12.i32[2] = *(_DWORD *)(v20 + 8);
          a11.f32[2] = a12.f32[2] + (float)(*(float *)(v20 + 24) * a10.f32[0]);
          a13.i64[0] = *(void *)(v20 + 16);
          a13.i32[2] = *(_DWORD *)(v20 + 24);
          a13 = vnegq_f32(a13);
          v21.i64[0] = *(void *)(v20 + 32);
          v21.i32[2] = *(_DWORD *)(v20 + 40);
          a14 = vnegq_f32(v21);
        }
        else
        {
          a10.i64[0] = *(void *)(v20 + 12);
          a11 = a10;
          a11.i32[1] = *(_DWORD *)(v20 + 20);
          float32x2_t v22 = vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a10.f32), *(float32x2_t *)a11.f32);
          a11.i64[0] = *(void *)v20;
          *(float32x2_t *)a12.f32 = vadd_f32(v22, *(float32x2_t *)v20);
          a12.f32[2] = (float)(*(float *)(v20 + 24) * a10.f32[0]) + *(float *)(v20 + 8);
          a11.i32[2] = *(_DWORD *)(v20 + 8);
          a13.i64[0] = *(void *)(v20 + 16);
          a13.i32[2] = *(_DWORD *)(v20 + 24);
          a14.i64[0] = *(void *)(v20 + 32);
          a14.i32[2] = *(_DWORD *)(v20 + 40);
        }
        if (*((void *)a3 + 4) <= a4 + v17) {
          goto LABEL_21;
        }
        uint64_t v23 = (__n128 *)(*((void *)a3 + 6) + v18);
        __n128 *v23 = (__n128)a12;
        v23[1] = (__n128)a11;
        v23[2] = (__n128)a13;
        v23[3] = (__n128)a14;
        v23[4].n128_u32[0] = a10.i32[0];
        a11 = vaddq_f32(a11, a12);
        float32x4_t v19 = vaddq_f32(v19, a11);
        float32x4_t v15 = vaddq_f32(v15, a14);
        float v24 = -a10.f32[0];
        if (v14 < v24) {
          float v14 = v24;
        }
        ++v17;
        v16 += 48;
        v18 += 80;
        if (48 * a5 == v16) {
          goto LABEL_19;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_21:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_22:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    a7.i32[0] = 0;
    a8.i32[0] = a4;
    float32x4_t v15 = (float32x4_t)vandq_s8(*((int8x16_t *)a3 + 5), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a8, a7)), 0));
    float v14 = *((float *)a3 + 24);
    if (!a4) {
      float v14 = 0.0;
    }
  }
  float32x4_t v19 = 0uLL;
LABEL_19:
  a10.f32[0] = (float)(2 * a5);
  float32x4_t v25 = vaddq_f32(vdivq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 0)), *((float32x4_t *)a3 + 4));
  v26.i64[0] = 0x3F0000003F000000;
  v26.i64[1] = 0x3F0000003F000000;
  *((float32x4_t *)a3 + 4) = vmulq_f32(v25, v26);
  *((float32x4_t *)a3 + 5) = v15;
  *((float *)a3 + 24) = v14;
  return v15.f32[0];
}

void re::PhysXManifoldContainer::~PhysXManifoldContainer(re::PhysXManifoldContainer *this)
{
}

void re::internal::PhysXControllerHitReport::onHit(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  *(void *)&a3->f64[0] = a1;
  float64x2_t v5 = *(float64x2_t *)(a2 + 8);
  *(float32x2_t *)&v5.f64[0] = vcvt_f32_f64(v5);
  float v6 = *(double *)(a2 + 24);
  *(float *)&v5.f64[1] = v6;
  a3[1] = v5;
  v5.f64[0] = *(float64_t *)(a2 + 32);
  LODWORD(v5.f64[1]) = *(_DWORD *)(a2 + 40);
  a3[2] = v5;
  LODWORD(a3[4].f64[0]) = *(_DWORD *)(a2 + 56);
  v5.f64[0] = *(float64_t *)(a2 + 44);
  LODWORD(v5.f64[1]) = *(_DWORD *)(a2 + 52);
  a3[3] = v5;
  v7.i64[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
  v7.i64[1] = v8;
  float32x4_t v9 = vmulq_f32((float32x4_t)a3[1], v7);
  float v28 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  v10.i64[0] = (*(uint64_t (**)(void))(**(void **)&a3->f64[0] + 88))();
  v10.i64[1] = v11;
  float32x4_t v27 = v10;
  v12.i64[0] = (*(uint64_t (**)(void))(**(void **)&a3->f64[0] + 160))();
  v12.i64[1] = v13;
  float32x4_t v14 = vmulq_f32(v27, v12);
  v27.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0];
  float v15 = (*(float (**)(void))(**(void **)a2 + 232))();
  float64_t v16 = a3->f64[0];
  if (v28 < (float)(v27.f32[0] + (float)(v15 * -0.5)))
  {
    *(unsigned char *)(*(void *)&v16 + 76) |= 1u;
    unint64_t v17 = *(re::CollisionObject **)&a3->f64[1];
    if (*((unsigned char *)v17 + 8))
    {
      re::CollisionObject::weakPointer(v17, from);
      if (from != (id *)(*(void *)&v16 + 96))
      {
        objc_destroyWeak((id *)(*(void *)&v16 + 96));
        *(void *)(*(void *)&v16 + 96) = 0;
        objc_moveWeak((id *)(*(void *)&v16 + 96), from);
      }
      objc_destroyWeak(from);
      (*(void (**)(id *__return_ptr))(**(void **)(*(void *)&a3->f64[1] + 16) + 40))(from);
      *(_OWORD *)(*(void *)&v16 + 80) = *(_OWORD *)from;
    }
    else
    {
      objc_destroyWeak((id *)(*(void *)&v16 + 96));
      *(void *)(*(void *)&v16 + 96) = 0;
    }
  }
  int v18 = *(_DWORD *)(*(void *)&v16 + 248);
  *(_DWORD *)(*(void *)&v16 + 248) = v18 + 1;
  if (*(void *)(*(void *)&v16 + 184))
  {
    unint64_t v19 = 0;
    do
    {
      if ((*(unsigned int (**)(float64x2_t *))(*(void *)(*(void *)&v16 + 200) + 32 * v19 + 24))(a3) == 1) {
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((void *)(*(void *)&v16 + 168), v19);
      }
      else {
        ++v19;
      }
    }
    while (v19 < *(void *)(*(void *)&v16 + 184));
    int v18 = *(_DWORD *)(*(void *)&v16 + 248) - 1;
  }
  *(_DWORD *)(*(void *)&v16 + 248) = v18;
  if (!v18)
  {
    uint64_t v20 = *(void *)(*(void *)&v16 + 224);
    if (v20)
    {
      uint64_t v21 = 0;
      for (unint64_t i = 0; i != v20; ++i)
      {
        unint64_t v23 = *(void *)(*(void *)&v16 + 224);
        if (v23 <= i)
        {
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          *(_OWORD *)from = 0u;
          long long v40 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v31 = 136315906;
          int32x4_t v32 = "operator[]";
          __int16 v33 = 1024;
          int v34 = 789;
          __int16 v35 = 2048;
          unint64_t v36 = i;
          __int16 v37 = 2048;
          unint64_t v38 = v23;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v24 = *(void *)(*(void *)&v16 + 240) + v21;
        uint64_t v25 = *(void *)(v24 + 32);
        long long v26 = *(_OWORD *)(v24 + 16);
        v29[0] = *(_OWORD *)v24;
        v29[1] = v26;
        uint64_t v30 = v25;
        if (LOBYTE(v29[0]))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(*(void *)&v16 + 168, (void *)v29 + 1, (uint64_t)from);
          if (!LOBYTE(from[0])) {
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(*(void *)&v16 + 168), (uint64_t)v29 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(*(void *)&v16 + 168, (void *)v29 + 1, (uint64_t)from);
          if (LOBYTE(from[0])) {
            re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((void *)(*(void *)&v16 + 168), (unint64_t)from[1]);
          }
        }
        v21 += 40;
      }
    }
  }
}

void re::internal::PhysXControllerHitReport::onShapeHit(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  memset(&v2[1], 0, 48);
  v2[0].f64[1] = *(float64_t *)(*(void *)(a2 + 72) + 16);
  re::internal::PhysXControllerHitReport::onHit(*(void *)(a1 + 8), a2, v2);
}

void re::internal::PhysXControllerHitReport::onControllerHit(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  memset(&v4[1], 0, 48);
  v4[0].f64[1] = *(float64_t *)((*(uint64_t (**)(void))(**(void **)a2 + 160))() + 136);
  re::internal::PhysXControllerHitReport::onHit(*(void *)(a1 + 8), a2, v4);
}

void re::internal::PhysXCapsuleController::~PhysXCapsuleController(re::internal::PhysXCapsuleController *this)
{
  *(void *)this = &unk_26E6DD848;
  (*(void (**)(void, void))(**((void **)this + 17) + 40))(*((void *)this + 17), 0);
  (*(void (**)(void))(**((void **)this + 19) + 8))(*((void *)this + 19));
  *((void *)this + 19) = 0;
  re::CharacterController::~CharacterController(this);
}

{
  uint64_t vars8;

  re::internal::PhysXCapsuleController::~PhysXCapsuleController(this);
  JUMPOUT(0x237DBCBD0);
}

__n128 re::internal::PhysXCapsuleController::pose@<Q0>(re::internal::PhysXCapsuleController *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 19);
  uint64_t v4 = (float64x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  uint64_t v9 = 0x3F80000000000000;
  int v10 = 0;
  (*(void (**)(float *__return_ptr, uint64_t))(*(void *)v3 + 112))(v8, v3);
  physx::PxShortestRotation((float *)&v9, v8, (float *)(a2 + 16));
  float64x2_t v6 = *v4;
  *(float32x2_t *)&v6.f64[0] = vcvt_f32_f64(*v4);
  float v5 = v4[1].f64[0];
  *(float *)&v6.f64[1] = v5;
  *(float64x2_t *)a2 = v6;
  result.n128_u64[0] = *(void *)&v6.f64[0];
  result.n128_u32[2] = LODWORD(v6.f64[1]);
  return result;
}

uint64_t re::internal::PhysXCapsuleController::setPoseInternal(uint64_t a1, uint64_t a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v4 = 1;
  }
  else {
    int v4 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  uint64_t v5 = *(void *)(a1 + 152);
  double v6 = *(float *)(a2 + 8);
  float64x2_t v15 = vcvtq_f64_f32(*(float32x2_t *)a2);
  double v16 = v6;
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v5 + 24))(v5, &v15);
  float32x4_t v7 = *(float32x4_t *)(a2 + 16);
  float32x4_t v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
  float32x4_t v9 = vmlaq_f32(vmulq_f32(v7, (float32x4_t)xmmword_23437C090), (float32x4_t)xmmword_23435FD60, v8);
  int32x4_t v10 = (int32x4_t)vaddq_f32(v9, v9);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL);
  int32x4_t v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v7)), v11, v8);
  float32x4_t v13 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v11, v7, 3), (float32x4_t)xmmword_23435FD60), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL));
  *(void *)&v15.f64[0] = v13.i64[0];
  LODWORD(v15.f64[1]) = v13.i32[2];
  uint64_t result = (*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)v5 + 120))(v5, &v15);
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 1;
  if (physx::shdfnd::g_isLockingEnabled != v4) {
    physx::shdfnd::g_isLockingEnabled = v4;
  }
  return result;
}

void re::internal::PhysXCapsuleController::updateVelocity(re::internal::PhysXCapsuleController *this, double a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v3 = 1;
  }
  else {
    int v3 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  if (*((unsigned char *)this + 132))
  {
    LODWORD(a2) = *((_DWORD *)this + 32);
    float32x4_t v4 = 0uLL;
    if (*(float *)&a2 > 0.0) {
      float32x4_t v4 = vdivq_f32(*((float32x4_t *)this + 7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0));
    }
    *((float32x4_t *)this + 16) = v4;
    *((void *)this + 14) = 0;
    *((void *)this + 15) = 0;
    *(void *)((char *)this + 125) = 0;
  }
  if (re::CharacterController::onPlatform((id *)this))
  {
    if (*((unsigned char *)this + 76))
    {
      uint64_t v5 = re::CharacterController::onPlatform((id *)this);
      (*(void (**)(float32x4_t *__return_ptr))(**(void **)(v5 + 16) + 40))(v13);
      float32x4_t v10 = vsubq_f32(v13[0], *((float32x4_t *)this + 5));
      v6.i64[0] = (*(uint64_t (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 88))(this);
      v6.i64[1] = v7;
      float32x4_t v8 = vaddq_f32(v10, v6);
      uint64_t v9 = *((void *)this + 19);
      float64x2_t v11 = vcvtq_f64_f32(*(float32x2_t *)v8.f32);
      double v12 = v8.f32[2];
      (*(void (**)(uint64_t, float64x2_t *))(*(void *)v9 + 24))(v9, &v11);
      *((float32x4_t *)this + 5) = v13[0];
    }
    else
    {
      objc_destroyWeak((id *)this + 12);
      *((void *)this + 12) = 0;
    }
  }
  if (physx::shdfnd::g_isLockingEnabled != v3) {
    physx::shdfnd::g_isLockingEnabled = v3;
  }
}

uint64_t re::internal::PhysXCapsuleController::move(float32x4_t *a1, float32x4_t *a2, float a3)
{
  int v6 = physx::shdfnd::g_isLockingEnabled;
  if (physx::shdfnd::g_isLockingEnabled) {
    int v7 = 1;
  }
  else {
    int v7 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
  {
    int v6 = 0;
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  a1[8].f32[0] = a1[8].f32[0] + a3;
  a1[8].i8[4] = 1;
  float32x4_t v8 = vmulq_f32(*a2, *a2);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0] >= 1.0e-10)
  {
    v10.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v10.i64[1] = v11;
    float32x4_t v12 = vmulq_f32(*a2, v10);
    float32x4_t v60 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)));
    uint64_t v13 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    uint64_t v15 = v14;
    if (v60.f32[0] > 0.0) {
      a1[4].i8[12] &= ~1u;
    }
    int v16 = *(_DWORD *)(a1[8].i64[1] + 32);
    int v17 = *(_DWORD *)(a1[8].i64[1] + 36);
    v70[0] = &unk_26E6DD5E8;
    v70[1] = 0;
    int v71 = v16;
    int v72 = v17;
    int v73 = 2;
    uint64_t v67 = 0;
    int v68 = v16;
    int v69 = v17;
    v64[0] = &v67;
    v64[1] = v70;
    __int16 v65 = 7;
    uint64_t v66 = 0;
    uint64_t v18 = a1[9].i64[1];
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
    double v20 = *(double *)(v19 + 16);
    uint64_t v21 = a1[9].i64[1];
    __int32 v22 = a2->i32[2];
    uint64_t v61 = a2->i64[0];
    __int32 v62 = v22;
    float64x2_t v57 = *(float64x2_t *)v19;
    (*(void (**)(unsigned __int8 *__return_ptr, uint64_t, uint64_t *, void *, void, double, float))(*(void *)v21 + 16))(&v63, v21, &v61, v64, 0, 0.0, a3);
    uint64_t v9 = v63;
    unint64_t v23 = (float64x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
    *(float32x2_t *)v24.f32 = vcvt_f32_f64(vsubq_f64(*v23, v57));
    *(float *)&unsigned int v25 = v23[1].f64[0] - v20;
    v24.i64[1] = __PAIR64__(HIDWORD(v57.f64[1]), v25);
    float32x4_t v58 = v24;
    v26.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v26.i64[1] = v27;
    float32x4_t v28 = vmulq_f32(v58, v26);
    float32x4_t v56 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1)));
    uint64_t v29 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    float32x4_t v30 = v56;
    v31.i64[0] = v29;
    v31.i64[1] = v32;
    float32x4_t v33 = vmulq_n_f32(v31, v56.f32[0]);
    float32x4_t v34 = vsubq_f32(v58, v33);
    float32x4_t v35 = *a2;
    float32x4_t v36 = vmulq_f32(*a2, v33);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0] > 0.0)
    {
      float v37 = fabsf(v60.f32[0]);
      if (v37 > 0.00001)
      {
        float32x4_t v59 = v34;
        float32x4_t v54 = v33;
        v38.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
        v38.i64[1] = v39;
        float32x4_t v40 = vmulq_f32(v54, v38);
        float v41 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0];
        if (v37 <= v41) {
          float v41 = v37;
        }
        float v55 = v41;
        uint64_t v42 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
        float32x4_t v30 = v56;
        float32x4_t v34 = v59;
        v43.i64[0] = v42;
        v43.i64[1] = v44;
        a1[7] = vaddq_f32(a1[7], vmulq_n_f32(v43, v55));
        float32x4_t v35 = *a2;
      }
    }
    float32x4_t v45 = vmulq_f32(v34, v35);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0] > 0.0)
    {
      v46.i64[0] = v13;
      v46.i64[1] = v15;
      float32x4_t v47 = vsubq_f32(v35, vmulq_n_f32(v46, v60.f32[0]));
      float32x4_t v48 = vmulq_f32(v47, v47);
      int32x2_t v49 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).u64[0];
      *(float *)v49.i32 = sqrtf(*(float *)v49.i32);
      if (*(float *)v49.i32 > 0.00001)
      {
        float32x4_t v50 = vdivq_f32(v47, (float32x4_t)vdupq_lane_s32(v49, 0));
        float32x4_t v51 = vmulq_f32(v34, v50);
        float v52 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0];
        if (*(float *)v49.i32 > v52) {
          *(float *)v49.i32 = v52;
        }
        a1[7] = vaddq_f32(vmulq_n_f32(v50, *(float *)v49.i32), a1[7]);
      }
    }
    if (v60.f32[0] < 0.0 && (a1[4].i8[12] & 1) != 0 && v30.f32[0] < 0.0 && fabsf(vsubq_f32(v60, v30).f32[0]) < 0.0001) {
      a1[4].i8[12] &= ~1u;
    }
    int v6 = physx::shdfnd::g_isLockingEnabled;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v6 != v7) {
    physx::shdfnd::g_isLockingEnabled = v7;
  }
  return v9;
}

float32x2_t re::internal::PhysXCapsuleController::position(re::internal::PhysXCapsuleController *this)
{
  return vcvt_f32_f64(*(float64x2_t *)(*(uint64_t (**)(void))(**((void **)this + 19) + 32))(*((void *)this + 19)));
}

float32x2_t re::internal::PhysXCapsuleController::footPosition(re::internal::PhysXCapsuleController *this)
{
  v1.f64[0] = (*(double (**)(void))(**((void **)this + 19) + 48))(*((void *)this + 19));
  v1.f64[1] = v2;
  return vcvt_f32_f64(v1);
}

uint64_t re::internal::PhysXCapsuleController::setFootPosition(uint64_t a1, float32x2_t *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v2 = 1;
  }
  else {
    int v2 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  uint64_t v3 = *(void *)(a1 + 152);
  double v4 = a2[1].f32[0];
  float64x2_t v6 = vcvtq_f64_f32(*a2);
  double v7 = v4;
  uint64_t result = (*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)v3 + 40))(v3, &v6);
  if (physx::shdfnd::g_isLockingEnabled != v2) {
    physx::shdfnd::g_isLockingEnabled = v2;
  }
  return result;
}

void re::internal::PhysXCapsuleController::setPosition(uint64_t a1, float32x2_t *a2)
{
  if (physx::shdfnd::g_isLockingEnabled) {
    int v3 = 1;
  }
  else {
    int v3 = physx::shdfnd::g_alwaysUseLocking;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled) {
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  uint64_t v4 = *(void *)(a1 + 152);
  double v5 = a2[1].f32[0];
  float64x2_t v6 = vcvtq_f64_f32(*a2);
  double v7 = v5;
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v4 + 24))(v4, &v6);
  objc_destroyWeak((id *)(a1 + 96));
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 76) &= ~1u;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 1;
  if (physx::shdfnd::g_isLockingEnabled != v3) {
    physx::shdfnd::g_isLockingEnabled = v3;
  }
}

float re::internal::PhysXCapsuleController::radius(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 85);
}

uint64_t re::internal::PhysXCapsuleController::setRadius(re::internal::PhysXCapsuleController *this, float a2)
{
  *((float *)this + 85) = a2;
  uint64_t v2 = *((void *)this + 19);
  v3.n128_f32[0] = COERCE_FLOAT((*(uint64_t (**)(void))(**((void **)this + 17) + 16))(*((void *)this + 17)))
                 * a2;
  uint64_t v4 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v2 + 224);
  return v4(v2, v3);
}

float re::internal::PhysXCapsuleController::height(re::internal::PhysXCapsuleController *this)
{
  float v1 = *((float *)this + 84);
  return v1
       + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 176))(this) * 2.0);
}

uint64_t re::internal::PhysXCapsuleController::setHeight(re::internal::PhysXCapsuleController *this, float a2)
{
  float v3 = a2
     + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 176))(this) * -2.0);
  if (v3 >= 0.01) {
    float v4 = v3;
  }
  else {
    float v4 = 0.01;
  }
  *((float *)this + 84) = v4;
  uint64_t v5 = *((void *)this + 19);
  v6.n128_f32[0] = v4
                 * COERCE_FLOAT((*(uint64_t (**)(void))(**((void **)this + 17) + 16))(*((void *)this + 17)));
  double v7 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 240);
  return v7(v5, v6);
}

uint64_t re::internal::PhysXCapsuleController::resize(re::internal::PhysXCapsuleController *this, float a2)
{
  float v3 = a2
     + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 176))(this) * -2.0);
  if (v3 >= 0.01) {
    float v4 = v3;
  }
  else {
    float v4 = 0.01;
  }
  *((float *)this + 84) = v4;
  uint64_t v5 = *((void *)this + 19);
  v6.n128_f32[0] = v4
                 * COERCE_FLOAT((*(uint64_t (**)(void))(**((void **)this + 17) + 16))(*((void *)this + 17)));
  double v7 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 192);
  return v7(v5, v6);
}

uint64_t re::internal::PhysXCapsuleController::setSkinWidth(re::internal::PhysXCapsuleController *this, float a2)
{
  LODWORD(v4) = (*(uint64_t (**)(void))(**((void **)this + 17) + 16))(*((void *)this + 17));
  v5.n128_f32[0] = (*(float (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 176))(this)
                 * 0.1;
  if (v5.n128_f32[0] > a2) {
    v5.n128_f32[0] = a2;
  }
  *((_DWORD *)this + 16) = v5.n128_u32[0];
  v5.n128_f32[0] = v5.n128_f32[0] * v4;
  __n128 v6 = *(uint64_t (**)(__n128))(**((void **)this + 19) + 104);
  return v6(v5);
}

float re::internal::PhysXCapsuleController::skinWidth(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 16);
}

uint64_t re::internal::PhysXCapsuleController::setSlopeLimit(re::internal::PhysXCapsuleController *this, float a2)
{
  float v2 = 1.0;
  if (a2 <= 1.0) {
    float v2 = a2;
  }
  if (a2 >= 0.0) {
    float v3 = v2;
  }
  else {
    float v3 = 0.0;
  }
  *((float *)this + 18) = v3;
  uint64_t v4 = *((void *)this + 19);
  v5.n128_f32[0] = cosf(v3);
  __n128 v6 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v4 + 136);
  return v6(v4, v5);
}

float re::internal::PhysXCapsuleController::slopeLimit(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 18);
}

uint64_t re::internal::PhysXCapsuleController::setStepLimit(re::internal::PhysXCapsuleController *this, float a2)
{
  if (a2 >= 0.0) {
    float v3 = a2;
  }
  else {
    float v3 = 0.0;
  }
  LODWORD(v4) = (*(uint64_t (**)(void))(**((void **)this + 17) + 16))(*((void *)this + 17));
  v5.n128_f32[0] = (*(float (**)(re::internal::PhysXCapsuleController *))(*(void *)this + 176))(this)
                 * 0.2;
  if (v5.n128_f32[0] > v3) {
    v5.n128_f32[0] = v3;
  }
  *((_DWORD *)this + 17) = v5.n128_u32[0];
  v5.n128_f32[0] = v5.n128_f32[0] * v4;
  __n128 v6 = *(uint64_t (**)(__n128))(**((void **)this + 19) + 64);
  return v6(v5);
}

float re::internal::PhysXCapsuleController::stepLimit(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 17);
}

uint64_t re::internal::PhysXCapsuleController::setUpVector(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 152);
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v5 = *a2;
  int v6 = v3;
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 120))(v2, &v5);
}

uint64_t re::internal::PhysXCapsuleController::upVector(re::internal::PhysXCapsuleController *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 19) + 112))(&v2);
  return v2;
}

uint64_t re::internal::PhysXCapsuleController::onScaleChanged(float *a1)
{
  (*(void (**)(float *, float))(*(void *)a1 + 184))(a1, a1[85]);
  (*(void (**)(float *, float))(*(void *)a1 + 200))(a1, a1[84] + (float)(a1[85] * 2.0));
  (*(void (**)(float *, float))(*(void *)a1 + 104))(a1, a1[17]);
  v2.n128_f32[0] = a1[17];
  int v3 = *(uint64_t (**)(float *, __n128))(*(void *)a1 + 136);
  return v3(a1, v2);
}

uint64_t re::internal::PhysXCapsuleController::onCollisionFilterChanged(re::internal::PhysXCapsuleController *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 19) + 144))();
}

uint64_t re::internal::PhysXCapsuleController::recreateUnderlying(void *a1, float32x2_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v21 = 0x100000000;
  float v19 = (*(float (**)(void *))(*a1 + 192))(a1);
  float v20 = (*(float (**)(void *))(*a1 + 176))(a1);
  v17[0] = (*(float (**)(void *))(*a1 + 112))(a1);
  v17[1] = (*(float (**)(void *))(*a1 + 128))(a1);
  void v17[2] = (*(float (**)(void *))(*a1 + 144))(a1);
  float32x4_t v10 = (void *)a1[17];
  uint64_t v18 = v10[4];
  LODWORD(v11) = (*(uint64_t (**)(void *))(*v10 + 16))(v10);
  uint64_t v12 = a1[46];
  uint64_t v13 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
  re::internal::PhysXCapsuleController::createUnderlyingController(a1, v12, v13, v17, a2, a3, a4, a5, v11);
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)a1[19] + 56))(a1[19]);
  uint64_t v15 = *(uint64_t (**)(void *, uint64_t))(*v10 + 40);
  return v15(v10, v14);
}

uint64_t re::internal::PhysXCapsuleController::createUnderlyingController(void *a1, uint64_t a2, uint64_t a3, float *a4, float32x2_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, float a9)
{
  float v13 = a4[6];
  float v14 = a4[5] + (float)(v13 * -2.0);
  if (v14 < 0.01) {
    float v14 = 0.01;
  }
  int v49 = 1;
  int v42 = 1069547520;
  uint64_t v48 = 0;
  uint64_t v38 = 0;
  char v47 = 1;
  uint64_t v32 = &unk_26E6DD9B8;
  float v15 = v14 * a9;
  float v50 = v13 * a9;
  float v51 = v14 * a9;
  double v16 = a5[1].f32[0];
  float64x2_t v33 = vcvtq_f64_f32(*a5);
  uint64_t v46 = a8;
  uint64_t v17 = *a6;
  double v34 = v16;
  uint64_t v35 = v17;
  float v18 = (float)(v13 * a9) * 0.1;
  float v19 = a4[1];
  if (v18 <= (float)(*a4 * a9)) {
    float v20 = v18;
  }
  else {
    float v20 = *a4 * a9;
  }
  int v36 = *((_DWORD *)a6 + 2);
  float v21 = a4[2] * a9;
  if ((float)(v15 * 0.2) <= v21) {
    float v22 = v15 * 0.2;
  }
  else {
    float v22 = v21;
  }
  float v39 = v20;
  float v40 = v22;
  float v23 = cosf(v19);
  float v37 = v23;
  uint64_t v41 = 0x3F80000041200000;
  int v52 = 1;
  int v45 = 1;
  float32x4_t v43 = a1 + 43;
  uint64_t v44 = a1 + 45;
  if (v22 < 0.0) {
    float v40 = 0.0;
  }
  float v24 = 0.0;
  if (v23 < 0.0 || (float v24 = 1.0, v23 > 1.0)) {
    float v37 = v24;
  }
  uint64_t v25 = (*(uint64_t (**)(void, void **))(**(void **)(a7 + 160) + 32))(*(void *)(a7 + 160), &v32);
  if (v25)
  {
    uint64_t v27 = v25;
    a1[19] = v25;
    (*(void (**)(uint64_t, void *))(*(void *)v25 + 168))(v25, a1);
    uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 56))(v27);
    uint64_t v31 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)v28 + 192))(v28, &v31, 1, 0);
    uint64_t v29 = v31;
    a1[7] = v31;
    *(void *)(v29 + 16) = a1;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 152) + 112))(*(void *)(a7 + 152), v28, 1);
    a1[18] = a3;
    a1[46] = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) Error creating character controller, check parameters", "pxcontroller != nullptr", "createUnderlyingController", 373);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::internal::PhysXControllerHitReport::~PhysXControllerHitReport(re::internal::PhysXControllerHitReport *this)
{
}

uint64_t re::CharacterController::shape(re::CharacterController *this)
{
  return *((void *)this + 18);
}

{
  return *((void *)this + 18);
}

void re::internal::PhysXCapsuleController::poseDidChange(re::internal::PhysXCapsuleController *this, uint64_t a2)
{
}

uint64_t re::CharacterController::type(re::CharacterController *this)
{
  return 1;
}

BOOL physx::PxCapsuleControllerDesc::isValid(physx::PxCapsuleControllerDesc *this)
{
  if (*((_DWORD *)this + 32) <= 1u
    && *((float *)this + 17) >= 0.0
    && *((float *)this + 18) >= 1.0
    && *((float *)this + 16) >= 0.0
    && *((float *)this + 11) >= 0.0
    && (float v1 = *((float *)this + 15), v1 >= 0.0)
    && *((float *)this + 14) > 0.0
    && *((void *)this + 13)
    && (float v2 = *((double *)this + 1), (~LODWORD(v2) & 0x7F800000) != 0)
    && (float v3 = *((double *)this + 2), (~LODWORD(v3) & 0x7F800000) != 0)
    && (float v4 = *((double *)this + 3), (~LODWORD(v4) & 0x7F800000) != 0)
    && (float v5 = *((float *)this + 33), v5 > 0.0)
    && (float v6 = *((float *)this + 34), v6 > 0.0))
  {
    return v1 <= (float)(v6 + (float)(v5 * 2.0));
  }
  else
  {
    return 0;
  }
}

void physx::PxCapsuleControllerDesc::~PxCapsuleControllerDesc(physx::PxCapsuleControllerDesc *this)
{
}

double physx::PxCapsuleControllerDesc::setToDefault(physx::PxCapsuleControllerDesc *this)
{
  double result = 0.0078125;
  *((void *)this + 8) = 0x3F4CCCCD41200000;
  *((_DWORD *)this + 18) = 1069547520;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = 0;
  *((_OWORD *)this + 2) = xmmword_23437C2E0;
  *((_OWORD *)this + 3) = xmmword_23437C2F0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 112) = 1;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 33) = 0;
  return result;
}

void re::ContactSetCollection::~ContactSetCollection(re::ContactSetCollection *this)
{
  if (*(void *)this) {
    re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this);
  }
  re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this);
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  float v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    double v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    float32x4_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      float v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 144 * v10, 16);
  if (v12)
  {
    float v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_7, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

double re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::ContactSet::~ContactSet((re::ContactSet *)(v6 + v4 + 16));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 144;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_8, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::ContactSet::~ContactSet((re::ContactSet *)(v6 + v4 + 16));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 144;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::ContactSetCollection::set(uint64_t a1, uint64_t a2)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a1 + 28);
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (*(_DWORD *)(a1 + 24) < (v5 + v4))
  {
    uint64_t v6 = *(unsigned int *)(a1 + 32);
    if (v6)
    {
      uint64_t v7 = 0;
      int v8 = *(int **)(a1 + 16);
      while (1)
      {
        int v9 = *v8;
        v8 += 36;
        if (v9 < 0) {
          break;
        }
        if (v6 == ++v7)
        {
          LODWORD(v7) = *(_DWORD *)(a1 + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if (v6 != v7)
    {
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = (void *)(*(void *)(a1 + 16) + 144 * v10);
        *(void *)(v11[2] + 80) = 0;
        *(void *)(v11[3] + 80) = 0;
        v11[16] = 0;
        v11[17] = 0;
        if (*(_DWORD *)(a1 + 32) <= (v7 + 1)) {
          int v12 = v7 + 1;
        }
        else {
          int v12 = *(_DWORD *)(a1 + 32);
        }
        int v13 = v7;
        while (1)
        {
          uint64_t v10 = (v13 + 1);
          if (v12 - 1 == v13) {
            break;
          }
          ++v13;
          LODWORD(v7) = v10;
          if ((*(_DWORD *)(*(void *)(a1 + 16) + 144 * v10) & 0x80000000) != 0) {
            goto LABEL_18;
          }
        }
        LODWORD(v7) = v12;
LABEL_18:
        ;
      }
      while (v6 != v7);
    }
    re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(a1, 2 * (v5 + v4));
    uint64_t v14 = *(unsigned int *)(a1 + 32);
    if (v14)
    {
      uint64_t v15 = 0;
      double v16 = *(int **)(a1 + 16);
      while (1)
      {
        int v17 = *v16;
        v16 += 36;
        if (v17 < 0) {
          break;
        }
        if (v14 == ++v15)
        {
          LODWORD(v15) = *(_DWORD *)(a1 + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v15) = 0;
    }
    if (v14 != v15)
    {
      uint64_t v18 = v15;
      do
      {
        float v19 = (void *)(*(void *)(a1 + 16) + 144 * v18);
        uint64_t v20 = v19[2];
        v19 += 2;
        v19[14] = *(void *)(v20 + 80);
        *(void *)(v20 + 80) = v19;
        uint64_t v21 = v19[1];
        v19[15] = *(void *)(v21 + 80);
        *(void *)(v21 + 80) = v19;
        if (v14 <= (int)v15 + 1) {
          int v22 = v15 + 1;
        }
        else {
          int v22 = v14;
        }
        int v23 = v15;
        while (1)
        {
          uint64_t v18 = (v23 + 1);
          if (v22 - 1 == v23) {
            break;
          }
          ++v23;
          LODWORD(v15) = v18;
          if ((*(_DWORD *)(*(void *)(a1 + 16) + 144 * v18) & 0x80000000) != 0) {
            goto LABEL_35;
          }
        }
        LODWORD(v15) = v22;
LABEL_35:
        ;
      }
      while (v14 != v15);
    }
  }
  if (v5)
  {
    uint64_t v24 = 0;
    do
    {
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, v24);
      uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, v25);
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, v25);
      *(void *)&long long v82 = v26;
      *((void *)&v82 + 1) = v27;
      uint64_t v28 = (unsigned int *)re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(a1, (uint64_t *)&v82);
      if (!v28)
      {
        uint64_t v29 = *(void *)a1;
        long long v87 = 0u;
        long long v88 = 0u;
        int v89 = 0;
        v86[0] = 0;
        *(_DWORD *)((char *)v86 + 7) = 0;
        uint64_t v90 = 0;
        uint64_t v91 = 0;
        v84[1] = 0;
        v84[2] = 0;
        int v85 = 0;
        long long v83 = v82;
        v84[0] = v29;
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v84, 0);
        ++v85;
        uint64_t v28 = (unsigned int *)re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(a1, (uint64_t *)&v83);
        re::ContactSet::~ContactSet((re::ContactSet *)&v83);
        uint64_t v30 = *(void *)v28;
        *((void *)v28 + 14) = *(void *)(*(void *)v28 + 80);
        *(void *)(v30 + 80) = v28;
        uint64_t v31 = *((void *)v28 + 1);
        *((void *)v28 + 15) = *(void *)(v31 + 80);
        *(void *)(v31 + 80) = v28;
      }
      if (*((unsigned char *)v28 + 56))
      {
        re::ContactSet::merge(v28, a2, v25);
      }
      else
      {
        re::ContactSet::set(v28, a2, v25);
        *((unsigned char *)v28 + 56) = 1;
      }
      uint64_t v24 = (v24 + 1);
    }
    while (v5 != v24);
  }
  uint64_t v32 = *(void *)(a1 + 48);
  if (v32)
  {
    uint64_t v33 = *(void *)(v32 + 64);
    if (v33)
    {
      uint64_t v34 = *(unsigned int *)(a1 + 32);
      if (v34)
      {
        uint64_t v35 = 0;
        int v36 = *(int **)(a1 + 16);
        while (1)
        {
          int v37 = *v36;
          v36 += 36;
          if (v37 < 0) {
            break;
          }
          if (v34 == ++v35)
          {
            LODWORD(v35) = *(_DWORD *)(a1 + 32);
            break;
          }
        }
      }
      else
      {
        LODWORD(v35) = 0;
      }
      unsigned int v38 = *(_DWORD *)(a1 + 32);
      if (v34 != v35)
      {
        uint64_t v39 = v35;
        do
        {
          uint64_t v40 = *(void *)(a1 + 16);
          uint64_t v41 = v40 + 144 * v39;
          uint64_t v43 = *(void *)(v41 + 16);
          uint64_t v42 = v41 + 16;
          int v44 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 48))(v43);
          if (v44) {
            LOBYTE(v44) = (*(uint64_t (**)(void))(**(void **)(v42 + 8) + 48))(*(void *)(v42 + 8));
          }
          *(unsigned char *)(v40 + 144 * v39 + 74) = v44;
          unsigned int v38 = *(_DWORD *)(a1 + 32);
          if (v38 <= (int)v35 + 1) {
            int v45 = v35 + 1;
          }
          else {
            int v45 = *(_DWORD *)(a1 + 32);
          }
          while (1)
          {
            uint64_t v39 = (v35 + 1);
            if (v45 - 1 == v35) {
              break;
            }
            LODWORD(v35) = v35 + 1;
            int v46 = v39;
            if ((*(_DWORD *)(*(void *)(a1 + 16) + 144 * v39) & 0x80000000) != 0) {
              goto LABEL_63;
            }
          }
          int v46 = v45;
LABEL_63:
          LODWORD(v35) = v46;
        }
        while (v34 != v46);
      }
      uint64_t v47 = 0;
      if (v38)
      {
        uint64_t v48 = *(int **)(a1 + 16);
        while (1)
        {
          int v49 = *v48;
          v48 += 36;
          if (v49 < 0) {
            break;
          }
          if (v38 == ++v47)
          {
            LODWORD(v47) = v38;
            break;
          }
        }
      }
      if (v38 != v47)
      {
        uint64_t v50 = v47;
        do
        {
          uint64_t v51 = *(void *)(a1 + 16);
          uint64_t v52 = v51 + 144 * v50;
          int v55 = *(unsigned __int8 *)(v52 + 72);
          float32x4_t v53 = (unsigned char *)(v52 + 72);
          LODWORD(v54) = v55;
          if (v55)
          {
            uint64_t v56 = v51 + 144 * v50;
            uint64_t v57 = *(void *)(v56 + 48);
            if (v57)
            {
              uint64_t v58 = *(void *)(v56 + 64);
              uint64_t v54 = 80 * v57;
              float32x4_t v59 = (float *)(v58 + 64);
              while (*v59 > 0.0)
              {
                float32x4_t v60 = vmulq_f32(*(float32x4_t *)(v59 - 4), *(float32x4_t *)(v59 - 4));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), vaddq_f32(v60, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1))).f32[0] != 0.0)break; {
                v59 += 20;
                }
                v54 -= 80;
                if (!v54) {
                  goto LABEL_80;
                }
              }
              LODWORD(v54) = 1;
            }
            else
            {
              LODWORD(v54) = 0;
            }
          }
LABEL_80:
          uint64_t v61 = v53 - 56;
          uint64_t v62 = v51 + 144 * v50;
          int v63 = *(unsigned __int8 *)(v62 + 73);
          if (*(unsigned char *)(v62 + 73)) {
            BOOL v64 = *(unsigned char *)(v62 + 74) == 0;
          }
          else {
            BOOL v64 = 1;
          }
          if (v64) {
            char v65 = v54;
          }
          else {
            char v65 = 1;
          }
          *(unsigned char *)(v62 + 73) = v65;
          if (v64)
          {
            if (!v63 && ((v54 ^ 1) & 1) == 0)
            {
              (*(void (**)(uint64_t, void, void))(*(void *)v33 + 16))(v33, *((void *)v53 - 7), *((void *)v53 - 6));
              goto LABEL_99;
            }
          }
          else
          {
            *float32x4_t v53 = 1;
          }
          char v66 = v65 ^ 1;
          if (!v63) {
            char v66 = 1;
          }
          if (v66)
          {
            if (!v63) {
              char v65 = 1;
            }
            if ((v65 & 1) == 0) {
              (*(void (**)(uint64_t, void, void))(*(void *)v33 + 32))(v33, *v61, v61[1]);
            }
          }
          else
          {
            (*(void (**)(uint64_t, void, void))(*(void *)v33 + 24))(v33, *v61, v61[1]);
          }
LABEL_99:
          if (*(_DWORD *)(a1 + 32) <= (v47 + 1)) {
            int v67 = v47 + 1;
          }
          else {
            int v67 = *(_DWORD *)(a1 + 32);
          }
          while (1)
          {
            uint64_t v50 = (v47 + 1);
            if (v67 - 1 == v47) {
              break;
            }
            LODWORD(v47) = v47 + 1;
            int v68 = v50;
            if ((*(_DWORD *)(*(void *)(a1 + 16) + 144 * v50) & 0x80000000) != 0) {
              goto LABEL_106;
            }
          }
          int v68 = v67;
LABEL_106:
          LODWORD(v47) = v68;
        }
        while (v38 != v68);
      }
    }
  }
  uint64_t v69 = *(unsigned int *)(a1 + 32);
  if (v69)
  {
    uint64_t v70 = 0;
    int v71 = *(int **)(a1 + 16);
    while (1)
    {
      int v72 = *v71;
      v71 += 36;
      if (v72 < 0) {
        break;
      }
      if (v69 == ++v70)
      {
        LODWORD(v70) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v70) = 0;
  }
  if (v69 != v70)
  {
    uint64_t v73 = v70;
    unsigned int v74 = *(_DWORD *)(a1 + 32);
    do
    {
      uint64_t v75 = *(void *)(a1 + 16);
      uint64_t v76 = v75 + 144 * v73;
      int v78 = *(unsigned __int8 *)(v76 + 72);
      int32x2_t v77 = (unsigned char *)(v76 + 72);
      if (v78)
      {
        *int32x2_t v77 = 0;
      }
      else
      {
        uint64_t v79 = v75 + 144 * v73;
        re::ContactSetCollection::removeFromLinkedLists((void *)(v79 + 16));
        re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove(a1, *(void *)(v79 + 16), *(void *)(v79 + 24));
        unsigned int v74 = *(_DWORD *)(a1 + 32);
      }
      if (v74 <= (int)v70 + 1) {
        unsigned int v80 = v70 + 1;
      }
      else {
        unsigned int v80 = v74;
      }
      while (1)
      {
        uint64_t v73 = (v70 + 1);
        if (v80 - 1 == v70) {
          break;
        }
        LODWORD(v70) = v70 + 1;
        unsigned int v81 = v73;
        if ((*(_DWORD *)(*(void *)(a1 + 16) + 144 * v73) & 0x80000000) != 0) {
          goto LABEL_125;
        }
      }
      unsigned int v81 = v80;
LABEL_125:
      LODWORD(v70) = v81;
    }
    while (v69 != v81);
  }
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v17, 0, 36);
      *(void *)&v17[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init((uint64_t)v17, v4, a2);
      long long v5 = *(_OWORD *)v17;
      *(_OWORD *)int v17 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v17[16];
      *(void *)&v17[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v17[24];
      *(_OWORD *)&v17[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v17[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v17[16] + v10) & 0x80000000) != 0)
          {
            unint64_t v12 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9
                  * (*(void *)(*(void *)&v17[16] + v10 + 16) ^ (*(void *)(*(void *)&v17[16] + v10 + 16) >> 30))) ^ ((0xBF58476D1CE4E5B9 * (*(void *)(*(void *)&v17[16] + v10 + 16) ^ (*(void *)(*(void *)&v17[16] + v10 + 16) >> 30))) >> 27));
            unint64_t v13 = v12 ^ (v12 >> 31);
            unint64_t v14 = 0xBF58476D1CE4E5B9
                * (*(void *)(*(void *)&v17[16] + v10 + 24) ^ (*(void *)(*(void *)&v17[16] + v10 + 24) >> 30));
            unint64_t v15 = (0x94D049BB133111EBLL * (v14 ^ (v14 >> 27))) ^ ((0x94D049BB133111EBLL * (v14 ^ (v14 >> 27))) >> 31);
            if (v13 == v15) {
              unint64_t v15 = 0;
            }
            re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(a1, (v15 ^ v13) % *(unsigned int *)(a1 + 24), v15 ^ v13, *(void *)&v17[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v17[32];
          }
          ++v11;
          v10 += 144;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)v17);
    }
  }
  else
  {
    if (a2) {
      signed int v16 = a2;
    }
    else {
      signed int v16 = 3;
    }
  }
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v6 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  unint64_t v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) >> 27));
  unint64_t v9 = v8 ^ (v8 >> 31);
  if (v7 == v9) {
    unint64_t v9 = 0;
  }
  unint64_t v10 = v9 ^ v7;
  unint64_t v11 = *(unsigned int *)(a1 + 24);
  if (!v11)
  {
    LODWORD(v12) = 0;
    goto LABEL_13;
  }
  unint64_t v12 = v10 % v11;
  uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v10 % v11));
  if (v13 == 0x7FFFFFFF)
  {
LABEL_13:
    unsigned int v19 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(a1, v12, v10, (uint64_t)a2);
    ++*(_DWORD *)(a1 + 40);
    return *(void *)(a1 + 16) + 144 * v19 + 16;
  }
  uint64_t v14 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v15 = v14 + 144 * v13;
    uint64_t v18 = *(void *)(v15 + 16);
    uint64_t result = v15 + 16;
    uint64_t v17 = v18;
    if (v18 == v4 && *(void *)(result + 8) == v5) {
      return result;
    }
    if (v17 == v5 && *(void *)(result + 8) == v4) {
      return result;
    }
    uint64_t v13 = *(_DWORD *)(v14 + 144 * v13) & 0x7FFFFFFF;
    if (v13 == 0x7FFFFFFF) {
      goto LABEL_13;
    }
  }
}

void *re::ContactSetCollection::removeFromLinkedLists(void *result)
{
  uint64_t v1 = *result;
  uint64_t v2 = result[14];
  unint64_t v3 = *(void **)(*result + 80);
  if (v3 == result)
  {
    *(void *)(v1 + 80) = v2;
  }
  else
  {
    do
    {
      uint64_t v4 = v3;
      uint64_t v5 = *v3;
      if (*v3 == v1) {
        uint64_t v6 = 14;
      }
      else {
        uint64_t v6 = 15;
      }
      unint64_t v3 = (void *)v4[v6];
    }
    while (v3 != result);
    if (v5 == v1) {
      v4[14] = v2;
    }
    else {
      v4[15] = v2;
    }
  }
  uint64_t v7 = result[1];
  uint64_t v8 = result[15];
  unint64_t v9 = *(void **)(v7 + 80);
  if (v9 == result)
  {
    *(void *)(v7 + 80) = v8;
  }
  else
  {
    do
    {
      unint64_t v10 = v9;
      uint64_t v11 = *v9;
      if (*v9 == v7) {
        uint64_t v12 = 14;
      }
      else {
        uint64_t v12 = 15;
      }
      unint64_t v9 = (void *)v10[v12];
    }
    while (v9 != result);
    if (v11 == v7) {
      v10[14] = v8;
    }
    else {
      v10[15] = v8;
    }
  }
  result[14] = 0;
  result[15] = 0;
  return result;
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 24);
  if (v3)
  {
    unint64_t v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v6 = v5 ^ (v5 >> 31);
    unint64_t v7 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
    unint64_t v8 = v7 ^ (v7 >> 31);
    if (v6 == v8) {
      unint64_t v8 = 0;
    }
    unint64_t v9 = (v8 ^ v6) % v3;
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(unsigned int *)(v10 + 4 * v9);
    if (v11 != 0x7FFFFFFF)
    {
      uint64_t v12 = *(void *)(a1 + 16);
      uint64_t v13 = 0x7FFFFFFFLL;
      while (1)
      {
        uint64_t v14 = v12 + 144 * v11;
        uint64_t v17 = *(void *)(v14 + 16);
        uint64_t v15 = v14 + 16;
        uint64_t v16 = v17;
        if (v17 == a2 && *(void *)(v15 + 8) == a3) {
          break;
        }
        if (v16 == a3 && *(void *)(v15 + 8) == a2) {
          break;
        }
        uint64_t v13 = v11;
        uint64_t v11 = *(_DWORD *)(v12 + 144 * v11) & 0x7FFFFFFF;
        if (v11 == 0x7FFFFFFF) {
          return;
        }
      }
      int v18 = *(_DWORD *)(v12 + 144 * v11) & 0x7FFFFFFF;
      if (v13 == 0x7FFFFFFF) {
        *(_DWORD *)(v10 + 4 * v9) = v18;
      }
      else {
        *(_DWORD *)(v12 + 144 * v13) = *(_DWORD *)(v12 + 144 * v13) & 0x80000000 | v18;
      }
      uint64_t v19 = *(void *)(a1 + 16);
      uint64_t v20 = (int *)(v19 + 144 * v11);
      int v21 = *v20;
      if (*v20 < 0)
      {
        int *v20 = v21 & 0x7FFFFFFF;
        re::ContactSet::~ContactSet((re::ContactSet *)(v19 + 144 * v11 + 16));
        uint64_t v19 = *(void *)(a1 + 16);
        int v21 = *(_DWORD *)(v19 + 144 * v11);
      }
      int v22 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(v19 + 144 * v11) = *(_DWORD *)(a1 + 36) | v21 & 0x80000000;
      --*(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 36) = v11;
      *(_DWORD *)(a1 + 40) = v22 + 1;
    }
  }
}

void re::ContactSetCollection::remove(re::ContactSetCollection *this, re::ContactSet *a2)
{
  if (*((void *)this + 6)) {
    re::ContactSetCollection::removeFromLinkedLists(a2);
  }
  unint64_t v4 = *(void *)a2;
  unint64_t v5 = *((void *)a2 + 1);
  re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove((uint64_t)this, v4, v5);
}

void re::ContactSetCollection::remove(re::ContactSetCollection *this, re::CollisionObject *a2)
{
  uint64_t v4 = *((void *)this + 6);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 64);
    if (v5)
    {
      for (uint64_t i = *((void *)a2 + 10); i; uint64_t i = *(void *)(i + v7))
      {
        if (*(unsigned char *)(i + 57))
        {
          *(unsigned char *)(i + 57) = 0;
          (*(void (**)(uint64_t, void, void))(*(void *)v5 + 32))(v5, *(void *)i, *(void *)(i + 8));
        }
        if (*(re::CollisionObject **)i == a2) {
          uint64_t v7 = 112;
        }
        else {
          uint64_t v7 = 120;
        }
      }
    }
    while (1)
    {
      unint64_t v8 = (re::ContactSet *)*((void *)a2 + 10);
      if (!v8) {
        break;
      }
      re::ContactSetCollection::remove(this, v8);
    }
  }
  else
  {
    uint64_t v9 = *((unsigned int *)this + 8);
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (int *)*((void *)this + 2);
      while (1)
      {
        int v12 = *v11;
        v11 += 36;
        if (v12 < 0) {
          break;
        }
        if (v9 == ++v10)
        {
          LODWORD(v10) = *((_DWORD *)this + 8);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (v9 != v10)
    {
      uint64_t v13 = v10;
      unsigned int v14 = *((_DWORD *)this + 8);
      do
      {
        uint64_t v15 = *((void *)this + 2) + 144 * v13;
        uint64_t v17 = *(re::CollisionObject **)(v15 + 16);
        uint64_t v16 = (re::CollisionObject **)(v15 + 16);
        if (v17 == a2 || v16[1] == a2)
        {
          re::ContactSetCollection::remove(this, (re::ContactSet *)v16);
          unsigned int v14 = *((_DWORD *)this + 8);
        }
        if (v14 <= (int)v10 + 1) {
          unsigned int v18 = v10 + 1;
        }
        else {
          unsigned int v18 = v14;
        }
        while (1)
        {
          uint64_t v13 = (v10 + 1);
          if (v18 - 1 == v10) {
            break;
          }
          LODWORD(v10) = v10 + 1;
          unsigned int v19 = v13;
          if ((*(_DWORD *)(*((void *)this + 2) + 144 * v13) & 0x80000000) != 0) {
            goto LABEL_32;
          }
        }
        unsigned int v19 = v18;
LABEL_32:
        LODWORD(v10) = v19;
      }
      while (v9 != v19);
    }
  }
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(unsigned int *)(a1 + 36);
  if (v6 == 0x7FFFFFFF)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 32);
    int v7 = v6;
    if (v6 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v7 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v7 + 1;
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = *(_DWORD *)(v9 + 144 * v6);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = *(_DWORD *)(v9 + 144 * v6);
    *(_DWORD *)(a1 + 36) = v10 & 0x7FFFFFFF;
  }
  uint64_t v11 = 144 * v6;
  *(_DWORD *)(v9 + v11) = v10 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v11) = *(_DWORD *)(*(void *)(a1 + 16) + 144 * v6) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  uint64_t v12 = *(void *)(a1 + 16) + 144 * v6;
  *(_OWORD *)(v12 + 16) = *(_OWORD *)a4;
  *(void *)(v12 + 64) = 0;
  *(void *)(v12 + 40) = 0;
  *(void *)(v12 + 48) = 0;
  *(void *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 56) = 0;
  uint64_t v13 = *(void *)(a4 + 24);
  *(void *)(v12 + 32) = *(void *)(a4 + 16);
  *(void *)(v12 + 40) = v13;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  uint64_t v14 = *(void *)(v12 + 48);
  *(void *)(v12 + 48) = *(void *)(a4 + 32);
  *(void *)(a4 + 32) = v14;
  uint64_t v15 = *(void *)(v12 + 64);
  *(void *)(v12 + 64) = *(void *)(a4 + 48);
  *(void *)(a4 + 48) = v15;
  ++*(_DWORD *)(a4 + 40);
  ++*(_DWORD *)(v12 + 56);
  *(_OWORD *)(v12 + 72) = *(_OWORD *)(a4 + 56);
  long long v16 = *(_OWORD *)(a4 + 72);
  long long v17 = *(_OWORD *)(a4 + 88);
  long long v18 = *(_OWORD *)(a4 + 104);
  *(void *)(v12 + 136) = *(void *)(a4 + 120);
  *(_OWORD *)(v12 + 120) = v18;
  *(_OWORD *)(v12 + 104) = v17;
  *(_OWORD *)(v12 + 88) = v16;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v6;
  ++*(_DWORD *)(a1 + 28);
  return v6;
}

void re::introspect_CharacterControllerType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F870, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF7F870);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Undefined";
      qword_26AF7F8A8 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Capsule";
      qword_26AF7F8B0 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = 2;
      *(void *)(v30 + 16) = "Box";
      qword_26AF7F8B8 = v30;
      __cxa_guard_release(&qword_26AF7F870);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F878, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7F878))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF7F8F8, "CharacterControllerType", 2, 2, 1, 1);
    qword_26AF7F8F8 = (uint64_t)&unk_26E715E00;
    qword_26AF7F938 = (uint64_t)&re::introspect_CharacterControllerType(BOOL)::enumTable;
    dword_26AF7F908 = 9;
    __cxa_guard_release(&qword_26AF7F878);
  }
  if ((_MergedGlobals_127 & 1) == 0)
  {
    _MergedGlobals_127 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF7F8F8, a2);
    uint64_t v32 = 0x7A5112036B46B8BELL;
    uint64_t v33 = "CharacterControllerType";
    v36[0] = 0x607DD0D4E68;
    v36[1] = "uint16_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v36);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v36);
      uint64_t v4 = (unsigned int *)qword_26AF7F938;
      v35[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v36, &v32, 1, 1, (uint64_t)v35);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v34.var0 = 2 * v10;
            v34.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v36, v14, &v34);
            re::StringID::destroyString((re::StringID *)&v34);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              long long v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v34.var0 = 2 * v18;
              v34.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v36, v22, &v34);
              re::StringID::destroyString((re::StringID *)&v34);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v36, v23);
      xmmword_26AF7F918 = (__int128)v34;
      re::StringID::destroyString((re::StringID *)&v32);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CharacterControllerType", v32, v33);
      _os_crash();
      __break(1u);
    }
  }
}

void re::introspect_CharacterControllerFlags(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F888, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF7F888);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *(void *)(v26 + 8) = 0;
      *(void *)(v26 + 16) = "None";
      qword_26AF7F880 = v26;
      __cxa_guard_release(&qword_26AF7F888);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F890, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7F890))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF7F940, "CharacterControllerFlags", 2, 2, 1, 1);
    qword_26AF7F940 = (uint64_t)&unk_26E715E00;
    qword_26AF7F980 = (uint64_t)&re::introspect_CharacterControllerFlags(BOOL)::enumTable;
    dword_26AF7F950 = 9;
    __cxa_guard_release(&qword_26AF7F890);
  }
  if ((byte_26AF7F869 & 1) == 0)
  {
    byte_26AF7F869 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF7F940, a2);
    uint64_t v28 = 0xCFD12E69FBF98C04;
    uint64_t v29 = "CharacterControllerFlags";
    v32[0] = 0x607DD0D4E68;
    v32[1] = "uint16_t";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v32);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v32);
      uint64_t v4 = (unsigned int *)qword_26AF7F980;
      v31[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v32, &v28, 1, 1, (uint64_t)v31);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            uint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v30.var0 = 2 * v10;
            v30.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v32, v14, &v30);
            re::StringID::destroyString((re::StringID *)&v30);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              long long v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v30.var0 = 2 * v18;
              v30.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v32, v22, &v30);
              re::StringID::destroyString((re::StringID *)&v30);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v32, v23);
      xmmword_26AF7F960 = (__int128)v30;
      re::StringID::destroyString((re::StringID *)&v28);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v32);
      re::internal::assertLog((re::internal *)5, v27, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CharacterControllerFlags", v28, v29);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_CharacterControllerDescription(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F898, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7F898))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF7F988, "CharacterControllerDescription");
    __cxa_guard_release(&qword_26AF7F898);
  }
  return &unk_26AF7F988;
}

void re::initInfo_CharacterControllerDescription(re *this, re::IntrospectionBase *a2)
{
  v31[0] = 0x34296DE90D87266ELL;
  v31[1] = "CharacterControllerDescription";
  re::StringID::destroyString((re::StringID *)v31);
  *((_OWORD *)this + 2) = v32;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7F8A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF7F8A0);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      int v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "skinWidth";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF7F8C0 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "slopeLimit";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF7F8C8 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "stepLimit";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF7F8D0 = v16;
      long long v17 = re::introspectionAllocator((re *)v16);
      uint64_t v18 = re::introspect_CollisionFilter((re::IntrospectionBase **)1);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = "collisionFilter";
      *(void *)(v19 + 16) = v18;
      *(void *)(v19 + 24) = 0;
      *(void *)(v19 + 32) = 0xC00000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(void *)(v19 + 48) = 0;
      *(void *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_26AF7F8D8 = v19;
      uint64_t v20 = re::introspectionAllocator((re *)v19);
      uint64_t v22 = re::IntrospectionInfo<float [3]>::get(1, v21);
      uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v20 + 32))(v20, 72, 8);
      *(_DWORD *)uint64_t v23 = 1;
      *(void *)(v23 + 8) = "extents";
      *(void *)(v23 + 16) = v22;
      *(void *)(v23 + 24) = 0;
      *(void *)(v23 + 32) = 0x1400000005;
      *(_DWORD *)(v23 + 40) = 0;
      *(void *)(v23 + 48) = 0;
      *(void *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_26AF7F8E0 = v23;
      uint64_t v24 = (re *)re::introspectionAllocator((re *)v23);
      re::introspect_CharacterControllerType(v24, v25);
      uint64_t v26 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, 72, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *(void *)(v26 + 8) = "type";
      *(void *)(v26 + 16) = &qword_26AF7F8F8;
      *(void *)(v26 + 24) = 0;
      *(void *)(v26 + 32) = 0x2000000006;
      *(_DWORD *)(v26 + 40) = 0;
      *(void *)(v26 + 48) = 0;
      *(void *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_26AF7F8E8 = v26;
      uint64_t v27 = (re *)re::introspectionAllocator((re *)v26);
      re::introspect_CharacterControllerFlags(v27, v28);
      uint64_t v29 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 72, 8);
      *(_DWORD *)uint64_t v29 = 1;
      *(void *)(v29 + 8) = "flags";
      *(void *)(v29 + 16) = &qword_26AF7F940;
      *(void *)(v29 + 24) = 0;
      *(void *)(v29 + 32) = 0x2200000007;
      *(_DWORD *)(v29 + 40) = 0;
      *(void *)(v29 + 48) = 0;
      *(void *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_26AF7F8F0 = v29;
      __cxa_guard_release(&qword_26AF7F8A0);
    }
  }
  *((void *)this + 2) = 0x2400000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 7;
  *((void *)this + 8) = &qword_26AF7F8C0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::CharacterControllerDescription>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::CharacterControllerDescription>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::CharacterControllerDescription>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::CharacterControllerDescription>;
  re::IntrospectionRegistry::add(this, v3);
  long long v30 = v32;
}

void *re::IntrospectionInfo<float [3]>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info);
  }
  if (a1)
  {
    if (re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v3 = re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v3) {
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized)
    {
LABEL_14:
      char v11 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v11);
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
    }
  }
  re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized = 1;
  int v7 = (const re::IntrospectionBase *)re::introspect_float((re *)1, a2);
  re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info, v7, 3);
  re::IntrospectionRegistry::add(v8, v9);
  re::getPrettyTypeName((re *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
  if (BYTE8(v14)) {
    uint64_t v10 = v15;
  }
  else {
    uint64_t v10 = (char *)&v14 + 9;
  }
  if (void)v14 && (BYTE8(v14)) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  long long v14 = *((_OWORD *)v7 + 2);
  xmmword_268773EE0 = v13;
  re::StringID::destroyString((re::StringID *)v16);
  if ((a1 & 1) == 0) {
    goto LABEL_14;
  }
  return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::CharacterControllerDescription>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0x3F490FD83C23D70ALL;
  *(_DWORD *)(a3 + 8) = 1045220557;
  double result = NAN;
  *(void *)(a3 + 12) = 0xFFFFFFFF00000001;
  *(_DWORD *)(a3 + 20) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 28) = 0x100000000;
  return result;
}

double re::internal::defaultConstructV2<re::CharacterControllerDescription>(uint64_t a1)
{
  *(void *)a1 = 0x3F490FD83C23D70ALL;
  *(_DWORD *)(a1 + 8) = 1045220557;
  double result = NAN;
  *(void *)(a1 + 12) = 0xFFFFFFFF00000001;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 28) = 0x100000000;
  return result;
}

uint64_t re::introspect_CharacterControllerDescription(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CharacterControllerDescription", (uint64_t (*)(re::internal *))re::allocInfo_CharacterControllerDescription, (re::IntrospectionBase *(*)(void))re::initInfo_CharacterControllerDescription, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CharacterControllerDescription>, this);
}

re::CharacterController *re::CharacterController::CharacterController(re::CharacterController *this, re::Allocator *a2, float a3, float a4, float a5)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0x3F80000000000000;
  *(void *)this = &unk_26E6DDA28;
  *((float *)this + 16) = a3;
  *((float *)this + 17) = a4;
  *((float *)this + 18) = a5;
  *((unsigned char *)this + 76) = 0;
  *((_OWORD *)this + 5) = 0u;
  inited = (_anonymous_namespace_ *)objc_initWeak((id *)this + 12, 0);
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *(void *)((char *)this + 125) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = a2;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 16) = 0u;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)this + 21, 0);
  ++*((_DWORD *)this + 48);
  return this;
}

void re::CharacterController::~CharacterController(re::CharacterController *this)
{
  uint64_t v2 = (uint64_t (**)(re::CharacterController *))&unk_26E6DDA28;
  *(void *)this = &unk_26E6DDA28;
  int v3 = (void (***)(void))*((void *)this + 17);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 20);
    (**v3)(*((void *)this + 17));
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40))(v4, v3);
    uint64_t v2 = *(uint64_t (***)(re::CharacterController *))this;
  }
  uint64_t v5 = *((void *)this + 20);
  unint64_t v6 = (void (***)(void))v2[2](this);
  if (v6)
  {
    int v7 = v6;
    (**v6)(v6);
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v5 + 40))(v5, v7);
  }
  re::Event<re::GeometricObjectBase>::~Event((void *)this + 21);
  objc_destroyWeak((id *)this + 12);
  *((void *)this + 12) = 0;
}

uint64_t re::CharacterController::setCollisionFilter(void *a1, void *a2)
{
  int v3 = (void *)a1[17];
  if (v3[4] != *a2)
  {
    v3[4] = *a2;
    (*(void (**)(void *))(*v3 + 80))(v3);
  }
  uint64_t v4 = *(uint64_t (**)(void *))(*a1 + 168);
  return v4(a1);
}

uint64_t re::CharacterController::onPlatform(id *this)
{
  WeakRetained = objc_loadWeakRetained(this + 12);
  if (!WeakRetained) {
    return 0;
  }
  uint64_t v2 = WeakRetained[2];

  return v2;
}

double re::PlaneShape::massProperties(uint64_t a1, _DWORD *a2, void *a3, _OWORD *a4)
{
  *a2 = 0;
  *a3 = 0;
  a3[1] = 0;
  double result = 0.0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  return result;
}

float32x2_t re::PhysXRectangleShape::extent(re::PhysXRectangleShape *this)
{
  v1.i32[0] = *((_DWORD *)this + 6);
  v1.i32[1] = *((_DWORD *)this + 8);
  return vadd_f32(v1, v1);
}

double re::PhysXRectangleShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  long long v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((void *)&v18 + 1);
  uint64_t v19 = *a2;
  int v20 = *((_DWORD *)a2 + 2);
  v15.i64[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  double result = *(double *)v21;
  *(void *)&long long v17 = *(void *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXRectangleShape::~PhysXRectangleShape(re::PhysXRectangleShape *this)
{
}

uint64_t re::RectangleShape::type(re::RectangleShape *this)
{
  return 11;
}

float re::PhysXCylinderShape::height(re::PhysXCylinderShape *this)
{
  return *((float *)this + 8);
}

float re::PhysXCylinderShape::radius(re::PhysXCylinderShape *this)
{
  return *((float *)this + 7);
}

double re::PhysXCylinderShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  long long v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((void *)&v18 + 1);
  uint64_t v19 = *a2;
  int v20 = *((_DWORD *)a2 + 2);
  v15.i64[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  double result = *(double *)v21;
  *(void *)&long long v17 = *(void *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXCylinderShape::~PhysXCylinderShape(re::PhysXCylinderShape *this)
{
}

void *re::allocInfo_CollisionFilter(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_128, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_128))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF7FA20, "CollisionFilter");
    __cxa_guard_release(&_MergedGlobals_128);
  }
  return &unk_26AF7FA20;
}

void re::initInfo_CollisionFilter(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0xF1C766E267541254;
  v14[1] = "CollisionFilter";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FA08, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF7FA08);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      int v7 = re::introspect_uint32_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "group";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF7FA10 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_uint32_t((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "mask";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF7FA18 = v12;
      __cxa_guard_release(&qword_26AF7FA08);
    }
  }
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF7FA10;
  *((void *)this + 9) = re::internal::defaultConstruct<re::CollisionFilter>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::CollisionFilter>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::CollisionFilter>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::CollisionFilter>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

double re::internal::defaultConstruct<re::CollisionFilter>(uint64_t a1, uint64_t a2, void *a3)
{
  double result = NAN;
  *a3 = 0xFFFFFFFF00000001;
  return result;
}

double re::internal::defaultConstructV2<re::CollisionFilter>(void *a1)
{
  double result = NAN;
  *a1 = 0xFFFFFFFF00000001;
  return result;
}

uint64_t re::introspect_CollisionFilter(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CollisionFilter", (uint64_t (*)(re::internal *))re::allocInfo_CollisionFilter, (re::IntrospectionBase *(*)(void))re::initInfo_CollisionFilter, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CollisionFilter>, this);
}

void re::CollisionWorld::~CollisionWorld(re::CollisionWorld *this)
{
  *(void *)this = &unk_26E6DDC00;
  if (*((void *)this + 7))
  {
    uint64_t v2 = (uint64_t *)((char *)this + 72);
    if (*((void *)this + 9)) {
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(v2);
    }
    *((void *)this + 7) = 0;
  }
  re::ContactSetCollection::~ContactSetCollection((re::CollisionWorld *)((char *)this + 72));
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)this + 1);
}

void re::CollisionWorld::deinit(re::CollisionWorld *this)
{
  if (*((void *)this + 7))
  {
    uint64_t v3 = *((void *)this + 9);
    uint64_t v2 = (uint64_t *)((char *)this + 72);
    if (v3) {
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(v2);
    }
    *((void *)this + 7) = 0;
  }
}

uint64_t re::CollisionWorld::hasContact(void *a1, uint64_t a2)
{
  if (!a2 || *(void *)(a2 + 56) != a1[16]) {
    return (*(uint64_t (**)(void))(*a1 + 232))();
  }
  uint64_t v3 = *(void **)(a2 + 80);
  if (!v3) {
    return 0;
  }
  while (1)
  {
    uint64_t v4 = v3[4];
    if (v4) {
      break;
    }
LABEL_10:
    if (*v3 == a2) {
      uint64_t v8 = 14;
    }
    else {
      uint64_t v8 = 15;
    }
    uint64_t v3 = (void *)v3[v8];
    if (!v3) {
      return 0;
    }
  }
  uint64_t v5 = 80 * v4;
  unint64_t v6 = (float *)(v3[6] + 64);
  while (*v6 > 0.0)
  {
    float32x4_t v7 = vmulq_f32(*(float32x4_t *)(v6 - 4), *(float32x4_t *)(v6 - 4));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0] != 0.0)break; {
    v6 += 20;
    }
    v5 -= 80;
    if (!v5) {
      goto LABEL_10;
    }
  }
  return 1;
}

uint64_t re::CollisionWorld::haveContact(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !a3 || (uint64_t v3 = *(void *)(a2 + 56), v3 != a1[16]) || *(void *)(a3 + 56) != v3)
  {
    unint64_t v4 = *(void *)(a2 + 32);
    unint64_t v5 = *(void *)(a3 + 32);
    unint64_t v6 = v5 & HIDWORD(v4);
    unint64_t v7 = v4 & HIDWORD(v5);
    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      uint64_t v10 = *(uint64_t (**)(void))(*a1 + 240);
      return v10();
    }
    return 0;
  }
  v15[0] = a2;
  v15[1] = a3;
  uint64_t result = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet((uint64_t)(a1 + 9), v15);
  if (!result) {
    return result;
  }
  uint64_t v11 = *(void *)(result + 32);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = 80 * v11;
  long long v13 = (float *)(*(void *)(result + 48) + 64);
  uint64_t result = 0;
  while (*v13 > 0.0)
  {
    float32x4_t v14 = vmulq_f32(*(float32x4_t *)(v13 - 4), *(float32x4_t *)(v13 - 4));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0] != 0.0)break; {
    v13 += 20;
    }
    v12 -= 80;
    if (!v12) {
      return result;
    }
  }
  return 1;
}

double re::CollisionWorld::DEPRECATED_copyRayHitsToContactSet(uint64_t a1, float *a2, float a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)a2;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 32) = 0;
  ++*(_DWORD *)(a1 + 40);
  float v4 = -(float)(a2[12] * a3);
  long long v5 = *((_OWORD *)a2 + 2);
  v7[0] = *((_OWORD *)a2 + 1);
  v7[1] = v7[0];
  v7[2] = v5;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  float v10 = v4;
  *(void *)&double result = re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)(a1 + 16), (uint64_t)v7).n128_u64[0];
  return result;
}

void re::CollisionWorld::DEPRECATED_copyRayHitsToContactSetCollection(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = *(int **)(a1 + 16);
    while (1)
    {
      int v8 = *v7;
      v7 += 36;
      if (v8 < 0) {
        break;
      }
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v5 != v6)
  {
    uint64_t v9 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    do
    {
      uint64_t v11 = v10 + 144 * v9;
      *(void *)(v11 + 48) = 0;
      ++*(_DWORD *)(v11 + 56);
      uint64_t v10 = *(void *)(a1 + 16);
      if (v5 <= (int)v6 + 1) {
        int v12 = v6 + 1;
      }
      else {
        int v12 = v5;
      }
      int v13 = v6;
      while (1)
      {
        uint64_t v9 = (v13 + 1);
        if (v12 - 1 == v13) {
          break;
        }
        ++v13;
        LODWORD(v6) = v9;
        if ((*(_DWORD *)(v10 + 144 * v9) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v6) = v12;
LABEL_17:
      ;
    }
    while (v5 != v6);
  }
  uint64_t v14 = *(void *)(a2 + 40);
  if (v14)
  {
    for (unint64_t i = 0; i != v14; ++i)
    {
      unint64_t v16 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](a2, i);
      uint64_t v17 = *(void *)v16;
      *(void *)&long long v23 = 0;
      *((void *)&v23 + 1) = v17;
      uint64_t v18 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(a1, (uint64_t *)&v23);
      if (!v18)
      {
        unint64_t v19 = *(void *)a1;
        long long v28 = 0u;
        long long v29 = 0u;
        int v30 = 0;
        *(void *)&long long v27 = 0;
        *(_DWORD *)((char *)&v27 + 7) = 0;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        *(void *)&long long v26 = 0;
        DWORD2(v26) = 0;
        long long v24 = v23;
        long long v25 = v19;
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity(&v25, 0);
        ++DWORD2(v26);
        uint64_t v18 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(a1, (uint64_t *)&v24);
        re::ContactSet::~ContactSet((re::ContactSet *)&v24);
      }
      float v20 = -(float)(*(float *)(v16 + 48) * a3);
      long long v21 = *(_OWORD *)(v16 + 32);
      long long v24 = *(_OWORD *)(v16 + 16);
      long long v25 = v24;
      long long v26 = v21;
      long long v27 = 0uLL;
      *(float *)&long long v28 = v20;
      re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)(v18 + 16), (uint64_t)&v24);
    }
  }
}

uint64_t re::CollisionWorld::printDebugInformation(re::CollisionWorld *this, const char *a2)
{
  if (a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = "";
  }
  printf("%sCollision world:\n", v3);
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 16) + 176))(*((void *)this + 16));
  printf("%s    # of collision objects: %zu\n", v3, v4);
  return printf("%s    # of contact sets: %zu\n", v3, *((unsigned int *)this + 25));
}

void re::CollisionWorld::reportTriggerEvents(re::CollisionWorld *this)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 8);
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = *((unsigned int *)this + 10);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = (int *)(*((void *)this + 3) + 8);
      while (1)
      {
        int v6 = *v5;
        v5 += 10;
        if (v6 < 0) {
          break;
        }
        if (v3 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 10);
          break;
        }
      }
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if (v3 != v4)
    {
      uint64_t v7 = v4;
      unint64_t v16 = (char *)this + 8;
      while (1)
      {
        uint64_t v8 = *((void *)v2 + 3) + 40 * v7;
        uint64_t v11 = *(void *)(v8 + 16);
        uint64_t v10 = *(void *)(v8 + 24);
        uint64_t v9 = v8 + 16;
        int v13 = (unsigned char *)(v9 + 16);
        int v12 = *(unsigned __int8 *)(v9 + 16);
        if (v12 == 2)
        {
          re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove((uint64_t)v16, (uint64_t *)v9);
          this = (re::CollisionWorld *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1 + 32))(v1, v11, v10);
          goto LABEL_17;
        }
        if (v12 == 1) {
          break;
        }
        if (!*(unsigned char *)(v9 + 16))
        {
          int v26 = 0;
          long long v24 = 0u;
          long long v25 = 0u;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          int v22 = 0;
          v23[0] = 0;
          *(_DWORD *)((char *)v23 + 7) = 0;
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          uint64_t v17 = v11;
          uint64_t v18 = v10;
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity(&v19, 0);
          ++v22;
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v1 + 16))(v1, v11, v10, &v17);
          *int v13 = 1;
LABEL_15:
          re::ContactSet::~ContactSet((re::ContactSet *)&v17);
        }
LABEL_17:
        if (*((_DWORD *)v2 + 10) <= (v4 + 1)) {
          int v14 = v4 + 1;
        }
        else {
          int v14 = *((_DWORD *)v2 + 10);
        }
        while (1)
        {
          uint64_t v7 = (v4 + 1);
          if (v14 - 1 == v4) {
            break;
          }
          LODWORD(v4) = v4 + 1;
          int v15 = v7;
          if ((*(_DWORD *)(*((void *)v2 + 3) + 40 * v7 + 8) & 0x80000000) != 0) {
            goto LABEL_24;
          }
        }
        int v15 = v14;
LABEL_24:
        LODWORD(v4) = v15;
        if (v3 == v15) {
          return;
        }
      }
      int v26 = 0;
      long long v24 = 0u;
      long long v25 = 0u;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      int v22 = 0;
      v23[0] = 0;
      *(_DWORD *)((char *)v23 + 7) = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v17 = v11;
      uint64_t v18 = v10;
      re::DynamicArray<re::RigSplineIKJoint>::setCapacity(&v19, 0);
      ++v22;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v1 + 24))(v1, v11, v10, &v17);
      goto LABEL_15;
    }
  }
}

void *re::allocInfo_CollisionWorld(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_129, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_129))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF7FAA0, "CollisionWorld");
    __cxa_guard_release(&_MergedGlobals_129);
  }
  return &unk_26AF7FAA0;
}

void re::initInfo_CollisionWorld(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x28D4E2496010BF40;
  v5[1] = "CollisionWorld";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x9000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_CollisionWorld(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_CollisionWorld(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CollisionWorld", (uint64_t (*)(re::internal *))re::allocInfo_CollisionWorld, (re::IntrospectionBase *(*)(void))re::initInfo_CollisionWorld, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CollisionWorld>, this);
}

uint64_t re::CollisionWorld::isMultithreadingEnabled(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::numCollisionObjects(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::collisionObjectAtIndex(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::doContactTest()
{
  return 0;
}

uint64_t re::CollisionWorld::doContactPairTest()
{
  return 0;
}

uint64_t *re::collisionLogObjects(re *this)
{
  {
    re::collisionLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Collision");
  }
  return &re::collisionLogObjects(void)::logObjects;
}

uint64_t re::PhysXCompoundShape::useAABBTree(re::PhysXCompoundShape *this)
{
  return 1;
}

float32x4_t *re::PhysXCompoundShape::aabb@<X0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  long long v6 = *(re::GeometricObjectBase **)(a1 + 40);
  float32x4_t v7 = (float32x4_t)vdupq_n_s32(0x7F800000u);
  v8.i64[0] = 0x7F0000007FLL;
  v8.i64[1] = 0x7F0000007FLL;
  float32x4_t v42 = v7;
  float32x4_t v43 = v8;
  if (v5)
  {
    uint64_t v9 = 240 * v5;
    do
    {
      float32x4_t v36 = v8;
      float32x4_t v37 = v7;
      re::GeometricObjectBase::aabb((uint64_t *)&v38, v6);
      float32x4_t v11 = v36;
      float32x4_t v10 = v37;
      v10.i32[3] = 0;
      float32x4_t v12 = v38;
      float32x4_t v13 = v39;
      v12.i32[3] = 0;
      v11.i32[3] = 0;
      float32x4_t v7 = vminnmq_f32(v10, v12);
      v13.i32[3] = 0;
      float32x4_t v8 = vmaxnmq_f32(v11, v13);
      long long v6 = (re::GeometricObjectBase *)((char *)v6 + 240);
      v9 -= 240;
    }
    while (v9);
    float32x4_t v42 = v7;
    float32x4_t v43 = v8;
  }
  float v14 = a2[4];
  float v15 = a2[5];
  float v16 = v14 + v14;
  float v17 = v15 + v15;
  float v18 = a2[6];
  float v19 = a2[7];
  float v20 = v18 + v18;
  float v21 = v14 * (float)(v14 + v14);
  float v22 = v15 * (float)(v15 + v15);
  float v23 = v18 * (float)(v18 + v18);
  float v24 = v16 * v15;
  float v25 = v16 * v18;
  float v26 = v17 * v18;
  float v27 = v17 * v19;
  float v28 = v20 * v19;
  v29.i32[3] = 0;
  v29.f32[0] = 1.0 - (float)(v22 + v23);
  v29.f32[1] = v24 + v28;
  v29.f32[2] = v25 - v27;
  float v30 = v16 * v19;
  float32_t v31 = 1.0 - (float)(v21 + v23);
  v32.i32[3] = 0;
  v32.f32[0] = v24 - v28;
  v32.f32[1] = v31;
  v32.f32[2] = v26 + v30;
  HIDWORD(v33) = 0;
  *(float *)&long long v33 = v25 + v27;
  *((float *)&v33 + 1) = v26 - v30;
  *((float *)&v33 + 2) = 1.0 - (float)(v21 + v22);
  float32x4_t v38 = v29;
  float32x4_t v39 = v32;
  long long v34 = *(_OWORD *)a2;
  HIDWORD(v34) = 1.0;
  long long v40 = v33;
  long long v41 = v34;
  return re::AABB::transform(&v42, &v38, a3);
}

void re::PhysXCompoundShape::~PhysXCompoundShape(re::PhysXCompoundShape *this)
{
  re::CompoundShape::~CompoundShape(this);
  JUMPOUT(0x237DBCBD0);
}

float re::ConeShape::massProperties(uint64_t a1, float *a2, _OWORD *a3, uint64_t a4)
{
  float v8 = (*(float (**)(uint64_t))(*(void *)a1 + 64))(a1);
  float v9 = (*(float (**)(uint64_t))(*(void *)a1 + 72))(a1);
  float v10 = v9 * v9;
  float v11 = v8 * (float)(v10 * 1.0472);
  *a2 = v11;
  float v12 = (float)((float)(v8 * (float)(v8 * 0.0375)) + (float)(v10 * 0.15)) * v11;
  *(void *)(a4 + 4) = 0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = v12;
  *(float *)(a4 + 20) = v10 * (float)(v11 * 0.3);
  *(float *)(a4 + 40) = v12;
  *(_DWORD *)(a4 + 44) = 0;
  float result = v8 * -0.25;
  LODWORD(v14) = 0;
  *((float *)&v14 + 1) = v8 * -0.25;
  *a3 = v14;
  return result;
}

int32x4_t re::PhysXEmptyShape::aabb@<Q0>(uint64_t a1@<X8>)
{
  int32x4_t result = vdupq_n_s32(0x7F800000u);
  *(void *)&long long v2 = 0x7F0000007FLL;
  *((void *)&v2 + 1) = 0x7F0000007FLL;
  *(int32x4_t *)a1 = result;
  *(_OWORD *)(a1 + 16) = v2;
  return result;
}

void re::PhysXEmptyShape::~PhysXEmptyShape(re::PhysXEmptyShape *this)
{
}

float re::RectangleShape::massProperties(uint64_t a1, float *a2, void *a3, uint64_t a4)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
  float v15 = v8;
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  v10.i64[0] = LODWORD(v15) | 0x3400000000000000;
  v10.i64[1] = HIDWORD(v9) | 0x3400000000000000;
  float32x4_t v11 = vmulq_f32(v10, v10);
  float v12 = (float)(v15 * 0.00000011921) * *((float *)&v9 + 1);
  *a2 = v12;
  float v13 = v12 / 12.0;
  *(void *)(a4 + 4) = 0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = v13 * (float)(v11.f32[1] + v11.f32[2]);
  *(float *)(a4 + 20) = v13 * (float)(v11.f32[0] + v11.f32[2]);
  float result = v13 * vaddv_f32(*(float32x2_t *)v11.f32);
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

re::PhysXCollisionFactory *re::PhysXCollisionFactory::PhysXCollisionFactory(re::PhysXCollisionFactory *this)
{
  uint64_t v1 = this;
  uint64_t v49 = *MEMORY[0x263EF8340];
  *(_OWORD *)((char *)this + 8) = 0u;
  long long v2 = (uint64_t *)((char *)this + 8);
  *(void *)this = &unk_26E6DDE28;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB20, memory_order_acquire) & 1) == 0)
  {
    this = (re::PhysXCollisionFactory *)__cxa_guard_acquire(&qword_26AF7FB20);
    if (this)
    {
      _MergedGlobals_130 = (uint64_t)&unk_26E72F050;
      __cxa_guard_release(&qword_26AF7FB20);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB30, memory_order_acquire) & 1) == 0)
  {
    this = (re::PhysXCollisionFactory *)__cxa_guard_acquire(&qword_26AF7FB30);
    if (this)
    {
      qword_26AF7FB28 = 0x412000003F800000;
      __cxa_guard_release(&qword_26AF7FB30);
    }
  }
  re::internal::nvphysx::initPhysX(this);
  uint64_t Instance = physx::shdfnd::Foundation::createInstance(67174656, (uint64_t)&_MergedGlobals_130, (uint64_t)re::PhysXCollisionFactory::PhysXCollisionFactory(void)::s_allocatorCallback);
  if (*v2) {
    (**(void (***)(uint64_t))*v2)(*v2);
  }
  *long long v2 = Instance;
  float v8 = (physx::Dy *)physx::NpPhysics::createInstance((physx::shdfnd::Foundation *)0x4010100, Instance, (float *)&qword_26AF7FB28, 0, v3, v4, v5, v6);
  unint64_t v14 = v8;
  if (v8)
  {
    PxRegisterArticulations(v8);
    PxRegisterArticulationsReducedCoordinate(v14);
    physx::PxvRegisterHeightFields(v15);
    physx::Gu::registerHeightFields(v16);
  }
  uint64_t v17 = *((void *)v1 + 2);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 16))(v17);
  }
  *((void *)v1 + 2) = v14;
  uint64_t v18 = *((void *)v1 + 1);
  float v42 = *(float *)&qword_26AF7FB28 * (float)(*(float *)&qword_26AF7FB28 * 0.06);
  *(void *)float32x4_t v43 = 976715828;
  *(_DWORD *)((char *)&v43[1] + 3) = 0;
  *(void *)&v43[3] = qword_26AF7FB28;
  v43[5] = 0;
  uint64_t v44 = 0x3F0CCCCD00000000;
  int v45 = 0;
  int v46 = 0;
  int v47 = 32;
  __n128 Cooking = PxCreateCooking((physx::shdfnd::Foundation *)0x4010100, v18, (uint64_t)&v42, v9, v10, v11, v12, v13);
  uint64_t v21 = v20;
  float v22 = (void (***)(void, __n128))*((void *)v1 + 3);
  if (v22) {
    (**v22)(v22, Cooking);
  }
  *((void *)v1 + 3) = v21;
  uint64_t v23 = (*(uint64_t (**)(void, float, float, float))(**((void **)v1 + 2) + 240))(*((void *)v1 + 2), 0.5, 0.5, 0.1);
  float v24 = (void (***)(void))*((void *)v1 + 6);
  if (v24) {
    (**v24)(v24);
  }
  *((void *)v1 + 6) = v23;
  uint64_t v26 = *((void *)v1 + 2);
  uint64_t v25 = *((void *)v1 + 3);
  bzero(&v42, 0x3C0uLL);
  for (uint64_t i = 0; i != 60; ++i)
  {
    __float2 v28 = __sincosf_stret((float)((float)((float)(int)i / 60.0) + (float)((float)(int)i / 60.0)) * 3.1416);
    *(void *)&long long v29 = LODWORD(v28.__cosval) | 0xBF00000000000000;
    *((void *)&v29 + 1) = LODWORD(v28.__sinval) | 0xBF00000000000000;
    *(_OWORD *)&v43[4 * i - 1] = v29;
  }
  long long v48 = xmmword_23437C520;
  float32_t v31 = (void (***)(void))*((void *)v1 + 4);
  if (v31) {
    (**v31)(v31);
  }
  *((void *)v1 + 4) = ConvexMesh;
  uint64_t v33 = *((void *)v1 + 2);
  uint64_t v32 = *((void *)v1 + 3);
  bzero(&v42, 0x780uLL);
  for (uint64_t j = 0; j != 60; ++j)
  {
    __float2 v36 = __sincosf_stret((float)((float)((float)(int)j / 60.0) + (float)((float)(int)j / 60.0)) * 3.1416);
    *(float *)&long long v35 = v36.__cosval;
    long long v37 = v35;
    DWORD1(v37) = -0.5;
    DWORD2(v37) = LODWORD(v36.__sinval);
    float32x4_t v38 = (_OWORD *)&v43[4 * j - 1];
    DWORD1(v35) = 0.5;
    *float32x4_t v38 = v37;
    DWORD2(v35) = LODWORD(v36.__sinval);
    v38[60] = v35;
  }
  long long v40 = (void (***)(void))*((void *)v1 + 5);
  if (v40) {
    (**v40)(v40);
  }
  *((void *)v1 + 5) = v39;
  return v1;
}

void re::PhysXCollisionFactory::~PhysXCollisionFactory(re::PhysXCollisionFactory *this)
{
  long long v2 = (void (***)(void))*((void *)this + 5);
  if (v2) {
    (**v2)(v2);
  }
  *((void *)this + 5) = 0;
  uint64_t v3 = (void (***)(void))*((void *)this + 4);
  if (v3) {
    (**v3)(v3);
  }
  *((void *)this + 4) = 0;
  uint64_t v4 = (void (***)(void))*((void *)this + 6);
  if (v4) {
    (**v4)(v4);
  }
  *((void *)this + 6) = 0;
  uint64_t v5 = (void (***)(void))*((void *)this + 3);
  if (v5) {
    (**v5)(v5);
  }
  *((void *)this + 3) = 0;
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  *((void *)this + 2) = 0;
  float32x4_t v7 = (void (***)(void))*((void *)this + 1);
  if (v7) {
    (**v7)(v7);
  }
  *((void *)this + 1) = 0;
  float v8 = (void (***)(void))*((void *)this + 6);
  if (v8) {
    (**v8)(v8);
  }
  uint64_t v9 = (void (***)(void))*((void *)this + 5);
  if (v9) {
    (**v9)(v9);
  }
  uint64_t v10 = (void (***)(void))*((void *)this + 4);
  if (v10) {
    (**v10)(v10);
  }
  uint64_t v11 = (void (***)(void))*((void *)this + 3);
  if (v11) {
    (**v11)(v11);
  }
  uint64_t v12 = *((void *)this + 2);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
  }
  uint64_t v13 = (void (***)(void))*((void *)this + 1);
  if (v13) {
    (**v13)(v13);
  }
}

{
  uint64_t vars8;

  re::PhysXCollisionFactory::~PhysXCollisionFactory(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PhysXCollisionFactory::createCollisionWorld(re::PhysXCollisionFactory *this, re::Allocator *a2)
{
  uint64_t v4 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 416, 16);
  uint64_t v5 = *((void *)this + 2);
  return re::PhysXCollisionWorld::PhysXCollisionWorld(v4, (uint64_t)a2, v5);
}

float re::PhysXCollisionFactory::createBoxShape(double a1, double a2, float a3, uint64_t a4, const char *a5, float *a6)
{
  float v8 = *a6 * 0.5;
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1) {
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  }
  float v12 = a6[1] * 0.5;
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1) {
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  }
  float v15 = a6[2];
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1) {
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  }
  uint64_t v17 = (*(uint64_t (**)(const char *, uint64_t, uint64_t))(*(void *)a5 + 32))(a5, 40, 8);
  float v18 = fminf(fminf(v11, v16), v14);
  *(_DWORD *)(v17 + 20) = 3;
  float result = v18 + v18;
  *(float *)(v17 + 16) = result;
  *(void *)uint64_t v17 = &unk_26E6DE0F8;
  *(void *)(v17 + 8) = v17 + 20;
  *(float *)(v17 + 24) = v11;
  *(float *)(v17 + 28) = v14;
  *(float *)(v17 + 32) = v16;
  return result;
}

float anonymous namespace'::ensureValidExtent(_anonymous_namespace_ *this, float a2, const char *a3, float a4, float a5)
{
  float v5 = a2;
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a2 < a4) {
    a2 = a4;
  }
  if ((LODWORD(a2) & 0x7FFFFFFFu) >= 0x7F800000) {
    float v6 = 1000000.0;
  }
  else {
    float v6 = a2;
  }
  if (v6 != v5)
  {
    float v8 = *re::collisionLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315394;
      float v11 = this;
      __int16 v12 = 2048;
      double v13 = v5;
      _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "Bad parameter (%s), value = %f, passed to shape creation.", (uint8_t *)&v10, 0x16u);
    }
  }
  return v6;
}

float re::PhysXCollisionFactory::createCapsuleShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  uint64_t v11 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32, 8);
  if (v10 <= v7) {
    float v12 = v10;
  }
  else {
    float v12 = v7;
  }
  *(_DWORD *)(v11 + 20) = 2;
  float result = v12 + v12;
  *(float *)(v11 + 16) = result;
  *(void *)uint64_t v11 = &unk_26E6DD130;
  *(void *)(v11 + 8) = v11 + 20;
  *(float *)(v11 + 24) = v7;
  *(float *)(v11 + 28) = v10;
  return result;
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
    return re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(v8, v7);
  }
  return result;
}

uint64_t anonymous namespace'::createConvexMesh(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v21 = 0;
  int v22 = 0;
  int v23 = 0;
  uint64_t v24 = 0;
  __int16 v27 = 255;
  int v20 = 0;
  int v19 = a4;
  uint64_t v18 = a3;
  int v17 = a5;
  int v25 = 0;
  int v26 = 16711762;
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)physx::shdfnd::Foundation::mInstance + 32))(physx::shdfnd::Foundation::mInstance);
  double v13 = &unk_26E72F3B0;
  uint64_t v14 = v7;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int v12 = 0;
  uint64_t v8 = (re *)(*(uint64_t (**)(uint64_t, int *, void **, int *))(*(void *)a1 + 56))(a1, &v17, &v13, &v12);
  if (v8)
  {
    *(void *)buf = &unk_26E72F3E8;
    uint64_t v30 = v15;
    int v29 = v16;
    int v31 = 0;
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)a2 + 96))(a2, buf);
  }
  else
  {
    float v10 = *re::collisionLogObjects(v8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v12;
      _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "Failed to cook convex mesh (0x%x)", buf, 8u);
    }
    uint64_t v9 = 0;
  }
  double v13 = &unk_26E72F3B0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  return v9;
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, a3, a4, 16);
}

{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, a3, a4, 16);
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, *(void *)(a3 + 32), *(void *)(a3 + 16), 16);
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(re::PhysXCollisionFactory *this, Allocator *a2, const re::ConvexPolyhedronShape *a3)
{
  uint64_t v3 = *(void *)(*((void *)a3 + 1) + 32);
  uint64_t v4 = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 72, 8);
  return re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(v4, v3);
}

uint64_t *re::PhysXCollisionFactory::emptyShape(re::PhysXCollisionFactory *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7FB38))
  {
    dword_26AF7FB50 = 0;
    qword_26AF7FB40 = (uint64_t)&unk_26E6DDDA8;
    unk_26AF7FB48 = 0;
    __cxa_guard_release(&qword_26AF7FB38);
  }
  return &qword_26AF7FB40;
}

uint64_t re::PhysXCollisionFactory::createEmptyShape(re::PhysXCollisionFactory *this, Allocator *a2)
{
  uint64_t result = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 24, 8);
  *(_DWORD *)(result + 16) = 0;
  *(void *)uint64_t result = &unk_26E6DDDA8;
  *(void *)(result + 8) = 0;
  return result;
}

uint64_t re::PhysXCollisionFactory::createPlaneShape(float a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 112, 16);
  return re::PhysXPlaneShape::PhysXPlaneShape(v6, a4, a1);
}

uint64_t re::PhysXCollisionFactory::createSphereShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, double a4, float a5)
{
  uint64_t result = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32, 8);
  *(_DWORD *)(result + 20) = 0;
  *(float *)(result + 16) = v6;
  *(void *)uint64_t result = &unk_26E6DE088;
  *(void *)(result + 8) = result + 20;
  *(float *)(result + 24) = v6;
  return result;
}

double re::PhysXCollisionFactory::createConeShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  uint64_t v12 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
  uint64_t v13 = *((void *)this + 4);
  float v14 = v8 + v8;
  *(_DWORD *)(v12 + 24) = 4;
  if ((float)(v8 + v8) > v11) {
    float v14 = v11;
  }
  *(float *)(v12 + 16) = v14;
  *(void *)uint64_t v12 = &unk_26E6DD308;
  *(void *)(v12 + 8) = v12 + 24;
  *(float *)(v12 + 28) = v8;
  *(float *)(v12 + 32) = v11;
  *(float *)(v12 + 36) = v8;
  double result = 0.0;
  *(_OWORD *)(v12 + 40) = xmmword_23435FBB0;
  *(void *)(v12 + 56) = v13;
  *(unsigned char *)(v12 + 64) = 1;
  *(unsigned char *)(v12 + 67) = 0;
  *(_WORD *)(v12 + 65) = 0;
  return result;
}

double re::PhysXCollisionFactory::createCylinderShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  uint64_t v12 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
  uint64_t v13 = *((void *)this + 5);
  float v14 = v8 + v8;
  *(_DWORD *)(v12 + 24) = 4;
  if ((float)(v8 + v8) > v11) {
    float v14 = v11;
  }
  *(float *)(v12 + 16) = v14;
  *(void *)uint64_t v12 = &unk_26E6DDB88;
  *(void *)(v12 + 8) = v12 + 24;
  *(float *)(v12 + 28) = v8;
  *(float *)(v12 + 32) = v11;
  *(float *)(v12 + 36) = v8;
  double result = 0.0;
  *(_OWORD *)(v12 + 40) = xmmword_23435FBB0;
  *(void *)(v12 + 56) = v13;
  *(unsigned char *)(v12 + 64) = 1;
  *(unsigned char *)(v12 + 67) = 0;
  *(_WORD *)(v12 + 65) = 0;
  return result;
}

float re::PhysXCollisionFactory::createRectangleShape(double a1, double a2, float a3, uint64_t a4, const char *a5, float *a6)
{
  uint64_t v12 = (*(uint64_t (**)(const char *, uint64_t, uint64_t))(*(void *)a5 + 32))(a5, 40, 8);
  if (v11 >= v8) {
    float v13 = v8;
  }
  else {
    float v13 = v11;
  }
  *(_DWORD *)(v12 + 20) = 3;
  float result = v13 + v13;
  *(float *)(v12 + 16) = result;
  *(void *)uint64_t v12 = &unk_26E6DDB18;
  *(void *)(v12 + 8) = v12 + 20;
  *(float *)(v12 + 24) = v8;
  *(_DWORD *)(v12 + 28) = 872415232;
  *(float *)(v12 + 32) = v11;
  return result;
}

void *re::PhysXCollisionFactory::createCompoundShape(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 144, 8);
  float result = (void *)re::CompoundShape::CompoundShape(v12, a2, 0, a3, a4, a5, a7);
  *float result = &unk_26E6DDD18;
  return result;
}

void re::PhysXCollisionFactory::createTriangleMeshShape(re::PhysXCollisionFactory *this, re::Allocator *a2, const re::IndexedTriangleMesh *a3)
{
  if (a3)
  {
    uint64_t v4 = *((void *)a3 + 8);
    if (v4)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 120))(&v9);
      float v6 = v12 - *((float *)&v9 + 1);
      if ((float)(v12 - *((float *)&v9 + 1)) >= (float)(v13 - v10)) {
        float v6 = v13 - v10;
      }
      if ((float)(v11 - *(float *)&v9) >= v6) {
        float v7 = v6;
      }
      else {
        float v7 = v11 - *(float *)&v9;
      }
      float v8 = (re::PhysXTriangleMeshShape *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 80, 8);
      re::PhysXTriangleMeshShape::PhysXTriangleMeshShape(v8, a3, v7);
    }
  }
}

re::PhysXCollisionObject *re::PhysXCollisionFactory::createCollisionObject(re::CollisionFactory *a1, re::Allocator *a2, const re::CollisionShape *a3, uint64_t *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v9 = a3;
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v12 = (*(uint64_t (**)(const re::CollisionShape *))(*(void *)a3 + 56))(a3);
  uint64_t v13 = *((void *)a1 + 2);
  if ((a5 & 9) == 0 && v12 == 0)
  {
    long long v26 = *((_OWORD *)a4 + 1);
    uint64_t v27 = *a4;
    int v28 = *((_DWORD *)a4 + 2);
    uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, long long *))(*(void *)v13 + 176))(v13, &v26);
    (*(void (**)(void))(*v15 + 560))();
    (*(void (**)(void *, uint64_t, uint64_t))(*v15 + 560))(v15, 2, 1);
    (*(void (**)(void *, uint64_t, uint64_t))(*v15 + 560))(v15, 4, 1);
    (*(void (**)(void *, uint64_t, uint64_t))(*v15 + 560))(v15, 8, 1);
    (*(void (**)(void *, uint64_t, uint64_t))(*v15 + 560))(v15, 16, 1);
    (*(void (**)(void *, uint64_t, uint64_t))(*v15 + 560))(v15, 32, 1);
    if (a6) {
      goto LABEL_9;
    }
  }
  else
  {
    long long v26 = *((_OWORD *)a4 + 1);
    uint64_t v27 = *a4;
    int v28 = *((_DWORD *)a4 + 2);
    uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, long long *))(*(void *)v13 + 168))(v13, &v26);
    if (a6) {
      goto LABEL_9;
    }
  }
  uint64_t v9 = (const re::CollisionShape *)re::CollisionFactory::deepCopyShape(a1, a2, v9);
  a6 = (uint64_t)a2;
LABEL_9:
  GeometricObject = (void *)re::CollisionFactory::createGeometricObject((uint64_t)a1, (uint64_t)a2, (uint64_t)v9, a4, a6);
  uint64_t v17 = *((void *)a1 + 6);
  uint64_t v18 = *((void *)a1 + 2);
  float32x4_t v23 = 0uLL;
  uint64_t v25 = 0x3F80000000000000;
  *(void *)&long long v26 = v17;
  uint64_t v24 = 0;
  if (attachShape(v18, (uint64_t)v15, GeometricObject, 0, &v23, (uint64_t)&v26, 1, (a5 >> 1) & 1)) {
    int v19 = 2;
  }
  else {
    int v19 = 0;
  }
  int v20 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 144, 16);
  v21.i32[0] = 1.0;
  return re::PhysXCollisionObject::PhysXCollisionObject(v20, v19, a5, (uint64_t)GeometricObject, (uint64_t)a2, v15, v21);
}

uint64_t attachShape(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, float32x4_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = (*(uint64_t (**)(void *))(*a3 + 16))(a3);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 24))(v16) == 1) {
    return 0;
  }
  if (a4)
  {
    (*(void (**)(int32x4_t *__return_ptr, void *))(*a3 + 40))(&v55, a3);
    _Q0 = a5[1];
    float32x4_t v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL);
    float32x4_t v19 = vnegq_f32(_Q0);
    float32x4_t v20 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v55, v55), (int8x16_t)v55, 0xCuLL), v19), (float32x4_t)v55, v18);
    int32x4_t v21 = (int32x4_t)vaddq_f32(v20, v20);
    float32x4_t v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL);
    int32x4_t v23 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v19), v22, v18);
    float32x4_t v24 = vaddq_f32(vaddq_f32((float32x4_t)v55, vmulq_laneq_f32(v22, _Q0, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL));
    _Q5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v56, v56), (int8x16_t)v56, 0xCuLL), v19), (float32x4_t)v56, v18);
    float32x4_t v26 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q5, _Q5), (int8x16_t)_Q5, 0xCuLL), (float32x4_t)v56, _Q0, 3), _Q0, (float32x4_t)v56, 3);
    _S4 = v56.i32[3];
    __asm { FMLA            S5, S4, V0.S[3] }
    v26.i32[3] = _Q5.i32[0];
    *a5 = vaddq_f32(*a5, v24);
    a5[1] = v26;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 24))(v16) == 7)
  {
    uint64_t v32 = *(void *)(v16 + 32);
    if (v32)
    {
      uint64_t v33 = *(void *)(v16 + 40);
      uint64_t v34 = 240 * v32;
      LODWORD(v16) = 1;
      do
      {
        float32x4_t v35 = a5[1];
        v54[0] = *a5;
        v54[1] = v35;
        uint64_t v16 = v16 & attachShape(a1, a2, v33, a3, v54, a6, a7, a8);
        v33 += 240;
        v34 -= 240;
      }
      while (v34);
      return v16;
    }
    return 1;
  }
  uint64_t v36 = *(void *)(v16 + 8);
  if (!v36) {
    return 1;
  }
  a3[6] = a4;
  char v53 = 11;
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(void *)a1 + 192))(a1, v36, a6, a7, 1, &v53);
  uint64_t v38 = v37;
  if (a8)
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v37 + 296))(v37, 1, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v38 + 296))(v38, 4, 1);
  }
  else if (!v37)
  {
    return 1;
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16))
  {
    uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 48))(v16);
    _Q2 = a5[1];
    float32x4_t v41 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
    _Q4 = *(float32x4_t *)(v39 + 16);
    float32x4_t v43 = vnegq_f32(_Q2);
    float32x4_t v44 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)v39, *(int32x4_t *)v39), *(int8x16_t *)v39, 0xCuLL), v43), *(float32x4_t *)v39, v41);
    int32x4_t v45 = (int32x4_t)vaddq_f32(v44, v44);
    float32x4_t v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v45, v45), (int8x16_t)v45, 0xCuLL);
    int32x4_t v47 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), v43), v46, v41);
    float32x4_t v48 = vaddq_f32(*a5, vaddq_f32(vaddq_f32(*(float32x4_t *)v39, vmulq_laneq_f32(v46, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v47, v47), (int8x16_t)v47, 0xCuLL)));
    _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), (int8x16_t)_Q4, 0xCuLL), v43), _Q4, v41);
    float32x4_t v50 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), _Q4, _Q2, 3), _Q2, _Q4, 3);
    _Q4.i32[0] = _Q4.i32[3];
    __asm { FMLA            S3, S4, V2.S[3] }
    v50.i32[3] = _Q3.i32[0];
    *a5 = v48;
    a5[1] = v50;
    __int32 v51 = v48.i32[2];
  }
  else
  {
    float32x4_t v50 = a5[1];
    v48.i64[0] = a5->i64[0];
    __int32 v51 = a5->i32[2];
  }
  a3[7] = v38;
  int32x4_t v55 = (int32x4_t)v50;
  v56.i64[0] = v48.i64[0];
  v56.i32[2] = v51;
  (*(void (**)(uint64_t, int32x4_t *))(*(void *)v38 + 152))(v38, &v55);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 168))(a2, v38);
  uint64_t v16 = (*(unsigned int (**)(uint64_t))(*(void *)v38 + 64))(v38) == 3
     || (*(unsigned int (**)(uint64_t))(*(void *)v38 + 64))(v38) == 4
     || (*(unsigned int (**)(uint64_t))(*(void *)v38 + 64))(v38) == 5;
  (**(void (***)(uint64_t))v38)(v38);
  return v16;
}

re::PhysXCollisionObject *re::PhysXCollisionFactory::createCollisionObject(re::PhysXCollisionFactory *this, re::Allocator *a2, re::GeometricObjectBase *a3, void *a4, void *const *a5, uint64_t a6)
{
  uint64_t v9 = *((void *)this + 2);
  float32x4_t v14 = 0uLL;
  uint64_t v15 = 0;
  uint64_t v16 = 0x3F80000000000000;
  if (attachShape(v9, (uint64_t)a4, a3, 0, &v14, (uint64_t)a5, a6, 0)) {
    int v10 = 3;
  }
  else {
    int v10 = 1;
  }
  float v11 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 144, 16);
  v12.i32[0] = 1.0;
  return re::PhysXCollisionObject::PhysXCollisionObject(v11, v10, 8, (uint64_t)a3, 0, a4, v12);
}

uint64_t re::PhysXCollisionFactory::createIndexedTriangleMesh(re *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, unint64_t a7, int a8, uint64_t a9, unint64_t a10)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    float v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int32x2_t v12 = "Triangle mesh positions must not be null.";
      goto LABEL_10;
    }
    return 0;
  }
  if (!a6)
  {
    float v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int32x2_t v12 = "Triangle mesh indices must not be null.";
      goto LABEL_10;
    }
    return 0;
  }
  if (a7 != 3 * (a7 / 3))
  {
    float v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int32x2_t v12 = "Triangle mesh index count is not a multiple of 3.";
LABEL_10:
      uint64_t v13 = v11;
      uint32_t v14 = 2;
LABEL_11:
      _os_log_error_impl(&dword_233120000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      return 0;
    }
    return 0;
  }
  if (a9 && a7 / 3 > a10)
  {
    uint64_t v17 = *re::collisionLogObjects(a1);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 134217984;
    *(void *)float32x4_t v35 = a7;
    int32x2_t v12 = "Failed to cook triangle mesh material index count is too small, expected %zu material indices";
    uint64_t v13 = v17;
    uint32_t v14 = 12;
    goto LABEL_11;
  }
  __int16 v40 = 0;
  int v36 = a4;
  *(void *)&v35[4] = a3;
  *(_DWORD *)buf = a5;
  int v39 = a7 / 3;
  uint64_t v38 = a6;
  if (a8 == 1)
  {
    __int16 v40 = 2;
    int v20 = 6;
  }
  else
  {
    int v20 = 12;
  }
  uint64_t v42 = a9;
  int v37 = v20;
  int v41 = 2 * (a9 != 0);
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)physx::shdfnd::Foundation::mInstance + 32))(physx::shdfnd::Foundation::mInstance);
  float32x4_t v26 = &unk_26E72F3B0;
  uint64_t v27 = v21;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  int v25 = 0;
  float32x4_t v22 = (re *)(*(uint64_t (**)(void *, uint8_t *, void **, int *))(**((void **)a1 + 3) + 32))(*((void **)a1 + 3), buf, &v26, &v25);
  if (v22)
  {
    *(void *)uint64_t v30 = &unk_26E72F3E8;
    int v31 = v29;
    uint64_t v32 = v28;
    int v33 = 0;
    uint64_t v23 = (*(uint64_t (**)(void *, uint8_t *))(**((void **)a1 + 2) + 48))(*((void **)a1 + 2), v30);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 72, 8);
    re::PhysXIndexedTriangleMesh::PhysXIndexedTriangleMesh(v18, v23);
  }
  else
  {
    float32x4_t v24 = *re::collisionLogObjects(v22);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v30 = 67109120;
      *(_DWORD *)&v30[4] = v25;
      _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Failed to cook triangle mesh (0x%x)", v30, 8u);
    }
    uint64_t v18 = 0;
  }
  float32x4_t v26 = &unk_26E72F3B0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  }
  return v18;
}

uint64_t re::PhysXCollisionFactory::createCharacterController(uint64_t a1, re::Allocator *a2, uint64_t a3, float32x2_t *a4, uint64_t *a5, uint64_t a6, float a7)
{
  float v14 = *(float *)(a3 + 24);
  if ((float)(*(float *)(a3 + 20) + (float)(v14 * -2.0)) >= 0.01) {
    float v15 = *(float *)(a3 + 20) + (float)(v14 * -2.0);
  }
  else {
    float v15 = 0.01;
  }
  uint64_t v16 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 384, 16);
  uint64_t v17 = re::CharacterController::CharacterController((re::CharacterController *)v16, a2, *(float *)a3, *(float *)(a3 + 8), *(float *)(a3 + 4));
  *((float *)v17 + 84) = (float)(v15 + (float)(v14 * 2.0)) + (float)(v14 * -2.0);
  *((float *)v17 + 85) = v14;
  *(void *)uint64_t v17 = &unk_26E6DD848;
  *((void *)v17 + 43) = &unk_26E6DD940;
  *((void *)v17 + 44) = v17;
  *((void *)v17 + 45) = &unk_26E6DDF70;
  *((void *)v17 + 46) = 0;
  re::PhysXCollisionFactory::createCapsuleShape(v17, a2, (float)(v15 + (float)(*(float *)(a3 + 24) * 2.0)) * a7, *(float *)(a3 + 24) * a7, v18);
  re::internal::PhysXCapsuleController::createUnderlyingController((void *)v16, (uint64_t)a2, v19, (float *)a3, a4, a5, a6, *(void *)(a1 + 48), a7);
  int v20 = (void *)(*(uint64_t (**)(void))(**(void **)(v16 + 152) + 56))(*(void *)(v16 + 152));
  uint64_t v21 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 144, 16);
  *(float *)v22.i32 = a7;
  uint64_t v23 = re::PhysXCollisionObject::PhysXCollisionObject(v21, 1, 0, v16, 0, v20, v22);
  *(void *)(v16 + 136) = v23;
  uint64_t v24 = *(void *)(a3 + 12);
  if (*((void *)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    (*(void (**)(re::PhysXCollisionObject *))(*(void *)v23 + 80))(v23);
  }
  return v16;
}

void *re::PhysXCollisionFactory::serializeRawShape@<X0>(re::Allocator *a1@<X2>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)a2 = a1;
  float result = re::DynamicArray<BOOL>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

uint64_t re::PhysXCollisionFactory::type(re::PhysXCollisionFactory *this)
{
  return 0;
}

void anonymous namespace'::PhysXAllocator::~PhysXAllocator(_anonymous_namespace_::PhysXAllocator *this)
{
}

uint64_t anonymous namespace'::PhysXAllocator::allocate(_anonymous_namespace_::PhysXAllocator *this, uint64_t a2, const char *a3, const char *a4)
{
}

uint64_t anonymous namespace'::PhysXAllocator::deallocate(_anonymous_namespace_::PhysXAllocator *this, void *a2)
{
}

void re::internal::PhysXControllerBehaviorCallback::getBehaviorFlags(unsigned char *a1@<X8>)
{
  *a1 = 4;
}

{
  *a1 = 4;
}

{
  *a1 = 4;
}

void re::internal::PhysXControllerBehaviorCallback::~PhysXControllerBehaviorCallback(re::internal::PhysXControllerBehaviorCallback *this)
{
}

void ___ZN2re23RECollisionFeatureFlags22getMinimumBoxDimensionEv_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  re::Defaults::floatValue((re::Defaults *)"RECollisionMinimumBoxDimension", a2, (uint64_t)&v4);
  if ((_BYTE)v4) {
    re::RECollisionFeatureFlags::gMinimumBoxDimension = LODWORD(v5);
  }
  uint64_t v3 = *re::collisionLogObjects(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 134217984;
    double v5 = *(float *)&re::RECollisionFeatureFlags::gMinimumBoxDimension;
    _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "RECollisionMinimumBoxDimension is now %f.", (uint8_t *)&v4, 0xCu);
  }
}

void re::ContactSet::~ContactSet(re::ContactSet *this)
{
  long long v2 = (char *)this + 16;
  if (*((void *)this + 2))
  {
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + 16);
    *((void *)this + 14) = 0;
    *((void *)this + 15) = 0;
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
}

uint64_t re::ContactSet::set(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3);
  re::DynamicArray<re::Contact>::resize(a1 + 2, (int)v6);
  uint64_t v7 = *(void *)(*a1 + 24);
  BOOL v8 = v7 != *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a3) + 24);
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, void *, void, uint64_t, BOOL))(*(void *)a2 + 56);
  return v9(a2, a3, a1, 0, v6, v8);
}

void *re::DynamicArray<re::Contact>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      float result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 80 * v4;
      uint64_t v7 = v5 + 80 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = v7 / 0x50uLL + 1;
        do
        {
          *(_DWORD *)(v6 + 64) = 0;
          *(_OWORD *)(v6 + 32) = 0uLL;
          *(_OWORD *)(v6 + 48) = 0uLL;
          *(_OWORD *)uint64_t v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = 0uLL;
          v6 += 80;
          --v8;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::ContactSet::merge(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 4;
  uint64_t v7 = a1[8];
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3);
  re::DynamicArray<re::Contact>::resize(v6, (int)v8 + (int)v7);
  uint64_t v9 = *(void *)(*(void *)a1 + 24);
  BOOL v10 = v9 != *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a3) + 24);
  float v11 = *(uint64_t (**)(uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, BOOL))(*(void *)a2 + 56);
  return v11(a2, a3, a1, v7, v8, v10);
}

re::PhysXCollisionObject *re::PhysXCollisionObject::PhysXCollisionObject(re::PhysXCollisionObject *a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6, int32x2_t a7)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  BOOL v10 = (int32x4_t *)re::CollisionObject::CollisionObject((uint64_t)a1, a2, a3, a4, a5, (uint64_t)a6);
  v10->i64[0] = (uint64_t)&unk_26E6DE000;
  v10[7].i64[0] = 0;
  v10[7].i64[1] = 0;
  v10[6].i64[1] = 0;
  v10[8] = vdupq_lane_s32(a7, 0);
  a6[2] = v10;
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 24))(v11) == 7)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
    *(void *)&long long v41 = a1;
    *((void *)&v41 + 1) = re::PhysXCollisionObject::onChildPoseDidChange;
    *(void *)&long long v42 = 0;
    *((void *)&v42 + 1) = re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    v12.n128_f64[0] = re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription((_DWORD *)(v13 + 56), (uint64_t)&v41);
  }
  float v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void *, __n128))(*a6 + 184))(a6, v12);
  int v15 = (int)v14;
  uint64_t v16 = v14;
  *((void *)a1 + 14) = v16;
  if (v15)
  {
    *((void *)a1 + 15) = v17;
    if (!v17)
    {
LABEL_26:
      re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_27:
      re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) Unsupported geometry type!", "!\"Unreachable code\"", "getExtentsForAllShapes", 63);
      _os_crash();
      __break(1u);
    }
  }
  unsigned int v19 = (*(uint64_t (**)(void *))(*a6 + 184))(a6);
  if (v19)
  {
    unint64_t v20 = 0;
    uint64_t v21 = 8;
    uint64_t v22 = v19;
    while (1)
    {
      uint64_t v29 = 0;
      (*(void (**)(void *, uint64_t *, uint64_t, unint64_t))(*a6 + 192))(a6, &v29, 1, v20);
      switch((*(unsigned int (**)(uint64_t))(*(void *)v29 + 64))(v29))
      {
        case 0u:
          uint64_t v30 = 0;
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v29 + 96))(v29, &v30);
          unint64_t v24 = *((void *)a1 + 14);
          if (v24 <= v20)
          {
            *(void *)int v36 = 0;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v41 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v31 = 136315906;
            *(void *)&long long v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            unint64_t v33 = v20;
            *(_WORD *)uint64_t v34 = 2048;
            *(void *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_22:
            uint64_t v30 = 0;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v41 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v31 = 136315906;
            *(void *)&long long v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            unint64_t v33 = v20;
            *(_WORD *)uint64_t v34 = 2048;
            *(void *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_23:
            uint64_t v30 = 0;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v41 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v31 = 136315906;
            *(void *)&long long v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            unint64_t v33 = v20;
            *(_WORD *)uint64_t v34 = 2048;
            *(void *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_24:
            uint64_t v30 = 0;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v41 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v36 = 136315906;
            *(void *)&v36[4] = "operator[]";
            *(_WORD *)&v36[12] = 1024;
            *(_DWORD *)&v36[14] = 468;
            __int16 v37 = 2048;
            unint64_t v38 = v20;
            __int16 v39 = 2048;
            unint64_t v40 = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_25:
            uint64_t v30 = 0;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v41 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v36 = 136315906;
            *(void *)&v36[4] = "operator[]";
            *(_WORD *)&v36[12] = 1024;
            *(_DWORD *)&v36[14] = 468;
            __int16 v37 = 2048;
            unint64_t v38 = v20;
            __int16 v39 = 2048;
            unint64_t v40 = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_26;
          }
          *(_DWORD *)(*((void *)a1 + 15) + v21 - 8) = HIDWORD(v30);
LABEL_19:
          ++v20;
          v21 += 12;
          if (v22 == v20) {
            goto LABEL_20;
          }
          break;
        case 1u:
          goto LABEL_19;
        case 2u:
          *(_DWORD *)&v36[8] = 0;
          *(void *)int v36 = 2;
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 104))(v29, v36);
          unint64_t v24 = *((void *)a1 + 14);
          if (v24 <= v20) {
            goto LABEL_22;
          }
          *(int32x2_t *)(*((void *)a1 + 15) + v21 - 8) = vrev64_s32(*(int32x2_t *)&v36[4]);
          goto LABEL_19;
        case 3u:
          *(void *)int v36 = 3;
          *(void *)&v36[8] = 0;
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 88))(v29, v36);
          unint64_t v24 = *((void *)a1 + 14);
          if (v24 <= v20) {
            goto LABEL_23;
          }
          int v25 = (_DWORD *)(*((void *)a1 + 15) + v21);
          *((void *)v25 - 1) = *(void *)&v36[4];
          int v26 = *(_DWORD *)&v36[12];
          goto LABEL_18;
        case 4u:
          int v31 = 4;
          long long v32 = xmmword_2343679C0;
          unint64_t v33 = 0;
          *(_DWORD *)uint64_t v34 = 1065353216;
          *(void *)&v34[4] = 0;
          LOBYTE(v35) = 1;
          *(_WORD *)((char *)&v35 + 1) = 0;
          BYTE3(v35) = 0;
          (*(void (**)(uint64_t, int *))(*(void *)v29 + 120))(v29, &v31);
          unint64_t v24 = *((void *)a1 + 14);
          if (v24 <= v20) {
            goto LABEL_24;
          }
          goto LABEL_17;
        case 5u:
          int v31 = 5;
          long long v32 = xmmword_2343679C0;
          unint64_t v33 = 0;
          *(void *)uint64_t v34 = 1065353216;
          uint64_t v35 = 0;
          (*(void (**)(uint64_t, int *))(*(void *)v29 + 128))(v29, &v31);
          unint64_t v24 = *((void *)a1 + 14);
          if (v24 <= v20) {
            goto LABEL_25;
          }
LABEL_17:
          int v25 = (_DWORD *)(*((void *)a1 + 15) + v21);
          *((void *)v25 - 1) = v32;
          int v26 = DWORD2(v32);
LABEL_18:
          *int v25 = v26;
          goto LABEL_19;
        default:
          goto LABEL_27;
      }
    }
  }
LABEL_20:
  re::PhysXCollisionObject::updateFilterData(a1);
  return a1;
}

uint64_t re::PhysXCollisionObject::onChildPoseDidChange(re::PhysXCollisionObject *this, re::GeometricObjectBase *a2, float32x4_t a3)
{
  re::GeometricObjectBase::parentPose(a2, v5, a3);
  updateLocalPoses(a2, v5);
  return 0;
}

uint64_t re::PhysXCollisionObject::updateFilterData(re::PhysXCollisionObject *this)
{
  long long v2 = (unsigned __int16 *)*((void *)this + 3);
  int v3 = *((_DWORD *)this + 2) & 1;
  if (v2) {
    BOOL v4 = v2[4] == 5;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    (*(void (**)(void *__return_ptr, void))(*(void *)v2 + 432))(v12, *((void *)this + 3));
    v3 |= (LOBYTE(v12[0]) >> 1) & 2;
  }
  unsigned int v5 = *((_DWORD *)this + 22);
  uint64_t result = (*(uint64_t (**)(unsigned __int16 *))(*(void *)v2 + 184))(v2);
  if (result)
  {
    uint64_t v7 = 0;
    unsigned int v8 = (v5 >> 1) & 4 | v3;
    do
    {
      uint64_t v13 = 0;
      (*(void (**)(unsigned __int16 *, uint64_t *, uint64_t, uint64_t))(*(void *)v2 + 192))(v2, &v13, 1, v7);
      uint64_t v9 = *((void *)this + 4);
      v12[0] = v8;
      v12[1] = v9;
      (*(void (**)(uint64_t, void *))(*(void *)v13 + 168))(v13, v12);
      (*(void (**)(uint64_t, void *))(*(void *)v13 + 184))(v13, v12);
      uint64_t v7 = (v7 + 1);
      uint64_t result = (*(uint64_t (**)(unsigned __int16 *))(*(void *)v2 + 184))(v2);
    }
    while (v7 < result);
  }
  uint64_t v10 = *((void *)this + 7);
  if (v10)
  {
    re::ContactSetCollection::remove((re::ContactSetCollection *)(*(void *)(v10 + 128) + 72), this);
    (*(void (**)(void, re::PhysXCollisionObject *))(**(void **)(v10 + 128) + 200))(*(void *)(v10 + 128), this);
    uint64_t v11 = *(void *)(v10 + 128);
    *((void *)this + 7) = v11;
    return (*(uint64_t (**)(uint64_t, re::PhysXCollisionObject *))(*(void *)v11 + 192))(v11, this);
  }
  return result;
}

void re::PhysXCollisionObject::~PhysXCollisionObject(re::PhysXCollisionObject *this)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 24))(v3) == 7)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
    *(void *)&long long v7 = this;
    *((void *)&v7 + 1) = re::PhysXCollisionObject::onChildPoseDidChange;
    uint64_t v8 = 0;
    uint64_t v9 = re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::GeometricObjectBase>::removeSubscription(v4 + 56, &v7);
  }
  unsigned int v5 = (void (***)(void))*((void *)this + 3);
  if (v5) {
    (**v5)(v5);
  }
  uint64_t v6 = *((void *)this + 13);
  if (v6)
  {
    if (*((void *)this + 14))
    {
      (*(void (**)(uint64_t, void))(*(void *)v6 + 40))(v6, *((void *)this + 15));
      *((void *)this + 14) = 0;
      *((void *)this + 15) = 0;
    }
    *((void *)this + 13) = 0;
  }
  re::CollisionObject::~CollisionObject(this);
}

{
  uint64_t vars8;

  re::PhysXCollisionObject::~PhysXCollisionObject(this);
  JUMPOUT(0x237DBCBD0);
}

re::PhysXCollisionObject *re::PhysXCollisionObject::setRawCollisionObject(re::PhysXCollisionObject *this, void *a2)
{
  *((void *)this + 3) = a2;
  if (a2)
  {
    a2[2] = this;
    return (re::PhysXCollisionObject *)re::PhysXCollisionObject::updateFilterData(this);
  }
  return this;
}

uint64_t re::PhysXCollisionObject::poseDidChange(re::PhysXCollisionObject *this, re::GeometricObjectBase *a2)
{
  uint64_t v2 = *((void *)this + 3);
  (*(void (**)(uint64_t *__return_ptr, re::GeometricObjectBase *))(*(void *)a2 + 40))(&v4, a2);
  long long v7 = v6;
  uint64_t v8 = v4;
  int v9 = v5;
  (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v2 + 160))(v2, &v7, 1);
  return 0;
}

uint64_t updateLocalPoses(void *a1, float32x4_t *a2)
{
  (*(void (**)(int32x4_t *__return_ptr))(*a1 + 40))(&v39);
  _Q0 = a2[1];
  _Q2 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL);
  float32x4_t v6 = vnegq_f32(_Q0);
  float32x4_t v7 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL), v6), (float32x4_t)v39, _Q2);
  int32x4_t v8 = (int32x4_t)vaddq_f32(v7, v7);
  float32x4_t v9 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL);
  int32x4_t v10 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), v6), v9, _Q2);
  _Q1 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL), v6), (float32x4_t)v40, _Q2);
  float32x4_t v12 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q1, _Q1), (int8x16_t)_Q1, 0xCuLL), (float32x4_t)v40, _Q0, 3);
  _Q1.i32[0] = v40.i32[3];
  float32x4_t v13 = vmlaq_laneq_f32(v12, _Q0, (float32x4_t)v40, 3);
  __asm { FMLA            S2, S1, V0.S[3] }
  float32x4_t v36 = v13;
  __int32 v37 = _Q2.i32[0];
  v13.i32[3] = _Q2.i32[0];
  float32x4_t v38 = vaddq_f32(*a2, vaddq_f32(vaddq_f32((float32x4_t)v39, vmulq_laneq_f32(v9, _Q0, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL)));
  v41[0] = v38;
  v41[1] = v13;
  float32x4_t v35 = v13;
  uint64_t v18 = (void *)(*(uint64_t (**)(void *))(*a1 + 16))(a1);
  uint64_t result = (*(uint64_t (**)(void *))(*v18 + 24))(v18);
  if (result != 1)
  {
    if (result == 7)
    {
      uint64_t v20 = v18[4];
      if (v20)
      {
        uint64_t v21 = v18[5];
        uint64_t v22 = 240 * v20;
        do
        {
          uint64_t result = updateLocalPoses(v21, v41);
          v21 += 240;
          v22 -= 240;
        }
        while (v22);
      }
    }
    else
    {
      uint64_t v23 = a1[7];
      if ((*(unsigned int (**)(void *))(*v18 + 40))(v18))
      {
        uint64_t v24 = (*(uint64_t (**)(void *))(*v18 + 48))(v18);
        float32x4_t v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL);
        _Q2 = *(float32x4_t *)(v24 + 16);
        _Q4 = vnegq_f32(v36);
        float32x4_t v28 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)v24, *(int32x4_t *)v24), *(int8x16_t *)v24, 0xCuLL), _Q4), *(float32x4_t *)v24, v25);
        int32x4_t v29 = (int32x4_t)vaddq_f32(v28, v28);
        float32x4_t v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL);
        int32x4_t v31 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), _Q4), v30, v25);
        float32x4_t v32 = vaddq_f32(v38, vaddq_f32(vaddq_f32(*(float32x4_t *)v24, vmulq_laneq_f32(v30, v35, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL)));
        _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL), _Q4), _Q2, v25);
        float32x4_t v34 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), _Q2, v35, 3), v36, _Q2, 3);
        _Q4.i32[0] = v37;
        __asm { FMLA            S3, S4, V2.S[3] }
        v39.i64[0] = v34.i64[0];
        v39.i64[1] = __PAIR64__(_Q3.u32[0], v34.u32[2]);
        v40.i64[0] = v32.i64[0];
        v40.i32[2] = v32.i32[2];
      }
      else
      {
        v39.i64[0] = v36.i64[0];
        v39.i64[1] = __PAIR64__(v37, v36.u32[2]);
        v40.i64[0] = v38.i64[0];
        v40.i32[2] = v38.i32[2];
      }
      return (*(uint64_t (**)(uint64_t, int32x4_t *))(*(void *)v23 + 152))(v23, &v39);
    }
  }
  return result;
}

uint64_t re::PhysXCollisionObject::pxShape(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t v5 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v5 + 152))(&v23, v5);
  uint64_t v22 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v5 + 192))(v5, &v22, 1, a2);
  if (a3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v22 + 160))(&v16);
    float v6 = (float)(v25 * v25) + -0.5;
    float v7 = (float)((float)((float)(v20 + v20) * *((float *)&v23 + 1)) + (float)(*(float *)&v23 * (float)(v19 + v19)))
       + (float)(v24 * (float)(v21 + v21));
    float v8 = (float)((float)(v25
                       * (float)((float)(*(float *)&v23 * (float)(v20 + v20))
                               - (float)(*((float *)&v23 + 1) * (float)(v19 + v19))))
               + (float)((float)(v21 + v21) * v6))
       + (float)(v24 * v7);
    float v9 = v26
       + (float)((float)((float)(v25
                               * (float)((float)(*((float *)&v23 + 1) * (float)(v21 + v21))
                                       - (float)(v24 * (float)(v20 + v20))))
                       + (float)((float)(v19 + v19) * v6))
               + (float)(*(float *)&v23 * v7));
    float v10 = v27
        + (float)((float)((float)(v25
                                * (float)((float)(v24 * (float)(v19 + v19))
                                        - (float)(*(float *)&v23 * (float)(v21 + v21))))
                        + (float)((float)(v20 + v20) * v6))
                + (float)(*((float *)&v23 + 1) * v7));
    float v11 = (float)((float)((float)(*((float *)&v23 + 1) * v18) + (float)(v25 * *((float *)&v16 + 1)))
                + (float)(v24 * *(float *)&v16))
        - (float)(v17 * *(float *)&v23);
    float v12 = (float)((float)((float)(v24 * v18) + (float)(v25 * v17)) + (float)(*(float *)&v23 * *((float *)&v16 + 1)))
        - (float)(*(float *)&v16 * *((float *)&v23 + 1));
    float v13 = v28;
    float v14 = (float)((float)((float)(v25 * v18) - (float)(*(float *)&v23 * *(float *)&v16))
                - (float)(*((float *)&v23 + 1) * *((float *)&v16 + 1)))
        - (float)(v24 * v17);
    *a3 = (float)((float)((float)(*(float *)&v23 * v18) + (float)(v25 * *(float *)&v16))
                + (float)(*((float *)&v23 + 1) * v17))
        - (float)(*((float *)&v16 + 1) * v24);
    a3[1] = v11;
    a3[2] = v12;
    a3[3] = v14;
    a3[4] = v9;
    a3[5] = v10;
    a3[6] = v13 + v8;
  }
  return v22;
}

uint64_t re::PhysXCollisionObject::hasTriggerShapes(re::PhysXCollisionObject *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v1 + 184))(v1)) {
    return 1;
  }
  uint64_t v2 = 0;
  do
  {
    uint64_t v6 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v1 + 192))(v1, &v6, 1, v2);
    (*(void (**)(unsigned __int8 *__return_ptr))(*(void *)v6 + 312))(&v5);
    uint64_t v3 = (v5 >> 2) & 1;
    if ((v5 & 4) == 0) {
      break;
    }
    uint64_t v2 = (v2 + 1);
  }
  while (v2 < (*(unsigned int (**)(uint64_t))(*(void *)v1 + 184))(v1));
  return v3;
}

__n128 re::PhysXCollisionObject::setScaleInternal(uint64_t a1, float32x2_t *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(_WORD **)(a1 + 24);
  if ((*(unsigned int (**)(_WORD *))(*(void *)v4 + 184))(v4))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v15 = 0;
      (*(void (**)(_WORD *, uint64_t *, uint64_t, unint64_t))(*(void *)v4 + 192))(v4, &v15, 1, v6);
      switch((*(unsigned int (**)(uint64_t))(*(void *)v15 + 64))(v15))
      {
        case 0u:
          uint64_t v16 = 0;
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v15 + 96))(v15, &v16);
          unint64_t v8 = *(void *)(a1 + 112);
          if (v8 <= v6)
          {
            *(void *)uint64_t v22 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v17 = 136315906;
            *(void *)&long long v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            unint64_t v19 = v6;
            *(_WORD *)float v20 = 2048;
            *(void *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_23:
            uint64_t v16 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v17 = 136315906;
            *(void *)&long long v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            unint64_t v19 = v6;
            *(_WORD *)float v20 = 2048;
            *(void *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_24:
            uint64_t v16 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v17 = 136315906;
            *(void *)&long long v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            unint64_t v19 = v6;
            *(_WORD *)float v20 = 2048;
            *(void *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_25:
            uint64_t v16 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v22 = 136315906;
            *(void *)&v22[4] = "operator[]";
            *(_WORD *)&v22[12] = 1024;
            *(_DWORD *)&v22[14] = 468;
            __int16 v23 = 2048;
            unint64_t v24 = v6;
            __int16 v25 = 2048;
            unint64_t v26 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_26:
            uint64_t v16 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v22 = 136315906;
            *(void *)&v22[4] = "operator[]";
            *(_WORD *)&v22[12] = 1024;
            *(_DWORD *)&v22[14] = 468;
            __int16 v23 = 2048;
            unint64_t v24 = v6;
            __int16 v25 = 2048;
            unint64_t v26 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_27:
            re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Unsupported geometry type!", "!\"Unreachable code\"", "setScaleInternal", 238);
            _os_crash();
            __break(1u);
          }
          *((float *)&v16 + 1) = *(float *)(*(void *)(a1 + 120) + v5) * a2->f32[0];
          float v9 = *(void (**)(void))(*(void *)v15 + 72);
          break;
        case 1u:
          goto LABEL_16;
        case 2u:
          *(_DWORD *)&v22[8] = 0;
          *(void *)uint64_t v22 = 2;
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v15 + 104))(v15, v22);
          unint64_t v8 = *(void *)(a1 + 112);
          if (v8 <= v6) {
            goto LABEL_23;
          }
          *(int32x2_t *)&v22[4] = vrev64_s32((int32x2_t)vmul_n_f32(*(float32x2_t *)(*(void *)(a1 + 120) + v5), COERCE_FLOAT(*a2)));
          goto LABEL_10;
        case 3u:
          *(void *)uint64_t v22 = 3;
          *(void *)&v22[8] = 0;
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v15 + 88))(v15, v22);
          unint64_t v8 = *(void *)(a1 + 112);
          if (v8 <= v6) {
            goto LABEL_24;
          }
          float v10 = (float32x2_t *)(*(void *)(a1 + 120) + v5);
          float v11 = v10[1].f32[0] * a2[1].f32[0];
          *(float32x2_t *)&v22[4] = vmul_f32(*v10, *a2);
          *(float *)&v22[12] = v11;
LABEL_10:
          float v9 = *(void (**)(void))(*(void *)v15 + 72);
          break;
        case 4u:
          int v17 = 4;
          long long v18 = xmmword_2343679C0;
          unint64_t v19 = 0;
          *(_DWORD *)float v20 = 1065353216;
          *(void *)&v20[4] = 0;
          LOBYTE(v21) = 1;
          *(_WORD *)((char *)&v21 + 1) = 0;
          BYTE3(v21) = 0;
          (*(void (**)(uint64_t, int *))(*(void *)v15 + 120))(v15, &v17);
          unint64_t v8 = *(void *)(a1 + 112);
          if (v8 <= v6) {
            goto LABEL_25;
          }
          goto LABEL_14;
        case 5u:
          int v17 = 5;
          long long v18 = xmmword_2343679C0;
          unint64_t v19 = 0;
          *(void *)float v20 = 1065353216;
          uint64_t v21 = 0;
          (*(void (**)(uint64_t, int *))(*(void *)v15 + 128))(v15, &v17);
          unint64_t v8 = *(void *)(a1 + 112);
          if (v8 <= v6) {
            goto LABEL_26;
          }
LABEL_14:
          float v12 = (float32x2_t *)(*(void *)(a1 + 120) + v5);
          float v13 = v12[1].f32[0] * a2[1].f32[0];
          *(float32x2_t *)&long long v18 = vmul_f32(*v12, *a2);
          *((float *)&v18 + 2) = v13;
          float v9 = *(void (**)(void))(*(void *)v15 + 72);
          break;
        default:
          goto LABEL_27;
      }
      v9();
LABEL_16:
      if (v4[4] == 5
        && (*(uint64_t (**)(_WORD *))(*(void *)v4 + 56))(v4)
        && (*(unsigned int (**)(_WORD *))(*(void *)v4 + 512))(v4))
      {
        (*(void (**)(_WORD *))(*(void *)v4 + 592))(v4);
      }
      ++v6;
      v5 += 12;
    }
    while (v6 < (*(unsigned int (**)(_WORD *))(*(void *)v4 + 184))(v4));
  }
  __n128 result = *(__n128 *)a2->f32;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)a2->f32;
  return result;
}

uint64_t re::PhysXCollisionObject::scale(re::PhysXCollisionObject *this)
{
  return *((void *)this + 16);
}

void re::PhysXCollisionObject::logState(re::PhysXCollisionObject *this)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = (re *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  if (!v3)
  {
    uint64_t v58 = *re::collisionLogObjects(v3);
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v2;
    int32x4_t v55 = "%p (%p) - Actor type: static";
    int32x4_t v56 = v58;
    uint32_t v57 = 22;
    goto LABEL_46;
  }
  uint64_t v4 = (re *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  int v5 = (int)v4;
  unint64_t v6 = *re::collisionLogObjects(v4);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5 != 1)
  {
    if (!v7) {
      return;
    }
    int v59 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = this;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v59;
    int32x4_t v55 = "%p - Actor type: unknown! %d";
    int32x4_t v56 = v6;
    uint32_t v57 = 18;
    goto LABEL_46;
  }
  if (v7)
  {
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v2;
    _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, "%p (%p) - Actor type: dynamic", buf, 0x16u);
  }
  unint64_t v8 = *re::collisionLogObjects((re *)v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v2 + 432))(&v64, v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v64;
    _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "RB flags: %#010x", buf, 8u);
  }
  float v9 = (re *)(*(uint64_t (**)(uint64_t, long long *))(*(void *)v2 + 504))(v2, &v64);
  if (v9)
  {
    float v10 = *re::collisionLogObjects(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218496;
      *(double *)&uint8_t buf[4] = *(float *)&v65;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = *((float *)&v65 + 1);
      *(_WORD *)&buf[22] = 2048;
      double v68 = v66;
      _os_log_impl(&dword_233120000, v10, OS_LOG_TYPE_DEFAULT, "Kinematic target set to: %f, %f, %f", buf, 0x20u);
    }
  }
  float v11 = (re *)(*(void *(**)(unsigned char *__return_ptr, uint64_t))(*(void *)v2 + 152))(buf, v2);
  long long v64 = *(_OWORD *)buf;
  uint64_t v65 = *(void *)&buf[16];
  float v66 = *(float *)&v68;
  float v12 = *re::collisionLogObjects(v11);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&uint8_t buf[4] = *(float *)&v65;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v65 + 1);
    *(_WORD *)&buf[22] = 2048;
    double v68 = v66;
    _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Pose: %f, %f, %f", buf, 0x20u);
  }
  float v14 = *re::collisionLogObjects((re *)v13);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    double v16 = *((float *)this + 32);
    double v17 = *((float *)this + 33);
    double v18 = *((float *)this + 34);
    *(_DWORD *)buf = 134218496;
    *(double *)&uint8_t buf[4] = v16;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = v17;
    *(_WORD *)&buf[22] = 2048;
    double v68 = v18;
    _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Scale: %f, %f, %f", buf, 0x20u);
  }
  unint64_t v19 = *re::collisionLogObjects((re *)v15);
  BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
  if (v20)
  {
    int v21 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 512))(v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl(&dword_233120000, v19, OS_LOG_TYPE_DEFAULT, "Sleeping: %d", buf, 8u);
  }
  uint64_t v22 = *re::collisionLogObjects((re *)v20);
  BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (v23)
  {
    float v24 = (*(float (**)(uint64_t))(*(void *)v2 + 528))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v24;
    _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Sleep threshold: %f", buf, 0xCu);
  }
  __int16 v25 = *re::collisionLogObjects((re *)v23);
  BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
  if (v26)
  {
    float v27 = (*(float (**)(uint64_t))(*(void *)v2 + 584))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v27;
    _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_DEFAULT, "Wake counter: %f", buf, 0xCu);
  }
  long long v28 = *re::collisionLogObjects((re *)v26);
  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (v29)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v2 + 552))(&v62, v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v62;
    _os_log_impl(&dword_233120000, v28, OS_LOG_TYPE_DEFAULT, "Lock Flags %#010x", buf, 8u);
  }
  long long v30 = *re::collisionLogObjects((re *)v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    float v31 = (*(float (**)(uint64_t))(*(void *)v2 + 240))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v31;
    _os_log_impl(&dword_233120000, v30, OS_LOG_TYPE_DEFAULT, "Mass: %f", buf, 0xCu);
  }
  uint64_t v32 = (re *)(*(void *(**)(unsigned char *__return_ptr, uint64_t))(*(void *)v2 + 224))(buf, v2);
  long long v64 = *(_OWORD *)buf;
  uint64_t v65 = *(void *)&buf[16];
  float v66 = *(float *)&v68;
  unint64_t v33 = *re::collisionLogObjects(v32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219520;
    *(double *)&uint8_t buf[4] = *(float *)&v65;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v65 + 1);
    *(_WORD *)&buf[22] = 2048;
    double v68 = v66;
    __int16 v69 = 2048;
    double v70 = *(float *)&v64;
    __int16 v71 = 2048;
    double v72 = *((float *)&v64 + 1);
    __int16 v73 = 2048;
    double v74 = *((float *)&v64 + 2);
    __int16 v75 = 2048;
    double v76 = *((float *)&v64 + 3);
    _os_log_impl(&dword_233120000, v33, OS_LOG_TYPE_DEFAULT, "CMass local pose: %f, %f, %f, %f, %f, %f, %f", buf, 0x48u);
  }
  float32x4_t v34 = (re *)(*(void *(**)(uint64_t *__return_ptr, uint64_t))(*(void *)v2 + 264))(&v62, v2);
  float32x4_t v35 = *re::collisionLogObjects(v34);
  BOOL v36 = os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
  if (v36)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&uint8_t buf[4] = *(float *)&v62;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v62 + 1);
    *(_WORD *)&buf[22] = 2048;
    double v68 = v63;
    _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_DEFAULT, "MassSpace inertia tensor: %f, %f, %f", buf, 0x20u);
  }
  __int32 v37 = *re::collisionLogObjects((re *)v36);
  BOOL v38 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
  if (v38)
  {
    float v39 = (*(float (**)(uint64_t))(*(void *)v2 + 288))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v39;
    _os_log_impl(&dword_233120000, v37, OS_LOG_TYPE_DEFAULT, "Linear damping: %f", buf, 0xCu);
  }
  int32x4_t v40 = *re::collisionLogObjects((re *)v38);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    float v41 = (*(float (**)(uint64_t))(*(void *)v2 + 304))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v41;
    _os_log_impl(&dword_233120000, v40, OS_LOG_TYPE_DEFAULT, "Angular damping: %f", buf, 0xCu);
  }
  long long v42 = (re *)(*(void *(**)(uint64_t *__return_ptr, uint64_t))(*(void *)v2 + 312))(&v60, v2);
  long long v43 = *re::collisionLogObjects(v42);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&uint8_t buf[4] = *(float *)&v60;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v60 + 1);
    *(_WORD *)&buf[22] = 2048;
    double v68 = v61;
    _os_log_impl(&dword_233120000, v43, OS_LOG_TYPE_DEFAULT, "Linear velocity: %f, %f, %f", buf, 0x20u);
  }
  long long v44 = (re *)(*(void *(**)(unsigned char *__return_ptr, uint64_t))(*(void *)v2 + 328))(buf, v2);
  uint64_t v60 = *(void *)buf;
  float v61 = *(float *)&buf[8];
  long long v45 = *re::collisionLogObjects(v44);
  BOOL v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT);
  if (v46)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&uint8_t buf[4] = *(float *)&v60;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v60 + 1);
    *(_WORD *)&buf[22] = 2048;
    double v68 = v61;
    _os_log_impl(&dword_233120000, v45, OS_LOG_TYPE_DEFAULT, "Angular velocity: %f, %f, %f", buf, 0x20u);
  }
  int32x4_t v47 = *re::collisionLogObjects((re *)v46);
  BOOL v48 = os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
  if (v48)
  {
    float v49 = (*(float (**)(uint64_t))(*(void *)v2 + 352))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v49;
    _os_log_impl(&dword_233120000, v47, OS_LOG_TYPE_DEFAULT, "Max angular velocity: %f", buf, 0xCu);
  }
  float32x4_t v50 = *re::collisionLogObjects((re *)v48);
  BOOL v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
  if (v51)
  {
    float v52 = (*(float (**)(uint64_t))(*(void *)v2 + 368))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v52;
    _os_log_impl(&dword_233120000, v50, OS_LOG_TYPE_DEFAULT, "Max angular velocity: %f", buf, 0xCu);
  }
  char v53 = *re::collisionLogObjects((re *)v51);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    float v54 = (*(float (**)(uint64_t))(*(void *)v2 + 448))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&uint8_t buf[4] = v54;
    int32x4_t v55 = "Max CCD advance coefficient: %f";
    int32x4_t v56 = v53;
    uint32_t v57 = 12;
LABEL_46:
    _os_log_impl(&dword_233120000, v56, OS_LOG_TYPE_DEFAULT, v55, buf, v57);
  }
}

void *re::PhysXCollisionObject::internalLocalPose@<X0>(re::GeometricObject *a1@<X1>, uint64_t a2@<X8>)
{
  __n128 result = (void *)(*(uint64_t (**)(void))(**((void **)a1 + 8) + 24))(*((void *)a1 + 8));
  if (result == 7 || result == 1)
  {
    long long v7 = *((_OWORD *)a1 + 8);
    *(_OWORD *)a2 = *((_OWORD *)a1 + 7);
    *(_OWORD *)(a2 + 16) = v7;
  }
  else
  {
    (*(void (**)(void *__return_ptr))(**((void **)a1 + 7) + 160))(v8);
    return re::internal::nvphysx::fromPhysX((uint64_t)v8, (void *)a2);
  }
  return result;
}

uint64_t re::PhysXCollisionObject::isSleeping(re::PhysXCollisionObject *this)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    if (*(_WORD *)(result + 8) == 5) {
      return (*(uint64_t (**)(void))(*(void *)result + 512))();
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t re::PhysXCollisionObject::rayCastInternal(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, __n128 a5)
{
  uint64_t v8 = 0;
  uint64_t v50 = *MEMORY[0x263EF8340];
  a5.n128_u64[0] = 2139095039;
  do
  {
    float v9 = &v43[v8];
    *(void *)float v9 = 0;
    *((void *)v9 + 1) = 0;
    *((_DWORD *)v9 + 4) = -1;
    *((_WORD *)v9 + 10) = 0;
    *((void *)v9 + 4) = 0;
    *((void *)v9 + 5) = 0;
    *((void *)v9 + 3) = 0;
    *((void *)v9 + 6) = 2139095039;
    v8 += 64;
    *((_DWORD *)v9 + 14) = 0;
  }
  while (v8 != 2048);
  unsigned int v10 = *a3;
  if (v10 >= 3) {
    goto LABEL_18;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v11 + 184))(v11, a5);
  if (result)
  {
    uint64_t v13 = 0;
    __int16 v28 = (32 * v10) | 3;
    while (1)
    {
      uint64_t v29 = 0;
      (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v11 + 192))(v11, &v29, 1, v13);
      uint64_t v14 = v29;
      float v15 = *(float *)(a2 + 32);
      (*(void (**)(int *__return_ptr, uint64_t))(*(void *)v29 + 80))(&v45, v29);
      __int32 v37 = &v45;
      (*(void (**)(int **__return_ptr, uint64_t))(*(void *)v11 + 152))(&v37, v11);
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v14 + 160))(&v31, v14);
      float v16 = (float)(v39 * v39) + -0.5;
      float v17 = (float)((float)((float)(v35 + v35) * *((float *)&v37 + 1)) + (float)(*(float *)&v37 * (float)(v34 + v34)))
          + (float)(v38 * (float)(v36 + v36));
      v30[0] = (float)((float)((float)(*(float *)&v37 * v33) + (float)(v39 * *(float *)&v31))
                     + (float)(*((float *)&v37 + 1) * v32))
             - (float)(*((float *)&v31 + 1) * v38);
      v30[1] = (float)((float)((float)(*((float *)&v37 + 1) * v33) + (float)(v39 * *((float *)&v31 + 1)))
                     + (float)(v38 * *(float *)&v31))
             - (float)(v32 * *(float *)&v37);
      v30[2] = (float)((float)((float)(v38 * v33) + (float)(v39 * v32)) + (float)(*(float *)&v37 * *((float *)&v31 + 1)))
             - (float)(*(float *)&v31 * *((float *)&v37 + 1));
      void v30[3] = (float)((float)((float)(v39 * v33) - (float)(*(float *)&v37 * *(float *)&v31))
                     - (float)(*((float *)&v37 + 1) * *((float *)&v31 + 1)))
             - (float)(v38 * v32);
      v30[4] = v40
             + (float)((float)((float)(v39
                                     * (float)((float)(*((float *)&v37 + 1) * (float)(v36 + v36))
                                             - (float)(v38 * (float)(v35 + v35))))
                             + (float)((float)(v34 + v34) * v16))
                     + (float)(*(float *)&v37 * v17));
      v30[5] = v41
             + (float)((float)((float)(v39
                                     * (float)((float)(v38 * (float)(v34 + v34))
                                             - (float)(*(float *)&v37 * (float)(v36 + v36))))
                             + (float)((float)(v35 + v35) * v16))
                     + (float)(*((float *)&v37 + 1) * v17));
      v30[6] = v42
             + (float)((float)((float)(v39
                                     * (float)((float)(*(float *)&v37 * (float)(v35 + v35))
                                             - (float)(*((float *)&v37 + 1) * (float)(v34 + v34))))
                             + (float)((float)(v36 + v36) * v16))
                     + (float)(v38 * v17));
      double v18 = gRaycastMap[v45];
      LOWORD(v37) = v28;
      unsigned int v19 = ((uint64_t (*)(int *, float *, uint64_t, uint64_t, int **, uint64_t, unsigned char *, float))v18)(&v45, v30, a2, a2 + 16, &v37, 32, v43, v15);
      if (v19) {
        break;
      }
LABEL_15:
      uint64_t v13 = (v13 + 1);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 184))(v11);
      if (v13 >= result) {
        return result;
      }
    }
    uint64_t v20 = v19;
    int v21 = &v44;
    while (1)
    {
      uint64_t v22 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(a4);
      *(void *)uint64_t v22 = 0;
      *(_OWORD *)(v22 + 16) = 0u;
      *(_OWORD *)(v22 + 32) = 0u;
      *(_DWORD *)(v22 + 48) = 2139095039;
      *(void *)(v22 + 52) = 0xFFFFFFFF00000000;
      *(void *)(v22 + 64) = 0;
      uint64_t v24 = *(void *)(a4 + 40);
      if (!v24) {
        break;
      }
      unint64_t v25 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](a4, v24 - 1);
      *(float *)(v25 + 48) = *((float *)v21 + 4) / *(float *)(a2 + 32);
      *(void *)&long long v26 = *(v21 - 1);
      DWORD2(v26) = *(_DWORD *)v21;
      *(_OWORD *)(v25 + 16) = v26;
      *(void *)&long long v26 = *(uint64_t *)((char *)v21 + 4);
      DWORD2(v26) = *((_DWORD *)v21 + 3);
      *(_OWORD *)(v25 + 32) = v26;
      *(void *)unint64_t v25 = a1;
      *(_DWORD *)(v25 + 52) = v13;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 64))(v29) == 5)
      {
        long long v46 = xmmword_2343679C0;
        uint64_t v47 = 0;
        int v45 = 5;
        uint64_t v48 = 1065353216;
        uint64_t v49 = 0;
        (*(void (**)(uint64_t, int *))(*(void *)v29 + 128))(v29, &v45);
        if ((*(uint64_t (**)(uint64_t))(*(void *)v49 + 104))(v49)) {
          float v27 = (uint64_t *)((*(uint64_t (**)(uint64_t))(*(void *)v49 + 104))(v49)
        }
                          + 4 * *((unsigned int *)v21 - 4));
        else {
          float v27 = v21 - 2;
        }
        *(_DWORD *)(v25 + 56) = *(_DWORD *)v27;
        *(void *)(v25 + 64) = *(uint64_t *)((char *)v21 + 20);
      }
      v21 += 8;
      if (!--v20) {
        goto LABEL_15;
      }
    }
    re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
    _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  int v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

float re::PhysXSphereShape::radius(re::PhysXSphereShape *this)
{
  return *((float *)this + 6);
}

double re::PhysXSphereShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  long long v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((void *)&v18 + 1);
  uint64_t v19 = *a2;
  int v20 = *((_DWORD *)a2 + 2);
  v15.i64[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  double result = *(double *)v21;
  *(void *)&long long v17 = *(void *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXSphereShape::~PhysXSphereShape(re::PhysXSphereShape *this)
{
}

uint64_t re::SphereShape::type(re::SphereShape *this)
{
  return 2;
}

double re::PhysXBoxShape::extent(re::PhysXBoxShape *this, float32x4_t a2)
{
  a2.i64[0] = *((void *)this + 3);
  a2.i32[2] = *((_DWORD *)this + 8);
  a2.i64[0] = vaddq_f32(a2, a2).u64[0];
  return *(double *)a2.i64;
}

double re::PhysXBoxShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  long long v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((void *)&v18 + 1);
  uint64_t v19 = *a2;
  int v20 = *((_DWORD *)a2 + 2);
  v15.i64[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  double result = *(double *)v21;
  *(void *)&long long v17 = *(void *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXBoxShape::~PhysXBoxShape(re::PhysXBoxShape *this)
{
}

uint64_t re::PhysXSimulationEventCallback::onContact(uint64_t result, void *a2, uint64_t a3, unsigned int a4)
{
  if (!*(unsigned char *)(result + 24)) {
    return result;
  }
  uint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 8);
  unint64_t v9 = *(void *)(v8 + 40);
  unint64_t v10 = v9 + 1;
  if (v9 == -1)
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t v12 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v8, v11);
      re::DynamicArray<unsigned long>::deinit(v12 + 16);
      ++v11;
    }
    while (v11 != *(void *)(v8 + 40));
    *(void *)(v8 + 40) = v10;
  }
  else
  {
    if (v10 <= *(void *)(v8 + 8) << 8)
    {
      *(void *)(v8 + 40) = v10;
    }
    else
    {
      re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(*(uint64_t **)(result + 8), (v9 + 256) >> 8);
      unint64_t v9 = *(void *)(v8 + 40);
      *(void *)(v8 + 40) = v10;
      if (v9 == v10) {
        goto LABEL_11;
      }
    }
    do
    {
      uint64_t v14 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v8, v9);
      *(void *)(v14 + 48) = 0;
      *(_OWORD *)uint64_t v14 = 0u;
      *(_OWORD *)(v14 + 16) = 0u;
      *(_OWORD *)(v14 + 28) = 0u;
      ++v9;
    }
    while (v9 != *(void *)(v8 + 40));
  }
LABEL_11:
  ++*(_DWORD *)(v8 + 48);
  uint64_t v15 = *(void *)(v7 + 8);
  uint64_t v16 = *(void *)(v15 + 40);
  if (!v16) {
    goto LABEL_65;
  }
  double result = re::BucketArray<re::PhysXManifold,256ul>::operator[](v15, v16 - 1);
  uint64_t v17 = result;
  *(void *)double result = *(void *)(*a2 + 16);
  *(void *)(result + 8) = *(void *)(a2[1] + 16);
  unsigned int v18 = 0;
  if (a4)
  {
    uint64_t v19 = a4;
    int v20 = (unsigned __int8 *)(a3 + 44);
    do
    {
      int v21 = *v20;
      v20 += 64;
      v18 += v21;
      --v19;
    }
    while (v19);
  }
  unint64_t v22 = v18;
  unint64_t v23 = *(void *)(result + 32);
  if (v23 < v18)
  {
    if (*(void *)(result + 24) < (unint64_t)v18)
    {
      double result = (uint64_t)re::DynamicArray<physx::PxContactPairPoint>::setCapacity((void *)(result + 16), v18);
      unint64_t v23 = *(void *)(v17 + 32);
    }
    uint64_t v24 = v22 - v23;
    if (v22 > v23)
    {
      unint64_t v25 = (_DWORD *)(*(void *)(v17 + 48) + 48 * v23 + 44);
      do
      {
        *(v25 - 8) = 0;
        *(v25 - 4) = 0;
        *unint64_t v25 = 0;
        v25 += 12;
        --v24;
      }
      while (v24);
    }
    goto LABEL_23;
  }
  if (v23 > v18)
  {
LABEL_23:
    *(void *)(v17 + 32) = v22;
    ++*(_DWORD *)(v17 + 40);
  }
  if (a4 && v22)
  {
    uint64_t v26 = 0;
    unsigned int v27 = 0;
    uint64_t v28 = a4;
    while (1)
    {
      unsigned int v29 = v27;
      if (*(void *)(v17 + 32) <= (unint64_t)v27) {
        break;
      }
      uint64_t v30 = a3 + (v26 << 6);
      unsigned int v31 = *(unsigned __int8 *)(v30 + 44);
      if (*(unsigned char *)(v30 + 44))
      {
        float v32 = *(float32x2_t **)(v30 + 16);
        if (v32)
        {
          __int8 v33 = v32[5].i8[3];
          int v34 = v33;
          int v35 = v33 & 1;
          if ((v33 & 2) != 0) {
            unsigned int v36 = 64;
          }
          else {
            unsigned int v36 = 16;
          }
          if (v34 < 0) {
            unsigned int v36 = 32;
          }
        }
        else
        {
          int v35 = 0;
          unsigned int v36 = 0;
        }
        double result = *(unsigned __int8 *)(v30 + 45);
        if (*(unsigned char *)(v30 + 45))
        {
          unsigned int v37 = 0;
          int v38 = 0;
          int v39 = 0;
          unsigned int v40 = 0;
          uint64_t v41 = *(void *)(v17 + 48) + 48 * v29;
          float v42 = *(_OWORD **)(v30 + 24);
          uint64_t v43 = *(void *)(v30 + 32);
          uint64_t v44 = (int *)(v43 + 4 * v31);
          __int16 v45 = *(_WORD *)(a3 + (v26 << 6) + 48);
          do
          {
            if (v39)
            {
              unsigned int v46 = v32[5].u8[1];
              BOOL v47 = v46 >= v40;
              unsigned int v49 = v46 - v40;
              BOOL v48 = v49 != 0 && v47;
              LODWORD(v50) = v49 * v36;
              if (v48) {
                uint64_t v50 = v50;
              }
              else {
                uint64_t v50 = 0;
              }
              float v42 = (_OWORD *)((char *)v42 + v50);
              v32 += 6;
            }
            ++v39;
            unsigned int v40 = v32[5].u8[1];
            unsigned int v51 = v40;
            while (v51)
            {
              BOOL v52 = v38 == 0;
              BOOL v53 = v38 != 0;
              if (v52) {
                uint64_t v54 = 0;
              }
              else {
                uint64_t v54 = v36;
              }
              float v42 = (_OWORD *)((char *)v42 + v54);
              v44 += v53;
              uint64_t v55 = v41 + 48 * v37;
              *(_OWORD *)uint64_t v55 = *v42;
              float32x2_t v56 = v32[2];
              *(float32x2_t *)(v55 + 16) = v56;
              float v57 = v32[3].f32[0];
              *(float *)(v55 + 24) = v57;
              if ((v45 & 0x20) != 0)
              {
                if (v35) {
                  int v59 = *v44;
                }
                else {
                  int v59 = -1;
                }
                *(_DWORD *)(v41 + 48 * v37 + 28) = v59;
                int v58 = -1;
              }
              else
              {
                int v58 = -1;
                *(_DWORD *)(v41 + 48 * v37 + 28) = -1;
                if (v35) {
                  int v58 = *v44;
                }
              }
              *(_DWORD *)(v41 + 48 * v37 + 44) = v58;
              if ((v45 & 0x10) != 0)
              {
                float v62 = *(float *)(v43 + 4 * v37);
                float32x2_t v60 = vmul_n_f32(v56, v62);
                float v61 = v57 * v62;
              }
              else
              {
                float32x2_t v60 = 0;
                float v61 = 0.0;
              }
              float v63 = (float32x2_t *)(v41 + 48 * v37);
              v63[4] = v60;
              v63[5].f32[0] = v61;
              ++v37;
              --v51;
              int v38 = 1;
              if (v31 == v37) {
                goto LABEL_62;
              }
            }
          }
          while (v39 != result);
        }
      }
LABEL_62:
      unsigned int v27 = v29 + v31;
      if (++v26 == v28) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_65:
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return result;
}

void re::PhysXSimulationEventCallback::onTrigger(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    unsigned int v7 = *(_DWORD *)(v6 + 28) + a3;
    if (*(_DWORD *)(v6 + 24) < v7) {
      re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(v6, v7);
    }
    if (a3)
    {
      uint64_t v8 = 0;
      uint64_t v9 = a3;
      do
      {
        uint64_t v10 = a2 + 40 * v8;
        unint64_t v11 = *(void *)(*(void *)(v10 + 24) + 16);
        uint64_t v12 = *(void *)(*(void *)(v10 + 8) + 16);
        *(void *)&long long v37 = v11;
        *((void *)&v37 + 1) = v12;
        LOBYTE(v38) = 0;
        if ((*(unsigned char *)(v10 + 32) & 0x10) != 0)
        {
          uint64_t v23 = *(void *)(a1 + 16);
          if ((*(unsigned char *)(a2 + 40 * v8 + 36) & 3) != 0)
          {
            re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove(v23, (uint64_t *)&v37);
          }
          else
          {
            unint64_t v30 = *(unsigned int *)(v23 + 24);
            if (v30)
            {
              uint64_t v31 = *(unsigned int *)(*(void *)(v23 + 8)
                                    + 4 * ((((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + v12) ^ v11) % v30));
              if (v31 != 0x7FFFFFFF)
              {
                uint64_t v32 = *(void *)(v23 + 16);
                while (1)
                {
                  uint64_t v33 = v32 + 40 * v31;
                  uint64_t v36 = *(void *)(v33 + 16);
                  uint64_t v34 = v33 + 16;
                  uint64_t v35 = v36;
                  if (v36 == v11 && *(void *)(v34 + 8) == v12) {
                    break;
                  }
                  if (v35 == v12 && *(void *)(v34 + 8) == v11) {
                    break;
                  }
                  uint64_t v31 = *(_DWORD *)(v32 + 40 * v31 + 8) & 0x7FFFFFFF;
                  if (v31 == 0x7FFFFFFF) {
                    goto LABEL_25;
                  }
                }
                *(unsigned char *)(v32 + 40 * v31 + 32) = 2;
              }
            }
          }
          goto LABEL_25;
        }
        uint64_t v13 = *(void *)(a1 + 16);
        unint64_t v14 = ((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + v12) ^ v11;
        unint64_t v15 = *(unsigned int *)(v13 + 24);
        if (v15)
        {
          unint64_t v16 = v14 % v15;
          uint64_t v17 = *(unsigned int *)(*(void *)(v13 + 8) + 4 * (v14 % v15));
          if (v17 != 0x7FFFFFFF)
          {
            uint64_t v18 = *(void *)(v13 + 16);
            do
            {
              uint64_t v19 = v18 + 40 * v17;
              uint64_t v22 = *(void *)(v19 + 16);
              uint64_t v20 = v19 + 16;
              uint64_t v21 = v22;
              if (v22 == v11 && *(void *)(v20 + 8) == v12) {
                goto LABEL_25;
              }
              if (v21 == v12 && *(void *)(v20 + 8) == v11) {
                goto LABEL_25;
              }
              uint64_t v17 = *(_DWORD *)(v18 + 40 * v17 + 8) & 0x7FFFFFFF;
            }
            while (v17 != 0x7FFFFFFF);
          }
        }
        else
        {
          unint64_t v16 = 0;
        }
        uint64_t v24 = *(unsigned int *)(v13 + 36);
        if (v24 == 0x7FFFFFFF)
        {
          uint64_t v24 = *(unsigned int *)(v13 + 32);
          int v25 = v24;
          if (v24 == v15)
          {
            re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(*(void *)(a1 + 16), 2 * *(_DWORD *)(v13 + 28));
            unint64_t v16 = v14 % *(unsigned int *)(v13 + 24);
            int v25 = *(_DWORD *)(v13 + 32);
          }
          *(_DWORD *)(v13 + 32) = v25 + 1;
          uint64_t v26 = *(void *)(v13 + 16);
          int v27 = *(_DWORD *)(v26 + 40 * v24 + 8);
        }
        else
        {
          uint64_t v26 = *(void *)(v13 + 16);
          int v27 = *(_DWORD *)(v26 + 40 * v24 + 8);
          *(_DWORD *)(v13 + 36) = v27 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v26 + 40 * v24 + 8) = v27 | 0x80000000;
        *(_DWORD *)(*(void *)(v13 + 16) + 40 * v24 + 8) = *(_DWORD *)(*(void *)(v13 + 16) + 40 * v24 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v13 + 8) + 4 * v16);
        *(void *)(*(void *)(v13 + 16) + 40 * v24) = v14;
        uint64_t v28 = *(void *)(v13 + 16) + 40 * v24;
        long long v29 = v37;
        *(void *)(v28 + 32) = v38;
        *(_OWORD *)(v28 + 16) = v29;
        *(_DWORD *)(*(void *)(v13 + 8) + 4 * v16) = v24;
        ++*(_DWORD *)(v13 + 28);
        ++*(_DWORD *)(v13 + 40);
LABEL_25:
        ++v8;
      }
      while (v8 != v9);
    }
  }
}

void re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::init((uint64_t)v25, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v25;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)int v25 = v5;
      *(void *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        unint64_t v14 = (long long *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v14 - 2) & 0x80000000) != 0)
          {
            unint64_t v15 = *((void *)v14 - 2);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 40 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 40 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 40 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 40 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 40 * v18) = v15;
            uint64_t v22 = *(void *)(a1 + 16) + 40 * v18;
            long long v23 = *v14;
            *(void *)(v22 + 32) = *((void *)v14 + 2);
            *(_OWORD *)(v22 + 16) = v23;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          unint64_t v14 = (long long *)((char *)v14 + 40);
        }
        while (v11 < v10);
      }
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

void re::PhysXSimulationEventCallback::~PhysXSimulationEventCallback(re::PhysXSimulationEventCallback *this)
{
}

void *re::DynamicArray<physx::PxContactPairPoint>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v4)
      {
        double result = (void *)re::DynamicArray<physx::PxContactPairPoint>::setCapacity(v4, a2);
        ++*((_DWORD *)v4 + 6);
        return result;
      }
      if (a2)
      {
        double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 4);
        if (!result)
        {
          re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 48 * a2, *(void *)(*v4 + 8));
          double result = (void *)_os_crash();
          __break(1u);
          return result;
        }
        uint64_t v6 = result;
        if (!v4[1]) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v6 = 0;
        if (!v2)
        {
LABEL_14:
          v4[4] = v6;
          v4[1] = a2;
          return result;
        }
      }
      uint64_t v7 = v4[4];
      uint64_t v8 = v4[2];
      if (v8)
      {
        uint64_t v9 = v7 + 48 * v8;
        unint64_t v10 = v6;
        uint64_t v11 = v4[4];
        do
        {
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v11;
          v10[2] = *(void *)(v11 + 16);
          *((_DWORD *)v10 + 6) = *(_DWORD *)(v11 + 24);
          *((_DWORD *)v10 + 7) = *(_DWORD *)(v11 + 28);
          v10[4] = *(void *)(v11 + 32);
          *((_DWORD *)v10 + 10) = *(_DWORD *)(v11 + 40);
          *((_DWORD *)v10 + 11) = *(_DWORD *)(v11 + 44);
          v11 += 48;
          v10 += 6;
        }
        while (v11 != v9);
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 40))(*v4, v7);
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t re::CollisionFactory::createGeometricObject(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5)
{
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 240, 16);
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 160) = 0u;
  *(_OWORD *)(v9 + 176) = 0u;
  *(_OWORD *)(v9 + 192) = 0u;
  *(_OWORD *)(v9 + 208) = 0u;
  *(_OWORD *)(v9 + 224) = 0u;
  *(_OWORD *)(v9 + 144) = 0u;
  *(void *)(v9 + 32) = 0;
  *(void *)(v9 + 40) = 0x3F80000000000000;
  *(void *)uint64_t v9 = &unk_26E6DD0A8;
  *(void *)(v9 + 96) = 0;
  *(void *)(v9 + 104) = 0x3F80000000000000;
  *(void *)(v9 + 128) = 0;
  *(void *)(v9 + 136) = 0x3F80000000000000;
  *(void *)(v9 + 144) = 0;
  *(_DWORD *)(v9 + 168) = 0;
  *(void *)(v9 + 152) = 0;
  *(void *)(v9 + 160) = 0;
  *(_DWORD *)(v9 + 208) = 0;
  *(_OWORD *)(v9 + 176) = 0u;
  *(_OWORD *)(v9 + 192) = 0u;
  long long v10 = a4[1];
  *(_OWORD *)(v9 + 16) = *a4;
  *(_OWORD *)(v9 + 32) = v10;
  *(void *)(v9 + 64) = a3;
  long long v11 = a4[1];
  *(_OWORD *)(v9 + 112) = *a4;
  *(_OWORD *)(v9 + 128) = v11;
  *(void *)(v9 + 144) = a2;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)(v9 + 144), 0);
  ++*(_DWORD *)(v9 + 168);
  *(void *)(v9 + 232) = a5;
  return v9;
}

uint64_t re::CollisionFactory::deepCopyShape(re::CollisionFactory *this, re::Allocator *a2, const re::CollisionShape *a3)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  switch((*(unsigned int (**)(const re::CollisionShape *))(*(void *)a3 + 24))(a3))
  {
    case 0u:
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "deepCopyShape", 45);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2335CD944);
    case 1u:
      uint64_t v8 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *))(*(void *)this + 96);
      uint64_t v9 = this;
      long long v10 = a2;
      return v8(v9, v10);
    case 2u:
      (*(void (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      uint64_t v8 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *))(*(void *)this + 112);
      uint64_t v9 = this;
      long long v10 = a2;
      return v8(v9, v10);
    case 3u:
      *(void *)&long long v55 = (*(uint64_t (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      *((void *)&v55 + 1) = v12;
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, long long *))(*(void *)this + 32))(this, a2, &v55);
    case 4u:
      float v14 = (*(float (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(void *)a3 + 72))(a3);
      unint64_t v15 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, __n128, __n128))(*(void *)this + 40);
      v16.n128_u32[0] = v19.n128_u32[0];
      unint64_t v17 = this;
      uint64_t v18 = a2;
      v19.n128_f32[0] = v14;
      return v15(v17, v18, v19, v16);
    case 5u:
      uint64_t v20 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *))(*(void *)this + 80);
      int v21 = this;
      uint64_t v22 = a2;
      long long v23 = a3;
      return v20(v21, v22, v23);
    case 6u:
      uint64_t v24 = (*(uint64_t (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(void *)a3 + 72))(a3);
      uint64_t v20 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *))(*(void *)this + 104);
      int v21 = this;
      uint64_t v22 = a2;
      long long v23 = (const re::CollisionShape *)v24;
      return v20(v21, v22, v23);
    case 7u:
      unint64_t v25 = *((void *)a3 + 4);
      uint64_t v26 = *((void *)a3 + 5);
      uint64_t v43 = 0;
      unint64_t v44 = 0;
      uint64_t v45 = 0;
      re::FixedArray<unsigned long>::init<>(&v43, (uint64_t)a2, v25);
      uint64_t v40 = 0;
      unint64_t v41 = 0;
      uint64_t v42 = 0;
      re::FixedArray<re::Pose<float>>::init<>(&v40, (uint64_t)a2, v25);
      if (v25)
      {
        uint64_t v27 = 0;
        unint64_t v28 = 0;
        long long v29 = (const re::CollisionShape **)(v26 + 112);
        do
        {
          uint64_t v30 = re::CollisionFactory::deepCopyShape(this, a2, *(v29 - 6));
          unint64_t v31 = v44;
          if (v44 <= v28)
          {
            uint64_t v46 = 0;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v57 = 0u;
            long long v55 = 0u;
            long long v56 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v47 = 136315906;
            BOOL v48 = "operator[]";
            __int16 v49 = 1024;
            int v50 = 468;
            __int16 v51 = 2048;
            unint64_t v52 = v28;
            __int16 v53 = 2048;
            unint64_t v54 = v31;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_44:
            uint64_t v46 = 0;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v57 = 0u;
            long long v55 = 0u;
            long long v56 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v47 = 136315906;
            BOOL v48 = "operator[]";
            __int16 v49 = 1024;
            int v50 = 468;
            __int16 v51 = 2048;
            unint64_t v52 = v28;
            __int16 v53 = 2048;
            unint64_t v54 = v31;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          *(void *)(v45 + 8 * v28) = v30;
          unint64_t v31 = v41;
          if (v41 <= v28) {
            goto LABEL_44;
          }
          uint64_t v32 = v42;
          uint64_t v33 = (_OWORD *)(v42 + v27);
          long long v34 = *(_OWORD *)v29;
          long long v35 = *((_OWORD *)v29 + 1);
          v29 += 30;
          *uint64_t v33 = v34;
          v33[1] = v35;
          ++v28;
          v27 += 32;
        }
        while (v25 != v28);
      }
      else
      {
        uint64_t v32 = v42;
      }
      uint64_t v38 = v45;
      uint64_t v39 = (*(uint64_t (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      uint64_t v7 = (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, uint64_t, uint64_t, unint64_t, uint64_t, re::Allocator *))(*(void *)this + 160))(this, a2, v38, v32, v25, v39, a2);
      if (v40 && v41) {
        (*(void (**)(void))(*(void *)v40 + 40))();
      }
      if (v43 && v44) {
        (*(void (**)(void))(*(void *)v43 + 40))();
      }
      return v7;
    case 8u:
      float v36 = (*(float (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(void *)a3 + 72))(a3);
      unint64_t v15 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, __n128, __n128))(*(void *)this + 128);
      v16.n128_u32[0] = v19.n128_u32[0];
      unint64_t v17 = this;
      uint64_t v18 = a2;
      v19.n128_f32[0] = v36;
      return v15(v17, v18, v19, v16);
    case 9u:
      float v37 = (*(float (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(void *)a3 + 72))(a3);
      unint64_t v15 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, __n128, __n128))(*(void *)this + 120);
      v16.n128_u32[0] = v19.n128_u32[0];
      unint64_t v17 = this;
      uint64_t v18 = a2;
      v19.n128_f32[0] = v37;
      return v15(v17, v18, v19, v16);
    case 0xBu:
      *(void *)&long long v55 = (*(uint64_t (**)(const re::CollisionShape *))(*(void *)a3 + 64))(a3);
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, long long *))(*(void *)this + 136))(this, a2, &v55);
    case 0xCu:
      long long v23 = (const re::CollisionShape *)*((void *)a3 + 3);
      uint64_t v20 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *))(*(void *)this + 144);
      int v21 = this;
      uint64_t v22 = a2;
      return v20(v21, v22, v23);
    default:
      return v7;
  }
}

double re::PhysXTriangleMeshShape::PhysXTriangleMeshShape(re::PhysXTriangleMeshShape *this, const re::IndexedTriangleMesh *a2, float a3)
{
  *((float *)this + 4) = a3;
  *((void *)this + 3) = a2;
  *(void *)this = &unk_26E6DE1E0;
  *((void *)this + 1) = (char *)this + 32;
  if (a2) {
    uint64_t v3 = *((void *)a2 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  *((_DWORD *)this + 8) = 5;
  double result = 0.00781250185;
  *(_OWORD *)((char *)this + 36) = xmmword_2343679C0;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *(void *)((char *)this + 60) = 1065353216;
  *((void *)this + 9) = v3;
  return result;
}

void re::PhysXTriangleMeshShape::aabb(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, int32x4_t *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  if (*(void *)(a1 + 72))
  {
    long long v18 = *((_OWORD *)a2 + 1);
    v15.i64[1] = *((void *)&v18 + 1);
    uint64_t v19 = *a2;
    int v20 = *((_DWORD *)a2 + 2);
    v15.i64[0] = 0;
    a8.i32[0] = 1.0;
    physx::Gu::computeBounds((float32x2_t *)v21, a1 + 32, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
    int32x4_t v16 = *(int32x4_t *)v21;
    v17.i64[0] = *(void *)&v21[12];
    v17.i32[2] = v22;
  }
  else
  {
    int32x4_t v16 = vdupq_n_s32(0x7F800000u);
    v17.i64[0] = 0x7F0000007FLL;
    v17.i64[1] = 0x7F0000007FLL;
  }
  *a7 = v16;
  a7[1] = v17;
}

uint64_t re::PhysXTriangleMeshShape::vertices(re::PhysXTriangleMeshShape *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 9) + 56))();
}

uint64_t re::PhysXTriangleMeshShape::vertexStride(re::PhysXTriangleMeshShape *this)
{
  return 12;
}

uint64_t re::PhysXTriangleMeshShape::vertexCount(re::PhysXTriangleMeshShape *this)
{
  return (*(unsigned int (**)(void))(**((void **)this + 9) + 48))(*((void *)this + 9));
}

uint64_t re::PhysXTriangleMeshShape::indexFormat(re::PhysXTriangleMeshShape *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 9) + 96))(&var1);
  if ((var1 & 2) != 0) {
    return 1;
  }
  else {
    return 2;
  }
}

uint64_t re::PhysXTriangleMeshShape::indexCount(re::PhysXTriangleMeshShape *this)
{
  return 3 * (*(unsigned int (**)(void))(**((void **)this + 9) + 80))(*((void *)this + 9));
}

uint64_t re::PhysXTriangleMeshShape::indices(re::PhysXTriangleMeshShape *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 9) + 88))();
}

void re::PhysXTriangleMeshShape::~PhysXTriangleMeshShape(re::PhysXTriangleMeshShape *this)
{
}

uint64_t re::CollisionObject::CollisionObject(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v9[4] = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26E6DE278;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a6;
  *(_OWORD *)(a1 + 32) = xmmword_23437C6B0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = a3;
  *(void *)(a1 + 96) = a5;
  if ((a2 & 1) == 0)
  {
    uint64_t v7 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 48))(a4);
    v9[0] = a1;
    v9[1] = re::CollisionObject::poseDidChange;
    v9[2] = 0;
    v9[3] = re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(v7, (uint64_t)v9);
  }
  return a1;
}

uint64_t re::CollisionObject::poseDidChange(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

void re::CollisionObject::~CollisionObject(re::CollisionObject *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26E6DE278;
  if ((*((unsigned char *)this + 8) & 1) == 0)
  {
    uint64_t v2 = *((void *)this + 2);
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *(void *)&long long v6 = this;
    *((void *)&v6 + 1) = re::CollisionObject::poseDidChange;
    uint64_t v7 = 0;
    uint64_t v8 = re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::GeometricObjectBase>::removeSubscription(v3, &v6);
    uint64_t v4 = *((void *)this + 12);
    (**(void (***)(uint64_t))v2)(v2);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v2);
  }
  if (*((unsigned char *)this + 64))
  {
    uint64_t v5 = *((void *)this + 9);
    if (v5)
    {

      *((void *)this + 9) = 0;
    }
  }
}

uint64_t re::CollisionObject::setScale(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v3 = *a2;
  v3.i32[3] = 0;
  int8x16_t v4 = (int8x16_t)vmaxnmq_f32(v3, (float32x4_t)xmmword_23437C6C0);
  int8x16_t v13 = v4;
  if ((*(unsigned char *)(a1 + 8) & 2) != 0)
  {
    v5.i32[1] = v4.i32[1];
    v5.i32[0] = vextq_s8(v4, v4, 8uLL).u32[0];
  }
  else
  {
    int32x4_t v5 = vdupq_lane_s32(*(int32x2_t *)v4.i8, 0);
    int8x16_t v13 = (int8x16_t)v5;
  }
  uint64_t v6 = v5.i64[0];
  float v10 = *(float *)v4.i32;
  if (*(float *)v4.i32 <= 0.00001 || *(float *)&v5.i32[1] <= 0.00001 || *(float *)v5.i32 <= 0.00001)
  {
    uint64_t v7 = *re::collisionLogObjects((re *)a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v7, OS_LOG_TYPE_DEFAULT, "Collider scale, 0 or negative is not supported. Setting scale to epsilon value.", buf, 2u);
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  *(void *)buf = result;
  uint64_t v12 = v9;
  if (v10 != *(float *)&result
    && vabds_f32(*(float *)&result, v10) >= (float)((float)((float)(fabsf(v10) + fabsf(*(float *)&result)) + 1.0)
                                                  * 0.0001)
    || *((float *)&v6 + 1) != *((float *)&result + 1)
    && vabds_f32(*((float *)&result + 1), *((float *)&v6 + 1)) >= (float)((float)((float)(fabsf(*((float *)&v6 + 1))
                                                                                        + fabsf(*((float *)&result + 1)))
                                                                                + 1.0)
                                                                        * 0.0001)
    || *(float *)&v6 != *(float *)&v9
    && vabds_f32(*(float *)&v9, *(float *)&v6) >= (float)((float)((float)(fabsf(*(float *)&v6) + fabsf(*(float *)&v9))
                                                                + 1.0)
                                                        * 0.0001))
  {
    (*(void (**)(uint64_t, int8x16_t *))(*(void *)a1 + 72))(a1, &v13);
    return (*(uint64_t (**)(void, uint8_t *, int8x16_t *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), buf, &v13);
  }
  return result;
}

unint64_t re::CollisionObject::rayCast(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t result = re::BucketArray<re::CollisionCastHit,10ul>::clear(a4);
  unint64_t v9 = *(void *)(a3 + 4);
  unint64_t v10 = a1[4];
  unint64_t v11 = v10 & HIDWORD(v9);
  unint64_t v12 = v9 & HIDWORD(v10);
  if (v11) {
    BOOL v13 = v12 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    float v14 = *(uint64_t (**)(void *, uint64_t, uint64_t, unint64_t))(*a1 + 88);
    return v14(a1, a2, a3, a4);
  }
  return result;
}

id re::CollisionObject::weakPointer@<X0>(re::CollisionObject *this@<X0>, id *a2@<X8>)
{
  int8x16_t v4 = (char *)this + 64;
  if (!*((unsigned char *)this + 64))
  {
    uint64_t v8 = this;
    re::make::shared::object<re::CollisionObject::Shareable,re::CollisionObject*>((re *)&v8, &v9);
    v10[0] = 1;
    unint64_t v11 = v9;
    unint64_t v9 = 0;
    re::Optional<re::SharedPtr<re::CollisionObject::Shareable>>::operator=((uint64_t)v4, v10);
    if (v10[0] && v11)
    {

      unint64_t v11 = 0;
    }
    if (v9) {
  }
    }
  uint64_t v5 = *((void *)this + 9);
  if (v5) {
    uint64_t v6 = (void *)(v5 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  return objc_initWeak(a2, v6);
}

uint64_t re::Optional<re::SharedPtr<re::CollisionObject::Shareable>>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (*(unsigned char *)a1) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v3 == 0;
  }
  if (!v4)
  {
    if (*(unsigned char *)a1) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {

        *(void *)(a1 + 8) = 0;
      }
      *(unsigned char *)a1 = 0;
    }
    else
    {
      if (*(unsigned char *)a1) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v3 == 0;
      }
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *((void *)a2 + 1);
        *((void *)a2 + 1) = v7;
      }
      else
      {
        *(unsigned char *)a1 = 1;
        *(void *)(a1 + 8) = *((void *)a2 + 1);
        *((void *)a2 + 1) = 0;
      }
    }
  }
  return a1;
}

uint64_t re::CollisionObject::setRawCollisionObject(uint64_t this, void *a2)
{
  *(void *)(this + 24) = a2;
  return this;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  int v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  BOOL v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    int v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

void re::make::shared::object<re::CollisionObject::Shareable,re::CollisionObject*>(re *a1@<X0>, _anonymous_namespace_ **a2@<X8>)
{
  uint64_t v4 = re::globalAllocators(a1);
  BOOL v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 32, 8);
  uint64_t v6 = *(void *)a1;
  ArcSharedObject::ArcSharedObject(v5, 0);
  *((void *)v5 + 3) = v6;
  *(void *)BOOL v5 = &unk_26E6DE2F8;
  *a2 = v5;
}

void re::CollisionObject::Shareable::~Shareable(re::CollisionObject::Shareable *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

float re::SphereShape::massProperties(uint64_t a1, float *a2, void *a3, uint64_t a4)
{
  float v7 = (*(float (**)(uint64_t))(*(void *)a1 + 64))(a1);
  float v8 = v7 * v7;
  float v9 = v7 * (float)((float)(v7 * v7) * 4.1888);
  *a2 = v9;
  *(void *)(a4 + 4) = 0;
  float result = v8 * (float)(v9 * 0.4);
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  *(float *)a4 = result;
  *(float *)(a4 + 20) = result;
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void re::basicLocalWallTime(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v13 = [MEMORY[0x263EFF910] date];
  id v5 = objc_alloc_init(MEMORY[0x263F08790]);
  uint64_t v6 = [MEMORY[0x263EFFA18] localTimeZone];
  [v5 setTimeZone:v6];

  float v7 = [NSString stringWithUTF8String:this];
  [v5 setDateFormat:v7];

  float v8 = NSString;
  float v9 = [v5 stringFromDate:v13];
  unint64_t v10 = [v8 stringWithFormat:@"%@", v9];

  id v11 = v10;
  unint64_t v12 = (_anonymous_namespace_ *)[v11 UTF8String];
}

void re::WrappedError::make(re::WrappedError *this@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  id v6 = [MEMORY[0x263F087E8] errorWithDomain:this code:a2 userInfo:a3];
  *a4 = v6;
}

{
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  void v12[2];

  v12[1] = *MEMORY[0x263EF8340];
  id v11 = *MEMORY[0x263F08320];
  float v8 = [NSString stringWithCString:a3 encoding:4];
  v12[0] = v8;
  float v9 = [NSDictionary dictionaryWithObjects:v12 forKeys:&v11 count:1];

  unint64_t v10 = [MEMORY[0x263F087E8] errorWithDomain:this code:a2 userInfo:v9];
  *a4 = v10;
}

void re::WrappedError::make(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, id *a4@<X3>, void *a5@<X8>)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  v14[0] = *MEMORY[0x263F08320];
  float v9 = [NSString stringWithCString:a3 encoding:4];
  v14[1] = *MEMORY[0x263F08608];
  float32x4_t v15 = v9;
  id v16 = *a4;
  unint64_t v10 = NSDictionary;
  id v11 = v16;
  unint64_t v12 = [v10 dictionaryWithObjects:&v15 forKeys:v14 count:2];

  id v13 = [MEMORY[0x263F087E8] errorWithDomain:a1 code:a2 userInfo:v12];
  *a5 = v13;
}

uint64_t re::WrappedError::localizedDescription(id *this)
{
  id v1 = [*this localizedDescription];
  uint64_t v2 = [v1 UTF8String];

  return v2;
}

CFErrorDomain re::WrappedError::domain(id *this)
{
  id v1 = (__CFError *)*this;
  return CFErrorGetDomain(v1);
}

void re::formattedErrorMessage<re::DetailedError>(uint64_t a1@<X0>, re::DynamicString *a2@<X8>)
{
  std::error_code::message(&v6, (const std::error_code *)a1);
  if ((v6.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v6;
  }
  else {
    uint64_t v4 = (std::string *)v6.__r_.__value_.__r.__words[0];
  }
  if (*(void *)(a1 + 24)) {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v5 = a1 + 25;
  }
  re::DynamicString::format((re::DynamicString *)"%s. %s", a2, v4, v5);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void re::runInLocalAutoreleasePool(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x237DBDCF0]();
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  else
  {
    uint64_t v4 = (re::StackScratchAllocator *)std::__throw_bad_function_call[abi:nn180100]();
    re::StackScratchAllocator::FreePersistentBlocks(v4);
  }
}

void re::StackScratchAllocator::FreePersistentBlocks(re::StackScratchAllocator *this)
{
  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
  {
    for (unint64_t i = 0; i < v7; ++i)
    {
      uint64_t v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      uint64_t v5 = *(void *)(v4 + 8);
      if (v5)
      {
        std::string v6 = re::globalAllocators(v1);
        id v1 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6[2] + 40))(v6[2], v5);
        uint64_t v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      }
      *(void *)(v4 + 8) = 0;
      unint64_t v7 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
    }
  }
  atomic_store(0, &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
  std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
}

re::StackScratchAllocator *re::StackScratchAllocator::StackScratchAllocator(re::StackScratchAllocator *this)
{
  *((unsigned char *)this + 16) = 0;
  *(void *)this = &unk_26E6DE358;
  *((void *)this + 1) = "Thread-local Scratch Allocator";
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(void *)((char *)this + 108) = 0x7FFFFFFFLL;
  {
    unint64_t v7 = (void *)re::StackScratchAllocator::StackScratchAllocator(void)::root(&re::StackScratchAllocator::StackScratchAllocator(void)::root);
    _tlv_atexit((void (__cdecl *)(void *))re::StackScratchAllocator::Root::~Root, v7);
  }
  uint64_t v3 = (uint64_t *)re::StackScratchAllocator::StackScratchAllocator(void)::root(&re::StackScratchAllocator::StackScratchAllocator(void)::root);
  uint64_t v4 = *v3;
  if (*v3)
  {
    *((void *)this + 6) = v4;
    *(_OWORD *)((char *)this + 24) = *(_OWORD *)(v4 + 24);
    uint64_t v5 = v3[1];
  }
  else
  {
    uint64_t v5 = v3[1];
    if (!v5) {
      goto LABEL_6;
    }
    uint64_t v8 = v5 + *(void *)(v5 + 8);
    *((void *)this + 3) = v5 + 16;
    *((void *)this + 4) = v8;
  }
  *((void *)this + 5) = v5;
LABEL_6:
  *uint64_t v3 = (uint64_t)this;
  *((void *)this + 7) = v3;
  return this;
}

void re::StackScratchAllocator::Root::~Root(re::StackScratchAllocator::Root *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = re::globalAllocators(this);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3[2] + 40))(v3[2], v2);
    std::mutex::lock(&re::StackScratchAllocator::s_mutex);
    uint64_t v5 = (atomic_ullong *)&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount;
    if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
    {
      unint64_t v7 = 0;
      uint64_t v8 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks;
      while (*((re::StackScratchAllocator::Root **)&re::StackScratchAllocator::s_rootsWithPersistentBlocks + v7) != this)
      {
        ++v7;
        unint64_t v9 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
        if (v7 >= v9) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Can't find allocated block", "!\"Unreachable code\"", "~Root", 190);
      _os_crash();
      __break(1u);
    }
    atomic_fetch_add(v5, 0xFFFFFFFFFFFFFFFFLL);
    unint64_t v10 = atomic_load((unint64_t *)v5);
    uint64_t v11 = v8[v7];
    v8[v7] = v8[v10];
    v8[v10] = v11;
    std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
  }
}

void re::StackScratchAllocator::~StackScratchAllocator(re::StackScratchAllocator *this)
{
  id v1 = this;
  *(void *)this = &unk_26E6DE358;
  uint64_t v2 = (void *)*((void *)this + 7);
  uint64_t v3 = v2 + 1;
  uint64_t v4 = (void *)v2[1];
  for (unint64_t i = (void *)*((void *)this + 5); v4 != i && *v4; unint64_t i = (void *)*((void *)v1 + 5))
  {
    *uint64_t v3 = *v4;
    std::string v6 = re::globalAllocators(this);
    this = (re::StackScratchAllocator *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6[2] + 40))(v6[2], v4);
    uint64_t v2 = (void *)*((void *)v1 + 7);
    uint64_t v3 = v2 + 1;
    uint64_t v4 = (void *)v2[1];
  }
  *uint64_t v2 = *((void *)v1 + 6);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v1 + 9);
  re::Allocator::~Allocator(v1);
}

{
  uint64_t vars8;

  re::StackScratchAllocator::~StackScratchAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

re::StackScratchAllocator **re::StackScratchAllocator::alloc(re::StackScratchAllocator ***this, uint64_t a2, unint64_t a3)
{
  if (*this[7] != (re::StackScratchAllocator *)this)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Attempting to allocate from a StackScratchAlloc object that is not top of stack", "m_root->m_top == this", "alloc", 90);
    _os_crash();
    __break(1u);
LABEL_7:
    re::StackScratchAllocator::growAndAlign((re::StackScratchAllocator *)v3, v4, a3);
    float result = v3[3];
    goto LABEL_5;
  }
  uint64_t v4 = a2;
  uint64_t v3 = this;
  if (a3 <= 1) {
    a3 = 1;
  }
  unint64_t v5 = (unint64_t)this[4];
  float result = (re::StackScratchAllocator **)(((unint64_t)this[3] + a3 - 1) & -(uint64_t)a3);
  v3[3] = result;
  if ((unint64_t)result + a2 > v5) {
    goto LABEL_7;
  }
LABEL_5:
  v3[3] = (re::StackScratchAllocator **)((char *)result + v4);
  return result;
}

void re::StackScratchAllocator::growAndAlign(re::StackScratchAllocator *this, uint64_t a2, uint64_t a3)
{
  if ((unint64_t)(a3 + a2) <= 0x80000) {
    uint64_t v5 = 0x100000;
  }
  else {
    uint64_t v5 = a3 + a2 + 0x100000;
  }
  std::string v6 = re::globalAllocators(this);
  unint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v6[2] + 32))(v6[2], v5, 0);
  uint64_t v8 = *((void *)this + 7);
  *unint64_t v7 = *(void *)(v8 + 8);
  v7[1] = v5;
  if (*((void *)this + 3)) {
    goto LABEL_7;
  }
  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  unint64_t add = atomic_fetch_add((atomic_ullong *volatile)&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount, 1uLL);
  if (add < 0x100)
  {
    re::StackScratchAllocator::s_rootsWithPersistentBlocks[add] = *((void *)this + 7);
    std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
    uint64_t v8 = *((void *)this + 7);
LABEL_7:
    *(void *)(v8 + 8) = v7;
    *((void *)this + 3) = ((unint64_t)v7 + a3 + 15) & -a3;
    *((void *)this + 4) = (char *)v7 + v5;
    return;
  }
  re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) ", "index < MAX_THREADS", "growAndAlign", 158);
  _os_crash();
  __break(1u);
}

uint64_t re::StackScratchAllocator::free(uint64_t this, uint64_t a2)
{
  if (**(void **)(this + 56) != this)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Attempting to free from a StackScratchAlloc object that is not top of stack", "m_root->m_top == this", "free", 121);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::StackScratchAllocator::statistics(re::StackScratchAllocator *this)
{
  return 0;
}

uint64_t re::Allocator::addDestructor(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t re::Allocator::destructorCalledByDefault(re::Allocator *this)
{
  return 1;
}

uint64_t re::StackScratchAllocator::parent(re::StackScratchAllocator *this)
{
  return 0;
}

void re::Data::makeDataWithBytes(re::Data *this@<X0>, const void *a2@<X1>, void *a3@<X8>)
{
  id v4 = [MEMORY[0x263EFF8F8] dataWithBytes:this length:a2];
  *a3 = v4;
}

void re::Data::makeDataWithBytesNoCopy(re::Data *this@<X0>, const void *a2@<X1>, void *a3@<X8>)
{
  id v4 = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:this length:a2 freeWhenDone:0];
  *a3 = v4;
}

void re::Data::makeDataWithContentsOfFile(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  BOOL v4 = a2 == 1;
  uint64_t v5 = (void *)MEMORY[0x263EFF8F8];
  std::string v6 = [NSString stringWithUTF8String:a1];
  id v11 = 0;
  unint64_t v7 = [v5 dataWithContentsOfFile:v6 options:v4 error:&v11];
  id v8 = v11;

  if (v7) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = v8;
  }
  id v10 = v9;
  *(unsigned char *)a3 = v7 != 0;
  *(void *)(a3 + 8) = v10;
}

uint64_t *re::globalAllocators(re *this)
{
  {
    if (v2)
    {
      re::globalAllocators(void)::s_instance = (uint64_t)&unk_26E6DE3F8;
      byte_26879F3B8 = 0;
      unk_26879F3C8 = 0u;
      unk_26879F3D8 = 0u;
      re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
    }
  }
  return &re::globalAllocators(void)::s_instance;
}

void anonymous namespace'::internalSystemAllocator(_anonymous_namespace_ *this)
{
  {
    byte_26879F438 = 0;
    unk_26879F430 = "System allocator";
  }
}

_anonymous_namespace_ *re::initGlobalAllocators(re *this)
{
  float result = (_anonymous_namespace_ *)re::globalAllocators(this);
  if (!byte_26879F3B8)
  {
    re::globalAllocators(result);
    return re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
  }
  return result;
}

_anonymous_namespace_ *re::GlobalAllocators::init(_anonymous_namespace_ *this)
{
  if (!*((unsigned char *)this + 8))
  {
    id v1 = this;
    re::globalMemoryTracker(this);
    if (!re::globalMemoryTracker(void)::s_instance)
    {
      qword_26879F3F8[0] = *((void *)v1 + 2);
      re::DynamicArray<float *>::setCapacity(qword_26879F3F8, 0x400uLL);
      ++dword_26879F410;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
    re::MemoryTracker::track((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, *((const re::Allocator **)v1 + 2));
    uint64_t v2 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 3) = re::AlignedAllocator::AlignedAllocator(v2, "SIMD-aligned allocator", 16, v3);
    BOOL v4 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 4) = re::AlignedAllocator::AlignedAllocator(v4, "Cache-aligned allocator", 64, v5);
    std::string v6 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 5) = re::AlignedAllocator::AlignedAllocator(v6, "TLB-aligned allocator", 0x4000, v7);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 5304, 8);
    *(unsigned char *)uint64_t v8 = 0;
    *(void *)(v8 + 88) = 0;
    *(void *)(v8 + 96) = 0;
    *(_DWORD *)(v8 + 104) = 0;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 68) = 0u;
    *(void *)(v8 + 108) = 0x1FFFFFFFFLL;
    *(_DWORD *)(v8 + 120) = 0;
    *(void *)(v8 + 136) = 0;
    *(void *)(v8 + 144) = 0;
    *(void *)(v8 + 128) = 0;
    *(_DWORD *)(v8 + 152) = 0;
    bzero((void *)(v8 + 160), 0x1418uLL);
    *((void *)v1 + 6) = v8;
    this = re::PerFrameAllocatorManager::init((_anonymous_namespace_ *)v8);
    *((unsigned char *)v1 + 8) = 1;
  }
  return this;
}

void re::deinitGlobalAllocators(re *this)
{
  id v1 = re::globalAllocators(this);
  if (byte_26879F3B8)
  {
    re::globalAllocators((re *)v1);
    re::GlobalAllocators::deinit((re **)&re::globalAllocators(void)::s_instance);
  }
}

void re::GlobalAllocators::deinit(re **this)
{
  if (*((unsigned char *)this + 8))
  {
    re::StackScratchAllocator::FreePersistentBlocks((re::StackScratchAllocator *)this);
    re::globalMemoryTracker(v2);
    re::PerFrameAllocatorManager::deinit(this[6]);
    uint64_t v3 = this[2];
    BOOL v4 = this[6];
    if (v4)
    {
      uint64_t v5 = 5120;
      do
      {
        *(void *)((char *)v4 + v5 + 128) = 0;
        v5 -= 40;
      }
      while (v5);
      uint64_t v6 = *((void *)v4 + 16);
      if (v6)
      {
        uint64_t v7 = *((void *)v4 + 20);
        if (v7)
        {
          uint64_t v8 = *((void *)v4 + 18);
          if (v8)
          {
            uint64_t v9 = 88 * v8;
            uint64_t v10 = v7 + 48;
            do
            {
              re::DynamicArray<unsigned long>::deinit(v10);
              re::DynamicArray<unsigned long>::deinit(v10 - 40);
              v10 += 88;
              v9 -= 88;
            }
            while (v9);
            uint64_t v6 = *((void *)v4 + 16);
            uint64_t v7 = *((void *)v4 + 20);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, v7);
        }
        *((void *)v4 + 20) = 0;
        *((void *)v4 + 17) = 0;
        *((void *)v4 + 18) = 0;
        *((void *)v4 + 16) = 0;
        ++*((_DWORD *)v4 + 38);
      }
      re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)v4 + 56);
      re::DynamicArray<unsigned long>::deinit((uint64_t)v4 + 56);
      uint64_t v11 = *((void *)v4 + 4);
      if (v11)
      {
        if (*((void *)v4 + 5))
        {
          (*(void (**)(uint64_t, void))(*(void *)v11 + 40))(v11, *((void *)v4 + 6));
          *((void *)v4 + 5) = 0;
          *((void *)v4 + 6) = 0;
        }
        *((void *)v4 + 4) = 0;
      }
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)v4 + 1);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v4);
      uint64_t v3 = this[2];
    }
    this[6] = 0;
    unint64_t v12 = this[5];
    if (v12)
    {
      (**(void (***)(re *))v12)(this[5]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v12);
      uint64_t v3 = this[2];
    }
    this[5] = 0;
    id v13 = this[4];
    if (v13)
    {
      (**(void (***)(re *))v13)(this[4]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v13);
      uint64_t v3 = this[2];
    }
    this[4] = 0;
    float v14 = this[3];
    if (v14)
    {
      (**(void (***)(re *))v14)(this[3]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v14);
      uint64_t v3 = this[2];
    }
    this[3] = 0;
    re::MemoryTracker::untrack((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, v3);
    if (re::globalMemoryTracker(void)::s_instance)
    {
      float32x4_t v15 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)qword_26879F3F8);
      re::globalMemoryTracker(void)::s_instance = 0;
    }
    *((unsigned char *)this + 8) = 0;
  }
}

void re::GlobalAllocators::~GlobalAllocators(re **this)
{
  *this = (re *)&unk_26E6DE3F8;
  re::GlobalAllocators::deinit(this);
}

{
  uint64_t vars8;

  *this = (re *)&unk_26E6DE3F8;
  re::GlobalAllocators::deinit(this);
  JUMPOUT(0x237DBCBD0);
}

char *re::globalMemoryTracker(re *this)
{
  {
    if (v2)
    {
      re::globalMemoryTracker(void)::s_instance = 0;
      qword_26879F418 = 0;
      *(_OWORD *)&algn_26879F3F1[3] = 0u;
      unk_26879F404 = 0u;
      re::DynamicArray<float *>::setCapacity(qword_26879F3F8, 0x400uLL);
      ++dword_26879F410;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
  }
  return &re::globalMemoryTracker(void)::s_instance;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::deinit(uint64_t result)
{
  if (*(_DWORD *)(result + 44))
  {
    id v1 = (void *)result;
    double v2 = re::DataArray<re::PerFrameAllocatorImpl>::clear((void *)result);
    if (!v1[2])
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v3 = (void *)v1[4];
    (*(void (**)(void, void, double))(*(void *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, v3[1]);
    float result = re::DynamicArray<unsigned long>::deinit((uint64_t)v1);
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::PerFrameAllocatorImpl>::clear(void *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      unint64_t v4 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)a1, v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v12);
    }
    while (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  uint64_t v7 = a1[2];
  unint64_t v8 = v7 - 1;
  if (v7 != 1)
  {
    uint64_t v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = a1[4] + v9;
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 16));
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  double result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

uint64_t (***re::DataArray<re::PerFrameAllocatorImpl>::destroy(uint64_t a1, unint64_t a2))(void)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  double result = (uint64_t (***)(void))re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    uint64_t v6 = result;
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 184 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

void re::StringID::init(re::StringID *this, re::Allocator *a2, const char *__s)
{
  if (__s) {
    size_t v6 = strlen(__s);
  }
  else {
    size_t v6 = 0;
  }
  re::StringID::init(this, a2, __s, v6);
}

re::StringID *re::StringID::StringID(re::StringID *this, const char *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = "";
  return this;
}

void re::StringID::init(re::StringID *this, re::Allocator *a2, const char *a3, size_t a4)
{
  if (!a3)
  {
    re::StringID::invalid((re::StringID *)&v17);
    uint64_t v12 = v17;
    uint64_t v13 = v18;
    uint64_t v17 = 0;
    long long v18 = "";
    uint64_t v14 = *(void *)this;
    uint64_t v15 = *((void *)this + 1);
    *(void *)this = v12;
    *((void *)this + 1) = v13;
    unint64_t v19 = v12 & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
    uint64_t v20 = v15;
LABEL_9:
    re::StringID::destroyString((re::StringID *)&v19);
    re::StringID::destroyString((re::StringID *)&v17);
    return;
  }
  if (!a4)
  {
    uint64_t v17 = 0;
    long long v18 = "";
    uint64_t v16 = *((void *)this + 1);
    unint64_t v19 = *(void *)this & 1;
    uint64_t v20 = v16;
    *(void *)this = 0;
    *((void *)this + 1) = "";
    goto LABEL_9;
  }
  uint64_t v7 = *a3;
  size_t v8 = a4 - 1;
  if (a4 != 1)
  {
    uint64_t v9 = a3 + 1;
    do
    {
      uint64_t v10 = *v9++;
      uint64_t v7 = v10 - v7 + 32 * v7;
      --v8;
    }
    while (v8);
  }
  *(void *)this = *(void *)this & 1 | (2 * v7);
  uint64_t v11 = (void *)(*(uint64_t (**)(re::Allocator *, size_t, void))(*(void *)a2 + 32))(a2, a4 + 1, 0);
  memcpy(v11, a3, a4);
  *((unsigned char *)v11 + a4) = 0;
  *(void *)this |= 1uLL;
  *((void *)this + 1) = v11;
}

re::StringID *re::StringID::StringID(re::StringID *this, const re::DynamicString *a2)
{
  unint64_t v3 = *((void *)a2 + 1);
  if (v3) {
    uint64_t v4 = (const char *)*((void *)a2 + 2);
  }
  else {
    uint64_t v4 = (char *)a2 + 9;
  }
  size_t v5 = v3 >> 1;
  size_t v6 = v3 >> 1;
  if (*((void *)a2 + 1)) {
    size_t v7 = v5;
  }
  else {
    size_t v7 = v6;
  }
  *(void *)this = 0;
  *((void *)this + 1) = "";
  return this;
}

re::StringID *re::StringID::StringID(re::StringID *this, const StringID *a2)
{
  uint64_t v4 = *(void *)&a2->var0;
  *(void *)this = *(void *)&a2->var0 & 0xFFFFFFFFFFFFFFFELL | *(void *)this & 1;
  if (*(unsigned char *)&a2->var0)
  {
    uint64_t var1 = a2->var1;
    size_t v8 = strlen(var1);
    memcpy(v6, var1, v8);
    v6[v8] = 0;
    unint64_t v5 = *(void *)this | 1;
  }
  else
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    size_t v6 = a2->var1;
  }
  *(void *)this = v5;
  *((void *)this + 1) = v6;
  return this;
}

void re::StringID::destroyString(re::StringID *this)
{
  if (*(unsigned char *)this)
  {
    if (*(unsigned char *)this) {
  }
    }
  *(void *)this = 0;
  *((void *)this + 1) = "";
}

unint64_t *re::StringID::operator=(unint64_t *a1, uint64_t *a2)
{
  re::StringID::destroyString((re::StringID *)a1);
  uint64_t v5 = *a2;
  *a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | *a1 & 1;
  uint64_t v6 = *a2;
  *a1 = v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  if (v6)
  {
    size_t v8 = (const char *)a2[1];
    size_t v9 = strlen(v8);
    memcpy(v7, v8, v9);
    *((unsigned char *)v7 + v9) = 0;
  }
  else
  {
    size_t v7 = (void *)a2[1];
  }
  a1[1] = (unint64_t)v7;
  return a1;
}

uint64_t *re::StringID::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  *a1 = v3;
  a1[1] = v4;
  v8[0] = v3 & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  v8[1] = v6;
  re::StringID::destroyString((re::StringID *)v8);
  return a1;
}

void re::StringID::~StringID(re::StringID *this)
{
}

re::StringID *re::StringID::invalid@<X0>(re::StringID *a1@<X8>)
{
  unint64_t v2 = a1;
  {
    unint64_t v2 = a1;
    if (v4)
    {
      *(void *)&re::StringID::invalid(void)::invalid.var0 = -2;
      re::StringID::invalid(void)::invalid.uint64_t var1 = "";
      unint64_t v2 = a1;
    }
  }
  return re::StringID::StringID(v2, &re::StringID::invalid(void)::invalid);
}

const char *re::WeakStringID::debugStr(re::WeakStringID *this)
{
  if (*(void *)this == 0x7FFFFFFFFFFFFFFFLL) {
    return 0;
  }
  if (!*(void *)this) {
    return "";
  }
  id v1 = re::WeakStringID::debugStr(void)const::msg;
  snprintf(re::WeakStringID::debugStr(void)const::msg, 0x50uLL, "%llu", *(void *)this);
  return v1;
}

void re::StringID::copy(re::StringID *this, const re::StringID *a2, re::Allocator *a3)
{
  if (*(unsigned char *)this) {
    (*(void (**)(re::Allocator *, void))(*(void *)a3 + 40))(a3, *((void *)this + 1));
  }
  *(void *)this = 0;
  *((void *)this + 1) = "";
  if (*(unsigned char *)a2)
  {
    uint64_t v6 = (const char *)*((void *)a2 + 1);
    re::StringID::init(this, a3, v6);
  }
  else
  {
    re::StringID::operator=((unint64_t *)this, (uint64_t *)a2);
  }
}

BOOL re::StringID::operator==(void *a1, void *a2)
{
  if ((*a2 & 0x7FFFFFFFFFFFFFFFLL) != *a1 >> 1) {
    return 0;
  }
  unint64_t v2 = (const char *)a1[1];
  uint64_t v3 = (const char *)a2[1];
  return v2 == v3 || strcmp(v2, v3) == 0;
}

{
  const char *v2;
  const char *v3;

  if ((*a2 ^ *a1) > 1) {
    return 0;
  }
  unint64_t v2 = (const char *)a1[1];
  uint64_t v3 = (const char *)a2[1];
  return v2 == v3 || strcmp(v2, v3) == 0;
}

void re::MemoryTracker::track(os_unfair_lock_s *this, const re::Allocator *a2)
{
  int v4 = a2;
  uint64_t v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::TransitionCondition *>::add(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

void re::MemoryTracker::untrack(os_unfair_lock_s *this, const re::Allocator *a2)
{
  int v4 = a2;
  uint64_t v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::removeStable(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

BOOL re::DynamicArray<re::Allocator const*>::removeStable(void *a1, void *a2)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[2];
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = (void *)a1[4];
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        uint64_t v5 = (void *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    uint64_t v5 = (void *)a1[4];
  }
  uint64_t v6 = (uint64_t)v5 - v2;
  uint64_t v7 = v6 >> 3;
  if (v6 >> 3 != v3) {
    re::DynamicArray<re::Allocator const*>::removeStableAt(a1, v6 >> 3);
  }
  return v7 != v3;
}

uint64_t re::MemoryTracker::statistics(os_unfair_lock_s *this)
{
  v4[0] = 0;
  v4[1] = 0;
  uint64_t v2 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::MemoryTracker::statistics((uint64_t)this, 0, v4);
  os_unfair_lock_unlock(v2);
  return v4[0];
}

uint64_t re::MemoryTracker::statistics(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(result + 24);
  if (v3)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void **)(result + 40);
    uint64_t v8 = 8 * v3;
    do
    {
      uint64_t v9 = *v7;
      double result = (*(uint64_t (**)(void))(*(void *)*v7 + 48))(*v7);
      if (result == a2)
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
        uint64_t v12 = a3[1] + v11;
        *a3 += v10;
        a3[1] = v12;
        double result = re::MemoryTracker::statistics(v6, v9, a3);
      }
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  return result;
}

void re::MemoryTracker::logMemoryLeaks(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::MemoryTracker::logMemoryLeaks((const re::Allocator *)this, 0);
  os_unfair_lock_unlock(v2);
}

const re::Allocator *re::MemoryTracker::logMemoryLeaks(const re::Allocator *this, const re::Allocator *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v4 = (void *)*((void *)this + 5);
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      this = (const re::Allocator *)(*(uint64_t (**)(void))(*(void *)*v4 + 48))(*v4);
      if (this == a2) {
        this = (const re::Allocator *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 64))(v6);
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return this;
}

void *re::DynamicArray<re::Allocator const*>::removeStableAt(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = result;
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = result[4];
    double result = (void *)(v5 + 8 * a2);
    uint64_t v6 = (char *)(v5 + 8 * v2);
    if (v6 != (char *)(result + 1))
    {
      double result = memmove(result, result + 1, v6 - (char *)(result + 1));
      uint64_t v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

unsigned __int8 *re::StringSlice::findFirstOf@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  double result = std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>((unsigned __int8 *)(*a1 + a3), *a1 + a1[1], *(unsigned __int8 **)a2, (unsigned __int8 *)(*(void *)a2 + *(void *)(a2 + 8)));
  if ((unsigned __int8 *)(*a1 + a1[1]) == result)
  {
    char v7 = 0;
  }
  else
  {
    *(void *)(a4 + 8) = &result[-*a1];
    char v7 = 1;
  }
  *(unsigned char *)a4 = v7;
  return result;
}

uint64_t *re::StringSlice::findLastOf@<X0>(uint64_t *result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = result[1];
  uint64_t v5 = a2[1];
  if (v4 == a3 || v5 == 0) {
    goto LABEL_17;
  }
  uint64_t v7 = *result;
  uint64_t v8 = (unsigned __int8 *)(*result + v4);
  uint64_t v9 = (unsigned __int8 *)(*result + a3);
  uint64_t v10 = v8;
  do
  {
    if (*v9 == **a2)
    {
      uint64_t v11 = 1;
      while (v5 != (unsigned __int8 *)v11)
      {
        if (&v9[v11] == v8) {
          goto LABEL_15;
        }
        int v12 = v9[v11];
        double result = (uint64_t *)(*a2)[v11++];
        if (v12 != result) {
          goto LABEL_7;
        }
      }
      uint64_t v10 = v9;
    }
LABEL_7:
    ++v9;
  }
  while (v9 != v8);
LABEL_15:
  if (v10 == v8)
  {
LABEL_17:
    *(unsigned char *)a4 = 0;
  }
  else
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = &v10[-v7];
  }
  return result;
}

unsigned __int8 *std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int64_t v4 = a4 - a3;
  if (a4 == a3) {
    return a1;
  }
  uint64_t v5 = a2;
  if (a2 - (uint64_t)a1 >= v4)
  {
    uint64_t v6 = a2 - v4 + 1;
    if ((unsigned __int8 *)v6 != a1)
    {
      int v9 = *a3;
      uint64_t v7 = a3 + 1;
      int v8 = v9;
      while (*a1 != v8)
      {
LABEL_9:
        if (++a1 == (unsigned __int8 *)v6) {
          return (unsigned __int8 *)v5;
        }
      }
      uint64_t v10 = a1 + 1;
      uint64_t v11 = v7;
      while (v11 != a4)
      {
        int v13 = *v10++;
        int v12 = v13;
        int v14 = *v11++;
        if (v12 != v14) {
          goto LABEL_9;
        }
      }
      return a1;
    }
  }
  return (unsigned __int8 *)v5;
}

void *std::function<void ()(re::EventQueue &)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(re::EventQueue &)>::__value_func[abi:nn180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(re::EventQueue &)>::swap[abi:nn180100](v4, a1);
  std::__function::__value_func<void ()(re::EventQueue &)>::~__value_func[abi:nn180100](v4);
  return a1;
}

void re::EventQueue::postEvent(os_unfair_lock_s *this, const void *a2, size_t a3)
{
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, 0, "assertion failure: '%s' (%s:line %i) event must not be null.", "event", "postEvent", 28);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (a3 <= 3)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid size.", "size >= sizeof(uint32_t)", "postEvent", 29);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Invalid size. Size causes arithmetic overflow.", "!overflow", "postEvent", 44);
    _os_crash();
    __break(1u);
LABEL_15:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  os_unfair_lock_lock(this);
  uint32_t os_unfair_lock_opaque = this[22]._os_unfair_lock_opaque;
  uint64_t v7 = &this[10 * os_unfair_lock_opaque];
  unint64_t v10 = *(void *)&v7[6]._os_unfair_lock_opaque;
  int v9 = v7 + 6;
  unint64_t v8 = v10;
  BOOL v11 = v10 >= 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v12 = a3 + v10 + 4;
  BOOL v13 = __CFADD__(a3, v10 + 4);
  if (v11 || v13) {
    goto LABEL_14;
  }
  re::DynamicArray<char>::resize((uint64_t)&this[10 * os_unfair_lock_opaque + 2], v12);
  if (*(void *)&v9->_os_unfair_lock_opaque <= v8) {
    goto LABEL_15;
  }
  uint64_t v14 = *(void *)&this[10 * os_unfair_lock_opaque + 10]._os_unfair_lock_opaque;
  *(_DWORD *)(v14 + v8) = a3;
  memcpy((void *)(v14 + v8 + 4), a2, a3);
  os_unfair_lock_unlock(this);
}

void re::DynamicArray<char>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<char>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1) {
      bzero((void *)(*(void *)(a1 + 32) + v4), a2 - v4);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::EventQueue::processEvents(os_unfair_lock_s *this)
{
  re::EventQueue::swapBuffers(this);
  uint64_t result = *(void *)&this[32]._os_unfair_lock_opaque;
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v3();
  }
  return result;
}

void re::EventQueue::swapBuffers(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  BOOL v2 = (this[22]._os_unfair_lock_opaque & 1) == 0;
  this[22]._uint32_t os_unfair_lock_opaque = v2;
  uint64_t v3 = &this[10 * v2];
  *(void *)&v3[6]._uint32_t os_unfair_lock_opaque = 0;
  ++v3[8]._os_unfair_lock_opaque;
  *(void *)&this[24]._uint32_t os_unfair_lock_opaque = 0;
  os_unfair_lock_unlock(this);
}

uint64_t re::EventQueue::peekEvent(re::EventQueue *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 12);
  unint64_t v3 = *((void *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 3);
  if (v3 == v2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) EventQueue is empty.", "!isEmpty()", "peekEvent", 100);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  if (v3 - v2 - 8 < a2)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid offset.", "offset <= events.size() - payloadOffset - sizeof(uint32_t)", "peekEvent", 105);
    _os_crash();
    __break(1u);
LABEL_7:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v4 = a2 + v2 + 4;
  if (v3 <= v4) {
    goto LABEL_7;
  }
  return *(unsigned int *)(*((void *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 5) + v4);
}

void *re::EventQueue::readEvent(re::EventQueue *this, void *__dst, size_t __n)
{
  unint64_t v3 = *((void *)this + 12);
  unint64_t v4 = *((void *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 3);
  if (v3 == v4)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, __n, "assertion failure: '%s' (%s:line %i) EventQueue is empty.", "!isEmpty()", "readEvent", 115);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!__dst)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, __n, "assertion failure: '%s' (%s:line %i) buffer must not be null.", "buffer", "readEvent", 116);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (v4 <= v3)
  {
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  uint64_t v7 = *((void *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 5);
  if (*(_DWORD *)(v7 + v3) != __n)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, "assertion failure: '%s' (%s:line %i) Specified size does not match event size.", "size == nextEventSize()", "readEvent", 117);
    _os_crash();
    __break(1u);
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v8 = v3 + 4;
  if (v4 <= v8) {
    goto LABEL_11;
  }
  uint64_t result = memcpy(__dst, (const void *)(v7 + v8), __n);
  *((void *)this + 12) += __n + 4;
  return result;
}

uint64_t std::__function::__value_func<void ()(re::EventQueue &)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::EventQueue &)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(re::EventQueue &)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void re::internal::refCountCheckFailHandler(re::internal *this, const void *a2, const void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (this) {
    uint64_t v5 = "Retain";
  }
  else {
    uint64_t v5 = "Release";
  }
  fprintf((FILE *)*MEMORY[0x263EF8348], "Ref count out of range on %s. %p (retain count is %d 0x%x)\n", v5, a2, a3, a3);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7FB60))
  {
    re::Defaults::BOOLValue((re::Defaults *)"crashOnRefCountCheckFail", v6, (char *)buf);
    if (buf[0]) {
      uint8_t v8 = buf[1];
    }
    else {
      uint8_t v8 = 0;
    }
    _MergedGlobals_131 = v8;
    __cxa_guard_release(&qword_26AF7FB60);
  }
  if (_MergedGlobals_131)
  {
    re::internal::assertLog((re::internal *)8, (uint64_t)v6, "assertion failure: '%s' (%s:line %i) Ref count out of range on %s. %p (retain count is %d 0x%x)\n", "false", "refCountCheckFailHandler", 30, v5, a2, a3, a3);
    _os_crash();
    __break(1u);
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    unint64_t v10 = v5;
    __int16 v11 = 2048;
    unint64_t v12 = a2;
    __int16 v13 = 1024;
    int v14 = (int)a3;
    __int16 v15 = 1024;
    int v16 = (int)a3;
    _os_log_error_impl(&dword_233120000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Ref count out of range on %s. %p (retain count is %d 0x%x)\n", buf, 0x22u);
  }
  re::internal::logStackTrace(0, 0, v7);
}

re::PageDebugAllocator *re::PageDebugAllocator::PageDebugAllocator(re::PageDebugAllocator *this, const char *a2, int a3, unint64_t a4)
{
  uint64_t v6 = re::Allocator::Allocator(this, a2, a3);
  *(void *)uint64_t v6 = &unk_26E6DE428;
  *((_DWORD *)v6 + 5) = 0;
  *((_OWORD *)v6 + 3) = 0u;
  *((void *)v6 + 8) = 0;
  *((_OWORD *)v6 + 2) = 0u;
  uint64_t v7 = (uint64_t *)((char *)v6 + 32);
  return this;
}

void re::PageDebugAllocator::~PageDebugAllocator(re::PageDebugAllocator *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 20);
  os_unfair_lock_lock((os_unfair_lock_t)this + 5);
  uint64_t v4 = *((void *)this + 7);
  uint64_t v5 = *((void *)this + 8);
  uint64_t v3 = (void *)((char *)this + 56);
  if (v4 != v5)
  {
    uint64_t v6 = (vm_map_t *)MEMORY[0x263EF8960];
    do
    {
      unint64_t v7 = *((void *)this + 5);
      unint64_t v8 = (v7 - 1) & v4;
      if (v7 <= v8)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      mach_vm_deallocate(*v6, *(void *)(*((void *)this + 6) + 16 * v8), *(void *)(*((void *)this + 6) + 16 * v8 + 8));
      ++v4;
    }
    while (v5 != v4);
  }
  *uint64_t v3 = 0;
  *((void *)this + 8) = 0;
  os_unfair_lock_unlock(v2);
  *uint64_t v3 = 0;
  *((void *)this + 8) = 0;
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::PageDebugAllocator::~PageDebugAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

mach_vm_address_t re::PageDebugAllocator::alloc(os_unfair_lock_s *this, uint64_t a2)
{
  uint64_t v3 = this + 5;
  os_unfair_lock_lock(this + 5);
  mach_vm_size_t v4 = ~*MEMORY[0x263EF8AE8] & (unint64_t)(a2 + *MEMORY[0x263EF8AE8] + 16);
  mach_vm_address_t address = 0;
  mach_vm_address_t v5 = 0;
  if (!mach_vm_map(*MEMORY[0x263EF8960], &address, v4, 0, 1, 0, 0, 0, 3, 3, 2u))
  {
    mach_vm_address_t v6 = address;
    *(void *)mach_vm_address_t address = a2;
    *(void *)(v6 + 8) = v4;
    mach_vm_address_t v5 = v6 + 16;
    __dmb(0xBu);
  }
  os_unfair_lock_unlock(v3);
  return v5;
}

void re::PageDebugAllocator::free(os_unfair_lock_s *this, void *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  mach_vm_size_t v4 = this + 5;
  os_unfair_lock_lock(this + 5);
  __dmb(0xBu);
  mach_vm_address_t v5 = (char *)(a2 - 2);
  mach_vm_size_t v6 = *(a2 - 1);
  mach_vm_address_t address = (mach_vm_address_t)v5;
  unint64_t v7 = (vm_map_t *)MEMORY[0x263EF8960];
  mach_vm_map(*MEMORY[0x263EF8960], &address, v6, 0, 0x4000, 0, 0, 0, 0, 3, 2u);
  uint64_t v9 = *(void *)&this[14]._os_unfair_lock_opaque;
  uint64_t v8 = *(void *)&this[16]._os_unfair_lock_opaque;
  unint64_t v10 = v8 - v9;
  unint64_t v11 = *(void *)&this[10]._os_unfair_lock_opaque;
  if (v8 - v9 == v11)
  {
    unint64_t v11 = (v10 - 1) & v9;
    if (v10 <= v11) {
      goto LABEL_9;
    }
    unint64_t v12 = (mach_vm_address_t *)(*(void *)&this[12]._os_unfair_lock_opaque + 16 * v11);
    mach_vm_deallocate(*v7, *v12, v12[1]);
    *unint64_t v12 = 0;
    v12[1] = 0;
    uint64_t v8 = *(void *)&this[16]._os_unfair_lock_opaque;
    uint64_t v13 = *(void *)&this[14]._os_unfair_lock_opaque + 1;
    *(void *)&this[14]._uint32_t os_unfair_lock_opaque = v13;
    unint64_t v11 = *(void *)&this[10]._os_unfair_lock_opaque;
    unint64_t v10 = v8 - v13;
  }
  uint64_t v14 = v8 + 1;
  if (v10 == v11) {
    *(void *)&this[14]._uint32_t os_unfair_lock_opaque = v14 - v10;
  }
  *(void *)&this[16]._uint32_t os_unfair_lock_opaque = v14;
  unint64_t v10 = (v11 - 1) & v8;
  if (v11 <= v10)
  {
    uint64_t v17 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v26 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v18 = 136315906;
    unint64_t v19 = "operator[]";
    __int16 v20 = 1024;
    int v21 = 468;
    __int16 v22 = 2048;
    unint64_t v23 = v10;
    __int16 v24 = 2048;
    unint64_t v25 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    uint64_t v17 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v26 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v18 = 136315906;
    unint64_t v19 = "operator[]";
    __int16 v20 = 1024;
    int v21 = 468;
    __int16 v22 = 2048;
    unint64_t v23 = v11;
    __int16 v24 = 2048;
    unint64_t v25 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  __int16 v15 = (void *)(*(void *)&this[12]._os_unfair_lock_opaque + 16 * v10);
  *__int16 v15 = v5;
  v15[1] = v6;
  os_unfair_lock_unlock(v4);
}

uint64_t re::PageDebugAllocator::statistics(os_unfair_lock_s *this)
{
  id v1 = this + 5;
  os_unfair_lock_lock(this + 5);
  os_unfair_lock_unlock(v1);
  return 0;
}

void re::PageDebugAllocator::logMemoryLeaks(os_unfair_lock_s *this)
{
  id v1 = this + 5;
  os_unfair_lock_lock(this + 5);
  os_unfair_lock_unlock(v1);
}

uint64_t re::PageDebugAllocator::parent(re::PageDebugAllocator *this)
{
  return 0;
}

void re::FixedArray<re::PageDebugAllocator::DeferredFree>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 16 * a3;
  mach_vm_size_t v6 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    uint64_t v8 = (void *)((char *)v8 + v5 - 16);
  }
  *uint64_t v8 = 0;
  v8[1] = 0;
}

id *re::ObjCObject::operator=(id *location, id *a2)
{
  if (location != a2) {
    objc_storeStrong(location, *a2);
  }
  return location;
}

void **re::ObjCObject::operator=(void **a1, void *a2)
{
  id v3 = a2;
  mach_vm_size_t v4 = *a1;
  if (*a1 != v3)
  {
    *a1 = v3;

    id v3 = 0;
  }

  return a1;
}

const char *re::ObjCObject::description(id *this)
{
  id v1 = [*this description];
  uint64_t v2 = v1;
  if (v1) {
    id v3 = (const char *)[v1 UTF8String];
  }
  else {
    id v3 = "nil";
  }

  return v3;
}

re::ns::String *re::ns::String::String(re::ns::String *this, re::ns *a2)
{
  re::ns::convertToNSString(a2, (const char *)a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  *(void *)this = v3;

  return this;
}

re::ns *re::ns::convertToNSString(re::ns *this, const char *a2)
{
  if (this)
  {
    this = [NSString stringWithUTF8String:this];
    uint64_t v2 = vars8;
  }
  return this;
}

void re::ns::String::format(re::ns::String *this@<X0>, void *a2@<X8>, ...)
{
  va_start(va, a2);
  id v5 = [NSString alloc];
  mach_vm_size_t v6 = [NSString stringWithUTF8String:this];
  uint64_t v7 = (void *)[v5 initWithFormat:v6 arguments:va];

  id v8 = v7;
  *a2 = v8;
}

re::PoolAllocator *re::PoolAllocator::PoolAllocator(re::PoolAllocator *this, const char *a2, unint64_t a3, uint64_t a4, re::Allocator *a5, unint64_t a6)
{
  unint64_t v11 = re::Allocator::Allocator(this, a2, 1);
  *(void *)unint64_t v11 = &unk_26E6DE498;
  *((void *)v11 + 3) = a5;
  *((_DWORD *)v11 + 8) = 0;
  *((_DWORD *)v11 + 10) = 0;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_DWORD *)v11 + 20) = 0;
  *(void *)((char *)v11 + 84) = 0x7FFFFFFFLL;
  *((void *)v11 + 16) = 0;
  *((void *)v11 + 13) = 0;
  *((void *)v11 + 14) = 0;
  *((_DWORD *)v11 + 30) = 0;
  *((void *)v11 + 12) = a5;
  re::DynamicArray<float *>::setCapacity((void *)v11 + 12, 0);
  ++*((_DWORD *)this + 30);
  *((void *)this + 17) = a5;
  *((void *)this + 21) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)this + 17, 0);
  ++*((_DWORD *)this + 40);
  *((void *)this + 26) = 0;
  *((void *)this + 28) = 0;
  *((_WORD *)this + 116) = 1;
  int8x8_t v13 = (int8x8_t)16;
  if (a6 > 0x10) {
    int8x8_t v13 = (int8x8_t)a6;
  }
  *((int8x8_t *)this + 22) = v13;
  uint64_t v14 = 32;
  if (a4) {
    uint64_t v14 = a4;
  }
  *((void *)this + 24) = a3;
  unint64_t v15 = 8;
  if (a3 > 8) {
    unint64_t v15 = a3;
  }
  if (v15 >= 0x18)
  {
    *((void *)this + 26) = 8;
    unint64_t v15 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    *((void *)this + 28) = v15 - 8;
    *((unsigned char *)this + 233) = 1;
  }
  unint64_t v16 = v15 + 7;
  *((void *)this + 27) = v16 & 0xFFFFFFFFFFFFFFF8;
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v13);
  v17.i16[0] = vaddlv_u8(v17);
  unint64_t v18 = (v16 | 7) + *(void *)&v13;
  unint64_t v19 = v18 / *(void *)&v13 * *(void *)&v13;
  unint64_t v20 = v18 & -*(void *)&v13;
  if (v17.u32[0] != 1) {
    unint64_t v20 = v19;
  }
  *((void *)this + 23) = v20;
  unint64_t v21 = v20 * v14;
  *((void *)this + 25) = v21;
  if (HIDWORD(v21))
  {
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "m_blockSize <= std::numeric_limits<uint32_t>::max()", "PoolAllocator", 52);
    uint64_t result = (re::PoolAllocator *)_os_crash();
    __break(1u);
  }
  else
  {
    *((void *)this + 25) = v21 + *(void *)&v13;
    return this;
  }
  return result;
}

void re::PoolAllocator::~PoolAllocator(re::PoolAllocator *this)
{
  if (*((void *)this + 3))
  {
    uint64_t v2 = *((void *)this + 14);
    if (v2)
    {
      id v3 = (uint64_t *)*((void *)this + 16);
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *v3++;
        (*(void (**)(void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v5);
        v4 -= 8;
      }
      while (v4);
    }
    *((void *)this + 14) = 0;
    ++*((_DWORD *)this + 30);
    *((void *)this + 3) = 0;
  }
  uint64_t v6 = *((void *)this + 17);
  if (v6)
  {
    if (*((void *)this + 21)) {
      (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
    }
    *((void *)this + 21) = 0;
    *((void *)this + 18) = 0;
    *((void *)this + 19) = 0;
    *((void *)this + 17) = 0;
    ++*((_DWORD *)this + 40);
  }
  uint64_t v7 = *((void *)this + 12);
  if (v7)
  {
    if (*((void *)this + 16)) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    *((void *)this + 16) = 0;
    *((void *)this + 13) = 0;
    *((void *)this + 14) = 0;
    *((void *)this + 12) = 0;
    ++*((_DWORD *)this + 30);
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 6);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::PoolAllocator::~PoolAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

unint64_t re::PoolAllocator::alloc(re::PoolAllocator *this, unint64_t a2, unint64_t a3)
{
  if (!*((void *)this + 3) || *((void *)this + 22) < a3 || *((void *)this + 24) < a2) {
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  if (!*((void *)this + 19))
  {
    uint64_t v11 = *((void *)this + 3);
    if (!v11) {
      goto LABEL_38;
    }
    uint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v11 + 32))(v11, *((void *)this + 25), *((void *)this + 22));
    if (v12)
    {
      unint64_t v4 = (unint64_t)v12;
      *(_OWORD *)uint64_t v12 = xmmword_23437C790;
      unint64_t v13 = *((void *)this + 14);
      if (HIDWORD(v13)) {
        goto LABEL_41;
      }
      *((_DWORD *)v12 + 2) = v13;
      uint64_t v14 = *((void *)this + 23);
      unint64_t v15 = (unint64_t)v12 + *((void *)this + 22);
      unint64_t v16 = (char *)v12 + *((void *)this + 25) - v14;
      if (v15 <= (unint64_t)v16)
      {
        int v19 = *((unsigned __int8 *)this + 233);
        unint64_t v20 = (char *)v12 + *((void *)this + 22);
        uint64_t v17 = *((void *)this + 26);
        uint64_t v21 = *((void *)this + 27);
        do
        {
          *(void *)&v20[v21] = v12;
          if (v19)
          {
            *(void *)unint64_t v20 = 0xFEEFED900143AD35;
            *(void *)&v20[*((void *)this + 28)] = 0xDFFDFE9001F00735;
          }
          *(void *)&v20[v17] = &v20[v14];
          v20 += v14;
        }
        while (v20 <= v16);
      }
      else
      {
        uint64_t v17 = *((void *)this + 26);
      }
      *(void *)&v16[v17] = 0;
      unint64_t v22 = *((void *)this + 13);
      if (v13 >= v22)
      {
        unint64_t v23 = v13 + 1;
        if (v22 < v13 + 1)
        {
          if (*((void *)this + 12))
          {
            unint64_t v24 = 2 * v22;
            if (!v22) {
              unint64_t v24 = 8;
            }
            if (v24 <= v23) {
              unint64_t v25 = v23;
            }
            else {
              unint64_t v25 = v24;
            }
            re::DynamicArray<float *>::setCapacity((void *)this + 12, v25);
          }
          else
          {
            re::DynamicArray<float *>::setCapacity((void *)this + 12, v23);
            ++*((_DWORD *)this + 30);
          }
        }
        unint64_t v13 = *((void *)this + 14);
      }
      *(void *)(*((void *)this + 16) + 8 * v13) = v4;
      *((void *)this + 14) = v13 + 1;
      ++*((_DWORD *)this + 30);
      uint64_t v26 = *((void *)this + 19);
      v27.n128_u64[0] = v4;
      v27.n128_u64[1] = v15;
      re::DynamicArray<re::Pair<float *,re::AnimationBlendTreeInstance<float>::SampleFlags,true>>::add((uint64_t)this + 136, &v27);
      *(_DWORD *)(v4 + 12) = v26;
    }
    if (!*((void *)this + 19))
    {
LABEL_38:
      unint64_t v4 = 0;
      goto LABEL_39;
    }
  }
  uint64_t v7 = *((void *)this + 21);
  unint64_t v4 = *(void *)(v7 + 8);
  if (*((unsigned char *)this + 233)
    && (*(void *)v4 != 0xFEEFED900143AD35 || *(void *)(v4 + *((void *)this + 28)) != 0xDFFDFE9001F00735))
  {
    goto LABEL_42;
  }
  uint64_t v8 = *(void *)(v4 + *((void *)this + 27));
  unsigned int v9 = *(_DWORD *)(v8 + 4) + *((_DWORD *)this + 46);
  *(_DWORD *)(v8 + 4) = v9;
  uint64_t v10 = *(void *)(v4 + *((void *)this + 26));
  if (v10)
  {
    *(void *)(v7 + 8) = v10;
LABEL_20:
    *(void *)(v4 + *((void *)this + 26)) = 0;
LABEL_39:
    os_unfair_lock_unlock((os_unfair_lock_t)this + 8);
    return v4;
  }
  if (*((void *)this + 22) + v9 == *((void *)this + 25))
  {
    unint64_t v18 = *(unsigned int *)(v8 + 12);
    re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)this + 136, v18);
    if (*((void *)this + 19) > v18) {
      *(_DWORD *)(*(void *)(*((void *)this + 21) + 16 * v18) + 12) = v18;
    }
    goto LABEL_20;
  }
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "isBlockFull(block)", "alloc", 113);
  _os_crash();
  __break(1u);
LABEL_41:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "m_blocks.size() <= std::numeric_limits<uint32_t>::max()", "addPoolBlock", 281);
  _os_crash();
  __break(1u);
LABEL_42:
  re::internal::assertLog((re::internal *)5, v6, "assertion failure: '%s' (%s:line %i) Free pool entry %p is corrupted", "!hasEntryMemoryBeenStomped(entry)", "alloc", 104, v4);
  unint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::PoolAllocator::free(os_unfair_lock_s *this, char *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (!a2) {
    return;
  }
  if (*(void *)&this[6]._os_unfair_lock_opaque)
  {
    os_unfair_lock_lock(this + 8);
    uint64_t v5 = *(_DWORD **)&a2[*(void *)&this[54]._os_unfair_lock_opaque];
    if (!LOBYTE(this[58]._os_unfair_lock_opaque) || *v5 == -1159983635)
    {
      if (!BYTE1(this[58]._os_unfair_lock_opaque)
        || *(void *)a2 == 0xFEEFED900143AD35
        && *(void *)&a2[*(void *)&this[56]._os_unfair_lock_opaque] == 0xDFFDFE9001F00735)
      {
        uint64_t v6 = *(void *)&this[38]._os_unfair_lock_opaque;
        if (v6)
        {
          BOOL v7 = 0;
          uint64_t v8 = *(void *)&this[42]._os_unfair_lock_opaque;
          uint64_t v9 = v8 + 16 * v6;
          do
          {
            if (!v7)
            {
              for (unint64_t i = *(char **)(v8 + 8); i; unint64_t i = *(char **)&i[*(void *)&this[52]._os_unfair_lock_opaque])
              {
                BOOL v7 = i == a2;
                if (i == a2) {
                  break;
                }
              }
            }
            v8 += 16;
          }
          while (v8 != v9);
          if (v7) {
            goto LABEL_35;
          }
        }
      }
      uint64_t v11 = v5[1];
      uint64_t v12 = *(void *)&this[44]._os_unfair_lock_opaque;
      uint64_t v13 = *(void *)&this[50]._os_unfair_lock_opaque;
      int v14 = v11 - this[46]._os_unfair_lock_opaque;
      v5[1] = v14;
      if (!v14)
      {
        if (!*(void *)&this[6]._os_unfair_lock_opaque) {
          goto LABEL_35;
        }
        unint64_t v15 = v5[2];
        if (*(void *)&this[28]._os_unfair_lock_opaque > v15)
        {
          uint64_t v16 = *(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15);
          unint64_t v17 = *(unsigned int *)(v16 + 12);
          re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)&this[34], v17);
          if (*(void *)&this[38]._os_unfair_lock_opaque > v17) {
            *(_DWORD *)(*(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * v17) + 12) = v17;
          }
          (*(void (**)(void, uint64_t))(**(void **)&this[6]._os_unfair_lock_opaque + 40))(*(void *)&this[6]._os_unfair_lock_opaque, v16);
          unint64_t v18 = *(void *)&this[28]._os_unfair_lock_opaque;
          if (v18 > v15)
          {
            unint64_t v19 = v18 - 1;
            if (v18 - 1 <= v15)
            {
              *(void *)&this[28]._uint32_t os_unfair_lock_opaque = v19;
              ++this[30]._os_unfair_lock_opaque;
            }
            else
            {
              *(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15) = *(void *)(*(void *)&this[32]._os_unfair_lock_opaque
                                                                                             + 8 * v18
                                                                                             - 8);
              *(void *)&this[28]._uint32_t os_unfair_lock_opaque = v19;
              ++this[30]._os_unfair_lock_opaque;
              *(_DWORD *)(*(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15) + 8) = v15;
            }
LABEL_35:
            os_unfair_lock_unlock(this + 8);
            return;
          }
LABEL_48:
          long long v29 = 0u;
          long long v30 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_47:
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      }
      if (v12 + v11 == v13)
      {
        uint32_t os_unfair_lock_opaque = this[38]._os_unfair_lock_opaque;
        *(void *)buf = v5;
        *(void *)&uint8_t buf[8] = 0;
        re::DynamicArray<re::Pair<float *,re::AnimationBlendTreeInstance<float>::SampleFlags,true>>::add((uint64_t)&this[34], (__n128 *)buf);
        v5[3] = os_unfair_lock_opaque;
      }
      else
      {
        uint32_t os_unfair_lock_opaque = v5[3];
      }
      if (*(void *)&this[38]._os_unfair_lock_opaque > (unint64_t)os_unfair_lock_opaque)
      {
        uint64_t v23 = *(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8);
        if (BYTE1(this[58]._os_unfair_lock_opaque))
        {
          *(void *)a2 = 0xFEEFED900143AD35;
          *(void *)&a2[*(void *)&this[56]._os_unfair_lock_opaque] = 0xDFFDFE9001F00735;
        }
        *(void *)&a2[*(void *)&this[52]._os_unfair_lock_opaque] = v23;
        *(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8) = a2;
        goto LABEL_35;
      }
LABEL_46:
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug", "!m_enableAsserts || block->m_magic == blockGuard", "free", 149);
    _os_crash();
    __break(1u);
LABEL_42:
    if (*(void *)&this[2]._os_unfair_lock_opaque) {
      unint64_t v25 = *(const char **)&this[2]._os_unfair_lock_opaque;
    }
    else {
      unint64_t v25 = "<UNKNOWN>";
    }
    re::internal::assertLog((re::internal *)5, v21, "assertion failure: '%s' (%s:line %i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", "!m_enableAsserts", "free", 133, v25);
    _os_crash();
    __break(1u);
    goto LABEL_46;
  }
  unint64_t v20 = *re::foundationMemoryLogObjects((re *)this);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    unint64_t v24 = *(const char **)&this[2]._os_unfair_lock_opaque;
    if (!v24) {
      unint64_t v24 = "<UNKNOWN>";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", buf, 0xCu);
  }
  if (LOBYTE(this[58]._os_unfair_lock_opaque)) {
    goto LABEL_42;
  }
}

uint64_t re::PoolAllocator::statistics(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint64_t v3 = *(void *)&this[28]._os_unfair_lock_opaque;
  uint64_t v4 = 16 * *(void *)&this[38]._os_unfair_lock_opaque + 8 * v3;
  uint64_t v5 = 16 * *(void *)&this[36]._os_unfair_lock_opaque + 8 * *(void *)&this[26]._os_unfair_lock_opaque;
  if (v3)
  {
    uint64_t v6 = *(uint64_t **)&this[32]._os_unfair_lock_opaque;
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6++;
      v5 += *(void *)&this[50]._os_unfair_lock_opaque;
      v4 += *(unsigned int *)(v8 + 4);
      v7 -= 8;
    }
    while (v7);
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t re::PoolAllocator::parent(re::PoolAllocator *this)
{
  return *((void *)this + 3);
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  re::DynamicString::setCapacity(this, 0);
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *__s, re::Allocator *a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  size_t v6 = strlen(__s);
  if (v6)
  {
    size_t v7 = v6;
    *(void *)this = a3;
    re::DynamicString::setCapacity(this, v6 + 1);
    re::DynamicString::assign(this, __s, v7);
  }
  else
  {
    *(void *)this = a3;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::assign(re::DynamicString *this, const char *__src, size_t __len)
{
  uint64_t v6 = *((void *)this + 1);
  if (v6) {
    size_t v7 = *((void *)this + 3);
  }
  else {
    size_t v7 = 23;
  }
  if (v7 <= __len)
  {
    re::DynamicString::growCapacity(this, __len + 1);
    uint64_t v6 = *((void *)this + 1);
  }
  if (v6) {
    uint64_t v8 = (char *)*((void *)this + 2);
  }
  else {
    uint64_t v8 = (char *)this + 9;
  }
  unint64_t result = memmove(v8, __src, __len);
  if (*((unsigned char *)this + 8)) {
    uint64_t v10 = (char *)*((void *)this + 2);
  }
  else {
    uint64_t v10 = (char *)this + 9;
  }
  v10[__len] = 0;
  uint64_t v11 = *((void *)this + 1);
  if (v11) {
    *((void *)this + 1) = (2 * __len) | 1;
  }
  else {
    *((unsigned char *)this + 8) = v11 & 1 | (2 * __len);
  }
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *a2, size_t a3, re::Allocator *a4)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (a3)
  {
    *(void *)this = a4;
    re::DynamicString::setCapacity(this, a3 + 1);
    re::DynamicString::assign(this, a2, a3);
  }
  else
  {
    *(void *)this = a4;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const re::DynamicString *a2)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  unint64_t v4 = *((void *)a2 + 1);
  if (v4) {
    unint64_t v5 = v4 >> 1;
  }
  else {
    unint64_t v5 = v4 >> 1;
  }
  if (v5)
  {
    *(void *)this = *(void *)a2;
    re::DynamicString::setCapacity(this, v5 + 1);
    re::DynamicString::copy(this, a2);
  }
  else
  {
    uint64_t v6 = *(uint64_t **)a2;
    if (!*(void *)a2)
    {
    }
    *(void *)this = v6;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::copy(void *this, const re::DynamicString *a2)
{
  uint64_t v2 = this;
  unint64_t v3 = *((void *)a2 + 1);
  unint64_t v4 = v3 >> 1;
  if ((v3 & 1) == 0) {
    unint64_t v4 = v3 >> 1;
  }
  uint64_t v5 = this[1];
  if (v4)
  {
    if (v5) {
      unint64_t v7 = this[3];
    }
    else {
      unint64_t v7 = 23;
    }
    if (v4 >= v7)
    {
      re::DynamicString::setCapacity(this, v4 + 1);
      uint64_t v5 = v2[1];
    }
    if (v5) {
      uint64_t v9 = (void *)v2[2];
    }
    else {
      uint64_t v9 = (char *)v2 + 9;
    }
    unint64_t v10 = *((void *)a2 + 1);
    if (v10) {
      uint64_t v11 = (char *)*((void *)a2 + 2);
    }
    else {
      uint64_t v11 = (char *)a2 + 9;
    }
    unint64_t v12 = v10 >> 1;
    unint64_t v13 = v10 >> 1;
    if (*((void *)a2 + 1)) {
      unint64_t v13 = v12;
    }
    this = memmove(v9, v11, v13 + 1);
    uint64_t v14 = v2[1];
    if (v14)
    {
      uint64_t v15 = *((void *)a2 + 1);
      uint64_t v16 = 254;
      if (v15) {
        uint64_t v16 = -2;
      }
      v2[1] = v16 & v15 | 1;
    }
    else
    {
      *((unsigned char *)v2 + 8) = *((unsigned char *)a2 + 8) & 0xFE | v14 & 1;
    }
  }
  else
  {
    if (v5)
    {
      this[1] = 1;
      uint64_t v8 = (unsigned char *)this[2];
    }
    else
    {
      *((unsigned char *)this + 8) = v5 & 1;
      uint64_t v8 = (char *)this + 9;
    }
    *uint64_t v8 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    if (!*(void *)this)
    {
      re::DynamicString::setCapacity(this, v3 + 1);
    }
    re::DynamicString::assign(this, *(const char **)a2, v3);
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    if (v5)
    {
      *((void *)this + 1) = 1;
      uint64_t v6 = (unsigned char *)*((void *)this + 2);
    }
    else
    {
      *((unsigned char *)this + 8) = v5 & 1;
      uint64_t v6 = (char *)this + 9;
    }
    *uint64_t v6 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5) {
    size_t v6 = v5 + 1;
  }
  else {
    size_t v6 = 0;
  }
  *(void *)a1 = a3;
  re::DynamicString::setCapacity((void *)a1, v6);
  return re::DynamicString::operator=((re::DynamicString *)a1, a2);
}

void *re::DynamicString::setCapacity(void *this, size_t __n)
{
  size_t v3 = this;
  unint64_t v4 = this[1];
  if (__n <= 0x17)
  {
    if ((v4 & 1) == 0) {
      return this;
    }
    goto LABEL_6;
  }
  if (v4)
  {
LABEL_6:
    int v5 = 0;
    uint64_t v6 = this[3];
    goto LABEL_7;
  }
  int v5 = 1;
  uint64_t v6 = 23;
LABEL_7:
  if (v6 != __n)
  {
    size_t v7 = v5 ? v4 >> 1 : v4 >> 1;
    if (v7 < __n)
    {
      if (__n > 0x16)
      {
        this = (void *)(*(uint64_t (**)(void))(*(void *)*this + 32))();
        if (!this)
        {
          re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "newBuffer", "setCapacity", 455);
          this = (void *)_os_crash();
          __break(1u);
          return this;
        }
        uint64_t v11 = this;
        *(unsigned char *)this = 0;
        unint64_t v12 = v3[1];
        unint64_t v13 = v12 >> 1;
        if ((v12 & 1) == 0) {
          unint64_t v13 = v12 >> 1;
        }
        if (v13)
        {
          if (v12) {
            uint64_t v14 = (const void *)v3[2];
          }
          else {
            uint64_t v14 = (char *)v3 + 9;
          }
          this = memcpy(this, v14, v13 + 1);
          unint64_t v12 = v3[1];
        }
        if (v12)
        {
          this = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v3[2]);
          uint64_t v15 = v3[1];
        }
        else
        {
          uint64_t v15 = v12 & 0xFE;
        }
        v3[2] = v11;
        v3[3] = __n;
        unint64_t v9 = v15 | 1;
      }
      else
      {
        uint64_t v8 = (const void *)this[2];
        *((unsigned char *)this + 8) = v4;
        memcpy((char *)this + 9, v8, __n);
        this = (void *)(*(uint64_t (**)(void, const void *))(*(void *)*v3 + 40))(*v3, v8);
        unint64_t v9 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      }
      v3[1] = v9;
    }
  }
  return this;
}

double re::DynamicString::deinit(re::DynamicString *this)
{
  uint64_t v2 = *(void *)this;
  if (v2)
  {
    if (*((unsigned char *)this + 8)) {
      (*(void (**)(uint64_t, void))(*(void *)v2 + 40))(v2, *((void *)this + 2));
    }
    double result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  return result;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, re::DynamicString *a2)
{
  if (this == a2) {
    return this;
  }
  uint64_t v4 = *(void *)a2;
  if (!*(void *)this)
  {
    if (!v4) {
      return this;
    }
    unint64_t v7 = *((void *)a2 + 1);
    if (v7) {
      unint64_t v8 = v7 >> 1;
    }
    else {
      unint64_t v8 = v7 >> 1;
    }
    *(void *)this = v4;
    re::DynamicString::setCapacity(this, v8 + 1);
LABEL_11:
    re::DynamicString::copy(this, a2);
    return this;
  }
  if (v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    *((void *)this + 1) = 1;
    uint64_t v6 = (unsigned char *)*((void *)this + 2);
  }
  else
  {
    *((unsigned char *)this + 8) = v5 & 1;
    uint64_t v6 = (char *)this + 9;
  }
  *uint64_t v6 = 0;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned char *v11;

  if (this != a2)
  {
    size_t v3 = *(void *)this;
    uint64_t v4 = *(void *)a2;
    if (*(void *)this) {
      uint64_t v5 = v3 == v4;
    }
    else {
      uint64_t v5 = 1;
    }
    if (v5)
    {
      *(void *)this = v4;
      *(void *)a2 = v3;
      uint64_t v6 = *((void *)this + 3);
      *((void *)this + 3) = *((void *)a2 + 3);
      *((void *)a2 + 3) = v6;
      unint64_t v8 = *((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      unint64_t v9 = *((void *)a2 + 2);
      *((void *)this + 1) = *((void *)a2 + 1);
      *((void *)this + 2) = v9;
      *((void *)a2 + 1) = v8;
      *((void *)a2 + 2) = v7;
    }
    else if (v4)
    {
      re::DynamicString::copy(this, a2);
    }
    else
    {
      uint64_t v10 = *((void *)this + 1);
      if (v10)
      {
        *((void *)this + 1) = 1;
        uint64_t v11 = (unsigned char *)*((void *)this + 2);
      }
      else
      {
        *((unsigned char *)this + 8) = v10 & 1;
        uint64_t v11 = (char *)this + 9;
      }
      *uint64_t v11 = 0;
    }
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *a1, char *__s)
{
  v4[0] = __s;
  v4[1] = strlen(__s);
  return re::DynamicString::operator=(a1, (uint64_t)v4);
}

void re::DynamicString::~DynamicString(re::DynamicString *this)
{
}

uint64_t re::DynamicString::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = v2 >> 1;
  if ((v2 & 1) == 0) {
    unint64_t v3 = v2 >> 1;
  }
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, length = %zu", "index <= size()", "operator[]", 180, a2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    if (v2) {
      uint64_t v4 = *(void *)(a1 + 16);
    }
    else {
      uint64_t v4 = a1 + 9;
    }
    return v4 + a2;
  }
  return result;
}

{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t result;

  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = v2 >> 1;
  if ((v2 & 1) == 0) {
    unint64_t v3 = v2 >> 1;
  }
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, length = %zu", "index <= size()", "operator[]", 188, a2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    if (v2) {
      uint64_t v4 = *(void *)(a1 + 16);
    }
    else {
      uint64_t v4 = a1 + 9;
    }
    return v4 + a2;
  }
  return result;
}

BOOL re::DynamicString::operator==(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    unint64_t v2 = *(const char **)(a1 + 16);
  }
  else {
    unint64_t v2 = (const char *)(a1 + 9);
  }
  if (*(void *)(a2 + 8)) {
    unint64_t v3 = *(const char **)(a2 + 16);
  }
  else {
    unint64_t v3 = (const char *)(a2 + 9);
  }
  return strcmp(v2, v3) == 0;
}

BOOL re::DynamicString::operator!=(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    unint64_t v2 = *(const char **)(a1 + 16);
  }
  else {
    unint64_t v2 = (const char *)(a1 + 9);
  }
  if (*(void *)(a2 + 8)) {
    unint64_t v3 = *(const char **)(a2 + 16);
  }
  else {
    unint64_t v3 = (const char *)(a2 + 9);
  }
  return strcmp(v2, v3) != 0;
}

uint64_t re::DynamicString::operator<(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    unint64_t v2 = *(const char **)(a1 + 16);
  }
  else {
    unint64_t v2 = (const char *)(a1 + 9);
  }
  if (*(void *)(a2 + 8)) {
    unint64_t v3 = *(const char **)(a2 + 16);
  }
  else {
    unint64_t v3 = (const char *)(a2 + 9);
  }
  return strcmp(v2, v3) >> 31;
}

void *re::DynamicString::append(re::DynamicString *this, const char *__src, size_t __len)
{
  unint64_t v6 = *((void *)this + 1);
  unint64_t v7 = v6 >> 1;
  if ((v6 & 1) == 0) {
    unint64_t v7 = v6 >> 1;
  }
  unint64_t v8 = v7 + __len;
  if (v6) {
    unint64_t v9 = *((void *)this + 3);
  }
  else {
    unint64_t v9 = 23;
  }
  if (v8 >= v9)
  {
    re::DynamicString::growCapacity(this, v8 + 1);
    unint64_t v6 = *((void *)this + 1);
  }
  if (v6) {
    uint64_t v10 = (char *)*((void *)this + 2);
  }
  else {
    uint64_t v10 = (char *)this + 9;
  }
  if (v6) {
    unint64_t v11 = v6 >> 1;
  }
  else {
    unint64_t v11 = v6 >> 1;
  }
  uint64_t result = memmove(&v10[v11], __src, __len);
  uint64_t v13 = *((void *)this + 1);
  if (v13)
  {
    size_t v14 = v13 + 2 * __len;
    *((void *)this + 1) = v14;
    if (v14) {
      goto LABEL_16;
    }
  }
  else
  {
    *((unsigned char *)this + 8) = v13 + 2 * __len;
    size_t v14 = *((void *)this + 1);
    if (v14)
    {
LABEL_16:
      uint64_t v15 = (char *)*((void *)this + 2);
      goto LABEL_19;
    }
  }
  uint64_t v15 = (char *)this + 9;
LABEL_19:
  if (v14) {
    size_t v16 = v14 >> 1;
  }
  else {
    size_t v16 = v14 >> 1;
  }
  v15[v16] = 0;
  return result;
}

void *re::DynamicString::operator+@<X0>(re::DynamicString *a1@<X0>, uint64_t a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v4 = re::DynamicString::DynamicString(a3, a1);
  unint64_t v5 = *(void *)(a2 + 8);
  if (v5) {
    unint64_t v6 = *(const char **)(a2 + 16);
  }
  else {
    unint64_t v6 = (const char *)(a2 + 9);
  }
  size_t v7 = v5 >> 1;
  size_t v8 = v5 >> 1;
  if (*(void *)(a2 + 8)) {
    size_t v9 = v7;
  }
  else {
    size_t v9 = v8;
  }
  return re::DynamicString::append(v4, v6, v9);
}

void *re::DynamicString::operator+@<X0>(re::DynamicString *a1@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  re::DynamicString::DynamicString(a3, a1);
  size_t v5 = strlen(a2);
  return re::DynamicString::append(a3, a2, v5);
}

uint64_t re::DynamicString::compare(re::DynamicString *this, const re::DynamicString *a2)
{
  if (*((unsigned char *)this + 8)) {
    unint64_t v2 = (const char *)*((void *)this + 2);
  }
  else {
    unint64_t v2 = (char *)this + 9;
  }
  if (*((void *)a2 + 1)) {
    unint64_t v3 = (const char *)*((void *)a2 + 2);
  }
  else {
    unint64_t v3 = (char *)a2 + 9;
  }
  return strcmp(v2, v3);
}

void *re::DynamicString::growCapacity(void *this, size_t a2)
{
  if (this[1])
  {
    size_t v3 = this[3];
    if (v3 >= a2) {
      return this;
    }
    unint64_t v2 = 2 * v3;
  }
  else
  {
    if (a2 <= 0x17) {
      return this;
    }
    unint64_t v2 = 64;
  }
  if (v2 > a2) {
    a2 = v2;
  }
  return re::DynamicString::setCapacity(this, a2);
}

uint64_t re::DynamicString::appendf(re::DynamicString *this, const char *a2, ...)
{
  va_start(va, a2);
  return re::DynamicString::vappendf(this, a2, va);
}

uint64_t re::DynamicString::vappendf(re::DynamicString *this, const char *__format, va_list a3)
{
  unint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    unint64_t v6 = v5 >> 1;
    uint64_t v8 = *((void *)this + 3);
    size_t v7 = (char *)(*((void *)this + 2) + (v5 >> 1));
  }
  else
  {
    unint64_t v6 = v5 >> 1;
    size_t v7 = (char *)this + v6 + 9;
    uint64_t v8 = 23;
  }
  uint64_t result = vsnprintf(v7, v8 - v6, __format, a3);
  unint64_t v10 = *((void *)this + 1);
  if ((result & 0x80000000) == 0)
  {
    unint64_t v11 = v10 >> 1;
    unint64_t v12 = v10 >> 1;
    if (v10) {
      unint64_t v12 = v10 >> 1;
    }
    unint64_t v13 = v12 + result;
    if (v10)
    {
      if (v13 >= *((void *)this + 3))
      {
        size_t v14 = (char *)*((void *)this + 2);
        if (!v14)
        {
LABEL_16:
          re::DynamicString::growCapacity(this, result + v11 + 1);
          unint64_t v17 = *((void *)this + 1);
          if (v17)
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v20 = *((void *)this + 3);
            unint64_t v19 = (char *)(*((void *)this + 2) + (v17 >> 1));
          }
          else
          {
            unint64_t v18 = v17 >> 1;
            unint64_t v19 = (char *)this + v18 + 9;
            uint64_t v20 = 23;
          }
          uint64_t result = vsnprintf(v19, v20 - v18, __format, a3);
          goto LABEL_25;
        }
LABEL_14:
        v14[v12] = 0;
        unint64_t v16 = *((void *)this + 1);
        unint64_t v11 = v16 >> 1;
        if ((v16 & 1) == 0) {
          unint64_t v11 = v16 >> 1;
        }
        goto LABEL_16;
      }
    }
    else if (v13 >= 0x17)
    {
      size_t v14 = (char *)this + 9;
      goto LABEL_14;
    }
LABEL_25:
    uint64_t v22 = *((void *)this + 1);
    if (v22) {
      *((void *)this + 1) = v22 + 2 * (int)result;
    }
    else {
      *((unsigned char *)this + 8) = v22 + 2 * result;
    }
    return result;
  }
  if (v10)
  {
    uint64_t v15 = (char *)*((void *)this + 2);
    if (!v15) {
      return result;
    }
  }
  else
  {
    uint64_t v15 = (char *)this + 9;
  }
  if (v10) {
    unint64_t v21 = v10 >> 1;
  }
  else {
    unint64_t v21 = v10 >> 1;
  }
  v15[v21] = 0;
  return result;
}

uint64_t re::DynamicString::assignf(re::DynamicString *this, const char *a2, ...)
{
  va_start(va, a2);
  return re::DynamicString::vassignf(this, a2, va);
}

uint64_t re::DynamicString::vassignf(re::DynamicString *this, const char *__format, va_list a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 1) = 1;
    uint64_t v4 = (unsigned char *)*((void *)this + 2);
  }
  else
  {
    *((unsigned char *)this + 8) = v3 & 1;
    uint64_t v4 = (char *)this + 9;
  }
  *uint64_t v4 = 0;
  return re::DynamicString::vappendf(this, __format, a3);
}

void *re::DynamicString::resize(void *this, unint64_t a2, int a3)
{
  unint64_t v3 = this[1];
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (v4 != a2)
  {
    size_t v7 = this;
    this = re::DynamicString::growCapacity(this, a2 + 1);
    unint64_t v8 = v7[1];
    unint64_t v9 = v8 >> 1;
    if ((v8 & 1) == 0) {
      unint64_t v9 = v8 >> 1;
    }
    if (a2 > v9)
    {
      if (v8) {
        unint64_t v10 = (char *)v7[2];
      }
      else {
        unint64_t v10 = (char *)v7 + 9;
      }
      this = memset(&v10[v9], a3, a2 - v9);
      unint64_t v8 = v7[1];
    }
    if (v8) {
      unint64_t v11 = (char *)v7[2];
    }
    else {
      unint64_t v11 = (char *)v7 + 9;
    }
    v11[a2] = 0;
    uint64_t v12 = v7[1];
    if (v12) {
      v7[1] = (2 * a2) | 1;
    }
    else {
      *((unsigned char *)v7 + 8) = v12 & 1 | (2 * a2);
    }
  }
  return this;
}

void *re::DynamicString::trimExcess(void *this)
{
  unint64_t v2 = this + 1;
  unint64_t v1 = this[1];
  if (v1)
  {
    if (v1 > 1)
    {
      return re::DynamicString::setCapacity(this, (v1 >> 1) + 1);
    }
    else
    {
      this = (void *)(*(uint64_t (**)(void, void))(*(void *)*this + 40))(*this, this[2]);
      *unint64_t v2 = 0;
      v2[1] = 0;
      void v2[2] = 0;
    }
  }
  return this;
}

uint64_t re::DynamicString::insert(re::DynamicString *this, unint64_t a2, uint64_t a3, uint64_t __c)
{
  unint64_t v5 = *((void *)this + 1);
  unint64_t v6 = v5 >> 1;
  unint64_t v7 = v5 >> 1;
  if (v5) {
    unint64_t v8 = v5 >> 1;
  }
  else {
    unint64_t v8 = v5 >> 1;
  }
  if (v8 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, a3, __c, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "insert", 529, a2, v8);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    int v9 = __c;
    size_t v12 = a3 + v8 + 1;
    if (v5) {
      unint64_t v13 = *((void *)this + 3);
    }
    else {
      unint64_t v13 = 23;
    }
    if (v12 >= v13)
    {
      re::DynamicString::growCapacity(this, v12);
      unint64_t v5 = *((void *)this + 1);
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = v5 >> 1;
    }
    if ((v5 & 1) == 0) {
      unint64_t v6 = v7;
    }
    if (v6 != a2)
    {
      if (v5) {
        size_t v14 = (char *)*((void *)this + 2);
      }
      else {
        size_t v14 = (char *)this + 9;
      }
      memmove(&v14[a2 + a3], &v14[a2], v6 - a2);
      unint64_t v5 = *((void *)this + 1);
    }
    if (v5)
    {
      unint64_t v15 = v5 + 2 * a3;
      *((void *)this + 1) = v15;
    }
    else
    {
      *((unsigned char *)this + 8) = v5 + 2 * a3;
      unint64_t v15 = *((void *)this + 1);
    }
    if (v15) {
      unint64_t v16 = (char *)*((void *)this + 2);
    }
    else {
      unint64_t v16 = (char *)this + 9;
    }
    uint64_t result = (uint64_t)memset(&v16[a2], v9, a3 + a2);
    unint64_t v18 = *((void *)this + 1);
    if (v18) {
      unint64_t v19 = (char *)*((void *)this + 2);
    }
    else {
      unint64_t v19 = (char *)this + 9;
    }
    if (v18) {
      unint64_t v20 = v18 >> 1;
    }
    else {
      unint64_t v20 = v18 >> 1;
    }
    v19[v20] = 0;
  }
  return result;
}

uint64_t re::DynamicString::insert(re::DynamicString *this, unint64_t a2, const char *__src, size_t __len)
{
  unint64_t v5 = *((void *)this + 1);
  unint64_t v6 = v5 >> 1;
  if ((v5 & 1) == 0) {
    unint64_t v6 = v5 >> 1;
  }
  if (v6 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, __src, __len, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "insert", 561, a2, v6);
    _os_crash();
    __break(1u);
    goto LABEL_28;
  }
  size_t v10 = __len + v6 + 1;
  if (v5) {
    unint64_t v11 = *((void *)this + 3);
  }
  else {
    unint64_t v11 = 23;
  }
  if (v10 >= v11)
  {
    re::DynamicString::growCapacity(this, v10);
    unint64_t v5 = *((void *)this + 1);
  }
  if (v5)
  {
    unint64_t v13 = (char *)*((void *)this + 2);
    if (v13)
    {
      unint64_t v12 = v5 >> 1;
      if (v5 >> 1 == a2) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
LABEL_28:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Unexpected null buffer after growCapacity", "data() != nullptr", "insert", 567);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v12 = v5 >> 1;
  if (v12 == a2) {
    goto LABEL_15;
  }
  unint64_t v13 = (char *)this + 9;
LABEL_14:
  memmove(&v13[a2 + __len], &v13[a2], v12 - a2);
  unint64_t v5 = *((void *)this + 1);
LABEL_15:
  if (v5) {
    size_t v14 = (char *)*((void *)this + 2);
  }
  else {
    size_t v14 = (char *)this + 9;
  }
  uint64_t result = (uint64_t)memmove(&v14[a2], __src, __len);
  uint64_t v16 = *((void *)this + 1);
  if (v16)
  {
    size_t v17 = v16 + 2 * __len;
    *((void *)this + 1) = v17;
    if (v17) {
      goto LABEL_20;
    }
LABEL_22:
    unint64_t v18 = (char *)this + 9;
    goto LABEL_23;
  }
  *((unsigned char *)this + 8) = v16 + 2 * __len;
  size_t v17 = *((void *)this + 1);
  if ((v17 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_20:
  unint64_t v18 = (char *)*((void *)this + 2);
LABEL_23:
  if (v17) {
    size_t v19 = v17 >> 1;
  }
  else {
    size_t v19 = v17 >> 1;
  }
  v18[v19] = 0;
  return result;
}

uint64_t re::DynamicString::removeAt(re::DynamicString *this, unint64_t a2)
{
  unint64_t v2 = *((void *)this + 1);
  if (v2) {
    unint64_t v3 = v2 >> 1;
  }
  else {
    unint64_t v3 = v2 >> 1;
  }
  if (v3 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "removeAt", 590, a2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    if (v2)
    {
      unint64_t v5 = (char *)*((void *)this + 2);
      unint64_t v6 = &v5[v2 >> 1];
    }
    else
    {
      unint64_t v5 = (char *)this + 9;
      unint64_t v6 = (char *)this + (v2 >> 1) + 9;
    }
    uint64_t result = (uint64_t)&v5[a2];
    if (v6 != &v5[a2])
    {
      uint64_t result = (uint64_t)memmove((void *)result, (const void *)(result + 1), (size_t)&v6[-result]);
      unint64_t v2 = *((void *)this + 1);
    }
    if (v2) {
      *((void *)this + 1) = (v2 | 1) - 2;
    }
    else {
      *((unsigned char *)this + 8) = v2 - 2;
    }
  }
  return result;
}

void *re::DynamicString::substr@<X0>(re::DynamicString *this@<X0>, unint64_t a2@<X1>, size_t a3@<X2>, re::DynamicString *a4@<X8>)
{
  unint64_t v6 = *((void *)this + 1);
  if (v6) {
    unint64_t v7 = v6 >> 1;
  }
  else {
    unint64_t v7 = v6 >> 1;
  }
  if (v7 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "substr", 610, a2, v7);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    if (v7 - a2 >= a3) {
      size_t v9 = a3;
    }
    else {
      size_t v9 = v7 - a2;
    }
    *((void *)a4 + 1) = 0;
    *((void *)a4 + 2) = 0;
    *((void *)a4 + 3) = 0;
    re::DynamicString::setCapacity(a4, 0);
    *(void *)a4 = *(void *)this;
    re::DynamicString::setCapacity(a4, v9);
    if (*((unsigned char *)this + 8)) {
      size_t v10 = (char *)*((void *)this + 2);
    }
    else {
      size_t v10 = (char *)this + 9;
    }
    return re::DynamicString::assign(a4, &v10[a2], v9);
  }
  return result;
}

char *re::DynamicString::find@<X0>(re::DynamicString *this@<X0>, char *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = *((void *)this + 1);
  unint64_t v7 = v6 >> 1;
  if ((v6 & 1) == 0) {
    unint64_t v7 = v6 >> 1;
  }
  if (v7 < a4)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset <= this->size()", "find", 631, a4, v7);
    uint64_t result = (char *)_os_crash();
    __break(1u);
  }
  else
  {
    if (v6) {
      size_t v9 = (char *)*((void *)this + 2);
    }
    else {
      size_t v9 = (char *)this + 9;
    }
    size_t v10 = &v9[v7];
    uint64_t result = (char *)std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>((unsigned __int8 *)&v9[a4], (uint64_t)&v9[v7], (unsigned __int8 *)a2, (unsigned __int8 *)&a2[a3]);
    if (v10 == result)
    {
      *(unsigned char *)a5 = 0;
    }
    else
    {
      if (*((unsigned char *)this + 8)) {
        unint64_t v12 = (char *)*((void *)this + 2);
      }
      else {
        unint64_t v12 = (char *)this + 9;
      }
      *(unsigned char *)a5 = 1;
      *(void *)(a5 + 8) = result - v12;
    }
  }
  return result;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  unint64_t v3 = *(void *)(this + 8);
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (v4) {
    return re::DynamicString::rfind(this, a2, v4 - 1, (uint64_t)a3);
  }
  *a3 = 0;
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void *)(this + 8);
  unint64_t v5 = v4 >> 1;
  if ((v4 & 1) == 0) {
    unint64_t v5 = v4 >> 1;
  }
  if (v5 <= a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < size()", "rfind", 667, a3, v5);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if (v4) {
      uint64_t v6 = *(void *)(this + 16);
    }
    else {
      uint64_t v6 = this + 9;
    }
    uint64_t v7 = this + 9;
    uint64_t v8 = a3 + v6;
    uint64_t v9 = -(uint64_t)(a3 + v6);
    uint64_t v10 = v8 + 1;
    while (*(unsigned __int8 *)(v10 - 1) != a2)
    {
      uint64_t v11 = this + 9;
      if (v4) {
        uint64_t v11 = *(void *)(this + 16);
      }
      ++v9;
      if (--v10 == v11)
      {
        *(unsigned char *)a4 = 0;
        return this;
      }
    }
    if (v4) {
      uint64_t v7 = *(void *)(this + 16);
    }
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = -(v7 + v9);
  }
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, const char *__s@<X1>, unsigned char *a3@<X8>)
{
  unint64_t v4 = *(void *)(this + 8);
  if (v4) {
    unint64_t v5 = v4 >> 1;
  }
  else {
    unint64_t v5 = v4 >> 1;
  }
  if (v5)
  {
    uint64_t v7 = this;
    size_t v8 = strlen(__s);
    return re::DynamicString::rfind(v7, __s, v8, v5 - 1, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
  }
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v5 = *(void *)(this + 8);
  unint64_t v6 = v5 >> 1;
  if ((v5 & 1) == 0) {
    unint64_t v6 = v5 >> 1;
  }
  if (v6 <= a4)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < this->size()", "rfind", 700, a4, v6);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if (v5)
    {
      uint64_t v7 = *(unsigned __int8 **)(this + 16);
      if (!a3)
      {
LABEL_25:
        *(unsigned char *)a5 = 0;
        return this;
      }
    }
    else
    {
      uint64_t v7 = (unsigned __int8 *)(this + 9);
      if (!a3) {
        goto LABEL_25;
      }
    }
    size_t v8 = &v7[a4];
    uint64_t v9 = (uint64_t)&v7[a4 + 1];
    if (v7 == (unsigned __int8 *)v9) {
      goto LABEL_25;
    }
    int v12 = *(unsigned __int8 *)a2;
    uint64_t v10 = a2 + 1;
    int v11 = v12;
    uint64_t v13 = a3 - 1;
    uint64_t v14 = (uint64_t)&v7[a4 + 1];
    do
    {
      unint64_t v15 = v7;
      while (*v15 != v11)
      {
        if (v15++ == v8) {
          goto LABEL_22;
        }
      }
      uint64_t v17 = 0;
      while (v13 != v17)
      {
        if (&v15[v17] == v8) {
          goto LABEL_22;
        }
        int v18 = v15[v17 + 1];
        int v19 = v10[v17++];
        if (v18 != v19) {
          goto LABEL_21;
        }
      }
      uint64_t v14 = (uint64_t)v15;
LABEL_21:
      uint64_t v7 = v15 + 1;
    }
    while (v15 != v8);
LABEL_22:
    if (v14 == v9) {
      goto LABEL_25;
    }
    if (v5) {
      uint64_t v20 = *(void *)(this + 16);
    }
    else {
      uint64_t v20 = this + 9;
    }
    *(unsigned char *)a5 = 1;
    *(void *)(a5 + 8) = v14 - v20;
  }
  return this;
}

uint64_t re::DynamicString::toLowerCase(uint64_t this)
{
  unint64_t v1 = *(void *)(this + 8);
  if (v1) {
    unint64_t v2 = *(char **)(this + 16);
  }
  else {
    unint64_t v2 = (char *)(this + 9);
  }
  if (v1) {
    unint64_t v3 = v1 >> 1;
  }
  else {
    unint64_t v3 = v1 >> 1;
  }
  for (; v3; --v3)
  {
    this = __tolower(*v2);
    *v2++ = this;
  }
  return this;
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::Allocator *a2@<X1>, re::DynamicString *a3@<X8>, ...)
{
  va_start(va, a3);
  *((void *)a3 + 2) = 0;
  *((void *)a3 + 3) = 0;
  *(void *)a3 = this;
  *((void *)a3 + 1) = 0;
  re::DynamicString::setCapacity(a3, 0);
  return re::DynamicString::vassignf(a3, (const char *)a2, va);
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::DynamicString *a2@<X8>, ...)
{
  va_start(va, a2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::DynamicString::vassignf(a2, (const char *)this, va);
}

__n128 re::internal::anonymous namespace'::RegexOperationList::parseRegex(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned char *a6)
{
  unint64_t v6 = (char *)a4;
  *(void *)(a2 + 16) = 0;
  ++*(_DWORD *)(a2 + 24);
  if (a4 >= a5)
  {
LABEL_187:
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = v6;
    return result;
  }
  float v109 = (_anonymous_namespace_ *)(a3 + 320);
  float v105 = (_anonymous_namespace_ *)(a3 + 40);
  unint64_t v100 = (_anonymous_namespace_ *)(a3 + 80);
  uint64_t v110 = a3 + 240;
  float v101 = (_anonymous_namespace_ *)(a3 + 200);
  uint64_t v102 = (void *)(a3 + 160);
  float v97 = (_anonymous_namespace_ *)(a3 + 120);
  unint64_t v98 = (re::DynamicString *)&v127[16];
  int v99 = (_OWORD *)(a1 + 8);
  float v103 = (_anonymous_namespace_ *)(a3 + 280);
  float v104 = a6 + 1;
  while (1)
  {
    v117.n128_u8[0] = 0;
    v117.n128_u64[1] = -1;
    float v118 = 0;
    uint64_t v122 = 0;
    uint64_t v119 = 0;
    uint64_t v120 = 0;
    int v121 = 1;
    if (*v6 != 40)
    {
      int v14 = 1;
      unsigned __int8 v113 = 1;
      *(void *)&long long v114 = 0;
LABEL_28:
      int v15 = 1;
      goto LABEL_29;
    }
    uint64_t v9 = (unsigned __int8 *)(v6 + 1);
    do
    {
      if (v9 == a5) {
        goto LABEL_26;
      }
      uint64_t v133 = 0;
      uint64_t v131 = 0;
      __n128 v130 = 0uLL;
      int v132 = 0;
      if (v127[0])
      {
        int v11 = *(unsigned __int8 **)&v127[8];
        if (*(void *)&v127[8])
        {
          __endptr[0] = *(char **)(a3 + 336);
          re::DynamicArray<unsigned long>::add(&v118, __endptr);
          int v12 = *v11;
          if (v12 == 41)
          {
            int v13 = 1;
            unsigned __int8 v113 = 1;
            *(void *)&long long v114 = v11 + 1;
            uint64_t v9 = v11;
          }
          else
          {
            if (v12 == 124) {
              int v13 = 2;
            }
            else {
              int v13 = 3;
            }
            if (v12 == 124) {
              uint64_t v9 = v11 + 1;
            }
            else {
              uint64_t v9 = v11;
            }
          }
        }
        else
        {
          int v13 = 3;
        }
      }
      else
      {
        *(_OWORD *)__endptr = *(_OWORD *)&v127[8];
        re::DynamicString::DynamicString((re::DynamicString *)&v124, (const re::DynamicString *)&v128);
        unsigned __int8 v113 = 0;
        long long v114 = *(_OWORD *)__endptr;
        *(void *)float v115 = v124;
        unint64_t v116 = v126;
        __n128 result = v125;
        *(__n128 *)&v115[8] = v125;
        if (v128.n128_u64[0] && (v128.n128_u8[8] & 1) != 0) {
          (*(void (**)(unint64_t, uint64_t))(*(void *)v128.n128_u64[0] + 40))(v128.n128_u64[0], v129);
        }
        int v13 = 1;
      }
      if (v130.n128_u64[0] && v133) {
        (*(void (**)(unint64_t))(*(void *)v130.n128_u64[0] + 40))(v130.n128_u64[0]);
      }
    }
    while (v13 == 2);
    if (v13 == 3)
    {
LABEL_26:
      re::DynamicString::format((re::DynamicString *)"Regular expression group missing corresponding ')'.", (re::DynamicString *)v127, v97, v98);
      int v14 = 0;
      int v15 = 0;
      __n128 result = *(__n128 *)v127;
      unsigned __int8 v113 = 0;
      *(void *)&long long v114 = 100;
      *((void *)&v114 + 1) = re::FoundationErrorCategory(void)::instance;
      *(_OWORD *)float v115 = *(_OWORD *)v127;
      *(void *)&v115[16] = *(void *)&v127[16];
      unint64_t v116 = v128.n128_u64[0];
      goto LABEL_29;
    }
    int v14 = v113;
    if (!v113)
    {
      int v15 = 0;
      goto LABEL_29;
    }
    if (!(void)v114) {
      goto LABEL_28;
    }
    v117.n128_u8[0] = 5;
    unint64_t v42 = *(void *)(a3 + 128);
    unint64_t v43 = *(void *)(a3 + 136);
    v117.n128_u64[1] = v43;
    if (v43 >= v42)
    {
      unint64_t v44 = v43 + 1;
      if (v42 < v43 + 1)
      {
        if (*(void *)v97)
        {
          uint64_t v45 = 2 * v42;
          BOOL v22 = v42 == 0;
          unint64_t v46 = 8;
          if (!v22) {
            unint64_t v46 = v45;
          }
          if (v46 <= v44) {
            unint64_t v47 = v44;
          }
          else {
            unint64_t v47 = v46;
          }
          re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v97, v47);
        }
        else
        {
          re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v97, v44);
          ++*(_DWORD *)(a3 + 144);
        }
      }
    }
    int v15 = 0;
    uint64_t v91 = *(void *)(a3 + 152) + 40 * *(void *)(a3 + 136);
    *(void *)(v91 + 32) = 0;
    *(_DWORD *)(v91 + 24) = 0;
    *(void *)(v91 + 8) = 0;
    *(void *)(v91 + 16) = 0;
    *(void *)uint64_t v91 = 0;
    *(void *)uint64_t v91 = v118;
    float v118 = 0;
    *(void *)(v91 + 8) = v119;
    uint64_t v119 = 0;
    uint64_t v92 = *(void *)(v91 + 16);
    *(void *)(v91 + 16) = v120;
    uint64_t v120 = v92;
    uint64_t v93 = *(void *)(v91 + 32);
    *(void *)(v91 + 32) = v122;
    uint64_t v122 = v93;
    ++v121;
    ++*(_DWORD *)(v91 + 24);
    ++*(void *)(a3 + 136);
    ++*(_DWORD *)(a3 + 144);
LABEL_29:
    uint64_t v16 = v118;
    if (v118 && v122) {
      uint64_t v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v118 + 40))();
    }
    if (!v15) {
      break;
    }
    *(void *)float v127 = &unk_26E6DE508;
    uint64_t v129 = 0;
    *(void *)&v127[16] = 0;
    v128.n128_u64[0] = 0;
    *(void *)&v127[8] = 0;
    v128.n128_u32[2] = 1;
    int v17 = *v6;
    if (v17 == 91)
    {
      int v18 = v6 + 1;
      if (v6 + 1 == (char *)a5)
      {
LABEL_74:
        int v18 = (char *)a5;
        if (*a5 != 93)
        {
          re::DynamicString::format((re::DynamicString *)"Character set missing corresponding ']'.", (re::DynamicString *)__endptr);
          int v14 = 0;
          __n128 result = *(__n128 *)__endptr;
          unsigned __int8 v113 = 0;
          *(void *)&long long v114 = 100;
          *((void *)&v114 + 1) = re::FoundationErrorCategory(void)::instance;
          *(_OWORD *)float v115 = *(_OWORD *)__endptr;
          *(void *)&v115[16] = v124;
          unint64_t v116 = v125.n128_u64[0];
          goto LABEL_93;
        }
      }
      else
      {
        while (*v18 != 93)
        {
          v130.n128_u8[0] = 0;
          v130.n128_u64[1] = -1;
          __endptr[0] = (char *)&unk_26E6DE5A8;
          if (a5 - (unsigned __int8 *)v18 >= 2 && *v18 == 92)
          {
            LOBYTE(__endptr[1]) = v18[1];
            v18 += 2;
            v130.n128_u8[0] = 2;
            v130.n128_u64[1] = *(void *)(a3 + 56);
          }
          else
          {
            __endptr[0] = (char *)&unk_26E6DE548;
            if ((unint64_t)(a5 - (unsigned __int8 *)v18) < 3) {
              goto LABEL_55;
            }
            uint64_t v19 = 0;
            int v20 = *v18;
            do
            {
              BOOL v22 = v21 == v20 || v19++ == 8;
            }
            while (!v22);
            if (v21 == v20 || v18[1] != 45) {
              goto LABEL_55;
            }
            uint64_t v23 = 0;
            unint64_t v25 = v18 + 2;
            int v24 = v18[2];
            do
            while (v26 != v24 && v23++ != 8);
            if (v26 == v24)
            {
LABEL_55:
              __endptr[0] = (char *)&unk_26E6DE5D8;
              char v28 = *v18++;
              LOBYTE(__endptr[1]) = v28;
              v130.n128_u8[0] = 1;
              v130.n128_u64[1] = *(void *)(a3 + 16);
            }
            else
            {
              if (v24 >= v20) {
                unint64_t v25 = v18;
              }
              LOBYTE(__endptr[1]) = *v25;
              if (v20 <= v24) {
                LOBYTE(v20) = v24;
              }
              BYTE1(__endptr[1]) = v20;
              v130.n128_u8[0] = 3;
              unint64_t v29 = *(void *)(a3 + 88);
              unint64_t v30 = *(void *)(a3 + 96);
              v130.n128_u64[1] = v30;
              if (v30 >= v29)
              {
                unint64_t v31 = v30 + 1;
                if (v29 < v30 + 1)
                {
                  if (*(void *)v100)
                  {
                    uint64_t v32 = 2 * v29;
                    BOOL v22 = v29 == 0;
                    unint64_t v33 = 8;
                    if (!v22) {
                      unint64_t v33 = v32;
                    }
                    if (v33 <= v31) {
                      unint64_t v34 = v31;
                    }
                    else {
                      unint64_t v34 = v33;
                    }
                  }
                  else
                  {
                    ++*(_DWORD *)(a3 + 104);
                  }
                }
              }
              v18 += 3;
              uint64_t v35 = *(void *)(a3 + 112) + 16 * *(void *)(a3 + 96);
              *(void *)uint64_t v35 = &unk_26E6DE548;
              *(_WORD *)(v35 + 8) = __endptr[1];
              ++*(void *)(a3 + 96);
              ++*(_DWORD *)(a3 + 104);
            }
          }
          __endptr[0] = *(char **)(a3 + 256);
          re::DynamicArray<unsigned long>::add(&v127[8], __endptr);
          if (v18 == (char *)a5) {
            goto LABEL_74;
          }
        }
      }
      unsigned __int8 v113 = 1;
      *(void *)&long long v114 = v18 + 1;
      v117.n128_u8[0] = 6;
      unint64_t v36 = *(void *)(a3 + 168);
      v117.n128_u64[1] = *(void *)(a3 + 176);
      unint64_t v37 = v117.n128_u64[1] + 1;
      if (v117.n128_u64[1] >= v36 && v36 < v37)
      {
        if (*v102)
        {
          uint64_t v80 = 2 * v36;
          BOOL v22 = v36 == 0;
          unint64_t v81 = 8;
          if (!v22) {
            unint64_t v81 = v80;
          }
          if (v81 <= v37) {
            unint64_t v82 = v117.n128_u64[1] + 1;
          }
          else {
            unint64_t v82 = v81;
          }
        }
        else
        {
          ++*(_DWORD *)(a3 + 184);
        }
      }
      uint64_t v39 = *(void *)(a3 + 192) + 48 * *(void *)(a3 + 176);
      *(void *)(v39 + 40) = 0;
      *(_DWORD *)(v39 + 32) = 0;
      *(void *)(v39 + 16) = 0;
      *(void *)(v39 + 24) = 0;
      *(void *)uint64_t v39 = &unk_26E6DE508;
      *(void *)(v39 + 8) = 0;
      *(void *)(v39 + 8) = *(void *)&v127[8];
      *(void *)&v127[8] = 0;
      *(void *)(v39 + 16) = *(void *)&v127[16];
      *(void *)&v127[16] = 0;
      unint64_t v40 = *(void *)(v39 + 24);
      *(void *)(v39 + 24) = v128.n128_u64[0];
      v128.n128_u64[0] = v40;
      uint64_t v41 = *(void *)(v39 + 40);
      *(void *)(v39 + 40) = v129;
      uint64_t v129 = v41;
      ++v128.n128_u32[2];
      ++*(_DWORD *)(v39 + 32);
      ++*(void *)(a3 + 176);
      ++*(_DWORD *)(a3 + 184);
      int v14 = 1;
    }
    else
    {
      int v14 = 1;
      unsigned __int8 v113 = 1;
      *(void *)&long long v114 = 0;
    }
LABEL_93:
    *(void *)float v127 = &unk_26E6DE508;
    if (*(void *)&v127[8] && v129) {
      (*(void (**)(void))(**(void **)&v127[8] + 40))(*(void *)&v127[8]);
    }
    if (v17 == 91) {
      break;
    }
    *(void *)float v127 = &unk_26E6DE578;
    v127[8] = 0;
    if (v6 == (char *)a5) {
      goto LABEL_122;
    }
    int v59 = *v6;
    switch(v59)
    {
      case '$':
        char v60 = 3;
        goto LABEL_173;
      case '.':
        char v60 = 1;
LABEL_173:
        v127[8] = v60;
        unsigned __int8 v113 = 1;
        *(void *)&long long v114 = v6 + 1;
        v117.n128_u8[0] = 4;
        unint64_t v83 = *(void *)(a3 + 208);
        unint64_t v84 = *(void *)(a3 + 216);
        v117.n128_u64[1] = v84;
        if (v84 >= v83)
        {
          unint64_t v85 = v84 + 1;
          if (v83 < v84 + 1)
          {
            if (*(void *)v101)
            {
              uint64_t v86 = 2 * v83;
              BOOL v22 = v83 == 0;
              unint64_t v87 = 8;
              if (!v22) {
                unint64_t v87 = v86;
              }
              if (v87 <= v85) {
                unint64_t v88 = v85;
              }
              else {
                unint64_t v88 = v87;
              }
            }
            else
            {
              ++*(_DWORD *)(a3 + 224);
            }
          }
        }
        uint64_t v89 = *(void *)(a3 + 216);
        uint64_t v90 = *(void *)(a3 + 232) + 16 * v89;
        *(void *)uint64_t v90 = &unk_26E6DE578;
        *(unsigned char *)(v90 + 8) = v127[8];
        *(void *)(a3 + 216) = v89 + 1;
        ++*(_DWORD *)(a3 + 224);
        goto LABEL_98;
      case '^':
        char v60 = 2;
        goto LABEL_173;
    }
LABEL_122:
    *(void *)float v127 = &unk_26E6DE5A8;
    v127[8] = -1;
    if (a5 - (unsigned __int8 *)v6 >= 2 && *v6 == 92)
    {
      v127[8] = v6[1];
      unsigned __int8 v113 = 1;
      *(void *)&long long v114 = v6 + 2;
      v117.n128_u8[0] = 2;
      v117.n128_u64[1] = *(void *)(a3 + 56);
    }
    else
    {
      *(void *)float v127 = &unk_26E6DE5D8;
      v127[8] = -1;
      if (v6 == (char *)a5) {
        goto LABEL_187;
      }
      uint64_t v63 = 0;
      int v64 = *v6;
      v127[8] = *v6;
      do
      while (v65 != v64 && v63++ != 8);
      if (v65 == v64) {
        goto LABEL_187;
      }
      unsigned __int8 v113 = 1;
      *(void *)&long long v114 = v6 + 1;
      v117.n128_u8[0] = 1;
      v117.n128_u64[1] = *(void *)(a3 + 16);
    }
LABEL_98:
    BOOL v48 = (char *)v114;
    if (!(void)v114) {
      goto LABEL_187;
    }
    uint64_t v49 = *(void *)(a3 + 256);
    if ((unsigned __int8 *)v114 == a5)
    {
      LODWORD(v54) = 1;
      *(unsigned char *)a1 = 1;
      *(void *)(a1 + 8) = a5;
      if (!a5) {
        goto LABEL_187;
      }
      BOOL v50 = 0;
      unint64_t v6 = (char *)a5;
      int v52 = 1;
      goto LABEL_148;
    }
    BOOL v50 = 0;
    int v51 = *(char *)v114;
    int v52 = 1;
    if (v51 > 62)
    {
      if (v51 == 63)
      {
        LODWORD(v54) = 0;
        int v62 = *(unsigned __int8 *)(v114 + 1);
        BOOL v48 = (char *)(v114 + 1);
        BOOL v50 = v62 != 63;
        if (v62 == 63) {
          BOOL v48 = (char *)(v114 + 2);
        }
        int v52 = 1;
      }
      else
      {
        LODWORD(v54) = 1;
        if (v51 == 123)
        {
          __endptr[0] = 0;
          unint64_t v55 = strtol((const char *)(v114 + 1), __endptr, 10);
          if ((v55 & 0x8000000000000000) != 0)
          {
            float32x2_t v94 = "Repetition brace requires valid positive number.";
LABEL_198:
            re::DynamicString::format((re::DynamicString *)v94, (re::DynamicString *)v127, v97);
            __n128 result = *(__n128 *)v127;
            uint64_t v95 = *(void *)&v127[16];
            unint64_t v96 = v128.n128_u64[0];
            *(unsigned char *)a1 = 0;
            *(void *)(a1 + 8) = 100;
            *(void *)(a1 + 16) = re::FoundationErrorCategory(void)::instance;
            *(__n128 *)(a1 + 24) = result;
            *(void *)(a1 + 40) = v95;
            *(void *)(a1 + 48) = v96;
            return result;
          }
          unint64_t v54 = v55;
          if (v55 >= 0xFFFFFFFF)
          {
            float32x2_t v94 = "Repetition brace exceeded maximum match count.";
            goto LABEL_198;
          }
          long long v56 = __endptr[0];
          int v57 = *__endptr[0];
          if (v57 == 44)
          {
            unint64_t v58 = strtol(__endptr[0] + 1, __endptr, 10);
            if ((v58 & 0x8000000000000000) != 0)
            {
              float32x2_t v94 = "Repetition brace maximum requires valid positive number.";
              goto LABEL_198;
            }
            int v52 = v58;
            if (v58 >= 0xFFFFFFFF)
            {
              float32x2_t v94 = "Repetition brace maximum exceeded maximum match count.";
              goto LABEL_198;
            }
            if (v58 < v54)
            {
              float32x2_t v94 = "Repetition brace maximum must be larger than the minimum.";
              goto LABEL_198;
            }
            long long v56 = __endptr[0];
            int v57 = *__endptr[0];
          }
          else
          {
            int v52 = v55;
          }
          if (v57 != 125)
          {
            float32x2_t v94 = "Repetition brace expected closing '}'.";
            goto LABEL_198;
          }
          int v68 = v56[1];
          int v67 = v56 + 1;
          BOOL v50 = v68 != 63;
          if (v68 == 63) {
            BOOL v48 = v67 + 1;
          }
          else {
            BOOL v48 = v67;
          }
        }
      }
      goto LABEL_147;
    }
    if (v51 == 42)
    {
      LODWORD(v54) = 0;
      int v61 = *(unsigned __int8 *)(v114 + 1);
      BOOL v48 = (char *)(v114 + 1);
      BOOL v50 = v61 != 63;
      if (v61 == 63) {
        BOOL v48 = (char *)(v114 + 2);
      }
    }
    else
    {
      if (v51 != 43)
      {
        LODWORD(v54) = 1;
        goto LABEL_147;
      }
      int v53 = *(unsigned __int8 *)(v114 + 1);
      BOOL v48 = (char *)(v114 + 1);
      BOOL v50 = v53 != 63;
      if (v53 == 63) {
        BOOL v48 = (char *)(v114 + 2);
      }
      LODWORD(v54) = 1;
    }
    int v52 = 0x7FFFFFFF;
LABEL_147:
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = v48;
    unint64_t v6 = v48;
LABEL_148:
    *(void *)float v127 = *(void *)(a3 + 296);
    re::DynamicArray<unsigned long>::add((void *)a2, v127);
    unint64_t v69 = *(void *)(a3 + 288);
    unint64_t v70 = *(void *)(a3 + 296);
    if (v70 >= v69)
    {
      unint64_t v71 = v70 + 1;
      if (v69 < v70 + 1)
      {
        if (*(void *)v103)
        {
          uint64_t v72 = 2 * v69;
          BOOL v22 = v69 == 0;
          unint64_t v73 = 8;
          if (!v22) {
            unint64_t v73 = v72;
          }
          if (v73 <= v71) {
            unint64_t v74 = v71;
          }
          else {
            unint64_t v74 = v73;
          }
          re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v103, v74);
        }
        else
        {
          re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v103, v71);
          ++*(_DWORD *)(a3 + 304);
        }
      }
    }
    uint64_t v75 = *(void *)(a3 + 312) + 24 * *(void *)(a3 + 296);
    *(void *)uint64_t v75 = v49;
    *(unsigned char *)(v75 + 8) = v50;
    *(unsigned char *)(v75 + 11) = v112;
    *(_WORD *)(v75 + 9) = v111;
    *(_DWORD *)(v75 + 12) = v54;
    *(_DWORD *)(v75 + 16) = v52;
    ++*(void *)(a3 + 296);
    ++*(_DWORD *)(a3 + 304);
    int v76 = *a6;
    if (*a6)
    {
      char v77 = 0;
      int v78 = v104;
      do
      {
        v77 |= v76 == *v6;
        int v79 = *v78++;
        int v76 = v79;
      }
      while (v79);
      if (v77) {
        goto LABEL_187;
      }
    }
    if (v6 >= (char *)a5) {
      goto LABEL_187;
    }
  }
  if (v14) {
    goto LABEL_98;
  }
  *(_OWORD *)float v127 = v114;
  re::DynamicString::DynamicString(v98, (const re::DynamicString *)v115);
  *(unsigned char *)a1 = 0;
  *int v99 = *(_OWORD *)v127;
  *(void *)(a1 + 24) = *(void *)&v127[16];
  *(void *)(a1 + 48) = v129;
  __n128 result = v128;
  *(__n128 *)(a1 + 32) = v128;
  if (*(void *)v115 && (v115[8] & 1) != 0) {
    (*(void (**)(void))(**(void **)v115 + 40))();
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::anonymous namespace'::RegexOperationList>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)result)
    {
      uint64_t v12 = 2 * v4;
      BOOL v13 = v4 == 0;
      unint64_t v14 = 8;
      if (!v13) {
        unint64_t v14 = v12;
      }
      if (v14 <= v6) {
        unint64_t v15 = v6;
      }
      else {
        unint64_t v15 = v14;
      }
      __n128 result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(result, v15);
    }
    else
    {
      __n128 result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v3, v6);
      ++*((_DWORD *)v3 + 6);
    }
  }
  uint64_t v8 = *((void *)v3 + 4) + 40 * *((void *)v3 + 2);
  *(void *)(v8 + 32) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(void *)(v8 + 8) = 0;
  *(void *)(v8 + 16) = 0;
  *(void *)uint64_t v8 = 0;
  uint64_t v9 = *(void *)(a2 + 8);
  *(void *)uint64_t v8 = *(void *)a2;
  *(void *)(v8 + 8) = v9;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v10 = *(void *)(v8 + 16);
  *(void *)(v8 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v10;
  uint64_t v11 = *(void *)(v8 + 32);
  *(void *)(v8 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v8 + 24);
  ++*((void *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>::~BucketArray(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  return a1;
}

BOOL re::internal::RegexRoot::fullMatch(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  uint64_t v5 = a1[47];
  if (!v5) {
    return a2 == a3;
  }
  v36[0] = a1;
  v36[1] = a2;
  v36[2] = a3;
  uint64_t v37 = a2;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  int v40 = 1;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  int v44 = 0;
  v30[0] = 0;
  v30[1] = 0;
  int v31 = 1;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  uint64_t v8 = (unint64_t *)a1[49];
  uint64_t v9 = &v8[v5];
  int v35 = 0;
  while (1)
  {
    unint64_t v10 = *v8;
    unint64_t v11 = a1[42];
    if (v11 <= *v8) {
      goto LABEL_51;
    }
    if (v37 == a3) {
      break;
    }
    do
    {
      unint64_t v11 = a1[42];
      if (v11 <= v10)
      {
        uint64_t v45 = 0;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v46 = 136315906;
        unint64_t v47 = "operator[]";
        __int16 v48 = 1024;
        int v49 = 797;
        __int16 v50 = 2048;
        unint64_t v51 = v10;
        __int16 v52 = 2048;
        unint64_t v53 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        uint64_t v45 = 0;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v54 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v46 = 136315906;
        unint64_t v47 = "operator[]";
        __int16 v48 = 1024;
        int v49 = 797;
        __int16 v50 = 2048;
        unint64_t v51 = v10;
        __int16 v52 = 2048;
        unint64_t v53 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      else {
        BOOL v12 = 1;
      }
    }
    while (!v12);
    if (v37 == a3) {
      break;
    }
LABEL_13:
    if (++v8 == v9)
    {
      uint64_t v13 = 0;
      goto LABEL_34;
    }
  }
  *(void *)(a4 + 16) = 0;
  ++*(_DWORD *)(a4 + 24);
  uint64_t v14 = v34;
  if (v34)
  {
    unint64_t v15 = 0;
    do
    {
      if (*(unsigned char *)v16 == 5)
      {
        int v17 = v16;
        unint64_t v18 = *(void *)(a4 + 8);
        unint64_t v19 = *(void *)(a4 + 16);
        if (v19 >= v18)
        {
          unint64_t v20 = v19 + 1;
          if (v18 < v19 + 1)
          {
            if (*(void *)a4)
            {
              if (v18) {
                unint64_t v21 = 2 * v18;
              }
              else {
                unint64_t v21 = 8;
              }
              if (v21 <= v20) {
                unint64_t v22 = v19 + 1;
              }
              else {
                unint64_t v22 = v21;
              }
              re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v22);
            }
            else
            {
              re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a4, v20);
              ++*(_DWORD *)(a4 + 24);
            }
          }
          unint64_t v19 = *(void *)(a4 + 16);
        }
        *(_OWORD *)(*(void *)(a4 + 32) + 16 * v19) = *((_OWORD *)v17 + 1);
        ++*(void *)(a4 + 16);
        ++*(_DWORD *)(a4 + 24);
      }
      ++v15;
    }
    while (v14 != v15);
  }
  uint64_t v13 = 1;
LABEL_34:
  uint64_t v23 = v43;
  if (v43)
  {
    unint64_t v24 = 0;
    do
    {
      re::BucketArray<unsigned long,8ul>::deinit(v25 + 64);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 64);
      uint64_t v26 = *(void *)(v25 + 48);
      if (v26)
      {
        for (unint64_t i = 0; i != v26; ++i)
        {
        }
      }
      while (*(void *)(v25 + 16))
        re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)(v25 + 8));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 8);
      *(void *)(v25 + 48) = 0;
      ++*(_DWORD *)(v25 + 56);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 8);
      ++v24;
    }
    while (v24 != v23);
  }
  while (v39)
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v38);
  if (v38 && (v40 & 1) == 0) {
    (*(void (**)(void))(*(void *)v38 + 40))();
  }
  return v13;
}

uint64_t re::internal::anonymous namespace'::RegexOperationList::unwindMatch(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 0;
  }
  unint64_t v7 = v3 - 1;
  while (1)
  {
    if (*(void *)(a1 + 16) <= v7)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_17:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_18:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v8 = (void *)*a2;
    unint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8 * v7);
    if (*(void *)(*a2 + 296) <= v9) {
      goto LABEL_17;
    }
    uint64_t v10 = v8[39];
    unint64_t v11 = *(void *)(v10 + 24 * v9);
    if (v8[32] <= v11) {
      goto LABEL_18;
    }
    uint64_t v12 = a2[3];
    {
      break;
    }
    --v7;
LABEL_13:
    if (v7 >= v3) {
      return 0;
    }
  }
    goto LABEL_13;
  return 1;
}

uint64_t *re::internal::regularExpressionCreate@<X0>(re::internal *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3 = (char *)this;
  uint64_t v34 = *MEMORY[0x263EF8340];
  unint64_t v4 = re::globalAllocators(this);
  uint64_t v5 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 400, 8);
  *uint64_t v5 = 0u;
  v5[1] = 0u;
  float32x4_t v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  unsigned char v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[16] = 0u;
  v5[17] = 0u;
  v5[18] = 0u;
  v5[19] = 0u;
  v5[20] = 0u;
  v5[21] = 0u;
  v5[22] = 0u;
  v5[23] = 0u;
  v5[24] = 0u;
  *(void *)int v31 = &unk_26E6DE608;
  *(void *)&long long v32 = v31;
  unint64_t v30 = v29;
  uint64_t v28 = v5;
  v29[0] = &unk_26E6DE608;
  std::__function::__value_func<void ()(re::internal::RegexRoot *)>::~__value_func[abi:nn180100](v31);
  unint64_t v6 = v28;
  unint64_t v7 = (unsigned __int8 *)&v3[strlen(v3)];
  do
  {
    if (v3 >= (char *)v7) {
      goto LABEL_21;
    }
    uint64_t v27 = 0;
    memset(v25, 0, sizeof(v25));
    int v26 = 0;
    if (!v31[0])
    {
      char v17 = 0;
      long long v18 = *(_OWORD *)&v31[8];
      re::DynamicString::DynamicString((re::DynamicString *)&v19, (const re::DynamicString *)&v32);
      if (void)v32 && (BYTE8(v32)) {
        (*(void (**)(void, uint64_t))(*(void *)v32 + 40))(v32, v33);
      }
      goto LABEL_12;
    }
    uint64_t v8 = *(char **)&v31[8];
    if (!*(void *)&v31[8])
    {
      re::DynamicString::format((re::DynamicString *)"Unknown error parsing regular expression.", (re::DynamicString *)&v22);
      char v17 = 0;
      *(void *)&long long v18 = 100;
      *((void *)&v18 + 1) = re::FoundationErrorCategory(void)::instance;
      long long v19 = v22;
      uint64_t v20 = v23;
      uint64_t v21 = v24;
LABEL_12:
      int v9 = 1;
      goto LABEL_16;
    }
    *(void *)&long long v22 = v6[42];
    re::DynamicArray<unsigned long>::add(v6 + 45, &v22);
    if (!*v8)
    {
      int v9 = 3;
LABEL_15:
      unint64_t v3 = v8;
      goto LABEL_16;
    }
    if (*v8 != 124)
    {
      re::DynamicString::format((re::DynamicString *)"Could not parse regular expression: %s.", (re::DynamicString *)&v22, v8);
      char v17 = 0;
      *(void *)&long long v18 = 100;
      *((void *)&v18 + 1) = re::FoundationErrorCategory(void)::instance;
      long long v19 = v22;
      uint64_t v20 = v23;
      uint64_t v21 = v24;
      int v9 = 1;
      goto LABEL_15;
    }
    unint64_t v3 = v8 + 1;
    int v9 = 2;
LABEL_16:
    if (v25[0] && v27) {
      (*(void (**)(void))(*(void *)v25[0] + 40))();
    }
  }
  while (v9 == 2);
  if (v9 == 3)
  {
LABEL_21:
    char v17 = 1;
    goto LABEL_23;
  }
  if (v17)
  {
LABEL_23:
    uint64_t v10 = (uint64_t)v28;
    unint64_t v11 = v30;
    uint64_t v28 = 0;
    *(void *)int v31 = v10;
    if (v30)
    {
      if (v30 != v29)
      {
        unint64_t v30 = 0;
        *(unsigned char *)a2 = 1;
        uint64_t v12 = a2;
        *((void *)&v32 + 1) = v11;
        *(void *)int v31 = 0;
        *(void *)(a2 + 8) = v10;
LABEL_29:
        if (v11 == &v31[8])
        {
          *(void *)(v12 + 40) = v12 + 16;
          (*(void (**)(unsigned char *))(*(void *)&v31[8] + 24))(&v31[8]);
        }
        else
        {
          *(void *)(v12 + 40) = v11;
          *((void *)&v32 + 1) = 0;
        }
LABEL_32:
        std::unique_ptr<re::internal::RegexRoot,std::function<void ()(re::internal::RegexRoot*)>>::~unique_ptr[abi:nn180100]((uint64_t *)v31);
        goto LABEL_33;
      }
      *((void *)&v32 + 1) = &v31[8];
      (*(void (**)(void))(v29[0] + 24))();
      uint64_t v13 = *(void *)v31;
      unint64_t v11 = (unsigned char *)*((void *)&v32 + 1);
      *(unsigned char *)a2 = 1;
      uint64_t v12 = a2;
      *(void *)int v31 = 0;
      *(void *)(a2 + 8) = v13;
      if (v11) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v12 = a2;
      *(unsigned char *)a2 = 1;
      *((void *)&v32 + 1) = 0;
      *(void *)int v31 = 0;
      *(void *)(a2 + 8) = v10;
    }
    *(void *)(v12 + 40) = 0;
    goto LABEL_32;
  }
  *(_OWORD *)int v31 = v18;
  re::DynamicString::DynamicString((re::DynamicString *)&v31[16], (const re::DynamicString *)&v19);
  *(unsigned char *)a2 = 0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)v31;
  uint64_t v15 = v33;
  *(void *)(a2 + 24) = *(void *)&v31[16];
  *(void *)(a2 + 48) = v15;
  *(_OWORD *)(a2 + 32) = v32;
LABEL_33:
  if (!v17 && (void)v19 && (BYTE8(v19) & 1) != 0) {
    (*(void (**)(void))(*(void *)v19 + 40))();
  }
  return std::unique_ptr<re::internal::RegexRoot,std::function<void ()(re::internal::RegexRoot*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v28);
}

uint64_t re::internal::regularExpressionFullMatch@<X0>(char *__s@<X1>, void **a2@<X0>, uint64_t a3@<X8>)
{
  size_t v6 = strlen(__s);
  uint64_t v12 = 0;
  long long v10 = 0uLL;
  uint64_t v9 = 0;
  int v11 = 0;
  uint64_t result = re::internal::RegexRoot::fullMatch(*a2, (uint64_t)__s, (uint64_t)&__s[v6], (uint64_t)&v9);
  if (result)
  {
    *(void *)(a3 + 8) = v9;
    *(_OWORD *)(a3 + 16) = v10;
    *(void *)(a3 + 40) = v12;
    *(_DWORD *)(a3 + 32) = 1;
    *(unsigned char *)a3 = 1;
  }
  else
  {
    uint64_t result = v9;
    *(unsigned char *)a3 = 0;
    if (result && v12)
    {
      uint64_t v8 = *(uint64_t (**)(void))(*(void *)result + 40);
      return v8();
    }
  }
  return result;
}

__n128 re::DynamicArray<re::internal::anonymous namespace'::RegexToken>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)a1)
    {
      uint64_t v9 = 2 * v4;
      BOOL v10 = v4 == 0;
      unint64_t v11 = 8;
      if (!v10) {
        unint64_t v11 = v9;
      }
      if (v11 <= v6) {
        unint64_t v12 = v6;
      }
      else {
        unint64_t v12 = v11;
      }
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, v12);
    }
    else
    {
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)a1, v6);
      ++*(_DWORD *)(a1 + 24);
    }
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(a1 + 32) + 16 * (*(void *)(a1 + 16))++) = *a2;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenEscapedCharacter>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)result)
    {
      uint64_t v10 = 2 * v4;
      BOOL v11 = v4 == 0;
      unint64_t v12 = 8;
      if (!v11) {
        unint64_t v12 = v10;
      }
      if (v12 <= v6) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = v12;
      }
    }
    else
    {
      ++*((_DWORD *)v3 + 6);
    }
  }
  uint64_t v8 = *((void *)v3 + 2);
  uint64_t v9 = *((void *)v3 + 4) + 16 * v8;
  *(void *)uint64_t v9 = &unk_26E6DE5A8;
  *(unsigned char *)(v9 + 8) = *(unsigned char *)(a2 + 8);
  *((void *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenCharacter>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)result)
    {
      uint64_t v10 = 2 * v4;
      BOOL v11 = v4 == 0;
      unint64_t v12 = 8;
      if (!v11) {
        unint64_t v12 = v10;
      }
      if (v12 <= v6) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = v12;
      }
    }
    else
    {
      ++*((_DWORD *)v3 + 6);
    }
  }
  uint64_t v8 = *((void *)v3 + 2);
  uint64_t v9 = *((void *)v3 + 4) + 16 * v8;
  *(void *)uint64_t v9 = &unk_26E6DE5D8;
  *(unsigned char *)(v9 + 8) = *(unsigned char *)(a2 + 8);
  *((void *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::internal::anonymous namespace'::RegexTokenCharacterSet::tryMatch(uint64_t a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  v11[0] = 0;
  v11[1] = 0;
  int v12 = 1;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  int v16 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    unint64_t v4 = *(unint64_t **)(a1 + 40);
    uint64_t v5 = 8 * v2 - 8;
    do
    {
      unint64_t v6 = *v4;
      unint64_t v7 = *(void *)(*a2 + 256);
      if (v7 <= *v4)
      {
        uint64_t v17 = 0;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v26 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v18 = 136315906;
        long long v19 = "operator[]";
        __int16 v20 = 1024;
        int v21 = 797;
        __int16 v22 = 2048;
        unint64_t v23 = v6;
        __int16 v24 = 2048;
        unint64_t v25 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (v8) {
        break;
      }
      ++v4;
      uint64_t v9 = v5;
      v5 -= 8;
    }
    while (v9);
  }
  else
  {
    uint64_t v8 = 0;
  }
  return v8;
}

uint64_t re::internal::anonymous namespace'::RegexToken::match(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v5 = (unsigned char *)a2;
  unint64_t v6 = (unint64_t)&v41;
  switch(*(unsigned char *)a1)
  {
    case 1:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 16);
      if (i <= v7) {
        goto LABEL_67;
      }
      uint64_t v9 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 32) + 16 * v7);
      char v10 = 1;
      goto LABEL_45;
    case 2:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 56);
      if (i <= v7) {
        goto LABEL_68;
      }
      uint64_t v9 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 72) + 16 * v7);
      char v10 = 2;
      goto LABEL_45;
    case 3:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 96);
      if (i <= v7) {
        goto LABEL_69;
      }
      uint64_t v9 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 112) + 16 * v7);
      char v10 = 3;
      goto LABEL_45;
    case 4:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 216);
      if (i <= v7) {
        goto LABEL_70;
      }
      uint64_t v9 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 232) + 16 * v7);
      char v10 = 4;
      goto LABEL_45;
    case 5:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 136);
      if (i <= v7) {
        goto LABEL_71;
      }
      uint64_t v11 = *(void *)(*a3 + 152);
      LOBYTE(v41) = 0;
      uint64_t v12 = v11 + 40 * v7;
      *((void *)&v41 + 1) = 0;
      *(void *)&long long v42 = 0;
      DWORD2(v42) = 1;
      *(void *)&long long v44 = 0;
      long long v43 = 0uLL;
      DWORD2(v44) = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      int v47 = 1;
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      uint64_t v48 = 0;
      int v51 = 0;
      uint64_t v35 = a3[3];
      uint64_t v13 = *(unsigned char **)(v12 + 16);
      unint64_t i = *(unsigned int *)(a2 + 4);
      if ((int)i < 1) {
        goto LABEL_22;
      }
      if (!v13) {
        goto LABEL_48;
      }
      int v14 = 0;
      unint64_t v15 = (unint64_t)&v38[4];
      break;
    case 6:
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t i = *(void *)(*a3 + 176);
      if (i <= v7) {
        goto LABEL_72;
      }
      uint64_t v9 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 192) + 48 * v7);
      char v10 = 6;
LABEL_45:
    default:
      re::internal::assertLog((re::internal *)4, a2, a2, "assertion failure: '%s' (%s:line %i) Invalid token type.", "!\"Unreachable code\"", "match", 915);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2335D7AF0);
  }
LABEL_14:
  int v32 = v14;
  for (unint64_t i = 0; (unsigned char *)i != v13; ++i)
  {
    *(void *)uint64_t v37 = 0;
    *(void *)&v37[8] = 0;
    *(_DWORD *)&v37[16] = 1;
    uint64_t v39 = 0;
    *(_OWORD *)&v38[4] = 0uLL;
    int v40 = 0;
    unint64_t v6 = *(void *)(v12 + 16);
    if (v6 <= i)
    {
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      unint64_t v16 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v52 = 136315906;
      *(void *)&v52[4] = "operator[]";
      __int16 v53 = 1024;
      int v54 = 797;
      __int16 v55 = 2048;
      long long v56 = (unsigned char *)i;
      __int16 v57 = 2048;
      unint64_t v58 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_64:
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v52 = 136315906;
      *(void *)&v52[4] = "operator[]";
      __int16 v53 = 1024;
      int v54 = 797;
      __int16 v55 = 2048;
      long long v56 = (unsigned char *)v6;
      __int16 v57 = 2048;
      unint64_t v58 = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_65:
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      unint64_t v18 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v52 = 136315906;
      *(void *)&v52[4] = "operator[]";
      __int16 v53 = 1024;
      int v54 = 797;
      __int16 v55 = 2048;
      long long v56 = (unsigned char *)v15;
      __int16 v57 = 2048;
      unint64_t v58 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      unint64_t v7 = (unint64_t)&v41;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v52 = 136315906;
      *(void *)&v52[4] = "operator[]";
      __int16 v53 = 1024;
      int v54 = 797;
      __int16 v55 = 2048;
      long long v56 = (unsigned char *)v6;
      __int16 v57 = 2048;
      unint64_t v58 = v18;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_67:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_68:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_69:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_70:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_71:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_72:
      *(void *)uint64_t v37 = 0;
      *(_OWORD *)(v6 + 64) = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v59) = 136315906;
      *(void *)(v6 + 180) = "operator[]";
      WORD6(v59) = 1024;
      *(_DWORD *)(v6 + 190) = 797;
      WORD1(v60) = 2048;
      *(void *)(v6 + 196) = v7;
      WORD6(v60) = 2048;
      *(void *)(v6 + 206) = i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_73;
    }
    unint64_t v6 = *(void *)(*(void *)(v12 + 32) + 8 * i);
    unint64_t v16 = *(void *)(*a3 + 336);
    if (v16 <= v6) {
      goto LABEL_64;
    }
    {
      *(void *)re::BucketArray<unsigned long,8ul>::addUninitialized((uint64_t)&v45) = i;
      int v14 = v32 + 1;
      unint64_t i = *(unsigned int *)(a2 + 4);
      if (v32 + 1 >= (int)i)
      {
        uint64_t v5 = (unsigned char *)a2;
LABEL_22:
        if (*v5)
        {
          LOBYTE(v41) = 1;
          if ((int)i < *(_DWORD *)(a2 + 8))
          {
            if (v13)
            {
              uint64_t v33 = a3[3];
              do
              {
                BOOL v17 = 0;
                unint64_t v15 = 0;
                while (1)
                {
                  *(void *)uint64_t v37 = 0;
                  *(void *)&v37[8] = 0;
                  *(_DWORD *)&v37[16] = 1;
                  *(void *)&v38[12] = 0;
                  uint64_t v39 = 0;
                  *(void *)&v38[4] = 0;
                  int v40 = 0;
                  unint64_t v6 = *(void *)(v12 + 16);
                  if (v6 <= v15) {
                    goto LABEL_65;
                  }
                  unint64_t v6 = *(void *)(*(void *)(v12 + 32) + 8 * v15);
                  unint64_t v18 = *(void *)(*a3 + 336);
                  if (v18 <= v6) {
                    goto LABEL_66;
                  }
                  BOOL v17 = ++v15 >= (unint64_t)v13;
                  if (v13 == (unsigned char *)v15) {
                    goto LABEL_34;
                  }
                }
                *(void *)re::BucketArray<unsigned long,8ul>::addUninitialized((uint64_t)&v45) = v15;
                if (v17 || v33 == a3[3]) {
                  break;
                }
                unint64_t i = (i + 1);
                uint64_t v33 = a3[3];
              }
              while ((int)i < *(_DWORD *)(a2 + 8));
            }
          }
        }
LABEL_34:
        unint64_t v19 = a3[9];
        unint64_t i = a3[5];
        if (v19 + 1 > i << 6)
        {
          unint64_t i = a3[5];
        }
        unint64_t v6 = v19 >> 6;
        if (i > v19 >> 6)
        {
          __int16 v20 = (void *)a3[8];
          if (a3[6]) {
            __int16 v20 = a3 + 7;
          }
          uint64_t v21 = v20[v6];
          ++a3[9];
          ++*((_DWORD *)a3 + 20);
          uint64_t v22 = v21 + 120 * (v19 & 0x3F);
          *(unsigned char *)uint64_t v22 = v41;
          *(void *)(v22 + 8) = 0;
          *(void *)(v22 + 16) = 0;
          *(void *)(v22 + 40) = 0;
          *(void *)(v22 + 48) = 0;
          *(void *)(v22 + 32) = 0;
          *(_DWORD *)(v22 + 56) = 0;
          *((void *)&v60 + 1) = 0;
          *(void *)&long long v61 = 0;
          long long v59 = 0uLL;
          *(_DWORD *)(v22 + 24) = 3;
          LODWORD(v60) = 3;
          if ((void)v59 && (v60 & 1) == 0) {
            (*(void (**)(void))(*(void *)v59 + 40))();
          }
          uint64_t v23 = v21 + 120 * (v19 & 0x3F);
          uint64_t v24 = *(void *)(v23 + 48);
          *(void *)(v23 + 48) = v44;
          *(void *)&long long v44 = v24;
          ++*(_DWORD *)(v23 + 56);
          ++DWORD2(v44);
          *(void *)(v23 + 64) = 0;
          *(void *)(v23 + 72) = 0;
          v23 += 64;
          uint64_t v25 = 1;
          *(_DWORD *)(v23 + 16) = 1;
          *(void *)(v23 + 32) = 0;
          *(void *)(v23 + 40) = 0;
          *(void *)(v23 + 24) = 0;
          *(_DWORD *)(v23 + 48) = 0;
          re::BucketArray<RESubscriptionHandle,8ul>::swap(v23, (uint64_t)&v45);
          LOBYTE(v59) = 5;
          uint64_t v26 = a3[3] - v35;
          *((void *)&v59 + 1) = a3[9] - 1;
          *(void *)&long long v60 = v35;
          *((void *)&v60 + 1) = v26;
          goto LABEL_49;
        }
LABEL_73:
        *(void *)__int16 v52 = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v59 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v37 = 136315906;
        *(void *)&v37[4] = "operator[]";
        *(_WORD *)&v37[12] = 1024;
        *(_DWORD *)&v37[14] = 858;
        *(_WORD *)&v37[18] = 2048;
        *(void *)uint64_t v38 = v6;
        *(_WORD *)&v38[8] = 2048;
        *(void *)&v38[10] = i;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      goto LABEL_14;
    }
  }
LABEL_48:
  uint64_t v25 = 0;
  a3[3] = v35;
LABEL_49:
  re::BucketArray<unsigned long,8ul>::deinit((uint64_t)&v45);
  if (v45)
  {
    int v28 = v47;
    if ((v47 & 1) == 0)
    {
      (*(void (**)(void))(*(void *)v45 + 40))();
      int v28 = v47;
    }
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    int v47 = (v28 | 1) + 2;
  }
  uint64_t v29 = v44;
  if ((void)v44)
  {
    unint64_t v30 = 0;
    do
    {
      ++v30;
    }
    while (v29 != v30);
  }
  while ((void)v42)
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)&v41 + 1);
  if (*((void *)&v41 + 1) && (BYTE8(v42) & 1) == 0) {
    (*(void (**)(void))(**((void **)&v41 + 1) + 40))();
  }
  return v25;
}

uint64_t re::internal::anonymous namespace'::RegexBasicToken::match(uint64_t (***a1)(void, uint64_t), char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a4 + 24);
  int v11 = *(_DWORD *)(a3 + 4);
  if (v11 < 1)
  {
LABEL_5:
    if (*(unsigned char *)a3)
    {
      while (v11 < *(_DWORD *)(a3 + 8) && ((**a1)(a1, a4) & 1) != 0)
        ++v11;
    }
    v15[0] = a2;
    uint64_t v13 = *(void *)(a4 + 24) - v10;
    uint64_t v16 = -1;
    uint64_t v17 = v10;
    uint64_t v18 = v13;
    return 1;
  }
  else
  {
    int v12 = 0;
    while (((**a1)(a1, a4) & 1) != 0)
    {
      ++v12;
      int v11 = *(_DWORD *)(a3 + 4);
      if (v12 >= v11) {
        goto LABEL_5;
      }
    }
    uint64_t result = 0;
    *(void *)(a4 + 24) = v10;
  }
  return result;
}

__n128 re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 8);
  if (v4 + 1 > v5 << 6)
  {
    unint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5 <= v4 >> 6)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v6 + 8 * (v4 >> 6));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  uint64_t v8 = (_OWORD *)(v7 + 32 * (v4 & 0x3F));
  __n128 result = *(__n128 *)a2;
  long long v10 = *(_OWORD *)(a2 + 16);
  *uint64_t v8 = *(_OWORD *)a2;
  v8[1] = v10;
  return result;
}

void *re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        __n128 result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 2048, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            __n128 result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          unint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            unint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>,8ul>::add(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 8);
  if (v4 + 1 > 8 * v5)
  {
    unint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5 <= v4 >> 3)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v12 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v6 + 8 * (v4 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  uint64_t v8 = v7 + 56 * (v4 & 7);
  *(void *)uint64_t v8 = 0;
  *(void *)(v8 + 8) = 0;
  *(void *)(v8 + 32) = 0;
  *(void *)(v8 + 40) = 0;
  *(void *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 48) = 0;
  *((void *)&v13 + 1) = 0;
  *(void *)&long long v14 = 0;
  long long v12 = 0uLL;
  *(_DWORD *)(v8 + 16) = 3;
  LODWORD(v13) = 3;
  uint64_t result = v12;
  if ((void)v12 && (v13 & 1) == 0) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v12 + 40))();
  }
  uint64_t v10 = v7 + 56 * (v4 & 7);
  uint64_t v11 = *(void *)(v10 + 40);
  *(void *)(v10 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v11;
  ++*(_DWORD *)(v10 + 48);
  ++*(_DWORD *)(a2 + 48);
  return result;
}

void *re::BucketArray<re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 448, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::DynamicOverflowArray<re::internal::anonymous namespace'::MatchStackItem *,2ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (*(void *)a2 && v4 != *(void *)a2)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 527);
      uint64_t result = _os_crash();
      __break(1u);
      return result;
    }
  }
  if (*(unsigned char *)(a2 + 16))
  {
    unint64_t v10 = *(void *)(a2 + 8);
    if (v10)
    {
      *(void *)a1 = *(void *)a2;
      if (v10 >= *(void *)(a1 + 8))
      {
        re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, v10);
        if (*(unsigned char *)(a2 + 16)) {
          unint64_t v13 = (const void *)(a2 + 24);
        }
        else {
          unint64_t v13 = *(const void **)(a2 + 32);
        }
        uint64_t v14 = *(void *)(a1 + 8);
        int v15 = *(_DWORD *)(a1 + 16);
        if (v15) {
          unint64_t v16 = (void *)(a1 + 24);
        }
        else {
          unint64_t v16 = *(void **)(a1 + 32);
        }
        if (v14)
        {
          memmove(v16, v13, 8 * v14);
          int v15 = *(_DWORD *)(a1 + 16);
        }
        if (v15) {
          uint64_t v17 = a1 + 24;
        }
        else {
          uint64_t v17 = *(void *)(a1 + 32);
        }
        uint64_t v18 = *(void *)(a1 + 8);
        unint64_t v19 = (void *)(v17 + 8 * v18);
        if (*(_DWORD *)(a2 + 16)) {
          uint64_t v20 = a2 + 24;
        }
        else {
          uint64_t v20 = *(void *)(a2 + 32);
        }
        memcpy(v19, (const void *)(v20 + 8 * v18), 8 * v10 - 8 * v18);
      }
      else
      {
        if (*(unsigned char *)(a2 + 16)) {
          BOOL v11 = (const void *)(a2 + 24);
        }
        else {
          BOOL v11 = *(const void **)(a2 + 32);
        }
        if (*(unsigned char *)(a1 + 16)) {
          unint64_t v12 = (void *)(a1 + 24);
        }
        else {
          unint64_t v12 = *(void **)(a1 + 32);
        }
        memmove(v12, v11, 8 * v10);
      }
      *(void *)(a1 + 8) = v10;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 16) += 4;
      uint64_t v6 = (_DWORD *)(a1 + 16);
      goto LABEL_37;
    }
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
    *(void *)a1 = *(void *)a2;
    uint64_t v6 = (_DWORD *)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v6 = (_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) += 2;
    uint64_t v7 = *(void *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v7;
    *(void *)a2 = v4;
    *(void *)(a2 + 8) = 0;
    uint64_t v8 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = v8;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16) & 0xFFFFFFFE | *(_DWORD *)(a1 + 16) & 1;
    *(_DWORD *)(a1 + 16) &= ~1u;
    uint64_t v9 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(void *)(a2 + 24) = v9;
  }
  *(_DWORD *)(a2 + 16) += 2;
LABEL_37:
  *v6 += 2;
  return a1;
}

uint64_t re::BucketArray<unsigned long,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<unsigned long,8ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 7);
}

uint64_t *re::BucketArray<unsigned long,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 64, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<unsigned long,8ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::internal::anonymous namespace'::RegexTokenGroup::RegexTokenGroupState,64ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 7680, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          int v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            int v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>,8ul>::BucketArrayIterator<re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>,re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>&,re::BucketArray<re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>,8ul>&,true>::operator*(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 56 * (a2 & 7);
}

uint64_t re::internal::anonymous namespace'::RegexTokenCharacterRange::tryMatch(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(char **)(a2 + 24);
  if ((uint64_t)(*(void *)(a2 + 16) - (void)v2) < 1) {
    return 0;
  }
  int v3 = *v2;
  if (v3 < *(char *)(a1 + 8) || v3 > *(char *)(a1 + 9)) {
    return 0;
  }
  *(void *)(a2 + 24) = v2 + 1;
  return 1;
}

void *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenCharacterRange>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 16 * v9;
        BOOL v11 = (__int16 *)(v8 + 8);
        unint64_t v12 = v7;
        unint64_t v13 = v7;
        do
        {
          *unint64_t v13 = &unk_26E6DE548;
          __int16 v14 = *v11;
          v11 += 8;
          *((_WORD *)v13 + 4) = v14;
          v12 += 2;
          v13 += 2;
          v10 -= 16;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenCharacterSet>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 48 * v9;
        do
        {
          unint64_t v12 = &v7[v10 / 8];
          uint64_t v13 = v8 + v10;
          _OWORD v12[5] = 0;
          *unint64_t v12 = &unk_26E6DE508;
          v12[1] = 0;
          void v12[2] = 0;
          v12[3] = 0;
          *((_DWORD *)v12 + 8) = 0;
          __int16 v14 = (void *)(v8 + v10 + 8);
          uint64_t v15 = *(void *)(v8 + v10 + 16);
          v12[1] = *v14;
          *__int16 v14 = 0;
          void v12[2] = v15;
          *(void *)(v13 + 16) = 0;
          uint64_t v16 = v7[v10 / 8 + 3];
          v12[3] = *(void *)(v8 + v10 + 24);
          *(void *)(v13 + 24) = v16;
          uint64_t v17 = v7[v10 / 8 + 5];
          _OWORD v12[5] = *(void *)(v8 + v10 + 40);
          *(void *)(v13 + 40) = v17;
          *(_DWORD *)(v13 + 32) = *(_DWORD *)(v8 + v10 + 32) + 1;
          *((_DWORD *)v12 + 8) = LODWORD(v7[v10 / 8 + 4]) + 1;
          *(void *)uint64_t v13 = &unk_26E6DE508;
          re::DynamicArray<unsigned long>::deinit((uint64_t)v14);
          v10 += 48;
        }
        while (v11 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::internal::anonymous namespace'::RegexTokenMarker::tryMatch(uint64_t a1, void *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 8);
  if (v2 == 3)
  {
    uint64_t v5 = a2[2];
    uint64_t v4 = a2[3];
    return v4 == v5;
  }
  if (v2 == 2)
  {
    uint64_t v4 = a2[3];
    uint64_t v5 = a2[1];
    return v4 == v5;
  }
  if (v2 != 1)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid token marker type.", "!\"Unreachable code\"", "tryMatch", 511);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  uint64_t v3 = a2[3];
  if (v3 == a2[2]) {
    return 0;
  }
  a2[3] = v3 + 1;
  return 1;
}

void *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenMarker>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_15;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 16 * v9;
        uint64_t v11 = (char *)(v8 + 8);
        unint64_t v12 = v7;
        uint64_t v13 = v7;
        do
        {
          *uint64_t v13 = &unk_26E6DE578;
          char v14 = *v11;
          v11 += 16;
          *((unsigned char *)v13 + 8) = v14;
          v12 += 2;
          v13 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t re::internal::anonymous namespace'::RegexTokenEscapedCharacter::tryMatch(uint64_t a1, void *a2)
{
  uint64_t v4 = (unsigned __int8 *)a2[2];
  uint64_t v3 = (char *)a2[3];
  int v5 = *(char *)(a1 + 8);
  if (v5 > 89)
  {
    if (v5 <= 114)
    {
      if (v5 != 90)
      {
        if (v5 == 100)
        {
          if (v4 != (unsigned __int8 *)v3 && *v3 - 48 <= 9) {
            goto LABEL_55;
          }
          return 0;
        }
        goto LABEL_47;
      }
      return v4 == (unsigned __int8 *)v3;
    }
    if (v5 != 115)
    {
      if (v5 == 119)
      {
        if (v4 != (unsigned __int8 *)v3)
        {
          int v9 = *v3;
          BOOL v10 = v9 != 95 && (v9 - 48) >= 0xA;
          if (!v10 || (v9 & 0xFFFFFFDF) - 65 <= 0x19) {
            goto LABEL_55;
          }
        }
        return 0;
      }
      goto LABEL_47;
    }
    if (v4 == (unsigned __int8 *)v3) {
      return 0;
    }
    unsigned int v14 = *v3;
    if ((v14 & 0x80000000) != 0)
    {
      if (!__maskrune(v14, 0x4000uLL)) {
        return 0;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x263EF8318] + 4 * v14 + 60) & 0x4000) == 0)
    {
      return 0;
    }
  }
  else
  {
    if (v5 <= 82)
    {
      if (v5 != 65)
      {
        if (v5 == 68)
        {
          if (v4 != (unsigned __int8 *)v3 && *v3 - 58 <= 0xFFFFFFF5) {
            goto LABEL_55;
          }
          return 0;
        }
LABEL_47:
        if (v4 != (unsigned __int8 *)v3 && *(unsigned __int8 *)(a1 + 8) == *v3) {
          goto LABEL_55;
        }
        return 0;
      }
      uint64_t v4 = (unsigned __int8 *)a2[1];
      return v4 == (unsigned __int8 *)v3;
    }
    if (v5 != 83)
    {
      if (v5 == 87)
      {
        if (v4 != (unsigned __int8 *)v3)
        {
          int v6 = *v3;
          BOOL v7 = v6 != 95 && (v6 - 48) >= 0xA;
          if (v7 && (v6 & 0xFFFFFFDF) - 65 >= 0x1A) {
            goto LABEL_55;
          }
        }
        return 0;
      }
      goto LABEL_47;
    }
    if (v4 == (unsigned __int8 *)v3) {
      return 0;
    }
    unsigned int v12 = *v3;
    if ((v12 & 0x80000000) != 0
       ? __maskrune(v12, 0x4000uLL)
       : *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v12 + 60) & 0x4000)
    {
      return 0;
    }
  }
  uint64_t v3 = (char *)a2[3];
LABEL_55:
  a2[3] = v3 + 1;
  return 1;
}

void *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenEscapedCharacter>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    int v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            BOOL v7 = result;
            if (!v5[1]) {
              goto LABEL_15;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      BOOL v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 16 * v9;
        uint64_t v11 = (char *)(v8 + 8);
        unsigned int v12 = v7;
        uint64_t v13 = v7;
        do
        {
          *uint64_t v13 = &unk_26E6DE5A8;
          char v14 = *v11;
          v11 += 16;
          *((unsigned char *)v13 + 8) = v14;
          v12 += 2;
          v13 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

BOOL re::internal::anonymous namespace'::RegexTokenCharacter::tryMatch(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 8);
  uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
  int v4 = *v3;
  if (v2 == v4) {
    *(void *)(a2 + 24) = v3 + 1;
  }
  return v2 == v4;
}

void *re::DynamicArray<re::internal::anonymous namespace'::RegexTokenCharacter>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    int v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            BOOL v7 = result;
            if (!v5[1]) {
              goto LABEL_15;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      BOOL v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 16 * v9;
        uint64_t v11 = (char *)(v8 + 8);
        unsigned int v12 = v7;
        uint64_t v13 = v7;
        do
        {
          *uint64_t v13 = &unk_26E6DE5D8;
          char v14 = *v11;
          v11 += 16;
          *((unsigned char *)v13 + 8) = v14;
          v12 += 2;
          v13 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t re::internal::anonymous namespace'::RegexOperationList::matchFrom(uint64_t a1, unint64_t a2, void *a3, uint64_t a4)
{
  unint64_t v19 = *(void *)(a1 + 16);
  if (v19 > a2)
  {
    unint64_t v8 = a2;
    do
    {
      if (*(void *)(a1 + 16) <= v8) {
        goto LABEL_21;
      }
      uint64_t v9 = (void *)*a3;
      unint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8 * v8);
      if (*(void *)(*a3 + 296) <= v10)
      {
LABEL_22:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_23:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v11 = v9[39];
      unint64_t v12 = *(void *)(v11 + 24 * v10);
      if (v9[32] <= v12) {
        goto LABEL_23;
      }
      {
        unint64_t v13 = v8 + 1;
      }
      else
      {
        do
        {
          unint64_t v13 = v8;
          if (v8 <= a2) {
            break;
          }
          --v8;
          if (*(void *)(a1 + 16) <= v13 - 1)
          {
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_19:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_20:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_21:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_22;
          }
          char v14 = (void *)*a3;
          unint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8 * v13 - 8);
          if (*(void *)(*a3 + 296) <= v15) {
            goto LABEL_19;
          }
          uint64_t v16 = v14[39];
          unint64_t v17 = *(void *)(v16 + 24 * v15);
          if (v14[32] <= v17) {
            goto LABEL_20;
          }
        }
        if (a2 == v13) {
          return 0;
        }
      }
      unint64_t v8 = v13;
    }
    while (v13 < v19);
  }
  return 1;
}

uint64_t re::internal::anonymous namespace'::RegexToken::unwindMatch(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v8 = a2;
  switch(*(unsigned char *)a1)
  {
    case 1:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 16);
      if (v10 <= v9) {
        goto LABEL_53;
      }
      uint64_t v11 = *(void *)(*a3 + 32);
      goto LABEL_10;
    case 2:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 56);
      if (v10 <= v9) {
        goto LABEL_54;
      }
      uint64_t v11 = *(void *)(*a3 + 72);
      goto LABEL_10;
    case 3:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 96);
      if (v10 <= v9) {
        goto LABEL_55;
      }
      uint64_t v11 = *(void *)(*a3 + 112);
      goto LABEL_10;
    case 4:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 216);
      if (v10 <= v9) {
        goto LABEL_56;
      }
      uint64_t v11 = *(void *)(*a3 + 232);
LABEL_10:
      unint64_t v12 = (uint64_t (***)(void, uint64_t))(v11 + 16 * v9);
      goto LABEL_39;
    case 5:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 136);
      if (v10 <= v9) {
        goto LABEL_57;
      }
      uint64_t v13 = *(void *)(a4 + 40);
      if (!v13) {
        goto LABEL_59;
      }
      uint64_t v14 = *(void *)(*a3 + 152) + 40 * v9;
      long long v16 = v15[1];
      long long v31 = *v15;
      long long v32 = v16;
      --*(void *)(a4 + 40);
      ++*(_DWORD *)(a4 + 48);
      unint64_t v9 = v17;
      unint64_t v18 = *(void *)(v14 + 16);
      uint64_t v30 = v8;
      if (*(unsigned char *)v17) {
        goto LABEL_22;
      }
      if (*(void *)(v17 + 104) >= (unint64_t)*(int *)(v8 + 8) || !v18) {
        goto LABEL_21;
      }
      unint64_t v4 = 0;
      uint64_t v28 = v17 + 64;
      unint64_t v19 = 40;
      break;
    case 6:
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = *(void *)(*a3 + 176);
      if (v10 <= v9) {
        goto LABEL_58;
      }
      unint64_t v12 = (uint64_t (***)(void, uint64_t))(*(void *)(*a3 + 192) + 48 * v9);
LABEL_39:
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid token type.", "!\"Unreachable code\"", "unwindMatch", 948);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2335DAC44);
  }
  do
  {
    *(void *)uint64_t v34 = 0;
    *(void *)&v34[8] = 0;
    *(_DWORD *)&v34[16] = 1;
    uint64_t v36 = 0;
    *(_OWORD *)&v35[4] = 0uLL;
    int v37 = 0;
    unint64_t v10 = *(void *)(v14 + 16);
    if (v10 <= v4) {
      goto LABEL_49;
    }
    unint64_t v10 = *(void *)(*(void *)(v14 + 32) + 8 * v4);
    int v5 = *(unsigned char **)(*a3 + 336);
    if ((unint64_t)v5 <= v10) {
      goto LABEL_50;
    }
    {
      *(void *)re::BucketArray<unsigned long,8ul>::addUninitialized(v28) = v4;
LABEL_44:
      *((void *)&v32 + 1) = a3[3] - v32;
      return 1;
    }
    ++v4;
  }
  while (v18 != v4);
LABEL_21:
  *(unsigned char *)unint64_t v9 = 1;
  uint64_t v8 = v30;
LABEL_22:
  unint64_t v20 = *(void *)(v9 + 104);
  if (v20 && v20 >= *(int *)(v8 + 4))
  {
    uint64_t v21 = v9 + 64;
    int v5 = &v35[4];
    uint64_t v27 = v9 + 8;
    uint64_t v29 = v9 + 64;
    while (1)
    {
      unint64_t v19 = *(void *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v21, v20 - 1);
      unint64_t v10 = *(void *)(v14 + 16);
      if (v10 <= v19) {
        goto LABEL_51;
      }
      unint64_t v10 = *(void *)(*(void *)(v14 + 32) + 8 * v19);
      unint64_t v4 = *(void *)(*a3 + 336);
      if (v4 <= v10) {
        goto LABEL_52;
      }
      if (++v19 < v18) {
        break;
      }
LABEL_34:
      --*(void *)(v9 + 48);
      ++*(_DWORD *)(v9 + 56);
      uint64_t v21 = v9 + 64;
      re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v29, *(void *)(v9 + 104) - 1);
      uint64_t v23 = *(void *)(v9 + 104);
      ++*(_DWORD *)(v9 + 112);
      unint64_t v20 = v23 - 1;
      *(void *)(v9 + 104) = v20;
      if (!v20 || v20 < *(int *)(v30 + 4)) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = a3[3];
    while (1)
    {
      *(void *)uint64_t v34 = 0;
      *(void *)&v34[8] = 0;
      *(_DWORD *)&v34[16] = 1;
      *(void *)&unsigned char v35[12] = 0;
      uint64_t v36 = 0;
      *(void *)&v35[4] = 0;
      int v37 = 0;
      unint64_t v10 = *(void *)(v14 + 16);
      if (v10 <= v19) {
        break;
      }
      unint64_t v10 = *(void *)(*(void *)(v14 + 32) + 8 * v19);
      unint64_t v4 = *(void *)(*a3 + 336);
      if (v4 <= v10) {
        goto LABEL_48;
      }
      {
        *(void *)re::BucketArray<unsigned long,8ul>::addUninitialized(v29) = v19;
        uint64_t v25 = a3[3] - v26;
        *(void *)&long long v32 = v26;
        *((void *)&v32 + 1) = v25;
        return 1;
      }
      if (v18 == ++v19) {
        goto LABEL_34;
      }
    }
    uint64_t v33 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v38 = 136315906;
    *(void *)&v38[4] = "operator[]";
    __int16 v39 = 1024;
    int v40 = 797;
    __int16 v41 = 2048;
    unint64_t v42 = v19;
    __int16 v43 = 2048;
    long long v44 = (unsigned char *)v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    uint64_t v33 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v38 = 136315906;
    *(void *)&v38[4] = "operator[]";
    __int16 v39 = 1024;
    int v40 = 797;
    __int16 v41 = 2048;
    unint64_t v42 = v10;
    __int16 v43 = 2048;
    long long v44 = (unsigned char *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    uint64_t v33 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v38 = 136315906;
    *(void *)&v38[4] = "operator[]";
    __int16 v39 = 1024;
    int v40 = 797;
    __int16 v41 = 2048;
    unint64_t v42 = v4;
    __int16 v43 = 2048;
    long long v44 = (unsigned char *)v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    uint64_t v33 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v38 = 136315906;
    *(void *)&v38[4] = "operator[]";
    __int16 v39 = 1024;
    int v40 = 797;
    __int16 v41 = 2048;
    unint64_t v42 = v10;
    __int16 v43 = 2048;
    long long v44 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v19;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v10;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    *(void *)uint64_t v38 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v34 = 136315906;
    *(void *)&v34[4] = "operator[]";
    *(_WORD *)&unsigned char v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(void *)uint64_t v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(void *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
LABEL_36:
  uint64_t result = 0;
  a3[3] = v32;
  return result;
}

uint64_t re::internal::anonymous namespace'::RegexBasicToken::unwindMatch(uint64_t (***a1)(void, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 40);
  if (v4)
  {
    int v10 = *(_DWORD *)(v9 + 24);
    if (v10)
    {
      uint64_t v11 = v9;
      if (*(unsigned char *)a2)
      {
        if (*(_DWORD *)(a2 + 4) < v10)
        {
          uint64_t v12 = *(void *)(a3 + 24) - 1;
          *(void *)(a3 + 24) = v12;
          *(void *)(v9 + 24) = v12 - *(void *)(v9 + 16);
          return 1;
        }
        uint64_t v14 = *(void *)(v9 + 16);
      }
      else
      {
        char v13 = (**a1)(a1, a3);
        uint64_t v14 = *(void *)(v11 + 16);
        if (v13)
        {
          unint64_t v15 = *(void *)(a3 + 24) - v14;
          *(void *)(v11 + 24) = v15;
          if (v15 <= *(int *)(a2 + 8)) {
            return 1;
          }
        }
      }
      *(void *)(a3 + 24) = v14;
    }
    uint64_t result = 0;
    --*(void *)(a4 + 40);
    ++*(_DWORD *)(a4 + 48);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::BucketArray<re::internal::anonymous namespace'::MatchStackItem,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 6) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 6)) + 32 * (a2 & 0x3F);
}

uint64_t re::BucketArray<re::internal::anonymous namespace'::RegexTokenGroup::RegexTokenGroupState,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 6) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 6)) + 120 * (a2 & 0x3F);
}

void std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::~__func()
{
}

void *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6DE608;
  return result;
}

void std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DE608;
}

re *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::operator()(re *result, void **a2)
{
  unint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = re::globalAllocators(result)[2];
    re::DynamicArray<unsigned long>::deinit((uint64_t)(v2 + 45));
    uint64_t v4 = v2[40];
    if (v4)
    {
      uint64_t v5 = v2[44];
      if (v5)
      {
        uint64_t v6 = v2[42];
        if (v6)
        {
          uint64_t v7 = 40 * v6;
          do
          {
            re::DynamicArray<unsigned long>::deinit(v5);
            v5 += 40;
            v7 -= 40;
          }
          while (v7);
          uint64_t v4 = v2[40];
          uint64_t v5 = v2[44];
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v5);
      }
      v2[44] = 0;
      v2[41] = 0;
      v2[42] = 0;
      v2[40] = 0;
      ++*((_DWORD *)v2 + 86);
    }
    uint64_t v8 = v2[35];
    if (v8)
    {
      if (v2[39]) {
        (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
      }
      v2[39] = 0;
      v2[36] = 0;
      v2[37] = 0;
      v2[35] = 0;
      ++*((_DWORD *)v2 + 76);
    }
    uint64_t v9 = v2[30];
    if (v9)
    {
      if (v2[34]) {
        (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
      }
      v2[34] = 0;
      v2[31] = 0;
      v2[32] = 0;
      v2[30] = 0;
      ++*((_DWORD *)v2 + 66);
    }
    uint64_t v10 = v2[25];
    if (v10)
    {
      if (v2[29]) {
        (*(void (**)(uint64_t))(*(void *)v10 + 40))(v10);
      }
      v2[29] = 0;
      v2[26] = 0;
      v2[27] = 0;
      v2[25] = 0;
      ++*((_DWORD *)v2 + 56);
    }
    uint64_t v11 = v2[20];
    if (v11)
    {
      uint64_t v12 = (void *)v2[24];
      if (v12)
      {
        uint64_t v13 = v2[22];
        if (v13)
        {
          uint64_t v14 = &v12[6 * v13];
          uint64_t v15 = v2[24];
          do
          {
            uint64_t v16 = (uint64_t)(v12 + 1);
            *uint64_t v12 = &unk_26E6DE508;
            v12 += 6;
            re::DynamicArray<unsigned long>::deinit(v16);
            v15 += 48;
          }
          while (v12 != v14);
          uint64_t v11 = v2[20];
          uint64_t v12 = (void *)v2[24];
        }
        (*(void (**)(uint64_t, void *))(*(void *)v11 + 40))(v11, v12);
      }
      v2[24] = 0;
      v2[21] = 0;
      v2[22] = 0;
      v2[20] = 0;
      ++*((_DWORD *)v2 + 46);
    }
    uint64_t v17 = v2[15];
    if (v17)
    {
      uint64_t v18 = v2[19];
      if (v18)
      {
        uint64_t v19 = v2[17];
        if (v19)
        {
          uint64_t v20 = 40 * v19;
          do
          {
            re::DynamicArray<unsigned long>::deinit(v18);
            v18 += 40;
            v20 -= 40;
          }
          while (v20);
          uint64_t v17 = v2[15];
          uint64_t v18 = v2[19];
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v18);
      }
      v2[19] = 0;
      v2[16] = 0;
      v2[17] = 0;
      v2[15] = 0;
      ++*((_DWORD *)v2 + 36);
    }
    uint64_t v21 = v2[10];
    if (v21)
    {
      if (v2[14]) {
        (*(void (**)(uint64_t))(*(void *)v21 + 40))(v21);
      }
      v2[14] = 0;
      v2[11] = 0;
      v2[12] = 0;
      v2[10] = 0;
      ++*((_DWORD *)v2 + 26);
    }
    uint64_t v22 = v2[5];
    if (v22)
    {
      if (v2[9]) {
        (*(void (**)(uint64_t))(*(void *)v22 + 40))(v22);
      }
      v2[9] = 0;
      v2[6] = 0;
      v2[7] = 0;
      float64x2_t v2[5] = 0;
      ++*((_DWORD *)v2 + 16);
    }
    if (*v2)
    {
      if (v2[4]) {
        (*(void (**)(void))(*(void *)*v2 + 40))(*v2);
      }
      v2[4] = 0;
      v2[1] = 0;
      void v2[2] = 0;
      *unint64_t v2 = 0;
      ++*((_DWORD *)v2 + 6);
    }
    uint64_t v23 = *(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 40);
    return (re *)v23(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::internal::RegexRoot *)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::internal::RegexRoot,std::function<void ()(re::internal::RegexRoot*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::internal::RegexRoot *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::internal::RegexRoot *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t std::function<void ()(re::internal::RegexRoot *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  }
  uint64_t v4 = (re::internal *)std::__throw_bad_function_call[abi:nn180100]();
  return re::internal::assertLog(v4, v5);
}

uint64_t re::internal::assertLog(re::internal *this, uint64_t a2, ...)
{
  return os_log_with_args();
}

size_t re::internal::FixedLengthString::append(size_t this, const char *a2)
{
  size_t v2 = *(void *)(this + 8);
  if (v2)
  {
    size_t v3 = this;
    strncpy(*(char **)this, a2, v2);
    *(unsigned char *)(*(void *)(v3 + 8) + *(void *)v3 - 1) = 0;
    this = strlen(*(const char **)v3);
    size_t v4 = *(void *)(v3 + 8) - this;
    *(void *)v3 += this;
    *(void *)(v3 + 8) = v4;
  }
  return this;
}

void re::internal::logStackTrace(re::internal *this, const char *a2, const char *a3)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  if (os_variant_has_internal_diagnostics()
    && (unint64_t)re::internal::logStackTrace(char const*,char const*)::nInvocations <= 0x3F)
  {
    ++re::internal::logStackTrace(char const*,char const*)::nInvocations;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    *(_OWORD *)uint64_t v36 = 0u;
    long long v37 = 0u;
    int v5 = backtrace(v36, 64);
    uint64_t v6 = backtrace_symbols(v36, v5);
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = "";
      }
      uint64_t v8 = "Stack trace:";
      if (this) {
        uint64_t v8 = (const char *)this;
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl(&dword_233120000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s%s", buf, 0x16u);
    }
    unint64_t v9 = v5 - 1;
    if (v9 >= 3)
    {
      if (a2) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = "";
      }
      uint64_t v30 = v10;
      uint64_t v11 = 2;
      uint64_t v12 = &_os_log_internal;
      do
      {
        uint64_t v13 = v6[v11];
        int v14 = *(unsigned __int8 *)v13;
        uint64_t v15 = v13;
        while ((v14 & 0xFFFFFFDF) != 0)
        {
          int v16 = *(unsigned __int8 *)++v15;
          int v14 = v16;
        }
        while (v14 == 32)
        {
          int v17 = *(unsigned __int8 *)++v15;
          int v14 = v17;
        }
        if ((v14 & 0xFFFFFFDF) != 0)
        {
          do
          {
            int v18 = *(unsigned __int8 *)++v15;
            int v14 = v18;
          }
          while ((v18 & 0xFFFFFFDF) != 0);
          while (v14 == 32)
          {
            int v19 = *(unsigned __int8 *)++v15;
            int v14 = v19;
          }
        }
        uint64_t v20 = v15;
        if (v14)
        {
          uint64_t v20 = v15 + 1;
          int v21 = *((unsigned __int8 *)v15 + 1);
          *uint64_t v15 = 0;
          while ((v21 & 0xFFFFFFDF) != 0)
          {
            int v22 = *(unsigned __int8 *)++v20;
            int v21 = v22;
          }
          while (v21 == 32)
          {
            int v23 = *(unsigned __int8 *)++v20;
            int v21 = v23;
          }
          if (v21)
          {
            int v24 = 0;
            uint64_t v15 = v20;
            while (v21 != 32 || v24)
            {
              int v25 = v24 - 1;
              if (v21 == 91) {
                ++v24;
              }
              if (v21 == 93) {
                int v24 = v25;
              }
              int v26 = *(unsigned __int8 *)++v15;
              int v21 = v26;
              if (!v26) {
                goto LABEL_43;
              }
            }
            *uint64_t v15 = 0;
          }
          else
          {
            uint64_t v15 = v20;
          }
        }
LABEL_43:
        uint64_t v27 = v15 + 1;
        uint64_t v28 = __cxa_demangle(v20, 0, 0, 0);
        *(void *)buf = &buf[16];
        *(void *)&uint8_t buf[8] = 256;
        re::internal::FixedLengthString::append((size_t)buf, v13);
        re::internal::FixedLengthString::append((size_t)buf, " ");
        if (v28) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = v20;
        }
        re::internal::FixedLengthString::append((size_t)buf, v29);
        re::internal::FixedLengthString::append((size_t)buf, " ");
        re::internal::FixedLengthString::append((size_t)buf, v27);
        if (v28) {
          free(v28);
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long v31 = 136315394;
          long long v32 = v30;
          __int16 v33 = 2080;
          uint64_t v34 = &buf[16];
          _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "%s%s", v31, 0x16u);
        }
        ++v11;
      }
      while (v11 != v9);
    }
    free(v6);
  }
}

void re::readBooleanEnvironmentVariable(re *this@<X0>, uint64_t a2@<X8>)
{
  id v10 = objc_alloc_init(MEMORY[0x263F08AB0]);
  int v5 = [v10 environment];
  uint64_t v6 = [NSString stringWithUTF8String:this];
  uint64_t v7 = [v5 objectForKey:v6];
  uint64_t v8 = [v7 lowercaseString];

  if (v8)
  {
    if ([v8 isEqualToString:@"1"]
      || [v8 isEqualToString:@"true"])
    {
      *(_WORD *)a2 = 257;
    }
    else
    {
      int v9 = [v8 isEqualToString:@"yes"];
      *(unsigned char *)a2 = 1;
      if (v9) {
        *(unsigned char *)(a2 + 1) = 1;
      }
      else {
        *(unsigned char *)(a2 + 1) = 0;
      }
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

uint64_t *re::foundationCoreLogObjects(re *this)
{
  {
    re::foundationCoreLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Core");
  }
  return &re::foundationCoreLogObjects(void)::logObjects;
}

size_t re::packCharArrayToUInt64ForAriadne(re *this, const char *a2)
{
  int v2 = (int)a2;
  size_t result = strlen((const char *)this);
  if (result)
  {
    if (result <= v2) {
      return 0;
    }
    unint64_t v5 = result - v2;
    if (v5 >= 8) {
      LODWORD(v5) = 8;
    }
    int v6 = result <= 8 ? result : v5;
    if (v6 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v8 = v6 + v2;
      do
      {
        size_t result = v7 | *((char *)this + v8 - 1);
        uint64_t v7 = result << 8;
        --v8;
      }
      while (v8 > v2);
    }
  }
  return result;
}

BOOL re::internal::enableSignposts(re::internal *this, uint64_t a2)
{
  {
    unsigned int v6 = a2;
    char v7 = (char)this;
    a2 = v6;
    LOBYTE(this) = v7;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"enableSignposts", (const char *)v6, (uint64_t)v8);
      if (v8[0]) {
        BOOL v4 = v9 == 0;
      }
      else {
        BOOL v4 = 0;
      }
      char v5 = !v4;
      re::internal::enableSignposts(BOOL,BOOL)::value = v5;
      a2 = v6;
      LOBYTE(this) = v7;
    }
  }
  if ((this & 1) == 0) {
    return re::internal::enableSignposts(BOOL,BOOL)::value != 0;
  }
  re::internal::enableSignposts(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyTracing(re::internal *this, uint64_t a2)
{
  {
    unsigned int v6 = a2;
    char v7 = (char)this;
    a2 = v6;
    LOBYTE(this) = v7;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyTracing", (const char *)v6, (uint64_t)v8);
      if (v8[0]) {
        BOOL v4 = v9 == 0;
      }
      else {
        BOOL v4 = 1;
      }
      char v5 = !v4;
      re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value = v5;
      a2 = v6;
      LOBYTE(this) = v7;
    }
  }
  if ((this & 1) == 0) {
    return re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value != 0;
  }
  re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyNetworkTracing(re::internal *this, uint64_t a2)
{
  {
    unsigned int v6 = a2;
    char v7 = (char)this;
    a2 = v6;
    LOBYTE(this) = v7;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyNetworkTracing", (const char *)v6, (uint64_t)v8);
      if (v8[0]) {
        BOOL v4 = v9 == 0;
      }
      else {
        BOOL v4 = 1;
      }
      char v5 = !v4;
      re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = v5;
      a2 = v6;
      LOBYTE(this) = v7;
    }
  }
  if ((this & 1) == 0) {
    return re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value != 0;
  }
  re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = a2;
  return a2;
}

void re::FoundationErrorCategoryImpl::~FoundationErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x237DBCBD0);
}

const char *re::FoundationErrorCategoryImpl::name(re::FoundationErrorCategoryImpl *this)
{
  return "REFoundation error";
}

void *re::FoundationErrorCategoryImpl::message@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 299)
  {
    if (a1 == 300)
    {
      int v3 = "File I/O error";
      return std::string::basic_string[abi:nn180100]<0>(a2, v3);
    }
    if (a1 == 400)
    {
      int v3 = "Serialization error";
      return std::string::basic_string[abi:nn180100]<0>(a2, v3);
    }
LABEL_9:
    int v3 = "Unknown REFoundation error";
    return std::string::basic_string[abi:nn180100]<0>(a2, v3);
  }
  if (a1 == 100)
  {
    int v3 = "Unexpected error";
    return std::string::basic_string[abi:nn180100]<0>(a2, v3);
  }
  if (a1 != 200) {
    goto LABEL_9;
  }
  int v3 = "JSON serialization error";
  return std::string::basic_string[abi:nn180100]<0>(a2, v3);
}

double re::EventBus::EventBus(re::EventBus *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26E6DE6F8;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)((char *)this + 188) = 0x7FFFFFFFLL;
  return result;
}

void re::EventBus::~EventBus(re::EventBus *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::EventBus::~EventBus(this);
  JUMPOUT(0x237DBCBD0);
}

void *re::EventBus::EventInfo::publish(re::EventBus::EventInfo *this, uint64_t a2, uint64_t a3, const void *a4)
{
  ++*((_DWORD *)this + 4);
  if (a4 && a2 && *((unsigned char *)this + 23))
  {
    uint64_t v17 = a2;
    int v18 = a4;
    uint64_t v8 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v8 == -1) {
      int v9 = 0;
    }
    else {
      int v9 = (void *)(*((void *)this + 28) + 144 * v8 + 16);
    }
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v9, a2, a3);
  }
  if (a2 && *((unsigned char *)this + 21))
  {
    uint64_t v17 = a2;
    int v18 = 0;
    uint64_t v10 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v10 == -1) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (void *)(*((void *)this + 28) + 144 * v10 + 16);
    }
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v11, a2, a3);
  }
  if (a4 && *((unsigned char *)this + 22))
  {
    uint64_t v17 = 0;
    int v18 = a4;
    uint64_t v12 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v12 == -1) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = (void *)(*((void *)this + 28) + 144 * v12 + 16);
    }
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v13, a2, a3);
  }
  re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, (void *)this + 11, a2, a3);
  return re::EventBus::EventInfo::stopPublishing(this, v14, v15);
}

uint64_t re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v5 = a2[2];
    if (v5)
    {
      uint64_t v8 = (re::EventBus::EventInfo *)result;
      uint64_t v9 = a2[4];
      uint64_t v10 = v5 << 6;
      uint64_t v11 = (void *)(v9 + 56);
      do
      {
        *(void *)&v21[0] = a3;
        *(void *)double v14 = a4;
        double result = (*(uint64_t (**)(void, _OWORD *, unsigned char *))(*(void *)*v11 + 16))(*v11, v21, v14);
        if (result == 1)
        {
          unint64_t v12 = (v9 - a2[4]) >> 6;
          unint64_t v13 = a2[7];
          if (v13 <= v12)
          {
            memset(v21, 0, sizeof(v21));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)double v14 = 136315906;
            *(void *)&v14[4] = "operator[]";
            __int16 v15 = 1024;
            int v16 = 797;
            __int16 v17 = 2048;
            unint64_t v18 = v12;
            __int16 v19 = 2048;
            unint64_t v20 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          double result = re::EventBus::EventInfo::removeSubscription(v8, *(void *)(a2[9] + 8 * v12));
        }
        v9 += 64;
        v11 += 8;
        v10 -= 64;
      }
      while (v10);
    }
  }
  return result;
}

void *re::EventBus::EventInfo::stopPublishing(void *this, double a2, __n128 a3)
{
  int v3 = *((_DWORD *)this + 4) - 1;
  *((_DWORD *)this + 4) = v3;
  if (!v3)
  {
    BOOL v4 = this;
    if (this[38])
    {
      v17[0] = this + 35;
      unint64_t v5 = this[37];
      if (v5 >= 0x10)
      {
        uint64_t v6 = 0;
        uint64_t v7 = this[35];
        unint64_t v8 = v5 >> 4;
        __n128 v9 = (__n128)xmmword_2343680E0;
        a3.n128_u64[0] = 0x3830282018100800;
        while (1)
        {
          unsigned __int16 v10 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
          v17[1] = (unsigned __int16)~v10;
          if (v10 != 0xFFFF) {
            break;
          }
          v6 += 16;
          if (!--v8) {
            goto LABEL_12;
          }
        }
        uint64_t v11 = __clz(__rbit64((unsigned __int16)~v10)) + v6;
        uint64_t v18 = v11;
        if (v11 != -1)
        {
          do
          {
            uint64_t v12 = *(void *)(*(void *)(v17[0] + 8) + 56 * v11 + 48);
            (*(void (**)(uint64_t, __n128, __n128))(*(void *)v12 + 16))(v12, v9, a3);
            this = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v17);
            uint64_t v11 = v18;
          }
          while (v18 != -1);
          unint64_t v5 = v4[37];
        }
      }
LABEL_12:
      v4[40] = 0;
      v4[41] = 0;
      v4[38] = 0;
      v4[39] = v5;
      if (v5 >= 0x10)
      {
        unint64_t v13 = 0;
        *(void *)&long long v14 = -1;
        *((void *)&v14 + 1) = -1;
        do
        {
          *(_OWORD *)(v4[35] + 16 * v13++) = v14;
          unint64_t v5 = v4[37];
        }
        while (v13 < v5 >> 4);
      }
      if (v5)
      {
        uint64_t v15 = 56 * v5;
        uint64_t v16 = v4[36] + 16;
        do
        {
          this = re::FunctionBase<24ul,void ()(void)>::destroyCallable(v16);
          v16 += 56;
          v15 -= 56;
        }
        while (v15);
      }
    }
  }
  return this;
}

uint64_t re::EventBus::publish(re::EventBus *this, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, const void *a6)
{
  uint64_t v11 = a3;
  uint64_t result = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((void *)this + 3, &v11);
  if (result != -1)
  {
    uint64_t result = *(void *)(*((void *)this + 4) + 48 * result + 8);
    if (result) {
      return (uint64_t)re::EventBus::EventInfo::publish((re::EventBus::EventInfo *)result, a2, a4, a6);
    }
  }
  return result;
}

uint64_t *re::EventBus::EventInfo::addToBatch(re::EventBus::EventInfo *this, re::EventBus *a2, uint64_t a3, const void *a4, size_t __n, const void *a6)
{
  v20[0] = (uint64_t)a2;
  v20[1] = (uint64_t)this;
  if (a3 && a6 && *((unsigned char *)this + 23))
  {
    uint64_t v18 = a3;
    __int16 v19 = a6;
    uint64_t v11 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v11 == -1) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = (void *)(*((void *)this + 28) + 144 * v11 + 16);
    }
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v12, a3, a4, __n);
  }
  if (a3 && *((unsigned char *)this + 21))
  {
    uint64_t v18 = a3;
    __int16 v19 = 0;
    uint64_t v13 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v13 == -1) {
      long long v14 = 0;
    }
    else {
      long long v14 = (void *)(*((void *)this + 28) + 144 * v13 + 16);
    }
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v14, a3, a4, __n);
  }
  if (a3 && *((unsigned char *)this + 22))
  {
    uint64_t v18 = 0;
    __int16 v19 = a6;
    uint64_t v15 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v15 == -1) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = (void *)(*((void *)this + 28) + 144 * v15 + 16);
    }
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v16, a3, a4, __n);
  }
  return re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, (void *)this + 11, a3, a4, __n);
}

uint64_t *re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(uint64_t *result, void *a2, uint64_t a3, const void *a4, size_t __n)
{
  long long v44 = result;
  uint64_t v67 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v5 = a2[2];
    if (v5)
    {
      size_t v6 = __n;
      unint64_t v7 = result[1];
      uint64_t v8 = a2[4];
      unint64_t v39 = __n + 7;
      uint64_t v40 = v8 + (v5 << 6);
      size_t v9 = (__n + 7) >> 3;
      unint64_t v10 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      unint64_t v45 = v10 ^ (v10 >> 31);
      long long v41 = a2;
      do
      {
        unint64_t v11 = (v8 - a2[4]) >> 6;
        *(void *)&long long v46 = v7;
        *((void *)&v46 + 1) = v8;
        unint64_t v12 = a2[7];
        if (v12 <= v11)
        {
          uint64_t v53 = 0;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v62 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v54 = 136315906;
          long long v55 = "operator[]";
          __int16 v56 = 1024;
          int v57 = 797;
          __int16 v58 = 2048;
          unint64_t v59 = v11;
          __int16 v60 = 2048;
          unint64_t v61 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        *(void *)&long long v47 = *(void *)(a2[9] + 8 * v11);
        *((void *)&v47 + 1) = a3;
        long long v48 = 0;
        size_t v49 = 0;
        char v13 = 1;
        int v50 = 1;
        unint64_t v51 = 0;
        long long v52 = 0;
        if (v39 >= 8)
        {
          re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity(&v48, v9);
          char v15 = v50;
          v50 += 2;
          BOOL v16 = (v15 & 1) == 0;
          unint64_t v17 = 4;
          if (v16) {
            unint64_t v17 = v51;
          }
          if (v17 < v9) {
            re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity(&v48, v9);
          }
          size_t v18 = v49;
          if (v49 < v9)
          {
            do
            {
              if (v50) {
                __int16 v19 = &v51;
              }
              else {
                __int16 v19 = v52;
              }
              v19[v18++] = 0;
            }
            while (v9 != v18);
          }
          size_t v49 = v9;
          char v13 = v50 + 2;
          v50 += 2;
          long long v14 = v52;
        }
        else
        {
          long long v14 = 0;
        }
        if (v13) {
          unint64_t v20 = &v51;
        }
        else {
          unint64_t v20 = v14;
        }
        int v21 = (_anonymous_namespace_ *)memcpy(v20, a4, v6);
        uint64_t v22 = *v44;
        unint64_t v23 = *(unsigned int *)(*v44 + 176);
        if (v23)
        {
          unint64_t v24 = v45 % v23;
          uint64_t v25 = *(unsigned int *)(*(void *)(v22 + 160) + 4 * (v45 % v23));
          if (v25 != 0x7FFFFFFF)
          {
            uint64_t v26 = *(void *)(v22 + 168);
            while (*(void *)(v26 + 24 * v25 + 16) != v7)
            {
              LODWORD(v25) = *(_DWORD *)(v26 + 24 * v25 + 8) & 0x7FFFFFFF;
              if (v25 == 0x7FFFFFFF) {
                goto LABEL_27;
              }
            }
            goto LABEL_33;
          }
        }
        else
        {
          unint64_t v24 = 0;
        }
LABEL_27:
        uint64_t v27 = *(unsigned int *)(v22 + 188);
        if (v27 == 0x7FFFFFFF)
        {
          uint64_t v27 = *(unsigned int *)(v22 + 184);
          int v28 = v27;
          if (v27 == v23)
          {
            re::HashSetBase<re::TextureAsset *,re::TextureAsset *,re::internal::ValueAsKey<re::TextureAsset *>,re::Hash<re::TextureAsset *>,re::EqualTo<re::TextureAsset *>,true,false>::setCapacity(v22 + 152, 2 * *(_DWORD *)(v22 + 180));
            unint64_t v24 = v45 % *(unsigned int *)(v22 + 176);
            int v28 = *(_DWORD *)(v22 + 184);
          }
          *(_DWORD *)(v22 + 184) = v28 + 1;
          uint64_t v29 = *(void *)(v22 + 168);
          int v30 = *(_DWORD *)(v29 + 24 * v27 + 8);
        }
        else
        {
          uint64_t v29 = *(void *)(v22 + 168);
          int v30 = *(_DWORD *)(v29 + 24 * v27 + 8);
          *(_DWORD *)(v22 + 188) = v30 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v29 + 24 * v27 + 8) = v30 | 0x80000000;
        *(_DWORD *)(*(void *)(v22 + 168) + 24 * v27 + 8) = *(_DWORD *)(*(void *)(v22 + 168) + 24 * v27 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v22 + 160) + 4 * v24);
        *(void *)(*(void *)(v22 + 168) + 24 * v27) = v45;
        *(void *)(*(void *)(v22 + 168) + 24 * v27 + 16) = v7;
        *(_DWORD *)(*(void *)(v22 + 160) + 4 * vre::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v27;
        ++*(_DWORD *)(v22 + 180);
        ++*(_DWORD *)(v22 + 192);
LABEL_33:
        long long v32 = (uint64_t *)(v22 + 120);
        uint64_t v31 = *(void *)(v22 + 120);
        unint64_t v33 = v31 + 1;
        unint64_t v34 = *(void *)(v22 + 112);
        if (v31 + 1 >= v34)
        {
          if (v34 < v33)
          {
            if (*(void *)(v22 + 104))
            {
              unint64_t v35 = 2 * v34;
              if (!v34) {
                unint64_t v35 = 8;
              }
              if (v35 <= v33) {
                unint64_t v36 = v33;
              }
              else {
                unint64_t v36 = v35;
              }
              re::Queue<re::EventBus::DeferredEvent>::setCapacity((void *)(v22 + 104), v36);
              uint64_t v31 = *v32;
            }
            else
            {
              re::Queue<re::EventBus::DeferredEvent>::setCapacity((void *)(v22 + 104), v33);
              uint64_t v31 = 0;
              *long long v32 = 0;
              *(void *)(v22 + 128) = 0;
              *(_DWORD *)(v22 + 136) = 0;
            }
            size_t v6 = __n;
          }
          unint64_t v34 = *(void *)(v22 + 112);
        }
        long long v37 = (_OWORD *)(*(void *)(v22 + 144) + 88 * ((*(void *)(v22 + 128) + v31) % v34));
        *long long v37 = v46;
        v37[1] = v47;
        re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)(v37 + 2), (uint64_t)&v48);
        ++*(void *)(v22 + 120);
        ++*(_DWORD *)(v22 + 136);
        uint64_t result = v48;
        if (v48)
        {
          if ((v50 & 1) == 0) {
            uint64_t result = (uint64_t *)(*(uint64_t (**)(void))(*v48 + 40))();
          }
        }
        v8 += 64;
        a2 = v41;
      }
      while (v8 != v40);
    }
  }
  return result;
}

void re::EventBus::endBatch(re::EventBus *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    uint64_t v4 = v2 - 1;
    *((void *)this + 12) = v4;
    if (!v4)
    {
      int v33 = 0;
      long long v30 = *(_OWORD *)((char *)this + 152);
      *((void *)this + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
      *((void *)this + 20) = 0;
      uint64_t v5 = *((void *)this + 21);
      uint64_t v31 = v5;
      *((void *)this + 21) = 0;
      long long v32 = *((_OWORD *)this + 11);
      long long v6 = v32;
      __n128 v7 = (__n128)xmmword_23436F740;
      *((_OWORD *)this + 11) = xmmword_23436F740;
      uint64_t v8 = 0;
      uint64_t v9 = DWORD2(v6);
      if (DWORD2(v6))
      {
        unint64_t v10 = (int *)(v5 + 8);
        while (1)
        {
          int v11 = *v10;
          v10 += 6;
          if (v11 < 0) {
            break;
          }
          if (DWORD2(v6) == ++v8)
          {
            LODWORD(v8) = DWORD2(v6);
            break;
          }
        }
      }
      if (DWORD2(v6) != v8)
      {
        uint64_t v12 = v8;
        do
        {
          ++*(_DWORD *)(*(void *)(v5 + 24 * v12 + 16) + 16);
          if (DWORD2(v6) <= (v8 + 1)) {
            int v13 = v8 + 1;
          }
          else {
            int v13 = DWORD2(v6);
          }
          int v14 = v8;
          while (1)
          {
            uint64_t v12 = (v14 + 1);
            if (v13 - 1 == v14) {
              break;
            }
            ++v14;
            LODWORD(v8) = v12;
            if ((*(_DWORD *)(v5 + 24 * v12 + 8) & 0x80000000) != 0) {
              goto LABEL_18;
            }
          }
          LODWORD(v8) = v13;
LABEL_18:
          ;
        }
        while (DWORD2(v6) != v8);
      }
      while (*((void *)this + 15))
      {
        char v15 = (_OWORD *)(*((void *)this + 18) + 88 * *((void *)this + 16));
        *(_OWORD *)uint64_t v25 = *v15;
        *(_OWORD *)uint64_t v26 = v15[1];
        re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)&v27, (uint64_t)(v15 + 2));
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(*((void *)this + 18)
                                                                   + 88 * *((void *)this + 16) + 32);
        uint64_t v16 = *((void *)this + 16);
        if ((unint64_t)(v16 + 1) < *((void *)this + 14)) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = 0;
        }
        --*((void *)this + 15);
        *((void *)this + 16) = v17;
        ++*((_DWORD *)this + 34);
        if (v28) {
          size_t v18 = v29;
        }
        else {
          size_t v18 = (void *)v29[1];
        }
        unint64_t v34 = v18;
        unint64_t v35 = v26[1];
        if ((*(unsigned int (**)(void, unint64_t *, void **))(**((void **)v25[1] + 7) + 16))(*((void *)v25[1] + 7), &v35, &v34) == 1)re::EventBus::EventInfo::removeSubscription(v25[0], v26[0]); {
        if (v27 && (v28 & 1) == 0)
        }
          (*(void (**)(void))(*(void *)v27 + 40))();
      }
      uint64_t v19 = 0;
      if (v9)
      {
        unint64_t v20 = (int *)(v5 + 8);
        while (1)
        {
          int v21 = *v20;
          v20 += 6;
          if (v21 < 0) {
            break;
          }
          if (v9 == ++v19)
          {
            LODWORD(vre::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = v9;
            break;
          }
        }
      }
      if (v9 != v19)
      {
        uint64_t v22 = v19;
        do
        {
          re::EventBus::EventInfo::stopPublishing(*(void **)(v5 + 24 * v22 + 16), *(double *)&v6, v7);
          if (v9 <= (int)v19 + 1) {
            int v23 = v19 + 1;
          }
          else {
            int v23 = v9;
          }
          int v24 = v19;
          while (1)
          {
            uint64_t v22 = (v24 + 1);
            if (v23 - 1 == v24) {
              break;
            }
            ++v24;
            LODWORD(vre::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = v22;
            if ((*(_DWORD *)(v5 + 24 * v22 + 8) & 0x80000000) != 0) {
              goto LABEL_47;
            }
          }
          LODWORD(vre::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = v23;
LABEL_47:
          ;
        }
        while (v9 != v19);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v30);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unbalanced beginBatch/endBatch", "m_batchLevel > 0", "endBatch", 108);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::EventBus::EventInfo::removeSubscription(re::EventBus::EventInfo *this, unint64_t a2)
{
  v10[1] = a2;
  unint64_t v11 = a2;
  int v3 = (uint64_t *)((char *)this + 24);
  v10[0] = *(void *)this;
  re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::remove((uint64_t *)this + 35, v10);
  uint64_t result = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(v3, (uint64_t *)&v11);
  if (result != -1)
  {
    uint64_t v5 = *((void *)this + 4);
    uint64_t v6 = v5 + 24 * result;
    uint64_t v8 = *(void *)(v6 + 8);
    __n128 v7 = (void *)(v6 + 8);
    if (v8 || *(void *)(v5 + 24 * result + 16)) {
      uint64_t v9 = (void *)(*((void *)this + 28)
    }
                    + 144
                    * re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, v7)+ 16);
    else {
      uint64_t v9 = (void *)((char *)this + 88);
    }
    re::EventBus::Subscriptions::remove(v9, v11);
    return re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::remove(v3, (uint64_t *)&v11);
  }
  return result;
}

uint64_t re::EventBus::subscribe(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  v13[8] = *MEMORY[0x263EF8340];
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, a2);
  re::EventBus::createHandler(a4, a6, v13);
  uint64_t v11 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v13, a3, a5);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v13);
  return v11;
}

uint64_t (***re::EventBus::createHandler@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    uint64_t v8 = 0;
    uint64_t v5 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)v6, a1);
    a3[6] = re::globalAllocators(v5)[2];
    a3[7] = 0;
    *a3 = &unk_26E6DE798;
    a3[4] = v7;
    a3[5] = 0;
    re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v6);
    a3[7] = a3;
    return re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v6);
  }
  else
  {
    a3[6] = *(void *)(a1 + 24);
    a3[7] = 0;
    return (uint64_t (***)(void))re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)a3, a1);
  }
}

uint64_t re::EventBus::unsubscribe(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = a2;
  uint64_t result = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((void *)(a1 + 24), &v6);
  if (result != -1)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 32) + 48 * result + 8);
    if (result) {
      return re::EventBus::EventInfo::removeSubscription((re::EventBus::EventInfo *)result, a3);
    }
  }
  return result;
}

unint64_t re::EventBus::getTypeId(re::EventBus *this, const char *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  size_t v3 = strlen((const char *)this);
  if (v3)
  {
    unint64_t v4 = 0;
    do
    {
      unint64_t v5 = v4 + 1;
      v13[v4] = (v3 % 0xA) | 0x30;
      if (v3 < 0xA) {
        break;
      }
      v3 /= 0xAuLL;
    }
    while (v4++ < 0x7E);
    if (v5 != 1)
    {
      uint64_t v7 = &v13[v5 - 1];
      unint64_t v8 = v5 >> 1;
      uint64_t v9 = v13;
      do
      {
        char v10 = *v9;
        *v9++ = *v7;
        *v7-- = v10;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    v13[0] = 48;
    unint64_t v5 = 1;
  }
  v13[v5] = 0;
  strncpy(&v13[v5], (const char *)this, 128 - v5);
  v13[127] = 0;
  return re::EventBus::typeStringToId((re::EventBus *)v13, v11);
}

void *re::Queue<re::EventBus::DeferredEvent>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    uint64_t v6 = result + 2;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::Queue<re::EventBus::DeferredEvent>::setCapacity(v5, a2);
        *uint64_t v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x58uLL))
        {
          uint64_t v2 = 88 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 88 * a2, 8);
          if (result)
          {
            unint64_t v8 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 88, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        uint64_t v9 = 0;
        uint64_t v10 = v5[3];
        do
        {
          uint64_t v11 = (_OWORD *)(v5[5] + 88 * ((unint64_t)(v9 + v5[3]) % v5[1]));
          long long v12 = v11[1];
          int v13 = &v8[11 * v10];
          *int v13 = *v11;
          v13[1] = v12;
          uint64_t v14 = (uint64_t)(v11 + 2);
          re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)(v13 + 2), (uint64_t)(v11 + 2));
          re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v14);
          if (v10 + 1 < a2) {
            ++v10;
          }
          else {
            uint64_t v10 = 0;
          }
          ++v9;
        }
        while (v9 != v5[2]);
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  unint64_t v4 = (char *)(a1 + 24);
  *(void *)(a1 + 32) = 0;
  if ((*(unsigned char *)(a2 + 16) & 1) == 0)
  {
    *(_DWORD *)(a1 + 16) = 3;
    uint64_t v5 = *(void *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v5;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = v6;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16) & 0xFFFFFFFE | *(_DWORD *)(a1 + 16) & 1;
    *(_DWORD *)(a1 + 16) &= ~1u;
    uint64_t v7 = *(void *)(a1 + 24);
    *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24);
    *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v7;
LABEL_18:
    int v14 = 2;
    goto LABEL_19;
  }
  unint64_t v8 = *(void *)(a2 + 8);
  if (!v8)
  {
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
    *(void *)a1 = *(void *)a2;
    goto LABEL_18;
  }
  *(void *)a1 = *(void *)a2;
  re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity((void *)a1, v8);
  if (*(unsigned char *)(a2 + 16)) {
    uint64_t v9 = (const void *)(a2 + 24);
  }
  else {
    uint64_t v9 = *(const void **)(a2 + 32);
  }
  uint64_t v10 = *(void *)(a1 + 8);
  int v11 = *(_DWORD *)(a1 + 16);
  long long v12 = v4;
  if ((v11 & 1) == 0) {
    long long v12 = *(void **)(a1 + 32);
  }
  if (v10)
  {
    memmove(v12, v9, 8 * v10);
    int v11 = *(_DWORD *)(a1 + 16);
  }
  if ((v11 & 1) == 0) {
    unint64_t v4 = *(char **)(a1 + 32);
  }
  if (*(_DWORD *)(a2 + 16)) {
    uint64_t v13 = a2 + 24;
  }
  else {
    uint64_t v13 = *(void *)(a2 + 32);
  }
  memcpy(&v4[8 * *(void *)(a1 + 8)], (const void *)(v13 + 8 * *(void *)(a1 + 8)), 8 * v8 - 8 * *(void *)(a1 + 8));
  *(void *)(a1 + 8) = v8;
  *(void *)(a2 + 8) = 0;
  int v14 = 4;
LABEL_19:
  *(_DWORD *)(a2 + 16) = ((*(_DWORD *)(a2 + 16) & 0xFFFFFFFE) + v14) | *(_DWORD *)(a2 + 16) & 1;
  *(_DWORD *)(a1 + 16) += 2;
  return a1;
}

BOOL re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::remove(uint64_t *a1, void *a2)
{
  uint64_t v3 = re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::find(a1, a2);
  uint64_t v4 = v3;
  if (v3 != -1)
  {
    uint64_t v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    int8x8_t v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    if (v7) {
      char v8 = -1;
    }
    else {
      char v8 = 0x80;
    }
    v5->i8[v3 & 0xF] = v8;
    a1[5] ^= re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v13, (void *)(a1[1] + 56 * v3));
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1[1] + 56 * v4 + 16);
    if (v7) {
      uint64_t v9 = a1[4] + 1;
    }
    else {
      uint64_t v9 = a1[4];
    }
    unint64_t v10 = a1[2];
    unint64_t v11 = a1[3] - 1;
    a1[3] = v11;
    a1[4] = v9;
    if (v10 >= 0x11 && v11 < v10 >> 2) {
      re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::resize(a1, 0);
    }
  }
  return v4 != -1;
}

void *re::EventBus::Subscriptions::remove(void *this, uint64_t a2)
{
  uint64_t v2 = this;
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v3 = this[9];
  uint64_t v4 = this[7];
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    int8x16_t v6 = (void *)this[9];
    while (*v6 != a2)
    {
      ++v6;
      v5 -= 8;
      if (!v5)
      {
        int8x16_t v6 = (void *)(v3 + 8 * v4);
        break;
      }
    }
  }
  else
  {
    int8x16_t v6 = (void *)this[9];
  }
  unint64_t v7 = ((uint64_t)v6 - v3) >> 3;
  if (v7 != v4)
  {
    uint64_t v10 = ((uint64_t)v6 - v3) >> 3;
    unint64_t v8 = this[2];
    if (v8 <= v7)
    {
      uint64_t v11 = 0;
      long long v24 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v12 = 136315906;
      char v13 = "operator[]";
      __int16 v14 = 1024;
      int v15 = 789;
      __int16 v16 = 2048;
      unint64_t v17 = v7;
      __int16 v18 = 2048;
      unint64_t v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      uint64_t v9 = (void *)(this[4] + (v7 << 6));
      re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v9);
      *uint64_t v9 = &unk_26E6DE740;
      v9[7] = v9;
      unint64_t v8 = v2[7];
      if (v8 > v7)
      {
        *(void *)(v2[9] + 8 * v7) = 0;
        this = re::DynamicArray<unsigned long>::add(v2 + 10, &v10);
        --v2[15];
        return this;
      }
    }
    uint64_t v11 = 0;
    long long v24 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v12 = 136315906;
    char v13 = "operator[]";
    __int16 v14 = 1024;
    int v15 = 789;
    __int16 v16 = 2048;
    unint64_t v17 = v7;
    __int16 v18 = 2048;
    unint64_t v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return this;
}

BOOL re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::remove(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(a1, a2);
  uint64_t v4 = v3;
  if (v3 != -1)
  {
    uint64_t v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    int8x8_t v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    if (v7) {
      char v8 = -1;
    }
    else {
      char v8 = 0x80;
    }
    v5->i8[v3 & 0xF] = v8;
    unint64_t v9 = a1[2];
    unint64_t v10 = *(void *)(a1[1] + 24 * v3);
    unint64_t v11 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) >> 27));
    a1[5] ^= (v11 >> 31) ^ v11;
    uint64_t v12 = a1[4];
    if (v7) {
      ++v12;
    }
    unint64_t v13 = a1[3] - 1;
    a1[3] = v13;
    a1[4] = v12;
    if (v9 >= 0x11 && v13 < v9 >> 2) {
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize(a1, 0);
    }
  }
  return v4 != -1;
}

void re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable()
{
}

uint64_t re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()()
{
  return 0;
}

void *re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DE740;
  return result;
}

void *re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DE740;
  return result;
}

uint64_t re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 16;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6DE798;
  re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6DE798;
  re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = v3;
  (*(void (**)(void, uint64_t *, uint64_t *))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v6, &v5);
  return 1;
}

void *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DE798;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DE798;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a1);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
    uint64_t v6 = a1;
    if (v5 >= 0x31)
    {
      unint64_t v7 = v5;
      uint64_t v8 = *(void *)(a1 + 48);
      if (v8) {
        uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
      }
      else {
        uint64_t v6 = 0;
      }
    }
    *(void *)(a1 + 56) = v6;
    (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
  }
  return a1;
}

double re::Queue<re::EventBus::DeferredEvent>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      if (a1[2])
      {
        uint64_t v4 = 0;
        do
        {
          re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1[5]
                                                                     + 88 * ((v4 + a1[3]) % (unint64_t)a1[1]) + 32);
          ++v4;
        }
        while (v4 != a1[2]);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    double result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

BOOL re::isEngineFrameworkIdentifier(re *this, const char *a2)
{
  return !strcmp((const char *)this, "com.apple.REResources")
      || !strcmp((const char *)this, "com.apple.CoreRE")
      || strcmp((const char *)this, "com.apple.RealityKit") == 0;
}

BOOL re::isEngineFrameworkPath(re *this, const char *a2)
{
  return !strncmp((const char *)this, "com.apple.REResources", 0x15uLL)
      || !strncmp((const char *)this, "com.apple.CoreRE", 0x10uLL)
      || strncmp((const char *)this, "com.apple.RealityKit", 0x14uLL) == 0;
}

uint64_t re::protectionOptions(re *this)
{
  unint64_t v1 = &unk_26879F000;
  {
    unint64_t v1 = (void *)&unk_26879F000;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"protection.options", v4, (uint64_t)v6);
      uint64_t v5 = v7;
      if (!v6[0]) {
        uint64_t v5 = 0;
      }
      re::protectionOptions(void)::options = v5;
      unint64_t v1 = (void *)&unk_26879F000;
    }
  }
  return v1[158];
}

void re::Defaults::intValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    uint64_t v6 = v4;
    *(_DWORD *)(a3 + 4) = [v4 intValue];
    uint64_t v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)a3 = v5;
}

id anonymous namespace'::getValue(_anonymous_namespace_ *this, const char *a2)
{
  int v3 = [MEMORY[0x263EFFA40] standardUserDefaults];
  uint64_t v4 = objc_msgSend(NSString, "stringWithFormat:", @"%s.%s", "com.apple.re", this);
  char v5 = [v3 objectForKey:v4];
  if (!v5)
  {
    uint64_t v6 = [NSString stringWithUTF8String:this];
    int v7 = [v3 objectForKey:v6];
    if (v7)
    {
      char v5 = v7;
      uint64_t v8 = v6;
    }
    else
    {
      uint64_t v9 = [v4 rangeOfString:@"." options:4];
      unint64_t v10 = [v4 substringToIndex:v9];
      uint64_t v8 = [v4 substringFromIndex:v9 + 1];

      if ([(__CFString *)v10 isEqualToString:@"com.apple.re.network.multipeerservice"])
      {

        unint64_t v10 = @"com.apple.renetwork.multipeerservice";
      }
      unint64_t v11 = [v3 dictionaryForKey:v10];
      char v5 = [v11 objectForKey:v8];

      if (!v5) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = *re::foundationCoreLogObjects(v7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
    }
LABEL_9:
  }
  return v5;
}

void re::Defaults::BOOLValue(re::Defaults *this@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    uint64_t v6 = v4;
    a3[1] = [v4 BOOLValue];
    uint64_t v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *a3 = v5;
}

void re::Defaults::uintValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    uint64_t v6 = v4;
    *(_DWORD *)(a3 + 4) = [v4 unsignedIntValue];
    uint64_t v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)a3 = v5;
}

void re::Defaults::uint64Value(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    uint64_t v6 = v4;
    *(void *)(a3 + 8) = [v4 unsignedLongLongValue];
    uint64_t v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)a3 = v5;
}

void re::Defaults::floatValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    int v7 = v4;
    [v4 floatValue];
    uint64_t v4 = v7;
    *(_DWORD *)(a3 + 4) = v5;
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)a3 = v6;
}

void re::Defaults::doubleValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  if (v4)
  {
    int v7 = v4;
    [v4 doubleValue];
    uint64_t v4 = v7;
    *(void *)(a3 + 8) = v5;
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)a3 = v6;
}

void re::Defaults::stringValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = ;
  uint64_t v5 = v4;
  if (v4)
  {
    char v6 = (_anonymous_namespace_ *)[v4 UTF8String];
    *(void *)(a3 + 8) = v8;
    *(void *)(a3 + 32) = v10;
    *(_OWORD *)(a3 + 16) = v9;
    char v7 = 1;
  }
  else
  {
    char v7 = 0;
  }
  *(unsigned char *)a3 = v7;
}

re::LeakTestAllocator *re::LeakTestAllocator::LeakTestAllocator(re::LeakTestAllocator *this, const char *a2, re::Allocator *a3)
{
  uint64_t v5 = re::Allocator::Allocator(this, a2, 1);
  *(void *)uint64_t v5 = &unk_26E6DE7F0;
  *((void *)v5 + 3) = a3;
  *((_OWORD *)v5 + 3) = 0u;
  *((_DWORD *)v5 + 16) = 0;
  *((_OWORD *)v5 + 2) = 0u;
  *(void *)((char *)this + 68) = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v5 + 32, (uint64_t)a3, 3);
  return this;
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    char v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    __int16 v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_8, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

void re::LeakTestAllocator::~LeakTestAllocator(re::LeakTestAllocator *this, uint64_t a2)
{
  if (*((_DWORD *)this + 15))
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) %u memory leaks found.", "m_allocations.size() == 0", "~LeakTestAllocator", 18, *((unsigned int *)this + 15));
    _os_crash();
    __break(1u);
  }
  else
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 4);
    re::Allocator::~Allocator(this);
  }
}

{
  uint64_t vars8;

  re::LeakTestAllocator::~LeakTestAllocator(this, a2);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::LeakTestAllocator::alloc(re::LeakTestAllocator *this)
{
  uint64_t v3 = (*(uint64_t (**)(void))(**((void **)this + 3) + 32))(*((void *)this + 3));
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v3);
  return v3;
}

uint64_t re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::LeakTestAllocator::free(re::LeakTestAllocator *this, uint64_t a2)
{
  uint64_t v4 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 32, &v4);
  return (*(uint64_t (**)(void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v4);
}

uint64_t re::LeakTestAllocator::parent(re::LeakTestAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t re::LeakTestAllocator::statistics(re::LeakTestAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 56))();
}

uint64_t re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

re::AlignedAllocator *re::AlignedAllocator::AlignedAllocator(re::AlignedAllocator *this, const char *a2, uint64_t a3, re::Allocator *a4)
{
  uint64_t v6 = re::Allocator::Allocator(this, a2, 1);
  *((void *)v6 + 8) = 0;
  *((void *)v6 + 9) = 0;
  *(_OWORD *)((char *)v6 + 20) = 0u;
  *(_OWORD *)((char *)v6 + 36) = 0u;
  *(void *)((char *)v6 + 52) = 0;
  *(void *)uint64_t v6 = &unk_26E6DE860;
  *((void *)v6 + 10) = 0;
  *((void *)v6 + 11) = 0;
  re::BaseAllocator::init(v6);
  *((_DWORD *)this + 5) |= 1u;
  *((void *)this + 10) = a3;
  return this;
}

void re::BaseAllocator::~BaseAllocator(re::BaseAllocator *this)
{
  *(void *)this = &unk_26E6DE8E8;
  uint64_t v2 = (char *)this + 32;
  if (*((void *)this + 4)) {
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + 32);
  }
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  re::Allocator::~Allocator(this);
}

void re::AlignedAllocator::~AlignedAllocator(re::AlignedAllocator *this)
{
  uint64_t v3 = *((void *)this + 4);
  uint64_t v2 = (char *)this + 32;
  if (v3)
  {
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  }
  re::BaseAllocator::~BaseAllocator(this);
}

{
  char *v2;
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *((void *)this + 4);
  uint64_t v2 = (char *)this + 32;
  if (v3)
  {
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  }
  re::BaseAllocator::~BaseAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

void *re::AlignedAllocator::alloc(re::AlignedAllocator *this, size_t size)
{
  uint64_t v4 = *((void *)this + 11);
  if (v4)
  {
    double result = (void *)(*(uint64_t (**)(uint64_t, size_t, void))(*(void *)v4 + 32))(v4, size, 0);
  }
  else
  {
    size_t v6 = (*((void *)this + 10) + 7) & 0xFFFFFFFFFFFFFFF8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, v6, size, 0xC75C8B65uLL);
    double result = memptr;
  }
  __dmb(0xBu);
  return result;
}

void re::AlignedAllocator::free(re::AlignedAllocator *this, void *a2)
{
  __dmb(0xBu);
  uint64_t v2 = *((void *)this + 11);
  if (v2) {
    (*(void (**)(uint64_t, void *))(*(void *)v2 + 40))(v2, a2);
  }
  else {
    free(a2);
  }
}

uint64_t re::AlignedAllocator::statistics(re::AlignedAllocator *this)
{
  return 0;
}

uint64_t re::AlignedAllocator::parent(re::AlignedAllocator *this)
{
  return *((void *)this + 11);
}

uint64_t re::Allocator::useMallocAllocator(re::Allocator *this)
{
  unint64_t v1 = (unsigned __int8 *)&unk_26879F000;
  {
    unint64_t v1 = (unsigned char *)&unk_26879F000;
    if (v3)
    {
      unint64_t v1 = (unsigned char *)&unk_26879F000;
    }
  }
  return v1[1280];
}

BOOL anonymous namespace'::memoryDebugStatus(_anonymous_namespace_ *this)
{
  unint64_t v1 = getenv("RE_USE_POOL_ALLOCATOR");
  if (v1) {
    BOOL v2 = atoi(v1) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (getenv("MallocTracing")) {
    return 1;
  }
  if (getenv("MallocStackLogging")) {
    return 1;
  }
  return v2;
}

re::Allocator *re::Allocator::Allocator(re::Allocator *this, const char *a2, int a3)
{
  *(void *)this = &unk_26E6DE940;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = a3;
  if (a3)
  {
    uint64_t v4 = re::globalMemoryTracker(this);
    if (*v4)
    {
      long long v5 = re::globalMemoryTracker((re *)v4);
      re::MemoryTracker::track((os_unfair_lock_s *)v5, this);
    }
  }
  return this;
}

void re::Allocator::~Allocator(re::Allocator *this)
{
  *(void *)this = &unk_26E6DE940;
  if (*((unsigned char *)this + 16))
  {
    BOOL v2 = re::globalMemoryTracker(this);
    if (*v2)
    {
      uint64_t v3 = re::globalMemoryTracker((re *)v2);
      re::MemoryTracker::untrack((os_unfair_lock_s *)v3, this);
    }
  }
}

void re::PerFrameAllocatorImpl::~PerFrameAllocatorImpl(re::PerFrameAllocatorImpl *this)
{
  *(void *)this = &unk_26E6DE9A8;
  BOOL v2 = (uint64_t *)((char *)this + 96);
  uint64_t v3 = *((void *)this + 17);
  if (v3)
  {
    for (unint64_t i = 0; i != v3; ++i)
    {
      uint64_t v5 = re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[]((uint64_t)v2, i);
      re::FunctionBase<24ul,void ()(void *)>::destroyCallable(v5 + 8);
    }
  }
  while (*((void *)this + 13))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  *((void *)this + 17) = 0;
  ++*((_DWORD *)this + 36);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 56);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::PerFrameAllocatorImpl::~PerFrameAllocatorImpl(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::PerFrameAllocatorManager::sizeToIndex(re::PerFrameAllocatorManager *this, uint64_t a2)
{
  if (this)
  {
    signed int v4 = 16 - __clz(this - 1);
    return v4 & ~(v4 >> 31);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "size > 0", "sizeToIndex", 320, v2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PerFrameAllocatorImpl::alloc(re::PerFrameAllocatorImpl *this, unint64_t a2, unint64_t a3)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (!a2 || *((unsigned char *)this + 168)) {
    return 0;
  }
  if (pthread_self() != *((pthread_t *)this + 20))
  {
    unsigned int v7 = (void *)re::PerFrameAllocatorManager::perFrameAllocator(*((void *)this + 19), *((void *)this + 3));
    long long v8 = (_opaque_pthread_t *)v7[20];
    if (v8 == pthread_self())
    {
      unint64_t v34 = *(uint64_t (**)(void *, unint64_t, unint64_t))(*v7 + 32);
      return v34(v7, a2, a3);
    }
  }
  uint64_t v9 = 0;
  if (a3 <= 0x10) {
    uint64_t v10 = 16;
  }
  else {
    uint64_t v10 = a3;
  }
  unint64_t v11 = (char *)this + 32;
  do
  {
    uint64_t v12 = *(void *)&v11[v9];
    if (v12)
    {
      uint64_t v14 = *(void *)(v12 + 56);
      int64_t v13 = *(void *)(v12 + 64);
      if (v10 + a2 < v13 - v14) {
        goto LABEL_32;
      }
    }
    v9 += 8;
  }
  while (v9 != 24);
  uint64_t v15 = *((void *)this + 19);
  if (a2 <= 0x10000) {
    uint64_t v16 = 0x10000;
  }
  else {
    uint64_t v16 = a2;
  }
  uint64_t v43 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 120));
  unint64_t v18 = re::PerFrameAllocatorManager::sizeToIndex((re::PerFrameAllocatorManager *)v16, v17);
  unint64_t v20 = *(void *)(v15 + 144);
  if (v18 >= v20) {
    goto LABEL_43;
  }
  unint64_t v21 = v18;
  uint64_t v22 = *(void *)(v15 + 160);
  uint64_t v23 = v22 + 88 * v18;
  unint64_t v26 = *(void *)(v23 + 24);
  long long v24 = (unint64_t *)(v23 + 24);
  unint64_t v25 = v26;
  if (v26) {
    goto LABEL_19;
  }
  if (v18 < v20 - 1)
  {
    unint64_t v21 = v18 + 1;
    if (v20 <= v18 + 1)
    {
LABEL_45:
      uint64_t v45 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v46 = 136315906;
      long long v47 = "operator[]";
      __int16 v48 = 1024;
      int v49 = 789;
      __int16 v50 = 2048;
      unint64_t v51 = v21;
      __int16 v52 = 2048;
      unint64_t v53 = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_46;
    }
    if (2 * v16 > (unint64_t)(0x10000 << v18))
    {
      uint64_t v36 = v22 + 88 * v21;
      unint64_t v37 = *(void *)(v36 + 24);
      long long v24 = (unint64_t *)(v36 + 24);
      unint64_t v25 = v37;
      if (v37 >= 2)
      {
LABEL_19:
        unint64_t v27 = v25 - 1;
        uint64_t v12 = *(void *)(*(void *)(v22 + 88 * v21 + 40) + 8 * v27);
        *long long v24 = v27;
        ++*(_DWORD *)(v22 + 88 * v21 + 32);
        goto LABEL_20;
      }
    }
  }
  unint64_t v20 = 0x10000 << v18;
  long long v38 = (re *)re::PerFrameAllocatorManager::sizeToIndex((re::PerFrameAllocatorManager *)(0x10000 << v18), v19);
  if ((unint64_t)v38 >= *(void *)(v15 + 144))
  {
LABEL_43:
    os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 120));
    return 0;
  }
  unint64_t v21 = (unint64_t)v38;
  if (a3 <= 0x100) {
    a3 = 256;
  }
  unint64_t v39 = re::globalAllocators(v38);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39[2] + 32))(v39[2], 144, 8);
  *(void *)uint64_t v12 = 0;
  *(unsigned char *)(v12 + 32) = 0;
  *(_OWORD *)(v12 + 80) = 0u;
  *(_OWORD *)(v12 + 96) = 0u;
  *(_DWORD *)(v12 + 112) = 0;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_DWORD *)(v12 + 72) = 0;
  *(void *)(v12 + 116) = 0x7FFFFFFFLL;
  *(unsigned char *)(v12 + 128) = 1;
  *(void *)(v12 + 136) = 0xFFFFFFFFFFFFFFFLL;
  uint64_t v44 = v12;
  *(void *)(v12 + 16) = &unk_26E6DEA30;
  *(void *)(v12 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = "PerFrameAllocatoChunk-Linear";
  *(void *)(v12 + 8) = v20;
  uint64_t v40 = re::globalAllocators((re *)v12);
  uint64_t v41 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(*(void *)v40[2] + 32))(v40[2], v20, a3);
  *(void *)uint64_t v12 = v41;
  uint64_t v42 = *(void *)(v12 + 8) + v41;
  *(void *)(v12 + 40) = v41;
  *(void *)(v12 + 48) = v42;
  *(void *)(v12 + 56) = v41;
  *(void *)(v12 + 64) = v42;
  a3 = *(void *)(v15 + 144);
  if (a3 <= v21)
  {
LABEL_46:
    uint64_t v45 = 0;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v46 = 136315906;
    long long v47 = "operator[]";
    __int16 v48 = 1024;
    int v49 = 789;
    __int16 v50 = 2048;
    unint64_t v51 = v21;
    __int16 v52 = 2048;
    unint64_t v53 = a3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(*(void *)(v15 + 160) + 88 * v21 + 48), &v44);
LABEL_20:
  *(void *)(v12 + 136) = v43;
  *(_OWORD *)(v12 + 56) = *(_OWORD *)(v12 + 40);
  os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 120));
  *(void *)&long long v54 = v12;
  re::DynamicArray<re::RigDataValue *>::add((re::PerFrameAllocatorImpl *)((char *)this + 56), &v54);
  uint64_t v29 = 0;
  signed int v30 = 0;
  unint64_t v31 = -1;
  while (1)
  {
    uint64_t v32 = *(void *)&v11[8 * v29];
    if (!v32) {
      break;
    }
    unint64_t v33 = *(void *)(v32 + 64) - *(void *)(v32 + 56);
    if (v33 < v31)
    {
      unint64_t v31 = v33;
      signed int v30 = v29;
    }
    if (++v29 == 3) {
      goto LABEL_30;
    }
  }
  signed int v30 = v29;
LABEL_30:
  if (v30 >= 3)
  {
    re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v30, 3);
    _os_crash();
    __break(1u);
    goto LABEL_45;
  }
  *(void *)&v11[8 * v30] = v12;
  uint64_t v14 = *(void *)(v12 + 56);
  int64_t v13 = *(void *)(v12 + 64);
LABEL_32:
  uint64_t result = 0;
  uint64_t v35 = (v10 + v14 - 1) & -v10;
  if ((uint64_t)(v35 + a2) <= v13)
  {
    *(void *)(v12 + 56) = v35 + a2;
    return (v10 + v14 - 1) & -v10;
  }
  return result;
}

uint64_t re::PerFrameAllocatorManager::perFrameAllocator(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = (re::Allocator *)&v38;
  uint64_t v43 = *MEMORY[0x263EF8340];
  unint64_t v6 = a2 >> 60;
  unsigned int v7 = *(re::Allocator **)(a1 + 16);
  if ((unint64_t)v7 <= a2 >> 60)
  {
    *(void *)uint64_t v29 = 0;
    long long v42 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v30 = 136315906;
    unint64_t v31 = "operator[]";
    __int16 v32 = 1024;
    int v33 = 468;
    __int16 v34 = 2048;
    unint64_t v35 = v6;
    __int16 v36 = 2048;
    unint64_t v37 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_31;
  }
  uint64_t v10 = pthread_getspecific(*(void *)(*(void *)(a1 + 24) + 8 * v6));
  if (!v10 || (uint64_t v11 = re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1 + 56, (uint64_t)v10)) == 0)
  {
LABEL_10:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
    v29[0] = 0;
    uint64_t v15 = pthread_self();
    pthread_getname_np(v15, v29, 0xAuLL);
    uint64_t v16 = *(void *)(a1 + 5296);
    if (v16 - *(void *)(a1 + 5288) == 128) {
      *(void *)(a1 + 5288) = v16 - 127;
    }
    uint64_t v17 = a1 + 168;
    *(void *)(a1 + 5296) = v16 + 1;
    unsigned int v18 = v16 & 0x7F;
    re::InlineString<32ul>::format((uint64_t)&v38, (char)v29);
    uint64_t v20 = v38;
    if ((void)v38)
    {
      if ((unint64_t)v38 >= 0x20)
      {
LABEL_32:
        re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) ", "other.m_length < m_capacity", "copy", 481);
        _os_crash();
        __break(1u);
LABEL_33:
        *((_OWORD *)v5 + 4) = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v30 = 136315906;
        unint64_t v31 = "operator[]";
        __int16 v32 = 1024;
        int v33 = 789;
        __int16 v34 = 2048;
        unint64_t v35 = v4;
        __int16 v36 = 2048;
        unint64_t v37 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_34;
      }
      memcpy((void *)(v17 + 40 * v18 + 8), (char *)&v38 + 8, v38 + 1);
    }
    *(void *)(v17 + 40 * v18) = v20;
    int v21 = *(_DWORD *)(a1 + 112);
    if ((v21 + 1) >> 24) {
      int v22 = 1;
    }
    else {
      int v22 = v21 + 1;
    }
    *(_DWORD *)(a1 + 112) = v22;
    uint64_t v3 = *(unsigned __int16 *)(a1 + 108);
    unint64_t v4 = *(unsigned __int16 *)(a1 + 110);
    if (v3 == 0xFFFF && v4 == 0xFFFF)
    {
      if (*(_DWORD *)(a1 + 104) >= *(_DWORD *)(a1 + 100)) {
        re::DataArray<re::PerFrameAllocatorImpl>::allocBlock((void *)(a1 + 56));
      }
      uint64_t v23 = *(void *)(a1 + 72);
      unint64_t v4 = (unsigned __int16)(v23 - 1);
      if (!v23) {
        goto LABEL_33;
      }
      uint64_t v3 = *(unsigned int *)(a1 + 104);
      if (v3 >= 0x10000) {
        goto LABEL_35;
      }
      long long v24 = (void *)(*(void *)(a1 + 88) + 16 * v4);
      *(_DWORD *)(a1 + 104) = v3 + 1;
      *(_DWORD *)(v24[1] + 4 * v3) = *(_DWORD *)(a1 + 112);
      uint64_t v5 = (re::Allocator *)(*v24 + 184 * v3);
    }
    else
    {
      uint64_t v5 = *(re::Allocator **)(a1 + 72);
      if ((unint64_t)v5 <= v4)
      {
LABEL_34:
        uint64_t v28 = 0;
        long long v42 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v30 = 136315906;
        unint64_t v31 = "operator[]";
        __int16 v32 = 1024;
        int v33 = 789;
        __int16 v34 = 2048;
        unint64_t v35 = v4;
        __int16 v36 = 2048;
        unint64_t v37 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        re::internal::assertLog((re::internal *)5, v19, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v3, v28, *(void *)v29);
        _os_crash();
        __break(1u);
      }
      unint64_t v25 = (void *)(*(void *)(a1 + 88) + 16 * v4);
      *(_DWORD *)(v25[1] + 4 * v3) = v22;
      uint64_t v5 = (re::Allocator *)(*v25 + 184 * v3);
      *(_DWORD *)(a1 + 108) = *(_DWORD *)v5;
    }
    ++*(_DWORD *)(a1 + 96);
    unint64_t v26 = re::Allocator::Allocator(v5, (const char *)(v17 + 40 * v18 + 8), 0);
    *((void *)v5 + 3) = a2;
    *((void *)v5 + 4) = 0;
    *(void *)uint64_t v5 = &unk_26E6DE9A8;
    *((void *)v5 + 8) = 0;
    *((void *)v5 + 9) = 0;
    *((_DWORD *)v5 + 20) = 0;
    *((void *)v5 + 12) = 0;
    *((void *)v5 + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 0;
    *((void *)v5 + 11) = 0;
    *((_DWORD *)v5 + 28) = 1;
    *((void *)v5 + 16) = 0;
    *((void *)v5 + 17) = 0;
    *((void *)v5 + 15) = 0;
    *((_DWORD *)v5 + 36) = 0;
    *((void *)v5 + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = a1;
    *((unsigned char *)v5 + 168) = 0;
    *((_DWORD *)v5 + 43) = 3;
    *((unsigned char *)v5 + 176) = 0;
    *((void *)v5 + 5) = 0;
    *((void *)v5 + 6) = 0;
    *((void *)v26 + 7) = 0;
    re::DynamicArray<float *>::setCapacity((void *)v26 + 7, 0x40uLL);
    *((void *)v5 + 20) = pthread_self();
    uint64_t v2 = *(re::Allocator **)(a1 + 16);
    if ((unint64_t)v2 > v6)
    {
      pthread_setspecific(*(void *)(*(void *)(a1 + 24) + 8 * v6), (const void *)((v4 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 112) & 0xFFFFFF) << 32) | v3));
      uint64_t v12 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, (v4 << 16) | v3);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 120));
      return v12;
    }
LABEL_31:
    long long v42 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v30 = 136315906;
    unint64_t v31 = "operator[]";
    __int16 v32 = 1024;
    int v33 = 468;
    __int16 v34 = 2048;
    unint64_t v35 = v6;
    __int16 v36 = 2048;
    unint64_t v37 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_32;
  }
  uint64_t v12 = v11;
  uint64_t v13 = *(void *)(v11 + 24) & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v14 = a2 & 0xFFFFFFFFFFFFFFFLL;
  if (v13 == 0xFFFFFFFFFFFFFFFLL)
  {
    if (v14 == 0xFFFFFFFFFFFFFFFLL) {
      return v12;
    }
    goto LABEL_9;
  }
  if (v14 == 0xFFFFFFFFFFFFFFFLL || v13 != v14)
  {
LABEL_9:
    *(unsigned char *)(v11 + 176) = 1;
    goto LABEL_10;
  }
  return v12;
}

uint64_t re::LinearAllocator::alloc(re::LinearAllocator *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = (a3 + *((void *)this + 5) - 1) & -a3;
  if (v4 + a2 <= *((void *)this + 6))
  {
    *((void *)this + 5) = v4 + a2;
    return v4;
  }
  return v3;
}

uint64_t re::PerFrameAllocatorImpl::parent(re::PerFrameAllocatorImpl *this)
{
  return 0;
}

uint64_t re::PerFrameAllocatorImpl::addDestructor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v13 = *(void *)(a3 + 24);
  uint64_t v14 = 0;
  re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)v12, a3);
  unint64_t v5 = *(void *)(a1 + 136);
  unint64_t v6 = *(void *)(a1 + 104);
  if (v5 + 1 > v6 << 6)
  {
    re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity((void *)(a1 + 96), (v5 + 64) >> 6);
    unint64_t v6 = *(void *)(a1 + 104);
  }
  if (v6 <= v5 >> 6)
  {
    long long v26 = 0u;
    long long v27 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v15 = 136315906;
    uint64_t v16 = "operator[]";
    __int16 v17 = 1024;
    int v18 = 858;
    __int16 v19 = 2048;
    unint64_t v20 = v5 >> 6;
    __int16 v21 = 2048;
    unint64_t v22 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 112)) {
    uint64_t v7 = a1 + 120;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 128);
  }
  uint64_t v8 = *(void *)(v7 + 8 * (v5 >> 6));
  ++*(void *)(a1 + 136);
  ++*(_DWORD *)(a1 + 144);
  uint64_t v9 = (void *)(v8 + 48 * (v5 & 0x3F));
  *uint64_t v9 = a2;
  v9[4] = v13;
  void v9[5] = 0;
  re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(v9 + 1), (uint64_t)v12);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v12);
  return a2;
}

uint64_t re::PerFrameAllocatorImpl::statistics(re::PerFrameAllocatorImpl *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = 0;
  unint64_t v5 = (void *)*((void *)this + 11);
  uint64_t v6 = 8 * v1;
  do
  {
    uint64_t v7 = (void *)*v5++;
    uint64_t v8 = v7[5];
    uint64_t v9 = v7[6];
    uint64_t v4 = v4 - v8 + v9;
    uint64_t result = v7[7] + result + v9 - (v8 + v7[8]);
    v6 -= 8;
  }
  while (v6);
  return result;
}

uint64_t re::LinearAllocator::statistics(re::LinearAllocator *this)
{
  return *((void *)this + 5) + *((void *)this + 4) - (*((void *)this + 3) + *((void *)this + 6));
}

_anonymous_namespace_ *re::PerFrameAllocatorManager::init(_anonymous_namespace_ *this)
{
  if (!*(unsigned char *)this)
  {
    uint64_t v1 = this;
    uint64_t v2 = (uint64_t *)((char *)this + 8);
    unint64_t v5 = 0;
    *(unsigned char *)uint64_t v1 = 1;
    do
    {
      if (*((void *)v1 + 5) <= v5)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_23:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(*((void *)v1 + 6) + 8 * v5) = 0;
      if (*((void *)v1 + 2) <= v5) {
        goto LABEL_23;
      }
      *(void *)(*((void *)v1 + 3) + 8 * v5++) = 0;
    }
    while (v5 != 16);
    unint64_t v6 = *((void *)v1 + 18);
    if (v6 > 0xE)
    {
      if (v6 == 15) {
        goto LABEL_17;
      }
      unint64_t v11 = 15;
      uint64_t v12 = 1328;
      do
      {
        uint64_t v13 = *((void *)v1 + 20) + v12;
        re::DynamicArray<unsigned long>::deinit(v13 + 40);
        uint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit(v13);
        ++v11;
        v12 += 88;
      }
      while (v11 < *((void *)v1 + 18));
    }
    else if (*((void *)v1 + 17) > 0xEuLL {
           || (uint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity((void *)v1 + 16),
    }
               unint64_t v6 = *((void *)v1 + 18),
               v6 <= 0xE))
    {
      unint64_t v7 = v6 - 15;
      uint64_t v8 = 88 * v6;
      do
      {
        uint64_t v9 = *((void *)v1 + 20) + v8;
        *(void *)(v9 + 80) = 0;
        *(_OWORD *)uint64_t v9 = 0uLL;
        *(_OWORD *)(v9 + 16) = 0uLL;
        *(_DWORD *)(v9 + 32) = 0;
        *(_OWORD *)(v9 + 40) = 0uLL;
        *(_OWORD *)(v9 + 56) = 0uLL;
        *(_DWORD *)(v9 + 72) = 0;
        v8 += 88;
      }
      while (!__CFADD__(v7++, 1));
    }
    *((void *)v1 + 18) = 15;
    ++*((_DWORD *)v1 + 38);
LABEL_17:
    uint64_t v14 = 0;
    int v15 = (void *)*((void *)v1 + 20);
    do
    {
      *int v15 = 0x10000 << v14;
      v15 += 11;
      ++v14;
    }
    while (v14 != 15);
    uint64_t v16 = (char *)v1 + 56;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity(v16, 0);
    ++*((_DWORD *)v16 + 6);
    *((_DWORD *)v16 + 11) = 16;
    return re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(v16);
  }
  return this;
}

re *re::PerFrameAllocatorManager::deinit(re *this)
{
  if (*(unsigned char *)this)
  {
    uint64_t v1 = this;
    this = (re *)re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)this + 56);
    unint64_t v2 = *((void *)v1 + 18);
    if (v2)
    {
      for (unint64_t i = 0; i < v2; ++i)
      {
        uint64_t v4 = *((void *)v1 + 20);
        uint64_t v5 = v4 + 88 * i;
        unint64_t v8 = *(void *)(v5 + 64);
        unint64_t v7 = (unint64_t *)(v5 + 64);
        unint64_t v6 = v8;
        if (v8)
        {
          unint64_t v9 = 0;
          uint64_t v10 = (void *)(v4 + 88 * i + 80);
          do
          {
            uint64_t v11 = **(void **)(*v10 + 8 * v9);
            if (v11)
            {
              uint64_t v12 = re::globalAllocators(this);
              (*(void (**)(uint64_t, uint64_t))(*(void *)v12[2] + 40))(v12[2], v11);
              unint64_t v6 = *v7;
            }
            if (v6 <= v9)
            {
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_20:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_21:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_22:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            this = re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(*(re **)(*v10 + 8 * v9));
            unint64_t v6 = *v7;
            if (*v7 <= v9) {
              goto LABEL_20;
            }
            *(void *)(*v10 + 8 * v9++) = 0;
          }
          while (v6 > v9);
          unint64_t v2 = *((void *)v1 + 18);
        }
        *unint64_t v7 = 0;
        uint64_t v13 = v4 + 88 * i;
        ++*(_DWORD *)(v13 + 72);
        *(void *)(v13 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
        ++*(_DWORD *)(v13 + 32);
      }
    }
    for (unint64_t j = 0; j != 16; ++j)
    {
      if (*((void *)v1 + 5) <= j) {
        goto LABEL_21;
      }
      *(void *)(*((void *)v1 + 6) + 8 * j) = 0;
      if (*((void *)v1 + 2) <= j) {
        goto LABEL_22;
      }
      *(void *)(*((void *)v1 + 3) + 8 * j) = 0;
    }
    *(unsigned char *)uint64_t v1 = 0;
  }
  return this;
}

re *re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    *(_OWORD *)((char *)v1 + 40) = 0u;
    *(_OWORD *)((char *)v1 + 56) = 0u;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v1 + 10);
    re::Allocator::~Allocator((re *)((char *)v1 + 16));
    uint64_t v3 = *(uint64_t (**)(uint64_t, re *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

unint64_t re::PerFrameAllocatorManager::addOwner(os_unfair_lock_s *this, void *a2)
{
  uint64_t v4 = this + 30;
  os_unfair_lock_lock(this + 30);
  uint64_t v6 = 0;
  for (unint64_t i = 0; i != 16; ++i)
  {
    if (*(void *)&this[10]._os_unfair_lock_opaque == i)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_10:
      uint64_t v12 = 0;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(vre::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 136315906;
      *(void *)((char *)&v13 + 4) = "operator[]";
      WORD6(vre::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 1024;
      HIWORD(vre::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 468;
      _os_log_send_and_compose_impl();
      uint64_t v9 = _os_crash_msg();
      __break(1u);
LABEL_11:
      re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) pthread_key_create failed: %d", "result == 0", "addOwner", 271, v9, v12, v13);
      _os_crash();
      __break(1u);
    }
    uint64_t v8 = *(void *)&this[12]._os_unfair_lock_opaque;
    if (!*(void *)(v8 + 8 * i)) {
      goto LABEL_6;
    }
    v6 -= 8;
  }
  re::internal::assertLog((re::internal *)5, v5, "assertion failure: '%s' (%s:line %i) Too many PerFrameAllocator owners (more than %llu FrameManagers)", "!\"Unreachable code\"", "addOwner", 278, 16);
  _os_crash();
  __break(1u);
LABEL_6:
  *(void *)(v8 + 8 * i) = a2;
  if (*(void *)&this[4]._os_unfair_lock_opaque <= i) {
    goto LABEL_10;
  }
  uint64_t v9 = pthread_key_create((pthread_key_t *)(*(void *)&this[6]._os_unfair_lock_opaque - v6), 0);
  if (v9) {
    goto LABEL_11;
  }
  os_unfair_lock_unlock(v4);
  return i;
}

void re::PerFrameAllocatorManager::removeOwner(os_unfair_lock_s *this, unint64_t a2)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v4 = this + 30;
  os_unfair_lock_lock(this + 30);
  uint64_t v26 = 0;
  v23[1] = 0;
  uint64_t v24 = 0;
  v23[0] = 0;
  uint64_t v5 = (char *)&this[14];
  int v25 = 0;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v33, (uint64_t)&this[14], 0);
  *(_OWORD *)uint64_t v28 = v33;
  if (&this[14] == (os_unfair_lock_s *)v33 && WORD4(v33) == 0xFFFFLL && (DWORD2(v33) & 0xFFFF0000) == 4294901760)
  {
    uint64_t v13 = 0;
  }
  else
  {
    do
    {
      int v8 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v28);
      uint64_t v9 = re::DataArray<re::PerFrameAllocatorImpl>::get((uint64_t)&this[14], v8);
      if (a2 == *(void *)(v9 + 24) >> 60 && *(unsigned char *)(v9 + 168) != 0)
      {
        *(void *)&long long v33 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v28);
        re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)v23, &v33);
      }
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v28);
    }
    while (*(char **)v28 != v5 || *(unsigned __int16 *)&v28[8] != 0xFFFF || *(unsigned __int16 *)&v28[10] != 0xFFFF);
    uint64_t v13 = v26;
    if (v24)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 8 * v24;
      do
      {
        re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)&this[14], *(void *)(v13 + v14));
        v14 += 8;
      }
      while (v15 != v14);
    }
  }
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v33, (uint64_t)&this[14], 0);
  if (v5 != (char *)v33 || WORD4(v33) != 0xFFFFLL || (DWORD2(v33) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*((unsigned __int16 *)&v33);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v33);
    }
    while ((char *)v33 != v5 || WORD4(v33) != 0xFFFF || WORD5(v33) != 0xFFFF);
  }
  unint64_t v20 = *(void *)&this[10]._os_unfair_lock_opaque;
  if (v20 <= a2)
  {
    uint64_t v27 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v28 = 136315906;
    *(void *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    __int16 v29 = 2048;
    unint64_t v30 = a2;
    __int16 v31 = 2048;
    unint64_t v32 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_50;
  }
  *(void *)(*(void *)&this[12]._os_unfair_lock_opaque + 8 * a2) = 0;
  unint64_t v20 = *(void *)&this[4]._os_unfair_lock_opaque;
  if (v20 <= a2)
  {
LABEL_50:
    uint64_t v27 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v28 = 136315906;
    *(void *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    __int16 v29 = 2048;
    unint64_t v30 = a2;
    __int16 v31 = 2048;
    unint64_t v32 = v20;
    _os_log_send_and_compose_impl();
    uint64_t v21 = _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  uint64_t v21 = pthread_key_delete(*(void *)(*(void *)&this[6]._os_unfair_lock_opaque + 8 * a2));
  if (v21)
  {
LABEL_51:
    re::internal::assertLog((re::internal *)5, v22, "assertion failure: '%s' (%s:line %i) pthread_key_delete failed: %d", "result == 0", "removeOwner", 314, v21);
    _os_crash();
    __break(1u);
LABEL_52:
    uint64_t v27 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v28 = 136315906;
    *(void *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    __int16 v29 = 2048;
    unint64_t v30 = a2;
    __int16 v31 = 2048;
    unint64_t v32 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v20 = *(void *)&this[4]._os_unfair_lock_opaque;
  if (v20 <= a2) {
    goto LABEL_52;
  }
  *(void *)(*(void *)&this[6]._os_unfair_lock_opaque + 8 * a2) = 0;
  if (v23[0] && v13) {
    (*(void (**)(void))(*(void *)v23[0] + 40))();
  }
  os_unfair_lock_unlock(v4);
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 184 * (unsigned __int16)a2;
}

_anonymous_namespace_ *re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add(_anonymous_namespace_ *result, void *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)result)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(result, v10);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v5 = *((void *)v3 + 2);
  }
  *(void *)(*((void *)v3 + 4) + 8 * v5) = *a2;
  ++*((void *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1 = a1[5];
  if (*(void *)(*(void *)a1 + 16) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(*(void *)a1 + 32) + 16 * v1) + 184 * a1[4];
}

uint64_t re::PerFrameAllocatorManager::freeAllocatorsWithPredicate(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v78 = 0;
  unint64_t v75 = 0;
  unint64_t v76 = 0;
  unint64_t v74 = 0;
  unint64_t v6 = (os_unfair_lock_s *)(a1 + 120);
  int v77 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
  unint64_t v7 = a2 >> 60;
  uint64_t v8 = a1 + 56;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v69, a1 + 56, 0);
  unint64_t v64 = v69;
  uint64_t v65 = v70;
  if (a1 + 56 == v69 && (unsigned __int16)v70 == 0xFFFFLL && (v70 & 0xFFFF0000) == 4294901760)
  {
    os_unfair_lock_unlock(v6);
    unint64_t v12 = 0;
LABEL_43:
    char v55 = 1;
    goto LABEL_44;
  }
  lock = v6;
  unint64_t v58 = a2 >> 60;
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  unint64_t v59 = a2;
  uint64_t v60 = a3;
  do
  {
    uint64_t v13 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*((unsigned __int16 *)&v64);
    unint64_t v14 = *(void *)(v13 + 24);
    if (v7 == v14 >> 60)
    {
      uint64_t v15 = v13;
      unint64_t v69 = a2;
      unint64_t v79 = v14;
      if ((*(unsigned int (**)(void, unint64_t *, unint64_t *))(**(void **)(a3 + 32) + 16))(*(void *)(a3 + 32), &v69, &v79))
      {
        uint64_t v16 = *(void *)(v15 + 136);
        if (v16)
        {
          for (unint64_t i = 0; i != v16; ++i)
          {
            int v18 = (_anonymous_namespace_ *)re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](v15 + 96, i);
            __int16 v19 = v18;
            if (v12 >= v75)
            {
              unint64_t v20 = v12 + 1;
              if (v75 < v20)
              {
                if (v74)
                {
                  unint64_t v21 = 8;
                  if (v75) {
                    unint64_t v21 = 2 * v75;
                  }
                  if (v21 <= v20) {
                    unint64_t v22 = v20;
                  }
                  else {
                    unint64_t v22 = v21;
                  }
                  re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(&v74, v22);
                }
                else
                {
                  re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(&v74, v20);
                  ++v77;
                }
              }
              unint64_t v12 = v76;
              uint64_t v11 = v78;
            }
            long long v23 = (void *)(v11 + 48 * v12);
            void *v23 = *(void *)v19;
            v23[4] = *((void *)v19 + 4);
            v23[5] = 0;
            re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(v23 + 1), (uint64_t)v19 + 8);
            unint64_t v12 = ++v76;
            ++v77;
          }
          uint64_t v24 = *(void *)(v15 + 136);
          if (v24)
          {
            for (unint64_t j = 0; j != v24; ++j)
            {
              uint64_t v26 = re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](v15 + 96, j);
              re::FunctionBase<24ul,void ()(void *)>::destroyCallable(v26 + 8);
            }
          }
          a2 = v59;
          a3 = v60;
          unint64_t v7 = v58;
        }
        *(void *)(v15 + 136) = 0;
        ++*(_DWORD *)(v15 + 144);
      }
    }
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v64);
  }
  while (v64 != v8 || (unsigned __int16)v65 != 0xFFFF || WORD1(v65) != 0xFFFF);
  unint64_t v6 = lock;
  os_unfair_lock_unlock(lock);
  if (!v12) {
    goto LABEL_43;
  }
  uint64_t v29 = v78;
  uint64_t v30 = 48 * v12;
  do
  {
    unint64_t v69 = *(void *)(v29 + v30 - 48);
    (*(void (**)(void, unint64_t *))(**(void **)(v29 + v30 - 8) + 16))(*(void *)(v29 + v30 - 8), &v69);
    v30 -= 48;
  }
  while (v30);
  char v55 = 0;
  unint64_t v6 = lock;
LABEL_44:
  os_unfair_lock_lock(v6);
  unint64_t v73 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v68 = 0;
  unint64_t v69 = 0;
  int v72 = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  unint64_t v64 = 0;
  int v67 = 0;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v79, a1 + 56, 0);
  unint64_t v62 = v79;
  uint64_t v63 = v80;
  if (v8 == v79 && (unsigned __int16)v80 == 0xFFFFLL && (v80 & 0xFFFF0000) == 0xFFFF0000)
  {
    __int16 v31 = 0;
  }
  else
  {
    do
    {
      int v32 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v62);
      uint64_t v33 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, v32);
      unint64_t v34 = *(void *)(v33 + 24);
      if (v7 == v34 >> 60)
      {
        uint64_t v35 = v33;
        unint64_t v79 = a2;
        unint64_t v81 = v34;
        if ((*(unsigned int (**)(void, unint64_t *, unint64_t *))(**(void **)(a3 + 32)
                                                                                            + 16))(*(void *)(a3 + 32), &v79, &v81))
        {
          unint64_t v79 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v62);
          re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)&v69, &v79);
        }
        if (*(unsigned char *)(v35 + 168))
        {
          int v36 = *(_DWORD *)(v35 + 172);
          if (v36 >= 1) {
            *(_DWORD *)(v35 + 172) = --v36;
          }
          if (v36) {
            BOOL v37 = 1;
          }
          else {
            BOOL v37 = *(unsigned char *)(v35 + 176) == 0;
          }
          if (!v37)
          {
            unint64_t v79 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v62);
            re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)&v64, &v79);
          }
        }
      }
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v62);
    }
    while (v62 != v8 || (unsigned __int16)v63 != 0xFFFF || WORD1(v63) != 0xFFFF);
    __int16 v31 = v73;
    if (v71)
    {
      os_unfair_lock_t locka = v6;
      long long v40 = v73;
      unint64_t v61 = v73;
      long long v41 = &v73[v71];
      do
      {
        uint64_t v43 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, *v40);
        *(unsigned char *)(v43 + 168) = 1;
        if (*(void *)(v43 + 72))
        {
          unint64_t v44 = 0;
          do
          {
            unint64_t v45 = *(void *)(*(void *)(v43 + 88) + 8 * v44);
            unint64_t v79 = v45;
            unint64_t v46 = re::PerFrameAllocatorManager::sizeToIndex(*(re::PerFrameAllocatorManager **)(v45 + 8), v42);
            if (v46 < *(void *)(a1 + 144))
            {
              *(_OWORD *)(v45 + 56) = *(_OWORD *)(v45 + 40);
              re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(*(void *)(a1 + 160) + 88 * v46 + 8), &v79);
            }
            ++v44;
          }
          while (*(void *)(v43 + 72) > v44);
        }
        *(void *)(v43 + 72) = 0;
        ++*(_DWORD *)(v43 + 80);
        *(void *)(v43 + 40) = 0;
        *(void *)(v43 + 48) = 0;
        *(void *)(v43 + 32) = 0;
        ++v40;
      }
      while (v40 != v41);
      unint64_t v6 = locka;
      __int16 v31 = v61;
    }
  }
  long long v47 = v68;
  if (v66)
  {
    uint64_t v48 = 8 * v66;
    int v49 = v68;
    do
    {
      unint64_t v50 = *v49++;
      re::DataArray<re::PerFrameAllocatorImpl>::destroy(v8, v50);
      v48 -= 8;
    }
    while (v48);
  }
  if (v64) {
    BOOL v51 = v47 == 0;
  }
  else {
    BOOL v51 = 1;
  }
  if (!v51) {
    (*(void (**)(void))(*(void *)v64 + 40))();
  }
  if (v69 && v31) {
    (*(void (**)(void))(*(void *)v69 + 40))();
  }
  os_unfair_lock_unlock(v6);
  uint64_t result = (uint64_t)v74;
  if (v74 && v78)
  {
    if ((v55 & 1) == 0)
    {
      uint64_t v53 = 48 * v12;
      uint64_t v54 = v78 + 8;
      do
      {
        re::FunctionBase<24ul,void ()(void *)>::destroyCallable(v54);
        v54 += 48;
        v53 -= 48;
      }
      while (v53);
      uint64_t result = (uint64_t)v74;
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

uint64_t (***re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re *a1, unint64_t a2))(void)
{
  v6[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = re::globalAllocators(a1)[2];
  v6[0] = &unk_26E6DEAA0;
  v6[3] = v4;
  unsigned char v6[4] = v6;
  re::PerFrameAllocatorManager::freeAllocatorsWithPredicate((uint64_t)a1, a2, (uint64_t)v6);
  return re::FunctionBase<24ul,BOOL ()(re::FrameCount,re::FrameCount)>::destroyCallable((uint64_t)v6);
}

uint64_t (***re::PerFrameAllocatorManager::freeAllocatorsForFrame(re *a1, unint64_t a2))(void)
{
  v6[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = re::globalAllocators(a1)[2];
  v6[0] = &unk_26E6DEB08;
  v6[3] = v4;
  unsigned char v6[4] = v6;
  re::PerFrameAllocatorManager::freeAllocatorsWithPredicate((uint64_t)a1, a2, (uint64_t)v6);
  return re::FunctionBase<24ul,BOOL ()(re::FrameCount,re::FrameCount)>::destroyCallable((uint64_t)v6);
}

uint64_t re::InlineString<32ul>::format@<X0>(uint64_t a1@<X8>, char a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(void *)a1 = 0;
  uint64_t result = vsnprintf((char *)(a1 + 8), 0x20uLL, "PerThreadAllocator.%s", &a2);
  if ((result & 0x80000000) != 0)
  {
    *(unsigned char *)(a1 + *(void *)a1 + 8) = 0;
  }
  else
  {
    unint64_t v5 = *(void *)a1 + result;
    if (v5 >= 0x20)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) ", "m_length + result < m_capacity", "vappendf", 446);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      *(void *)a1 = v5;
    }
  }
  return result;
}

uint64_t *re::getValidAllocator(re *a1)
{
  uint64_t v2 = re::globalAllocators(a1);
  uint64_t result = (uint64_t *)re::PerFrameAllocatorManager::perFrameAllocator(v2[6], (unint64_t)a1);
  if (*((unsigned char *)result + 168))
  {
  }
  return result;
}

uint64_t re::PerFrameAllocatorImpl::destructorCalledByDefault(re::PerFrameAllocatorImpl *this)
{
  return 0;
}

void re::LinearAllocator::~LinearAllocator(re::LinearAllocator *this)
{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 8);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 8);
  re::Allocator::~Allocator(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::LinearAllocator::parent(re::LinearAllocator *this)
{
  return 0;
}

uint64_t (***re::FunctionBase<24ul,void ()(void *)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::~Callable()
{
}

BOOL re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::operator()(uint64_t a1, void *a2, void *a3)
{
  return (*a3 & 0xFFFFFFFFFFFFFFFuLL) <= (*a2 & 0xFFFFFFFFFFFFFFFuLL);
}

void *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DEAA0;
  return result;
}

void *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DEAA0;
  return result;
}

uint64_t re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,BOOL ()(re::FrameCount,re::FrameCount)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::~Callable()
{
}

BOOL re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::operator()(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v4 = *a2 & 0xFFFFFFFFFFFFFFFLL;
  BOOL v6 = v4 != 0xFFFFFFFFFFFFFFFLL && v3 == v4;
  BOOL v7 = v4 == 0xFFFFFFFFFFFFFFFLL;
  if (v3 == 0xFFFFFFFFFFFFFFFLL) {
    return v7;
  }
  else {
    return v6;
  }
}

void *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DEB08;
  return result;
}

void *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E6DEB08;
  return result;
}

uint64_t re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::size()
{
  return 16;
}

uint64_t re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(void *)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        *(void *)(a1 + 32) = v4;
        *(void *)(a2 + 32) = 0;
        return a1;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 32);
      if (!v4) {
        return a1;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    uint64_t v7 = a1;
    if (v6 >= 0x19)
    {
      unint64_t v8 = v6;
      uint64_t v9 = *(void *)(a1 + 24);
      if (v9) {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
      }
      else {
        uint64_t v7 = 0;
      }
    }
    *(void *)(a1 + 32) = v7;
    (*(void (**)(void))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32));
    re::FunctionBase<24ul,void ()(void *)>::destroyCallable(a2);
  }
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(void *)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      unint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        uint64_t v7 = v5;
        unint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          unint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          unint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

void *re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 3072, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(void *result)
{
  if (result[1] != 15)
  {
    unint64_t v1 = result;
    if (result[2] <= 0xFuLL)
    {
      uint64_t v2 = *result;
      if (*v1)
      {
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 32))(v2, 1320, 8);
        if (result)
        {
          unint64_t v4 = result;
          if (v1[1])
          {
            uint64_t v5 = v1[4];
            uint64_t v6 = v1[2];
            if (v6)
            {
              uint64_t v7 = v5 + 88 * v6;
              int v8 = result;
              do
              {
                uint64_t v9 = *(void *)v5;
                v8[5] = 0;
                *int v8 = v9;
                v8[1] = 0;
                *((_DWORD *)v8 + 8) = 0;
                void v8[2] = 0;
                void v8[3] = 0;
                uint64_t v10 = v5 + 8;
                uint64_t v11 = *(void *)(v5 + 16);
                v8[1] = *(void *)(v5 + 8);
                *(void *)(v5 + 8) = 0;
                void v8[2] = v11;
                *(void *)(v5 + 16) = 0;
                uint64_t v12 = v8[3];
                void v8[3] = *(void *)(v5 + 24);
                *(void *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v12;
                uint64_t v13 = v8[5];
                v8[5] = *(void *)(v5 + 40);
                *(void *)(v5 + 40) = v13;
                ++*(_DWORD *)(v5 + 32);
                ++*((_DWORD *)v8 + 8);
                v8[10] = 0;
                v8[7] = 0;
                v8[8] = 0;
                v8[6] = 0;
                *((_DWORD *)v8 + 18) = 0;
                uint64_t v14 = *(void *)(v5 + 48);
                uint64_t v15 = *(void *)(v5 + 56);
                uint64_t v16 = v5 + 48;
                v8[6] = v14;
                v8[7] = v15;
                *(void *)uint64_t v16 = 0;
                *(void *)(v16 + 8) = 0;
                uint64_t v17 = v8[8];
                v8[8] = *(void *)(v16 + 16);
                *(void *)(v16 + 16) = v17;
                uint64_t v18 = v8[10];
                v8[10] = *(void *)(v16 + 32);
                *(void *)(v16 + 32) = v18;
                ++*(_DWORD *)(v16 + 24);
                ++*((_DWORD *)v8 + 18);
                re::DynamicArray<unsigned long>::deinit(v16);
                re::DynamicArray<unsigned long>::deinit(v10);
                uint64_t v5 = v16 + 40;
                v8 += 11;
              }
              while (v5 != v7);
              uint64_t v5 = v1[4];
            }
            uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v1 + 40))(*v1, v5);
          }
          v1[4] = v4;
          v1[1] = 15;
        }
        else
        {
          re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 1320, *(void *)(*v1 + 8));
          uint64_t result = (void *)_os_crash();
          __break(1u);
        }
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(v1);
        ++*((_DWORD *)v1 + 6);
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(void *a1)
{
  uint64_t v3 = 184 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    uint64_t result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  uint64_t v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  *uint64_t v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

uint64_t re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 6) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 6)) + 48 * (a2 & 0x3F);
}

void *re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (void *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = &v8[6 * v9];
        unint64_t v11 = v7;
        do
        {
          *unint64_t v11 = *v8;
          v11[4] = v8[4];
          v11[5] = 0;
          re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(v11 + 1), (uint64_t)(v8 + 1));
          re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(v8 + 1));
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = (void *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::AutoFreeAllocator::~AutoFreeAllocator(re::AutoFreeAllocator *this)
{
  uint64_t v2 = (uint64_t *)((char *)this + 32);
  uint64_t v3 = *((unsigned int *)this + 16);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (int *)(*((void *)this + 6) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 6;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 != v4)
  {
    uint64_t v7 = v4;
    do
    {
      uint64_t v10 = *(void *)(*((void *)this + 6) + 24 * v7 + 16);
      re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)v2, &v10);
      (*(void (**)(void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v10);
      if (*((_DWORD *)this + 16) <= (v4 + 1)) {
        int v8 = v4 + 1;
      }
      else {
        int v8 = *((_DWORD *)this + 16);
      }
      int v9 = v4;
      while (1)
      {
        uint64_t v7 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v4) = v7;
        if ((*(_DWORD *)(*((void *)this + 6) + 24 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v4) = v8;
LABEL_17:
      ;
    }
    while (v3 != v4);
  }
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)v2);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::AutoFreeAllocator::~AutoFreeAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::AutoFreeAllocator::free(re::AutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 32, &v4);
  return (*(uint64_t (**)(void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v4);
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_7, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::AutoFreeAllocator::alloc(re::AutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 3) + 32))(*((void *)this + 3), a2, 0);
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v4);
  return v4;
}

re::ThreadSafeAutoFreeAllocator *re::ThreadSafeAutoFreeAllocator::ThreadSafeAutoFreeAllocator(re::ThreadSafeAutoFreeAllocator *this, const char *a2, re::Allocator *a3)
{
  *((unsigned char *)this + 16) = 0;
  *(void *)this = &unk_26E6DEBB8;
  *((void *)this + 1) = a2;
  *((void *)this + 3) = a3;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  *((_OWORD *)this + 2) = 0u;
  *(void *)((char *)this + 68) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 20) = 0;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)this + 32, (uint64_t)a3, 3);
  return this;
}

void re::ThreadSafeAutoFreeAllocator::~ThreadSafeAutoFreeAllocator(re::ThreadSafeAutoFreeAllocator *this)
{
  uint64_t v2 = *((unsigned int *)this + 16);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 6) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      re::ThreadSafeAutoFreeAllocator::free((os_unfair_lock_s *)this, *(void *)(*((void *)this + 6) + 24 * v6 + 16));
      if (*((_DWORD *)this + 16) <= (v3 + 1)) {
        int v7 = v3 + 1;
      }
      else {
        int v7 = *((_DWORD *)this + 16);
      }
      int v8 = v3;
      while (1)
      {
        uint64_t v6 = (v8 + 1);
        if (v7 - 1 == v8) {
          break;
        }
        ++v8;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)this + 6) + 24 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v7;
LABEL_17:
      ;
    }
    while (v2 != v3);
  }
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)this + 32);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 4);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::ThreadSafeAutoFreeAllocator::~ThreadSafeAutoFreeAllocator(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ThreadSafeAutoFreeAllocator::free(os_unfair_lock_s *this, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)&this[8], &v5);
  os_unfair_lock_unlock(v3);
  return (*(uint64_t (**)(void, uint64_t))(**(void **)&this[6]._os_unfair_lock_opaque + 40))(*(void *)&this[6]._os_unfair_lock_opaque, v5);
}

uint64_t re::ThreadSafeAutoFreeAllocator::alloc(re::ThreadSafeAutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 3) + 32))(*((void *)this + 3), a2, 0);
  os_unfair_lock_lock((os_unfair_lock_t)this + 20);
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v4);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 20);
  return v4;
}

uint64_t re::AutoFreeAllocator::parent(re::AutoFreeAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t re::AutoFreeAllocator::statistics(re::AutoFreeAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 56))();
}

uint64_t re::ThreadSafeAutoFreeAllocator::parent(re::ThreadSafeAutoFreeAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t re::ThreadSafeAutoFreeAllocator::statistics(re::ThreadSafeAutoFreeAllocator *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 56))();
}

pthread_t re::BaseAllocator::init(re::BaseAllocator *this)
{
  uint64_t v1 = this;
  *((void *)this + 3) = 0;
  uint64_t v1 = (re::BaseAllocator *)((char *)v1 + 32);
  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
  ++*((_DWORD *)v1 + 6);
  pthread_t result = pthread_self();
  *((void *)v1 + 5) = result;
  return result;
}

void re::defaultTemporaryDirectoryPath(uint64_t a1@<X8>)
{
  uint64_t v3 = [MEMORY[0x263F08850] defaultManager];
  uint64_t v4 = [v3 temporaryDirectory];
  uint64_t v5 = [v4 path];

  if (v5)
  {
    uint64_t v6 = (_anonymous_namespace_ *)[v5 UTF8String];
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 32) = v10;
    *(_OWORD *)(a1 + 16) = v9;
    char v7 = 1;
  }
  else
  {
    char v7 = 0;
  }
  *(unsigned char *)a1 = v7;
}

uint64_t *re::foundationMemoryLogObjects(re *this)
{
  {
    re::foundationMemoryLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Memory");
  }
  return &re::foundationMemoryLogObjects(void)::logObjects;
}

uint64_t MurmurHash3_x64_128(uint64_t result, int a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v4 = a3;
  if (a2 < 16)
  {
    uint64_t v7 = a3;
  }
  else
  {
    uint64_t v5 = (void *)(result + 8);
    uint64_t v6 = (a2 / 16);
    uint64_t v7 = v4;
    do
    {
      uint64_t v4 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v5 - 1)) | ((0x87C37B91114253D5 * *(v5 - 1)) >> 33))) ^ v4, 37)+ v7)+ 1390208809;
      uint64_t v7 = 5
         * (v4
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v5) | ((unint64_t)(0x4CF5AD432745937FLL * *v5) >> 31))) ^ v7, 33))+ 944331445;
      v5 += 2;
      --v6;
    }
    while (v6);
  }
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  unint64_t v20 = 0;
  unint64_t v21 = (unsigned __int8 *)(result + 16 * (a2 / 16));
  switch(a2 & 0xF)
  {
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      goto LABEL_19;
    case 4:
      goto LABEL_18;
    case 5:
      goto LABEL_17;
    case 6:
      goto LABEL_16;
    case 7:
      goto LABEL_15;
    case 8:
      goto LABEL_14;
    case 9:
      goto LABEL_13;
    case 0xA:
      goto LABEL_12;
    case 0xB:
      goto LABEL_11;
    case 0xC:
      goto LABEL_10;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      goto LABEL_8;
    case 0xF:
      unint64_t v8 = (unint64_t)v21[14] << 48;
LABEL_8:
      unint64_t v9 = v8 | ((unint64_t)v21[13] << 40);
LABEL_9:
      unint64_t v10 = v9 ^ ((unint64_t)v21[12] << 32);
LABEL_10:
      unint64_t v11 = v10 ^ ((unint64_t)v21[11] << 24);
LABEL_11:
      unint64_t v12 = v11 ^ ((unint64_t)v21[10] << 16);
LABEL_12:
      unint64_t v13 = v12 ^ ((unint64_t)v21[9] << 8);
LABEL_13:
      v7 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v13 ^ v21[8])) | ((0x4CF5AD432745937FLL * (v13 ^ v21[8])) >> 31));
LABEL_14:
      unint64_t v14 = (unint64_t)v21[7] << 56;
LABEL_15:
      unint64_t v15 = v14 | ((unint64_t)v21[6] << 48);
LABEL_16:
      unint64_t v16 = v15 ^ ((unint64_t)v21[5] << 40);
LABEL_17:
      unint64_t v17 = v16 ^ ((unint64_t)v21[4] << 32);
LABEL_18:
      unint64_t v18 = v17 ^ ((unint64_t)v21[3] << 24);
LABEL_19:
      unint64_t v19 = v18 ^ ((unint64_t)v21[2] << 16);
LABEL_20:
      unint64_t v20 = v19 ^ ((unint64_t)v21[1] << 8);
LABEL_21:
      v4 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v20 ^ *v21)) | ((0x87C37B91114253D5 * (v20 ^ *v21)) >> 33));
      break;
    default:
      break;
  }
  uint64_t v22 = v7 ^ a2;
  unint64_t v23 = (v4 ^ a2) + v22;
  unint64_t v24 = v23 + v22;
  unint64_t v25 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) >> 33));
  unint64_t v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  unint64_t v27 = v26 ^ (v26 >> 33);
  unint64_t v28 = v27 + (v25 ^ (v25 >> 33));
  *a4 = v28;
  a4[1] = v28 + v27;
  return result;
}

uint64_t re::SharedObjectBase::dispose(re::SharedObjectBase *this)
{
  uint64_t v2 = (*(uint64_t (**)(re::SharedObjectBase *))(*(void *)this + 24))(this);
  (**(void (***)(re::SharedObjectBase *))this)(this);
  uint64_t v3 = *(uint64_t (**)(uint64_t, re::SharedObjectBase *))(*(void *)v2 + 40);
  return v3(v2, this);
}

uint64_t re::SharedObject::dispose(re::SharedObject *this)
{
  uint64_t v2 = *((void *)this + 2);
  (**(void (***)(re::SharedObject *))this)(this);
  uint64_t v3 = *(uint64_t (**)(uint64_t, re::SharedObject *))(*(void *)v2 + 40);
  return v3(v2, this);
}

void re::MallocAllocator::~MallocAllocator(re::MallocAllocator *this)
{
  re::Allocator::~Allocator(this);
  JUMPOUT(0x237DBCBD0);
}

void *re::MallocAllocator::alloc(re::MallocAllocator *this, size_t size, unint64_t a3)
{
  uint64_t v3 = 16;
  if (a3 > 0x10) {
    uint64_t v3 = a3;
  }
  memptr = 0;
  malloc_type_posix_memalign(&memptr, (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0xC75C8B65uLL);
  pthread_t result = memptr;
  __dmb(0xBu);
  return result;
}

void re::MallocAllocator::free(re::MallocAllocator *this, void *a2)
{
}

uint64_t re::MallocAllocator::statistics(re::MallocAllocator *this)
{
  return 0;
}

uint64_t re::MallocAllocator::parent(re::MallocAllocator *this)
{
  return 0;
}

uint64_t ArcObjectDestroy(char *a1, objc_selector *a2)
{
  if (a1) {
    uint64_t v2 = a1 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 16))();
}

void ArcSharedObject::ArcSharedObject(ArcSharedObject *this, Class cls)
{
  uint64_t v2 = cls;
  *(void *)this = &unk_26E6DECE0;
  if (!cls)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB70, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26AF7FB70))
    {
      uint64_t v4 = (objc_class *)objc_opt_class();
      ClassPair = objc_allocateClassPair(v4, "_REArcObject", 0);
      if (ClassPair)
      {
        Class = ClassPair;
        class_addMethod(ClassPair, sel_dealloc, (IMP)ArcObjectDestroy, "");
        objc_registerClassPair(Class);
      }
      else
      {
        Class = objc_getClass("_REArcObject");
      }
      _MergedGlobals_132 = (uint64_t)Class;
      __cxa_guard_release(&qword_26AF7FB70);
    }
    uint64_t v2 = (objc_class *)_MergedGlobals_132;
  }
  *((void *)this + 1) = 0;
  objc_constructInstance(v2, (char *)this + 8);
}

void ArcSharedObject::~ArcSharedObject(ArcSharedObject *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

void ArcSharedObject::dispose(ArcSharedObject *this)
{
  (**(void (***)(ArcSharedObject *))this)(this);
  free(this);
}

re::DynamicString *re::AnimationLibraryCompiler::getCurrentCompiledAssetInfo@<X0>(re::AnimationLibraryCompiler *this@<X0>, void *a2@<X8>)
{
  *a2 = 0x100000001;
  uint64_t v2 = (re::DynamicString *)(a2 + 1);
  uint64_t v3 = (_anonymous_namespace_ *)re::AnimationLibraryAsset::assetType(this);
  uint64_t v4 = *(const char **)v3;
}

char **re::AnimationLibraryCompiler::assetIntrospectionType(re::AnimationLibraryCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::AnimationLibraryAsset>(void)::info = re::introspect_AnimationLibraryAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[376];
}

uint64_t re::AnimationLibraryCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = "reAnimationLibrary";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::AnimationLibraryCompiler::compile@<X0>(re::AnimationLibraryCompiler *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  v30[4] = *MEMORY[0x263EF8340];
  unint64_t v8 = re::globalAllocators(this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 224, 8);
  *(_OWORD *)(v9 + 176) = 0u;
  *(_OWORD *)(v9 + 192) = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 128) = 0u;
  *(_OWORD *)(v9 + 144) = 0u;
  *(_OWORD *)(v9 + 160) = 0u;
  *(_DWORD *)(v9 + 196) = 0x7FFFFFFF;
  *(void *)(v9 + 208) = 0;
  *(void *)(v9 + 216) = "";
  *(void *)&long long v25 = &unk_26E6DED80;
  *((void *)&v26 + 1) = &v25;
  void v30[3] = v30;
  uint64_t v29 = (const char *)v9;
  v30[0] = &unk_26E6DED80;
  std::__function::__value_func<void ()(re::AnimationLibraryAsset *)>::~__value_func[abi:nn180100](&v25);
  unint64_t v10 = strrchr(a2, 46);
  if (!strcasecmp(v10 + 1, "reanimationlibrary"))
  {
    unint64_t v13 = v29;
    unint64_t v14 = &off_268773000;
    {
      *(void *)unint64_t v21 = v13;
      unint64_t v14 = &off_268773000;
      unint64_t v13 = *(const char **)v21;
      if (v20)
      {
        re::introspect<re::AnimationLibraryAsset>(void)::info = re::introspect_AnimationLibraryAsset(0);
        unint64_t v14 = &off_268773000;
        unint64_t v13 = *(const char **)v21;
      }
    }
    re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, v13, (uint64_t)v14[376], a3, (uint64_t)v22);
    if (v22[0])
    {
      uint64_t v15 = (uint64_t)v29;
      uint64_t v29 = 0;
      *(unsigned char *)a4 = 1;
      *(void *)(a4 + 8) = v15;
    }
    else
    {
      *(void *)&long long v25 = 100;
      *((void *)&v25 + 1) = re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)&v23);
      long long v16 = v26;
      *(_OWORD *)(a4 + 8) = v25;
      uint64_t v17 = v27;
      uint64_t v18 = v28;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v16;
      *(void *)(a4 + 40) = v17;
      *(void *)(a4 + 48) = v18;
      if (!v22[0] && v23 && (v24 & 1) != 0) {
        (*(void (**)(void))(*(void *)v23 + 40))();
      }
    }
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v25, a2);
    long long v11 = v25;
    long long v12 = v26;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 200;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v11;
    *(_OWORD *)(a4 + 40) = v12;
  }
  return std::unique_ptr<re::AnimationLibraryAsset,std::function<void ()(re::AnimationLibraryAsset*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v29);
}

re *re::AnimationLibraryCompiler::deleteAsset(re::AnimationLibraryCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::AnimationLibraryAsset>((re *)"deleteAsset", 53, a2);
}

void re::AnimationLibraryCompiler::~AnimationLibraryCompiler(re::AnimationLibraryCompiler *this)
{
}

void std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::~__func()
{
}

void *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::__clone()
{
  pthread_t result = operator new(0x10uLL);
  *pthread_t result = &unk_26E6DED80;
  return result;
}

void std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DED80;
}

re *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::AnimationLibraryAsset>((re *)"operator()", 34, *a2);
}

uint64_t std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::AnimationLibraryAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::AnimationLibraryAsset,std::function<void ()(re::AnimationLibraryAsset*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::AnimationLibraryAsset *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::AnimationLibraryAsset *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t std::function<void ()(re::AnimationLibraryAsset *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return re::TextureBuilder::TextureBuilder(v4);
}

uint64_t re::TextureBuilder::TextureBuilder(uint64_t a1, uint64_t a2, void *a3)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26E6DEE10;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = re::ServiceLocator::serviceOrNull<re::AssetService>(a2);
  uint64_t v6 = (id *)re::ServiceLocator::service<re::ImportGraphicsResources>(a2);
  re::ImportGraphicsContext::ImportGraphicsContext((re::ImportGraphicsContext *)(a1 + 32), v6);
  id v7 = objc_msgSend(a3, sel_copy);
  *(void *)(a1 + 64) = v7;
  char v9 = *(unsigned char *)(a1 + 51);
  if (v9) {
    char v9 = *(unsigned char *)(a1 + 52);
  }
  *(unsigned char *)(a1 + 72) = v9;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 0;
  if (*(void *)(a1 + 24))
  {
    if (v7) {
      return a1;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) TextureBuilder expected an AssetManager", "m_assetManager", "TextureBuilder", 138);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) TextureBuilder expected a MTLTextureDescriptor", "m_textureDescriptor.isValid()", "TextureBuilder", 139);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ServiceLocator::service<re::ImportGraphicsResources>(uint64_t a1)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::ImportGraphicsResources>(a1);
  if (!result)
  {
    uint64_t v2 = (re::internal *)re::introspect<re::ImportGraphicsResources>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v2, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    int v3 = (re::internal *)re::introspect<re::ImportGraphicsResources>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v3, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    if (v7[8]) {
      uint64_t v5 = *(unsigned char **)&v8[7];
    }
    else {
      uint64_t v5 = v8;
    }
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v5);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TextureBuilder::~TextureBuilder(re::TextureBuilder *this)
{
  *(void *)this = &unk_26E6DEE10;
  uint64_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    [v2 endEncoding];
    int v3 = (void *)*((void *)this + 13);
    *((void *)this + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 0;

    uint64_t v4 = (void *)*((void *)this + 13);
  }
  else
  {
    uint64_t v4 = 0;
  }

  uint64_t v5 = (void *)*((void *)this + 11);
  if (v5)
  {

    *((void *)this + 11) = 0;
  }

  uint64_t v6 = (void *)*((void *)this + 8);
  if (v6)
  {

    *((void *)this + 8) = 0;
  }

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::TextureBuilder::~TextureBuilder(this);
  JUMPOUT(0x237DBCBD0);
}

BOOL re::TextureBuilder::beginEncodeBlitCommands(re::TextureBuilder *this)
{
  v3[4] = *MEMORY[0x263EF8340];
  if (!*((void *)this + 10)
    && (v3[0] = &unk_26E6DEED0,
        v3[1] = this,
        v3[3] = v3,
        re::runInLocalAutoreleasePool((uint64_t)v3),
        std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v3),
        *((void *)this + 11))
    && *((void *)this + 12))
  {
    return *((void *)this + 13) != 0;
  }
  else
  {
    return 0;
  }
}

void *re::TextureBuilder::commitCommandBuffer(void *this)
{
  v1[4] = *MEMORY[0x263EF8340];
  if (this[12])
  {
    v1[0] = &unk_26E6DEF50;
    v1[1] = this;
    v1[3] = v1;
    re::runInLocalAutoreleasePool((uint64_t)v1);
    return std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v1);
  }
  return this;
}

uint64_t re::TextureBuilder::makeTextureAsset(id *this)
{
  if ((*((_DWORD *)this + 19) - 3) > 1) {
    CGColorSpaceNameForPixelFormat = 0;
  }
  else {
    CGColorSpaceNameForPixelFormat = (void *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat((int)objc_msgSend(this[8], sel_pixelFormat), *((unsigned __int8 *)this + 72));
  }
  v13[0] = 0;
  v14[0] = this[11];
  unsigned int v15 = 0;
  id v16 = CGColorSpaceNameForPixelFormat;
  id v3 = objc_msgSend(this[8], sel_mipmapLevelCount);
  int v4 = *((_DWORD *)this + 19);
  v7[0] = (unint64_t)v3 > 1;
  v7[1] = (unint64_t)v3 > 1;
  __int16 v8 = 256;
  char v9 = 1;
  int v10 = 1;
  v11[0] = 0;
  *(void *)((char *)v11 + 5) = 0;
  int v12 = 0;
  uint64_t TextureAsset = re::TextureAsset::makeTextureAsset((re *)(this + 4), (uint64_t)v13, v4, (long long *)v7);
  *(unsigned char *)(TextureAsset + 125) = 1;

  if (v15 != -1) {
    ((void (*)(char *, id *))*(&off_26E6DEE48 + v15))(&v17, v14);
  }
  return TextureAsset;
}

void re::TextureBuilder::makeAssetSync(re::TextureBuilder *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = (id *)((char *)this + 80);
  id v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    id v5 = v3;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = v5;
  }
  else
  {
    id v7 = (id *)((char *)this + 96);
    if (*((void *)this + 12)
      && (re::TextureBuilder::commitCommandBuffer(this),
          [*((id *)this + 12) waitUntilCompleted],
          [*((id *)this + 12) status] != 4))
    {
      re::internal::makeCommandBufferError((id *)&v19, v7);
      if (v4 != (id *)&v19)
      {
        id v16 = (void *)v19;
        *(void *)&long long v19 = 0;
        id v17 = *v4;
        *int v4 = v16;
      }
      id v18 = *v4;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = v18;
    }
    else
    {
      uint64_t TextureAsset = (re::TextureAsset *)re::TextureBuilder::makeTextureAsset((id *)this);
      uint64_t v9 = *((void *)this + 3);
      int v10 = re::TextureAsset::assetType(TextureAsset);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, re::TextureAsset *, uint64_t *, uint64_t, uint64_t, void))(*(void *)v9 + 416))(&v22, v9, TextureAsset, v10, 1, 1, 0);
      if (v23 && (unsigned int v11 = atomic_load((unsigned int *)(v23 + 704)), v11 == 3))
      {
        re::AssetHandle::loadFailedMessage((re::AssetHandle *)&v22, (re::DynamicString *)&v19);
        if (BYTE8(v19)) {
          int v12 = v20;
        }
        else {
          int v12 = (char *)&v19 + 9;
        }
        re::WrappedError::make((re::WrappedError *)@"RETextureBuilderErrorDomain", (const __CFString *)2, (uint64_t)v12, &v21);
        if (v4 != &v21)
        {
          id v13 = v21;
          id v21 = 0;
          id v14 = *v4;
          *int v4 = v13;
        }
        if (void)v19 && (BYTE8(v19)) {
          (*(void (**)(void))(*(void *)v19 + 40))();
        }
        id v15 = *v4;
        *(unsigned char *)a2 = 0;
        *(void *)(a2 + 8) = v15;
      }
      else
      {
        re::AssetHandle::AssetHandle((re::AssetHandle *)&v19, (const re::AssetHandle *)&v22);
        *(unsigned char *)a2 = 1;
        *(_OWORD *)(a2 + 8) = v19;
        long long v19 = 0uLL;
        *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v20;
        int v20 = 0;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v19);
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v22);
    }
  }
}

void re::internal::makeCommandBufferError(id *this, id *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  re::mtl::CommandBuffer::error(a2, this);
  id v5 = *re::pipelineLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    uint64_t v8 = (int)[*a2 status];
    id v9 = *this;
    *(_DWORD *)int v10 = 134218242;
    *(void *)&v10[4] = v8;
    __int16 v11 = 2112;
    id v12 = v9;
    _os_log_error_impl(&dword_233120000, v5, OS_LOG_TYPE_ERROR, "TextureBuilder command buffer did not complete (status = %zu, error = %@)", v10, 0x16u);
  }
  if (!*this)
  {
    re::WrappedError::make((re::WrappedError *)@"RETextureBuilderErrorDomain", (const __CFString *)3, (uint64_t)"Command buffer did not complete", v10);
    if (v10 != (unsigned char *)this)
    {
      uint64_t v6 = *(void **)v10;
      *(void *)int v10 = 0;
      id v7 = *this;
      *this = v6;
    }
  }
}

void re::TextureBuilder::makeAssetAsync(uint64_t a1, uint64_t a2)
{
  v32[5] = *MEMORY[0x263EF8340];
  id v3 = *(void **)(a1 + 80);
  if (v3)
  {
    v29[0] = 0;
    id v30 = v3;
    (*(void (**)(void, unsigned __int8 *))(**(void **)(a2 + 32) + 16))(*(void *)(a2 + 32), v29);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v29);
    return;
  }
  id v5 = re::globalAllocators((re *)a1);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 112, 8);
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
  *(void *)uint64_t v6 = &unk_26E6DEFD0;
  *(_OWORD *)(v6 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(void *)(v6 + 80) = re::globalAllocators(v7)[2];
  *(void *)(v6 + 88) = 0;
  uint64_t v8 = (uint64_t *)(v6 + 88);
  *(void *)(v6 + 104) = 0;
  *(void *)(v6 + 94) = 0;
  uint64_t TextureAsset = (re::TextureAsset *)re::TextureBuilder::makeTextureAsset((id *)a1);
  uint64_t v10 = *(void *)(a1 + 24);
  __int16 v11 = re::TextureAsset::assetType(TextureAsset);
  (*(void (**)(long long *__return_ptr, uint64_t, re::TextureAsset *, uint64_t *, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 416))(&v27, v10, TextureAsset, v11, 1, 1, 1);
  long long v12 = *(_OWORD *)(v6 + 24);
  *(_OWORD *)(v6 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v27;
  long long v27 = v12;
  uint64_t v13 = *(void *)(v6 + 40);
  *(void *)(v6 + 40) = v28;
  uint64_t v28 = v13;
  re::AssetManager::makeLoadRequest(*(re::AssetManager **)(a1 + 24), &v26);
  uint64_t v14 = *(void *)(v6 + 48);
  *(void *)(v6 + 48) = v26;
  long long v26 = (re::AssetLoadRequest *)v14;
  if (v14) {

  }
  uint64_t v15 = v6 + 56;
  if (v6 + 56 != a2)
  {
    re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable(v6 + 56);
    uint64_t v16 = *(void *)(a2 + 32);
    if (*(void *)(v6 + 80) != *(void *)(a2 + 24))
    {
      uint64_t v17 = *(void *)(a2 + 32);
      if (!v16) {
        goto LABEL_16;
      }
LABEL_11:
      unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 40))(v17);
      if (v18 >= 0x19)
      {
        unint64_t v19 = v18;
        uint64_t v20 = *(void *)(v6 + 80);
        if (v20) {
          uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v20 + 32))(v20, v19, 0);
        }
        else {
          uint64_t v15 = 0;
        }
      }
      *uint64_t v8 = v15;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32), v15);
      re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable(a2);
      goto LABEL_16;
    }
    uint64_t v17 = a2;
    if (v16 == a2) {
      goto LABEL_11;
    }
    *uint64_t v8 = v16;
    *(void *)(a2 + 32) = 0;
  }
LABEL_16:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v27);
  if (*(void *)(a1 + 104))
  {
    uint64_t v21 = re::globalAllocators((re *)(id)(v6 + 8))[2];
    v32[0] = &unk_26E6DEE68;
    v32[1] = v6;
    v32[3] = v21;
    v32[4] = v32;
    re::mtl::CommandBuffer::addCompletionHandler((void **)(a1 + 96), (uint64_t)v32);
    re::FunctionBase<24ul,void ()(re::mtl::CommandBuffer const&)>::destroyCallable((uint64_t)v32);
    re::TextureBuilder::commitCommandBuffer((void *)a1);
  }
  else
  {
    v24[0] = 1;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v6, (uint64_t)v24);
    if (!v24[0]) {
  }
    }
  uint64_t v22 = *(void *)(v6 + 48);
  id v23 = (id)(v6 + 8);
  v31[0] = &unk_26E6DF018;
  v31[1] = v6;
  v31[3] = v31;
  re::AssetLoadRequest::setCompletionHandler(v22, (uint64_t)v31, 0);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](v31);
  re::AssetLoadRequest::addAsset(*(re::AssetLoadRequest::Data ***)(v6 + 48), (const re::AssetHandle *)(v6 + 24));
}

void re::internal::TextureBuilderAsync::commandBufferDidComplete(uint64_t a1, uint64_t a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (*(unsigned char *)(a1 + 100))
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!m_commandBufferCompleted", "commandBufferDidComplete", 54);
    _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(a1 + 100) = 1;
    if (*(unsigned char *)a2 || (re::ObjCObject::operator=((id *)(a1 + 104), (id *)(a2 + 8)), *(unsigned char *)(a1 + 100)))
    {
      int v6 = *(unsigned __int8 *)(a1 + 101);
      os_unfair_lock_unlock(v4);
      if (v6)
      {
        re::internal::TextureBuilderAsync::callCompletionHandler((re::internal::TextureBuilderAsync *)a1);
      }
    }
    else
    {
      os_unfair_lock_unlock(v4);
    }
  }
}

uint64_t (***re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E6DEE68;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::~Callable(void *a1)
{
  *a1 = &unk_26E6DEE68;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::operator()(uint64_t a1, id *a2)
{
  int v4 = [*a2 status];
  uint64_t v5 = *(void *)(a1 + 8);
  if (v4 == 4)
  {
    v9[0] = 1;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v5, (uint64_t)v9);
    if (v9[0]) {
      return;
    }
    id v6 = v10;
  }
  else
  {
    re::internal::makeCommandBufferError(&v8, a2);
    id v7 = v8;
    id v8 = 0;
    v9[0] = 0;
    id v10 = v7;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v5, (uint64_t)v9);
    if (!v9[0]) {

    }
    id v6 = v8;
  }
}

void *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_26E6DEE68;
  a2[1] = v3;
  if (v3) {
    id v4 = (id)(v3 + 8);
  }
  return a2;
}

void *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6DEE68;
  a2[1] = v2;
  *(void *)(a1 + 8) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::mtl::CommandBuffer const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t (***re::internal::TextureBuilderAsync::callCompletionHandler(re::internal::TextureBuilderAsync *this))(void)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    *((void *)this + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 0;
    v11[0] = 0;
    uint64_t v12 = v2;
    (*(void (**)(void, unsigned __int8 *))(**((void **)this + 11) + 16))(*((void *)this + 11), v11);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v11);
  }
  else
  {
    long long v3 = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)((char *)this + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
    uint64_t v4 = *((void *)this + 5);
    *((void *)this + 5) = 0;
    v13[0] = 1;
    long long v14 = v3;
    long long v16 = 0u;
    uint64_t v15 = v4;
    uint64_t v17 = 0;
    (*(void (**)(void, unsigned __int8 *))(**((void **)this + 11) + 16))(*((void *)this + 11), v13);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v13);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v16);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {

    *((void *)this + 3) = 0;
  }
  *((void *)this + 4) = 0;
  id v6 = (char *)this + 56;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  if ((long long *)((char *)this + 56) != &v16)
  {
    re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable((uint64_t)this + 56);
    if (v19)
    {
      unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 40))(v19);
      if (v7 >= 0x19)
      {
        unint64_t v8 = v7;
        uint64_t v9 = *((void *)this + 10);
        if (v9) {
          id v6 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
        }
        else {
          id v6 = 0;
        }
      }
      *((void *)this + 11) = v6;
      (*(void (**)(uint64_t, char *))(*(void *)v19 + 24))(v19, v6);
    }
  }
  return re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable((uint64_t)&v16);
}

uint64_t re::introspect<re::ImportGraphicsResources>()
{
  v0 = &qword_268772000;
  {
    v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::ImportGraphicsResources>(void)::info = re::introspect_ImportGraphicsResources(0);
      v0 = &qword_268772000;
    }
  }
  return v0[309];
}

void std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6DEED0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6DEED0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = (void **)(v1 + 88);
  if (*(void *)(v1 + 88)) {
    goto LABEL_19;
  }
  if (*(unsigned char *)(*(void *)(v1 + 24) + 1344)
    && [*(id *)(v1 + 32) supportsSharedTextureHandles])
  {
    objc_msgSend(*(id *)(v1 + 64), sel_setStorageMode_, 2);
    re::mtl::Device::makeSharedTexture(*(id *)(v1 + 64), (id *)(v1 + 32), v24);
    NS::SharedPtr<MTL::Texture>::operator=(v2, (void **)v24);
    uint64_t v3 = *(re **)v24;
    if (*(void *)v24) {

    }
    if (*v2) {
      goto LABEL_19;
    }
    uint64_t v4 = *re::pipelineLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v21 = objc_msgSend(*(id *)(v1 + 64), sel_width);
      id v22 = objc_msgSend(*(id *)(v1 + 64), sel_height);
      *(_DWORD *)char v24 = 134218240;
      *(void *)&v24[4] = v21;
      *(_WORD *)&v24[12] = 2048;
      *(void *)&v24[14] = v22;
      _os_log_error_impl(&dword_233120000, v4, OS_LOG_TYPE_ERROR, "Failed to allocate shared texture with dimensions %zu x %zu", v24, 0x16u);
    }
    uint64_t v5 = "Failed to allocate shared texture";
    uint64_t v6 = 1;
  }
  else
  {
    re::mtl::Device::makeTexture(*(id *)(v1 + 64), (id *)(v1 + 32), v24);
    NS::SharedPtr<MTL::Texture>::operator=(v2, (void **)v24);
    unint64_t v7 = *(re **)v24;
    if (*(void *)v24) {

    }
    if (*v2) {
      goto LABEL_19;
    }
    unint64_t v8 = *re::pipelineLogObjects(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v19 = objc_msgSend(*(id *)(v1 + 64), sel_width);
      id v20 = objc_msgSend(*(id *)(v1 + 64), sel_height);
      *(_DWORD *)char v24 = 134218240;
      *(void *)&v24[4] = v19;
      *(_WORD *)&v24[12] = 2048;
      *(void *)&v24[14] = v20;
      _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Failed to allocate texture with dimensions %zu x %zu", v24, 0x16u);
    }
    uint64_t v5 = "Failed to allocate texture";
    uint64_t v6 = 0;
  }
  re::WrappedError::make((re::WrappedError *)@"RETextureBuilderErrorDomain", (const __CFString *)v6, (uint64_t)v5, v24);
  uint64_t v9 = (void **)(v1 + 80);
  if ((unsigned char *)(v1 + 80) != v24)
  {
    id v10 = *(void **)v24;
    *(void *)char v24 = 0;
    __int16 v11 = *v9;
    *uint64_t v9 = v10;
  }
  if (*v2)
  {
LABEL_19:
    uint64_t v12 = (id *)(v1 + 96);
    if (!*(void *)(v1 + 96))
    {
      *(void *)char v24 = 0x60C128E0D03BE2D1;
      *(void *)&char v24[8] = "TextureBuilderQueue";
      re::ImportGraphicsContext::getOrCreateCommandQueue(v1 + 32, (uint64_t)v24, (const char *)1, &v23);
      re::mtl::CommandQueue::makeCommandBuffer(&v23, v24);
      if (v12 != (id *)v24)
      {
        uint64_t v13 = *(void **)v24;
        *(void *)char v24 = 0;
        id v14 = *v12;
        *uint64_t v12 = v13;
      }
    }
    uint64_t v16 = *(void *)(v1 + 104);
    uint64_t v15 = (unsigned char *)(v1 + 104);
    if (!v16)
    {
      re::mtl::CommandBuffer::makeBlitCommandEncoder(v12, v24);
      if (v15 != v24)
      {
        uint64_t v17 = *(void *)v24;
        *(void *)char v24 = 0;
        uint64_t v18 = *(void **)v15;
        *(void *)uint64_t v15 = v17;
      }
    }
  }
}

uint64_t std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6DEF50;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6DEF50;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void **)(v1 + 104);
  if (v2)
  {
    [v2 endEncoding];
    uint64_t v3 = *(void **)(v1 + 104);
    *(void *)(v1 + 104) = 0;
  }
  uint64_t v4 = *(void **)(v1 + 96);
  return [v4 commit];
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::target_type()
{
}

void re::internal::TextureBuilderAsync::~TextureBuilderAsync(id *this)
{
  *this = &unk_26E6DEFD0;

  re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable((uint64_t)(this + 7));
  uint64_t v2 = (char *)this[6];
  if (v2)
  {

    this[6] = 0;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 3));
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  char *v2;
  uint64_t vars8;

  *this = &unk_26E6DEFD0;

  re::FunctionBase<24ul,void ()(re::Result<re::AssetHandle,re::WrappedError>)>::destroyCallable((uint64_t)(this + 7));
  uint64_t v2 = (char *)this[6];
  if (v2)
  {

    this[6] = 0;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 3));
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBD0);
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::~__func(void *a1)
{
  *a1 = &unk_26E6DF018;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::~__func(void *a1)
{
  *a1 = &unk_26E6DF018;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_26E6DF018;
  v2[1] = v3;
  if (v3) {
    id v4 = (id)(v3 + 8);
  }
  return v2;
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::__clone(void *result, void *a2)
{
  uint64_t v2 = result[1];
  *a2 = &unk_26E6DF018;
  a2[1] = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return result;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {

    *(void *)(a1 + 8) = 0;
  }
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = __p[1];
  if (v2) {

  }
  operator delete(__p);
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v2 = *a2;
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3) {
    id v4 = v3 + 1;
  }
  if (v2)
  {
    v10[0] = 1;
    re::internal::TextureBuilderAsync::assetLoadDidComplete((uint64_t)v3, (uint64_t)v10);
    if (!v10[0]) {
  }
    }
  else
  {
    re::AssetHandle::loadFailedMessage((re::AssetHandle *)(v3 + 3), (re::DynamicString *)&v12);
    if (v13) {
      uint64_t v5 = *(unsigned char **)&v14[7];
    }
    else {
      uint64_t v5 = v14;
    }
    re::WrappedError::make((re::WrappedError *)@"RETextureBuilderErrorDomain", (const __CFString *)2, (uint64_t)v5, &v9);
    id v6 = v9;
    id v9 = 0;
    v10[0] = 0;
    id v11 = v6;
    re::internal::TextureBuilderAsync::assetLoadDidComplete((uint64_t)v3, (uint64_t)v10);
    if (!v10[0]) {

    }
    if (v12 && (v13 & 1) != 0) {
      (*(void (**)(void))(*(void *)v12 + 40))();
    }
  }
  uint64_t v7 = v3[6];
  uint64_t v12 = &unk_26E6DF088;
  uint64_t v15 = &v12;
  re::AssetLoadRequest::setCompletionHandler(v7, (uint64_t)&v12, 0);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](&v12);
  uint64_t v8 = v3[6];
  if (v8)
  {

    v3[6] = 0;
  }
}

uint64_t std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::target_type()
{
}

void re::internal::TextureBuilderAsync::assetLoadDidComplete(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (*(unsigned char *)(a1 + 101))
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!m_assetLoadCompleted", "assetLoadDidComplete", 74);
    _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(a1 + 101) = 1;
    if (!*(unsigned char *)a2 && !*(void *)(a1 + 104)) {
      re::ObjCObject::operator=((id *)(a1 + 104), (id *)(a2 + 8));
    }
    if (*(unsigned char *)(a1 + 100))
    {
      int v6 = *(unsigned __int8 *)(a1 + 101);
      os_unfair_lock_unlock(v4);
      if (v6)
      {
        re::internal::TextureBuilderAsync::callCompletionHandler((re::internal::TextureBuilderAsync *)a1);
      }
    }
    else
    {
      os_unfair_lock_unlock(v4);
    }
  }
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func()
{
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6DF088;
  return result;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DF088;
}

uint64_t std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::target_type()
{
}

re::DynamicString *re::SkeletonCompiler::getCurrentCompiledAssetInfo@<X0>(re::SkeletonCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::SkeletonAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::SkeletonAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::SkeletonCompiler::assetIntrospectionType(re::SkeletonCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::SkeletonAsset>(void)::info = re::introspect_SkeletonAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[354];
}

uint64_t re::SkeletonCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::SkeletonCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::SkeletonCompiler::compile@<X0>(re::SkeletonCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  v26[4] = *MEMORY[0x263EF8340];
  id v9 = re::globalAllocators(this);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9[2] + 32))(v9[2], 248, 8);
  *(_OWORD *)uint64_t v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_OWORD *)(v10 + 80) = 0u;
  *(_OWORD *)(v10 + 96) = 0u;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 128) = 0u;
  *(_OWORD *)(v10 + 144) = 0u;
  *(_OWORD *)(v10 + 160) = 0u;
  *(_OWORD *)(v10 + 176) = 0u;
  *(_OWORD *)(v10 + 192) = 0u;
  *(_OWORD *)(v10 + 208) = 0u;
  *(_OWORD *)(v10 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(void *)(v10 + 8) = "";
  *(void *)(v10 + 96) = "";
  *(_OWORD *)(v10 + 104) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 184) = 0u;
  *(_OWORD *)(v10 + 200) = 0u;
  *(_OWORD *)(v10 + 216) = 0u;
  *(void *)(v10 + 232) = 0x7FFFFFFF00000000;
  *(void *)(v10 + 240) = 0;
  *(void *)&long long v21 = &unk_26E6DF180;
  *((void *)&v22 + 1) = &v21;
  v26[3] = v26;
  uint64_t v25 = (const char *)v10;
  v26[0] = &unk_26E6DF180;
  std::__function::__value_func<void ()(re::SkeletonAsset *)>::~__value_func[abi:nn180100](&v21);
  id v11 = v25;
  uint64_t v12 = (*(uint64_t (**)(re::SkeletonCompiler *))(*(void *)this + 24))(this);
  re::AssetUtilities::readSourceJson(a2, v11, v12, a3, (uint64_t)v18);
  if (v18[0])
  {
    uint64_t v13 = (uint64_t)v25;
    uint64_t v25 = 0;
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v13;
  }
  else
  {
    *(void *)&long long v21 = 100;
    *((void *)&v21 + 1) = re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v22, (const re::DynamicString *)&v19);
    long long v14 = v22;
    *(_OWORD *)(a4 + 8) = v21;
    uint64_t v15 = v23;
    uint64_t v16 = v24;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v14;
    *(void *)(a4 + 40) = v15;
    *(void *)(a4 + 48) = v16;
    if (!v18[0] && v19 && (v20 & 1) != 0) {
      (*(void (**)(void))(*(void *)v19 + 40))();
    }
  }
  return std::unique_ptr<re::SkeletonAsset,std::function<void ()(re::SkeletonAsset*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v25);
}

re *re::SkeletonCompiler::deleteAsset(re::SkeletonCompiler *this, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::SkeletonAsset>((re *)"deleteAsset", 55, a2);
}

re *re::internal::destroyPersistent<re::SkeletonAsset>(re *result, uint64_t a2, uint64_t *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::Skeleton::~Skeleton((re::Skeleton *)(a3 + 11));
    re::FixedArray<CoreIKTransform>::deinit(a3 + 8);
    re::FixedArray<CoreIKTransform>::deinit(a3 + 5);
    re::FixedArray<re::StringID>::deinit(a3 + 2);
    re::StringID::destroyString((re::StringID *)a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::SkeletonCompiler::~SkeletonCompiler(re::SkeletonCompiler *this)
{
}

void std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::~__func()
{
}

void *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6DF180;
  return result;
}

void std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DF180;
}

re *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::operator()(uint64_t a1, uint64_t **a2)
{
  return re::internal::destroyPersistent<re::SkeletonAsset>((re *)"operator()", 40, *a2);
}

uint64_t std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::SkeletonAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::SkeletonAsset,std::function<void ()(re::SkeletonAsset*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::SkeletonAsset *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::SkeletonAsset *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t std::function<void ()(re::SkeletonAsset *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return re::TextureAssetData::TextureAssetData(v4);
}

uint64_t re::TextureAssetData::TextureAssetData(uint64_t a1, uint64_t a2, int a3, _OWORD *a4)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26E6DF210;
  *(unsigned char *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(unsigned char *)a2;
  *(unsigned char *)(v8 + 32) = 0;
  *(_DWORD *)(a1 + 112) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>(v8 + 32, a2 + 8);
  *(void *)(a1 + 120) = *(id *)(a2 + 96);
  *(_DWORD *)(a1 + 128) = a3;
  long long v9 = a4[1];
  *(_OWORD *)(a1 + 132) = *a4;
  *(_OWORD *)(a1 + 148) = v9;
  return a1;
}

void re::TextureAssetData::~TextureAssetData(id *this)
{
  *this = &unk_26E6DF210;

  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, id *))*(&off_26E6DF248 + v2))(&v3, this + 4);
  }
  *((_DWORD *)this + 28) = -1;
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  uint64_t v2;
  char v3;

  *this = &unk_26E6DF210;

  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, id *))*(&off_26E6DF248 + v2))(&v3, this + 4);
  }
  *((_DWORD *)this + 28) = -1;
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  MEMORY[0x237DBCBD0](this, 0x10F3C409B209BBFLL);
}

re::DynamicString *re::MeshCompiler::getCurrentCompiledAssetInfo@<X0>(re::MeshCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  char v3 = (re::MeshAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::MeshAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::MeshCompiler::assetIntrospectionType(re::MeshCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::MeshAsset>(void)::info = re::introspect_MeshAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[151];
}

void *re::MeshCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  do
    uint64_t result = re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::MeshCompiler::getSupportedExtensions(void)const::supportedExtensions[v3++]);
  while (v3 != 5);
  return result;
}

void re::MeshCompiler::compile(const char *a1@<X1>, char *a2@<X2>, uint64_t a3@<X8>)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v36, 4500, 0);
  *(_DWORD *)uint64_t v33 = 16842752;
  v33[4] = 1;
  *(_DWORD *)&v33[5] = 0;
  *(_WORD *)&v33[9] = 0;
  *(_DWORD *)&v33[12] = 1036831949;
  *(_DWORD *)&v33[16] = 16843008;
  v33[20] = 0;
  long long v35 = 0u;
  memset(v34, 0, sizeof(v34));
  DWORD1(v35) = 0x7FFFFFFF;
  if (a2)
  {
    *(_OWORD *)uint64_t v33 = *(_OWORD *)a2;
    *(void *)&v33[13] = *(void *)(a2 + 13);
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v34, (uint64_t)(a2 + 24));
  }
  re::loadGeomSceneFromFile(a1, (uint64_t)v33, (uint64_t)v26);
  if (v26[0])
  {
    re::DynamicArray<re::GeomModelWithLods>::DynamicArray((uint64_t)&v18, v27);
    re::DynamicArray<re::GeomInstance>::DynamicArray((uint64_t)v21, v28);
    re::DynamicArray<re::GeomSkeleton>::DynamicArray((uint64_t)v24, v31);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)v25, (uint64_t)v32);
    re::makeMeshAssetDataFromGeomScene(&v18, (uint64_t)v33, (uint64_t)v16);
    int v8 = v16[0];
    uint64_t v10 = re::globalAllocators(v9);
    id v11 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 960, 8);
    if (v8) {
      uint64_t v12 = re::MeshAsset::MeshAsset((uint64_t)v11, (uint64_t)&v17);
    }
    else {
      re::MeshAsset::MeshAsset(v11);
    }
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v12;
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)v16);
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v25);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)v24);
    if (v21[0])
    {
      if (v23) {
        (*(void (**)(void))(*(void *)v21[0] + 40))();
      }
      uint64_t v23 = 0;
      memset(v21, 0, sizeof(v21));
      ++v22;
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)&v18);
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Failed to load '%s", (re::DynamicString *)&v18, a1);
    long long v13 = v18;
    uint64_t v14 = v19;
    uint64_t v15 = v20;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 100;
    *(void *)(a3 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v13;
    *(void *)(a3 + 40) = v14;
    *(void *)(a3 + 48) = v15;
  }
  if (v26[0])
  {
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v32);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)v31);
    if (v28[0])
    {
      if (v30) {
        (*(void (**)(void))(*(void *)v28[0] + 40))();
      }
      uint64_t v30 = 0;
      memset(v28, 0, sizeof(v28));
      ++v29;
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v27);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v34);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v36);
}

re *re::MeshCompiler::deleteAsset(re::MeshCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::MeshAsset>((re *)"deleteAsset", 89, a2);
}

re *re::MeshCompiler::deleteAssetCompileOptions(re *this, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = re::globalAllocators(this)[2];
    v4.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a2 + 3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t *, __n128))(*(void *)v3 + 40);
    return (re *)v5(v3, a2, v4);
  }
  return this;
}

void re::MeshCompiler::~MeshCompiler(re::MeshCompiler *this)
{
}

uint64_t re::DynamicArray<re::GeomModelWithLods>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomModelWithLods>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomModelWithLods>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::GeomModelWithLods>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomModelWithLods>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 152 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 152 * v8;
      uint64_t v12 = 152 * v4;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)(v10 + v11), (const re::DynamicString *)(v9 + v11));
        re::DynamicArray<re::GeomModel>::DynamicArray(v10 + v11 + 32, (uint64_t *)(v9 + v11 + 32));
        re::DynamicArray<float>::DynamicArray(v10 + v11 + 72, (uint64_t *)(v9 + v11 + 72));
        re::DynamicArray<float>::DynamicArray(v10 + v11 + 112, (uint64_t *)(v9 + v11 + 112));
        v9 += 152;
        v12 -= 152;
        v10 += 152;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>((uint64_t)&v13, *(void *)(a2 + 32), *(void *)(a2 + 32) + 152 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      int v6 = (re::DynamicString *)(a1[4] + 152 * v4);
      uint64_t v7 = -152 * v4 + 152 * v5;
      do
      {
        re::DynamicArray<unsigned long>::deinit((uint64_t)v6 + 112);
        re::DynamicArray<unsigned long>::deinit((uint64_t)v6 + 72);
        re::DynamicArray<re::GeomModel>::deinit((uint64_t)v6 + 32);
        re::DynamicString::deinit(v6);
        int v6 = (re::DynamicString *)((char *)v6 + 152);
        v7 -= 152;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<re::GeomModel>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<float>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::DynamicArray<float>::operator=(a4 + v7 + 112, (uint64_t *)(a2 + v7 + 112));
    v7 += 152;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::GeomModel>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomModel>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomModel>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::GeomModel>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomModel>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::GeomModel>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomModel>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>((uint64_t)&v20, *(void *)(a2 + 32), *(void *)(a2 + 32) + 248 * a1[2], a1[4]);
    uint64_t v10 = a1[2];
    if (v10 != v4)
    {
      uint64_t v11 = *(void *)(a2 + 32);
      uint64_t v12 = a1[4];
      uint64_t v13 = 248 * v10;
      uint64_t v14 = 248 * v4;
      do
      {
        uint64_t v15 = v11 + v13;
        uint64_t v16 = v12 + v13;
        re::DynamicString::DynamicString((re::DynamicString *)(v12 + v13), (const re::DynamicString *)(v11 + v13));
        re::DynamicArray<re::GeomMesh>::DynamicArray(v12 + v13 + 32, (uint64_t *)(v11 + v13 + 32));
        re::DynamicArray<float>::DynamicArray(v12 + v13 + 72, (uint64_t *)(v11 + v13 + 72));
        int v17 = *(unsigned __int8 *)(v11 + v13 + 112);
        *(unsigned char *)(v12 + v13 + 112) = v17;
        if (v17) {
          re::DynamicArray<re::GeomIndexMap>::DynamicArray(v16 + 120, (uint64_t *)(v15 + 120));
        }
        int v18 = *(unsigned __int8 *)(v15 + 160);
        *(unsigned char *)(v16 + 160) = v18;
        if (v18) {
          re::DynamicArray<re::GeomIndexMap>::DynamicArray(v12 + v13 + 168, (uint64_t *)(v11 + v13 + 168));
        }
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray(v12 + v13 + 208, (uint64_t *)(v11 + v13 + 208));
        v11 += 248;
        v14 -= 248;
        v12 += 248;
      }
      while (v13 != v14);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>((uint64_t)&v19, *(void *)(a2 + 32), *(void *)(a2 + 32) + 248 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4];
      uint64_t v7 = 248 * v4;
      uint64_t v8 = 248 * v5;
      do
      {
        uint64_t v9 = v6 + v7;
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v6 + v7 + 208);
        if (*(unsigned char *)(v6 + v7 + 160)) {
          re::DynamicArray<re::GeomIndexMap>::deinit(v9 + 168);
        }
        if (*(unsigned char *)(v9 + 112)) {
          re::DynamicArray<re::GeomIndexMap>::deinit(v6 + v7 + 120);
        }
        re::DynamicArray<unsigned long>::deinit(v6 + v7 + 72);
        re::DynamicArray<re::GeomMesh>::deinit(v6 + v7 + 32);
        re::DynamicString::deinit((re::DynamicString *)(v6 + v7));
        v6 += 248;
        v8 -= 248;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::GeomModel>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = 248 * v2;
    do
    {
      uint64_t v6 = v4 + v3;
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v4 + v3 + 208);
      if (*(unsigned char *)(v4 + v3 + 160)) {
        re::DynamicArray<re::GeomIndexMap>::deinit(v6 + 168);
      }
      if (*(unsigned char *)(v6 + 112)) {
        re::DynamicArray<re::GeomIndexMap>::deinit(v4 + v3 + 120);
      }
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 72);
      re::DynamicArray<re::GeomMesh>::deinit(v4 + v3 + 32);
      re::DynamicString::deinit((re::DynamicString *)(v4 + v3));
      v3 += 248;
    }
    while (v5 != v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<re::GeomMesh>::operator=((re::GeomMesh *)(a4 + v7 + 32), (re::GeomMesh *)(a2 + v7 + 32));
    re::DynamicArray<float>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=((unsigned char *)(a4 + v7 + 112), (uint64_t *)(a2 + v7 + 112));
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=((unsigned char *)(a4 + v7 + 160), (uint64_t *)(a2 + v7 + 160));
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::operator=(a4 + v7 + 208, (uint64_t *)(a2 + v7 + 208));
    v7 += 248;
  }
  while (a2 + v7 != v6);
  return v6;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::operator=(re::GeomMesh *a1, re::GeomMesh *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomMesh>::copy((uint64_t)a1, (uint64_t)a2);
        ++*((_DWORD *)a1 + 6);
      }
      else
      {
        re::DynamicArray<re::GeomMesh>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = *((void *)a2 + 2);
      *(void *)a1 = v4;
      re::DynamicArray<re::GeomMesh>::setCapacity(a1, v5);
      ++*((_DWORD *)a1 + 6);
      re::DynamicArray<re::GeomMesh>::copy((uint64_t)a1, (uint64_t)a2);
    }
  }
  return a1;
}

unsigned char *re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(unsigned char *a1, uint64_t *a2)
{
  int v3 = *a1;
  int v4 = *(unsigned __int8 *)a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (uint64_t)(a1 + 8);
    if (v3) {
      BOOL v7 = v4 == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      re::DynamicArray<re::GeomIndexMap>::deinit(v6);
      *a1 = 0;
    }
    else
    {
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::DynamicArray<re::GeomIndexMap>::operator=(v6, a2 + 1);
      }
      else
      {
        *a1 = 1;
        re::DynamicArray<re::GeomIndexMap>::DynamicArray(v6, a2 + 1);
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::GeomMesh>::setCapacity((void *)a1, *(void *)(a2 + 16));
    uint64_t result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(*(re::GeomMesh **)(a2 + 32), (re::GeomMesh *)(*(void *)(a2 + 32) + 736 * *(void *)(a1 + 16)), *(re::GeomMesh **)(a1 + 32));
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9 != v4)
    {
      uint64_t v10 = 736 * v9;
      uint64_t v11 = (re::GeomMesh *)(*(void *)(a2 + 32) + v10);
      uint64_t v12 = 736 * v4 - v10;
      uint64_t v13 = (void *)(v10 + *(void *)(a1 + 32) + 16);
      do
      {
        *(v13 - 2) = 0;
        *((_DWORD *)v13 - 2) = 0;
        bzero(v13, 0x2C8uLL);
        re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)v13);
        v13[89] = 0;
        uint64_t result = re::GeomMesh::copy(v11, (re::GeomMesh *)(v13 - 2));
        uint64_t v11 = (re::GeomMesh *)((char *)v11 + 736);
        v13 += 92;
        v12 -= 736;
      }
      while (v12);
    }
  }
  else
  {
    uint64_t result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(*(re::GeomMesh **)(a2 + 32), (re::GeomMesh *)(*(void *)(a2 + 32) + 736 * v4), *(re::GeomMesh **)(a1 + 32));
    uint64_t v6 = *(void *)(a1 + 16);
    if (v4 != v6)
    {
      uint64_t result = (re::GeomMesh *)(*(void *)(a1 + 32) + 736 * v4);
      uint64_t v7 = 736 * v6 - 736 * v4;
      do
      {
        re::GeomMesh::~GeomMesh(result);
        uint64_t result = (re::GeomMesh *)(v8 + 736);
        v7 -= 736;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
  return result;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::clear(re::GeomMesh *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 2);
  *((void *)result + 2) = 0;
  if (v2)
  {
    uint64_t result = (re::GeomMesh *)*((void *)result + 4);
    uint64_t v3 = 736 * v2;
    do
    {
      re::GeomMesh::~GeomMesh(result);
      uint64_t result = (re::GeomMesh *)(v4 + 736);
      v3 -= 736;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

re::GeomMesh *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(re::GeomMesh *a1, re::GeomMesh *a2, re::GeomMesh *a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::GeomMesh::copy(v4, a3);
      uint64_t v4 = (re::GeomMesh *)((char *)v4 + 736);
      a3 = (re::GeomMesh *)((char *)a3 + 736);
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomIndexMap>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomIndexMap>::clear(a1, (uint64_t)a2);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::GeomIndexMap>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomIndexMap>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomIndexMap>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomIndexMap>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::GeomIndexMap>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomIndexMap>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 80 * a1[2], a1[4]);
    uint64_t v11 = a1[2];
    if (v11 != v4)
    {
      uint64_t v12 = *(void *)(a2 + 32);
      uint64_t v13 = v12 + 80 * v4;
      uint64_t v14 = a1[4];
      uint64_t v15 = 80 * v11;
      do
      {
        uint64_t v16 = v12 + v15;
        uint64_t v17 = v14 + v15;
        *(void *)uint64_t v17 = *(void *)(v12 + v15);
        *(_DWORD *)(v17 + 8) = *(_DWORD *)(v12 + v15 + 8);
        *(unsigned char *)(v17 + 12) = *(unsigned char *)(v12 + v15 + 12);
        int v18 = (_DWORD *)(v14 + v15 + 16);
        int v19 = *(unsigned __int8 *)(v12 + v15 + 12);
        if (v19 == 2)
        {
          re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)v18, (uint64_t *)(v16 + 16));
        }
        else if (v19 == 1)
        {
          re::DynamicArray<float>::DynamicArray((uint64_t)v18, (uint64_t *)(v12 + v15 + 16));
        }
        else
        {
          if (*(unsigned char *)(v12 + v15 + 12)) {
            goto LABEL_23;
          }
          *int v18 = *(_DWORD *)(v12 + v15 + 16);
        }
        v12 += 80;
        v14 += 80;
      }
      while (v16 + 80 != v13);
    }
    goto LABEL_21;
  }
  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 80 * v4, a1[4]);
  uint64_t v6 = a1[2];
  if (v4 == v6)
  {
LABEL_21:
    a1[2] = v4;
    return;
  }
  uint64_t v7 = 80 * v6 - 80 * v4;
  uint64_t v8 = (_DWORD *)(a1[4] + 80 * v4 + 16);
  while (1)
  {
    int v9 = *((unsigned __int8 *)v8 - 4);
    if (v9 == 2)
    {
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)v8);
      goto LABEL_10;
    }
    if (v9 == 1)
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)v8);
      goto LABEL_10;
    }
    if (*((unsigned char *)v8 - 4)) {
      break;
    }
    *uint64_t v8 = 0;
LABEL_10:
    v8 += 20;
    v7 -= 80;
    if (!v7) {
      goto LABEL_21;
    }
  }
  re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_23:
  re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
  _os_crash();
  __break(1u);
}

void *re::DynamicArray<re::GeomIndexMap>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomIndexMap>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (!a2)
      {
        uint64_t v7 = 0;
        if (!v3)
        {
LABEL_22:
          v5[4] = v7;
          v5[1] = a2;
          return result;
        }
LABEL_11:
        uint64_t v8 = v5[4];
        uint64_t v9 = v5[2];
        if (v9)
        {
          uint64_t v10 = 80 * v9;
          uint64_t v11 = (_DWORD *)(v8 + 16);
          uint64_t v12 = (uint64_t)v7;
          do
          {
            re::GeomIndexMap::GeomIndexMap(v12, (uint64_t)(v11 - 4));
            int v14 = *((unsigned __int8 *)v11 - 4);
            if (v14 == 2)
            {
              re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)v11);
            }
            else if (v14 == 1)
            {
              re::DynamicArray<unsigned long>::deinit((uint64_t)v11);
            }
            else
            {
              if (*((unsigned char *)v11 - 4)) {
                goto LABEL_26;
              }
              *uint64_t v11 = 0;
            }
            v12 += 80;
            v11 += 20;
            v10 -= 80;
          }
          while (v10);
          uint64_t v8 = v5[4];
        }
        uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
        goto LABEL_22;
      }
      if (is_mul_ok(a2, 0x50uLL))
      {
        uint64_t v2 = 80 * a2;
        uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
        if (result)
        {
          uint64_t v7 = result;
          if (!v5[1]) {
            goto LABEL_22;
          }
          goto LABEL_11;
        }
      }
      else
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
      _os_crash();
      __break(1u);
LABEL_26:
      re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      uint64_t result = (void *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::GeomIndexMap::GeomIndexMap(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  uint64_t v4 = a1 + 16;
  int v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 2)
  {
LABEL_8:
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)uint64_t v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    re::HashBrown<re::WeakStringID,unsigned char,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned char>,false>::swap((uint64_t *)v4, (uint64_t *)(a2 + 16));
    *(void *)a2 = 0xFFFFFFFF00000000;
    *(_DWORD *)(a2 + 8) = -1;
    int v8 = *(unsigned __int8 *)(a2 + 12);
    if (v8 == 2)
    {
      *(void *)(a2 + 56) = 0;
      *(void *)(a2 + 64) = 0;
      unint64_t v17 = *(void *)(a2 + 32);
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = v17;
      if (v17 >= 0x10)
      {
        unint64_t v18 = 0;
        *(void *)&long long v19 = -1;
        *((void *)&v19 + 1) = -1;
        do
          *(_OWORD *)(*(void *)(a2 + 16) + 16 * v18++) = v19;
        while (v18 < *(void *)(a2 + 32) >> 4);
      }
      return a1;
    }
    if (v8 != 1)
    {
      if (!*(unsigned char *)(a2 + 12))
      {
        *(_DWORD *)(a2 + 16) = 0;
        return a1;
      }
      goto LABEL_31;
    }
    goto LABEL_16;
  }
  if (v5 != 1)
  {
    if (*(unsigned char *)(a2 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 461);
      _os_crash();
      __break(1u);
LABEL_31:
      re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
      _os_crash();
      __break(1u);
      goto LABEL_32;
    }
    *(_DWORD *)uint64_t v4 = *(_DWORD *)(a2 + 16);
    *(void *)a2 = 0xFFFFFFFF00000000;
    *(_DWORD *)(a2 + 8) = -1;
    int v6 = *(unsigned __int8 *)(a2 + 12);
    if (v6 == 2)
    {
      *(void *)(a2 + 56) = 0;
      *(void *)(a2 + 64) = 0;
      unint64_t v14 = *(void *)(a2 + 32);
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = v14;
      if (v14 >= 0x10)
      {
        unint64_t v15 = 0;
        *(void *)&long long v16 = -1;
        *((void *)&v16 + 1) = -1;
        do
          *(_OWORD *)(*(void *)(a2 + 16) + 16 * v15++) = v16;
        while (v15 < *(void *)(a2 + 32) >> 4);
      }
      return a1;
    }
    if (v6 == 1)
    {
LABEL_16:
      *(void *)(a2 + 32) = 0;
      ++*(_DWORD *)(a2 + 40);
      return a1;
    }
    if (*(unsigned char *)(a2 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
      uint64_t v4 = _os_crash();
      __break(1u);
      goto LABEL_8;
    }
LABEL_15:
    *(_DWORD *)(a2 + 16) = 0;
    return a1;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  *(_DWORD *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v9 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v9;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  unint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v10;
  uint64_t v11 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v11;
  ++*(_DWORD *)(a2 + 40);
  ++*(_DWORD *)(a1 + 40);
  *(void *)a2 = 0xFFFFFFFF00000000;
  *(_DWORD *)(a2 + 8) = -1;
  int v12 = *(unsigned __int8 *)(a2 + 12);
  if (v12 == 2)
  {
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = v10;
    if (v10 >= 0x10)
    {
      unint64_t v20 = 0;
      *(void *)&long long v21 = -1;
      *((void *)&v21 + 1) = -1;
      do
        *(_OWORD *)(*(void *)(a2 + 16) + 16 * v20++) = v21;
      while (v20 < *(void *)(a2 + 32) >> 4);
    }
    return a1;
  }
  if (v12 == 1) {
    goto LABEL_16;
  }
  if (!*(unsigned char *)(a2 + 12)) {
    goto LABEL_15;
  }
LABEL_32:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t v18;

  *(void *)(a1 + 4) = -1;
  *(unsigned char *)(a1 + 12) = 1;
  uint64_t v4 = *(void *)(a2 + 16);
  if (!v4) {
    goto LABEL_20;
  }
  int v5 = 0;
  int v6 = (void *)(a1 + 16);
  uint64_t v7 = *(void *)(a2 + 32);
  int v8 = -1;
  uint64_t v9 = -1;
  do
  {
    if (v4 == v5)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*(_DWORD *)(v7 + 4 * v5) != -1)
    {
      *(_DWORD *)(a1 + 8) = v5;
      if (v9 == -1)
      {
        *(_DWORD *)(a1 + 4) = v5;
        int v8 = v5;
        uint64_t v9 = v5;
      }
      else
      {
        int v8 = v5;
      }
    }
    ++v5;
  }
  while (v4 != v5);
  if (v8 == -1)
  {
LABEL_20:
    *(void *)(a2 + 16) = 0;
    ++*(_DWORD *)(a2 + 24);
    goto LABEL_21;
  }
  re::DynamicArray<float>::resize(a2, (v8 + 1));
  unint64_t v10 = *(void *)(a2 + 16);
  if (!v10)
  {
LABEL_21:
    *(_DWORD *)a1 = 0;
    *(unsigned char *)(a1 + 12) = 0;
LABEL_22:
    *(void *)(a1 + 4) = -1;
    *(_DWORD *)(a1 + 16) = 0;
    return a1;
  }
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 1;
  do
  {
    unint64_t v14 = *(unsigned int *)(*(void *)(a2 + 32) + 4 * v11);
    v13 &= v11 == v14;
    if (v14 == 0xFFFFFFFFLL) {
      ++v12;
    }
    ++v11;
  }
  while (*(void *)(a2 + 16) != v11);
  unint64_t v15 = v10 - v12;
  if (*(_DWORD *)(a1 + 4) == -1) {
    unint64_t v15 = 0;
  }
  *(_DWORD *)a1 = v15;
  if ((v13 & 1) == 0)
  {
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *int v6 = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(void *)(a1 + 16) = *(void *)a2;
    *(void *)a2 = 0;
    *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = 0;
    unint64_t v17 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v17;
    unint64_t v18 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = v18;
    ++*(_DWORD *)(a2 + 24);
    ++*(_DWORD *)(a1 + 40);
    return a1;
  }
  *(unsigned char *)(a1 + 12) = 0;
  if (!v15) {
    goto LABEL_22;
  }
  *(_DWORD *)int v6 = v15;
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::GeomIndexMap::operator=(a3, v4);
      v4 += 80;
      a3 += 80;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::GeomIndexMap::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 == a1) {
    return a1;
  }
  int v4 = *(unsigned __int8 *)(a1 + 12);
  if (v4 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a1 + 16);
  }
  else if (v4 == 1)
  {
    re::DynamicArray<unsigned long>::deinit(a1 + 16);
  }
  else
  {
    if (*(unsigned char *)(a1 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 810);
      _os_crash();
      __break(1u);
      goto LABEL_16;
    }
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  int v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 2)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown(a1 + 16, (uint64_t *)(a2 + 16));
    return a1;
  }
  if (v5 == 1)
  {
    re::DynamicArray<float>::DynamicArray(a1 + 16, (uint64_t *)(a2 + 16));
    return a1;
  }
  if (!*(unsigned char *)(a2 + 12))
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    return a1;
  }
LABEL_16:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 833);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  long long v16;
  unint64_t v17;
  unint64_t v18;
  long long v19;
  unint64_t v20;
  long long v21;

  if (a2 == a1) {
    return a1;
  }
  int v4 = *(unsigned __int8 *)(a1 + 12);
  if (v4 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a1 + 16);
  }
  else if (v4 == 1)
  {
    re::DynamicArray<unsigned long>::deinit(a1 + 16);
  }
  else
  {
    if (*(unsigned char *)(a1 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 859);
      _os_crash();
      __break(1u);
      goto LABEL_38;
    }
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  int v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 2) {
    goto LABEL_15;
  }
  if (v5 != 1)
  {
    if (!*(unsigned char *)(a2 + 12))
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
      *(void *)a2 = 0xFFFFFFFF00000000;
      *(_DWORD *)(a2 + 8) = -1;
      int v6 = *(unsigned __int8 *)(a2 + 12);
      if (v6 == 2)
      {
        *(void *)(a2 + 56) = 0;
        *(void *)(a2 + 64) = 0;
        unint64_t v14 = *(void *)(a2 + 32);
        *(void *)(a2 + 40) = 0;
        *(void *)(a2 + 48) = v14;
        if (v14 >= 0x10)
        {
          unint64_t v15 = 0;
          *(void *)&long long v16 = -1;
          *((void *)&v16 + 1) = -1;
          do
            *(_OWORD *)(*(void *)(a2 + 16) + 16 * v15++) = v16;
          while (v15 < *(void *)(a2 + 32) >> 4);
        }
        return a1;
      }
      if (v6 == 1) {
        goto LABEL_23;
      }
      if (*(unsigned char *)(a2 + 12))
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
        _os_crash();
        __break(1u);
LABEL_15:
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        re::HashBrown<re::WeakStringID,unsigned char,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned char>,false>::swap((uint64_t *)(a1 + 16), (uint64_t *)(a2 + 16));
        *(void *)a2 = 0xFFFFFFFF00000000;
        *(_DWORD *)(a2 + 8) = -1;
        int v8 = *(unsigned __int8 *)(a2 + 12);
        if (v8 == 2)
        {
          *(void *)(a2 + 56) = 0;
          *(void *)(a2 + 64) = 0;
          unint64_t v17 = *(void *)(a2 + 32);
          *(void *)(a2 + 40) = 0;
          *(void *)(a2 + 48) = v17;
          if (v17 >= 0x10)
          {
            unint64_t v18 = 0;
            *(void *)&long long v19 = -1;
            *((void *)&v19 + 1) = -1;
            do
              *(_OWORD *)(*(void *)(a2 + 16) + 16 * v18++) = v19;
            while (v18 < *(void *)(a2 + 32) >> 4);
          }
          return a1;
        }
        if (v8 != 1)
        {
          if (!*(unsigned char *)(a2 + 12))
          {
            *(_DWORD *)(a2 + 16) = 0;
            return a1;
          }
          goto LABEL_39;
        }
LABEL_23:
        *(void *)(a2 + 32) = 0;
        ++*(_DWORD *)(a2 + 40);
        return a1;
      }
LABEL_22:
      *(_DWORD *)(a2 + 16) = 0;
      return a1;
    }
LABEL_38:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 885);
    _os_crash();
    __break(1u);
LABEL_39:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
    _os_crash();
    __break(1u);
    goto LABEL_40;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  uint64_t v9 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v9;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  unint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v10;
  uint64_t v11 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v11;
  ++*(_DWORD *)(a2 + 40);
  ++*(_DWORD *)(a1 + 40);
  *(void *)a2 = 0xFFFFFFFF00000000;
  *(_DWORD *)(a2 + 8) = -1;
  int v12 = *(unsigned __int8 *)(a2 + 12);
  if (v12 == 2)
  {
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = v10;
    if (v10 >= 0x10)
    {
      unint64_t v20 = 0;
      *(void *)&long long v21 = -1;
      *((void *)&v21 + 1) = -1;
      do
        *(_OWORD *)(*(void *)(a2 + 16) + 16 * v20++) = v21;
      while (v20 < *(void *)(a2 + 32) >> 4);
    }
    return a1;
  }
  if (v12 == 1) {
    goto LABEL_23;
  }
  if (!*(unsigned char *)(a2 + 12)) {
    goto LABEL_22;
  }
LABEL_40:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = a2[7];
  if (v4)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init((uint64_t *)a1, v4, a2[3]);
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::copy((_anonymous_namespace_ *)a1, a2);
  }
  return a1;
}

void re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  a1[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  a1[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v6 = v5 >> 4;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 9 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *a1 = v7;
    if (v4 >= 0x80)
    {
      uint64_t v8 = 0;
      *(void *)&long long v9 = -1;
      *((void *)&v9 + 1) = -1;
      do
        *(_OWORD *)(*a1 + 16 * v8++) = v9;
      while (v6 != v8);
      uint64_t v7 = *a1;
    }
    unint64_t v10 = (void *)(v7 + 16 * v6);
    a1[1] = (uint64_t)v10;
    uint64_t v11 = a1[2];
    if (v11) {
      bzero(v10, 8 * v11);
    }
  }
  else
  {
    uint64_t v11 = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  a1[5] = 0;
  a1[6] = 0;
  a1[3] = 0;
  a1[4] = v11;
}

_anonymous_namespace_ *re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::copy(_anonymous_namespace_ *result, uint64_t *a2)
{
  uint64_t v2 = result;
  *((void *)result + 5) = 0;
  *((void *)result + 6) = 0;
  unint64_t v3 = *((void *)result + 2);
  *((void *)result + 3) = 0;
  *((void *)result + 4) = v3;
  if (v3 >= 0x10)
  {
    unint64_t v4 = 0;
    *(void *)&long long v5 = -1;
    *((void *)&v5 + 1) = -1;
    do
      *(_OWORD *)(*(void *)result + 16 * v4++) = v5;
    while (v4 < *((void *)result + 2) >> 4);
  }
  v13[0] = a2;
  unint64_t v6 = a2[2];
  if (v6 >= 0x10)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *a2;
    unint64_t v9 = v6 >> 4;
    while (1)
    {
      unsigned __int16 v10 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v13[1] = (unsigned __int16)~v10;
      if (v10 != 0xFFFF) {
        break;
      }
      v7 += 16;
      if (!--v9) {
        return result;
      }
    }
    uint64_t v11 = __clz(__rbit64((unsigned __int16)~v10)) + v7;
    for (i = v11; i != -1; uint64_t v11 = i)
    {
      uint64_t v12 = *(void *)(*(void *)(v13[0] + 8) + 8 * v11);
      re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(v2, (unsigned int *)&v12, (unsigned int *)&v12 + 1);
      uint64_t result = (_anonymous_namespace_ *)re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v13);
    }
  }
  return result;
}

_DWORD *re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(_anonymous_namespace_ *a1, unsigned int *a2, unsigned int *a3)
{
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize((uint64_t *)a1, 1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9;
  unint64_t v9 = 0x94D049BB133111EBLL;
  unint64_t v10 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v11 = (0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) ^ ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) >> 31);
  unint64_t v12 = v7 >> 4;
  uint64_t v13 = *(void *)a1;
  unint64_t v14 = v11 % v12;
  while (1)
  {
    unint64_t v15 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v13 + 16 * v14)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v15 < 0x40) {
      break;
    }
    if (v14 + 1 == v12) {
      unint64_t v14 = 0;
    }
    else {
      ++v14;
    }
    if (v14 == v11 % v12)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, -1.79399301e-307, 4.74803907e-38, "assertion failure: '%s' (%s:line %i) Unexpected full hash-table", "blockIndex != h1(key) % blockCount()", "internalAdd", 656);
      _os_crash();
      __break(1u);
      break;
    }
  }
  uint64_t v16 = v13 + 16 * v14;
  BOOL v17 = *(unsigned __int8 *)(v16 + v15) == 255;
  *(unsigned char *)(v16 + v15) = v11 & 0x7F;
  unint64_t v18 = v15 + 16 * v14;
  *(void *)(*((void *)a1 + 1) + 8 * v18) = *a2 | ((unint64_t)*a3 << 32);
  uint64_t v19 = *((void *)a1 + 4) - v17;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v19;
  unint64_t v20 = (unsigned int *)(*((void *)a1 + 1) + 8 * v18);
  unsigned int v22 = *v20;
  uint64_t result = v20 + 1;
  unint64_t v23 = (((v22 ^ ((unint64_t)v22 >> 30)) * v8) ^ (((v22 ^ ((unint64_t)v22 >> 30)) * v8) >> 27)) * v9;
  *((void *)a1 + 5) ^= (v23 >> 31) ^ v23;
  return result;
}

{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  _DWORD *result;
  unsigned int v20;
  unint64_t v21;

  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize(a1, 1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v9 = (0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) ^ ((0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) >> 31);
  unint64_t v10 = v7 >> 4;
  unint64_t v11 = v9 % (v7 >> 4);
  unint64_t v12 = *(void *)a1;
  uint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
  if (v13 >= 0x40)
  {
    do
    {
      if (v11 + 1 == v10) {
        unint64_t v11 = 0;
      }
      else {
        ++v11;
      }
      uint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    }
    while (v13 > 0x3F);
  }
  unint64_t v14 = v12 + 16 * v11;
  unint64_t v15 = *(unsigned __int8 *)(v14 + v13) == 255;
  *(unsigned char *)(v14 + vre::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = v9 & 0x7F;
  uint64_t v16 = v13 + 16 * v11;
  *(void *)(*((void *)a1 + 1) + 8 * v16) = *a2 | ((unint64_t)*a3 << 32);
  BOOL v17 = *((void *)a1 + 4) - v15;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v17;
  unint64_t v18 = (unsigned int *)(*((void *)a1 + 1) + 8 * v16);
  unint64_t v20 = *v18;
  uint64_t result = v18 + 1;
  long long v21 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v20 ^ ((unint64_t)v20 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v20 ^ ((unint64_t)v20 >> 30))) >> 27));
  *((void *)a1 + 5) ^= (v21 >> 31) ^ v21;
  return result;
}

uint64_t **re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned int,unsigned int> const&>::HashBrownIterator(uint64_t **result, uint64_t *a2)
{
  *uint64_t result = a2;
  result[1] = 0;
  unint64_t v2 = a2[2];
  if (v2 < 0x10)
  {
LABEL_5:
    uint64_t v8 = -1;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = *a2;
    unint64_t v5 = v2 >> 4;
    while (1)
    {
      unsigned __int16 v6 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v4 + v3)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      unint64_t v7 = (unsigned __int16)~v6;
      result[1] = (uint64_t *)v7;
      if (v6 != 0xFFFF) {
        break;
      }
      v3 += 16;
      if (!--v5) {
        goto LABEL_5;
      }
    }
    uint64_t v8 = __clz(__rbit64(v7)) + v3;
  }
  result[2] = (uint64_t *)v8;
  return result;
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[3] + a2;
  unint64_t v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    unint64_t v5 = 3 * v2;
    unint64_t v6 = v5 << 6;
    uint64_t v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7) {
      unint64_t v4 = v7;
    }
    unint64_t v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::doResize(a1, v3);
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  memset(v22, 0, sizeof(v22));
  re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init((uint64_t *)v22, v4, a2);
  v20[0] = a1;
  unint64_t v5 = a1[2];
  if (v5 >= 0x10)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *a1;
    unint64_t v8 = v5 >> 4;
    while (1)
    {
      unsigned __int16 v9 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v20[1] = (unsigned __int16)~v9;
      if (v9 != 0xFFFF) {
        break;
      }
      v6 += 16;
      if (!--v8) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = __clz(__rbit64((unsigned __int16)~v9)) + v6;
    uint64_t v21 = v10;
    if (v10 != -1)
    {
      do
      {
        re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd((_anonymous_namespace_ *)v22, (unsigned int *)(*(void *)(v20[0] + 8) + 8 * v10), (unsigned int *)(*(void *)(v20[0] + 8) + 8 * v10 + 4));
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        uint64_t v10 = v21;
      }
      while (v21 != -1);
      unint64_t v5 = a1[2];
    }
  }
LABEL_9:
  uint64_t v12 = *((void *)&v22[3] + 1);
  *((void *)&v22[3] + 1) = a1[7];
  uint64_t result = *((void *)&v22[3] + 1);
  long long v13 = v22[0];
  long long v14 = v22[1];
  *(void *)&v22[1] = v5;
  uint64_t v15 = *a1;
  uint64_t v16 = a1[1];
  *(void *)&v22[0] = *a1;
  *((void *)&v22[0] + 1) = v16;
  long long v17 = v22[2];
  long long v18 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v22[3];
  a1[7] = v12;
  *(_OWORD *)((char *)&v22[2] + 8) = v18;
  long long v19 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v13;
  *((_OWORD *)a1 + 1) = v14;
  *((_OWORD *)a1 + 2) = v17;
  *(_OWORD *)((char *)&v22[1] + 8) = v19;
  if (result)
  {
    if (v16) {
      *((void *)&v22[0] + 1) = 0;
    }
    if (v15) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    }
  }
  return result;
}

void re::DynamicArray<re::GeomIndexMap>::clear(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (!v3)
  {
LABEL_10:
    ++*(_DWORD *)(a1 + 24);
    return;
  }
  uint64_t v4 = 80 * v3;
  unint64_t v5 = (_DWORD *)(*(void *)(a1 + 32) + 16);
  while (1)
  {
    int v6 = *((unsigned __int8 *)v5 - 4);
    if (v6 == 2)
    {
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)v5);
      goto LABEL_9;
    }
    if (v6 == 1)
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)v5);
      goto LABEL_9;
    }
    if (*((unsigned char *)v5 - 4)) {
      break;
    }
    *unint64_t v5 = 0;
LABEL_9:
    v5 += 20;
    v4 -= 80;
    if (!v4) {
      goto LABEL_10;
    }
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
}

void re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = 3 * v8;
      uint64_t v10 = *(void *)(a2 + 32) + 16 * v9;
      uint64_t v11 = a1[4] + 16 * v9;
      uint64_t v12 = 48 * v4 - 16 * v9;
      do
      {
        uint64_t v13 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v11, v10);
        v10 += 48;
        uint64_t v11 = v13 + 48;
        v12 -= 48;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      int v6 = (uint64_t *)(a1[4] + 48 * v4);
      uint64_t v7 = 48 * v5 - 48 * v4;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v6);
        v6 += 6;
        v7 -= 48;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = 48 * v2;
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v3);
      v3 += 6;
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 48 * v9;
        uint64_t v11 = v7;
        do
        {
          *((_DWORD *)v11 + 8) = 0;
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          *(void *)((char *)v11 + 36) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11, v8);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v8);
          v8 += 6;
          v11 += 6;
          v10 -= 48;
        }
        while (v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a3, v4);
      v4 += 48;
      a3 += 48;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomMesh>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomMesh>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomMesh>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomModel>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomModel>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomModel>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomInstance>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomInstance>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<re::GeomInstance>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 80 * (void)v5 - 12);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 80 * (void)v5, (const void *)(*(void *)(a2 + 32) + 80 * (void)v5), 80 * v4 - 80 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 80 * v4 - 12);
  }
  void v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::GeomSkeleton>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomSkeleton>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomSkeleton>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::GeomSkeleton>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomSkeleton>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 160 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = a1[4];
      uint64_t v12 = 160 * v9;
      uint64_t v13 = 160 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v11 + v12), (const StringID *)(v10 + v12));
        re::FixedArray<re::StringID>::FixedArray((unint64_t *)(v11 + v12 + 16), v10 + v12 + 16);
        re::FixedArray<unsigned int>::FixedArray((uint64_t *)(v11 + v12 + 40), v10 + v12 + 40);
        re::FixedArray<re::GenericSRT<float>>::FixedArray((void *)(v11 + v12 + 64), v10 + v12 + 64);
        re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(v11 + v12 + 88), v10 + v12 + 88);
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(v11 + v12 + 112, v10 + v12 + 112);
        v10 += 160;
        v13 -= 160;
        v11 += 160;
      }
      while (v12 != v13);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 160 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4];
      uint64_t v7 = 160 * v4;
      uint64_t v8 = 160 * v5;
      do
      {
        re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v6 + v7 + 112));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 88));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 64));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 40));
        re::FixedArray<re::StringID>::deinit((void *)(v6 + v7 + 16));
        re::StringID::destroyString((re::StringID *)(v6 + v7));
        v6 += 160;
        v8 -= 160;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::GeomSkeleton>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0xA0uLL))
        {
          uint64_t v2 = 160 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 8);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::GeomSkeleton>((uint64_t *)v5[4], (uint64_t *)(v5[4] + 160 * v5[2]), v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomSkeleton>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::GeomSkeleton>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      *(void *)a3 = *(void *)a3 & 0xFFFFFFFFFFFFFFFELL | *v5 & 1;
      *(void *)a3 = *v5 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
      *(void *)(a3 + 8) = v5[1];
      *uint64_t v5 = 0;
      v5[1] = (uint64_t)"";
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 16) = v5[2];
      float32x4_t v5[2] = 0;
      uint64_t v7 = *(void *)(a3 + 32);
      uint64_t v8 = v5[4];
      *(void *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v5[3];
      *(void *)(a3 + 32) = v8;
      v5[3] = 0;
      v5[4] = v7;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
      *(void *)(a3 + 40) = v5[5];
      v5[5] = 0;
      uint64_t v9 = *(void *)(a3 + 56);
      uint64_t v10 = v5[7];
      *(void *)(a3 + 48) = v5[6];
      *(void *)(a3 + 56) = v10;
      v5[6] = 0;
      v5[7] = v9;
      *(void *)(a3 + 64) = 0;
      *(void *)(a3 + 72) = 0;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 64) = v5[8];
      unsigned char v5[8] = 0;
      uint64_t v11 = *(void *)(a3 + 80);
      uint64_t v12 = v5[10];
      *(void *)(a3 + 72) = v5[9];
      *(void *)(a3 + 80) = v12;
      v5[9] = 0;
      v5[10] = v11;
      *(void *)(a3 + 88) = 0;
      *(void *)(a3 + 96) = 0;
      *(void *)(a3 + 104) = 0;
      *(void *)(a3 + 88) = v5[11];
      v5[11] = 0;
      uint64_t v13 = *(void *)(a3 + 104);
      uint64_t v14 = v5[13];
      *(void *)(a3 + 96) = v5[12];
      *(void *)(a3 + 104) = v14;
      v5[12] = 0;
      v5[13] = v13;
      *(_OWORD *)(a3 + 112) = 0u;
      uint64_t v15 = a3 + 112;
      *(_DWORD *)(v15 + 32) = 0;
      *(_OWORD *)(v15 + 16) = 0u;
      *(void *)(v15 + 36) = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v15, v5 + 14);
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v5 + 14);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 11);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 8);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 5);
      re::FixedArray<re::StringID>::deinit(v5 + 2);
      re::StringID::destroyString((re::StringID *)v5);
      v5 += 20;
      a3 = v15 + 48;
    }
    while (v5 != a2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::FixedArray<re::StringID>::operator=((unint64_t *)(a4 + v7 + 16), a2 + v7 + 16);
    re::FixedArray<unsigned int>::operator=((uint64_t *)(a4 + v7 + 40), a2 + v7 + 40);
    re::FixedArray<re::GenericSRT<float>>::operator=((void *)(a4 + v7 + 64), a2 + v7 + 64);
    re::FixedArray<re::Matrix4x4<float>>::operator=((uint64_t *)(a4 + v7 + 88), a2 + v7 + 88);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a4 + v7 + 112, a2 + v7 + 112);
    v7 += 160;
  }
  while (a2 + v7 != v6);
  return v6;
}

id *re::TextureCompiler::init(uint64_t a1, uint64_t a2, char a3)
{
  re::ObjCObject::operator=((id *)(a1 + 8), (id *)a2);
  uint64_t result = re::ObjCObject::operator=((id *)(a1 + 16), (id *)(a2 + 8));
  __int16 v7 = *(_WORD *)(a2 + 16);
  *(unsigned char *)(a1 + 26) = *(unsigned char *)(a2 + 18);
  *(_WORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v7;
  int v8 = *(unsigned __int8 *)(a2 + 19);
  if (*(unsigned char *)(a1 + 27)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v8 == 0;
  }
  if (!v9)
  {
    if (*(unsigned char *)(a1 + 27)) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10)
    {
      *(unsigned char *)(a1 + 27) = 0;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 27) && *(unsigned char *)(a2 + 19)) {
        *(unsigned char *)(a1 + 27) = 1;
      }
      *(unsigned char *)(a1 + 28) = *(unsigned char *)(a2 + 20);
    }
  }
  *(void *)(a1 + 32) = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 40) = a3;
  return result;
}

re::DynamicString *re::TextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::TextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::TextureAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::TextureCompiler::assetIntrospectionType(re::TextureCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[262];
}

void *re::TextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  do
    uint64_t result = re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::TextureCompiler::getSupportedExtensions(void)const::supportedExtensions[v3++]);
  while (v3 != 12);
  return result;
}

void re::TextureCompiler::compile(id *this@<X0>, char *__s@<X1>, char *a3@<X2>, uint64_t a4@<X8>, uint8x8_t a5@<D0>, int16x8_t a6@<Q1>)
{
  v69[2] = *MEMORY[0x263EF8340];
  if (!__s)
  {
    uint64_t v13 = *re::pipelineLogObjects((re *)this);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
    }
    long long v15 = *(_OWORD *)buf;
    uint64_t v16 = v64;
    uint64_t v17 = v65;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 100;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v15;
    *(void *)(a4 + 40) = v16;
    *(void *)(a4 + 48) = v17;
    return;
  }
  v69[0] = 0;
  *(void *)((char *)v69 + 5) = 0;
  if (a3)
  {
    a5.i32[0] = *(_DWORD *)a3;
    a6 = (int16x8_t)vmovl_u8(a5);
    char v10 = a3[4];
    __int16 v38 = *(_WORD *)(a3 + 5);
    char v39 = a3[7];
    unsigned int v11 = *((_DWORD *)a3 + 2);
    v69[0] = *(void *)(a3 + 12);
    *(void *)((char *)v69 + 5) = *(void *)(a3 + 17);
    __int16 v36 = *(_WORD *)(a3 + 25);
    char v37 = a3[27];
    int v12 = *((_DWORD *)a3 + 7);
  }
  else
  {
    a6.i64[0] = 0x1000000010001;
    int v12 = 0;
    char v10 = 1;
    unsigned int v11 = 1;
  }
  unsigned __int32 v34 = a6.i32[0];
  *(_DWORD *)long long v35 = vmovn_s16(a6).u32[0];
  v35[4] = v10;
  *(_WORD *)&v35[5] = v38;
  v35[7] = v39;
  *(_DWORD *)&v35[8] = v11;
  *(void *)&unsigned char v35[12] = v69[0];
  *(void *)&v35[17] = *(void *)((char *)v69 + 5);
  *(_WORD *)&v35[25] = v36;
  v35[27] = v37;
  *(_DWORD *)&v35[28] = v12;
  long long v18 = strrchr(__s, 47);
  if (!v18)
  {
    buf[0] = 0;
    *(void *)&uint8_t buf[8] = 0;
    unsigned int v67 = 0;
    id v68 = 0;
    goto LABEL_12;
  }
  long long v19 = v18;
  unint64_t v20 = strcasestr(v18, "cubemap");
  uint64_t v21 = strcasestr(v19, "lut");
  buf[0] = 0;
  *(void *)&uint8_t buf[8] = 0;
  unsigned int v67 = 0;
  id v68 = 0;
  if (v20)
  {
    *(_OWORD *)uint64_t v54 = *(_OWORD *)v35;
    long long v55 = *(_OWORD *)&v35[16];
    re::loadTextureFileAndConvertToCubeMap(this + 1, (uint64_t)__s, (uint64_t)v54, (uint64_t)v56);
    goto LABEL_26;
  }
  if (!v21)
  {
LABEL_12:
    re::createTextureDescriptorFromCompileOptions(this + 1, (uint64_t)v35, v54);
    long long v45 = 0uLL;
    *(_DWORD *)unint64_t v46 = 1;
    LODWORD(v47) = 0;
    BYTE4(v47) = 0;
    *(void *)&v46[12] = 0;
    v46[20] = 0;
    int v48 = 0;
    int v50 = 6;
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    id v51 = 0;
    if (v11 >= 2)
    {
      DWORD2(v45) = 1;
      *(_DWORD *)unint64_t v46 = v11;
    }
    int v22 = BYTE2(v34) == 0;
    if (!(_BYTE)v34) {
      int v22 = 2;
    }
    *(_DWORD *)&v46[4] = v22;
    *(_DWORD *)&v46[8] = *(_DWORD *)&v35[12];
    DWORD1(v45) = 2;
    char v49 = *((unsigned char *)this + 40);
    id v44 = v54[0];
    re::loadTextureFromFile(this + 1, (uint64_t)__s, &v44, (re::internal *)&v45, (uint64_t)v56);
    buf[0] = v56[0];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&buf[8], (uint64_t)&v57);
    if (&v68 != &v62)
    {
      id v23 = v62;
      id v62 = 0;
      id v24 = v68;
      id v68 = v23;
    }
    if (v61 != -1) {
      ((void (*)(uint64_t **, long long *))*(&off_26E6DF328 + v61))(&v40, &v57);
    }
    unsigned int v61 = -1;
    if (v44)
    {

      id v44 = 0;
    }

    uint64_t v25 = (_anonymous_namespace_ *)v54[0];
    if (v54[0]) {

    }
    goto LABEL_28;
  }
  re::loadTextureFileAndConvertTo3DTexture(this + 1, (const re::mtl::Device *)__s, (uint64_t)v56);
LABEL_26:
  buf[0] = v56[0];
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&buf[8], (uint64_t)&v57);
  id v26 = v62;
  id v62 = 0;
  id v27 = v68;
  id v68 = v26;

  if (v61 != -1) {
    uint64_t v25 = (_anonymous_namespace_ *)((uint64_t (*)(long long *, long long *))*(&off_26E6DF328 + v61))(&v45, &v57);
  }
  if (v67)
  {
    if (v67 != 1)
    {
      int v32 = (re::TextureCompiler *)std::__throw_bad_variant_access[abi:nn180100]();
      re::TextureCompiler::deleteAsset(v32, v33);
      return;
    }
    if (!*((void *)&v65 + 1)) {
      goto LABEL_33;
    }
  }
LABEL_28:
  if (*(void *)&buf[8])
  {
    long long v45 = *(_OWORD *)v35;
    *(_OWORD *)unint64_t v46 = *(_OWORD *)&v35[16];
    uint64_t TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)buf, 6, &v45);
    int v29 = 1;
    v56[0] = 1;
    *(void *)&long long v57 = TextureAsset;
  }
  else
  {
LABEL_33:
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    re::DynamicString::setCapacity(&v40, 0);
    re::DynamicString::assignf((re::DynamicString *)&v40, "failed to load texture %s", __s);
    *(void *)&long long v45 = 100;
    *((void *)&v45 + 1) = re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)v46, (const re::DynamicString *)&v40);
    v56[0] = 0;
    long long v57 = v45;
    long long v58 = *(_OWORD *)v46;
    uint64_t v59 = *(void *)&v46[16];
    uint64_t v60 = v47;
    if (v40 && (v41 & 1) != 0) {
      (*(void (**)(void))(*v40 + 40))();
    }
    int v29 = 0;
  }

  if (v67 != -1)
  {
    ((void (*)(uint64_t **, uint8_t *))*(&off_26E6DF328 + v67))(&v40, &buf[8]);
    int v29 = v56[0];
  }
  if (v29)
  {
    uint64_t v30 = v57;
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v30;
  }
  else
  {
    *(_OWORD *)buf = v57;
    re::DynamicString::DynamicString((re::DynamicString *)&v64, (const re::DynamicString *)&v58);
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
    uint64_t v31 = v66;
    *(void *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v64;
    *(void *)(a4 + 48) = v31;
    *(_OWORD *)(a4 + 32) = v65;
    if ((void)v58)
    {
      if (BYTE8(v58)) {
        (*(void (**)(void))(*(void *)v58 + 40))();
      }
    }
  }
}

re *re::TextureCompiler::deleteAsset(re::TextureCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::TextureAsset>((re *)"deleteAsset", 127, a2);
}

re *re::TextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::TextureCompiler::~TextureCompiler(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x237DBCBD0);
}

re::DynamicString *re::BVHCompiler::getCurrentCompiledAssetInfo@<X0>(re::BVHCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::TimelineAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TimelineAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::BVHCompiler::assetIntrospectionType(re::BVHCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TimelineAsset>(void)::info = re::introspect_TimelineAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[372];
}

uint64_t re::BVHCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::BVHCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::BVHCompiler::compile@<X0>(re::FileStreamReader *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  re::FileStreamReader::open(a1, (uint64_t)v73);
  if (v73[0])
  {
    __int16 v7 = (_anonymous_namespace_ *)re::parseAnimationBVH((re *)&v74, (uint64_t)v61);
    if (v61[0])
    {
      float v50 = v62;
      re::FixedArray<re::StringID>::FixedArray(v51, (uint64_t)&v63);
      re::FixedArray<unsigned int>::FixedArray(&v52, (uint64_t)&v66);
      re::FixedArray<re::GenericSRT<float>>::FixedArray(&v55, (uint64_t)&v69);
      re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::FixedArray(&v58, (uint64_t)v72);
      float v8 = v50;
      unint64_t v9 = v59;
      char v10 = (_anonymous_namespace_ *)re::Timeline::Timeline((uint64_t)&v36, 34);
      __int16 v41 = 256;
      unint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v45 = 0;
      __int16 v36 = &unk_26E6C1190;
      __int16 v48 = 257;
      char v49 = 1;
      float v42 = v8;
      int v43 = 0;
      float v44 = v50 * (float)(v9 - 1);
      *(void *)&unsigned long long v32 = 0;
      *((void *)&v32 + 1) = "";
      memset(v33, 0, sizeof(v33));
      int v34 = 0;
      uint64_t v35 = 0x7FFFFFFFLL;
      *(void *)&long long v81 = 0x190FB25473155C2;
      *((void *)&v81 + 1) = "BVHSkeleton";
      *(void *)unint64_t v76 = v51[2];
      *(void *)&v76[8] = v51[1];
      v28[0] = v54;
      v28[1] = v53;
      v27[0] = v57;
      v27[1] = v56;
      if (!v29[0] && (void)v30)
      {
        if (BYTE8(v30)) {
          (*(void (**)(void))(*(void *)v30 + 40))();
        }
        long long v30 = 0u;
        long long v31 = 0u;
      }
      re::StringID::destroyString((re::StringID *)&v81);
      int v12 = (re *)re::make::shared::object<re::SkeletalPoseJointDefinition,re::FixedArray<re::StringID>,re::Skeleton>((re *)v51, (const StringID *)&v32, v27);
      if (v46)
      {
        uint64_t v13 = v47;
        uint64_t v14 = 88 * v46;
        do
        {
          re::SkeletalPose::init(v13, v27);
          v13 += 11;
          v14 -= 88;
        }
        while (v14);
      }
      if (v9)
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        uint64_t v17 = 2;
        do
        {
          unint64_t v18 = v59;
          if (v59 <= v16)
          {
            v28[0] = 0;
            long long v85 = 0u;
            long long v84 = 0u;
            long long v83 = 0u;
            long long v82 = 0u;
            long long v81 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unint64_t v76 = 136315906;
            *(void *)&v76[4] = "operator[]";
            *(_WORD *)&v76[12] = 1024;
            *(_DWORD *)&v76[14] = 468;
            __int16 v77 = 2048;
            unint64_t v78 = v16;
            __int16 v79 = 2048;
            unint64_t v80 = v18;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_50:
            v28[0] = 0;
            long long v85 = 0u;
            long long v84 = 0u;
            long long v83 = 0u;
            long long v82 = 0u;
            long long v81 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unint64_t v76 = 136315906;
            *(void *)&v76[4] = "operator[]";
            *(_WORD *)&v76[12] = 1024;
            *(_DWORD *)&v76[14] = 468;
            __int16 v77 = 2048;
            unint64_t v78 = v16;
            __int16 v79 = 2048;
            unint64_t v80 = v18;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          unint64_t v18 = v46;
          if (v46 <= v16) {
            goto LABEL_50;
          }
          int v12 = (re *)re::FixedArray<float>::operator=(&v47[v17], (uint64_t *)(v60 + v15));
          ++v16;
          v15 += 24;
          v17 += 11;
        }
        while (v9 != v16);
      }
      LODWORD(v83) = 0;
      long long v82 = 0u;
      long long v81 = 0u;
      *(void *)((char *)&v83 + 4) = 0x7FFFFFFFLL;
      long long v19 = re::globalAllocators(v12);
      uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19[2] + 32))(v19[2], 120, 8);
      re::SampledAnimation<re::SkeletalPose>::SampledAnimation(v20, &v36);
      *(void *)uint64_t v21 = &unk_26E6C1190;
      __int16 v22 = v48;
      *(unsigned char *)(v21 + 114) = v49;
      *(_WORD *)(v21 + 112) = v22;
      TimelineAsset = re::AssetHelper::makeTimelineAsset((re *)v21, (uint64_t)&v81);
      *(unsigned char *)a2 = 1;
      *(void *)(a2 + 8) = TimelineAsset;
      re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v81);
      if (v27[0]) {

      }
      re::Skeleton::~Skeleton((re::Skeleton *)&v32);
      __int16 v36 = &unk_26E6C0FD0;
      re::FixedArray<re::SkeletalPose>::deinit(&v45);
      __int16 v36 = &unk_26E6BF1F0;
      if ((void)v39)
      {
        if (BYTE8(v39)) {
          (*(void (**)(void))(*(void *)v39 + 40))();
        }
        long long v39 = 0u;
        long long v40 = 0u;
      }
      re::StringID::destroyString((re::StringID *)&v38);
      re::FixedArray<re::FixedArray<float>>::deinit(&v58);
      if (v55)
      {
        if (v56)
        {
          (*(void (**)(void))(*(void *)v55 + 40))();
          uint64_t v56 = 0;
          uint64_t v57 = 0;
        }
        uint64_t v55 = 0;
      }
      if (v52)
      {
        if (v53)
        {
          (*(void (**)(void))(*(void *)v52 + 40))();
          uint64_t v53 = 0;
          uint64_t v54 = 0;
        }
        uint64_t v52 = 0;
      }
      re::FixedArray<re::StringID>::deinit(v51);
    }
    else
    {
      re::DynamicString::operator+((re::DynamicString *)&v36, (const char *)a1, (re::DynamicString *)&v32);
      unsigned long long v25 = v32;
      unsigned long long v32 = 0uLL;
      long long v26 = v33[0];
      v33[0] = 0uLL;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 100;
      *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v25;
      *(_OWORD *)(a2 + 40) = v26;
      if (v36 && (v37 & 1) != 0) {
        (*(void (**)(void))(*(void *)v36 + 40))();
      }
    }
    if (v61[0])
    {
      re::FixedArray<re::FixedArray<float>>::deinit(v72);
      if (v69)
      {
        if (v70)
        {
          (*(void (**)(void))(*(void *)v69 + 40))();
          uint64_t v70 = 0;
          uint64_t v71 = 0;
        }
        uint64_t v69 = 0;
      }
      if (v66)
      {
        if (v67)
        {
          (*(void (**)(void))(*(void *)v66 + 40))();
          uint64_t v67 = 0;
          uint64_t v68 = 0;
        }
        uint64_t v66 = 0;
      }
      re::FixedArray<re::StringID>::deinit(&v63);
    }
    else if (v64 && (v65 & 1) != 0)
    {
      (*(void (**)(void))(*(void *)v64 + 40))();
    }
  }
  else
  {
    unsigned long long v32 = v74;
    re::DynamicString::DynamicString((re::DynamicString *)v33, (const re::DynamicString *)&v75);
    *(unsigned char *)a2 = 0;
    *(_OWORD *)(a2 + 8) = v32;
    *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)&v33[0];
    *(void *)(a2 + 48) = *((void *)&v33[1] + 1);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v33 + 8);
  }
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v73);
}

re *re::BVHCompiler::deleteAsset(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::BVHCompiler::~BVHCompiler(re::BVHCompiler *this)
{
}

uint64_t *re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::FixedArray<unsigned int>>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::copy((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)(a2 + 8))
  {
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = *(void **)(a1 + 16);
    return std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,0>(v3, v3 + 24 * v2, v4);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::SampledAnimation<re::SkeletalPose>::SampledAnimation(uint64_t a1, void *a2)
{
  re::Animation<re::SkeletalPose>::Animation(a1, (uint64_t)a2);
  *uint64_t v3 = &unk_26E6C0FD0;
  uint64_t v4 = *(void *)((char *)a2 + 73);
  v3[10] = a2[10];
  v3[11] = 0;
  *(void *)((char *)v3 + 73) = v4;
  v3[12] = 0;
  v3[13] = 0;
  uint64_t v5 = a2[12];
  v3[11] = a2[11];
  v3[12] = v5;
  a2[11] = 0;
  a2[12] = 0;
  uint64_t v6 = v3[13];
  v3[13] = a2[13];
  a2[13] = v6;
}

double re::Animation<re::SkeletalPose>::Animation(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6BF1F0;
  uint64_t v2 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a2 + 32) = "";
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a2 + 64) = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  *(void *)(a2 + 48) = v8;
  *(void *)(a2 + 56) = v7;
  *(void *)a1 = &unk_26E6BFA70;
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  return result;
}

re::DynamicString *re::TextureDefinitionCompiler::getCurrentCompiledAssetInfo@<X0>(re::TextureDefinitionCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::TextureAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::TextureDefinitionCompiler::assetIntrospectionType(re::TextureDefinitionCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[262];
}

void *re::TextureDefinitionCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::TextureDefinitionCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re::DynamicString *re::TextureDefinitionCompiler::compile@<X0>(id *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  if (a2)
  {
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
    }
    uint64_t v9 = re::introspect<re::TextureAsset>(void)::info;
    memset(v49, 0, sizeof(v49));
    re::FileStreamReader::open((re::FileStreamReader *)a2, (uint64_t)v46);
    if (v46[0])
    {
      v49[0] = a3;
      unsigned int v11 = re::globalAllocators(v10);
      uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11[2] + 32))(v11[2], 424, 8);
      *(_OWORD *)uint64_t v12 = 0u;
      *(_OWORD *)(v12 + 16) = 0u;
      *(_OWORD *)(v12 + 32) = 0u;
      *(_OWORD *)(v12 + 48) = 0u;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      *(_OWORD *)(v12 + 112) = 0u;
      *(_OWORD *)(v12 + 128) = 0u;
      *(_OWORD *)(v12 + 144) = 0u;
      *(_OWORD *)(v12 + 160) = 0u;
      *(_OWORD *)(v12 + 176) = 0u;
      *(_OWORD *)(v12 + 192) = 0u;
      *(_OWORD *)(v12 + 208) = 0u;
      *(_OWORD *)(v12 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
      *(_OWORD *)(v12 + 240) = 0u;
      *(_OWORD *)(v12 + 256) = 0u;
      *(_OWORD *)(v12 + 272) = 0u;
      *(_OWORD *)(v12 + 288) = 0u;
      *(_OWORD *)(v12 + 304) = 0u;
      *(_OWORD *)(v12 + 320) = 0u;
      *(_OWORD *)(v12 + 336) = 0u;
      *(_OWORD *)(v12 + 352) = 0u;
      *(_OWORD *)(v12 + 368) = 0u;
      *(_OWORD *)(v12 + 384) = 0u;
      *(_OWORD *)(v12 + 400) = 0u;
      *(void *)(v12 + 416) = 0;
      re::TextureAsset::TextureAsset((re::TextureAsset *)v12);
      if (v42[0])
      {
        uint64_t v13 = 5;
        if (!*(unsigned char *)(v12 + 10)) {
          uint64_t v13 = 0;
        }
        uint64_t v14 = v13 | *(unsigned __int8 *)(v12 + 11);
        id v15 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
        objc_msgSend(v15, sel_setWidth_, *(int *)(v12 + 360));
        objc_msgSend(v15, sel_setHeight_, *(int *)(v12 + 364));
        objc_msgSend(v15, sel_setDepth_, *(int *)(v12 + 368));
        objc_msgSend(v15, sel_setPixelFormat_, *(int *)(v12 + 376));
        objc_msgSend(v15, sel_setTextureType_, *(int *)(v12 + 380));
        objc_msgSend(v15, sel_setStorageMode_, 0);
        if (*(unsigned char *)(v12 + 8))
        {
          int v16 = *(_DWORD *)(v12 + 360);
          if (v16 <= *(_DWORD *)(v12 + 364)) {
            int v16 = *(_DWORD *)(v12 + 364);
          }
          unint64_t v17 = (unint64_t)(floor(log2((double)v16)) + 1.0);
        }
        else
        {
          unint64_t v17 = 1;
        }
        objc_msgSend(v15, sel_setMipmapLevelCount_, v17);
        long long v26 = (re *)objc_msgSend(v15, sel_setSampleCount_, 1);
        if (*(unsigned char *)(v12 + 10)) {
          objc_msgSend(v15, sel_setProtectionOptions_, re::protectionOptions(v26));
        }
        objc_msgSend(v15, sel_setUsage_, v14);
        re::mtl::Device::makeTexture(v15, this + 1, &v41);
        if (v41)
        {
          buf[0] = 0;
          *(void *)&uint8_t buf[8] = v41;
          unsigned int v35 = 0;
          id v36 = 0;
          *(unsigned char *)(v12 + 152) = 0;
          std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(v12 + 160, (uint64_t)&buf[8]);
          if ((uint8_t *)(v12 + 152) != buf)
          {
            id v27 = v36;
            id v36 = 0;
            uint64_t v28 = *(void **)(v12 + 248);
            *(void *)(v12 + 248) = v27;
          }
          if (v35 != -1) {
            ((void (*)(uint64_t **, uint8_t *))*(&off_26E6DF408 + v35))(&v37, &buf[8]);
          }
          *(unsigned char *)a4 = 1;
          *(void *)(a4 + 8) = v12;
        }
        else
        {
          uint64_t v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          re::DynamicString::setCapacity(&v37, 0);
          re::DynamicString::assignf((re::DynamicString *)&v37, "failed to load texture %s", a2);
          *(void *)buf = 100;
          *(void *)&uint8_t buf[8] = re::AssetErrorCategory(void)::instance;
          re::DynamicString::DynamicString((re::DynamicString *)v33, (const re::DynamicString *)&v37);
          long long v29 = *(_OWORD *)v33;
          *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
          uint64_t v30 = *(void *)&v33[16];
          uint64_t v31 = v34;
          *(unsigned char *)a4 = 0;
          *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v29;
          *(void *)(a4 + 40) = v30;
          *(void *)(a4 + 48) = v31;
          if (v37 && (v38 & 1) != 0) {
            (*(void (**)(void))(*v37 + 40))();
          }
        }
        if (v41) {

        }
        if (v15) {
      }
        }
      else
      {
        if (v44) {
          id v23 = *(unsigned char **)&v45[7];
        }
        else {
          id v23 = v45;
        }
        re::DynamicString::format((re::DynamicString *)"Failed to read JSON source asset \"%s\": %s", (re::DynamicString *)buf, a2, v23);
        long long v24 = *(_OWORD *)buf;
        long long v25 = *(_OWORD *)v33;
        *(unsigned char *)a4 = 0;
        *(void *)(a4 + 8) = 100;
        *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v24;
        *(_OWORD *)(a4 + 40) = v25;
      }
      if (!v42[0] && v43 && (v44 & 1) != 0) {
        (*(void (**)(void))(*(void *)v43 + 40))();
      }
    }
    else
    {
      *(_OWORD *)buf = v47;
      re::DynamicString::DynamicString((re::DynamicString *)v33, (const re::DynamicString *)&v48);
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
      *(void *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)v33;
      *(void *)(a4 + 48) = v34;
      *(_OWORD *)(a4 + 32) = *(_OWORD *)&v33[8];
    }
    return (re::DynamicString *)re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v46);
  }
  else
  {
    unint64_t v18 = *re::pipelineLogObjects((re *)this);
    BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
    }
    long long v21 = *(_OWORD *)buf;
    long long v22 = *(_OWORD *)v33;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 100;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v21;
    *(_OWORD *)(a4 + 40) = v22;
  }
  return result;
}

re *re::TextureDefinitionCompiler::deleteAsset(re::TextureDefinitionCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::TextureAsset>((re *)"deleteAsset", 144, a2);
}

re *re::TextureDefinitionCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::TextureDefinitionCompiler::~TextureDefinitionCompiler(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x237DBCBD0);
}

re::DynamicString *re::KTXTextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::KTXTextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::TextureAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::KTXTextureCompiler::assetIntrospectionType(re::KTXTextureCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[262];
}

void *re::KTXTextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::KTXTextureCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

void re::KTXTextureCompiler::compile(re::KTXTextureCompiler *this@<X0>, const char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>, int16x8_t a5@<Q0>)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v92 = 0;
    char v93 = 0;
    if (a3)
    {
      a5.i32[0] = *(_DWORD *)a3;
      int16x8_t v41 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a5.i8);
      char v9 = a3[4];
      __int16 v50 = *(_WORD *)(a3 + 5);
      char v51 = a3[7];
      unsigned int v11 = *((_DWORD *)a3 + 2);
      unsigned int v10 = *((_DWORD *)a3 + 3);
      uint64_t v92 = *((void *)a3 + 2);
      char v93 = a3[24];
      char v49 = a3[27];
      __int16 v48 = *(_WORD *)(a3 + 25);
      int v12 = *((_DWORD *)a3 + 7);
    }
    else
    {
      unsigned int v10 = 0;
      a5.i64[0] = 0x1000000010001;
      int16x8_t v41 = a5;
      int v12 = 0;
      char v9 = 1;
      unsigned int v11 = 1;
    }
    uint64_t v42 = v92;
    LOBYTE(v43) = v93;
    *(_WORD *)((char *)&v43 + 1) = v48;
    HIBYTE(v43) = v49;
    char v18 = *((unsigned char *)this + 40);
    re::Data::makeDataWithContentsOfFile((uint64_t)a2, 0, (uint64_t)v90);
    if (!v90[0])
    {
      *((void *)&v94 + 1) = 0;
      uint64_t v95 = 0;
      *(void *)&long long v96 = 0;
      re::DynamicString::setCapacity(&v94, 0);
      re::DynamicString::assignf((re::DynamicString *)&v94, "failed to load texture source %s", a2);
      *(void *)buf = 100;
      *(void *)&uint8_t buf[8] = re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v85, (const re::DynamicString *)&v94);
      uint64_t TextureAsset = *((void *)&v86 + 1);
      long long v29 = v85;
      LOBYTE(v26) = v86;
      long long v44 = *(_OWORD *)buf;
      uint64_t v47 = v87;
      uint64_t v45 = v85;
      long long v46 = v86;
      if (void)v94 && (BYTE8(v94)) {
        (*(void (**)(void, __n128 *))(*(void *)v94 + 40))(v94, v95);
      }

LABEL_54:
      *(_OWORD *)buf = v44;
      re::DynamicString::DynamicString((re::DynamicString *)&v85, (const re::DynamicString *)&v45);
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
      uint64_t v36 = v87;
      *(void *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v85;
      *(void *)(a4 + 48) = v36;
      *(_OWORD *)(a4 + 32) = v86;
      if (v29)
      {
        if (v26) {
          (*(void (**)(__n128 *, uint64_t))(v29->n128_u64[0] + 40))(v29, TextureAsset);
        }
      }
      return;
    }
    char v39 = v9;
    uint64_t v40 = a4;
    v20.i32[0] = v41.u16[1];
    v20.i32[1] = v41.u16[0];
    int32x2_t v21 = vceqz_s32((int32x2_t)vand_s8(v20, (int8x8_t)0xFF000000FFLL));
    if (v21.i8[4]) {
      int v22 = 2;
    }
    else {
      int v22 = v21.i8[0] & 1;
    }
    if (v11 <= 1) {
      int v23 = 1;
    }
    else {
      int v23 = v11;
    }
    long long v24 = (__n128 *)[v91 bytes];
    uint64_t v68 = 0x200000000;
    BOOL v69 = v11 > 1;
    int v70 = 0;
    int v71 = v23;
    int v72 = v22;
    unsigned int v25 = v10;
    unsigned int v73 = v10;
    uint64_t v74 = 0;
    char v75 = 0;
    int v76 = 0;
    char v77 = 0;
    int v78 = 0;
    char v79 = v18;
    int v80 = 6;
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    id v81 = 0;

    if (v88)
    {
      if (v88 != 1)
      {
        char v37 = (re::KTXTextureCompiler *)std::__throw_bad_variant_access[abi:nn180100]();
        re::KTXTextureCompiler::deleteAsset(v37, v38);
        return;
      }
      a4 = v40;
      if (!*((void *)&v86 + 1) || !*(void *)&buf[8]) {
        goto LABEL_19;
      }
    }
    else
    {
      a4 = v40;
      if (!*(void *)&buf[8])
      {
LABEL_19:
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        uint64_t v62 = 0;
        re::DynamicString::setCapacity(&v59, 0);
        re::DynamicString::assignf((re::DynamicString *)&v59, "failed to load texture %s", a2);
        *(void *)&long long v94 = 100;
        *((void *)&v94 + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v95, (const re::DynamicString *)&v59);
        uint64_t TextureAsset = *((void *)&v96 + 1);
        long long v29 = v95;
        LOBYTE(v26) = v96;
        long long v44 = v94;
        uint64_t v47 = v97;
        uint64_t v45 = v95;
        long long v46 = v96;
        if (v59 && (v60 & 1) != 0) {
          (*(void (**)(void))(*v59 + 40))();
        }
        char v30 = 1;
        goto LABEL_51;
      }
    }
    LODWORD(v64) = vmovn_s16(v41).u32[0];
    BYTE4(v64) = v39;
    *(_WORD *)((char *)&v64 + 5) = v50;
    BYTE7(v64) = v51;
    *((void *)&v64 + 1) = __PAIR64__(v25, v11);
    uint64_t v65 = v42;
    int v66 = v43;
    int v67 = v12;
    uint64_t TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)buf, 6, &v64);
    uint64_t v63 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v58 = 0;
    unint64_t v59 = 0;
    LODWORD(v62) = 0;
    v55[1] = 0;
    uint64_t v56 = 0;
    v55[0] = 0;
    int v57 = 0;
    long long v29 = (__n128 *)[v91 bytes];
    if (v52[0])
    {
      if (v61)
      {
        uint64_t v31 = (*(void *)(v63 + 8) & 1) != 0 ? *(const char **)(v63 + 16) : (const char *)(v63 + 9);
        if (!strcmp(v31, "ToolVersion") && v56)
        {
          unint64_t v32 = *(void *)(v58 + 8);
          unint64_t v33 = v32 >> 1;
          if ((v32 & 1) == 0) {
            unint64_t v33 = v32 >> 1;
          }
          if (v33 < 3)
          {
            if (v32) {
              unsigned int v35 = *(const char **)(v58 + 16);
            }
            else {
              unsigned int v35 = (const char *)(v58 + 9);
            }
            __int16 v34 = atoi(v35);
          }
          else
          {
            __int16 v34 = 0;
          }
          if (!*(unsigned char *)(TextureAsset + 126)) {
            *(unsigned char *)(TextureAsset + 126) = 1;
          }
          *(_WORD *)(TextureAsset + 128) = v34;
        }
      }
      *(void *)&long long v44 = TextureAsset;
    }
    else
    {
      *(void *)&long long v44 = TextureAsset;
      if (v53 && (v54 & 1) != 0) {
        (*(void (**)(void))(*(void *)v53 + 40))();
      }
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)v55);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v59);
    char v30 = 0;
LABEL_51:

    if (v88 != -1) {
      ((void (*)(long long *, uint8_t *))*(&off_26E6DF480 + v88))(&v94, &buf[8]);
    }

    if ((v30 & 1) == 0)
    {
      *(unsigned char *)a4 = 1;
      *(void *)(a4 + 8) = v44;
      return;
    }
    goto LABEL_54;
  }
  uint64_t v13 = *re::pipelineLogObjects(this);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
  }
  long long v15 = *(_OWORD *)buf;
  int v16 = v85;
  uint64_t v17 = v86;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 100;
  *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v15;
  *(void *)(a4 + 40) = v16;
  *(void *)(a4 + 48) = v17;
}

re *re::KTXTextureCompiler::deleteAsset(re::KTXTextureCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::TextureAsset>((re *)"deleteAsset", 134, a2);
}

re *re::KTXTextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::KTXTextureCompiler::~KTXTextureCompiler(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x237DBCBD0);
}

re::DynamicString *re::RenderGraphCompiler::getCurrentCompiledAssetInfo@<X0>(re::RenderGraphCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::RenderGraphAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::RenderGraphAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

void *re::RenderGraphCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::RenderGraphCompiler::getSupportedExtensions(void)const::supportedExtensions);
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, off_268774010);
}

char **re::RenderGraphCompiler::assetIntrospectionType(re::RenderGraphCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::RenderGraphAsset>(void)::info = re::introspect_RenderGraphAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[374];
}

uint64_t re::RenderGraphCompiler::compile@<X0>(re::RenderGraphCompiler *this@<X0>, re::FileStreamReader *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = re::globalAllocators(this);
  char v9 = (void (***)(void))(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 872, 8);
  bzero(v9, 0x368uLL);
  re::RenderGraphAsset::RenderGraphAsset((re::RenderGraphAsset *)v9);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB80, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7FB80))
  {
    _MergedGlobals_133 = re::introspect_RenderGraphFile(0);
    __cxa_guard_release(&qword_26AF7FB80);
  }
  uint64_t v10 = _MergedGlobals_133;
  v39[1] = 0;
  v39[2] = 0;
  v39[0] = a3;
  re::FileStreamReader::open(a2, (uint64_t)v36);
  if (!v36[0])
  {
    long long v32 = v37;
    re::DynamicString::DynamicString((re::DynamicString *)&v33, (const re::DynamicString *)&v38);
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v32;
    *(void *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v33;
    *(void *)(a4 + 48) = v35;
    *(_OWORD *)(a4 + 32) = v34;
    return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v36);
  }
  if ((_BYTE)v32)
  {
    uint64_t v13 = re::RenderGraphFile::calculateValidity((re::RenderGraphFile *)(v9 + 1), (uint64_t)v29);
    if (v29[0])
    {
      re::RenderGraphFile::initRuntimeNodeSettings((re::RenderGraphFile *)(v9 + 1), (uint64_t)&v25);
      BOOL v14 = (re *)re::Result<re::Unit,re::DynamicString>::operator=((uint64_t)v29, (uint64_t)&v25);
      if (!(_BYTE)v25)
      {
        BOOL v14 = (re *)*((void *)&v25 + 1);
        if (*((void *)&v25 + 1))
        {
          if (v26) {
            BOOL v14 = (re *)(*(uint64_t (**)(void))(**((void **)&v25 + 1) + 40))();
          }
        }
      }
      if (v29[0])
      {
        *(unsigned char *)a4 = 1;
        *(void *)(a4 + 8) = v9;
LABEL_19:
        if (!v29[0] && v30 && (v31 & 1) != 0) {
          (*(void (**)(void))(*(void *)v30 + 40))();
        }
        goto LABEL_20;
      }
      uint64_t v20 = re::globalAllocators(v14)[2];
      (**v9)(v9);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v20 + 40))(v20, v9);
    }
    else
    {
      uint64_t v19 = re::globalAllocators((re *)v13)[2];
      (**v9)(v9);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v19 + 40))(v19, v9);
    }
    *(void *)&long long v25 = 100;
    *((void *)&v25 + 1) = re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)&v30);
    long long v21 = v26;
    *(_OWORD *)(a4 + 8) = v25;
    uint64_t v22 = v27;
    uint64_t v23 = v28;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v21;
    *(void *)(a4 + 40) = v22;
    *(void *)(a4 + 48) = v23;
    goto LABEL_19;
  }
  uint64_t v15 = re::globalAllocators(v12)[2];
  (**v9)(v9);
  (*(void (**)(uint64_t, void (***)(void)))(*(void *)v15 + 40))(v15, v9);
  if (BYTE8(v34)) {
    int v16 = v35;
  }
  else {
    int v16 = (char *)&v34 + 9;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to read JSON source asset \"%s\": %s", (re::DynamicString *)&v25, a2, v16);
  long long v17 = v25;
  long long v18 = v26;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 100;
  *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v17;
  *(_OWORD *)(a4 + 40) = v18;
LABEL_20:
  if (!(_BYTE)v32 && (void)v34 && (BYTE8(v34) & 1) != 0) {
    (*(void (**)(void))(*(void *)v34 + 40))();
  }
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v36);
}

re *re::RenderGraphCompiler::deleteAsset(re::RenderGraphCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::RenderGraphAsset>((re *)"deleteAsset", 97, a2);
}

re::DynamicString *re::RenderGraphEmitterCompiler::getCurrentCompiledAssetInfo@<X0>(re::RenderGraphEmitterCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::RenderGraphEmitterAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::RenderGraphEmitterAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::RenderGraphEmitterCompiler::assetIntrospectionType(re::RenderGraphEmitterCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::RenderGraphEmitterAsset>(void)::info = re::introspect_RenderGraphEmitterAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[147];
}

void *re::RenderGraphEmitterCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::RenderGraphEmitterCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re *re::RenderGraphEmitterCompiler::compile@<X0>(re::RenderGraphEmitterCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = re::globalAllocators(this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 32, 8);
  *(void *)(v9 + 8) = 0;
  uint64_t v10 = (const char *)(v9 + 8);
  *(void *)(v9 + 16) = 0;
  *(void *)(v9 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v9 = &unk_26E6CD880;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FB90, memory_order_acquire) & 1) == 0)
  {
    int v18 = __cxa_guard_acquire(&qword_26AF7FB90);
    uint64_t v10 = (const char *)(v9 + 8);
    if (v18)
    {
      qword_26AF7FB88 = re::introspect_RenderGraphEmitterPointer(0);
      __cxa_guard_release(&qword_26AF7FB90);
      uint64_t v10 = (const char *)(v9 + 8);
    }
  }
  SourceJson = (re *)re::AssetUtilities::readSourceJson(a2, v10, qword_26AF7FB88, a3, (uint64_t)v23);
  if (!v23[0])
  {
    uint64_t v13 = re::globalAllocators(SourceJson)[2];
    (**(void (***)(uint64_t))v9)(v9);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 40))(v13, v9);
LABEL_11:
    *(void *)&long long v19 = 100;
    *((void *)&v19 + 1) = re::AssetErrorCategory(void)::instance;
    double result = re::DynamicString::DynamicString((re::DynamicString *)&v20, (const re::DynamicString *)&v24);
    long long v15 = v20;
    *(_OWORD *)(a4 + 8) = v19;
    uint64_t v16 = v21;
    uint64_t v17 = v22;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v15;
    *(void *)(a4 + 40) = v16;
    *(void *)(a4 + 48) = v17;
    goto LABEL_12;
  }
  re::RenderGraphEmitterBase::initRuntimeSettings(*(re::RenderGraphEmitterBase **)(v9 + 16), *(void *)(v9 + 8), (uint64_t)&v19);
  double result = (re *)re::Result<re::Unit,re::DynamicString>::operator=((uint64_t)v23, (uint64_t)&v19);
  if (!(_BYTE)v19)
  {
    double result = (re *)*((void *)&v19 + 1);
    if (*((void *)&v19 + 1))
    {
      if (v20) {
        double result = (re *)(*(uint64_t (**)(void))(**((void **)&v19 + 1) + 40))();
      }
    }
  }
  if (!v23[0])
  {
    uint64_t v14 = re::globalAllocators(result)[2];
    (**(void (***)(uint64_t))v9)(v9);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 40))(v14, v9);
    goto LABEL_11;
  }
  *(unsigned char *)a4 = 1;
  *(void *)(a4 + 8) = v9;
LABEL_12:
  if (!v23[0])
  {
    double result = v24;
    if (v24)
    {
      if (v25) {
        return (re *)(*(uint64_t (**)(void))(*(void *)v24 + 40))();
      }
    }
  }
  return result;
}

re *re::RenderGraphEmitterCompiler::deleteAsset(re::RenderGraphEmitterCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::RenderGraphEmitterAsset>((re *)"deleteAsset", 154, a2);
}

void re::RenderGraphCompiler::~RenderGraphCompiler(re::RenderGraphCompiler *this)
{
}

void re::RenderGraphEmitterCompiler::~RenderGraphEmitterCompiler(re::RenderGraphEmitterCompiler *this)
{
}

re::TextureImportOperation *re::TextureImportOperation::TextureImportOperation(re::TextureImportOperation *this, re::TextureProvider *a2, char a3, re::AssetManager *a4)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 3) = a4;
  *(void *)this = &unk_26E6DF570;
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  uint64_t v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 5, 0);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  uint64_t v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 9, 0);
  *((void *)this + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  unsigned int v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 15, 0);
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  int v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 19, 0);
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  uint64_t v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 23, 0);
  *((unsigned char *)this + 216) &= 0x80u;
  *((void *)this + 28) = 0;
  *((_DWORD *)this + 76) = 0;
  *((void *)this + 43) = 0;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  uint64_t v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)this + 40, 0);
  *((_DWORD *)this + 94) = 0;
  *((void *)this + 46) = 0;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *((void *)this + 57) = 0;
  re::DynamicString::setCapacity((void *)this + 54, 0);
  *((void *)this + 62) = a2;
  *((unsigned char *)this + 504) = a3;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  return this;
}

void re::TextureImportOperation::~TextureImportOperation(re::TextureImportOperation *this)
{
  uint64_t v1 = this;
  *(void *)this = &unk_26E6DF570;
  if (*((unsigned char *)this + 504))
  {
    uint64_t v2 = (void (***)(void))*((void *)this + 62);
    if (v2)
    {
      uint64_t v3 = re::globalAllocators(this)[2];
      (**v2)(v2);
      this = (re::TextureImportOperation *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v3 + 40))(v3, v2);
    }
    *((void *)v1 + 62) = 0;
  }
  uint64_t v4 = (void (***)(void))*((void *)v1 + 58);
  if (v4)
  {
    uint64_t v5 = re::globalAllocators(this)[2];
    (**v4)(v4);
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v5 + 40))(v5, v4);
    *((void *)v1 + 58) = 0;
  }
  re::AssetHandle::~AssetHandle((re::TextureImportOperation *)((char *)v1 + 472));
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 432));
  re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 392);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 352);
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 320));

  uint64_t v6 = *((unsigned int *)v1 + 76);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_26E6DF5A8 + v6))(&v7, (char *)v1 + 224);
  }
  *((_DWORD *)v1 + 76) = -1;
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 184));
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 152));
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 120));
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 72));
  re::DynamicString::deinit((re::TextureImportOperation *)((char *)v1 + 40));
  *(void *)uint64_t v1 = &unk_26E6DECE0;
  objc_destructInstance((char *)v1 + 8);
}

{
  uint64_t vars8;

  re::TextureImportOperation::~TextureImportOperation(this);
  JUMPOUT(0x237DBCBD0);
}

void re::USDImportContext::init(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, char a6, double a7)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  *(double *)a1 = a7;
  int v9 = *a4;
  if (*(unsigned char *)(a1 + 16)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v9 == 0;
  }
  if (!v10)
  {
    if (*(unsigned char *)(a1 + 16)) {
      BOOL v11 = v9 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      *(unsigned char *)(a1 + 16) = 0;
    }
    else
    {
      if (*(unsigned char *)(a1 + 16)) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = v9 == 0;
      }
      if (!v12) {
        *(unsigned char *)(a1 + 16) = 1;
      }
      *(_DWORD *)(a1 + 20) = *((_DWORD *)a4 + 1);
    }
  }
  int v13 = *a5;
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v14 = 0;
  }
  else {
    BOOL v14 = v13 == 0;
  }
  if (!v14)
  {
    if (*(unsigned char *)(a1 + 24)) {
      BOOL v15 = v13 == 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      *(unsigned char *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 24) && *a5) {
        *(unsigned char *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 1;
      }
      *(_DWORD *)(a1 + 28) = *((_DWORD *)a5 + 1);
    }
  }
  if (*a4) {
    int v16 = *((_DWORD *)a4 + 1);
  }
  else {
    int v16 = 2139095040;
  }
  *(_DWORD *)(a1 + 8) = v16;
  if (*a5) {
    int v17 = *((_DWORD *)a5 + 1);
  }
  else {
    int v17 = -8388608;
  }
  *(_DWORD *)(a1 + 12) = v17;
  *(unsigned char *)(a1 + 32) = a6;
  *(void *)(a1 + 40) = a3;
  re::BucketArray<re::USDImportContextSkeletonData,4ul>::init(a1 + 56, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 112, a2, 4);
  re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::init(a1 + 160, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 216, a2, 8);
  re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::init(a1 + 624, a2, 1uLL);
  int v18 = re::BucketArray<unsigned long,32ul>::init(a1 + 680, a2, 1uLL);
  re::DynamicString::setCapacity((void *)(a1 + 784), 0x40uLL);
  *(void *)(a1 + 816) = a2;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)(a1 + 816), 0x20uLL);
  ++*(_DWORD *)(a1 + 840);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 856, a2, 3);
  bzero(v26, 0x430uLL);
  unint64_t v26[2] = "";
  v26[4] = "";
  v26[6] = "";
  memset(v27, 0, sizeof(v27));
  uint64_t v28 = 0x7FFFFFFF00000000;
  long long v29 = 0u;
  int v30 = 1;
  uint64_t v31 = 0;
  long long v32 = 0u;
  int v33 = 0;
  uint64_t v34 = -1;
  int v35 = 16842752;
  char v36 = 1;
  int v37 = 0;
  __int16 v38 = 0;
  int v39 = 1036831949;
  int v40 = 16843008;
  char v41 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v42 = 0u;
  DWORD1(v44) = 0x7FFFFFFF;
  char v45 = -1;
  uint64_t v46 = 0;
  uint64_t v47 = 0x3F80000000000000;
  int v50 = 0;
  uint64_t v49 = 0;
  long long v48 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  int v53 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  int v56 = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  uint64_t v59 = 0x3F8000003F800000;
  uint64_t v60 = 1065353216;
  uint64_t v61 = 0;
  uint64_t v62 = 0x3F80000000000000;
  long long v63 = 0u;
  long long v20 = (_anonymous_namespace_ *)re::TimelineAssetData::TimelineAssetData((uint64_t)&v64, 33);
  __int16 v65 = 256;
  int v66 = 1023969417;
  uint64_t v70 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  int v69 = 0;
  long long v64 = &unk_26E6D0CB8;
  memset(v71, 0, sizeof(v71));
  uint64_t v72 = 0;
  uint64_t v21 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)v71 + 1, 0);
  memset(v73, 0, 32);
  uint64_t v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v73, 0);
  memset(v74, 0, sizeof(v74));
  uint64_t v23 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v74, 0);
  memset(v75, 0, sizeof(v75));
  long long v24 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v75, 0);
  memset(v76, 0, sizeof(v76));
  re::DynamicString::setCapacity(v76, 0);
  long long v77 = 0u;
  int v79 = 0;
  uint64_t v78 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  uint64_t v82 = -1;
  long long v83 = 0u;
  int v84 = 1;
  uint64_t v85 = 0;
  long long v86 = 0u;
  int v87 = 0;
  long long v88 = 0u;
  memset(v89, 0, 28);
  uint64_t v91 = 0;
  memset(&v89[32], 0, 64);
  int v90 = 0;
  uint64_t v25 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized(a1 + 624);
  re::USDImportContext::NodeStackItem::NodeStackItem(v25, (uint64_t)v26);
  re::USDImportContext::NodeStackItem::~NodeStackItem((re::USDImportContext::NodeStackItem *)v26);
  v26[0] = 0;
  re::DynamicArray<unsigned long>::add((void *)(a1 + 816), v26);
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::init(a1 + 368, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 424, a2, 8);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 472, a2, 8);
  re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::init(a1 + 520, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 576, a2, 8);
}

void *re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  double result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<unsigned long,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  double result = re::BucketArray<unsigned long,32ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::deinit(re::USDImportContext *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0xFF7FFFFF7F7FFFFFLL;
  *((void *)this + 5) = 0;
  re::BucketArray<re::USDImportContextSkeletonData,4ul>::deinit((uint64_t)this + 56);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 14);
  re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::deinit((uint64_t)this + 160);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 27);
  re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::deinit((uint64_t)this + 624);
  re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)this + 680);
  re::DynamicString::deinit((re::USDImportContext *)((char *)this + 784));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 816);
  re::USDImportContext::PhysicsColliderTable::deinit((re::USDImportContext *)((char *)this + 368));
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)this + 520);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 72);
  return re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 107);
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (re::USDImportContext::NodeStackItem *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1, i);
      re::USDImportContext::NodeStackItem::~NodeStackItem(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::PhysicsColliderTable::deinit(re::USDImportContext::PhysicsColliderTable *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this, i);
      re::StringID::StringID((re::StringID *)v9, (const StringID *)v4);
      long long v5 = *(_OWORD *)(v4 + 16);
      long long v6 = *(_OWORD *)(v4 + 32);
      long long v7 = *(_OWORD *)(v4 + 48);
      char v10 = *(unsigned char *)(v4 + 64);
      v9[2] = v6;
      v9[3] = v7;
      v9[1] = v5;
      re::internal::destroyPersistent<re::CollisionShapeData>((re *)"deinit", 667, (void (***)(void))v5);
      re::StringID::destroyString((re::StringID *)v9);
    }
  }
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)this);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7);
  return re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13);
}

uint64_t re::USDImportContext::pushNodePath(re::USDImportContext *this, const char *a2, const char *a3, const char *a4)
{
  uint64_t v5 = re::USDImportContext::pushNodeLevel(this, a2, a3, a4, 1);
  uint64_t v7 = *((void *)this + 83);
  if (v7)
  {
    uint64_t v8 = v5;
    v10[0] = *(const char **)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, v7 - 1)+ 32);
    v10[1] = (const char *)strlen(v10[0]);
    re::DynamicString::operator=((re::USDImportContext *)((char *)this + 784), (uint64_t)v10);
    return v8;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::USDImportContext::pushNodeLevel(re::USDImportContext *this, const char *a2, const char *a3, const char *a4, int a5)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  unint64_t v10 = *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8);
  char v36 = (char *)this + 624;
  uint64_t v11 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, v10);
  uint64_t v12 = v11;
  if (a5)
  {
    re::UniqueNameGenerator::uniqueName((re::UniqueNameGenerator *)(v11 + 56), a2, a3, (re::StringID *)&v44);
  }
  else
  {
    *(void *)&v44.var0 = 0;
    v44.uint64_t var1 = "";
  }
  uint64_t v13 = *((void *)this + 83);
  BOOL v14 = (_anonymous_namespace_ *)re::BucketArray<unsigned long,8ul>::addUninitialized(v12 + 880);
  *(void *)BOOL v14 = v13;
  BOOL v15 = *(const char **)(v12 + 32);
  uint64_t var1 = v44.var1;
  uint64_t v18 = v43 & 1;
  unint64_t v19 = v43 >> 1;
  unint64_t v20 = v43 >> 1;
  if (v43) {
    unint64_t v21 = v43 >> 1;
  }
  else {
    unint64_t v21 = v43 >> 1;
  }
  if (v21)
  {
    if (v21 != 1 || *(unsigned char *)re::DynamicString::operator[]((uint64_t)&v42, 0) != 47)
    {
LABEL_20:
      re::DynamicString::append((re::DynamicString *)&v42, "/", 1uLL);
      goto LABEL_21;
    }
    uint64_t v18 = v43 & 1;
    unint64_t v19 = v43 >> 1;
    unint64_t v20 = v43 >> 1;
  }
  if (v18) {
    unint64_t v22 = v19;
  }
  else {
    unint64_t v22 = v20;
  }
  if (!v22)
  {
    unint64_t v23 = (v41 & 1) != 0 ? v41 >> 1 : v41 >> 1;
    if (v23 != 1 || *(unsigned char *)re::DynamicString::operator[]((uint64_t)&v40, 0) != 47) {
      goto LABEL_20;
    }
  }
LABEL_21:
  LOBYTE(v45) = 0;
  re::StringID::StringID((re::StringID *)&v46, &v44);
  long long v24 = (_anonymous_namespace_ *)re::DynamicString::operator+((re::DynamicString *)&v42, v44.var1, (re::DynamicString *)&v37);
  if (v38) {
    uint64_t v25 = *(const char **)&v39[7];
  }
  else {
    uint64_t v25 = v39;
  }
  v47[0] = 0;
  v47[1] = "";
  v48[0] = 0;
  v48[1] = "";
  int v50 = 0;
  memset(v49, 0, sizeof(v49));
  uint64_t v51 = 0x7FFFFFFFLL;
  uint64_t v53 = 1;
  long long v52 = 0u;
  long long v55 = 0u;
  uint64_t v54 = 0;
  uint64_t v56 = 0;
  uint64_t v57 = -1;
  int v58 = 16842752;
  char v59 = 1;
  int v60 = 0;
  __int16 v61 = 0;
  uint64_t v62 = 0x10101003DCCCCCDLL;
  char v63 = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  DWORD1(v66) = 0x7FFFFFFF;
  char v67 = -1;
  uint64_t v68 = 0;
  uint64_t v69 = 0x3F80000000000000;
  int v72 = 0;
  uint64_t v71 = 0;
  long long v70 = 0u;
  int v75 = 0;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  int v78 = 0;
  long long v79 = 0u;
  long long v80 = 0u;
  uint64_t v82 = 1065353216;
  uint64_t v81 = 0x3F8000003F800000;
  uint64_t v84 = 0x3F80000000000000;
  uint64_t v83 = 0;
  long long v85 = 0u;
  uint64_t v28 = (_anonymous_namespace_ *)re::TimelineAssetData::TimelineAssetData((uint64_t)&v86, 33);
  __int16 v87 = 256;
  int v88 = 1023969417;
  uint64_t v92 = 0;
  long long v89 = 0u;
  long long v90 = 0u;
  int v91 = 0;
  long long v86 = &unk_26E6D0CB8;
  memset(v93, 0, sizeof(v93));
  uint64_t v94 = 0;
  long long v29 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)v93 + 1, 0);
  memset(v95, 0, 32);
  int v30 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v95, 0);
  memset(&v95[4], 0, 32);
  memset(v96, 0, sizeof(v96));
  uint64_t v31 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v96, 0);
  memset(v97, 0, sizeof(v97));
  long long v32 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v97, 0);
  memset(v98, 0, sizeof(v98));
  re::DynamicString::setCapacity(v98, 0);
  long long v99 = 0u;
  int v101 = 0;
  uint64_t v100 = 0;
  long long v102 = 0u;
  long long v103 = 0u;
  unint64_t v104 = v10;
  uint64_t v108 = 0;
  long long v105 = 0u;
  long long v106 = 1u;
  long long v107 = 0uLL;
  long long v109 = 0u;
  memset(v110, 0, 28);
  uint64_t v112 = 0;
  memset(&v110[32], 0, 64);
  int v111 = 0;
  uint64_t v33 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized((uint64_t)v36);
  re::USDImportContext::NodeStackItem::NodeStackItem(v33, (uint64_t)&v45);
  re::USDImportContext::NodeStackItem::~NodeStackItem((re::USDImportContext::NodeStackItem *)&v45);
  if (v37 && (v38 & 1) != 0) {
    (*(void (**)(void))(*(void *)v37 + 40))();
  }
  uint64_t v45 = *((void *)this + 83) - 1;
  re::DynamicArray<unsigned long>::add((void *)this + 102, &v45);
  if (!v10) {
    re::USDImportContext::setNodeAsEntity(this, *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8));
  }
  uint64_t v34 = *((void *)this + 83);
  if (v40 && (v41 & 1) != 0) {
    (*(void (**)(void))(*(void *)v40 + 40))();
  }
  if (v42 && (v43 & 1) != 0) {
    (*(void (**)(void))(*(void *)v42 + 40))();
  }
  re::StringID::destroyString((re::StringID *)&v44);
  return v34 - 1;
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 5) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 5)) + 1072 * (a2 & 0x1F);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 5) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 5)) + 1072 * (a2 & 0x1F);
}

uint64_t re::USDImportContext::popNodePath(re::USDImportContext *this)
{
  unint64_t v2 = (void *)((char *)this + 784);
  uint64_t result = re::DynamicString::rfind((uint64_t)this + 784, 47, v6);
  if (v6[0])
  {
    uint64_t result = (uint64_t)re::DynamicString::resize(v2, v7, 0);
  }
  else
  {
    uint64_t v4 = *((void *)this + 99);
    if (v4)
    {
      *((void *)this + 99) = 1;
      uint64_t v5 = (unsigned char *)*((void *)this + 100);
    }
    else
    {
      *((unsigned char *)this + 792) = v4 & 1;
      uint64_t v5 = (char *)this + 793;
    }
    *uint64_t v5 = 0;
  }
  --*((void *)this + 104);
  ++*((_DWORD *)this + 210);
  return result;
}

uint64_t re::USDImportContext::setNodeAsEntity(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v4 = (char *)this + 624;
  uint64_t result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  if (*(void *)(result + 160) == -1)
  {
    *(void *)re::BucketArray<unsigned long,32ul>::addUninitialized((uint64_t)this + 680) = a2;
    uint64_t v6 = *((void *)this + 90) - 1;
    uint64_t result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v4, a2);
    *(void *)(result + 160) = v6;
  }
  return result;
}

re::DynamicString *re::USDImportContext::setText3D(re::USDImportContext *this, const re::USDImportContext::GeomText3D *a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8));
  re::DynamicString::operator=((re::DynamicString *)(v3 + 616), a2);
  re::DynamicString::operator=((re::DynamicString *)(v3 + 648), (const re::USDImportContext::GeomText3D *)((char *)a2 + 32));
  long long v4 = *((_OWORD *)a2 + 5);
  *(_OWORD *)(v3 + 680) = *((_OWORD *)a2 + 4);
  *(_OWORD *)(v3 + 696) = v4;
  re::DynamicString::operator=((re::DynamicString *)(v3 + 712), (const re::USDImportContext::GeomText3D *)((char *)a2 + 96));
  re::DynamicString::operator=((re::DynamicString *)(v3 + 744), (const re::USDImportContext::GeomText3D *)((char *)a2 + 128));
  return re::DynamicString::operator=((re::DynamicString *)(v3 + 776), (const re::USDImportContext::GeomText3D *)((char *)a2 + 160));
}

uint64_t re::USDImportContext::setPrimitiveShape(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = a1 + 624;
  uint64_t v5 = (_OWORD *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  long long v7 = a2[1];
  long long v6 = a2[2];
  v5[15] = *a2;
  v5[16] = v7;
  v5[17] = v6;
  uint64_t v8 = (StringID *)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8))+ 40);
  int v9 = (void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8);
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 856, v8, v9);
}

uint64_t re::USDImportContext::setModel(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 624;
  uint64_t v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(v5 + 288, 1uLL);
  re::make::shared::object<re::ShareableInternal<re::GeomModelDescriptor>,re::GeomModelDescriptor>((re *)v12, a2);
  uint64_t v6 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  if (!*(void *)(v6 + 304))
  {
    v12[1] = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v13 = 136315906;
    BOOL v14 = "operator[]";
    __int16 v15 = 1024;
    int v16 = 789;
    __int16 v17 = 2048;
    uint64_t v18 = 0;
    __int16 v19 = 2048;
    uint64_t v20 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  long long v7 = *(uint64_t **)(v6 + 320);
  uint64_t v8 = *v7;
  *long long v7 = v12[0];
  if (v8) {

  }
  int v9 = (StringID *)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8))+ 40);
  unint64_t v10 = (void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8);
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 856, v9, v10);
}

uint64_t *re::USDImportContext::setModelsWithLods(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  unint64_t v36 = *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8);
  uint64_t v32 = a1 + 624;
  uint64_t v8 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v36);
  re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(v8 + 288, *(void *)(a2 + 16));
  uint64_t v9 = *(void *)(v8 + 304);
  if (v9)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = *(void *)(a2 + 16);
      if (v12 <= v11) {
        break;
      }
      re::make::shared::object<re::ShareableInternal<re::GeomModelDescriptor>,re::GeomModelDescriptor>((re *)&v35, *(void *)(a2 + 32) + v10);
      unint64_t v12 = *(void *)(v8 + 304);
      if (v12 <= v11) {
        goto LABEL_25;
      }
      uint64_t v13 = *(void *)(v8 + 320);
      uint64_t v14 = *(void *)(v13 + 8 * v11);
      *(void *)(v13 + 8 * v11) = v35;
      if (v14) {

      }
      unint64_t v12 = *(void *)(a4 + 16);
      if (v12 <= v11) {
        goto LABEL_26;
      }
      unint64_t v15 = *(void *)(*(void *)(a4 + 32) + 8 * v11);
      if (v15 != -1)
      {
        uint64_t v16 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](a1 + 160, v15);
        re::DynamicArray<unsigned long>::add((void *)(v16 + 240), &v36);
      }
      unint64_t v12 = *(void *)(a3 + 16);
      if (v12 <= v11) {
        goto LABEL_27;
      }
      unint64_t v17 = *(void *)(*(void *)(a3 + 32) + 8 * v11);
      if (v17 != -1)
      {
        uint64_t v18 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](a1 + 56, v17);
        re::DynamicArray<unsigned long>::add((void *)(v18 + 376), &v36);
      }
      ++v11;
      v10 += 216;
      if (v9 == v11) {
        goto LABEL_14;
      }
    }
    uint64_t v37 = 0;
    long long v50 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v38 = 136315906;
    int v39 = "operator[]";
    __int16 v40 = 1024;
    int v41 = 789;
    __int16 v42 = 2048;
    unint64_t v43 = v11;
    __int16 v44 = 2048;
    unint64_t v45 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_25:
    uint64_t v37 = 0;
    long long v50 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v38 = 136315906;
    int v39 = "operator[]";
    __int16 v40 = 1024;
    int v41 = 789;
    __int16 v42 = 2048;
    unint64_t v43 = v11;
    __int16 v44 = 2048;
    unint64_t v45 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    uint64_t v37 = 0;
    long long v50 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v38 = 136315906;
    int v39 = "operator[]";
    __int16 v40 = 1024;
    int v41 = 789;
    __int16 v42 = 2048;
    unint64_t v43 = v11;
    __int16 v44 = 2048;
    unint64_t v45 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_27:
    uint64_t v37 = 0;
    long long v50 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v38 = 136315906;
    int v39 = "operator[]";
    __int16 v40 = 1024;
    int v41 = 789;
    __int16 v42 = 2048;
    unint64_t v43 = v11;
    __int16 v44 = 2048;
    unint64_t v45 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_14:
  uint64_t v19 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  if (v19)
  {
    uint64_t v20 = 0;
    uint64_t v21 = *(void *)(a2 + 32);
    uint64_t v22 = 216 * v19;
    do
    {
      uint64_t v23 = v21 + v20;
      re::DynamicString::deinit((re::DynamicString *)(v21 + v20 + 184));
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v21 + v20 + 136));
      re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(v21 + v20 + 96);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v21 + v20 + 48));
      uint64_t v24 = *(void *)(v21 + v20 + 40);
      if (v24)
      {

        *(void *)(v23 + 40) = 0;
      }
      uint64_t v25 = *(void *)(v23 + 32);
      if (v25)
      {

        *(void *)(v23 + 32) = 0;
      }
      uint64_t v26 = *(void *)(v21 + v20 + 8);
      if (v26)
      {

        *(void *)(v21 + v20 + 8) = 0;
      }
      v20 += 216;
    }
    while (v22 != v20);
  }
  ++*(_DWORD *)(a2 + 24);
  uint64_t v27 = a1;
  uint64_t v28 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v32, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v28 + 328, a3);
  uint64_t v29 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v32, *(void *)(*(void *)(v27 + 848) + 8 * *(void *)(v27 + 832) - 8));
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v29 + 368, a4);
  uint64_t v30 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v32, *(void *)(*(void *)(v27 + 848) + 8 * *(void *)(v27 + 832) - 8));
  return re::FixedArray<float>::operator=((uint64_t *)(v30 + 408), a5);
}

uint64_t re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 280 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 280 * (a2 & 7);
}

uint64_t re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 424 * (a2 & 3);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 424 * (a2 & 3);
}

uint64_t re::USDImportContext::setMeshMaterials(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8))+ 808;
  return re::DynamicArray<re::AssetHandle>::operator=(v3, a2);
}

uint64_t re::DynamicArray<re::AssetHandle>::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)a2;
    if (*(void *)result) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4 || v2 == v3)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)uint64_t result = v3;
      *(void *)(result + 8) = v7;
      *(void *)a2 = v2;
      *(void *)(a2 + 8) = v6;
      uint64_t v8 = *(void *)(result + 16);
      *(void *)(result + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v8;
      uint64_t v9 = *(void *)(result + 32);
      *(void *)(result + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      uint64_t result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

float32x4_t re::USDImportContext::concatenateLocalTransform(uint64_t a1, float32x4_t *a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  float32x4_t v4 = *(float32x4_t *)(v3 + 432);
  _Q1 = *(float32x4_t *)(v3 + 448);
  _Q3 = a2[1];
  float32x4_t v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL);
  float32x4_t v8 = vnegq_f32(_Q1);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), v8), _Q3, v7);
  float32x4_t v10 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL), _Q3, _Q1, 3), _Q1, _Q3, 3);
  _Q3.i32[0] = _Q3.i32[3];
  __asm { FMLA            S7, S3, V1.S[3] }
  v10.i32[3] = _S7;
  float32x4_t v16 = vmulq_f32(v4, *a2);
  float32x4_t v17 = a2[2];
  float32x4_t v18 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v8), v17, v7);
  int8x16_t v19 = (int8x16_t)vaddq_f32(v18, v18);
  float32x4_t v20 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), v19, 0xCuLL);
  float32x4_t v21 = vaddq_f32(v17, vmulq_laneq_f32(v20, _Q1, 3));
  int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v8), v20, v7);
  float32x4_t result = vaddq_f32(*(float32x4_t *)(v3 + 464), vmulq_f32(v4, vaddq_f32(v21, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL))));
  *(float32x4_t *)(v3 + 432) = v16;
  *(float32x4_t *)(v3 + 448) = v10;
  *(float32x4_t *)(v3 + 464) = result;
  return result;
}

uint64_t re::USDImportContext::setTransformAnimation(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 16))
  {
    float v4 = *(float *)(a1 + 8);
    if (v4 > *(float *)(a2 + 80)) {
      float v4 = *(float *)(a2 + 80);
    }
    *(float *)(a1 + 8) = v4;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    float v5 = *(float *)(a2 + 84);
  }
  else
  {
    float v6 = *(float *)(a1 + 12);
    float v5 = *(float *)(a2 + 84);
    if (v6 < v5) {
      float v6 = *(float *)(a2 + 84);
    }
    *(float *)(a1 + 12) = v6;
  }
  float v7 = *(float *)(a2 + 80);
  double v8 = v7;
  *(_DWORD *)(a2 + 80) = 0;
  *(float *)(a2 + 84) = v5 - v7;
  uint64_t v9 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  re::SampledAnimationAssetData<re::GenericSRT<float>>::operator=(v9 + 480, a2);
  uint64_t result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  *(double *)(result + 608) = v8;
  return result;
}

void re::USDImportContext::setVertexCacheAnimation(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  v3[124] = *a2;
  if (v3 + 124 != a2)
  {
    uint64_t v5 = v3[125];
    uint64_t v6 = a2[1];
    if (v5) {
      BOOL v7 = v5 == v6;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      _os_crash();
      __break(1u);
      return;
    }
    v3[125] = v6;
    a2[1] = v5;
    uint64_t v8 = v3[126];
    v3[126] = a2[2];
    a2[2] = v8;
    uint64_t v9 = v3[127];
    v3[127] = a2[3];
    a2[3] = v9;
  }
  uint64_t v11 = 0xBD8878DBB047AD5ELL;
  unint64_t v12 = "DefaultVertexCacheDeformer";
  unint64_t v13 = 0x20889405B90383CLL;
  uint64_t v14 = "VertexCache";
  float32x4_t v10 = (_anonymous_namespace_ *)(v3 + 128);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  int v18 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  int v21 = 0;
  long long v23 = 0u;
  long long v26 = 0u;
  long long v22 = 0u;
  DWORD2(v23) = 1;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  *(void *)&long long v26 = 0;
  uint64_t v28 = 1;
  long long v27 = 0u;
  DWORD2(v26) = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v36 = 0;
  long long v33 = 0u;
  long long v34 = 1uLL;
  long long v35 = 0uLL;
  long long v37 = 0u;
  uint64_t v41 = 0;
  uint64_t v38 = 1;
  uint64_t v40 = 0;
  uint64_t v39 = 0;
  uint64_t v42 = 0;
  uint64_t v46 = 0;
  long long v43 = 0u;
  long long v44 = 1uLL;
  long long v45 = 0uLL;
  long long v47 = 0u;
  uint64_t v51 = 0;
  uint64_t v48 = 1;
  uint64_t v50 = 0;
  uint64_t v49 = 0;
  uint64_t v52 = 0;
  re::DynamicArray<re::GeomDeformer>::add((_anonymous_namespace_ *)(v3 + 128), &v11);
  re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)&v11);
  uint64_t v11 = 0xAE076461BA42A276;
  unint64_t v12 = "DefaultRenormalizationDeformer";
  unint64_t v13 = 0xABCEC87F22A13454;
  uint64_t v14 = "Renormalization";
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  int v18 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  int v21 = 0;
  long long v23 = 0u;
  long long v26 = 0u;
  long long v22 = 0u;
  DWORD2(v23) = 1;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  *(void *)&long long v26 = 0;
  uint64_t v28 = 1;
  long long v27 = 0u;
  DWORD2(v26) = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v38 = 1;
  uint64_t v36 = 0;
  long long v33 = 0u;
  long long v34 = 1u;
  long long v35 = 0uLL;
  long long v37 = 0u;
  uint64_t v41 = 0;
  uint64_t v40 = 0;
  uint64_t v39 = 0;
  uint64_t v42 = 0;
  uint64_t v48 = 1;
  uint64_t v46 = 0;
  long long v43 = 0u;
  long long v44 = 1u;
  long long v45 = 0uLL;
  long long v47 = 0u;
  uint64_t v51 = 0;
  uint64_t v50 = 0;
  uint64_t v49 = 0;
  uint64_t v52 = 0;
  re::DynamicArray<re::GeomDeformer>::add(v10, &v11);
  re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)&v11);
}

uint64_t re::USDImportContext::setSkeletonReference(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = this;
  uint64_t v21 = *MEMORY[0x263EF8340];
  v7[0] = *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8);
  uint64_t v4 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)this + 56, a2);
  re::DynamicArray<unsigned long>::add((void *)(v4 + 376), v7);
  uint64_t v3 = (re::USDImportContext *)((char *)v3 + 624);
  uint64_t v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  re::DynamicArray<unsigned long>::resize(v5 + 328, 1uLL);
  uint64_t result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  if (!*(void *)(result + 344))
  {
    v7[1] = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v8 = 136315906;
    uint64_t v9 = "operator[]";
    __int16 v10 = 1024;
    int v11 = 789;
    __int16 v12 = 2048;
    uint64_t v13 = 0;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  **(void **)(result + 360) = a2;
  return result;
}

uint64_t re::USDImportContext::setSkeletalAnimationReference(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = this;
  uint64_t v21 = *MEMORY[0x263EF8340];
  v7[0] = *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8);
  uint64_t v4 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[]((uint64_t)this + 160, a2);
  re::DynamicArray<unsigned long>::add((void *)(v4 + 240), v7);
  uint64_t v3 = (re::USDImportContext *)((char *)v3 + 624);
  uint64_t v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  re::DynamicArray<unsigned long>::resize(v5 + 368, 1uLL);
  uint64_t result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  if (!*(void *)(result + 384))
  {
    v7[1] = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v8 = 136315906;
    uint64_t v9 = "operator[]";
    __int16 v10 = 1024;
    int v11 = 789;
    __int16 v12 = 2048;
    uint64_t v13 = 0;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  **(void **)(result + 400) = a2;
  return result;
}

void re::USDImportContext::setSpatialAudioData(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(void *)(*(void *)(a1 + 848) + 8 * *(void *)(a1 + 832) - 8));
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v3 + 936) = v4;
  uint64_t v6 = *(std::__shared_weak_count **)(v3 + 944);
  *(void *)(v3 + 944) = v5;
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void *re::USDImportContext::setAdditionalAnimation(re::USDImportContext *this, re::Timeline *a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, *(void *)(*((void *)this + 106) + 8 * *((void *)this + 104) - 8));
  return re::DynamicArray<re::TransitionCondition *>::add((void *)(v2 + 952), &v4);
}

void *re::USDImportContext::setSkeletonEntity(re::USDImportContext *this, unint64_t a2, unint64_t a3)
{
  *(void *)(re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)this + 56, a3) + 416) = a2;
  uint64_t v6 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  uint64_t result = (void *)re::BucketArray<unsigned long,4ul>::addUninitialized(v6 + 104);
  *uint64_t result = a3;
  return result;
}

uint64_t re::USDImportContext::addBlendShape(uint64_t a1, StringID *a2, uint64_t *a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  re::StringID::StringID((re::StringID *)&v21, a2);
  uint64_t v23 = *a3;
  long long v6 = *(_OWORD *)(a3 + 1);
  *a3 = 0;
  a3[1] = (uint64_t)"";
  long long v24 = v6;
  uint64_t v25 = a3[3];
  long long v26 = *((_OWORD *)a3 + 2);
  *((_OWORD *)a3 + 1) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  uint64_t v27 = a3[6];
  a3[6] = 0;
  long long v28 = *(_OWORD *)(a3 + 7);
  *(_OWORD *)(a3 + 7) = 0u;
  uint64_t v7 = a3[10];
  uint64_t v29 = a3[9];
  uint64_t v30 = v7;
  a3[9] = 0;
  a3[10] = 0;
  int v33 = 0;
  uint64_t v32 = 0;
  long long v31 = 0u;
  unint64_t v8 = *(void *)(a1 + 304);
  unint64_t v9 = *(void *)(a1 + 272);
  uint64_t v34 = 0;
  uint64_t v35 = -1;
  if (v8 + 1 > 8 * v9)
  {
    re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity((void *)(a1 + 264), (v8 + 8) >> 3);
    unint64_t v9 = *(void *)(a1 + 272);
  }
  if (v9 <= v8 >> 3)
  {
    uint64_t v36 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v37 = 136315906;
    uint64_t v38 = "operator[]";
    __int16 v39 = 1024;
    int v40 = 858;
    __int16 v41 = 2048;
    unint64_t v42 = v8 >> 3;
    __int16 v43 = 2048;
    unint64_t v44 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 280)) {
    uint64_t v10 = a1 + 288;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 296);
  }
  uint64_t v11 = *(void *)(v10 + 8 * (v8 >> 3));
  ++*(void *)(a1 + 304);
  ++*(_DWORD *)(a1 + 312);
  uint64_t v12 = v11 + 152 * (v8 & 7);
  char v13 = v21;
  *(void *)uint64_t v12 = *(void *)v12 & 0xFFFFFFFFFFFFFFFELL | v21 & 1;
  *(void *)uint64_t v12 = v21 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  *(void *)(v12 + 8) = v22;
  uint64_t v21 = 0;
  long long v22 = "";
  char v14 = v23;
  *(void *)(v12 + 16) = *(void *)(v12 + 16) & 0xFFFFFFFFFFFFFFFELL | v23 & 1;
  *(void *)(v12 + 16) = v23 & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
  *(void *)(v12 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v24;
  uint64_t v23 = 0;
  *(void *)&long long v24 = "";
  *(void *)(v12 + 32) = 0;
  *(void *)(v12 + 40) = 0;
  *(void *)(v12 + 48) = 0;
  *(void *)(v12 + 32) = *((void *)&v24 + 1);
  *((void *)&v24 + 1) = 0;
  *(void *)(v12 + 40) = v25;
  uint64_t v25 = 0;
  uint64_t v15 = *(void *)(v12 + 48);
  *(void *)(v12 + 48) = v26;
  *(void *)&long long v26 = v15;
  *(void *)(v12 + 56) = 0;
  *(void *)(v12 + 64) = 0;
  *(void *)(v12 + 72) = 0;
  *(void *)(v12 + 56) = *((void *)&v26 + 1);
  *((void *)&v26 + 1) = 0;
  *(void *)(v12 + 64) = v27;
  uint64_t v27 = 0;
  uint64_t v16 = *(void *)(v12 + 72);
  *(void *)(v12 + 72) = v28;
  *(void *)&long long v28 = v16;
  *(void *)(v12 + 80) = 0;
  *(void *)(v12 + 88) = 0;
  *(void *)(v12 + 96) = 0;
  *(void *)(v12 + 80) = *((void *)&v28 + 1);
  *((void *)&v28 + 1) = 0;
  *(void *)(v12 + 88) = v29;
  uint64_t v29 = 0;
  uint64_t v17 = *(void *)(v12 + 96);
  *(void *)(v12 + 96) = v30;
  uint64_t v30 = v17;
  *(void *)(v12 + 136) = 0;
  *(_DWORD *)(v12 + 128) = 0;
  *(void *)(v12 + 112) = 0;
  *(void *)(v12 + 120) = 0;
  *(void *)(v12 + 104) = 0;
  *(void *)(v12 + 104) = v31;
  *(void *)&long long v31 = 0;
  *(void *)(v12 + 112) = *((void *)&v31 + 1);
  *((void *)&v31 + 1) = 0;
  uint64_t v18 = *(void *)(v12 + 120);
  *(void *)(v12 + 120) = v32;
  uint64_t v32 = v18;
  uint64_t v19 = *(void *)(v12 + 136);
  *(void *)(v12 + 136) = v34;
  uint64_t v34 = v19;
  ++v33;
  ++*(_DWORD *)(v12 + 128);
  *(void *)(v12 + 144) = v35;
  if ((void)v31)
  {
    if (v19) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
    uint64_t v34 = 0;
    uint64_t v32 = 0;
    long long v31 = 0uLL;
    ++v33;
  }
  if (*((void *)&v28 + 1))
  {
    if (v29)
    {
      (*(void (**)(void))(**((void **)&v28 + 1) + 40))();
      uint64_t v29 = 0;
      uint64_t v30 = 0;
    }
    *((void *)&v28 + 1) = 0;
  }
  if (*((void *)&v26 + 1))
  {
    if (v27)
    {
      (*(void (**)(void))(**((void **)&v26 + 1) + 40))();
      uint64_t v27 = 0;
      *(void *)&long long v28 = 0;
    }
    *((void *)&v26 + 1) = 0;
  }
  if (*((void *)&v24 + 1))
  {
    if (v25)
    {
      (*(void (**)(void))(**((void **)&v24 + 1) + 40))();
      uint64_t v25 = 0;
      *(void *)&long long v26 = 0;
    }
    *((void *)&v24 + 1) = 0;
  }
  re::StringID::destroyString((re::StringID *)&v23);
  re::StringID::destroyString((re::StringID *)&v21);
  uint64_t v21 = *(void *)(a1 + 304) - 1;
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 320, a2, &v21);
}

uint64_t re::USDImportContext::addSkeleton(uint64_t a1, StringID *a2, uint64_t *a3)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  re::StringID::StringID((re::StringID *)&v27, a2);
  uint64_t v29 = *a3;
  long long v6 = *(_OWORD *)(a3 + 1);
  *a3 = 0;
  a3[1] = (uint64_t)"";
  long long v30 = v6;
  uint64_t v31 = a3[3];
  long long v32 = *((_OWORD *)a3 + 2);
  *((_OWORD *)a3 + 1) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  uint64_t v33 = a3[6];
  a3[6] = 0;
  long long v34 = *(_OWORD *)(a3 + 7);
  *(_OWORD *)(a3 + 7) = 0u;
  uint64_t v35 = a3[9];
  a3[9] = 0;
  long long v36 = *((_OWORD *)a3 + 5);
  *((_OWORD *)a3 + 5) = 0u;
  uint64_t v37 = a3[12];
  a3[12] = 0;
  int v42 = 0;
  long long v38 = *(_OWORD *)(a3 + 13);
  *(_OWORD *)(a3 + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = 0u;
  uint64_t v7 = a3[16];
  uint64_t v39 = a3[15];
  uint64_t v40 = v7;
  *(_OWORD *)(a3 + 15) = 0u;
  long long v41 = *(_OWORD *)(a3 + 17);
  *(_OWORD *)(a3 + 17) = xmmword_23436F740;
  re::TimelineAssetData::TimelineAssetData((uint64_t)v43, 34);
  __int16 v47 = 256;
  int v48 = 1023969417;
  uint64_t v51 = 0;
  memset(v49, 0, sizeof(v49));
  int v50 = 0;
  v43[0] = &unk_26E6D0D68;
  uint64_t v56 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  int v55 = 0;
  __int16 v57 = 257;
  char v58 = 1;
  uint64_t v59 = 0;
  long long v60 = 0u;
  int v61 = 0;
  unint64_t v8 = *(void *)(a1 + 96);
  unint64_t v9 = *(void *)(a1 + 64);
  uint64_t v62 = 0;
  uint64_t v63 = -1;
  if (v8 + 1 > 4 * v9)
  {
    re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity((void *)(a1 + 56), (v8 + 4) >> 2);
    unint64_t v9 = *(void *)(a1 + 64);
  }
  if (v9 <= v8 >> 2)
  {
    uint64_t v64 = 0;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v73 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v65 = 136315906;
    long long v66 = "operator[]";
    __int16 v67 = 1024;
    int v68 = 858;
    __int16 v69 = 2048;
    unint64_t v70 = v8 >> 2;
    __int16 v71 = 2048;
    unint64_t v72 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 72)) {
    uint64_t v10 = a1 + 80;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 88);
  }
  uint64_t v11 = *(void *)(v10 + 8 * (v8 >> 2));
  ++*(void *)(a1 + 96);
  ++*(_DWORD *)(a1 + 104);
  uint64_t v12 = v11 + 424 * (v8 & 3);
  LOBYTE(v11) = v27;
  *(void *)uint64_t v12 = *(void *)v12 & 0xFFFFFFFFFFFFFFFELL | v27 & 1;
  *(void *)uint64_t v12 = v27 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(void *)(v12 + 8) = v28;
  uint64_t v27 = 0;
  long long v28 = "";
  LOBYTE(v11) = v29;
  *(void *)(v12 + 16) = *(void *)(v12 + 16) & 0xFFFFFFFFFFFFFFFELL | v29 & 1;
  *(void *)(v12 + 16) = v29 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(void *)(v12 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v30;
  uint64_t v29 = 0;
  *(void *)&long long v30 = "";
  *(void *)(v12 + 32) = 0;
  *(void *)(v12 + 40) = 0;
  *(void *)(v12 + 48) = 0;
  *(void *)(v12 + 32) = *((void *)&v30 + 1);
  *((void *)&v30 + 1) = 0;
  *(void *)(v12 + 40) = v31;
  uint64_t v31 = 0;
  uint64_t v13 = *(void *)(v12 + 48);
  *(void *)(v12 + 48) = v32;
  *(void *)&long long v32 = v13;
  *(void *)(v12 + 56) = 0;
  *(void *)(v12 + 64) = 0;
  *(void *)(v12 + 72) = 0;
  *(void *)(v12 + 56) = *((void *)&v32 + 1);
  *((void *)&v32 + 1) = 0;
  *(void *)(v12 + 64) = v33;
  uint64_t v33 = 0;
  uint64_t v14 = *(void *)(v12 + 72);
  *(void *)(v12 + 72) = v34;
  *(void *)&long long v34 = v14;
  *(void *)(v12 + 80) = 0;
  *(void *)(v12 + 88) = 0;
  *(void *)(v12 + 96) = 0;
  *(void *)(v12 + 80) = *((void *)&v34 + 1);
  *((void *)&v34 + 1) = 0;
  *(void *)(v12 + 88) = v35;
  uint64_t v35 = 0;
  uint64_t v15 = *(void *)(v12 + 96);
  *(void *)(v12 + 96) = v36;
  *(void *)&long long v36 = v15;
  *(void *)(v12 + 104) = 0;
  *(void *)(v12 + 112) = 0;
  *(void *)(v12 + 120) = 0;
  *(void *)(v12 + 104) = *((void *)&v36 + 1);
  *((void *)&v36 + 1) = 0;
  *(void *)(v12 + 112) = v37;
  uint64_t v37 = 0;
  uint64_t v16 = *(void *)(v12 + 120);
  *(void *)(v12 + 120) = v38;
  *(void *)&long long v38 = v16;
  *(_DWORD *)(v12 + 160) = 0;
  *(_OWORD *)(v12 + 128) = 0u;
  *(_OWORD *)(v12 + 144) = 0u;
  *(void *)(v12 + 164) = 0x7FFFFFFFLL;
  *(void *)(v12 + 128) = *((void *)&v38 + 1);
  *((void *)&v38 + 1) = 0;
  uint64_t v17 = *(void *)(v12 + 136);
  *(void *)(v12 + 136) = v39;
  uint64_t v39 = v17;
  uint64_t v18 = *(void *)(v12 + 144);
  *(void *)(v12 + 144) = v40;
  uint64_t v40 = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 152);
  *(_DWORD *)(v12 + 152) = v41;
  LODWORD(v41) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 156);
  *(_DWORD *)(v12 + 156) = DWORD1(v41);
  DWORD1(v41) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 160);
  *(_DWORD *)(v12 + 160) = DWORD2(v41);
  DWORD2(v41) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 164);
  *(_DWORD *)(v12 + 164) = HIDWORD(v41);
  HIDWORD(v41) = v18;
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(v12 + 176, (uint64_t)v43);
  *(void *)(v12 + 176) = &unk_26E6D0D68;
  *(void *)(v12 + 312) = 0;
  *(void *)(v12 + 320) = 0;
  *(void *)(v12 + 304) = 0;
  *(void *)(v12 + 312) = *((void *)&v52 + 1);
  *((void *)&v52 + 1) = 0;
  uint64_t v19 = *(void *)(v12 + 304);
  *(void *)(v12 + 304) = 0;
  *(void *)(v12 + 304) = v52;
  *(void *)&long long v52 = v19;
  uint64_t v20 = *(void *)(v12 + 320);
  *(void *)(v12 + 320) = v53;
  *(void *)&long long v53 = v20;
  *(void *)(v12 + 360) = 0;
  *(void *)(v12 + 336) = 0;
  *(void *)(v12 + 344) = 0;
  *(void *)(v12 + 328) = 0;
  *(_DWORD *)(v12 + 352) = 0;
  *(void *)(v12 + 328) = *((void *)&v53 + 1);
  *((void *)&v53 + 1) = 0;
  *(void *)(v12 + 336) = v54;
  *(void *)&long long v54 = 0;
  uint64_t v21 = *(void *)(v12 + 344);
  *(void *)(v12 + 344) = *((void *)&v54 + 1);
  *((void *)&v54 + 1) = v21;
  uint64_t v22 = *(void *)(v12 + 360);
  *(void *)(v12 + 360) = v56;
  uint64_t v56 = v22;
  ++v55;
  ++*(_DWORD *)(v12 + 352);
  LOWORD(v22) = v57;
  *(unsigned char *)(v12 + 370) = v58;
  *(_WORD *)(v12 + 368) = v22;
  *(void *)(v12 + 408) = 0;
  *(void *)(v12 + 384) = 0;
  *(void *)(v12 + 392) = 0;
  *(void *)(v12 + 376) = 0;
  *(_DWORD *)(v12 + 400) = 0;
  *(void *)(v12 + 376) = v59;
  uint64_t v59 = 0;
  *(void *)(v12 + 384) = v60;
  *(void *)&long long v60 = 0;
  uint64_t v23 = *(void *)(v12 + 392);
  *(void *)(v12 + 392) = *((void *)&v60 + 1);
  *((void *)&v60 + 1) = v23;
  uint64_t v24 = *(void *)(v12 + 408);
  *(void *)(v12 + 408) = v62;
  uint64_t v62 = v24;
  ++v61;
  ++*(_DWORD *)(v12 + 400);
  *(void *)(v12 + 416) = v63;
  if (v59)
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v59 + 40))();
    }
    uint64_t v62 = 0;
    long long v60 = 0uLL;
    uint64_t v59 = 0;
    ++v61;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v53 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v52);
  v43[0] = &unk_26E6D0DD8;
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)v49 + 8);
  v43[0] = &unk_26E6D3730;
  if ((void)v45)
  {
    if (BYTE8(v45)) {
      (*(void (**)(void))(*(void *)v45 + 40))();
    }
    long long v45 = 0u;
    long long v46 = 0u;
  }
  re::StringID::destroyString((re::StringID *)&v44);
  v25.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v38 + 1);
  if (*((void *)&v36 + 1))
  {
    if (v37)
    {
      (*(void (**)(double))(**((void **)&v36 + 1) + 40))(v25.n128_f64[0]);
      uint64_t v37 = 0;
      *(void *)&long long v38 = 0;
    }
    *((void *)&v36 + 1) = 0;
  }
  if (*((void *)&v34 + 1))
  {
    if (v35)
    {
      (*(void (**)(__n128))(**((void **)&v34 + 1) + 40))(v25);
      uint64_t v35 = 0;
      *(void *)&long long v36 = 0;
    }
    *((void *)&v34 + 1) = 0;
  }
  if (*((void *)&v32 + 1))
  {
    if (v33)
    {
      (*(void (**)(__n128))(**((void **)&v32 + 1) + 40))(v25);
      uint64_t v33 = 0;
      *(void *)&long long v34 = 0;
    }
    *((void *)&v32 + 1) = 0;
  }
  re::FixedArray<re::StringID>::deinit((void *)&v30 + 1);
  re::StringID::destroyString((re::StringID *)&v29);
  re::StringID::destroyString((re::StringID *)&v27);
  uint64_t v27 = *(void *)(a1 + 96) - 1;
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 112, a2, &v27);
}

void re::USDImportContext::addSkeletalAnimation(uint64_t a1, StringID *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  float v8 = *(float *)(a4 + 80);
  float v9 = *(float *)(a1 + 8);
  float v10 = *(float *)(a1 + 12);
  if (v9 > v8) {
    float v9 = *(float *)(a4 + 80);
  }
  *(float *)(a1 + 8) = v9;
  float v11 = *(float *)(a4 + 84);
  if (v10 < v11) {
    float v10 = *(float *)(a4 + 84);
  }
  *(float *)(a1 + 12) = v10;
  double v12 = v8;
  *(_DWORD *)(a4 + 80) = 0;
  *(float *)(a4 + 84) = v11 - v8;
  re::StringID::operator=((unint64_t *)(a4 + 24), a3);
  uint64_t v29 = *(void *)(a1 + 200);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 216, a2, &v29);
  uint64_t var1 = a2->var1;
  uint64_t v29 = *(void *)&a2->var0;
  long long v30 = var1;
  *(void *)&a2->var0 = 0;
  a2->uint64_t var1 = "";
  uint64_t v14 = (const char *)a3[1];
  uint64_t v31 = *a3;
  long long v32 = v14;
  *a3 = 0;
  a3[1] = (uint64_t)"";
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData((uint64_t)v33, a4);
  uint64_t v15 = *(void *)(a4 + 136);
  uint64_t v38 = *(void *)(a4 + 128);
  uint64_t v39 = v15;
  v33[0] = &unk_26E6D0D68;
  long long v16 = *(_OWORD *)(a4 + 144);
  long long v17 = *(_OWORD *)(a4 + 160);
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  long long v40 = v16;
  long long v41 = v17;
  *(_OWORD *)(a4 + 160) = 0u;
  uint64_t v43 = *(void *)(a4 + 184);
  *(void *)(a4 + 184) = 0;
  ++*(_DWORD *)(a4 + 176);
  int v42 = 1;
  LOWORD(v15) = *(_WORD *)(a4 + 192);
  char v45 = *(unsigned char *)(a4 + 194);
  __int16 v44 = v15;
  double v46 = v12;
  uint64_t v50 = 0;
  int v49 = 0;
  unint64_t v18 = *(void *)(a1 + 200);
  uint64_t v48 = 0;
  unint64_t v19 = *(void *)(a1 + 168);
  long long v47 = 0u;
  if (v18 + 1 > 8 * v19)
  {
    re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity((void *)(a1 + 160), (v18 + 8) >> 3);
    unint64_t v19 = *(void *)(a1 + 168);
  }
  if (v19 <= v18 >> 3)
  {
    uint64_t v51 = 0;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v52 = 136315906;
    long long v53 = "operator[]";
    __int16 v54 = 1024;
    int v55 = 858;
    __int16 v56 = 2048;
    unint64_t v57 = v18 >> 3;
    __int16 v58 = 2048;
    unint64_t v59 = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 176)) {
    uint64_t v20 = a1 + 184;
  }
  else {
    uint64_t v20 = *(void *)(a1 + 192);
  }
  uint64_t v21 = *(void *)(v20 + 8 * (v18 >> 3));
  ++*(void *)(a1 + 200);
  ++*(_DWORD *)(a1 + 208);
  uint64_t v22 = v21 + 280 * (v18 & 7);
  LOBYTE(v21) = v29;
  *(void *)uint64_t v22 = *(void *)v22 & 0xFFFFFFFFFFFFFFFELL | v29 & 1;
  *(void *)uint64_t v22 = v29 & 0xFFFFFFFFFFFFFFFELL | v21 & 1;
  *(void *)(v22 + 8) = v30;
  uint64_t v29 = 0;
  long long v30 = "";
  LOBYTE(v21) = v31;
  *(void *)(v22 + 16) = *(void *)(v22 + 16) & 0xFFFFFFFFFFFFFFFELL | v31 & 1;
  *(void *)(v22 + 16) = v31 & 0xFFFFFFFFFFFFFFFELL | v21 & 1;
  *(void *)(v22 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v32;
  uint64_t v31 = 0;
  long long v32 = "";
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(v22 + 32, (uint64_t)v33);
  *(void *)(v22 + 32) = &unk_26E6D0D68;
  *(void *)(v22 + 168) = 0;
  *(void *)(v22 + 176) = 0;
  *(void *)(v22 + 160) = 0;
  *(void *)(v22 + 168) = v39;
  uint64_t v39 = 0;
  uint64_t v23 = *(void *)(v22 + 160);
  *(void *)(v22 + 160) = 0;
  *(void *)(v22 + 160) = v38;
  uint64_t v38 = v23;
  uint64_t v24 = *(void *)(v22 + 176);
  *(void *)(v22 + 176) = v40;
  *(void *)&long long v40 = v24;
  *(void *)(v22 + 216) = 0;
  *(void *)(v22 + 192) = 0;
  *(void *)(v22 + 200) = 0;
  *(void *)(v22 + 184) = 0;
  *(_DWORD *)(v22 + 208) = 0;
  *(void *)(v22 + 184) = *((void *)&v40 + 1);
  *((void *)&v40 + 1) = 0;
  *(void *)(v22 + 192) = v41;
  *(void *)&long long v41 = 0;
  uint64_t v25 = *(void *)(v22 + 200);
  *(void *)(v22 + 200) = *((void *)&v41 + 1);
  *((void *)&v41 + 1) = v25;
  uint64_t v26 = *(void *)(v22 + 216);
  *(void *)(v22 + 216) = v43;
  uint64_t v43 = v26;
  ++v42;
  ++*(_DWORD *)(v22 + 208);
  LOWORD(v26) = v44;
  *(unsigned char *)(v22 + 226) = v45;
  *(_WORD *)(v22 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v26;
  *(double *)(v22 + 232) = v46;
  *(void *)(v22 + 272) = 0;
  *(void *)(v22 + 248) = 0;
  *(void *)(v22 + 256) = 0;
  *(void *)(v22 + 240) = 0;
  *(_DWORD *)(v22 + 264) = 0;
  *(void *)(v22 + 240) = v47;
  *(void *)&long long v47 = 0;
  *(void *)(v22 + 248) = *((void *)&v47 + 1);
  *((void *)&v47 + 1) = 0;
  uint64_t v27 = *(void *)(v22 + 256);
  *(void *)(v22 + 256) = v48;
  uint64_t v48 = v27;
  uint64_t v28 = *(void *)(v22 + 272);
  *(void *)(v22 + 272) = v50;
  uint64_t v50 = v28;
  ++v49;
  ++*(_DWORD *)(v22 + 264);
  if ((void)v47)
  {
    if (v28) {
      (*(void (**)(void))(*(void *)v47 + 40))();
    }
    uint64_t v50 = 0;
    uint64_t v48 = 0;
    long long v47 = 0uLL;
    ++v49;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v40 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v38);
  v33[0] = &unk_26E6D0DD8;
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v37);
  v33[0] = &unk_26E6D3730;
  if ((void)v35)
  {
    if (BYTE8(v35)) {
      (*(void (**)(void))(*(void *)v35 + 40))();
    }
    long long v35 = 0u;
    long long v36 = 0u;
  }
  re::StringID::destroyString((re::StringID *)&v34);
  re::StringID::destroyString((re::StringID *)&v31);
  re::StringID::destroyString((re::StringID *)&v29);
}

void re::USDImportContext::addPhysicsCollider(uint64_t a1, StringID *a2, uint64_t a3, long long *a4, int a5, char a6)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a5)
  {
    LOBYTE(v16[0]) = 1;
    re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<BOOL>(a1 + 472, a2, (unsigned __int8 *)v16);
  }
  uint64_t v11 = a1 + 368;
  v16[0] = *(void *)(a1 + 408);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 424, a2, v16);
  uint64_t v12 = *(void *)&a2->var0;
  uint64_t var1 = a2->var1;
  *(void *)&a2->var0 = 0;
  a2->uint64_t var1 = "";
  *(void *)&long long v17 = a3;
  long long v14 = a4[1];
  long long v18 = *a4;
  long long v19 = v14;
  char v20 = a6;
  uint64_t v15 = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::addUninitialized(v11);
  *(void *)uint64_t v15 = v12;
  *(void *)(v15 + 8) = var1;
  v16[0] = 0;
  v16[1] = "";
  *(_OWORD *)(v15 + 16) = v17;
  *(_OWORD *)(v15 + 32) = v18;
  *(_OWORD *)(v15 + 48) = v19;
  *(unsigned char *)(v15 + 64) = v20;
  re::StringID::destroyString((re::StringID *)v16);
}

uint64_t re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<BOOL>(uint64_t a1, StringID *a2, unsigned __int8 *a3)
{
  unint64_t v6 = 0xBF58476D1CE4E5B9 * ((*(void *)&a2->var0 >> 31) ^ (*(void *)&a2->var0 >> 1));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v7 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<BOOL>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(void *)(a1 + 16) + 32 * v12 + 24;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v11 = v10 + 32 * v9;
    if (re::StringID::operator==((void *)(v11 + 8), a2)) {
      return v11 + 24;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 32 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

void re::USDImportContext::addPhysicsRigidBody(uint64_t a1, StringID *a2, long long *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v5 = a1 + 520;
  v10[0] = *(void *)(a1 + 560);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 576, a2, v10);
  uint64_t v6 = *(void *)&a2->var0;
  uint64_t var1 = a2->var1;
  *(void *)&a2->var0 = 0;
  a2->uint64_t var1 = "";
  long long v8 = a3[1];
  long long v11 = *a3;
  long long v12 = v8;
  long long v13 = a3[2];
  LODWORD(v14) = *((_DWORD *)a3 + 12);
  uint64_t v9 = re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::addUninitialized(v5);
  *(void *)uint64_t v9 = v6;
  *(void *)(v9 + 8) = var1;
  v10[0] = 0;
  v10[1] = "";
  *(_OWORD *)(v9 + 16) = v11;
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v13;
  *(_OWORD *)(v9 + 64) = v14;
  re::StringID::destroyString((re::StringID *)v10);
}

uint64_t re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 152 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 152 * (a2 & 7);
}

unint64_t *re::USDImportContext::getPhysicsColliderData(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  uint64_t result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (void *)(v3 + 40));
  if (result) {
    return *(unint64_t **)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 16);
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 80 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 80 * (a2 & 7);
}

unint64_t *re::USDImportContext::getPhysicsColliderPose(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  uint64_t result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (void *)(v3 + 40));
  if (result) {
    return (unint64_t *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 32);
  }
  return result;
}

unint64_t *re::USDImportContext::getCollidesWithEnvironment(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  uint64_t result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (void *)(v3 + 40));
  if (result) {
    return (unint64_t *)(*(unsigned char *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 64) != 0);
  }
  return result;
}

unint64_t *re::USDImportContext::getPhysicsRigidBodyProperties(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  uint64_t result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 576, (void *)(v3 + 40));
  if (result) {
    return (unint64_t *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 520, *result)+ 16);
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContextBlendShapeData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[](a1, i);
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v4 + 13));
      re::FixedArray<CoreIKTransform>::deinit(v4 + 10);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 7);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 4);
      re::StringID::destroyString((re::StringID *)(v4 + 2));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::USDImportContextSkeletonData,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextSkeletonData,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](a1, i);
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v4 + 47));
      re::DynamicArray<re::StringID>::deinit((uint64_t)(v4 + 41));
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 + 38));
      v4[22] = (uint64_t)&unk_26E6D0DD8;
      re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)(v4 + 33));
      v4[22] = (uint64_t)&unk_26E6D3730;
      re::DynamicString::deinit((re::DynamicString *)(v4 + 27));
      re::StringID::destroyString((re::StringID *)(v4 + 25));
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v4 + 16);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 13);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 10);
      re::FixedArray<CoreIKTransform>::deinit(v4 + 7);
      re::FixedArray<re::StringID>::deinit(v4 + 4);
      re::StringID::destroyString((re::StringID *)(v4 + 2));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (void *)re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](a1, i);
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v4 + 30));
      re::DynamicArray<re::StringID>::deinit((uint64_t)(v4 + 23));
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 + 20));
      v4[4] = &unk_26E6D0DD8;
      re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)(v4 + 15));
      v4[4] = &unk_26E6D3730;
      re::DynamicString::deinit((re::DynamicString *)(v4 + 9));
      re::StringID::destroyString((re::StringID *)(v4 + 7));
      re::StringID::destroyString((re::StringID *)(v4 + 2));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::generatePerMeshCompileOptions@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_DWORD *)(a3 + 60) = 0x7FFFFFFF;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(void *)(a3 + 108) = 0x7FFFFFFFLL;
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(void *)(a3 + re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13) = *(void *)(a2 + 13);
  *(_OWORD *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  uint64_t v5 = a3 + 72;
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a3 + 24, a2 + 24);
  int v15 = 16842752;
  char v16 = 1;
  int v17 = 0;
  __int16 v18 = 0;
  int v19 = 1036831949;
  int v20 = 16843008;
  char v21 = 0;
  long long v23 = 0u;
  memset(v22, 0, sizeof(v22));
  DWORD1(v23) = 0x7FFFFFFF;
  if (*(void *)(a1 + 664))
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v6);
      if ((re::MeshCompileOptions::operator==((unsigned __int8 *)(v7 + 168), (unsigned __int8 *)&v15) & 1) == 0)
      {
        uint64_t v8 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v6);
        if ((re::MeshCompileOptions::operator==((unsigned __int8 *)(v8 + 168), (unsigned __int8 *)a2) & 1) == 0)
        {
          uint64_t v9 = (_anonymous_namespace_ *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v6);
          uint64_t v10 = (const char *)*((void *)v9 + 4);
          uint64_t v11 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v6);
          re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(v5, (re::DynamicString *)&v13, (long long *)(v11 + 168));
          if (v13)
          {
            if (v14) {
              (*(void (**)(void))(*(void *)v13 + 40))();
            }
          }
        }
      }
      ++v6;
    }
    while (*(void *)(a1 + 664) > v6);
  }
  return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v22);
}

uint64_t re::MeshCompileOptions::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2
    || a1[1] != a2[1]
    || a1[2] != a2[2]
    || a1[3] != a2[3]
    || a1[5] != a2[5]
    || a1[6] != a2[6]
    || a1[7] != a2[7]
    || a1[9] != a2[9]
    || a1[8] != a2[8]
    || a1[10] != a2[10]
    || *((float *)a1 + 3) != *((float *)a2 + 3)
    || !re::MeshModelIOLoadOptions::operator==(a1 + 16, a2 + 16))
  {
    return 0;
  }
  return re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator==((uint64_t)(a1 + 24), (uint64_t)(a2 + 24));
}

uint64_t re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(uint64_t a1, re::DynamicString *a2, long long *a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 120 * v11;
    return v12 + 48;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 120 * v9 + 16, (uint64_t)a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 120 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 120 * v9;
  return v12 + 48;
}

void re::USDImportContext::PhysicsColliderTable::~PhysicsColliderTable(re::USDImportContext::PhysicsColliderTable *this)
{
}

void *re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

re *re::internal::destroyPersistent<re::CollisionShapeData>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (re::StringID *)re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::USDImportContext::NodeStackItem::~NodeStackItem(re::USDImportContext::NodeStackItem *this)
{
  re::DynamicArray<re::GeomDeformer>::deinit((uint64_t)this + 1024);
  re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit((void *)this + 125);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 952);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 118);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  re::BucketArray<unsigned long,8ul>::deinit((uint64_t)this + 880);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 880);
  re::AssetHandle::~AssetHandle((re::USDImportContext::NodeStackItem *)((char *)this + 848));
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 808);
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 776));
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 744));
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 712));
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 648));
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 616));
  *((void *)this + 60) = &unk_26E6D0D28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 568);
  *((void *)this + 60) = &unk_26E6D3730;
  re::DynamicString::deinit((re::USDImportContext::NodeStackItem *)((char *)this + 520));
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 504));
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 51);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 368);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 328);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 288);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 24);
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 104);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 104);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 7);
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 40));
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 24));
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 8));
}

void *re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = v2 << 6;
      uint64_t v5 = (uint64_t *)(result[2] + 32);
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v5);
        v5 += 8;
        v4 -= 64;
      }
      while (v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<unsigned long,4ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 8 * (a2 & 3);
}

uint64_t re::SampledAnimationAssetData<re::GenericSRT<float>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 32);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a2 + 32) = "";
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v5;
  *(void *)(a1 + 32) = v6;
  v11[0] = v5 & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v11[1] = v8;
  re::StringID::destroyString((re::StringID *)v11);
  re::DynamicString::operator=((re::DynamicString *)(a1 + 40), (re::DynamicString *)(a2 + 40));
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  uint64_t v9 = *(void *)(a2 + 73);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 73) = v9;
  re::DynamicArray<re::AssetHandle>::operator=(a1 + 88, a2 + 88);
  return a1;
}

void re::GeomDeformer::~GeomDeformer(re::GeomDeformer *this)
{
  unint64_t v2 = (char *)this + 112;
  uint64_t v3 = (char *)this + 392;
  re::BucketArray<re::Matrix4x4<float>,8ul>::deinit((uint64_t)this + 392);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3);
  re::BucketArray<re::StringID,8ul>::deinit((uint64_t)this + 336);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 336);
  re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::deinit((uint64_t)this + 280);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 280);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)this + 224);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 224);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)this + 168);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 168);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)v2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  re::DynamicArray<re::GeomDeformer::Affector>::deinit((uint64_t)this + 72);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 32);
  re::StringID::destroyString((re::GeomDeformer *)((char *)this + 16));
  re::StringID::destroyString(this);
}

uint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + ((a2 & 7) << 6);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + ((a2 & 7) << 6);
}

uint64_t re::BucketArray<re::StringID,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, i);
      re::StringID::destroyString((re::StringID *)(v4 + 16));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, i);
      re::FixedArray<CoreIKTransform>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 24 * (a2 & 7);
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        do
        {
          re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        uint64_t v6 = (re::StringID *)(v3 + 8);
        do
        {
          re::StringID::destroyString(v6);
          uint64_t v6 = (re::StringID *)((char *)v6 + 40);
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(uint64_t a1, uint64_t a2)
{
  re::AnimationAssetData<re::SkeletalPoseAssetData>::AnimationAssetData(a1, a2);
  *(void *)uint64_t v3 = &unk_26E6D0DD8;
  uint64_t v4 = *(void *)(a2 + 73);
  *(void *)(v3 + 80) = *(void *)(a2 + 80);
  *(void *)(v3 + 88) = 0;
  *(void *)(v3 + 73) = v4;
  *(void *)(v3 + 120) = 0;
  *(_DWORD *)(v3 + 112) = 0;
  *(void *)(v3 + 96) = 0;
  *(void *)(v3 + 104) = 0;
  uint64_t v5 = *(void *)(a2 + 96);
  *(void *)(v3 + 88) = *(void *)(a2 + 88);
  *(void *)(v3 + 96) = v5;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  uint64_t v6 = *(void *)(v3 + 104);
  *(void *)(v3 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v6;
  uint64_t v7 = *(void *)(v3 + 120);
  *(void *)(v3 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = v7;
  ++*(_DWORD *)(a2 + 112);
  ++*(_DWORD *)(v3 + 112);
}

double re::AnimationAssetData<re::SkeletalPoseAssetData>::AnimationAssetData(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6D3730;
  uint64_t v2 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a2 + 32) = "";
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a2 + 64) = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  *(void *)(a2 + 48) = v8;
  *(void *)(a2 + 56) = v7;
  *(void *)a1 = &unk_26E6CF4A8;
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  return result;
}

BOOL re::MeshModelIOLoadOptions::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4];
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28)) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(a2 + 32);
  if (v2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(a2 + 16);
    while (1)
    {
      if ((*(_DWORD *)(v5 + 56 * v4 + 8) & 0x80000000) != 0)
      {
        if (!*(void *)a1) {
          break;
        }
        uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8)
                             + 4 * (*(void *)(v5 + 56 * v4) % (unint64_t)*(unsigned int *)(a1 + 24)));
        if (v6 == 0x7FFFFFFF) {
          break;
        }
        uint64_t v7 = *(void *)(a1 + 16);
        while (!re::DynamicString::operator==(v7 + 56 * v6 + 16, v5 + 56 * v4 + 16))
        {
          uint64_t v6 = *(_DWORD *)(v7 + 56 * v6 + 8) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF) {
            return 0;
          }
        }
        if (*(unsigned __int8 *)(v7 + 56 * v6 + 48) != *(unsigned __int8 *)(v5 + 56 * v4 + 48)
          || *(float *)(v7 + 56 * v6 + 52) != *(float *)(v5 + 56 * v4 + 52))
        {
          break;
        }
      }
      if (++v4 == v2) {
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

double re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 120;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::DynamicString::deinit((re::DynamicString *)(a1 + 16));
    return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 72));
  }
  return result;
}

void *re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          double result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 34304, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              double result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            double result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          int v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            int v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t *re::BucketArray<unsigned long,32ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 256, 0);
        double result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity((void *)a1, (v2 + 32) >> 5);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 5));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 1072 * (v2 & 0x1F);
}

uint64_t re::USDImportContext::NodeStackItem::NodeStackItem(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = *(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(void *)(a1 + 8) = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = "";
  uint64_t v5 = *(void *)(a2 + 24);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a2 + 32) = "";
  uint64_t v6 = *(void *)(a2 + 40);
  *(void *)(a1 + 40) = *(void *)(a1 + 40) & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(a1 + 40) = *(void *)(a2 + 40) & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = "";
  *(_DWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 92) = 0x7FFFFFFFLL;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v7;
  uint64_t v8 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a2 + 80) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 84) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 88) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 92) = v8;
  uint64_t v9 = a2 + 104;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v10 = a1 + 104;
  *(_DWORD *)(a1 + 120) = 1;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::DynamicOverflowArray((uint64_t)v43, a1 + 104);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(v10, v9);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(v9, (uint64_t)v43);
  if (v43[0] && (v44 & 1) == 0) {
    (*(void (**)(void))(*(void *)v43[0] + 40))();
  }
  uint64_t v11 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v11;
  ++*(_DWORD *)(a1 + 152);
  ++*(_DWORD *)(a2 + 152);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  long long v12 = *(_OWORD *)(a2 + 168);
  *(void *)(a1 + 181) = *(void *)(a2 + 181);
  *(_OWORD *)(a1 + 168) = v12;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 228) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 192), (uint64_t *)(a2 + 192));
  long long v13 = *(_OWORD *)(a2 + 240);
  long long v14 = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 272) = v14;
  *(_OWORD *)(a1 + 240) = v13;
  *(void *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(void *)(a2 + 288) = 0;
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a2 + 296) = 0;
  uint64_t v15 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(void *)(a2 + 304) = v15;
  uint64_t v16 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  *(void *)(a2 + 320) = v16;
  ++*(_DWORD *)(a2 + 312);
  ++*(_DWORD *)(a1 + 312);
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 328) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_DWORD *)(a1 + 352) = 0;
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  *(void *)(a2 + 328) = 0;
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(void *)(a2 + 336) = 0;
  uint64_t v17 = *(void *)(a1 + 344);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(void *)(a2 + 344) = v17;
  uint64_t v18 = *(void *)(a1 + 360);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(void *)(a2 + 360) = v18;
  ++*(_DWORD *)(a2 + 352);
  ++*(_DWORD *)(a1 + 352);
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_DWORD *)(a1 + 392) = 0;
  *(void *)(a1 + 368) = *(void *)(a2 + 368);
  *(void *)(a2 + 368) = 0;
  *(void *)(a1 + 376) = *(void *)(a2 + 376);
  *(void *)(a2 + 376) = 0;
  uint64_t v19 = *(void *)(a1 + 384);
  *(void *)(a1 + 384) = *(void *)(a2 + 384);
  *(void *)(a2 + 384) = v19;
  uint64_t v20 = *(void *)(a1 + 400);
  *(void *)(a1 + 400) = *(void *)(a2 + 400);
  *(void *)(a2 + 400) = v20;
  ++*(_DWORD *)(a2 + 392);
  ++*(_DWORD *)(a1 + 392);
  *(void *)(a1 + 408) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(void *)(a1 + 408) = *(void *)(a2 + 408);
  *(void *)(a2 + 408) = 0;
  *(void *)(a1 + 416) = *(void *)(a2 + 416);
  *(void *)(a2 + 416) = 0;
  uint64_t v21 = *(void *)(a1 + 424);
  *(void *)(a1 + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 424);
  *(void *)(a2 + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v21;
  long long v22 = *(_OWORD *)(a2 + 432);
  long long v23 = *(_OWORD *)(a2 + 464);
  *(_OWORD *)(a1 + 448) = *(_OWORD *)(a2 + 448);
  *(_OWORD *)(a1 + 464) = v23;
  *(_OWORD *)(a1 + 432) = v22;
  re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData(a1 + 480, a2 + 480);
  *(void *)(a1 + 480) = &unk_26E6D0CB8;
  *(void *)(a1 + 608) = *(void *)(a2 + 608);
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(void *)(a1 + 616) = *(void *)(a2 + 616);
  *(void *)(a2 + 616) = 0;
  uint64_t v24 = *(void *)(a1 + 632);
  *(void *)(a1 + 632) = *(void *)(a2 + 632);
  *(void *)(a2 + 632) = v24;
  *(void *)(a1 + 640) = *(void *)(a2 + 640);
  *(void *)(a2 + 640) = 0;
  uint64_t v25 = *(void *)(a1 + 624);
  *(void *)(a1 + 6re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 624);
  *(void *)(a2 + 6re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v25;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(void *)(a1 + 648) = *(void *)(a2 + 648);
  *(void *)(a2 + 648) = 0;
  uint64_t v26 = *(void *)(a1 + 664);
  *(void *)(a1 + 664) = *(void *)(a2 + 664);
  *(void *)(a2 + 664) = v26;
  *(void *)(a1 + 672) = *(void *)(a2 + 672);
  *(void *)(a2 + 672) = 0;
  uint64_t v27 = *(void *)(a1 + 656);
  *(void *)(a1 + 656) = *(void *)(a2 + 656);
  *(void *)(a2 + 656) = v27;
  long long v28 = *(_OWORD *)(a2 + 696);
  *(_OWORD *)(a1 + 680) = *(_OWORD *)(a2 + 680);
  *(_OWORD *)(a1 + 696) = v28;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(void *)(a1 + 712) = *(void *)(a2 + 712);
  *(void *)(a2 + 712) = 0;
  uint64_t v29 = *(void *)(a1 + 728);
  *(void *)(a1 + 728) = *(void *)(a2 + 728);
  *(void *)(a2 + 728) = v29;
  *(void *)(a1 + 736) = *(void *)(a2 + 736);
  *(void *)(a2 + 736) = 0;
  uint64_t v30 = *(void *)(a1 + 720);
  *(void *)(a1 + 720) = *(void *)(a2 + 720);
  *(void *)(a2 + 720) = v30;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(void *)(a1 + 744) = *(void *)(a2 + 744);
  *(void *)(a2 + 744) = 0;
  uint64_t v31 = *(void *)(a1 + 760);
  *(void *)(a1 + 760) = *(void *)(a2 + 760);
  *(void *)(a2 + 760) = v31;
  *(void *)(a1 + 768) = *(void *)(a2 + 768);
  *(void *)(a2 + 768) = 0;
  uint64_t v32 = *(void *)(a1 + 752);
  *(void *)(a1 + 752) = *(void *)(a2 + 752);
  *(void *)(a2 + 752) = v32;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(void *)(a1 + 776) = *(void *)(a2 + 776);
  *(void *)(a2 + 776) = 0;
  uint64_t v33 = *(void *)(a1 + 792);
  *(void *)(a1 + 792) = *(void *)(a2 + 792);
  *(void *)(a2 + 792) = v33;
  *(void *)(a1 + 800) = *(void *)(a2 + 800);
  *(void *)(a2 + 800) = 0;
  uint64_t v34 = *(void *)(a1 + 784);
  *(void *)(a1 + 784) = *(void *)(a2 + 784);
  *(void *)(a2 + 784) = v34;
  *(void *)(a1 + 840) = 0;
  *(_DWORD *)(a1 + 832) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(void *)(a1 + 808) = 0;
  *(void *)(a1 + 808) = *(void *)(a2 + 808);
  *(void *)(a2 + 808) = 0;
  *(void *)(a1 + 816) = *(void *)(a2 + 816);
  *(void *)(a2 + 816) = 0;
  uint64_t v35 = *(void *)(a1 + 824);
  *(void *)(a1 + 8re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 824);
  *(void *)(a2 + 8re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v35;
  uint64_t v36 = *(void *)(a1 + 840);
  *(void *)(a1 + 840) = *(void *)(a2 + 840);
  *(void *)(a2 + 840) = v36;
  ++*(_DWORD *)(a2 + 832);
  ++*(_DWORD *)(a1 + 832);
  *(void *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(void *)(a1 + 856) = *(void *)(a2 + 856);
  *(void *)(a2 + 856) = 0;
  uint64_t v37 = *(void *)(a1 + 848);
  *(void *)(a1 + 848) = 0;
  *(void *)(a1 + 848) = *(void *)(a2 + 848);
  *(void *)(a2 + 848) = v37;
  uint64_t v38 = *(void *)(a1 + 864);
  *(void *)(a1 + 864) = *(void *)(a2 + 864);
  *(void *)(a2 + 864) = v38;
  *(void *)(a1 + 872) = *(void *)(a2 + 872);
  *(_OWORD *)(a1 + 880) = 0u;
  *(_DWORD *)(a1 + 896) = 1;
  *(_DWORD *)(a1 + 928) = 0;
  *(_OWORD *)(a1 + 912) = 0u;
  *(void *)(a1 + 904) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(a1 + 880, a2 + 880);
  *(void *)(a1 + 936) = *(void *)(a2 + 936);
  *(void *)(a1 + 944) = *(void *)(a2 + 944);
  *(_OWORD *)(a2 + 936) = 0u;
  *(void *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 976) = 0;
  *(void *)(a1 + 968) = 0;
  *(void *)(a1 + 960) = 0;
  *(void *)(a1 + 952) = 0;
  *(void *)(a1 + 952) = *(void *)(a2 + 952);
  *(void *)(a2 + 952) = 0;
  *(void *)(a1 + 960) = *(void *)(a2 + 960);
  *(void *)(a2 + 960) = 0;
  uint64_t v39 = *(void *)(a1 + 968);
  *(void *)(a1 + 968) = *(void *)(a2 + 968);
  *(void *)(a2 + 968) = v39;
  uint64_t v40 = *(void *)(a1 + 984);
  *(void *)(a1 + 984) = *(void *)(a2 + 984);
  *(void *)(a2 + 984) = v40;
  ++*(_DWORD *)(a2 + 976);
  ++*(_DWORD *)(a1 + 976);
  *(void *)(a1 + 992) = *(void *)(a2 + 992);
  *(void *)(a1 + 1000) = 0;
  *(void *)(a1 + 1016) = 0;
  *(void *)(a1 + 1008) = 0;
  *(void *)(a1 + 1000) = *(void *)(a2 + 1000);
  *(void *)(a2 + 1000) = 0;
  *(void *)(a1 + 1008) = *(void *)(a2 + 1008);
  *(void *)(a2 + 1008) = 0;
  uint64_t v41 = *(void *)(a1 + 1016);
  *(void *)(a1 + 1016) = *(void *)(a2 + 1016);
  *(void *)(a2 + 1016) = v41;
  re::DynamicArray<re::GeomDeformer>::DynamicArray(a1 + 1024, (uint64_t *)(a2 + 1024));
  return a1;
}

void re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData(uint64_t a1, uint64_t a2)
{
  re::AnimationAssetData<re::GenericSRT<float>>::AnimationAssetData(a1, a2);
  *(void *)uint64_t v3 = &unk_26E6D0D28;
  uint64_t v4 = *(void *)(a2 + 73);
  *(void *)(v3 + 80) = *(void *)(a2 + 80);
  *(void *)(v3 + 88) = 0;
  *(void *)(v3 + 73) = v4;
  *(void *)(v3 + 120) = 0;
  *(_DWORD *)(v3 + 112) = 0;
  *(void *)(v3 + 96) = 0;
  *(void *)(v3 + 104) = 0;
  uint64_t v5 = *(void *)(a2 + 96);
  *(void *)(v3 + 88) = *(void *)(a2 + 88);
  *(void *)(v3 + 96) = v5;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  uint64_t v6 = *(void *)(v3 + 104);
  *(void *)(v3 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v6;
  uint64_t v7 = *(void *)(v3 + 120);
  *(void *)(v3 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = v7;
  ++*(_DWORD *)(a2 + 112);
  ++*(_DWORD *)(v3 + 112);
}

double re::AnimationAssetData<re::GenericSRT<float>>::AnimationAssetData(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6D3730;
  uint64_t v2 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a2 + 32) = "";
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a2 + 64) = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  *(void *)(a2 + 48) = v8;
  *(void *)(a2 + 56) = v7;
  *(void *)a1 = &unk_26E6CF3A0;
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomDeformer>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

re::GeomDeformer *re::DynamicArray<re::GeomDeformer>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>((uint64_t)&v10, *(void *)(a2 + 32), *(void *)(a2 + 32) + 448 * a1[2], a1[4]);
    double result = (re::GeomDeformer *)re::ObjectHelper::copyConstruct<re::GeomDeformer>(a1[4] + 448 * a1[2], *(void *)(a2 + 32) + 448 * a1[2], *(void *)(a2 + 32) + 448 * v4);
  }
  else
  {
    double result = (re::GeomDeformer *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>((uint64_t)&v9, *(void *)(a2 + 32), *(void *)(a2 + 32) + 448 * v4, a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      double result = (re::GeomDeformer *)(a1[4] + 448 * v4);
      uint64_t v7 = -448 * v4 + 448 * v6;
      do
      {
        re::GeomDeformer::~GeomDeformer(result);
        double result = (re::GeomDeformer *)(v8 + 448);
        v7 -= 448;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

void *re::DynamicArray<re::GeomDeformer>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::GeomDeformer>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x1C0uLL))
        {
          uint64_t v2 = 448 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 448 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 448, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 448 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::GeomDeformer::GeomDeformer(v11, v8);
          re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)v8);
          v8 += 56;
          v11 += 448;
          v10 -= 448;
        }
        while (v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::GeomDeformer::GeomDeformer(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)a1 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(void *)(a1 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  uint64_t v5 = a2[2];
  *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(void *)(a1 + 16) = a2[2] & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)"";
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v6 = a2[5];
  *(void *)(a1 + 32) = a2[4];
  *(void *)(a1 + 40) = v6;
  a2[4] = 0;
  a2[5] = 0;
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = a2[6];
  a2[6] = v7;
  uint64_t v8 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2[8];
  a2[8] = v8;
  ++*((_DWORD *)a2 + 14);
  ++*(_DWORD *)(a1 + 56);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  uint64_t v9 = a2[10];
  *(void *)(a1 + 72) = a2[9];
  *(void *)(a1 + 80) = v9;
  a2[9] = 0;
  a2[10] = 0;
  uint64_t v10 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = a2[11];
  a2[11] = v10;
  uint64_t v11 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = a2[13];
  a2[13] = v11;
  ++*((_DWORD *)a2 + 24);
  ++*(_DWORD *)(a1 + 96);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 128) = 1;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 112, (uint64_t)(a2 + 14));
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 1;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 168, (uint64_t)(a2 + 21));
  *(void *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 1;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 224, (uint64_t)(a2 + 28));
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 296) = 1;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 280, (uint64_t)(a2 + 35));
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 352) = 1;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 336, (uint64_t)(a2 + 42));
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 408) = 1;
  *(void *)(a1 + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 392, (uint64_t)(a2 + 49));
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::swap(uint64_t a1, uint64_t a2)
{
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::DynamicOverflowArray((uint64_t)v6, a1);
  re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(a1, a2);
  re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(a2, (uint64_t)v6);
  uint64_t result = v6[0];
  if (v6[0] && (v7 & 1) == 0) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v6[0] + 40))();
  }
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  ++*(_DWORD *)(a1 + 48);
  ++*(_DWORD *)(a2 + 48);
  return result;
}

uint64_t re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (*(void *)a1)
    {
      if (*(void *)a2 && *(void *)a1 != *(void *)a2)
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 527);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
    }
    if (*(unsigned char *)(a2 + 16))
    {
      if (*(void *)(a2 + 8))
      {
        re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::move(a1, a2);
      }
      else
      {
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
        *(void *)a1 = *(void *)a2;
        *(_DWORD *)(a2 + 16) += 2;
        *(_DWORD *)(a1 + 16) += 2;
      }
    }
    else
    {
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) += 2;
      re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::swap((uint64_t *)a1, (uint64_t *)a2);
    }
  }
  return a1;
}

uint64_t re::ObjectHelper::copyConstruct<re::GeomDeformer>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
    {
      re::StringID::StringID((re::StringID *)(v5 + v6), (const StringID *)(a2 + v6));
      re::StringID::StringID((re::StringID *)(v5 + v6 + 16), (const StringID *)(a2 + v6 + 16));
      re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(v5 + v6 + 32, (uint64_t *)(a2 + v6 + 32));
      re::DynamicArray<re::GeomDeformer::Affector>::DynamicArray(v5 + v6 + 72, (uint64_t *)(a2 + v6 + 72));
      re::BucketArray<re::FixedArray<int>,8ul>::BucketArray(v5 + v6 + 112, a2 + v6 + 112);
      re::BucketArray<re::FixedArray<float>,8ul>::BucketArray(v5 + v6 + 168, a2 + v6 + 168);
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArray(v5 + v6 + 224, a2 + v6 + 224);
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArray(v5 + v6 + 280, a2 + v6 + 280);
      re::BucketArray<re::StringID,8ul>::BucketArray(v5 + v6 + 336, a2 + v6 + 336);
      uint64_t result = re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArray(v5 + v6 + 392, a2 + v6 + 392);
      v6 += 448;
    }
    while (a2 + v6 != a3);
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::StringID::operator=((unint64_t *)(a4 + v7 + 16), (uint64_t *)(a2 + v7 + 16));
    re::DynamicArray<re::GeomDeformer::Attribute>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<re::GeomDeformer::Affector>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::BucketArray<re::FixedArray<int>,8ul>::operator=(a4 + v7 + 112, a2 + v7 + 112);
    re::BucketArray<re::FixedArray<float>,8ul>::operator=(a4 + v7 + 168, a2 + v7 + 168);
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator=(a4 + v7 + 224, a2 + v7 + 224);
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator=(a4 + v7 + 280, a2 + v7 + 280);
    re::BucketArray<re::StringID,8ul>::operator=(a4 + v7 + 336, a2 + v7 + 336);
    re::BucketArray<re::Matrix4x4<float>,8ul>::operator=(a4 + v7 + 392, a2 + v7 + 392);
    v7 += 448;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomDeformer::Attribute>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomDeformer::Attribute>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomDeformer::Attribute>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomDeformer::Affector>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomDeformer::Affector>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomDeformer::Affector>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::GeomDeformer::Attribute>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 40 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = v9 + 40 * v4;
      uint64_t v11 = 40 * v8 + 8;
      uint64_t v12 = v9 + v11;
      long long v13 = (re::StringID *)(a1[4] + v11);
      do
      {
        *((void *)v13 - 1) = *(void *)(v12 - 8);
        long long v14 = re::StringID::StringID(v13, (const StringID *)v12);
        *((_OWORD *)v14 + 1) = *(_OWORD *)(v12 + 16);
        uint64_t v15 = v12 + 32;
        v12 += 40;
        long long v13 = (re::StringID *)((char *)v14 + 40);
      }
      while (v15 != v10);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 40 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = 40 * v5 - 40 * v4;
      uint64_t v7 = (re::StringID *)(a1[4] + 40 * v4 + 8);
      do
      {
        re::StringID::destroyString(v7);
        uint64_t v7 = (re::StringID *)((char *)v7 + 40);
        v6 -= 40;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::GeomDeformer::Attribute>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 40 * v2;
    unint64_t v4 = (re::StringID *)(*(void *)(a1 + 32) + 8);
    do
    {
      re::StringID::destroyString(v4);
      unint64_t v4 = (re::StringID *)((char *)v4 + 40);
      v3 -= 40;
    }
    while (v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (void *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[5 * v9];
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = *v8;
          uint64_t v13 = v8[1];
          uint64_t v12 = v8 + 1;
          v11[1] = v11[1] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[1] = *v12 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          void v11[2] = v12[1];
          *uint64_t v12 = 0;
          v12[1] = "";
          *(_OWORD *)(v11 + 3) = *((_OWORD *)v12 + 1);
          re::StringID::destroyString((re::StringID *)v12);
          uint64_t v8 = v12 + 4;
          v11 += 5;
        }
        while (v8 != v10);
        uint64_t v8 = (void *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a1 + 8;
  do
  {
    *(void *)a3 = *(void *)(v5 - 8);
    re::StringID::operator=((unint64_t *)(a3 + 8), (uint64_t *)v5);
    *(_OWORD *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(_OWORD *)(v5 + 16);
    a3 += 40;
    uint64_t v6 = v5 + 32;
    v5 += 40;
  }
  while (v6 != v4);
  return v4;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = (uint64_t)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * a1[2]), a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = 5 * v9;
      uint64_t v11 = (uint64_t *)(*(void *)(a2 + 32) + 8 * v10);
      uint64_t result = a1[4] + 8 * v10;
      uint64_t v12 = 40 * v4 - 8 * v10;
      do
      {
        uint64_t v13 = re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(result, v11);
        v11 += 5;
        uint64_t result = v13 + 40;
        v12 -= 40;
      }
      while (v12);
    }
  }
  else
  {
    uint64_t result = (uint64_t)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 40 * v4), a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = a1[4] + 40 * v4;
      uint64_t v8 = 40 * v6 - 40 * v4;
      do
      {
        uint64_t result = re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v7);
        v7 += 40;
        v8 -= 40;
      }
      while (v8);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 40 * v2;
    do
    {
      uint64_t result = re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v3);
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

void *re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 40 * v9;
        uint64_t v11 = v7 + 4;
        do
        {
          *uint64_t v11 = 0;
          *(v11 - 3) = 0;
          *(v11 - 2) = 0;
          *(v11 - 4) = 0;
          *((_DWORD *)v11 - 2) = 0;
          uint64_t v12 = *(void *)(v8 + 8);
          *(v11 - 4) = *(void *)v8;
          *(v11 - 3) = v12;
          *(void *)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
          uint64_t v13 = *(v11 - 2);
          *(v11 - 2) = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v13;
          uint64_t v14 = *v11;
          *uint64_t v11 = *(void *)(v8 + 32);
          *(void *)(v8 + 32) = v14;
          ++*(_DWORD *)(v8 + 24);
          ++*((_DWORD *)v11 - 2);
          re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v8);
          v11 += 5;
          v8 += 40;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::DynamicArray<re::GeomDeformer::Attribute>::operator=(a3, v4);
      v4 += 5;
      a3 += 40;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer::Attribute>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<int>,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<float>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<float>,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::StringID,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::StringID,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::StringID,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::StringID,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::StringID,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::operator=(unint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::Matrix4x4<float>,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::Matrix4x4<float>,8ul>::init(a1, v4, *(void *)(a2 + 8));
      re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::BucketArray<re::FixedArray<int>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<int>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v14);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = v4 - v7;
    if (v4 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v11 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v11 = *(void *)(a1 + 32);
        }
        uint64_t v12 = (uint64_t *)(*(void *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        uint64_t v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<int>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        re::FixedArray<CoreIKTransform>::deinit(v6);
        ++v5;
      }
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      unint64_t v4 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](v1, i);
      uint64_t result = re::FixedArray<CoreIKTransform>::deinit(v4);
    }
  }
  *(void *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 192, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 24 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        uint64_t v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        uint64_t v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<int>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::FixedArray<float>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<float>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v14);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = v4 - v7;
    if (v4 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v11 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v11 = *(void *)(a1 + 32);
        }
        uint64_t v12 = (uint64_t *)(*(void *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        uint64_t v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<float>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        re::FixedArray<CoreIKTransform>::deinit(v6);
        ++v5;
      }
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

uint64_t *re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 192, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        uint64_t v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        uint64_t v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<float>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v14);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = v4 - v7;
    if (v4 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v11 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v11 = *(void *)(a1 + 32);
        }
        uint64_t v12 = (uint64_t *)(*(void *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        uint64_t v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<re::PackedFloat3>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        re::FixedArray<CoreIKTransform>::deinit(v6);
        ++v5;
      }
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

uint64_t *re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 192, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        uint64_t v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        uint64_t v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<re::PackedFloat3>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::FixedArray<re::PackedFloat3>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::MeshLodLevelInfo>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::PackedFloat3>::copy(a1, a2);
    }
  }
  return a1;
}

void *re::FixedArray<re::PackedFloat3>::copy(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      uint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 12 * v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::PackedFloat3>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::MeshLodLevelInfo>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::PackedFloat3>::copy(a1, a2);
  }
  return a1;
}

uint64_t *re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v14);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = v4 - v7;
    if (v4 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v11 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v11 = *(void *)(a1 + 32);
        }
        uint64_t v12 = *(void *)(v11 + 8 * (v10 >> 3)) + 32 * (v10 & 7);
        unint64_t v13 = (const StringID *)re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](a2, v10);
        re::StringID::StringID((re::StringID *)v12, v13);
        re::StringID::StringID((re::StringID *)(v12 + 16), v13 + 1);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, v5);
        re::StringID::destroyString((re::StringID *)(v6 + 16));
        re::StringID::destroyString((re::StringID *)v6);
        ++v5;
      }
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

void re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, i);
      re::StringID::destroyString((re::StringID *)(v4 + 16));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
}

uint64_t *re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 256, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 32 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        uint64_t v15 = (uint64_t *)re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](a1, a2);
        uint64_t v16 = (unint64_t *)re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a5, a6);
        uint64_t v17 = re::StringID::operator=(v16, v15);
        re::StringID::operator=(v17 + 2, v15 + 2);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::StringID,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::StringID,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::StringID,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::StringID,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v14);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = v4 - v7;
    if (v4 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v11 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v11 = *(void *)(a1 + 32);
        }
        uint64_t v12 = (re::StringID *)(*(void *)(v11 + 8 * (v10 >> 3)) + 16 * (v10 & 7));
        unint64_t v13 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](a2, v10);
        re::StringID::StringID(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
      {
        uint64_t v6 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, v5);
        re::StringID::destroyString(v6);
        ++v5;
      }
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

void re::BucketArray<re::StringID,8ul>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      unint64_t v4 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
}

uint64_t *re::BucketArray<re::StringID,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 128, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::StringID,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 16 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        uint64_t v15 = (uint64_t *)re::BucketArray<re::StringID,8ul>::operator[](a1, a2);
        uint64_t v16 = (unint64_t *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a5, a6);
        re::StringID::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::Matrix4x4<float>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::Matrix4x4<float>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a2 + 40);
  if (v4 >= *(void *)(a1 + 40))
  {
    re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(a2, 0, a2, *(void *)(a1 + 40), a1, 0, (uint64_t *)v16);
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = v4 - v6;
    if (v4 != v6)
    {
      uint64_t v8 = 0;
      do
      {
        unint64_t v9 = v8 + *(void *)(a1 + 40);
        if (*(void *)(a1 + 8) <= v9 >> 3)
        {
          memset(v16, 0, sizeof(v16));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
          uint64_t v10 = *(void *)(a1 + 32);
        }
        uint64_t v11 = (_OWORD *)(*(void *)(v10 + 8 * (v9 >> 3)) + ((v9 & 7) << 6));
        uint64_t v12 = (long long *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a2, v9);
        long long v13 = v12[3];
        long long v15 = *v12;
        long long v14 = v12[1];
        void v11[2] = v12[2];
        v11[3] = v13;
        *uint64_t v11 = v15;
        v11[1] = v14;
        ++v8;
      }
      while (v7 != v8);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(a2, 0, a2, *(void *)(a2 + 40), a1, 0, (uint64_t *)v16);
    if (v4 != *(void *)(a1 + 40))
    {
      unint64_t v5 = v4;
      do
        re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, v5++);
      while (v5 != *(void *)(a1 + 40));
    }
  }
  *(void *)(a1 + 40) = v4;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::clear(unint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      uint64_t result = re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](v1, i);
  }
  *(void *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 512, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v13 = a4 - 1;
    do
    {
      do
      {
        unint64_t v14 = a2;
        long long v15 = (long long *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, a2);
        uint64_t v16 = (_OWORD *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a5, a6);
        long long v17 = v15[3];
        long long v19 = *v15;
        long long v18 = v15[1];
        void v16[2] = v15[2];
        v16[3] = v17;
        *uint64_t v16 = v19;
        v16[1] = v18;
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer::Affector>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<int>,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<float>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<float>,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::StringID,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::StringID,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::StringID,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::BucketArray<re::Matrix4x4<float>,8ul>::init(a1, v4, *(void *)(a2 + 8));
    re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::make::shared::object<re::ShareableInternal<re::GeomModelDescriptor>,re::GeomModelDescriptor>(re *a1, uint64_t a2)
{
  uint64_t v4 = re::globalAllocators(a1);
  unint64_t v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 240, 8);
  ArcSharedObject::ArcSharedObject(v5, 0);
  *(void *)unint64_t v5 = &unk_26E6DF5C8;
  uint64_t result = re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)v5 + 24, a2);
  *(void *)a1 = v5;
  return result;
}

uint64_t *re::ShareableInternal<re::GeomModelDescriptor>::~ShareableInternal(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6DF5C8;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 26));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1 + 20);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)(a1 + 15));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1 + 9);
  uint64_t v2 = a1[8];
  if (v2)
  {

    a1[8] = 0;
  }
  uint64_t v3 = a1[7];
  if (v3)
  {

    a1[7] = 0;
  }
  uint64_t v4 = a1[4];
  if (v4)
  {

    a1[4] = 0;
  }
  *a1 = (uint64_t)&unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ShareableInternal<re::GeomModelDescriptor>::~ShareableInternal(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6DF5C8;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 26));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1 + 20);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)(a1 + 15));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1 + 9);
  uint64_t v2 = a1[8];
  if (v2)
  {

    a1[8] = 0;
  }
  uint64_t v3 = a1[7];
  if (v3)
  {

    a1[7] = 0;
  }
  uint64_t v4 = a1[4];
  if (v4)
  {

    a1[4] = 0;
  }
  *a1 = (uint64_t)&unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::GeomModelDescriptor::GeomModelDescriptor(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(unsigned char *)(a1 + 2) = *(unsigned char *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = (void *)(a2 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  uint64_t v5 = a2 + 48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 84) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 48), (uint64_t *)(a2 + 48));
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = 0;
  uint64_t v6 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v6;
  uint64_t v7 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v7;
  ++*(_DWORD *)(a2 + 120);
  ++*(_DWORD *)(a1 + 120);
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 172) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 136), (uint64_t *)(a2 + 136));
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(void *)(a2 + 184) = 0;
  uint64_t v8 = *(void *)(a1 + 200);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a2 + 200) = v8;
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a2 + 208) = 0;
  uint64_t v9 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(void *)(a2 + 192) = v9;
  *(_WORD *)a2 = 0;
  *(unsigned char *)(a2 + 2) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  uint64_t v10 = *(void *)(a2 + 8);
  if (v10)
  {

    *(void *)(a2 + 8) = 0;
  }
  *uint64_t v4 = 0;
  v4[1] = 0;
  uint64_t v11 = *(void *)(a2 + 32);
  if (v11)
  {

    *(void *)(a2 + 32) = 0;
  }
  uint64_t v12 = *(void *)(a2 + 40);
  if (v12)
  {

    *(void *)(a2 + 40) = 0;
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v5);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::clear(a2 + 96);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a2 + 136);
  v14[0] = "";
  v14[1] = 0;
  re::DynamicString::operator=((re::DynamicString *)(a2 + 184), (uint64_t)v14);
  return a1;
}

void re::DynamicArray<re::GeomModelDescriptor::AttributeData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    uint64_t v4 = 56 * v2;
    do
    {
      uint64_t v5 = *((void *)v3 + 6);
      if (v5)
      {

        *((void *)v3 + 6) = 0;
      }
      uint64_t v6 = *((void *)v3 + 5);
      if (v6)
      {

        *((void *)v3 + 5) = 0;
      }
      re::DynamicString::deinit(v3);
      uint64_t v3 = (re::DynamicString *)((char *)v3 + 56);
      v4 -= 56;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 56 * v4;
        do
        {
          uint64_t v6 = *((void *)v3 + 6);
          if (v6)
          {

            *((void *)v3 + 6) = 0;
          }
          uint64_t v7 = *((void *)v3 + 5);
          if (v7)
          {

            *((void *)v3 + 5) = 0;
          }
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<unsigned long,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

uint64_t *re::BucketArray<unsigned long,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 32, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    uint64_t result = (uint64_t *)re::BucketArray<unsigned long,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<unsigned long,32ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 32) >> 5);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 5));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 0x1F);
}

void *re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1216, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1696, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 2240, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          long long v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            long long v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<BOOL>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, unsigned __int8 *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 32 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 32 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 32 * v9 + 8), a4);
  uint64_t v15 = *(void *)(a1 + 8);
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *a5;
  *(_DWORD *)(v15 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity((void *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 & 7);
}

void *re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 640, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity((void *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 & 7);
}

void *re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 640, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, long long *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 120 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 120 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 120 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 120 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 120 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 120 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 120 * v10 + 16), a4);
  uint64_t v14 = *(void *)(a1 + 16) + 120 * v10;
  long long v15 = *a5;
  *(void *)(v14 + 61) = *(void *)((char *)a5 + 13);
  *(_OWORD *)(v14 + 48) = v15;
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v14 + 72, (uint64_t)a5 + 24);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v26, 0, 36);
      *(void *)&v26[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v26, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v26;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v26[8];
      *(_OWORD *)uint64_t v26 = v5;
      *(void *)&v26[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v26[24];
      *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v26[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (uint64_t *)(v6 + 72);
        do
        {
          if ((*(_DWORD *)(v14 - 8) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 9);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 120 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 120 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 120 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 120 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 120 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 120 * v18) = v15;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 120 * v18 + 16), (const re::DynamicString *)(v14 - 7));
            uint64_t v22 = *(void *)(a1 + 16) + 120 * v18;
            long long v23 = *(_OWORD *)(v14 - 3);
            uint64_t v24 = *(uint64_t *)((char *)v14 - 11);
            *(_OWORD *)(v22 + 72) = 0u;
            v22 += 72;
            *(void *)(v22 - 11) = v24;
            *(_OWORD *)(v22 - re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v23;
            *(_OWORD *)(v22 + 16) = 0u;
            *(_DWORD *)(v22 + 32) = 0;
            *(void *)(v22 + 36) = 0x7FFFFFFFLL;
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v22, v14);
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v1re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 15;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v26);
    }
  }
  else
  {
    if (a2) {
      signed int v25 = a2;
    }
    else {
      signed int v25 = 3;
    }
  }
}

void re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 120 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
  }
  return a1;
}

BOOL re::nameIsBlendShapeRoot(re *this, const char *a2)
{
  size_t v3 = strlen((const char *)this);
  return v3 >= 0xC && strcmp((const char *)this + v3 - 11, "_blendShape") == 0;
}

BOOL re::importModelBlendShapes(unsigned __int16 *a1)
{
  uint64_t v1 = a1;
  uint64_t v84 = *MEMORY[0x263EF8340];
  unint64_t v2 = a1[104];
  re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity(v1 + 14, v2);
  unint64_t v57 = (_anonymous_namespace_ *)(v1 + 14);
  ++*((_DWORD *)v1 + 34);
  unint64_t v59 = v2;
  if (v2)
  {
    unint64_t v3 = 0;
    __int16 v58 = (StringID *)v1;
    while (1)
    {
      uint64_t v4 = (unsigned char *)v1[26];
      if ((unint64_t)v4 <= v3) {
        goto LABEL_54;
      }
      unint64_t v5 = v1[28] + (v3 << 8);
      uint64_t v66 = 0;
      unint64_t v63 = 0;
      unint64_t v64 = 0;
      long long v62 = 0;
      int v65 = 0;
      uint64_t v6 = *(void *)(v5 + 16);
      if (v6)
      {
        uint64_t v7 = 0;
        unint64_t v8 = 0;
        uint64_t v9 = *(void *)(v5 + 32);
        uint64_t v10 = (int *)(v5 + 48);
        uint64_t v11 = 80 * v6;
        do
        {
          if (*(unsigned char *)(v9 + 8)) {
            int v12 = *(const char **)(v9 + 16);
          }
          else {
            int v12 = (const char *)(v9 + 9);
          }
          size_t v13 = strlen(v12);
          if (v13 >= 0x16)
          {
            uint64_t v14 = (_anonymous_namespace_ *)strcmp(&v12[v13 - 21], "|blendTargetPosDeltas");
            if (!v14)
            {
              int v15 = *v10;
              if (v8 >= v63)
              {
                unint64_t v16 = v8 + 1;
                if (v63 < v16)
                {
                  if (v62)
                  {
                    unint64_t v17 = 8;
                    if (v63) {
                      unint64_t v17 = 2 * v63;
                    }
                    if (v17 <= v16) {
                      unint64_t v18 = v16;
                    }
                    else {
                      unint64_t v18 = v17;
                    }
                    re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(&v62, v18);
                  }
                  else
                  {
                    re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(&v62, v16);
                    ++v65;
                  }
                }
                unint64_t v8 = v64;
                uint64_t v7 = v66;
              }
              uint64_t v19 = v7 + 56 * v8;
              *(_OWORD *)uint64_t v19 = 0u;
              *(_OWORD *)(v19 + 16) = 0u;
              *(void *)(v19 + 32) = v9;
              *(_WORD *)(v19 + 40) = v15;
              __int16 v20 = WORD2(v79);
              *(_DWORD *)(v19 + 42) = v79;
              *(_WORD *)(v19 + 46) = v20;
              *(void *)(v19 + 48) = 16;
              unint64_t v8 = ++v64;
              ++v65;
            }
          }
          v9 += 80;
          v11 -= 80;
        }
        while (v11);
        uint64_t v1 = v58;
        if (v8)
        {
          if (*v10) {
            break;
          }
        }
      }
LABEL_45:
      if (v62 && v66) {
        (*(void (**)(void))(*v62 + 40))();
      }
      if (++v3 == v59) {
        return v1[16] != 0;
      }
    }
    int v21 = re::StringID::StringID((re::StringID *)&v67, v58);
    memset(&v70[2], 0, 24);
    unint64_t v22 = 0;
    char v71 = 2;
    int v72 = *v10;
    __int16 v73 = v3;
    uint64_t v23 = v66;
    while (1)
    {
      uint64_t v4 = *(unsigned char **)&v70[10];
      if (*(void *)&v70[10] <= v22) {
        goto LABEL_53;
      }
      uint64_t v24 = v23 + 56 * v22;
      uint64_t v27 = *(void *)(v24 + 32);
      uint64_t v26 = (uint64_t *)(v24 + 32);
      uint64_t v25 = v27;
      if (*(unsigned char *)(v27 + 8)) {
        long long v28 = *(const char **)(v25 + 16);
      }
      else {
        long long v28 = (const char *)(v25 + 9);
      }
      unint64_t v29 = *(void *)&v70[18];
      uint64_t v30 = (void *)(*(void *)&v70[18] + 136 * v22);
      uint64_t v31 = (_anonymous_namespace_ *)strlen(v28);
      size_t v32 = (size_t)v31 - 21;
      if (BYTE8(v79)) {
        uint64_t v34 = (const char *)v80;
      }
      else {
        uint64_t v34 = (char *)&v79 + 9;
      }
      uint64_t v60 = 0;
      long long v61 = "";
      uint64_t v35 = v60;
      uint64_t v36 = v61;
      uint64_t v60 = 0;
      long long v61 = "";
      uint64_t v37 = v30[1];
      unint64_t v38 = v35 & 0xFFFFFFFFFFFFFFFELL | *v30 & 1;
      v30[1] = v36;
      *(void *)long long v74 = v38;
      *(void *)&v74[8] = v37;
      *uint64_t v30 = v35;
      re::StringID::destroyString((re::StringID *)v74);
      re::StringID::destroyString((re::StringID *)&v60);
      uint64_t v39 = (_anonymous_namespace_ *)v79;
      if (void)v79 && (BYTE8(v79)) {
        uint64_t v39 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v79 + 40))();
      }
      uint64_t v40 = (void *)(v29 + 136 * v22);
      v40[3] = 0;
      v40[9] = 0;
      v40[12] = 0;
      v40[15] = 0;
      uint64_t v44 = *v26;
      uint64_t v45 = *(unsigned __int16 *)(v23 + 56 * v22 + 40);
      double v46 = v40 + 5;
      uint64_t v47 = 3 * v45;
      if (v45) {
        break;
      }
LABEL_43:
      if (++v22 == v8)
      {
        re::DynamicArray<re::MeshAssetBlendShapeData>::add(v57, (uint64_t *)&v67);
        re::FixedArray<re::BlendShapeDefinition>::deinit(&v70[2]);
        re::StringID::destroyString((re::StringID *)&v67);
        uint64_t v1 = v58;
        goto LABEL_45;
      }
    }
    unint64_t v49 = 0;
    unint64_t v50 = v29 + 136 * v22;
    unint64_t v51 = *(void *)(v50 + 48);
    int v52 = (int *)(*(void *)(v44 + 64) + 8);
    long long v53 = (_DWORD *)(*(void *)(v50 + 56) + 4);
    while (v51 > v49)
    {
      int v55 = *(v52 - 1);
      int v54 = *v52;
      *(v53 - 1) = *(v52 - 2);
      unint64_t v29 = v49 + 1;
      if (v51 <= v49 + 1) {
        goto LABEL_51;
      }
      *long long v53 = v55;
      unint64_t v29 = v49 + 2;
      if (v51 <= v49 + 2) {
        goto LABEL_52;
      }
      v52 += 3;
      v53[1] = v54;
      v49 += 3;
      v53 += 3;
      if (v47 == v49) {
        goto LABEL_43;
      }
    }
    uint64_t v60 = 0;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v79 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v74 = 136315906;
    *(void *)&void v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    __int16 v75 = 2048;
    unint64_t v76 = v49;
    __int16 v77 = 2048;
    uint64_t v78 = (unsigned char *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    uint64_t v60 = 0;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v79 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v74 = 136315906;
    *(void *)&void v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    __int16 v75 = 2048;
    unint64_t v76 = v29;
    __int16 v77 = 2048;
    uint64_t v78 = (unsigned char *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    uint64_t v60 = 0;
    uint64_t v4 = v74;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v79 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v74 = 136315906;
    *(void *)&void v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    __int16 v75 = 2048;
    unint64_t v76 = v29;
    __int16 v77 = 2048;
    uint64_t v78 = (unsigned char *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    uint64_t v60 = 0;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v79 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v74 = 136315906;
    *(void *)&void v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    __int16 v75 = 2048;
    unint64_t v76 = v22;
    __int16 v77 = 2048;
    uint64_t v78 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    long long v62 = 0;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v79 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v67 = 136315906;
    int v68 = "operator[]";
    __int16 v69 = 1024;
    *(_DWORD *)unint64_t v70 = 789;
    *(_WORD *)&v70[4] = 2048;
    *(void *)&v70[6] = v3;
    *(_WORD *)&v70[14] = 2048;
    *(void *)&v70[16] = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v1[16] != 0;
}

BOOL re::objectIsBlendShapeRoot(re *this, MDLObject *a2)
{
  unint64_t v2 = this;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v4 = [(re *)v2 name];

  if (!v4) {
    uint64_t v4 = &stru_26E738380;
  }
  if (isKindOfClass)
  {
    unint64_t v5 = (re *)[(__CFString *)v4 UTF8String];
    BOOL IsBlendShapeRoot = re::nameIsBlendShapeRoot(v5, v6);
  }
  else
  {
    BOOL IsBlendShapeRoot = 0;
  }

  return IsBlendShapeRoot;
}

BOOL re::uskNodeIsBlendShapeRoot(void *a1)
{
  id v1 = a1;
  unint64_t v2 = [v1 type];
  unint64_t v3 = (void *)*MEMORY[0x263F83FF8];

  uint64_t v4 = [v1 name];

  unint64_t v5 = [v4 stringValue];

  if (!v5) {
    unint64_t v5 = &stru_26E738380;
  }
  if (v2 == v3)
  {
    uint64_t v7 = (re *)[(__CFString *)v5 UTF8String];
    BOOL IsBlendShapeRoot = re::nameIsBlendShapeRoot(v7, v8);
  }
  else
  {
    BOOL IsBlendShapeRoot = 0;
  }

  return IsBlendShapeRoot;
}

void *re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 56 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::TextureCompatibility::updateLegacyTextureSemantic(re::TextureCompatibility *this, const re::AssetHandle *a2, const re::StringID *a3, const re::AssetManager *a4, os_unfair_lock_s **a5, const re::RenderManager *a6, BOOL *a7, BOOL *a8)
{
  *a7 = 0;
  *(unsigned char *)a6 = 0;
  if (!*((void *)this + 1)) {
    return;
  }
  if (re::AssetManager::isDeviceAsset((uint64_t)a3, (uint64_t)this, 13)) {
    return;
  }
  if (!re::MaterialAsset::isColorTextureParameter(a2, v14)) {
    return;
  }
  int v15 = (re::TextureAsset *)re::AssetHandle::asset<re::TextureAsset>(this);
  if (!v15) {
    return;
  }
  uint64_t v16 = (uint64_t)v15;
  BOOL isLegacyLinearFormatWithSRGBData = re::TextureAsset::isLegacyLinearFormatWithSRGBData(v15);
  int v18 = *(_DWORD *)(v16 + 376);
  if (isLegacyLinearFormatWithSRGBData) {
    int v18 = re::translateLinearPixelFormatToSRGB(*(unsigned int *)(v16 + 376));
  }
  int v19 = *(_DWORD *)(v16 + 388);
  if (v19 == 6) {
    goto LABEL_10;
  }
  if (v19 != 3)
  {
    if (v19) {
      return;
    }
LABEL_10:
    if (re::StringID::operator==(a2, re::MaterialAsset::isHdrColorTextureParameter(re::StringID const&)::textureEmissive))
    {
      int v20 = 4;
    }
    else
    {
      int v20 = 3;
    }
    *(_DWORD *)(v16 + 388) = v20;
  }
  unint64_t v21 = *(void *)(v16 + 400);
  if (v21) {
    unint64_t v22 = v21 >> 1;
  }
  else {
    unint64_t v22 = v21 >> 1;
  }
  if (!v22)
  {
    CGColorSpaceNameForPixelFormat = (__CFString *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat(v18, 0);
    if (CGColorSpaceNameForPixelFormat) {
      re::TextureAsset::updateColorSpaceFromTexture((re::TextureAsset *)v16, a4, CGColorSpaceNameForPixelFormat);
    }
  }
  if (*(_DWORD *)(v16 + 240))
  {
    uint64_t v30 = std::__throw_bad_variant_access[abi:nn180100]();
    re::TextureData::TextureData(v30, v31, v32);
  }
  else
  {
    id v24 = *(id *)(v16 + 160);
    id v25 = *(id *)(v16 + 248);
    if (v24)
    {
      LOBYTE(v33[0]) = 0;
      if (re::ColorHelpers::getColorGamutFromCGColorSpaceName(v25, (char *)v33))
      {
        unsigned __int8 v26 = *((unsigned char *)a4 + 19) ? *((unsigned char *)a4 + 20) : 0;
        if (LOBYTE(v33[0]) != v26) {
          *(unsigned char *)a6 = 1;
        }
      }
      if (isLegacyLinearFormatWithSRGBData)
      {
        objc_msgSend(v24, sel_textureType);
        int isSupportedPixelFormat = re::isSupportedPixelFormat();
        if ((objc_msgSend(v24, sel_isShareable) & 1) == 0
          && isSupportedPixelFormat
          && (v28 = objc_msgSend(v24, sel_newTextureViewWithPixelFormat_, v18), (id v34 = v28) != 0))
        {
          unint64_t v29 = v28;
          re::TextureData::TextureData((uint64_t)v33, &v34, (__CFString *)*(id *)(v16 + 248));
          LOBYTE(v33[0]) = *(unsigned char *)(v16 + 152);
          re::TextureAsset::setTextureAndSemantic(v16, a4, (uint64_t)v33, *(_DWORD *)(v16 + 388));
          re::TextureData::~TextureData(v33);
        }
        else
        {
          *a7 = 1;
          if (!*(unsigned char *)a6) {
            re::TextureAsset::addLegacyLinearFormatWithSRGBDataTexture((os_unfair_lock_s **)v16, a5);
          }
        }
      }
    }
  }
}

uint64_t re::TextureData::TextureData(uint64_t a1, id *a2, __CFString *a3)
{
  *(unsigned char *)a1 &= 0x80u;
  *(void *)(a1 + 8) = *a2;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  re::TextureData::setColorSpace((id *)a1, a3);
  return a1;
}

uint64_t re::AssetHandle::asset<re::ImageBasedLightAsset>(re::ImageBasedLightAsset *a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = re::ImageBasedLightAsset::assetType(a1);
  uint64_t v3 = re::AssetHandle::assetWithType(a1, (const re::AssetType *)v2, 0);
  if (!v3)
  {
    uint64_t v4 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = v4;
      uint64_t v7 = re::AssetHandle::assetInfo(a1);
      if (v7[17]) {
        unint64_t v8 = (char *)v7[18];
      }
      else {
        unint64_t v8 = (char *)v7 + 137;
      }
      int v9 = 136315138;
      uint64_t v10 = v8;
      _os_log_error_impl(&dword_233120000, v6, OS_LOG_TYPE_ERROR, "Invalid asset: '%s'", (uint8_t *)&v9, 0xCu);
    }
  }
  return v3;
}

uint64_t re::TextureCompatibility::postProcessLoadedIBLAsset(re::TextureCompatibility *this, re::ImageBasedLightAsset *a2, const re::ImportGraphicsContext *a3)
{
  uint64_t v4 = this;
  uint64_t v28 = *MEMORY[0x263EF8340];
  unsigned __int8 v23 = 0;
  unint64_t v5 = *((void *)this + 10);
  unint64_t v6 = v5 >> 1;
  if ((v5 & 1) == 0) {
    unint64_t v6 = v5 >> 1;
  }
  if (v6)
  {
    if (v5) {
      uint64_t v7 = (const char *)*((void *)this + 11);
    }
    else {
      uint64_t v7 = (char *)this + 81;
    }
    CFStringRef v8 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    re::ColorHelpers::getColorGamutFromCGColorSpaceName(v8, (char *)&v23);
    CFRelease(v8);
    int v9 = v23;
  }
  else
  {
    int v9 = 0;
  }
  if (*((unsigned char *)a2 + 19)) {
    unsigned __int8 v10 = *((unsigned char *)a2 + 20);
  }
  else {
    unsigned __int8 v10 = 0;
  }
  if (v9 != v10)
  {
    if (*((void *)v4 + 1))
    {
      this = (re::TextureCompatibility *)re::TextureCompatibility::convertTextureAssetColorSpace(v4, (uint64_t)a2, 4, 1, 0);
      int v11 = (int)this;
    }
    else
    {
      int v11 = 1;
    }
    if (*((void *)v4 + 4))
    {
      uint64_t v12 = re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureCompatibility *)((char *)v4 + 24), (uint64_t)a2, 4, 1, 0);
      if (!v12) {
        int v11 = 0;
      }
    }
    else
    {
      size_t v13 = *re::assetsLogObjects(this);
      uint64_t v12 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Invalid ImageBasedLight asset: no diffuseTexture", buf, 2u);
      }
    }
    if (*((void *)v4 + 7))
    {
      uint64_t v14 = re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureCompatibility *)((char *)v4 + 48), (uint64_t)a2, 4, 1, 0);
      if ((v14 & 1) == 0)
      {
LABEL_27:
        unint64_t v17 = *re::assetsLogObjects((re *)v14);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = v17;
          int v19 = re::ColorHelpers::getColorGamutSerializationLiteral(re::ColorGamut const&)::kGamutToLiterals[v9];
          if (*((unsigned char *)a2 + 19)) {
            unsigned __int8 v20 = *((unsigned char *)a2 + 20);
          }
          else {
            unsigned __int8 v20 = 0;
          }
          unint64_t v21 = re::ColorHelpers::getColorGamutSerializationLiteral(re::ColorGamut const&)::kGamutToLiterals[v20];
          *(_DWORD *)buf = 136315394;
          id v25 = v19;
          __int16 v26 = 2080;
          uint64_t v27 = v21;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Failed to convert ImageBasedLight asset gamut from %s to %s", buf, 0x16u);
        }
        return 1;
      }
      uint64_t v15 = re::AssetHandle::asset<re::TextureAsset>((re::TextureCompatibility *)((char *)v4 + 48));
      uint64_t v14 = (uint64_t)re::DynamicString::operator=((re::TextureCompatibility *)((char *)v4 + 72), (re::DynamicString *)(v15 + 392));
    }
    else
    {
      uint64_t v16 = *re::assetsLogObjects((re *)v12);
      uint64_t v14 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_DEFAULT, "Invalid ImageBasedLight asset: no specularTexture", buf, 2u);
      }
    }
    if (v11) {
      return 1;
    }
    goto LABEL_27;
  }
  return 1;
}

uint64_t re::TextureCompatibility::convertTextureAssetColorSpace(re::TextureAsset *a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  unsigned __int8 v10 = (void *)MEMORY[0x237DBDCF0]();
  uint64_t v11 = re::AssetHandle::asset<re::TextureAsset>(a1);
  if (!v11
    || (uint64_t v12 = v11,
        size_t v13 = (id *)(v11 + 152),
        isValid = (re *)re::TextureData::isValid((re::TextureData *)(v11 + 152)),
        !isValid))
  {
    int v16 = 1;
LABEL_50:
    return v16 == 0;
  }
  v41[0] = 0;
  v42[0] = 0;
  unsigned int v43 = 0;
  id v44 = 0;
  if (a4)
  {
    buf[0] = 0;
    *(void *)&v47[4] = 0;
    unsigned int v48 = 0;
    id v49 = 0;
    if (!*(_DWORD *)(v12 + 240))
    {
      re::TextureHandle::unsynchronizedMetalTexture((os_unfair_lock_s **)(v12 + 136), &v40);
      id v15 = v40;
      if (v40) {
        goto LABEL_54;
      }
      if (a5)
      {
        if (*(_DWORD *)(v12 + 240)) {
          goto LABEL_51;
        }
        re::TextureAsset::createTextureSRGBAdaptor((id *)a2, (id *)(v12 + 160), 0, &v36);
      }
      else
      {
        re::TextureHandle::unsynchronizedMetalTexture((os_unfair_lock_s **)(v12 + 48), &v36);
      }
      NS::SharedPtr<MTL::Texture>::operator=(&v40, &v36);
      if (v36) {

      }
      id v15 = v40;
      if (v40)
      {
LABEL_54:
        if (*(_DWORD *)(v12 + 240)) {
          goto LABEL_51;
        }
        if (v15 == *(id *)(v12 + 160)) {
          goto LABEL_30;
        }
        id v23 = *(id *)(v12 + 248);
        LOBYTE(v36) = 0;
        v37[0] = v40;
        unsigned int v38 = 0;
        id v39 = v23;
        buf[0] = 0;
        std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&v47[4], (uint64_t)v37);
        id v24 = v39;
        id v39 = 0;
        id v25 = v49;
        id v49 = v24;

        if (v38 != -1) {
          ((void (*)(char *, void *))*(&off_26E6DF600 + v38))(&v45, v37);
        }
        buf[0] = *(unsigned char *)v13;
        id v15 = v40;
        size_t v13 = (id *)buf;
        if (v40) {
LABEL_30:
        }
      }
    }
    if (!v13[12]) {
      re::TextureData::setColorSpace(v13, (__CFString *)*MEMORY[0x263F00230]);
    }
    if (*(unsigned char *)(a2 + 19)) {
      unsigned __int8 v26 = *(unsigned char *)(a2 + 20);
    }
    else {
      unsigned __int8 v26 = 0;
    }
    re::convertTextureColorSpace(v26, (uint64_t)v13, (uint64_t)&v36);
    v41[0] = (_BYTE)v36;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v42, (uint64_t)v37);
    id v27 = v39;
    id v39 = 0;
    id v28 = v44;
    id v44 = v27;

    if (v38 != -1) {
      ((void (*)(id *, void *))*(&off_26E6DF600 + v38))(&v40, v37);
    }

    if (v48 != -1) {
      ((void (*)(id *, unsigned char *))*(&off_26E6DF600 + v48))(&v36, &v47[4]);
    }
  }
  else
  {
    if (!a5) {
      goto LABEL_47;
    }
    if (*(_DWORD *)(v12 + 240))
    {
      unint64_t v17 = *re::assetsLogObjects(isValid);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = v17;
        int v19 = re::AssetHandle::assetInfo(a1);
        if (v19[17]) {
          unsigned __int8 v20 = (char *)v19[18];
        }
        else {
          unsigned __int8 v20 = (char *)v19 + 137;
        }
        *(_DWORD *)buf = 136315138;
        *(void *)uint64_t v47 = v20;
        _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Texture %s conversion to sRGB transfer is not supported without Metal.", buf, 0xCu);
      }
    }
    else
    {
      re::TextureAsset::createTextureSRGBAdaptor((id *)a2, (id *)(v12 + 160), 1, &v36);
      buf[0] = 0;
      *(void *)&v47[4] = v36;
      unsigned int v48 = 0;
      id v49 = 0;
      v41[0] = 0;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v42, (uint64_t)&v47[4]);
      id v21 = v49;
      id v49 = 0;
      id v22 = v44;
      id v44 = v21;

      if (v48 != -1) {
        ((void (*)(id *, unsigned char *))*(&off_26E6DF600 + v48))(&v40, &v47[4]);
      }
      unsigned int v48 = -1;
      if (v36) {
    }
      }
  }
  if (!v43)
  {
    if (v42[0])
    {
LABEL_46:
      re::AssetHandle::AssetHandle((re::AssetHandle *)v35, a1);
      re::TextureAsset::setTextureAndSemantic_makeMutable((const re::ImportGraphicsContext *)a2, v35, (uint64_t)v41, a3, (long long *)(v12 + 8));
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v35);
      int v16 = 0;
      goto LABEL_48;
    }
LABEL_47:
    int v16 = 1;
LABEL_48:

    if (v43 != -1) {
      ((void (*)(uint8_t *, void *))*(&off_26E6DF600 + v43))(buf, v42);
    }
    goto LABEL_50;
  }
  if (v43 == 1)
  {
    int v16 = 1;
    if (!v42[3] || !v42[0]) {
      goto LABEL_48;
    }
    goto LABEL_46;
  }
LABEL_51:
  uint64_t v30 = (re::TextureCompatibility *)std::__throw_bad_variant_access[abi:nn180100]();
  return re::TextureCompatibility::postProcessLoadedTextures(v30, v31, v32, v33, v34);
}

void re::TextureCompatibility::postProcessLoadedTextures(re::TextureCompatibility *this, re::ecs2::Scene *a2, const re::AssetManager *a3, const re::RenderManager *a4)
{
  int v121 = (int)a4;
  uint64_t v158 = *MEMORY[0x263EF8340];
  re::ImportGraphicsContext::createFromRenderManager(a3, (re::ImportGraphicsContext *)v140);
  float v139 = 0;
  v136[1] = 0;
  uint64_t v137 = 0;
  v136[0] = 0;
  int v138 = 0;
  LODWORD(v156) = 0;
  *(_OWORD *)buf = 0u;
  long long v155 = 0u;
  *(void *)((char *)&v156 + 4) = 0x7FFFFFFFLL;
  int v150 = 0;
  long long v148 = 0u;
  long long v149 = 0u;
  uint64_t v151 = 0x7FFFFFFFLL;
  uint64_t v120 = (re::TextureCompatibility *)((char *)this + 200);
  uint64_t v6 = re::ecs2::SceneComponentTable::get((re::TextureCompatibility *)((char *)this + 200), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  uint64_t v7 = *(void *)(v6 + 24);
  if (v7)
  {
    uint64_t v124 = 0;
    uint64_t v126 = 0;
    int v125 = 0;
    unsigned int v128 = 0;
    uint64_t v131 = 0;
    uint64_t v132 = 0;
    uint64_t v8 = 0;
    uint64_t v129 = 0;
    uint64_t v9 = 0;
    unsigned __int8 v10 = *(void **)(v6 + 40);
    uint64_t v122 = &v10[v7];
    do
    {
      float v123 = v10;
      uint64_t v11 = *v10;
      uint64_t v12 = *(void *)(v11 + 72);
      if (v12)
      {
        size_t v13 = *(const re::AssetHandle **)(v11 + 88);
        uint64_t v14 = (const re::AssetHandle *)((char *)v13 + 24 * v12);
        float v127 = v14;
        do
        {
          re::AssetHandle::AssetHandle((re::AssetHandle *)v145, v13);
          if (v145[1])
          {
            unint64_t v15 = re::AssetHandle::asset<re::MaterialAsset>((re::MaterialAsset *)v145);
            if (v15)
            {
              unint64_t v16 = v15;
              unint64_t v17 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
              unint64_t v18 = v17 ^ (v17 >> 31);
              uint64_t v19 = v132;
              if (v9)
              {
                unint64_t v20 = v18 % v9;
                for (uint64_t i = *(unsigned int *)(v129 + 4 * v20);
                      i != 0x7FFFFFFF;
                      LODWORD(i) = *(_DWORD *)(v8 + 24 * i + 8) & 0x7FFFFFFF)
                {
                  if (*(void *)(v8 + 24 * i + 16) == v15) {
                    goto LABEL_67;
                  }
                }
                unint64_t v22 = v18 % v9;
                for (uint64_t j = *(unsigned int *)(v131 + 4 * v20);
                      j != 0x7FFFFFFF;
                      LODWORD(j) = *(_DWORD *)(v132 + 24 * j + 8) & 0x7FFFFFFF)
                {
                  if (*(void *)(v132 + 24 * j + 16) == v15)
                  {
                    uint64_t v130 = v9;
                    goto LABEL_23;
                  }
                }
              }
              else
              {
                unint64_t v22 = 0;
              }
              uint64_t v24 = DWORD1(v156);
              if (DWORD1(v156) == 0x7FFFFFFF)
              {
                unsigned int v25 = v128;
                unsigned int v26 = v128;
                if (v128 == v9)
                {
                  re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity((uint64_t)buf, 2 * v125);
                  uint64_t v9 = DWORD2(v155);
                  unsigned int v26 = v156;
                  unint64_t v22 = v18 % DWORD2(v155);
                  uint64_t v19 = v155;
                  uint64_t v124 = *(void *)&buf[8];
                }
                unsigned int v27 = v26 + 1;
                LODWORD(v156) = v27;
                uint64_t v24 = v128;
                int v28 = *(_DWORD *)(v19 + 24 * v128 + 8);
                uint64_t v29 = v124;
              }
              else
              {
                int v28 = *(_DWORD *)(v132 + 24 * DWORD1(v156) + 8);
                DWORD1(v156) = v28 & 0x7FFFFFFF;
                unsigned int v27 = v128;
                unsigned int v25 = v24;
                uint64_t v29 = v126;
              }
              uint64_t v130 = v9;
              uint64_t v30 = 3 * v24;
              *(_DWORD *)(v19 + 8 * v30 + 8) = v28 | 0x80000000;
              uint64_t v131 = v29;
              uint64_t v132 = v155;
              uint64_t v31 = v155 + 8 * v30;
              *(_DWORD *)(v31 + 8) = *(_DWORD *)(v31 + 8) & 0x80000000 | *(_DWORD *)(v29 + 4 * v22);
              *(void *)uint64_t v31 = v18;
              *(void *)(v31 + 16) = v16;
              *(_DWORD *)(v29 + 4 * v22) = v25;
              int v125 = ++HIDWORD(v155);
              ++DWORD2(v156);
              unsigned int v128 = v27;
              uint64_t v126 = v29;
LABEL_23:
              uint64_t v32 = *(unsigned int *)(v16 + 192);
              if (v32)
              {
                uint64_t v33 = 0;
                BOOL v34 = (int *)(*(void *)(v16 + 176) + 8);
                while (1)
                {
                  int v35 = *v34;
                  v34 += 22;
                  if (v35 < 0) {
                    break;
                  }
                  if (v32 == ++v33)
                  {
                    LODWORD(v33) = *(_DWORD *)(v16 + 192);
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v33) = 0;
              }
              if (v32 != v33)
              {
                uint64_t v36 = v33;
                unsigned int v37 = *(_DWORD *)(v16 + 192);
                do
                {
                  uint64_t v38 = *(void *)(v16 + 176);
                  uint64_t v39 = v38 + 88 * v36;
                  if (*(_DWORD *)(v39 + 80) == 1)
                  {
                    id v40 = (re::TextureCompatibility *)(v39 + 48);
                    v152[0] = 0;
                    v147[0] = 0;
                    re::StringID::StringID((re::StringID *)&v141, (const re::DynamicString *)(v38 + 88 * v36 + 16));
                    re::TextureCompatibility::updateLegacyTextureSemantic(v40, (const re::AssetHandle *)&v141, a2, (const re::AssetManager *)v140, (os_unfair_lock_s **)a3, (const re::RenderManager *)v152, v147, v41);
                    re::StringID::destroyString((re::StringID *)&v141);
                    uint8_t v42 = v152[0];
                    BOOL v43 = v147[0];
                    if (v152[0] | v147[0])
                    {
                      *(void *)&long long v135 = re::AssetHandle::asset<re::TextureAsset>(v40);
                      if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v148, v135))
                      {
                        re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v148, (uint64_t *)&v135);
                        uint64_t v141 = 0;
                        uint64_t v142 = 0;
                        uint64_t v143 = 0;
                        re::AssetHandle::operator=((uint64_t)&v141, (uint64_t *)v40);
                        LOBYTE(v144) = v42;
                        HIBYTE(v144) = v43;
                        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v136, (re::AssetHandle *)&v141);
                        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v141);
                      }
                    }
                    unsigned int v37 = *(_DWORD *)(v16 + 192);
                  }
                  if (v37 <= (int)v33 + 1) {
                    unsigned int v44 = v33 + 1;
                  }
                  else {
                    unsigned int v44 = v37;
                  }
                  while (1)
                  {
                    uint64_t v36 = (v33 + 1);
                    if (v44 - 1 == v33) {
                      break;
                    }
                    LODWORD(v33) = v33 + 1;
                    unsigned int v45 = v36;
                    if ((*(_DWORD *)(*(void *)(v16 + 176) + 88 * v36 + 8) & 0x80000000) != 0) {
                      goto LABEL_43;
                    }
                  }
                  unsigned int v45 = v44;
LABEL_43:
                  LODWORD(v33) = v45;
                }
                while (v32 != v45);
              }
              uint64_t v46 = *(unsigned int *)(v16 + 240);
              if (v46)
              {
                uint64_t v47 = 0;
                unsigned int v48 = (int *)(*(void *)(v16 + 224) + 8);
                uint64_t v8 = v132;
                while (1)
                {
                  int v49 = *v48;
                  v48 += 40;
                  if (v49 < 0) {
                    break;
                  }
                  if (v46 == ++v47)
                  {
                    LODWORD(v4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = *(_DWORD *)(v16 + 240);
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
                uint64_t v8 = v132;
              }
              if (v46 != v47)
              {
                uint64_t v50 = v47;
                unsigned int v51 = *(_DWORD *)(v16 + 240);
                do
                {
                  uint64_t v52 = *(void *)(v16 + 224);
                  uint64_t v53 = v52 + 160 * v50;
                  if (*(_DWORD *)(v53 + 80) == 1)
                  {
                    int v54 = (re::TextureCompatibility *)(v53 + 48);
                    v152[0] = 0;
                    v147[0] = 0;
                    re::StringID::StringID((re::StringID *)&v141, (const re::DynamicString *)(v52 + 160 * v50 + 16));
                    re::TextureCompatibility::updateLegacyTextureSemantic(v54, (const re::AssetHandle *)&v141, a2, (const re::AssetManager *)v140, (os_unfair_lock_s **)a3, (const re::RenderManager *)v152, v147, v55);
                    re::StringID::destroyString((re::StringID *)&v141);
                    uint8_t v56 = v152[0];
                    BOOL v57 = v147[0];
                    if (v152[0] | v147[0])
                    {
                      *(void *)&long long v135 = re::AssetHandle::asset<re::TextureAsset>(v54);
                      if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v148, v135))
                      {
                        re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v148, (uint64_t *)&v135);
                        uint64_t v141 = 0;
                        uint64_t v142 = 0;
                        uint64_t v143 = 0;
                        re::AssetHandle::operator=((uint64_t)&v141, (uint64_t *)v54);
                        LOBYTE(v144) = v56;
                        HIBYTE(v144) = v57;
                        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v136, (re::AssetHandle *)&v141);
                        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v141);
                      }
                    }
                    unsigned int v51 = *(_DWORD *)(v16 + 240);
                  }
                  if (v51 <= (int)v47 + 1) {
                    unsigned int v58 = v47 + 1;
                  }
                  else {
                    unsigned int v58 = v51;
                  }
                  while (1)
                  {
                    uint64_t v50 = (v47 + 1);
                    if (v58 - 1 == v47) {
                      break;
                    }
                    LODWORD(v4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v47 + 1;
                    unsigned int v59 = v50;
                    if ((*(_DWORD *)(*(void *)(v16 + 224) + 160 * v50 + 8) & 0x80000000) != 0) {
                      goto LABEL_64;
                    }
                  }
                  unsigned int v59 = v58;
LABEL_64:
                  LODWORD(v4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v59;
                }
                while (v46 != v59);
                uint64_t v8 = v132;
              }
              uint64_t v9 = v130;
              uint64_t v129 = v131;
LABEL_67:
              uint64_t v14 = v127;
            }
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v145);
          size_t v13 = (const re::AssetHandle *)((char *)v13 + 24);
        }
        while (v13 != v14);
      }
      unsigned __int8 v10 = v123 + 1;
    }
    while (v123 + 1 != v122);
  }
  uint64_t v60 = re::ecs2::SceneComponentTable::get(v120, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::MaterialParameterBlockArrayComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  uint64_t v61 = *(void *)(v60 + 24);
  if (v61)
  {
    long long v62 = *(void ***)(v60 + 40);
    uint64_t v133 = &v62[v61];
    do
    {
      uint64_t v63 = (uint64_t)*v62;
      re::ecs2::MaterialParameterBlockArrayComponent::upgradeBlocksToBlockHandles(*v62);
      uint64_t v64 = *(void *)(v63 + 48);
      if (v64)
      {
        int v65 = *(uint64_t **)(v63 + 64);
        uint64_t v66 = &v65[3 * v64];
        do
        {
          uint64_t v67 = *v65;
          if (!*v65) {
            uint64_t v67 = v65[1];
          }
          uint64_t v68 = *(unsigned int *)(v67 + 336);
          if (v68)
          {
            uint64_t v69 = 0;
            unint64_t v70 = *(_DWORD **)(v67 + 320);
            while ((*v70 & 0x80000000) == 0)
            {
              v70 += 80;
              if (v68 == ++v69)
              {
                LODWORD(v69) = *(_DWORD *)(v67 + 336);
                break;
              }
            }
          }
          else
          {
            LODWORD(v69) = 0;
          }
          if (v68 != v69)
          {
            uint64_t v71 = v69;
            unsigned int v72 = *(_DWORD *)(v67 + 336);
            do
            {
              uint64_t v73 = *(void *)(v67 + 320);
              if (*(unsigned char *)(v73 + 320 * v71 + 32) == 64)
              {
                uint64_t v74 = v73 + 320 * v71;
                __int16 v75 = (const re::AssetHandle *)(v74 + 8);
                re::AssetHandle::AssetHandle((re::AssetHandle *)v145, (const re::AssetHandle *)(v74 + 112));
                v152[0] = 0;
                v147[0] = 0;
                re::TextureCompatibility::updateLegacyTextureSemantic((re::TextureCompatibility *)v145, v75, a2, (const re::AssetManager *)v140, (os_unfair_lock_s **)a3, (const re::RenderManager *)v152, v147, v76);
                uint8_t v77 = v152[0];
                BOOL v78 = v147[0];
                if (v152[0] | v147[0])
                {
                  *(void *)&long long v135 = re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)v145);
                  if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v148, v135))
                  {
                    re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v148, (uint64_t *)&v135);
                    uint64_t v141 = 0;
                    uint64_t v142 = 0;
                    uint64_t v143 = 0;
                    re::AssetHandle::operator=((uint64_t)&v141, v145);
                    LOBYTE(v144) = v77;
                    HIBYTE(v144) = v78;
                    re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v136, (re::AssetHandle *)&v141);
                    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v141);
                  }
                }
                re::AssetHandle::~AssetHandle((re::AssetHandle *)v145);
                unsigned int v72 = *(_DWORD *)(v67 + 336);
              }
              if (v72 <= (int)v69 + 1) {
                unsigned int v79 = v69 + 1;
              }
              else {
                unsigned int v79 = v72;
              }
              while (1)
              {
                uint64_t v71 = (v69 + 1);
                if (v79 - 1 == v69) {
                  break;
                }
                LODWORD(v69) = v69 + 1;
                unsigned int v80 = v71;
                if ((*(_DWORD *)(*(void *)(v67 + 320) + 320 * v71) & 0x80000000) != 0) {
                  goto LABEL_98;
                }
              }
              unsigned int v80 = v79;
LABEL_98:
              LODWORD(v69) = v80;
            }
            while (v68 != v80);
          }
          v65 += 3;
        }
        while (v65 != v66);
      }
      ++v62;
    }
    while (v62 != v133);
  }
  uint64_t v81 = re::ecs2::SceneComponentTable::get(v120, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::ImageBasedLightComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  uint64_t v82 = *(void *)(v81 + 24);
  if (v82)
  {
    uint64_t v83 = *(void *)(v81 + 40);
    uint64_t v84 = 8 * v82;
    do
    {
      long long v85 = *(void **)v83;
      if (*(void *)(*(void *)v83 + 96))
      {
        long long v86 = (re::TextureCompatibility *)re::AssetHandle::asset<re::ImageBasedLightAsset>((re::ImageBasedLightAsset *)(v85 + 11));
        re::TextureCompatibility::postProcessLoadedIBLAsset(v86, (re::ImageBasedLightAsset *)v140, v87);
      }
      if (v85[15])
      {
        int v88 = (re::TextureCompatibility *)re::AssetHandle::asset<re::ImageBasedLightAsset>((re::ImageBasedLightAsset *)(v85 + 14));
        re::TextureCompatibility::postProcessLoadedIBLAsset(v88, (re::ImageBasedLightAsset *)v140, v89);
      }
      v83 += 8;
      v84 -= 8;
    }
    while (v84);
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v148);
  v90.n128_f64[0] = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)buf);
  uint64_t v91 = v137;
  if (v137)
  {
    uint64_t v92 = v139;
    char v93 = (re::AssetHandle *)((char *)v139 + 32 * v137);
    uint64_t v94 = v139;
    do
    {
      uint64_t v95 = re::AssetHandle::AssetHandle((re::AssetHandle *)buf, v94);
      WORD4(v155) = *((_WORD *)v94 + 12);
      uint64_t v96 = re::AssetHandle::asset<re::TextureAsset>(v95);
      re::TextureHandle::unsafeReleaseMetalTextures((os_unfair_lock_s **)(v96 + 48));
      if (BYTE8(v155)) {
        BOOL v97 = BYTE9(v155) == 0;
      }
      else {
        BOOL v97 = 1;
      }
      if (v97) {
        re::TextureHandle::unsafeReleaseMetalTextures((os_unfair_lock_s **)(v96 + 136));
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
      uint64_t v94 = (re::AssetHandle *)((char *)v94 + 32);
    }
    while (v94 != v93);
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v141, v92);
      __int16 v144 = *((_WORD *)v92 + 12);
      uint64_t v98 = re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)&v141);
      uint64_t v157 = 0;
      long long v155 = 0u;
      long long v156 = 0u;
      *(_OWORD *)buf = 0u;
      MTLPixelFormatGetInfoForDevice();
      if (*(_DWORD *)(v98 + 240)) {
LABEL_149:
      }
        std::__throw_bad_variant_access[abi:nn180100]();
      __int16 v99 = *(_WORD *)&buf[8];
      id v100 = *(id *)(v98 + 160);
      re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureAsset *)&v141, (uint64_t)v140, *(_DWORD *)(v98 + 388), v144, HIBYTE(v144));
      if (v100) {

      }
      if ((v99 & 0x400) != 0
        && v121
        && ((uint64_t (*)(uint64_t, void, void, uint64_t))re::shouldASTCCompress)(v98 + 152, *(unsigned int *)(v98 + 388), *(unsigned int *)(v98 + 20), v98 + 24))
      {
        if (*(_DWORD *)(v98 + 240)) {
          goto LABEL_149;
        }
        id v101 = *(id *)(v98 + 160);
        *(void *)&long long v135 = 1;
        BYTE8(v135) = 0;
        HIDWORD(v135) = 0;
        uint64_t isValid = re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)&v141);
        *(void *)float v147 = isValid;
        if (!isValid) {
          goto LABEL_130;
        }
        uint64_t v103 = isValid;
        uint64_t v104 = isValid + 152;
        uint64_t isValid = re::TextureData::isValid((re::TextureData *)(isValid + 152));
        if (!isValid) {
          goto LABEL_130;
        }
        char v146 = 0;
        long long v105 = operator new(0x28uLL);
        *long long v105 = &unk_26E6DF620;
        v105[1] = a3;
        v105[2] = v147;
        v105[3] = v140;
        v105[4] = &v146;
        *((void *)&v149 + 1) = v105;
        re::createCompressedTextureData(v104, *(_DWORD *)(v103 + 388), &v135, v140, 0, (uint64_t)&v148, (uint64_t)buf);
        int v107 = buf[0];
        if (buf[0])
        {
          uint64_t v108 = *(void *)v147;
          *(_DWORD *)(*(void *)v147 + 20) = 4;
          *(_OWORD *)(v108 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v135;
          re::AssetHandle::AssetHandle((re::AssetHandle *)v145, (const re::AssetHandle *)&v141);
          re::TextureAsset::setTextureAndSemantic_makeMutable((const re::ImportGraphicsContext *)v140, v145, (uint64_t)&buf[8], *(_DWORD *)(*(void *)v147 + 388), (long long *)(*(void *)v147 + 8));
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v145);
        }
        else
        {
          long long v109 = *re::assetsLogObjects(v106);
          if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
          {
            long long v114 = (char *)&v155 + 1;
            if (v155) {
              long long v114 = (char *)*((void *)&v155 + 1);
            }
            *(_DWORD *)v152 = 136315138;
            v153 = v114;
            _os_log_error_impl(&dword_233120000, v109, OS_LOG_TYPE_ERROR, "Failed to compress texture: %s.", v152, 0xCu);
          }
        }
        re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)buf);
        uint64_t isValid = (uint64_t)std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v148);
        if (!v107)
        {
LABEL_130:
          uint64_t v110 = *re::assetsLogObjects((re *)isValid);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
          {
            int v111 = v110;
            uint64_t v112 = re::AssetHandle::assetInfo((re::AssetHandle *)&v141);
            if (v112[17]) {
              uint64_t v113 = (char *)v112[18];
            }
            else {
              uint64_t v113 = (char *)v112 + 137;
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v113;
            _os_log_impl(&dword_233120000, v111, OS_LOG_TYPE_DEFAULT, "Failed to recompress  %s", buf, 0xCu);
          }
        }
        if (v101) {
      }
        }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v141);
      uint64_t v92 = (re::AssetHandle *)((char *)v92 + 32);
    }
    while (v92 != v93);
  }
  uint64_t v115 = v136[0];
  if (v136[0])
  {
    unint64_t v116 = v139;
    if (v139)
    {
      if (v91)
      {
        uint64_t v117 = 32 * v91;
        float v118 = v139;
        do
        {
          re::AssetHandle::~AssetHandle(v118);
          float v118 = (re::AssetHandle *)(v119 + 32);
          v117 -= 32;
        }
        while (v117);
      }
      (*(void (**)(uint64_t, re::AssetHandle *, __n128))(*(void *)v115 + 40))(v115, v116, v90);
    }
  }
}

void std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26E6DF620;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = result;
  return result;
}

__n128 std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6DF620;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x237DBDCF0]();
  id v3 = *(id *)(*(void *)(*(void *)(a1 + 8) + 64) + 24);
  id v4 = *(id *)(**(void **)(a1 + 16) + 248);
  v8[0] = v3;
  unsigned int v9 = 0;
  id v10 = v4;
  unint64_t v5 = *(const re::ImportGraphicsContext **)(a1 + 24);
  uint64_t v6 = **(void **)(a1 + 16);
  v7[0] = *(unsigned char *)(v6 + 152);
  re::TextureAsset::setTextureAndSemantic(v6, v5, (uint64_t)v7, *(_DWORD *)(v6 + 388));
  **(unsigned char **)(a1 + 32) = 1;

  if (v9 != -1) {
    ((void (*)(char *, id *))*(&off_26E6DF600 + v9))(&v11, v8);
  }
  if (v3) {
}
  }

uint64_t std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::target_type()
{
}

re::DynamicString *re::FontCompiler::getCurrentCompiledAssetInfo@<X0>(re::FontCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  id v3 = (re::FontAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::FontAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

void *re::FontCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::FontCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

char **re::FontCompiler::assetIntrospectionType(re::FontCompiler *this)
{
  id v1 = &off_268773000;
  {
    id v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::FontAsset>(void)::info = re::introspect_FontAsset(0);
      id v1 = &off_268773000;
    }
  }
  return v1[175];
}

uint64_t re::FontCompiler::compile@<X0>(re::FontCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = re::globalAllocators(this);
  unsigned int v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 80, 8);
  *(_OWORD *)unsigned int v9 = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  re::DynamicString::setCapacity(v9, 0);
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF7FBA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF7FBA0))
  {
    _MergedGlobals_134 = re::introspect_FontFile(0);
    __cxa_guard_release(&qword_26AF7FBA0);
  }
  uint64_t result = re::AssetUtilities::readSourceJson(a2, (const char *)v9, _MergedGlobals_134, a3, (uint64_t)v18);
  if (v18[0])
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v9;
  }
  else
  {
    re::internal::destroyPersistent<re::FontAsset>((re *)"compile", 58, (uint64_t)v9);
    *(void *)&long long v14 = 100;
    *((void *)&v14 + 1) = re::AssetErrorCategory(void)::instance;
    uint64_t result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)&v15, (const re::DynamicString *)&v19);
    long long v11 = v15;
    *(_OWORD *)(a4 + 8) = v14;
    uint64_t v12 = v16;
    uint64_t v13 = v17;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v11;
    *(void *)(a4 + 40) = v12;
    *(void *)(a4 + 48) = v13;
    if (!v18[0])
    {
      uint64_t result = v19;
      if (v19)
      {
        if (v20) {
          return (*(uint64_t (**)(void))(*(void *)v19 + 40))();
        }
      }
    }
  }
  return result;
}

re *re::FontCompiler::deleteAsset(re::FontCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::FontAsset>((re *)"deleteAsset", 68, a2);
}

re::DynamicString *re::FontLayoutCompiler::getCurrentCompiledAssetInfo@<X0>(re::FontLayoutCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::FontLayoutAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::FontLayoutAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::FontLayoutCompiler::assetIntrospectionType(re::FontLayoutCompiler *this)
{
  id v1 = &off_268773000;
  {
    id v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::FontLayoutAsset>(void)::info = re::introspect_FontLayoutAsset(0);
      id v1 = &off_268773000;
    }
  }
  return v1[177];
}

void *re::FontLayoutCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::FontLayoutCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

uint64_t re::FontLayoutCompiler::compile@<X0>(re::FontLayoutCompiler *this@<X0>, re::FileStreamReader *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = re::globalAllocators(this);
  uint64_t v8 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 128, 8);
  *uint64_t v8 = 0u;
  v8[1] = 0u;
  void v8[2] = 0u;
  void v8[3] = 0u;
  unsigned char v8[4] = 0u;
  v8[5] = 0u;
  v8[6] = 0u;
  v8[7] = 0u;
  uint64_t result = re::parseFontLayout(a2, (uint64_t)v8, (uint64_t)v10);
  if (!v10[0])
  {
    uint64_t result = v11;
    if (v11)
    {
      if (v12) {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  *(unsigned char *)a3 = 1;
  *(void *)(a3 + 8) = v8;
  return result;
}

re *re::FontLayoutCompiler::deleteAsset(re::FontLayoutCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::FontLayoutAsset>((re *)"deleteAsset", 115, a2);
}

void re::FontCompiler::~FontCompiler(re::FontCompiler *this)
{
}

void re::FontLayoutCompiler::~FontLayoutCompiler(re::FontLayoutCompiler *this)
{
}

re::DynamicString *re::ShaderLibraryCompiler::getCurrentCompiledAssetInfo@<X0>(re::ShaderLibraryCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::ShaderLibraryAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::ShaderLibraryAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::ShaderLibraryCompiler::assetIntrospectionType(re::ShaderLibraryCompiler *this)
{
  id v1 = &off_268773000;
  {
    id v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::ShaderLibraryAsset>(void)::info = re::introspect_ShaderLibraryAsset(0);
      id v1 = &off_268773000;
    }
  }
  return v1[194];
}

void *re::ShaderLibraryCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::ShaderLibraryCompiler::getSupportedExtensions(void)const::supportedExtensions);
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &off_268774040);
}

uint64_t *re::ShaderLibraryCompiler::compile@<X0>(re::ShaderLibraryCompiler *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = 0;
  id v23 = 0;
  uint64_t v24 = 0;
  re::DynamicString::setCapacity(&v21, 0);
  uint64_t v7 = strrchr(a2, 46);
  uint64_t v8 = (_anonymous_namespace_ *)strcmp(v7, ".hmshaderlib");
  if (v8)
  {
    __darwin_ino64_t v9 = strlen(a2);
    *(void *)&v25.st_dev = a2;
    v25.st_ino = v9;
    re::DynamicString::operator=((re::DynamicString *)&v21, (uint64_t)&v25);
    if (v22) {
      id v10 = v23;
    }
    else {
      id v10 = (char *)&v22 + 1;
    }
    uint64_t v11 = (re *)stat(v10, &v25);
    if (!v11)
    {
      long long v15 = re::globalAllocators(v11);
      uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15[2] + 32))(v15[2], 88, 8);
      *(_OWORD *)(v16 + 56) = 0u;
      *(_OWORD *)(v16 + 72) = 0u;
      *(_OWORD *)(v16 + 40) = 0u;
      *(void *)uint64_t v16 = &unk_26E6CEA08;
      *(_OWORD *)(v16 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
      *(_OWORD *)(v16 + 8) = 0u;
      uint64_t v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)(v16 + 8), 0);
      *(_OWORD *)(v16 + 56) = 0u;
      *(_OWORD *)(v16 + 40) = 0u;
      re::DynamicString::setCapacity((void *)(v16 + 40), 0);
      *(void *)(v16 + 80) = 0;
      if (v22) {
        unint64_t v18 = v23;
      }
      else {
        unint64_t v18 = (char *)&v22 + 1;
      }
      __darwin_ino64_t v19 = strlen(v18);
      *(void *)&v25.st_dev = v18;
      v25.st_ino = v19;
      re::DynamicString::operator=((re::DynamicString *)(v16 + 40), (uint64_t)&v25);
      *(unsigned char *)a3 = 1;
      *(void *)(a3 + 8) = v16;
      goto LABEL_13;
    }
    re::DynamicString::format((re::DynamicString *)"failed to load shader library %s", (re::DynamicString *)&v25, a2);
  }
  else
  {
  }
  long long v12 = *(_OWORD *)&v25.st_dev;
  uint64_t v13 = *(void *)&v25.st_uid;
  uint64_t v14 = *(void *)&v25.st_rdev;
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = 100;
  *(void *)(a3 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v12;
  *(void *)(a3 + 40) = v13;
  *(void *)(a3 + 48) = v14;
LABEL_13:
  uint64_t result = v21;
  if (v21)
  {
    if (v22) {
      return (uint64_t *)(*(uint64_t (**)(void))(*v21 + 40))();
    }
  }
  return result;
}

re *re::ShaderLibraryCompiler::deleteAsset(re::ShaderLibraryCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::ShaderLibraryAsset>((re *)"deleteAsset", 151, a2);
}

void re::ShaderLibraryCompiler::~ShaderLibraryCompiler(re::ShaderLibraryCompiler *this)
{
}

BOOL re::isPackageRelativePath(char *__s, size_t __n)
{
  if (!__n) {
    return 0;
  }
  if (__s[__n - 1] != 93) {
    return 0;
  }
  id v4 = (char *)memchr(__s, 91, __n);
  if (v4) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = &__s[__n];
  }
  return v5 - __s != __n;
}

uint64_t re::innerPathFromPackageRelativePath(uint64_t result, unint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + result - 1) == 93)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (a2 - 1);
    int v4 = 1;
    while (1)
    {
      uint64_t v5 = v3 + v2;
      if ((int)v3 + (int)v2 < 1) {
        break;
      }
      unint64_t v6 = v5 - 1;
      if (a2 <= v5 - 1)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3 + v2 - 1, a2);
        _os_crash();
        __break(1u);
LABEL_17:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
      int v7 = *(unsigned __int8 *)(v3 + result - 1 + v2);
      if (v6)
      {
        unint64_t v6 = (a2 - 3 + v2);
        if (a2 <= v6) {
          goto LABEL_17;
        }
        LODWORD(v6) = *(unsigned __int8 *)(result + v6);
      }
      BOOL v8 = v7 == 93;
      int v9 = v7 == 91;
      BOOL v10 = v6 == 92;
      BOOL v11 = v6 != 92;
      if (v10) {
        int v9 = 0;
      }
      int v12 = v9 << 31 >> 31;
      if (v8 && v11) {
        int v12 = 1;
      }
      --v2;
      v4 += v12;
      if (!v4)
      {
        result += v3 + v2 + 1;
        return result;
      }
    }
  }
  return result;
}

char *re::fixAssetName@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  re::replaceChar(*(re **)a1, *(const char **)(a1 + 8), 0x2Fu, (void *)a2);
  if (*(unsigned char *)(a2 + 8)) {
    uint64_t result = *(char **)(a2 + 16);
  }
  else {
    uint64_t result = (char *)(a2 + 9);
  }
  if (result)
  {
    uint64_t result = strpbrk(result, ":<>|\"?*");
    if (result)
    {
      for (uint64_t i = 0; i != 7; ++i)
      {
        unint64_t v5 = *(void *)(a2 + 8);
        if (v5) {
          unint64_t v6 = *(re **)(a2 + 16);
        }
        else {
          unint64_t v6 = (re *)(a2 + 9);
        }
        int v7 = (const char *)(v5 >> 1);
        BOOL v8 = (const char *)(v5 >> 1);
        if (*(void *)(a2 + 8)) {
          int v9 = v7;
        }
        else {
          int v9 = v8;
        }
        re::replaceChar(v6, v9, re::AssetPath::invalidNameChars[i], &v10);
        re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v10);
        uint64_t result = v10;
        if (v10)
        {
          if (v11) {
            uint64_t result = (char *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
          }
        }
      }
    }
  }
  return result;
}

unsigned char *re::replaceChar@<X0>(re *this@<X0>, const char *a2@<X1>, unsigned __int8 a3@<W2>, void *a4@<X8>)
{
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  re::DynamicString::setCapacity(a4, 0);
  uint64_t result = re::DynamicString::resize(a4, (unint64_t)a2, 0);
  if (a2)
  {
    int v9 = 0;
    do
    {
      int v10 = v9[(void)this];
      uint64_t result = (unsigned char *)re::DynamicString::operator[]((uint64_t)a4, (unint64_t)v9);
      if (v10 == a3) {
        char v11 = 95;
      }
      else {
        char v11 = v10;
      }
      *uint64_t result = v11;
      ++v9;
    }
    while (a2 != v9);
  }
  return result;
}

uint64_t re::ImportAssetTable::compiledAssetPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, re::DynamicString *a4@<X8>)
{
  v14[0] = a1;
  v14[1] = a2;
  re::stringToLowerCase(*a3, (re::DynamicString *)&v11);
  re::fixAssetName((uint64_t)v14, (uint64_t)&v8);
  if (v9) {
    unint64_t v5 = *(unsigned char **)&v10[7];
  }
  else {
    unint64_t v5 = v10;
  }
  if (v12) {
    unint64_t v6 = *(unsigned char **)&v13[7];
  }
  else {
    unint64_t v6 = v13;
  }
  re::DynamicString::format((re::DynamicString *)"%s.compiled%s", a4, v5, v6);
  if (v8 && (v9 & 1) != 0) {
    (*(void (**)(void))(*(void *)v8 + 40))();
  }
  uint64_t result = v11;
  if (v11)
  {
    if (v12) {
      return (*(uint64_t (**)(void))(*(void *)v11 + 40))();
    }
  }
  return result;
}

uint64_t re::setFunctionConstantsFromScene(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 200);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*(void *)(result + 184) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 20;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(result + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    char v9 = (void *)(a2 + 296);
    uint64_t v10 = *(void *)(result + 184);
    uint64_t v23 = result;
    *(void *)uint64_t v24 = a2 + 296;
    do
    {
      uint64_t v11 = v10 + 80 * v8;
      char v12 = (re::DynamicString *)(v11 + 16);
      uint64_t v13 = (const re::DynamicString *)(v11 + 48);
      unint64_t v14 = re::Hash<re::DynamicString>::operator()((uint64_t)&v25, v11 + 16);
      unint64_t v15 = v14;
      if (*v9)
      {
        unint64_t v16 = v14 % *(unsigned int *)(a2 + 320);
        uint64_t v17 = *(unsigned int *)(*(void *)(a2 + 304) + 4 * v16);
        if (v17 != 0x7FFFFFFF)
        {
          uint64_t v18 = *(void *)(a2 + 312);
          while (!re::DynamicString::operator==(v18 + 80 * v17 + 16, (uint64_t)v12))
          {
            uint64_t v17 = *(_DWORD *)(v18 + 80 * v17 + 8) & 0x7FFFFFFF;
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v3 = v23;
              goto LABEL_15;
            }
          }
          uint64_t v22 = 5 * v17;
          re::DynamicString::deinit((re::DynamicString *)(v18 + 16 * v22 + 48));
          uint64_t result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a2 + 312) + 16 * v22 + 48), v13);
          uint64_t v3 = v23;
          char v9 = *(void **)v24;
          goto LABEL_18;
        }
LABEL_15:
        char v9 = *(void **)v24;
      }
      else
      {
        LODWORD(v16) = 0;
      }
      uint64_t result = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString&>((uint64_t)v9, v16, v15, v12, v13);
LABEL_18:
      ++*(_DWORD *)(a2 + 336);
      unsigned int v19 = *(_DWORD *)(v3 + 200);
      uint64_t v10 = *(void *)(v3 + 184);
      if (v19 <= (int)v5 + 1) {
        int v20 = v5 + 1;
      }
      else {
        int v20 = *(_DWORD *)(v3 + 200);
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v20 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        int v21 = v8;
        if ((*(_DWORD *)(v10 + 80 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_25;
        }
      }
      int v21 = v20;
LABEL_25:
      LODWORD(v5) = v21;
    }
    while (v19 != v21);
  }
  return result;
}

uint64_t re::setFunctionConstantsFromMaterial(uint64_t a1, int a2)
{
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  uint64_t v5 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    uint64_t v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  unint64_t v6 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    unint64_t v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  int v7 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    int v7 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  uint64_t v8 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    uint64_t v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  char v9 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    char v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  uint64_t v10 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    uint64_t v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  uint64_t v11 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    uint64_t v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v80, (const re::DynamicString *)&v84);
  char v12 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    char v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  if (a2) {
    uint64_t v13 = "true";
  }
  else {
    uint64_t v13 = "false";
  }
  uint8_t v77 = v13;
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(a1 + 296, (re::DynamicString *)&v80, &v77);
  unint64_t v14 = (_anonymous_namespace_ *)v80;
  if (void)v80 && (BYTE8(v80)) {
    unint64_t v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v80 + 40))();
  }
  unsigned int v82 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  uint64_t v83 = 0x7FFFFFFFLL;
  uint64_t v15 = *(unsigned int *)(a1 + 184);
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = (int *)(*(void *)(a1 + 168) + 8);
    while (1)
    {
      int v18 = *v17;
      v17 += 22;
      if (v18 < 0) {
        break;
      }
      if (v15 == ++v16)
      {
        LODWORD(v16) = *(_DWORD *)(a1 + 184);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if (v15 != v16)
  {
    uint64_t v19 = v16;
    uint64_t v20 = *(void *)(a1 + 168);
    do
    {
      unint64_t v14 = (_anonymous_namespace_ *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v80, (re::DynamicString *)(v20 + 88 * v19 + 16));
      uint64_t v20 = *(void *)(a1 + 168);
      if (*(_DWORD *)(a1 + 184) <= (v16 + 1)) {
        int v21 = v16 + 1;
      }
      else {
        int v21 = *(_DWORD *)(a1 + 184);
      }
      int v22 = v16;
      while (1)
      {
        uint64_t v19 = (v22 + 1);
        if (v21 - 1 == v22) {
          break;
        }
        ++v22;
        LODWORD(v16) = v19;
        if ((*(_DWORD *)(v20 + 88 * v19 + 8) & 0x80000000) != 0) {
          goto LABEL_47;
        }
      }
      LODWORD(v16) = v21;
LABEL_47:
      ;
    }
    while (v15 != v16);
  }
  uint64_t v23 = *(unsigned int *)(a1 + 232);
  if (v23)
  {
    uint64_t v24 = 0;
    char v25 = (int *)(*(void *)(a1 + 216) + 8);
    while (1)
    {
      int v26 = *v25;
      v25 += 40;
      if (v26 < 0) {
        break;
      }
      if (v23 == ++v24)
      {
        LODWORD(vre::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(_DWORD *)(a1 + 232);
        break;
      }
    }
  }
  else
  {
    LODWORD(vre::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  }
  if (v23 == v24)
  {
    BOOL v27 = 0;
  }
  else
  {
    LOBYTE(v2re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
    uint64_t v28 = v24;
    uint64_t v29 = *(void *)(a1 + 216);
    do
    {
      unint64_t v14 = (_anonymous_namespace_ *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v80, (re::DynamicString *)(v29 + 160 * v28 + 16));
      if (v27)
      {
        BOOL v27 = 1;
      }
      else if (*(unsigned char *)(v29 + 160 * v28 + 152))
      {
        BOOL v27 = *(_DWORD *)(v29 + 160 * v28 + 156) != 0;
      }
      else
      {
        BOOL v27 = 0;
      }
      unsigned int v30 = *(_DWORD *)(a1 + 232);
      uint64_t v29 = *(void *)(a1 + 216);
      if (v30 <= (int)v24 + 1) {
        unsigned int v30 = v24 + 1;
      }
      while (1)
      {
        uint64_t v28 = (v24 + 1);
        if (v30 - 1 == v24) {
          break;
        }
        LODWORD(vre::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v24 + 1;
        unsigned int v31 = v28;
        if ((*(_DWORD *)(v29 + 160 * v28 + 8) & 0x80000000) != 0) {
          goto LABEL_68;
        }
      }
      unsigned int v31 = v30;
LABEL_68:
      LODWORD(vre::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v31;
    }
    while (v23 != v31);
  }
  if (v27) {
    uint64_t v32 = "true";
  }
  else {
    uint64_t v32 = "false";
  }
  __int16 v75 = (_anonymous_namespace_ *)v32;
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(a1 + 296, (re::DynamicString *)&v77, (const char **)&v75);
  if (v77 && (v78 & 1) != 0) {
    (*(void (**)(void))(*(void *)v77 + 40))();
  }
  unsigned int v33 = v82;
  if (v82)
  {
    uint64_t v34 = 0;
    int v35 = (int *)(v81 + 8);
    while (1)
    {
      int v36 = *v35;
      v35 += 12;
      if (v36 < 0) {
        break;
      }
      if (v82 == ++v34)
      {
        LODWORD(v34) = v82;
        break;
      }
    }
  }
  else
  {
    LODWORD(v34) = 0;
  }
  if (v82 != v34)
  {
    uint64_t v37 = v34;
    uint64_t v38 = v81;
    do
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v77, (const re::DynamicString *)(v38 + 48 * v37 + 16));
      if (v78) {
        uint64_t v39 = *(const char **)&v79[7];
      }
      else {
        uint64_t v39 = v79;
      }
      id v40 = (_anonymous_namespace_ *)strcmp(v39, "textureBaseColor");
      if (v40)
      {
        uint64_t v41 = (_anonymous_namespace_ *)strcmp(v39, "textureNormal");
        if (v41)
        {
          uint8_t v42 = (_anonymous_namespace_ *)strcmp(v39, "textureEmissive");
          if (v42)
          {
            BOOL v43 = (_anonymous_namespace_ *)strcmp(v39, "textureRoughness");
            if (v43)
            {
              unsigned int v44 = (_anonymous_namespace_ *)strcmp(v39, "textureMetallic");
              if (v44)
              {
                unsigned int v45 = (_anonymous_namespace_ *)strcmp(v39, "textureAmbientOcclusion");
                if (v45)
                {
                  uint64_t v46 = (_anonymous_namespace_ *)strcmp(v39, "textureSpecular");
                  if (v46)
                  {
                    uint64_t v47 = (_anonymous_namespace_ *)strcmp(v39, "textureOpacity");
                    if (v47)
                    {
                      unsigned int v48 = (_anonymous_namespace_ *)strcmp(v39, "textureClearcoatRoughness");
                      if (v48 && (unsigned int v48 = (_anonymous_namespace_ *)strcmp(v39, "textureClearcoat"), v48))
                      {
                        int v49 = (_anonymous_namespace_ *)strcmp(v39, "textureRMAS");
                        if (v49) {
                          goto LABEL_113;
                        }
                        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[6]>(a1 + 296, (re::DynamicString *)&v75, 2, "false");
                        uint64_t v50 = v75;
                        if (v75 && (v76 & 1) != 0) {
                          uint64_t v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v75 + 40))();
                        }
                        unsigned int v51 = "EnableSingleRMAS";
                      }
                      else
                      {
                        unsigned int v51 = "EnableClearcoat";
                      }
                    }
                    else
                    {
                      unsigned int v51 = "EnableOpacityMap";
                    }
                  }
                  else
                  {
                    unsigned int v51 = "EnableSpecularMap";
                  }
                }
                else
                {
                  unsigned int v51 = "EnableAOMap";
                }
              }
              else
              {
                unsigned int v51 = "EnableMetallicMap";
              }
            }
            else
            {
              unsigned int v51 = "EnableRoughnessMap";
            }
          }
          else
          {
            unsigned int v51 = "EnableEmissiveMap";
          }
        }
        else
        {
          unsigned int v51 = "EnableNormalMap";
        }
      }
      else
      {
        unsigned int v51 = "EnableBaseColorMap";
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[5]>(a1 + 296, (re::DynamicString *)&v75, 2, "true");
      if (v75 && (v76 & 1) != 0) {
        (*(void (**)(void))(*(void *)v75 + 40))();
      }
LABEL_113:
      if (v77 && (v78 & 1) != 0) {
        (*(void (**)(void))(*(void *)v77 + 40))();
      }
      uint64_t v38 = v81;
      if (v82 <= (int)v34 + 1) {
        unsigned int v52 = v34 + 1;
      }
      else {
        unsigned int v52 = v82;
      }
      while (1)
      {
        uint64_t v37 = (v34 + 1);
        if (v52 - 1 == v34) {
          break;
        }
        LODWORD(v34) = v34 + 1;
        unsigned int v53 = v37;
        if ((*(_DWORD *)(v81 + 48 * v37 + 8) & 0x80000000) != 0) {
          goto LABEL_123;
        }
      }
      unsigned int v53 = v52;
LABEL_123:
      LODWORD(v34) = v53;
    }
    while (v33 != v53);
  }
  uint64_t v54 = *(unsigned int *)(a1 + 88);
  if (v54)
  {
    uint64_t v55 = 0;
    uint8_t v56 = (int *)(*(void *)(a1 + 72) + 8);
    while (1)
    {
      int v57 = *v56;
      v56 += 20;
      if (v57 < 0) {
        break;
      }
      if (v54 == ++v55)
      {
        LODWORD(v55) = *(_DWORD *)(a1 + 88);
        break;
      }
    }
  }
  else
  {
    LODWORD(v55) = 0;
  }
  if (v54 != v55)
  {
    uint64_t v58 = v55;
    uint64_t v59 = *(void *)(a1 + 72);
    do
    {
      uint64_t v60 = v59 + 80 * v58;
      uint64_t v61 = v60 + 48;
      uint64_t v62 = *(void *)(v60 + 24);
      uint64_t v63 = *(const char **)(v60 + 32);
      uint64_t v64 = (const char *)(v60 + 25);
      if (v62) {
        int v65 = v63;
      }
      else {
        int v65 = v64;
      }
      if (!strcmp(v65, "clearcoatScale") || !strcmp(v65, "clearcoatRoughnessScale"))
      {
        if (*(unsigned char *)(v59 + 80 * v58 + 56)) {
          uint64_t v67 = *(const char **)(v59 + 80 * v58 + 64);
        }
        else {
          uint64_t v67 = (const char *)(v61 + 9);
        }
        if (strtof(v67, 0) <= 0.0) {
          goto LABEL_151;
        }
        uint64_t v69 = "EnableClearcoat";
      }
      else
      {
        if (strcmp(v65, "opacityThreshold")) {
          goto LABEL_151;
        }
        uint64_t v66 = (*(unsigned char *)(v59 + 80 * v58 + 56) & 1) != 0
            ? *(const char **)(v59 + 80 * v58 + 64)
            : (const char *)(v61 + 9);
        if (strtof(v66, 0) <= 0.0) {
          goto LABEL_151;
        }
        uint64_t v69 = "EnableOpacityThreshold";
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[5]>(a1 + 296, (re::DynamicString *)&v77, 2, "true");
      if (v77 && (v78 & 1) != 0) {
        (*(void (**)(void))(*(void *)v77 + 40))();
      }
LABEL_151:
      unsigned int v71 = *(_DWORD *)(a1 + 88);
      uint64_t v59 = *(void *)(a1 + 72);
      if (v71 <= (int)v55 + 1) {
        unsigned int v71 = v55 + 1;
      }
      while (1)
      {
        uint64_t v58 = (v55 + 1);
        if (v71 - 1 == v55) {
          break;
        }
        LODWORD(v55) = v55 + 1;
        unsigned int v72 = v58;
        if ((*(_DWORD *)(v59 + 80 * v58 + 8) & 0x80000000) != 0) {
          goto LABEL_157;
        }
      }
      unsigned int v72 = v71;
LABEL_157:
      LODWORD(v55) = v72;
    }
    while (v54 != v72);
  }
  double v73 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v80);
  uint64_t result = v84;
  if (v84)
  {
    if (v85) {
      return (*(uint64_t (**)(double))(*(void *)v84 + 40))(v73);
    }
  }
  return result;
}

void re::createMaterialAssetsFromMaterialTable(uint64_t a1, uint64_t a2, _anonymous_namespace_ *a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 18;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    unsigned int v44 = (re::AssetPath *)(a1 + 57);
    uint64_t v9 = *(void *)(a2 + 16);
    do
    {
      uint64_t v10 = (_anonymous_namespace_ *)*(id *)(v9 + 72 * v8 + 56);
      uint64_t v11 = v10;
      if (v10)
      {
        long long v51 = 0u;
        long long v52 = 0u;
        re::DynamicString::setCapacity(&v51, 0);
        memset(v53, 0, sizeof(v53));
        uint64_t v54 = 0x7FFFFFFFLL;
        memset(v55, 0, sizeof(v55));
        int v56 = 0;
        uint64_t v57 = 0x7FFFFFFFLL;
        memset(v58, 0, sizeof(v58));
        int v59 = 0;
        uint64_t v60 = 0x7FFFFFFFLL;
        memset(v61, 0, sizeof(v61));
        int v62 = 0;
        uint64_t v63 = 0x7FFFFFFFLL;
        int v65 = 0;
        memset(v64, 0, sizeof(v64));
        uint64_t v66 = 0x7FFFFFFFLL;
        memset(v67, 0, sizeof(v67));
        int v68 = 0;
        uint64_t v69 = 0x7FFFFFFFLL;
        v70[0] = 0;
        void v70[2] = 0;
        v70[4] = 0;
        v70[6] = 0;
        v70[8] = 0;
        v70[10] = 0;
        v70[12] = 0;
        v70[14] = 0;
        v70[16] = 0;
        uint64_t v73 = 0;
        int v72 = 0;
        memset(v71, 0, sizeof(v71));
        int v12 = *(unsigned __int8 *)(v9 + 72 * v8 + 68);
        uint64_t v13 = v11;
        uint64_t v14 = [(_anonymous_namespace_ *)v13 name];
        if (v14) {
          uint64_t v15 = (__CFString *)v14;
        }
        else {
          uint64_t v15 = &stru_26E738380;
        }
        if (v12)
        {
          uint64_t v16 = [(__CFString *)v15 stringByAppendingString:@"/subd"];

          uint64_t v15 = (__CFString *)v16;
        }
        uint64_t v17 = v15;
        int v18 = (const char *)[(__CFString *)v17 UTF8String];
        size_t v19 = strlen(v18);
        unsigned int v48 = v18;
        size_t v49 = v19;
        re::DynamicString::operator=((re::DynamicString *)&v51, (uint64_t)&v48);
        re::gatherMaterialConstants((uint64_t)&v53[24], v13);
        uint64_t v20 = a1;
        re::setFunctionConstantsFromScene(a1, (uint64_t)&v51);
        re::setFunctionConstantsFromMaterial((uint64_t)&v51, 0);
        int isMaterialTransparent = re::isMaterialTransparent(v13, v21);

        unint64_t v24 = *(void *)(a1 + 56);
        if (v24) {
          unint64_t v25 = v24 >> 1;
        }
        else {
          unint64_t v25 = v24 >> 1;
        }
        if (v25)
        {
          if (*(void *)(a1 + 56)) {
            int v26 = *(re::AssetPath **)(a1 + 64);
          }
          else {
            int v26 = v44;
          }
        }
        else
        {
          if (v12)
          {
            if (isMaterialTransparent) {
              BOOL v27 = "engine:transparentPbrOpenSubdiv.rematerialdefinition";
            }
            else {
              BOOL v27 = "engine:pbrOpenSubdiv.rematerialdefinition";
            }
          }
          else if (isMaterialTransparent)
          {
            BOOL v27 = "engine:transparentPbr.rematerialdefinition";
          }
          else
          {
            BOOL v27 = "engine:pbr.rematerialdefinition";
          }
          uint64_t v20 = a1;
        }

        uint64_t v29 = *(void *)(v20 + 104);
        if (BYTE8(v51)) {
          unsigned int v30 = (char *)v52;
        }
        else {
          unsigned int v30 = (char *)&v51 + 9;
        }
        if (BYTE8(v51)) {
          uint64_t v31 = *((void *)&v51 + 1) >> 1;
        }
        else {
          uint64_t v31 = BYTE8(v51) >> 1;
        }
        uint64_t v32 = re::MaterialAsset::assetType(v28);
        uint64_t v33 = re::ImportAssetTable::importedAsset(v29, (uint64_t)v30, v31, (re **)v32);
        if (!v33)
        {
          uint64_t v34 = re::globalAllocators(0);
          int v35 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v34[2] + 32))(v34[2], 1896, 8);
          bzero(v35, 0x768uLL);
          re::MaterialAsset::MaterialAsset((re::MaterialAsset *)v35);
          re::DynamicString::operator=((re::DynamicString *)(v35 + 8), (re::DynamicString *)&v51);
          re::AssetHandle::operator=((uint64_t)(v35 + 40), (uint64_t *)v53);
          re::MaterialParameterData::operator=((uint64_t)(v35 + 64), (uint64_t)&v53[24]);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)(v35 + 304), (uint64_t)v67);
          re::MaterialRenderFlags::operator=(v35 + 352, v70);
          int v36 = (re::MaterialAsset *)re::DynamicArray<re::FunctionLink>::operator=((uint64_t)(v35 + 376), v71);
          uint64_t v37 = *(_anonymous_namespace_ **)(v20 + 104);
          if (BYTE8(v51)) {
            uint64_t v38 = (char *)v52;
          }
          else {
            uint64_t v38 = (char *)&v51 + 9;
          }
          if (BYTE8(v51)) {
            uint64_t v39 = *((void *)&v51 + 1) >> 1;
          }
          else {
            uint64_t v39 = BYTE8(v51) >> 1;
          }
          id v40 = re::MaterialAsset::assetType(v36);
          uint64_t v33 = re::ImportAssetTable::addAsset(v37, (uint64_t)v38, v39, v35, (re **)v40);
        }
        size_t v49 = 0;
        uint64_t v50 = 0;
        unsigned int v48 = 0;
        if (*(unsigned char *)(v33 + 8)) {
          uint64_t v41 = *(re::AssetPath **)(v33 + 16);
        }
        else {
          uint64_t v41 = (re::AssetPath *)(v33 + 9);
        }
        uint64_t v3 = a2;
        re::DynamicArray<re::AssetHandle>::add(a3, (re::AssetHandle *)&v48);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v48);
        re::DynamicArray<re::FunctionLink>::deinit((uint64_t)v71);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v67);
        re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v64);
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v61);
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v58);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v55);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v53[24]);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v53);
        if (void)v51 && (BYTE8(v51)) {
          (*(void (**)(void))(*(void *)v51 + 40))();
        }
      }

      unsigned int v42 = *(_DWORD *)(v3 + 32);
      uint64_t v9 = *(void *)(v3 + 16);
      if (v42 <= (int)v5 + 1) {
        unsigned int v42 = v5 + 1;
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v42 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        unsigned int v43 = v8;
        if ((*(_DWORD *)(v9 + 72 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_57;
        }
      }
      unsigned int v43 = v42;
LABEL_57:
      LODWORD(v5) = v43;
    }
    while (v4 != v43);
  }
}

uint64_t re::ImportAssetTable::importedAsset(uint64_t a1, uint64_t a2, uint64_t a3, re **a4)
{
  re::ImportAssetTable::compiledAssetPath(a2, a3, a4, (re::DynamicString *)&v8);
  uint64_t v5 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(a1 + 56, (uint64_t)&v8);
  if (v5) {
    uint64_t v6 = *v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v8 && (v9 & 1) != 0) {
    (*(void (**)(void))(*(void *)v8 + 40))();
  }
  return v6;
}

uint64_t re::ImportAssetTable::addAsset(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, void *a4, re **a5)
{
  v26[0] = a2;
  v26[1] = a3;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  if (a3) {
    size_t v9 = a3 + 1;
  }
  else {
    size_t v9 = 0;
  }
  unint64_t v23 = 0;
  re::DynamicString::setCapacity(&v22, v9);
  re::DynamicString::operator=((re::DynamicString *)&v22, (uint64_t)v26);
  if (v23) {
    uint64_t v10 = v24;
  }
  else {
    uint64_t v10 = (char *)&v23 + 1;
  }
  if (v23) {
    uint64_t v11 = v23 >> 1;
  }
  else {
    uint64_t v11 = v23 >> 1;
  }
  re::ImportAssetTable::compiledAssetPath((uint64_t)v10, v11, a5, (re::DynamicString *)&v20);
  re::DynamicString::operator=((re::DynamicString *)&v22, (re::DynamicString *)&v20);
  if (v20 && (v21[0] & 1) != 0) {
    (*(void (**)(void))(*(void *)v20 + 40))();
  }
  if (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)a1 + 56, (uint64_t)&v22))
  {
    uint64_t v12 = 1;
    do
    {
      re::DynamicString::operator=((re::DynamicString *)&v22, (uint64_t)v26);
      re::DynamicString::format((re::DynamicString *)"_%02d", (re::DynamicString *)&v20, v12);
      uint64_t v13 = v21[0] & 1;
      if (v21[0]) {
        uint64_t v14 = (const char *)v21[1];
      }
      else {
        uint64_t v14 = (char *)v21 + 1;
      }
      if (v21[0]) {
        size_t v15 = v21[0] >> 1;
      }
      else {
        size_t v15 = LOBYTE(v21[0]) >> 1;
      }
      re::DynamicString::append((re::DynamicString *)&v22, v14, v15);
      if (v20 && v13) {
        (*(void (**)(void))(*(void *)v20 + 40))();
      }
      if (v23) {
        uint64_t v16 = v24;
      }
      else {
        uint64_t v16 = (char *)&v23 + 1;
      }
      if (v23) {
        uint64_t v17 = v23 >> 1;
      }
      else {
        uint64_t v17 = v23 >> 1;
      }
      re::ImportAssetTable::compiledAssetPath((uint64_t)v16, v17, a5, (re::DynamicString *)&v20);
      re::DynamicString::operator=((re::DynamicString *)&v22, (re::DynamicString *)&v20);
      if (v20 && (v21[0] & 1) != 0) {
        (*(void (**)(void))(*(void *)v20 + 40))();
      }
      uint64_t v12 = (v12 + 1);
    }
    while (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)a1 + 56, (uint64_t)&v22));
  }
  uint64_t v18 = re::ImportAssetTable::addAssetWithPath(a1, (const re::DynamicString *)&v22, a4, (const re::AssetType *)a5);
  if (v22 && (v23 & 1) != 0) {
    (*(void (**)(void))(*v22 + 40))();
  }
  return v18;
}

void re::createMaterialAssetsFromMaterialTableUSK(void *a1, uint64_t a2, _anonymous_namespace_ *a3)
{
  uint64_t v3 = a2;
  uint64_t v351 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 18;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    uint64_t v269 = *MEMORY[0x263F84060];
    v265 = a1 + 14;
    v245 = (char *)a1 + 57;
    uint64_t v9 = *(void *)(a2 + 16);
    __asm
    {
      FMOV            V11.2S, #1.0
      FMOV            V3.4S, #1.0
    }
    int32x4_t v250 = vdupq_lane_s32(0, 0);
    uint64_t v251 = *((void *)&_Q3 + 1);
    int v246 = *(_DWORD *)(a2 + 32);
    while (1)
    {
      int v258 = v5;
      id v16 = *(id *)(v9 + 72 * v8 + 56);
      if (v16) {
        break;
      }
LABEL_326:

      unsigned int v239 = *(_DWORD *)(v3 + 32);
      uint64_t v9 = *(void *)(v3 + 16);
      int v240 = v258;
      if (v239 <= v258 + 1) {
        unsigned int v239 = v258 + 1;
      }
      while (1)
      {
        uint64_t v8 = (v240 + 1);
        if (v239 - 1 == v240) {
          break;
        }
        ++v240;
        unsigned int v241 = v8;
        if ((*(_DWORD *)(v9 + 72 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_332;
        }
      }
      unsigned int v241 = v239;
LABEL_332:
      LODWORD(v5) = v241;
      if (v4 == v241) {
        return;
      }
    }
    long long v279 = 0u;
    long long v280 = 0u;
    uint64_t v17 = v16;
    re::DynamicString::setCapacity(&v279, 0);
    memset(v281, 0, sizeof(v281));
    uint64_t v282 = 0x7FFFFFFFLL;
    memset(v283, 0, sizeof(v283));
    int v284 = 0;
    uint64_t v285 = 0x7FFFFFFFLL;
    long long v286 = 0u;
    long long v287 = 0u;
    int v288 = 0;
    uint64_t v289 = 0x7FFFFFFFLL;
    long long v290 = 0u;
    long long v291 = 0u;
    int v292 = 0;
    uint64_t v293 = 0x7FFFFFFFLL;
    int v296 = 0;
    long long v294 = 0u;
    long long v295 = 0u;
    uint64_t v297 = 0x7FFFFFFFLL;
    memset(v298, 0, sizeof(v298));
    int v299 = 0;
    uint64_t v300 = 0x7FFFFFFFLL;
    v301[0] = 0;
    v301[2] = 0;
    v301[4] = 0;
    v301[6] = 0;
    v301[8] = 0;
    v301[10] = 0;
    v301[12] = 0;
    v301[14] = 0;
    v301[16] = 0;
    uint64_t v304 = 0;
    int v303 = 0;
    memset(v302, 0, sizeof(v302));
    int v18 = *(unsigned __int8 *)(v9 + 72 * v8 + 68);
    id v253 = v17;
    id v260 = v17;
    size_t v19 = [v260 path];
    uint64_t v20 = [v19 stringValue];

    if (v20) {
      int v21 = (__CFString *)v20;
    }
    else {
      int v21 = &stru_26E738380;
    }
    int v249 = v18;
    if (v18)
    {
      uint64_t v22 = [(__CFString *)v21 stringByAppendingString:@"/subd"];

      int v21 = (__CFString *)v22;
    }
    v254 = v21;
    unint64_t v23 = (const char *)[(__CFString *)v254 UTF8String];
    size_t v24 = strlen(v23);
    *(void *)v345 = v23;
    *(void *)&v345[8] = v24;
    re::DynamicString::operator=((re::DynamicString *)&v279, (uint64_t)v345);
    re::gatherMaterialTextureProperties((uint64_t)v260, (uint64_t)v331);
    unsigned int v329 = 0;
    long long v328 = 0u;
    long long v327 = 0u;
    uint64_t v330 = 0x7FFFFFFFLL;
    int v26 = [MEMORY[0x263F83F10] firstUVMeshAttributeNameInMaterial:v260];
    BOOL v27 = v26;
    if (v26)
    {
      uint64_t v28 = (const char *)[v26 UTF8String];
      size_t v29 = strlen(v28);
      *(void *)v345 = v28;
      *(void *)&v345[8] = v29;
      re::DynamicString::operator=((re::DynamicString *)&v324, (uint64_t)v345);
    }
    unsigned int v276 = v333;
    uint64_t v30 = 0;
    if (v333)
    {
      uint64_t v31 = (int *)(v332 + 8);
      uint64_t v32 = (uint64_t)a1;
      do
      {
        int v33 = *v31;
        v31 += 14;
        if (v33 < 0) {
          goto LABEL_23;
        }
        ++v30;
      }
      while (v333 != v30);
      LODWORD(v30) = v333;
    }
    else
    {
      uint64_t v32 = (uint64_t)a1;
    }
LABEL_23:
    v252 = v27;
    if (v333 == v30)
    {
      char v259 = 0;
      goto LABEL_25;
    }
    char v266 = 0;
    char v259 = 0;
    uint64_t v41 = v30;
    uint64_t v42 = v332;
LABEL_28:
    uint64_t v43 = v42 + 56 * v41;
    id v44 = *(id *)(v43 + 48);
    uint64_t ResourcePathAndColorSpaceForTextureProperty = (uint64_t)re::getResourcePathAndColorSpaceForTextureProperty(v44);
    if (!ResourcePathAndColorSpaceForTextureProperty) {
      goto LABEL_267;
    }
    id v277 = (id)ResourcePathAndColorSpaceForTextureProperty;
    uint64_t v267 = v43;
    if (*(unsigned char *)(v32 + 163)) {
      goto LABEL_69;
    }
    uint64_t v46 = [(id)ResourcePathAndColorSpaceForTextureProperty path];
    id v47 = [v46 pathExtension];
    std::string::basic_string[abi:nn180100]<0>(__p, (char *)[v47 UTF8String]);

    int v48 = SBYTE7(v314);
    size_t v49 = __p[1];
    if ((SBYTE7(v314) & 0x80u) == 0) {
      size_t v49 = (void *)BYTE7(v314);
    }
    if (v49)
    {
      size_t v50 = 0;
      unsigned int v51 = SBYTE7(v314) >> 31;
      do
      {
        if (v51) {
          long long v52 = (void **)__p[0];
        }
        else {
          long long v52 = __p;
        }
        uint64_t ResourcePathAndColorSpaceForTextureProperty = __tolower(*((char *)v52 + v50));
        if ((SBYTE7(v314) & 0x80u) == 0) {
          unsigned int v53 = __p;
        }
        else {
          unsigned int v53 = (void **)__p[0];
        }
        *((unsigned char *)v53 + v50++) = ResourcePathAndColorSpaceForTextureProperty;
        int v48 = SBYTE7(v314);
        unsigned int v51 = SBYTE7(v314) >> 31;
        if ((SBYTE7(v314) & 0x80u) == 0) {
          size_t v54 = BYTE7(v314);
        }
        else {
          size_t v54 = (size_t)__p[1];
        }
      }
      while (v54 > v50);
    }
    else
    {
      size_t v54 = 0;
    }
    uint64_t v55 = 0;
    if (v48 >= 0) {
      int v56 = __p;
    }
    else {
      int v56 = (void **)__p[0];
    }
    while (1)
    {
      if ((&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55 + 1] == (char *)v54)
      {
        uint64_t ResourcePathAndColorSpaceForTextureProperty = memcmp((&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55], v56, v54);
        if (!ResourcePathAndColorSpaceForTextureProperty) {
          break;
        }
      }
      v55 += 2;
      if (v55 == 8)
      {
        uint64_t v57 = off_264BE3438;
        goto LABEL_54;
      }
    }
    uint64_t v57 = &(&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55];
LABEL_54:
    if ((char *)v57
       - (char *)&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions != 64)
      goto LABEL_67;
    uint64_t v58 = 0;
    int v59 = (size_t *)&unk_264BE3400;
    while (1)
    {
      uint64_t v60 = (re *)re::DynamicString::append((re::DynamicString *)v345, (const char *)*(v59 - 1), *v59);
      if (v58 == 2) {
        break;
      }
      if (v58 != 3)
      {
        uint64_t v61 = ", ";
LABEL_60:
        size_t v62 = strlen(v61);
        uint64_t v60 = (re *)re::DynamicString::append((re::DynamicString *)v345, v61, v62);
      }
      v59 += 2;
      if (++v58 == 4)
      {
        uint64_t v63 = (id)*re::pipelineLogObjects(v60);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          id v207 = [v277 path];
          uint64_t v208 = [v207 UTF8String];
          v209 = &v345[9];
          if (v345[8]) {
            v209 = *(uint8_t **)&v345[16];
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v208;
          __int16 v340 = 2080;
          v341 = v209;
          _os_log_error_impl(&dword_233120000, v63, OS_LOG_TYPE_ERROR, "%s is an invalid USDZ texture format. Only %s textures are supported.", buf, 0x16u);
        }
        uint64_t ResourcePathAndColorSpaceForTextureProperty = *(void *)v345;
        if (*(void *)v345 && (v345[8] & 1) != 0) {
          uint64_t ResourcePathAndColorSpaceForTextureProperty = (*(uint64_t (**)(void))(**(void **)v345 + 40))();
        }
        char v259 = 1;
        LOBYTE(v48) = BYTE7(v314);
LABEL_67:
        if ((v48 & 0x80) != 0) {
          operator delete(__p[0]);
        }
LABEL_69:
        long long v323 = 0u;
        long long v322 = 0u;
        re::DynamicString::setCapacity(&v322, 0);
        id v278 = v44;
        uint64_t v64 = [v44 parentNode];
        int v65 = [MEMORY[0x263F83F10] shaderNodeType:v64];
        int v66 = [v65 isEqualToString:v269];

        uint64_t v270 = 0;
        long long v273 = xmmword_234376D50;
        if (v66)
        {
          uint64_t v67 = [v64 property:@"inputs:st"];
          int v68 = [MEMORY[0x263F83F10] targetPropertyWithProperty:v67];
          uint64_t v69 = [v68 parentNode];
          unint64_t v70 = [v69 property:@"info:id"];
          unsigned int v71 = v70;
          if (v70)
          {
            v271 = v67;
            int v72 = [v70 stringValue];
            int v73 = [v72 isEqualToString:@"UsdTransform2d"];

            if (!v73)
            {
              uint64_t v270 = 0;
              long long v273 = xmmword_234376D50;
              goto LABEL_93;
            }
            uint64_t v74 = [v69 property:@"inputs:scale"];
            __int16 v75 = v74;
            double v76 = _D11;
            if (v74) {
              objc_msgSend(v74, "float2Value", _D11);
            }
            double v274 = v76;
            uint8_t v77 = [v69 property:@"inputs:rotation"];
            v263 = v77;
            if (v77)
            {
              [v77 floatValue];
              double v79 = v78;
            }
            else
            {
              double v79 = 0.0;
            }
            long long v80 = [v69 property:@"inputs:translation"];
            v261 = v80;
            if (v80) {
              [v80 float2Value];
            }
            else {
              uint64_t v81 = 0;
            }
            uint64_t v82 = 0;
            v83.i64[1] = v251;
            v83.i32[0] = v81;
            *(_OWORD *)__p = xmmword_23435FD50;
            long long v314 = xmmword_23435FD60;
            long long v315 = xmmword_23437DC40;
            do
            {
              v83.f32[1] = -*((float *)&v81 + 1);
              *(float32x4_t *)&v345[v82 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_23435FD50, COERCE_FLOAT(*(_OWORD *)&__p[v82])), (float32x4_t)xmmword_23435FD60, (float32x2_t)__p[v82], 1), v83, *(float32x4_t *)&__p[v82], 2);
              v82 += 2;
            }
            while (v82 != 6);
            float v84 = v79 / 180.0 * 3.14159265;
            __float2 v85 = __sincosf_stret(v84);
            uint64_t v86 = 0;
            *(float *)&unint64_t v87 = v85.__cosval;
            *((float *)&v87 + 1) = -v85.__sinval;
            float32x4_t v88 = *(float32x4_t *)v345;
            float32x4_t v89 = *(float32x4_t *)&v345[16];
            float32x4_t v90 = *(float32x4_t *)v346;
            *(_OWORD *)__p = v87;
            long long v314 = (unint64_t)v85;
            long long v315 = xmmword_23435FD80;
            do
            {
              *(float32x4_t *)&v345[v86 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v88, COERCE_FLOAT(*(_OWORD *)&__p[v86])), v89, (float32x2_t)__p[v86], 1), v90, *(float32x4_t *)&__p[v86], 2);
              v86 += 2;
            }
            while (v86 != 6);
            uint64_t v91 = 0;
            long long v92 = (__int128)v250;
            int32x4_t v93 = v250;
            DWORD1(v92) = HIDWORD(v274);
            v93.i32[0] = LODWORD(v274);
            float32x4_t v94 = *(float32x4_t *)v345;
            float32x4_t v95 = *(float32x4_t *)&v345[16];
            float32x4_t v96 = *(float32x4_t *)v346;
            *(int32x4_t *)__p = v93;
            long long v314 = v92;
            long long v315 = xmmword_23435FD80;
            do
            {
              *(float32x4_t *)&v345[v91 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v94, COERCE_FLOAT(*(_OWORD *)&__p[v91])), v95, (float32x2_t)__p[v91], 1), v96, *(float32x4_t *)&__p[v91], 2);
              v91 += 2;
            }
            while (v91 != 6);
            uint64_t v97 = 0;
            float32x4_t v98 = *(float32x4_t *)v345;
            float32x4_t v99 = *(float32x4_t *)&v345[16];
            float32x4_t v100 = *(float32x4_t *)v346;
            *(_OWORD *)__p = xmmword_23435FD50;
            long long v314 = xmmword_23435FD60;
            long long v315 = xmmword_23437DC50;
            do
            {
              *(float32x4_t *)&v345[v97 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v98, COERCE_FLOAT(*(_OWORD *)&__p[v97])), v99, (float32x2_t)__p[v97], 1), v100, *(float32x4_t *)&__p[v97], 2);
              v97 += 2;
            }
            while (v97 != 6);
            uint64_t v275 = *(void *)v345;
            uint64_t v255 = *(void *)&v345[16];
            uint64_t v270 = *(void *)v346;
            id v101 = [v69 property:@"inputs:in"];
            long long v102 = [MEMORY[0x263F83F10] targetPropertyWithProperty:v101];
            uint64_t v103 = v102;
            if (v102)
            {
              [v102 parentNode];
              uint64_t v104 = v68;
              v106 = long long v105 = v75;

              uint64_t v107 = [v106 property:@"info:id"];

              unsigned int v71 = (void *)v107;
              uint64_t v69 = v106;
              __int16 v75 = v105;
              int v68 = v104;
            }
            *(void *)&long long v108 = v275;
            *((void *)&v108 + 1) = v255;
            long long v273 = v108;

            if (v71)
            {
LABEL_93:
              long long v109 = [v71 stringValue];
              int v110 = [v109 isEqualToString:@"UsdPrimvarReader_float2"];

              if (v110)
              {
                int v111 = [v69 property:@"inputs:varname"];
                uint64_t v112 = v111;
                if (v111)
                {
                  uint64_t v113 = [v111 stringValue];
                  long long v114 = v113;
                  if (v113)
                  {
                    uint64_t v115 = (const char *)[v113 UTF8String];
                    size_t v116 = strlen(v115);
                    *(void *)v345 = v115;
                    *(void *)&v345[8] = v116;
                    re::DynamicString::operator=((re::DynamicString *)&v322, (uint64_t)v345);
                  }
                }
              }
            }
            uint64_t v67 = v271;
          }
          else
          {
            uint64_t v270 = 0;
            long long v273 = xmmword_234376D50;
          }

          uint64_t v32 = (uint64_t)a1;
        }

        uint64_t v117 = *((void *)&v322 + 1) >> 1;
        if ((BYTE8(v322) & 1) == 0) {
          uint64_t v117 = BYTE8(v322) >> 1;
        }
        if (v117)
        {
          if (BYTE8(v322)) {
            float v118 = (const char *)v323;
          }
          else {
            float v118 = (char *)&v322 + 9;
          }
          if (v325) {
            uint64_t v119 = *(const char **)&v326[7];
          }
          else {
            uint64_t v119 = v326;
          }
          uint64_t v120 = (_anonymous_namespace_ *)strcmp(v118, v119);
          id v44 = v278;
          if ((v120 == 0) | v266 & 1)
          {
            BOOL v272 = v120 != 0;
            v266 |= v120 != 0;
          }
          else
          {
            re::DynamicString::operator+((re::DynamicString *)buf, (uint64_t)&v322, (re::DynamicString *)__p);
            re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace((uint64_t)v283, (re::DynamicString *)v345, (re::DynamicString *)__p);
            if (__p[0])
            {
              if ((uint64_t)__p[1]) {
                (*(void (**)(void))(*(void *)__p[0] + 40))();
              }
              long long v314 = 0u;
              *(_OWORD *)__p = 0u;
            }
            if (*(void *)buf && (buf[8] & 1) != 0) {
              (*(void (**)(void))(**(void **)buf + 40))();
            }
            if (*(void *)v345 && (v345[8] & 1) != 0) {
              (*(void (**)(void))(**(void **)v345 + 40))();
            }
            BOOL v272 = 1;
            char v266 = 1;
          }
        }
        else
        {
          BOOL v272 = 0;
          id v44 = v278;
        }
        BYTE3(__p[0]) = 0;
        LOBYTE(__p[1]) = 0;
        LOBYTE(v315) = 0;
        BYTE8(v315) = 0;
        char v316 = 0;
        char v317 = 0;
        char v318 = 0;
        char v319 = 0;
        char v320 = 0;
        char v321 = 0;
        LOWORD(__p[0]) = 2;
        LOBYTE(v314) = 1;
        DWORD1(v314) = 2;
        BYTE8(v314) = 1;
        HIDWORD(v314) = 2;
        uint64_t v122 = [v44 parentNode];
        float v123 = [MEMORY[0x263F83F10] shaderNodeType:v122];
        int v124 = [v123 isEqualToString:v269];

        if (v124)
        {
          int v125 = [v122 property:@"inputs:st"];
          uint64_t v126 = [v125 parentNode];
          float v127 = [v126 property:@"info:id"];
          unsigned int v128 = v127;
          if (v127)
          {
            uint64_t v129 = [v127 stringValue];
            int v130 = [v129 isEqualToString:@"UsdUVTexture"];

            if (v130)
            {
              int v262 = DWORD1(v314);
              int v264 = HIDWORD(v314);
              uint64_t v131 = [v126 property:@"inputs:wrapS"];
              uint64_t v132 = v131;
              if (v131)
              {
                uint64_t v133 = [v131 stringValue];
                if ([v133 isEqualToString:@"black"])
                {
                  int v134 = 4;
                  goto LABEL_136;
                }
                if ([v133 isEqualToString:@"clamp"])
                {
                  int v262 = 0;
                  goto LABEL_137;
                }
                if ([v133 isEqualToString:@"repeat"])
                {
                  int v134 = 2;
                  goto LABEL_136;
                }
                if ([v133 isEqualToString:@"mirror"])
                {
                  int v134 = 3;
LABEL_136:
                  int v262 = v134;
                }
                else
                {
                  v257 = v132;
                  v210 = (re *)[v133 isEqualToString:@"useMetadata"];
                  int v211 = (int)v210;
                  log = *re::pipelineLogObjects(v210);
                  BOOL v212 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
                  if (v211)
                  {
                    uint64_t v132 = v257;
                    if (!v212) {
                      goto LABEL_137;
                    }
                    *(_WORD *)v345 = 0;
                    v213 = log;
                    v214 = "Reading wrap mode from image metadata is currently not supported; defaulting to \"black\"";
                  }
                  else
                  {
                    uint64_t v132 = v257;
                    if (!v212) {
                      goto LABEL_137;
                    }
                    *(_WORD *)v345 = 0;
                    v213 = log;
                    v214 = "Wrap mode for imported USD was an invalid option; defaulting to \"black\"";
                  }
                  _os_log_impl(&dword_233120000, v213, OS_LOG_TYPE_DEFAULT, v214, v345, 2u);
                }
LABEL_137:
              }
              long long v135 = [v126 property:@"inputs:wrapT"];
              float v136 = v135;
              if (v135)
              {
                v256 = v132;
                uint64_t v137 = [v135 stringValue];
                if ([v137 isEqualToString:@"black"])
                {
                  int v138 = 4;
                  goto LABEL_147;
                }
                if ([v137 isEqualToString:@"clamp"])
                {
                  int v264 = 0;
                  goto LABEL_148;
                }
                if ([v137 isEqualToString:@"repeat"])
                {
                  int v138 = 2;
                  goto LABEL_147;
                }
                if ([v137 isEqualToString:@"mirror"])
                {
                  int v138 = 3;
LABEL_147:
                  int v264 = v138;
                }
                else
                {
                  v215 = (re *)[v137 isEqualToString:@"useMetadata"];
                  int loga = (int)v215;
                  v242 = *re::pipelineLogObjects(v215);
                  BOOL v216 = os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT);
                  if (loga)
                  {
                    if (!v216) {
                      goto LABEL_148;
                    }
                    *(_WORD *)v345 = 0;
                    v217 = v242;
                    v218 = "Reading wrap mode from image metadata is currently not supported; defaulting to \"black\"";
                  }
                  else
                  {
                    if (!v216) {
                      goto LABEL_148;
                    }
                    *(_WORD *)v345 = 0;
                    v217 = v242;
                    v218 = "Wrap mode for imported USD was an invalid option; defaulting to \"black\"";
                  }
                  _os_log_impl(&dword_233120000, v217, OS_LOG_TYPE_DEFAULT, v218, v345, 2u);
                }
LABEL_148:

                uint64_t v132 = v256;
              }
              if (!(_BYTE)v314) {
                LOBYTE(v314) = 1;
              }
              DWORD1(v314) = v262;
              if (!BYTE8(v314)) {
                BYTE8(v314) = 1;
              }
              HIDWORD(v314) = v264;
            }
          }

          uint64_t v32 = (uint64_t)a1;
          id v44 = v278;
        }

        id v139 = [v277 path];
        float v140 = (const char *)[v139 UTF8String];

        uint64_t v141 = (re::TextureAsset *)strlen(v140);
        uint64_t v142 = re::TextureAsset::assetType(v141);
        uint64_t v143 = (_anonymous_namespace_ *)re::ImportAssetTable::compiledAssetPath((uint64_t)v140, (uint64_t)v141, (re **)v142, (re::DynamicString *)&v311);
        memset(v310, 0, sizeof(v310));
        re::DynamicString::setCapacity(v310, 0);
        uint64_t v144 = *(void *)(v32 + 104);
        float v145 = (re::TextureAsset *)strlen(v140);
        char v146 = re::TextureAsset::assetType(v145);
        float v147 = (re::DynamicString *)re::ImportAssetTable::importedAsset(v144, (uint64_t)v140, (uint64_t)v145, (re **)v146);
        if (v147)
        {
          re::DynamicString::operator=((re::DynamicString *)v310, v147);
        }
        else
        {
          uint64_t isPackageRelativePath = re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v265, (uint64_t)&v311);
          if (isPackageRelativePath)
          {
            uint64_t v150 = isPackageRelativePath;
            re::loadTextureDataWithProvider((re *)isPackageRelativePath, *(re::TextureProvider **)v32, v149, (uint64_t)v345);
            if (v345[0])
            {
              buf[0] = v345[8];
              uint8_t buf[8] = 0;
              unsigned int v343 = -1;
              std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&buf[8], (uint64_t)&v345[16]);
              id v344 = v350;
              re::createTextureCompileOptionsFromTextureImageOptions((re *)(v150 + 48), (uint64_t)v309);
              uint64_t TextureAsset = (re::TextureAsset *)re::TextureAsset::makeTextureAsset((uint64_t)buf, *(_DWORD *)(v150 + 104), v309);
              v153 = *(re::ImportAssetTable **)(v32 + 104);
              v154 = re::TextureAsset::assetType(TextureAsset);
              long long v155 = (re::DynamicString *)re::ImportAssetTable::addAssetWithPath(v153, (const re::DynamicString *)&v311, TextureAsset, (const re::AssetType *)v154);
              re::DynamicString::operator=((re::DynamicString *)v310, v155);

              if (v343 != -1) {
                ((void (*)(_OWORD *, unsigned char *))*(&off_26E6DF7F8 + v343))(v308, &buf[8]);
              }
            }
            else
            {
              v161 = (id)*re::pipelineLogObjects(v151);
              if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
              {
                v219 = [v277 path];
                *(_DWORD *)buf = 138412546;
                *(void *)&uint8_t buf[4] = v219;
                __int16 v340 = 2112;
                v341 = (uint8_t *)v254;
                _os_log_debug_impl(&dword_233120000, v161, OS_LOG_TYPE_DEBUG, "Texture '%@' failed to load (referenced by material '%@'); removing associated texture provider",
                  buf,
                  0x16u);
              }
              unint64_t v162 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v311);
              if (*v265)
              {
                unint64_t v163 = v162 % *(unsigned int *)(v32 + 136);
                uint64_t v164 = *(void *)(v32 + 120);
                uint64_t v165 = *(unsigned int *)(v164 + 4 * v163);
                if (v165 != 0x7FFFFFFF)
                {
                  uint64_t v166 = *(void *)(v32 + 128);
                  if (re::DynamicString::operator==(v166 + 288 * v165 + 16, (uint64_t)&v311))
                  {
                    *(_DWORD *)(v164 + 4 * v163) = *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                    id v44 = v278;
LABEL_181:
                    re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(void *)(v32 + 128) + 288 * v165);
                    *(_DWORD *)(*(void *)(v32 + 128) + 288 * v165 + 8) = *(_DWORD *)(*(void *)(v32 + 128)
                                                                                     + 288 * v165
                                                                                     + 8) & 0x80000000 | *(_DWORD *)(v32 + 148);
                    --*(_DWORD *)(v32 + 140);
                    int v168 = *(_DWORD *)(v32 + 152) + 1;
                    *(_DWORD *)(v32 + 148) = v165;
                    *(_DWORD *)(v32 + 152) = v168;
                  }
                  else
                  {
                    id v44 = v278;
                    while (1)
                    {
                      uint64_t v167 = v165;
                      uint64_t v165 = *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                      if (v165 == 0x7FFFFFFF) {
                        break;
                      }
                      if (re::DynamicString::operator==(v166 + 288 * v165 + 16, (uint64_t)&v311))
                      {
                        *(_DWORD *)(v166 + 288 * v167 + 8) = *(_DWORD *)(v166 + 288 * v167 + 8) & 0x80000000 | *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                        goto LABEL_181;
                      }
                    }
                  }
                }
              }
            }
            re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)v345);
          }
          else
          {
            if (*(unsigned char *)(v32 + 82))
            {
              id v156 = [v277 resolvedPath];
              uint64_t v157 = (char *)[v156 UTF8String];

              size_t v158 = strlen(v157);
              uint64_t isPackageRelativePath = re::isPackageRelativePath(v157, v158);
              if ((isPackageRelativePath & 1) == 0) {
                uint64_t isPackageRelativePath = re::DynamicString::assignf((re::DynamicString *)v310, "sourcepath:%s", v157);
              }
            }
            if (BYTE8(v310[0])) {
              uint64_t v159 = *((void *)&v310[0] + 1) >> 1;
            }
            else {
              uint64_t v159 = BYTE8(v310[0]) >> 1;
            }
            if (!v159)
            {
              v160 = (id)*re::pipelineLogObjects((re *)isPackageRelativePath);
              if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
              {
                v220 = [v277 path];
                *(_DWORD *)v345 = 138412546;
                *(void *)&v345[4] = v254;
                *(_WORD *)&v345[12] = 2112;
                *(void *)&v345[14] = v220;
                _os_log_debug_impl(&dword_233120000, v160, OS_LOG_TYPE_DEBUG, "Material '%@' references texture '%@' which could not be found during loading", v345, 0x16u);
              }
            }
          }
        }
        if (BYTE8(v310[0])) {
          uint64_t v169 = *((void *)&v310[0] + 1) >> 1;
        }
        else {
          uint64_t v169 = BYTE8(v310[0]) >> 1;
        }
        if (!v169) {
          goto LABEL_257;
        }
        v170 = (re::DynamicString *)(v267 + 16);
        re::MaterialTextureParam::MaterialTextureParam((re::MaterialTextureParam *)buf, (const re::DynamicString *)v310);
        unint64_t v171 = re::Hash<re::DynamicString>::operator()((uint64_t)v345, v267 + 16);
        unint64_t v172 = v171;
        if ((void)v286)
        {
          unint64_t v173 = v171 % DWORD2(v287);
          uint64_t v174 = *(unsigned int *)(*((void *)&v286 + 1) + 4 * v173);
          if (v174 != 0x7FFFFFFF)
          {
            uint64_t v175 = v287;
            while (1)
            {
              uint64_t v176 = re::DynamicString::operator==(v175 + 88 * v174 + 16, (uint64_t)v170);
              if (v176) {
                break;
              }
              uint64_t v174 = *(_DWORD *)(v175 + 88 * v174 + 8) & 0x7FFFFFFF;
              if (v174 == 0x7FFFFFFF) {
                goto LABEL_194;
              }
            }
LABEL_195:
            memset(v345, 0, sizeof(v345));
            v177 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v345, 0);
            *(_DWORD *)v346 = 0;
            *(_OWORD *)&v346[8] = 0u;
            long long v347 = 0u;
            v178 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v346[8], 0);
            long long v348 = 0u;
            long long v349 = 0u;
            re::DynamicString::setCapacity(&v348, 0);
            LOBYTE(v350) = 0;
            re::MaterialTextureParam::setString((re::MaterialTextureParam *)v345, (const re::DynamicString *)v310);
            re::DynamicString::operator=((re::DynamicString *)&v346[8], v170);
            if (!(_BYTE)v350) {
              LOBYTE(v350) = 1;
            }
            HIDWORD(v350) = v272;
            unint64_t v179 = re::Hash<re::DynamicString>::operator()((uint64_t)v308, (uint64_t)v170);
            unint64_t v180 = v179;
            if ((void)v290)
            {
              unint64_t v181 = v179 % DWORD2(v291);
              uint64_t v182 = *(unsigned int *)(*((void *)&v290 + 1) + 4 * v181);
              if (v182 != 0x7FFFFFFF)
              {
                uint64_t v183 = v291;
                while (1)
                {
                  uint64_t v184 = re::DynamicString::operator==(v183 + 160 * v182 + 16, (uint64_t)v170);
                  if (v184) {
                    break;
                  }
                  uint64_t v182 = *(_DWORD *)(v183 + 160 * v182 + 8) & 0x7FFFFFFF;
                  if (v182 == 0x7FFFFFFF) {
                    goto LABEL_204;
                  }
                }
LABEL_205:
                memset(v308, 0, sizeof(v308));
                re::DynamicString::setCapacity(v308, 0);
                v185 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)v308, "%f, %f, %f, %f", *(float *)&v273, *((float *)&v273 + 1), *((float *)&v273 + 2), *((float *)&v273 + 3));
                memset(v307, 0, sizeof(v307));
                re::DynamicString::setCapacity(v307, 0);
                v186 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)v307, "%f, %f", *(float *)&v270, *((float *)&v270 + 1));
                if (v272)
                {
                  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v281[24], (re::DynamicString *)&v305, (const re::DynamicString *)v308);
                  v187 = v305;
                  if (v305 && (v306 & 1) != 0) {
                    v187 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v305 + 40))();
                  }
                  v188 = "uvOffset1";
                }
                else
                {
                  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v281[24], (re::DynamicString *)&v305, (const re::DynamicString *)v308);
                  v189 = v305;
                  if (v305 && (v306 & 1) != 0) {
                    v189 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v305 + 40))();
                  }
                  v188 = "uvOffset";
                }
                re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v281[24], (re::DynamicString *)&v305, (const re::DynamicString *)v307);
                if (v305 && (v306 & 1) != 0) {
                  (*(void (**)(void))(*(void *)v305 + 40))();
                }
                unint64_t v190 = re::Hash<re::DynamicString>::operator()((uint64_t)&v305, (uint64_t)v170);
                unint64_t v191 = v190;
                if ((void)v294)
                {
                  unint64_t v192 = v190 % DWORD2(v295);
                  uint64_t v193 = *(unsigned int *)(*((void *)&v294 + 1) + 4 * v192);
                  if (v193 != 0x7FFFFFFF)
                  {
                    uint64_t v194 = v295;
                    while (!re::DynamicString::operator==(v194 + 152 * v193 + 16, (uint64_t)v170))
                    {
                      uint64_t v193 = *(_DWORD *)(v194 + 152 * v193 + 8) & 0x7FFFFFFF;
                      if (v193 == 0x7FFFFFFF) {
                        goto LABEL_224;
                      }
                    }
LABEL_225:
                    if (!re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v327, (uint64_t)v170))
                    {
                      uint64_t v195 = re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v265, (uint64_t)&v311);
                      unint64_t v196 = re::Hash<re::DynamicString>::operator()((uint64_t)&v305, (uint64_t)v170);
                      unint64_t v197 = v196;
                      if ((void)v327)
                      {
                        unint64_t v198 = v196 % DWORD2(v328);
                        uint64_t v199 = *(unsigned int *)(*((void *)&v327 + 1) + 4 * v198);
                        if (v199 != 0x7FFFFFFF)
                        {
                          uint64_t v200 = v328;
                          while (!re::DynamicString::operator==(v200 + 56 * v199 + 16, (uint64_t)v170))
                          {
                            uint64_t v199 = *(_DWORD *)(v200 + 56 * v199 + 8) & 0x7FFFFFFF;
                            if (v199 == 0x7FFFFFFF) {
                              goto LABEL_233;
                            }
                          }
                          goto LABEL_239;
                        }
                      }
                      else
                      {
                        unint64_t v198 = 0;
                      }
LABEL_233:
                      uint64_t v201 = v330;
                      if (v330 == 0x7FFFFFFF)
                      {
                        uint64_t v201 = v329;
                        unsigned int v202 = v329;
                        if (v329 == DWORD2(v328))
                        {
                          re::HashTable<re::DynamicString,re::TextureProvider const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v327, 2 * HIDWORD(v328));
                          unsigned int v202 = v329;
                          unint64_t v198 = v197 % DWORD2(v328);
                        }
                        unsigned int v329 = v202 + 1;
                        uint64_t v203 = v328;
                        int v204 = *(_DWORD *)(v328 + 56 * v201 + 8);
                      }
                      else
                      {
                        uint64_t v203 = v328;
                        int v204 = *(_DWORD *)(v328 + 56 * v330 + 8);
                        LODWORD(v330) = v204 & 0x7FFFFFFF;
                      }
                      *(_DWORD *)(v203 + 56 * v201 + 8) = v204 | 0x80000000;
                      *(_DWORD *)(v328 + 56 * v201 + 8) = *(_DWORD *)(v328 + 56 * v201 + 8) & 0x80000000 | *(_DWORD *)(*((void *)&v327 + 1) + 4 * v198);
                      *(void *)(v328 + 56 * v201) = v197;
                      re::DynamicString::DynamicString((re::DynamicString *)(v328 + 56 * v201 + 16), v170);
                      *(void *)(v328 + 56 * v201 + 48) = v195;
                      *(_DWORD *)(*((void *)&v327 + 1) + 4 * v198) = v201;
                      ++HIDWORD(v328);
                      ++HIDWORD(v330);
                    }
LABEL_239:
                    if (*(void *)&v307[0] && (BYTE8(v307[0]) & 1) != 0) {
                      (*(void (**)(void))(**(void **)&v307[0] + 40))();
                    }
                    uint64_t v32 = (uint64_t)a1;
                    id v44 = v278;
                    if (*(void *)&v308[0] && (BYTE8(v308[0]) & 1) != 0) {
                      (*(void (**)(void))(**(void **)&v308[0] + 40))();
                    }
                    if ((void)v348)
                    {
                      if (BYTE8(v348)) {
                        (*(void (**)(void))(*(void *)v348 + 40))();
                      }
                      long long v348 = 0u;
                      long long v349 = 0u;
                    }
                    if (*(void *)&v346[8])
                    {
                      if (v346[16]) {
                        (*(void (**)(void))(**(void **)&v346[8] + 40))();
                      }
                      *(_OWORD *)&v346[8] = 0u;
                      long long v347 = 0u;
                    }
                    if (*(_DWORD *)v346 != -1) {
                      off_26E6DF7C8[*(unsigned int *)v346]((int)v308, (re::DynamicString *)v345);
                    }
                    if (v342 != -1) {
                      off_26E6DF7C8[v342]((int)v345, (re::DynamicString *)buf);
                    }
LABEL_257:
                    if (*(void *)&v310[0] && (BYTE8(v310[0]) & 1) != 0) {
                      (*(void (**)(void))(**(void **)&v310[0] + 40))();
                    }
                    if (v311 && (v312 & 1) != 0) {
                      (*(void (**)(void))(*(void *)v311 + 40))();
                    }
                    if (void)v322 && (BYTE8(v322)) {
                      (*(void (**)(void))(*(void *)v322 + 40))();
                    }
                    uint64_t ResourcePathAndColorSpaceForTextureProperty = (uint64_t)v277;
LABEL_267:

                    uint64_t v42 = v332;
                    if (v333 <= (int)v30 + 1) {
                      unsigned int v205 = v30 + 1;
                    }
                    else {
                      unsigned int v205 = v333;
                    }
                    while (1)
                    {
                      uint64_t v41 = (v30 + 1);
                      if (v205 - 1 == v30) {
                        break;
                      }
                      LODWORD(v30) = v30 + 1;
                      unsigned int v206 = v41;
                      if ((*(_DWORD *)(v332 + 56 * v41 + 8) & 0x80000000) != 0) {
                        goto LABEL_274;
                      }
                    }
                    unsigned int v206 = v205;
LABEL_274:
                    LODWORD(v30) = v206;
                    if (v276 == v206)
                    {
LABEL_25:
                      uint64_t v34 = [MEMORY[0x263F83F10] constantMaterialPropertiesWithMaterial:v260];
                      re::setFunctionConstantsFromScene(v32, (uint64_t)&v279);
                      re::gatherMaterialConstants((uint64_t)&v281[24], v260, v34, (uint64_t)v331, (uint64_t)&v327);
                      re::setFunctionConstantsFromMaterial((uint64_t)&v279, v338);
                      uint64_t isMaterialAlphaCutout = re::isMaterialAlphaCutout((re *)v34, v35, v36, v37);
                      int v39 = isMaterialAlphaCutout;
                      if (isMaterialAlphaCutout)
                      {
                        int v40 = 1;
                      }
                      else
                      {
                        uint64_t isMaterialAlphaCutout = re::isMaterialTransparent(v34, (uint64_t)v331, (uint64_t)&v327);
                        int v40 = isMaterialAlphaCutout;
                      }
                      LODWORD(v4) = v246;
                      uint64_t v3 = a2;
                      if (v259)
                      {
                        v221 = "engine:missingMaterial.rematerialdefinition";
                      }
                      else
                      {
                        unint64_t v222 = a1[7];
                        if (v222) {
                          unint64_t v223 = v222 >> 1;
                        }
                        else {
                          unint64_t v223 = v222 >> 1;
                        }
                        if (v223)
                        {
                          if (a1[7]) {
                            v224 = (char *)a1[8];
                          }
                          else {
                            v224 = v245;
                          }
                          v221 = v224;
                        }
                        else
                        {
                          if (v249)
                          {
                            if (v39)
                            {
                              v221 = "engine:alphaCutoutPbrOpenSubdiv.rematerialdefinition";
                            }
                            else if (v40)
                            {
                              v221 = "engine:transparentPbrOpenSubdiv.rematerialdefinition";
                            }
                            else
                            {
                              v221 = "engine:pbrOpenSubdiv.rematerialdefinition";
                            }
                          }
                          else if (v39)
                          {
                            v221 = "engine:alphaCutoutPbr.rematerialdefinition";
                          }
                          else if (v40)
                          {
                            v221 = "engine:transparentPbr.rematerialdefinition";
                          }
                          else
                          {
                            v221 = "engine:pbr.rematerialdefinition";
                          }
                        }
                      }

                      if (v324 && (v325 & 1) != 0) {
                        (*(void (**)(void))(*(void *)v324 + 40))();
                      }
                      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v327);

                      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v331);
                      uint64_t v226 = a1[13];
                      if (BYTE8(v279)) {
                        v227 = (char *)v280;
                      }
                      else {
                        v227 = (char *)&v279 + 9;
                      }
                      if (BYTE8(v279)) {
                        uint64_t v228 = *((void *)&v279 + 1) >> 1;
                      }
                      else {
                        uint64_t v228 = BYTE8(v279) >> 1;
                      }
                      v229 = re::MaterialAsset::assetType(v225);
                      uint64_t v230 = re::ImportAssetTable::importedAsset(v226, (uint64_t)v227, v228, (re **)v229);
                      if (!v230)
                      {
                        v231 = re::globalAllocators(0);
                        v232 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v231[2] + 32))(v231[2], 1896, 8);
                        bzero(v232, 0x768uLL);
                        re::MaterialAsset::MaterialAsset((re::MaterialAsset *)v232);
                        re::DynamicString::operator=((re::DynamicString *)(v232 + 8), (re::DynamicString *)&v279);
                        re::AssetHandle::operator=((uint64_t)(v232 + 40), (uint64_t *)v281);
                        re::MaterialParameterData::operator=((uint64_t)(v232 + 64), (uint64_t)&v281[24]);
                        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)(v232 + 304), (uint64_t)v298);
                        re::MaterialRenderFlags::operator=(v232 + 352, v301);
                        v233 = (re::MaterialAsset *)re::DynamicArray<re::FunctionLink>::operator=((uint64_t)(v232 + 376), v302);
                        v234 = (_anonymous_namespace_ *)a1[13];
                        if (BYTE8(v279)) {
                          v235 = (char *)v280;
                        }
                        else {
                          v235 = (char *)&v279 + 9;
                        }
                        if (BYTE8(v279)) {
                          uint64_t v236 = *((void *)&v279 + 1) >> 1;
                        }
                        else {
                          uint64_t v236 = BYTE8(v279) >> 1;
                        }
                        v237 = re::MaterialAsset::assetType(v233);
                        uint64_t v230 = re::ImportAssetTable::addAsset(v234, (uint64_t)v235, v236, v232, (re **)v237);
                      }
                      memset(v345, 0, 24);
                      if (*(unsigned char *)(v230 + 8)) {
                        v238 = *(re::AssetPath **)(v230 + 16);
                      }
                      else {
                        v238 = (re::AssetPath *)(v230 + 9);
                      }
                      re::DynamicArray<re::AssetHandle>::add(a3, (re::AssetHandle *)v345);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)v345);
                      re::DynamicArray<re::FunctionLink>::deinit((uint64_t)v302);
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v298);
                      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v294);
                      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v290);
                      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v286);
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v283);
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v281[24]);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)v281);
                      if (void)v279 && (BYTE8(v279)) {
                        (*(void (**)(void))(*(void *)v279 + 40))();
                      }
                      id v16 = v253;
                      goto LABEL_326;
                    }
                    goto LABEL_28;
                  }
                }
                else
                {
                  LODWORD(v192) = 0;
                }
LABEL_224:
                re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v294, v192, v191, v170, (uint64_t)__p);
                ++HIDWORD(v297);
                goto LABEL_225;
              }
            }
            else
            {
              LODWORD(v181) = 0;
            }
LABEL_204:
            uint64_t v184 = re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v290, v181, v180, v170, (uint64_t)v345);
            ++HIDWORD(v293);
            goto LABEL_205;
          }
        }
        else
        {
          LODWORD(v173) = 0;
        }
LABEL_194:
        uint64_t v176 = re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v286, v173, v172, v170, (unsigned int *)buf);
        ++HIDWORD(v289);
        goto LABEL_195;
      }
    }
    uint64_t v61 = " and ";
    goto LABEL_60;
  }
}

uint64_t re::usdimport::createFloatKeyframeAnimationFromProperty(id *a1, float a2)
{
  id v3 = *a1;
  uint64_t v4 = (re *)[v3 isAnimated];
  if (v4)
  {
    uint64_t v5 = re::globalAllocators(v4);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 128, 8);
    uint64_t v7 = re::Timeline::Timeline(v6, 19);
    *(_WORD *)(v7 + 72) = 256;
    *(_OWORD *)(v7 + 96) = 0u;
    *(_OWORD *)(v7 + 112) = 0u;
    *(_OWORD *)(v7 + 80) = 0u;
    uint64_t v8 = (uint64_t *)(v7 + 80);
    *(void *)uint64_t v7 = &unk_26E6D20B8;
    uint64_t v9 = [v3 timeSamples];
    uint64_t v10 = (_anonymous_namespace_ *)[v9 arraySize];
    [v9 floatArray:*(void *)(v6 + 96) maxCount:v10];
    if (v10)
    {
      unint64_t v12 = 0;
      unint64_t v13 = *(void *)(v6 + 88);
      while (v13 > v12)
      {
        [v3 floatValueAtTime:*(float *)(*(void *)(v6 + 96) + 4 * v12)];
        if (*(void *)(v6 + 112) <= v12) {
          goto LABEL_12;
        }
        *(_DWORD *)(*(void *)(v6 + 120) + 4 * v12) = v14;
        unint64_t v13 = *(void *)(v6 + 88);
        if (v13 <= v12) {
          goto LABEL_13;
        }
        *(float *)(*(void *)(v6 + 96) + 4 * v12) = *(float *)(*(void *)(v6 + 96) + 4 * v12) * a2;
        if (v10 == (_anonymous_namespace_ *)++v12) {
          goto LABEL_8;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_12:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_13:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_8:
    *(unsigned char *)(v6 + 16) = 3;
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

id re::variantNamesInLodVariantSet(void *a1)
{
  id v1 = a1;
  if ([v1 hasVariantSets])
  {
    uint64_t v2 = [v1 variantsWithVariantSet:@"lodVariant"];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void re::appendUsedMaterialsByMeshNodeToTableForHelper(void *a1, int a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  id v5 = a1;
  uint64_t v6 = v5;
  if (a2) {
    char isCatmullClarkSurface = re::isCatmullClarkSurface(v5);
  }
  else {
    char isCatmullClarkSurface = 0;
  }
  uint64_t v8 = [MEMORY[0x263F83F10] meshGroupsWithNode:v6];
  if ([v8 count])
  {
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    id v9 = v8;
    uint64_t v10 = [v9 countByEnumeratingWithState:&v24 objects:v36 count:16];
    if (v10)
    {
      uint64_t v11 = v10;
      int v21 = v8;
      uint64_t v22 = v6;
      uint64_t v12 = *(void *)v25;
      obuint64_t j = v9;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v25 != v12) {
            objc_enumerationMutation(obj);
          }
          int v14 = [*(id *)(*((void *)&v24 + 1) + 8 * i) inheritedMaterialBinding];
          if (v14)
          {
            int v33 = 0;
            char v35 = 0;
            re::ObjCObject::operator=(&v33, v14);
            int v34 = *(_DWORD *)(a3 + 28);
            char v35 = isCatmullClarkSurface;
            size_t v15 = [v14 path];
            id v16 = [v15 stringValue];
            uint64_t v17 = (_anonymous_namespace_ *)[v16 UTF8String];
            v30[0] = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v28);
            re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(a3, v30, (uint64_t)&v33);
            if ((void)v31)
            {
              if (BYTE8(v31)) {
                (*(void (**)(void))(*(void *)v31 + 40))();
              }
              long long v31 = 0u;
              long long v32 = 0u;
            }
            if ((void)v28)
            {
              if (BYTE8(v28)) {
                (*(void (**)(void))(*(void *)v28 + 40))();
              }
              long long v28 = 0u;
              long long v29 = 0u;
            }
          }
        }
        id v9 = obj;
        uint64_t v11 = [obj countByEnumeratingWithState:&v24 objects:v36 count:16];
      }
      while (v11);
      uint64_t v8 = v21;
      uint64_t v6 = v22;
    }
  }
  else
  {
    id v9 = [v6 inheritedMaterialBinding];
    if (v9)
    {
      int v33 = 0;
      char v35 = 0;
      re::ObjCObject::operator=(&v33, v9);
      int v34 = *(_DWORD *)(a3 + 28);
      char v35 = isCatmullClarkSurface;
      int v18 = [v9 path];
      id v19 = [v18 stringValue];
      uint64_t v20 = (_anonymous_namespace_ *)[v19 UTF8String];
      v30[0] = isCatmullClarkSurface;
      re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v28);
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(a3, v30, (uint64_t)&v33);
      if ((void)v31)
      {
        if (BYTE8(v31)) {
          (*(void (**)(void))(*(void *)v31 + 40))();
        }
        long long v31 = 0u;
        long long v32 = 0u;
      }
      if ((void)v28)
      {
        if (BYTE8(v28)) {
          (*(void (**)(void))(*(void *)v28 + 40))();
        }
        long long v28 = 0u;
        long long v29 = 0u;
      }
    }
  }
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t v6 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v15, a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_9;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_9:
    unsigned int v12 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addEmplace<re::MaterialInfoUSK&>(a1, v8, v7, (re::DynamicString *)a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 16) + 72 * v12;
    return v13 + 56;
  }
  int v10 = *a2;
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(unsigned __int8 *)(v11 + 72 * v9 + 16) != v10
       || !re::DynamicString::operator==(v11 + 72 * v9 + 24, (uint64_t)(a2 + 8)))
  {
    uint64_t v9 = *(_DWORD *)(v11 + 72 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_9;
    }
  }
  uint64_t v13 = v11 + 72 * v9;
  return v13 + 56;
}

void re::findSkeletonAndSkeletalAnimationIndices(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v5 = a2;
  unint64_t v6 = [v5 inheritedSkeletonBinding];
  unint64_t v7 = v6;
  if (!v6)
  {
LABEL_17:
    *(unsigned char *)a1 = 1;
    *(unsigned char *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    goto LABEL_22;
  }
  unint64_t v8 = [v6 path];
  id v9 = [v8 stringValue];
  int v10 = (char *)[v9 UTF8String];
  if (v10)
  {
    uint64_t v11 = *v10;
    if (*v10)
    {
      char v12 = v10[1];
      if (v12)
      {
        uint64_t v13 = (unsigned __int8 *)(v10 + 2);
        do
        {
          uint64_t v11 = 31 * v11 + v12;
          int v14 = *v13++;
          char v12 = v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v36 = 2 * v11;
  uint64_t v37 = v10;

  char v15 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3 + 112, &v36);
  if (!v15)
  {
    unint64_t v23 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      long long v29 = v23;
      uint64_t v30 = objc_msgSend(v5, "path", v36, v37);
      id v31 = [v30 stringValue];
      uint64_t v32 = [v31 UTF8String];
      int v33 = [v7 path];
      id v34 = [v33 stringValue];
      uint64_t v35 = [v34 UTF8String];
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v35;
      _os_log_error_impl(&dword_233120000, v29, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeleton: %s.", buf, 0x16u);
    }
    re::StringID::destroyString((re::StringID *)&v36);
    goto LABEL_17;
  }
  uint64_t v16 = *v15;
  uint64_t v17 = objc_msgSend(v5, "inheritedSkeletonAnimationBinding", v36, v37);
  if (v17
    || ([v7 inheritedSkeletonAnimationBinding], (uint64_t v17 = objc_claimAutoreleasedReturnValue()) != 0))
  {
LABEL_12:
    int v18 = [v17 path];
    id v19 = [v18 stringValue];
    uint64_t v20 = (_anonymous_namespace_ *)[v19 UTF8String];
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = "";
    int v21 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3 + 216, buf);
    if (v21)
    {
      a3 = *v21;
      int v22 = 1;
    }
    else
    {
      int v22 = 0;
    }
    re::StringID::destroyString((re::StringID *)buf);

    goto LABEL_20;
  }
  uint64_t v17 = [v5 childIterator];
  uint64_t v24 = [v17 nextObject];
  if (v24)
  {
    long long v25 = (void *)v24;
    long long v26 = (void *)*MEMORY[0x263F84008];
    while (1)
    {
      long long v27 = [v25 type];

      if (v27 == v26) {
        break;
      }
      uint64_t v28 = [v17 nextObject];

      long long v25 = (void *)v28;
      if (!v28) {
        goto LABEL_27;
      }
    }

    uint64_t v17 = v25;
    goto LABEL_12;
  }
LABEL_27:
  int v22 = 0;
LABEL_20:

  re::StringID::destroyString((re::StringID *)&v36);
  *(unsigned char *)a1 = 1;
  *(unsigned char *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = v16;
  *(unsigned char *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v22;
  if (v22) {
    *(void *)(a1 + 32) = a3;
  }
LABEL_22:
}

void re::loadModelFromMeshNode(uint64_t a1, void *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  id v9 = a2;
  uint64_t v44 = a5;
  int v10 = *(unsigned __int8 **)(a5 + 40);
  id v11 = v9;
  char v12 = [MEMORY[0x263F83F10] meshGroupsWithNode:v11];
  if ([(_anonymous_namespace_ *)v12 count])
  {
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v13 = v12;
    uint64_t v14 = [(_anonymous_namespace_ *)v13 countByEnumeratingWithState:&v47 objects:&v52 count:16];
    if (v14)
    {
      uint64_t v15 = v14;
      unint64_t v41 = a4;
      uint64_t v42 = a3;
      uint64_t v43 = a1;
      uint64_t v16 = *(void *)v48;
      while (2)
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          if (*(void *)v48 != v16) {
            objc_enumerationMutation(v13);
          }
          objc_msgSend(*(id *)(*((void *)&v47 + 1) + 8 * i), "inheritedMaterialBinding", v41, v42, v43);
          id v18 = (id)objc_claimAutoreleasedReturnValue();
          uint64_t v19 = [MEMORY[0x263F83F10] firstUVMeshAttributeNameInMaterial:v18];
          if (v19)
          {
            uint64_t v20 = (void *)v19;
            v51[0] = "primvars:";
            v51[1] = 9;
            re::DynamicString::operator=((re::DynamicString *)&v45, (uint64_t)v51);
            id v21 = v20;
            int v22 = (const char *)[v21 UTF8String];
            size_t v23 = strlen(v22);
            re::DynamicString::append((re::DynamicString *)&v45, v22, v23);

            a3 = v42;
            a1 = v43;
            a4 = v41;
            goto LABEL_14;
          }
        }
        uint64_t v15 = [(_anonymous_namespace_ *)v13 countByEnumeratingWithState:&v47 objects:&v52 count:16];
        if (v15) {
          continue;
        }
        break;
      }
      a3 = v42;
      a1 = v43;
      a4 = v41;
    }
  }
  else
  {
    uint64_t v13 = [v11 inheritedMaterialBinding];
    id v18 = [MEMORY[0x263F83F10] firstUVMeshAttributeNameInMaterial:v13];
    if (v18)
    {
      *(void *)&long long v52 = "primvars:";
      *((void *)&v52 + 1) = 9;
      re::DynamicString::operator=((re::DynamicString *)&v45, (uint64_t)&v52);
      id v18 = v18;
      uint64_t v24 = (const char *)[v18 UTF8String];
      size_t v25 = strlen(v24);
      re::DynamicString::append((re::DynamicString *)&v45, v24, v25);
    }
LABEL_14:
  }
  long long v26 = [v11 inheritedSkeletonBinding];
  long long v27 = v26;
  long long v47 = 0uLL;
  if (!v26)
  {
    unint64_t v36 = 0;
LABEL_27:
    re::makeGeomModelDescriptorFromUSKNode(v11, (uint64_t)&v45, a3, v10[165], v10[166], v10[164], (uint64_t)&v47, v36, a1);
    goto LABEL_28;
  }
  if (a4 != -1)
  {
    uint64_t v28 = [v26 path];
    id v29 = [v28 stringValue];
    uint64_t v30 = (char *)[v29 UTF8String];
    id v31 = v30;
    if (v30)
    {
      uint64_t v32 = *v30;
      if (*v30)
      {
        char v33 = v30[1];
        if (v33)
        {
          id v34 = (unsigned __int8 *)(v30 + 2);
          do
          {
            uint64_t v32 = 31 * v32 + v33;
            int v35 = *v34++;
            char v33 = v35;
          }
          while (v35);
        }
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    *(void *)&long long v52 = 2 * v32;
    *((void *)&v52 + 1) = v30;

    unint64_t v36 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](v44 + 56, a4) + 16;
    size_t v40 = strlen(v31);
    *(void *)&long long v47 = v31;
    *((void *)&v47 + 1) = v40;
    re::StringID::destroyString((re::StringID *)&v52);
    goto LABEL_27;
  }
  long long v37 = v52;
  uint64_t v38 = v53;
  uint64_t v39 = v54;
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = 100;
  *(void *)(a1 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v37;
  *(void *)(a1 + 40) = v38;
  *(void *)(a1 + 48) = v39;
LABEL_28:

  if (v45 && (v46 & 1) != 0) {
    (*(void (**)(void))(*(void *)v45 + 40))();
  }
}

void re::loadAllLodModelsForModelPathHelper(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  id v65 = a2;
  id v13 = a3;
  id v64 = a4;
  id v14 = a7;
  uint64_t v74 = 0;
  long long v72 = 0uLL;
  uint64_t v71 = 0;
  int v73 = 0;
  uint64_t v15 = [v14 objectAtIndexedSubscript:0];
  int v53 = [v15 isEqualToString:@"card"];

  unsigned int v16 = [v14 count];
  if (v16) {
    re::DynamicArray<re::GeomModelDescriptor>::setCapacity(&v71, v16);
  }
  [v13 selectVariant:@"default" variantSet:@"lodVariant"];
  uint64_t v17 = [v65 nodeAtPath:v64];
  if (!*(void *)(a8 + 16))
  {
LABEL_69:
    uint64_t v75 = 0;
    long long v79 = 0u;
    long long v80 = 0u;
    memset(v78, 0, sizeof(v78));
    long long v77 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)double v76 = 136315906;
    *(void *)&void v76[4] = "operator[]";
    *(_WORD *)&v76[12] = 1024;
    *(_DWORD *)&v76[14] = 797;
    *(_WORD *)&unsigned char v76[18] = 2048;
    *(void *)&v76[20] = 0;
    *(_WORD *)&v76[28] = 2048;
    *(void *)&v76[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  id v18 = v17;
  re::loadModelFromMeshNode((uint64_t)&v66, v17, a6, **(void **)(a8 + 32), a5);
  if (!(_BYTE)v66)
  {
    long long v77 = v67;
    goto LABEL_49;
  }
  uint64_t v60 = v14;
  uint64_t v19 = [v18 name];
  id v20 = [v19 stringValue];
  id v21 = (id)[v20 UTF8String];
  id v61 = v13;
  int v59 = (void *)a8;
  if (v21)
  {
    id v13 = [v18 name];
    id v8 = [v13 stringValue];
    int v22 = (const char *)[v8 UTF8String];
  }
  else
  {
    int v22 = "";
  }
  re::DynamicString::format((re::DynamicString *)"%s-default", (re::DynamicString *)&v77, v22);
  re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
  if ((void)v77)
  {
    if (BYTE8(v77)) {
      (*(void (**)(void, void))(*(void *)v77 + 40))(v77, *(void *)&v78[0]);
    }
    long long v77 = 0u;
    v78[0] = 0u;
  }
  if (v21)
  {
  }
  re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
  re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

  if (v53) {
    uint64_t v23 = 2;
  }
  else {
    uint64_t v23 = 1;
  }
  uint64_t v55 = v23;
  id v13 = v61;
  uint64_t v24 = (void *)a8;
  if (v23 >= v16)
  {
LABEL_44:
    if (v53)
    {
      [v13 selectVariant:@"card" variantSet:@"lodVariant"];
      uint64_t v39 = [v65 nodeAtPath:v64];
      re::loadModelFromMeshNode((uint64_t)&v66, v39, a6, *(void *)(v24[4] + 8 * v24[2] - 8), a5);
      if (!(_BYTE)v66)
      {
        long long v77 = v67;
        re::DynamicString::DynamicString((re::DynamicString *)v78, (const re::DynamicString *)&v68);
        *(unsigned char *)a1 = 0;
        *(_OWORD *)(a1 + 8) = v77;
        uint64_t v45 = *((void *)&v78[1] + 1);
        *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)&v78[0];
        *(void *)(a1 + 48) = v45;
        *(_OWORD *)(a1 + 32) = *(_OWORD *)((char *)v78 + 8);
        re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

LABEL_66:
        id v14 = v60;
        goto LABEL_67;
      }
      size_t v40 = [v39 name];
      id v41 = [v40 stringValue];
      uint64_t v42 = [v41 UTF8String];
      if (v42)
      {
        uint64_t v24 = [v39 name];
        id v21 = [v24 stringValue];
        uint64_t v43 = (const char *)[v21 UTF8String];
      }
      else
      {
        uint64_t v43 = "";
      }
      char v46 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-card", (re::DynamicString *)v76, v43);
      char v47 = v76[8];
      if (v76[8]) {
        long long v48 = *(const char **)&v76[16];
      }
      else {
        long long v48 = &v76[9];
      }
      re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
      if ((void)v77)
      {
        if (BYTE8(v77)) {
          (*(void (**)(void))(*(void *)v77 + 40))();
        }
        long long v77 = 0u;
        v78[0] = 0u;
      }
      if (*(void *)v76 && (v47 & 1) != 0) {
        (*(void (**)(void))(**(void **)v76 + 40))();
      }
      if (v42)
      {
      }
      re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
      re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

      id v13 = v61;
    }
    [v13 selectVariant:@"default" variantSet:@"lodVariant"];
    uint64_t v49 = v71;
    uint64_t v71 = 0;
    uint64_t v50 = v74;
    uint64_t v74 = 0;
    ++v73;
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = v49;
    uint64_t v66 = 0;
    long long v51 = v72;
    long long v72 = 0u;
    *(_OWORD *)(a1 + 16) = v51;
    long long v67 = 0u;
    *(void *)(a1 + 40) = v50;
    uint64_t v69 = 0;
    int v68 = 2;
    *(_DWORD *)(a1 + 32) = 1;
    re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v66);
    goto LABEL_66;
  }
  uint64_t v25 = 0;
  unint64_t v54 = v16 - (unint64_t)v23;
  while (1)
  {
    unint64_t v26 = (v25 + 1);
    id v14 = v60;
    long long v27 = [v60 objectAtIndexedSubscript:v55 + v25];
    [v13 selectVariant:v27 variantSet:@"lodVariant"];

    uint64_t v28 = [v65 nodeAtPath:v64];
    unint64_t v29 = v24[2];
    if (v29 <= v26)
    {
      uint64_t v75 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      memset(v78, 0, sizeof(v78));
      long long v77 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)double v76 = 136315906;
      *(void *)&void v76[4] = "operator[]";
      *(_WORD *)&v76[12] = 1024;
      *(_DWORD *)&v76[14] = 797;
      *(_WORD *)&unsigned char v76[18] = 2048;
      *(void *)&v76[20] = (v25 + 1);
      *(_WORD *)&v76[28] = 2048;
      *(void *)&v76[30] = v29;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_69;
    }
    id v18 = v28;
    re::loadModelFromMeshNode((uint64_t)&v66, v28, a6, *(void *)(v24[4] + 8 * v26), a5);
    if (!(_BYTE)v66) {
      break;
    }
    id v21 = [v18 name];
    id v30 = [v21 stringValue];
    uint64_t v31 = [v30 UTF8String];
    if (v31)
    {
      uint64_t v58 = [v18 name];
      id v56 = [v58 stringValue];
      uint64_t v32 = (const char *)[v56 UTF8String];
    }
    else
    {
      uint64_t v32 = "";
    }
    char v33 = [v60 objectAtIndexedSubscript:(v25 + 1)];
    uint64_t v34 = [v33 length];
    if (v34)
    {
      id v57 = [v60 objectAtIndexedSubscript:(v25 + 1)];
      int v35 = (const char *)[v57 UTF8String];
    }
    else
    {
      int v35 = "";
    }
    unint64_t v36 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-%s", (re::DynamicString *)v76, v32, v35);
    char v37 = v76[8];
    if (v76[8]) {
      uint64_t v38 = *(const char **)&v76[16];
    }
    else {
      uint64_t v38 = &v76[9];
    }
    re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
    if ((void)v77)
    {
      if (BYTE8(v77)) {
        (*(void (**)(void))(*(void *)v77 + 40))();
      }
      long long v77 = 0u;
      v78[0] = 0u;
    }
    if (*(void *)v76)
    {
      if (v37) {
        (*(void (**)(void))(**(void **)v76 + 40))();
      }
      memset(v76, 0, 32);
    }
    if (v34) {

    }
    if (v31)
    {
    }
    re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
    re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

    ++v25;
    id v13 = v61;
    uint64_t v24 = v59;
    if (v54 == v25) {
      goto LABEL_44;
    }
  }
  long long v77 = v67;
LABEL_49:
  re::DynamicString::DynamicString((re::DynamicString *)v78, (const re::DynamicString *)&v68);
  *(unsigned char *)a1 = 0;
  *(_OWORD *)(a1 + 8) = v77;
  uint64_t v44 = *((void *)&v78[1] + 1);
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)&v78[0];
  *(void *)(a1 + 48) = v44;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)((char *)v78 + 8);
  re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

LABEL_67:
  re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v71);
}

uint64_t re::DynamicArray<re::GeomModelDescriptor>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::GeomModelDescriptor>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::GeomModelDescriptor>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t result = re::GeomModelDescriptor::GeomModelDescriptor(*(void *)(a1 + 32) + 216 * v5, a2);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::loadTransformAndMeshNodes(void *a1, void *a2, re::USDImportContext *a3, char a4)
{
  uint64_t v623 = *MEMORY[0x263EF8340];
  id v537 = a1;
  id v8 = a2;
  uint64_t v575 = *((void *)a3 + 5);
  unint64_t v9 = *(unsigned __int8 *)(v575 + 96);
  unint64_t v10 = [v8 type];
  v562 = a3;
  v548 = v8;
  v527 = v10;
  if (![MEMORY[0x263F83F10] isSceneGraphNode:v8]
    || ([MEMORY[0x263F83F10] isTransformNode:v8] & 1) == 0)
  {
    id v11 = [v8 typeName];
    char v12 = [v11 stringValue];
    if ([v12 isEqualToString:@"Preliminary_Text"])
    {
LABEL_8:

      unint64_t v10 = v527;
      goto LABEL_9;
    }
    id v13 = [v8 typeName];
    id v14 = [v13 stringValue];
    if ([v14 isEqualToString:@"Preliminary_InfiniteColliderPlane"])
    {
LABEL_7:

      id v8 = v548;
      goto LABEL_8;
    }
    unsigned int v567 = v9;
    uint64_t v15 = [v548 typeName];
    unsigned int v16 = [v15 stringValue];
    if ([v16 isEqualToString:@"Preliminary_DeformerStack"])
    {

      a3 = v562;
      unint64_t v9 = v567;
      goto LABEL_7;
    }
    long long v67 = [v548 typeName];
    unint64_t v4 = [v67 stringValue];
    char objc = [v4 isEqualToString:@"DeformerStack"];

    a3 = v562;
    id v8 = v548;
    unint64_t v10 = v527;
    unint64_t v9 = v567;
    if ((objc & 1) == 0)
    {
      int v68 = [v548 typeName];
      uint64_t v69 = [v68 stringValue];
      int v70 = [v69 isEqualToString:@"Preliminary_Action"];

      if (v70)
      {
        uint64_t v71 = [v548 property:@"audio"];
        long long v72 = [v71 resourcePath];
        int v73 = [v548 property:@"affectedObjects"];

        uint64_t v74 = [v73 stringValue];
        uint64_t v75 = (void *)v74;
        if (v72 && v74)
        {
          re::usdimport::createAudioFileAssetForResourcePath(*(_anonymous_namespace_ **)(v575 + 104), v72, 0, 0, 0, (re::DynamicString *)v620);
          double v76 = [v548 path];
          id v77 = [v76 stringValue];
          float v78 = (_anonymous_namespace_ *)[v77 UTF8String];
          re::AssetHandle::serializationString((re::AssetHandle *)v620, (re::DynamicString *)__s);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(v575 + 264, (re::DynamicString *)buf, __s);
          if (*(void *)__s && (__s[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)__s + 40))();
          }
          if (*(void *)buf)
          {
            if (buf[8]) {
              (*(void (**)(void))(**(void **)buf + 40))();
            }
            memset(buf, 0, 32);
          }

          long long v79 = (_anonymous_namespace_ *)[v75 UTF8String];
          if (__s[8]) {
            long long v80 = *(unsigned char **)&__s[16];
          }
          else {
            long long v80 = &__s[9];
          }
          if (__s[8]) {
            unint64_t v81 = *(void *)&__s[8] >> 1;
          }
          else {
            unint64_t v81 = __s[8] >> 1;
          }
          *(void *)&v588[0] = re::innerPathFromPackageRelativePath((uint64_t)v80, v81);
          *((void *)&v588[0] + 1) = v82;
          float32x4_t v83 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v575 + 312, (uint64_t)v618);
          if (!v83)
          {
            *(void *)&buf[32] = 0;
            memset(buf, 0, 28);
            float32x4_t v83 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(v575 + 312, (const re::DynamicString *)v618, (uint64_t)buf);
            re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
          }
          re::DynamicArray<re::AssetHandle>::add(v83, (re::AssetHandle *)v620);
          if (v618[0].__r_.__value_.__r.__words[0] && (v618[0].__r_.__value_.__s.__data_[8] & 1) != 0) {
            (*(void (**)(void))(*(void *)v618[0].__r_.__value_.__l.__data_ + 40))();
          }
          id v8 = v548;
          if (*(void *)__s && (__s[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)__s + 40))();
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v620);
        }
      }
      else
      {
        uint64_t v164 = (re *)[v527 isEqualToString:*MEMORY[0x263F84030]];
        if (!v164) {
          goto LABEL_195;
        }
        uint64_t v165 = *re::pipelineLogObjects(v164);
        if (!os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_195;
        }
        v494 = v165;
        int v73 = [v548 typeName];
        id v495 = [v73 stringValue];
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = [v495 UTF8String];
        _os_log_debug_impl(&dword_233120000, v494, OS_LOG_TYPE_DEBUG, "USD import discovered unknown node, type = %s", buf, 0xCu);
      }
LABEL_195:
      int v523 = 0;
      goto LABEL_344;
    }
  }
LABEL_9:
  if (a4)
  {
    int v523 = 0;
    goto LABEL_17;
  }
  uint64_t v17 = [v8 typeName];
  id v18 = [v17 stringValue];
  if ([v18 isEqualToString:@"Preliminary_DeformerStack"])
  {
    int v523 = 0;
  }
  else
  {
    unint64_t v19 = v9;
    id v20 = [v8 typeName];
    id v21 = [v20 stringValue];
    int v22 = v8;
    char v23 = [v21 isEqualToString:@"DeformerStack"];

    if (v23)
    {
      int v523 = 0;
      id v8 = v22;
      unint64_t v10 = v527;
      unint64_t v9 = v19;
      goto LABEL_17;
    }
    uint64_t v17 = [v22 name];
    id v18 = [v17 stringValue];
    uint64_t v24 = (const char *)[v18 UTF8String];
    uint64_t v25 = [v22 path];
    id v26 = [v25 stringValue];
    re::USDImportContext::pushNodePath(a3, v24, "(default)", (const char *)[v26 UTF8String]);

    int v523 = 1;
    id v8 = v22;
    unint64_t v9 = v19;
  }

  unint64_t v10 = v527;
LABEL_17:
  long long v27 = [v8 property:@"purpose"];
  uint64_t v28 = v27;
  if (v27)
  {
    unint64_t v29 = [v27 stringValue];
    obunsigned int j = [v29 isEqualToString:@"guide"];
  }
  else
  {
    obunsigned int j = 0;
  }
  v546 = [v8 inheritedSkeletonBinding];
  if (!v546)
  {
    [MEMORY[0x263F83F10] localTransformWithNode:v8 time:0.0];
    long long v568 = v33;
    float32x4_t v34 = vmulq_f32(v30, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v32, (int8x16_t)v32, 0xCuLL), (int8x16_t)v32, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v31, (int8x16_t)v31, 0xCuLL), (int8x16_t)v31, 8uLL)));
    BOOL v35 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0] <= 0.0;
    float v36 = -1.0;
    if (!v35) {
      float v36 = 1.0;
    }
    float32x4_t v37 = vmulq_f32(v30, v30);
    float32x4_t v38 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1)));
    v38.f32[0] = sqrtf(v38.f32[0]);
    float32x4_t v39 = vmulq_f32(v31, v31);
    float32x4_t v40 = vmulq_f32(v32, v32);
    v38.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
    v38.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0]);
    long long v563 = (__int128)vmulq_n_f32(v38, v36);
    float32x4_t v41 = vdivq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v563, 0));
    float32x4_t v42 = vdivq_f32(v31, (float32x4_t)vdupq_lane_s32((int32x2_t)(v563 >> 32), 0));
    float32x4_t v43 = vdivq_f32(v32, (float32x4_t)vdupq_laneq_s32((int32x4_t)v563, 2));
    int32x4_t v44 = (int32x4_t)vmulq_f32(v41, v41);
    v44.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v44, 2), vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v44.i8, 1))).u32[0];
    *(float32x2_t *)v38.f32 = vrsqrte_f32((float32x2_t)v44.u32[0]);
    *(float32x2_t *)v38.f32 = vmul_f32(*(float32x2_t *)v38.f32, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v38.f32)));
    v624.columns[0] = (simd_float3)vmulq_n_f32(v41, vmul_f32(*(float32x2_t *)v38.f32, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v38.f32))).f32[0]);
    float32x4_t v45 = vmulq_f32((float32x4_t)v624.columns[0], v42);
    float32x4_t v46 = vmulq_f32((float32x4_t)v624.columns[0], (float32x4_t)v624.columns[0]);
    float32x4_t v47 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 2), vaddq_f32(v46, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 1)));
    float32x4_t v48 = vsubq_f32(v42, vmulq_n_f32((float32x4_t)v624.columns[0], vdivq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))), v47).f32[0]));
    int32x4_t v49 = (int32x4_t)vmulq_f32(v48, v48);
    v49.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v49, 2), vadd_f32(*(float32x2_t *)v49.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v49.i8, 1))).u32[0];
    *(float32x2_t *)v39.f32 = vrsqrte_f32((float32x2_t)v49.u32[0]);
    *(float32x2_t *)v39.f32 = vmul_f32(*(float32x2_t *)v39.f32, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(*(float32x2_t *)v39.f32, *(float32x2_t *)v39.f32)));
    v49.i32[0] = vmul_f32(*(float32x2_t *)v39.f32, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(*(float32x2_t *)v39.f32, *(float32x2_t *)v39.f32))).u32[0];
    float32x4_t v50 = vmulq_f32((float32x4_t)v624.columns[0], v43);
    v624.columns[1] = (simd_float3)vmulq_n_f32(v48, *(float *)v49.i32);
    float32x4_t v51 = vsubq_f32(v43, vmulq_n_f32((float32x4_t)v624.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0]/ v47.f32[0]));
    float32x4_t v52 = vmulq_f32(v43, (float32x4_t)v624.columns[1]);
    float32x4_t v53 = vmulq_f32((float32x4_t)v624.columns[1], (float32x4_t)v624.columns[1]);
    float32x4_t v54 = vsubq_f32(v51, vmulq_n_f32((float32x4_t)v624.columns[1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 2), vaddq_f32(v53, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 1))).f32[0]));
    int32x4_t v55 = (int32x4_t)vmulq_f32(v54, v54);
    v55.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v55, 2), vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v55.i8, 1))).u32[0];
    *(float32x2_t *)v53.f32 = vrsqrte_f32((float32x2_t)v55.u32[0]);
    *(float32x2_t *)v53.f32 = vmul_f32(*(float32x2_t *)v53.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v53.f32)));
    v624.columns[2] = (simd_float3)vmulq_n_f32(v54, vmul_f32(*(float32x2_t *)v53.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v53.f32))).f32[0]);
    *(double *)v56.i64 = simd_quaternion(v624);
    uint64_t v57 = v56.i64[1];
    float32x4_t v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1);
    unsigned __int8 v59 = vmovn_s32((int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v56, v58), (int8x16_t)vcgeq_f32(v58, v56)))).u8[0];
    *(int32x2_t *)v58.f32 = vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL));
    *(int8x8_t *)v58.f32 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v58.f32), (int8x8_t)vcgez_f32(*(float32x2_t *)v58.f32)));
    char v60 = v59 | v58.i8[4] | v58.i8[0];
    BOOL v61 = (v60 & 1) == 0;
    if (v60) {
      uint64_t v62 = 0;
    }
    else {
      uint64_t v62 = v56.i64[0];
    }
    *(_OWORD *)buf = v563;
    if (!v61) {
      uint64_t v57 = 0x3F80000000000000;
    }
    *(void *)&unsigned char buf[24] = v57;
    *(void *)&uint8_t buf[16] = v62;
    *(_OWORD *)&buf[32] = v568;
    uint64_t v63 = objc_msgSend(MEMORY[0x263F83F10], "transformKeyTimesWithNode:", v8, *(double *)re::USDImportContext::concatenateLocalTransform((uint64_t)a3, (float32x4_t *)buf).i64);
    if ((unint64_t)[v63 arraySize] >= 2 && *(unsigned char *)(*((void *)a3 + 5) + 97))
    {

      if (v9)
      {
        re::TimelineAssetData::TimelineAssetData((uint64_t)buf, 33);
        LOWORD(v59re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 256;
        uint64_t v601 = 0;
        long long v598 = 0u;
        long long v599 = 0u;
        int v600 = 0;
        *(void *)buf = &unk_26E6D0CB8;
        __s[0] = 1;
        float v64 = *(double *)a3;
        *((float *)&v597 + 1) = v64;
        if (v64 <= 0.0016667
          || fabsf(v64 + -0.0016667) < (float)((float)((float)(fabsf(v64) + 0.0016667) + 1.0) * 0.00001)
          || !*((unsigned char *)a3 + 32))
        {
          BYTE1(v59re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
        }
        re::importSRTSampledAnimationFromUSKNode(v8, (float *)buf, (uint64_t)v618);
        data = (re *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)__s, (uint64_t)v618);
        if (!v618[0].__r_.__value_.__s.__data_[0])
        {
          data = (re *)v618[1].__r_.__value_.__l.__data_;
          if (v618[1].__r_.__value_.__r.__words[0])
          {
            if (v618[1].__r_.__value_.__s.__data_[8]) {
              data = (re *)(*(uint64_t (**)(void))(*(void *)v618[1].__r_.__value_.__l.__data_ + 40))();
            }
          }
        }
        if (__s[0])
        {
          if (*(unsigned char *)(*((void *)a3 + 5) + 160))
          {
            uint64_t v66 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(void *)(*((void *)a3 + 106) + 8 * *((void *)a3 + 104) - 8));
            v620[0] = v601;
            v620[1] = *((void *)&v599 + 1);
            v618[0].__r_.__value_.__r.__words[0] = v66 + 432;
            v618[0].__r_.__value_.__l.__size_ = 1;
            LOBYTE(v59re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = re::AnimationHelper::makeAdditiveForValues<re::GenericSRT<float>>((re *)v620, (uint64_t)v618, v601, *((unint64_t *)&v599 + 1));
          }
          re::USDImportContext::setTransformAnimation((uint64_t)a3, (uint64_t)buf);
        }
        else
        {
          float v84 = (id)*re::pipelineLogObjects(data);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
          {
            std::error_code::message(v618, (const std::error_code *)&__s[8]);
            v487 = (v618[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? v618
                 : (std::string *)v618[0].__r_.__value_.__r.__words[0];
            v488 = (__s[32] & 1) != 0 ? *(unsigned char **)&__s[40] : &__s[33];
            LODWORD(v620[0]) = 136315394;
            *(void *)((char *)v620 + 4) = v487;
            WORD2(v620[1]) = 2080;
            *(void *)((char *)&v620[1] + 6) = v488;
            _os_log_error_impl(&dword_233120000, v84, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", (uint8_t *)v620, 0x16u);
            if (SHIBYTE(v618[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v618[0].__r_.__value_.__l.__data_);
            }
          }
        }
        if (!__s[0] && *(void *)&__s[24] && (__s[32] & 1) != 0) {
          (*(void (**)(void))(**(void **)&__s[24] + 40))();
        }
        *(void *)buf = &unk_26E6D0D28;
        if (*((void *)&v598 + 1))
        {
          if (v601) {
            (*(void (**)(void))(**((void **)&v598 + 1) + 40))();
          }
          uint64_t v601 = 0;
          long long v599 = 0uLL;
          *((void *)&v598 + 1) = 0;
          ++v600;
        }
        *(void *)buf = &unk_26E6D3730;
        unint64_t v10 = v527;
        if (*(void *)&buf[40])
        {
          if (buf[48]) {
            (*(void (**)(void))(**(void **)&buf[40] + 40))();
          }
          *(_OWORD *)&buf[40] = 0u;
          long long v596 = 0u;
        }
        re::StringID::destroyString((re::StringID *)&buf[24]);
      }
    }
    else
    {
    }
  }
  if ([v10 isEqualToString:*MEMORY[0x263F83FF8]])
  {
    v541 = v28;
    __float2 v85 = [v8 property:@"visibility"];
    uint64_t v86 = v85;
    if (!v85) {
      goto LABEL_88;
    }
    unint64_t v87 = [v85 tokenValue];
    if (!v87) {
      goto LABEL_88;
    }
    float32x4_t v88 = v87;
    [v87 stringValue];
    v90 = float32x4_t v89 = v86;
    char v91 = [v90 isEqualToString:@"invisible"];

    uint64_t v86 = v89;
    if ((v91 & 1) == 0)
    {
LABEL_88:
      v539 = v86;
      uint64_t v608 = 0;
      memset(v606, 0, sizeof(v606));
      int v607 = 0;
      v587[0] = 0;
      long long v585 = 0u;
      long long v586 = 0u;
      *(void *)&v587[1] = 0x7FFFFFFFLL;
      if (v9)
      {
        if (*(unsigned char *)(v575 + 165)) {
          std::string::value_type isCatmullClarkSurface = re::isCatmullClarkSurface(v8);
        }
        else {
          std::string::value_type isCatmullClarkSurface = 0;
        }
        uint64_t v117 = [MEMORY[0x263F83F10] meshGroupsWithNode:v8];
        v564 = v117;
        if ([v117 count])
        {
          unsigned int v569 = v9;
          long long v583 = 0u;
          long long v584 = 0u;
          long long v581 = 0u;
          long long v582 = 0u;
          id v118 = v117;
          uint64_t v119 = [v118 countByEnumeratingWithState:&v581 objects:v605 count:16];
          if (v119)
          {
            uint64_t v120 = v119;
            uint64_t v121 = *(void *)v582;
            do
            {
              for (uint64_t i = 0; i != v120; ++i)
              {
                if (*(void *)v582 != v121) {
                  objc_enumerationMutation(v118);
                }
                float v123 = [*(id *)(*((void *)&v581 + 1) + 8 * i) inheritedMaterialBinding];
                if (v123)
                {
                  v618[0].__r_.__value_.__r.__words[0] = 0;
                  v618[0].__r_.__value_.__s.__data_[12] = 0;
                  re::ObjCObject::operator=((void **)&v618[0].__r_.__value_.__l.__data_, v123);
                  LODWORD(v618[0].__r_.__value_.__r.__words[1]) = HIDWORD(v586);
                  v618[0].__r_.__value_.__s.__data_[12] = isCatmullClarkSurface;
                  int v124 = [v123 path];
                  id v125 = [v124 stringValue];
                  uint64_t v126 = (_anonymous_namespace_ *)[v125 UTF8String];
                  buf[0] = isCatmullClarkSurface;
                  re::DynamicString::DynamicString((re::DynamicString *)&buf[8], (const re::DynamicString *)__s);
                  re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)&v585, buf, (uint64_t)v618);
                  if (*(void *)&buf[8])
                  {
                    if (buf[16]) {
                      (*(void (**)(void))(**(void **)&buf[8] + 40))();
                    }
                    memset(&buf[8], 0, 32);
                  }
                  if (*(void *)__s)
                  {
                    if (__s[8]) {
                      (*(void (**)(void))(**(void **)__s + 40))();
                    }
                    memset(__s, 0, 32);
                  }
                }
              }
              uint64_t v120 = [v118 countByEnumeratingWithState:&v581 objects:v605 count:16];
            }
            while (v120);
          }

          re::createMaterialAssetsFromMaterialTableUSK((void *)v575, (uint64_t)&v585, (_anonymous_namespace_ *)v606);
          a3 = v562;
          id v8 = v548;
          unint64_t v9 = v569;
        }
        else
        {
          float v127 = [v8 inheritedMaterialBinding];
          if (v127)
          {
            unint64_t v128 = v9;
            v618[0].__r_.__value_.__r.__words[0] = 0;
            v618[0].__r_.__value_.__s.__data_[12] = 0;
            re::ObjCObject::operator=((void **)&v618[0].__r_.__value_.__l.__data_, v127);
            LODWORD(v618[0].__r_.__value_.__r.__words[1]) = HIDWORD(v586);
            v618[0].__r_.__value_.__s.__data_[12] = isCatmullClarkSurface;
            uint64_t v129 = [v127 path];
            id v130 = [v129 stringValue];
            uint64_t v131 = (_anonymous_namespace_ *)[v130 UTF8String];
            buf[0] = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)&buf[8], (const re::DynamicString *)__s);
            re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)&v585, buf, (uint64_t)v618);
            if (*(void *)&buf[8])
            {
              if (buf[16]) {
                (*(void (**)(void))(**(void **)&buf[8] + 40))();
              }
              memset(&buf[8], 0, 32);
            }
            unint64_t v9 = v128;
            if (*(void *)__s)
            {
              if (__s[8]) {
                (*(void (**)(void))(**(void **)__s + 40))();
              }
              memset(__s, 0, 32);
            }

            id v8 = v548;
          }
          re::createMaterialAssetsFromMaterialTableUSK((void *)v575, (uint64_t)&v585, (_anonymous_namespace_ *)v606);
          re::addPhysicsMaterialAsset(v127, (uint64_t)a3, v575, (uint64_t)&v585);
        }
        memset(__s, 0, 32);
        re::importVertexCacheAnimationFromUSKNode(v8, (float *)__s, (unint64_t)buf, *(double *)a3);
        if (buf[0])
        {
          uint64_t v133 = v564;
          if (*(void *)&__s[16]) {
            re::USDImportContext::setVertexCacheAnimation((uint64_t)a3, __s);
          }
        }
        else
        {
          int v134 = (id)*re::pipelineLogObjects(v132);
          if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
          {
            v457 = [v8 path];
            id v458 = [v457 stringValue];
            std::string::size_type v459 = [v458 UTF8String];
            if (buf[32]) {
              v460 = *(unsigned char **)&buf[40];
            }
            else {
              v460 = &buf[33];
            }
            LODWORD(v618[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v618[0].__r_.__value_.__r.__words + 4) = v459;
            WORD2(v618[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v618[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v460;
            _os_log_error_impl(&dword_233120000, v134, OS_LOG_TYPE_ERROR, "Mesh (%s) failed to import vertex cache: %s.", (uint8_t *)v618, 0x16u);
          }
          uint64_t v133 = v564;
        }
        if (!buf[0] && *(void *)&buf[24] && (buf[32] & 1) != 0) {
          (*(void (**)(void))(**(void **)&buf[24] + 40))();
        }
        re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit(&__s[8]);
      }
      uint64_t v579 = 0;
      size_t v580 = 0;
      long long v135 = v546;
      if (v546)
      {
        float v136 = [(_anonymous_namespace_ *)v546 path];
        id v137 = [v136 stringValue];
        int v138 = (char *)[v137 UTF8String];
        if (v138)
        {
          uint64_t v139 = *v138;
          if (*v138)
          {
            char v140 = v138[1];
            if (v140)
            {
              uint64_t v141 = (unsigned __int8 *)(v138 + 2);
              do
              {
                uint64_t v139 = 31 * v139 + v140;
                int v142 = *v141++;
                char v140 = v142;
              }
              while (v142);
            }
          }
        }
        else
        {
          uint64_t v139 = 0;
        }
        *(void *)&__s[8] = v138;
        *(void *)__s = 2 * v139;

        uint64_t v144 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 112, __s);
        if (v144)
        {
          unint64_t v145 = *v144;
          re::USDImportContext::setSkeletonReference(a3, *v144);
          unint64_t v143 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)a3 + 56, v145) + 16;
          uint64_t v579 = *(void *)&__s[8];
          size_t v580 = strlen(*(const char **)&__s[8]);
          char v146 = [v8 inheritedSkeletonAnimationBinding];
          if (!v146)
          {
            char v146 = [(_anonymous_namespace_ *)v546 inheritedSkeletonAnimationBinding];
            if (!v146)
            {
              float v147 = [v8 childIterator];
              char v146 = [v147 nextObject];
              if (v146)
              {
                long long v148 = (void *)*MEMORY[0x263F84008];
                while (1)
                {
                  long long v149 = [v146 type];

                  if (v149 == v148) {
                    break;
                  }
                  uint64_t v150 = [v147 nextObject];

                  char v146 = v150;
                  if (!v150) {
                    goto LABEL_241;
                  }
                }
                char v146 = v146;
              }
LABEL_241:
            }
          }
          if (v9 && v146)
          {
            int v212 = v9;
            v213 = [v146 path];
            id v214 = [v213 stringValue];
            v215 = (_anonymous_namespace_ *)[v214 UTF8String];
            *(void *)buf = 0;
            *(void *)&uint8_t buf[8] = "";
            BOOL v216 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 216, buf);
            v217 = v216;
            if (v216) {
              unint64_t v9 = *v216;
            }
            re::StringID::destroyString((re::StringID *)buf);

            if (v217)
            {
              re::USDImportContext::setSkeletalAnimationReference(a3, v9);
            }
            else
            {
              v219 = (id)*re::pipelineLogObjects(v218);
              if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
              {
                v481 = [v548 path];
                id v482 = [v481 stringValue];
                uint64_t v483 = [v482 UTF8String];
                v484 = [v146 path];
                id v485 = [v484 stringValue];
                uint64_t v486 = [v485 UTF8String];
                *(_DWORD *)buf = 136315394;
                *(void *)&uint8_t buf[4] = v483;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v486;
                _os_log_error_impl(&dword_233120000, v219, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeletal animation: %s.", buf, 0x16u);

                a3 = v562;
              }
            }
            LODWORD(v9) = v212;
          }
        }
        else
        {
          char v146 = (id)*re::pipelineLogObjects(0);
          if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
          {
            v461 = [v8 path];
            id v462 = [v461 stringValue];
            uint64_t v463 = [v462 UTF8String];
            v464 = [(_anonymous_namespace_ *)v546 path];
            [v464 stringValue];
            int v465 = v9;
            unint64_t v9 = (unint64_t) objc_claimAutoreleasedReturnValue();
            uint64_t v466 = [(id)v9 UTF8String];
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v463;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v466;
            _os_log_error_impl(&dword_233120000, v146, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeleton: %s.", buf, 0x16u);

            LODWORD(v9) = v465;
          }
          unint64_t v143 = 0;
        }

        re::StringID::destroyString((re::StringID *)__s);
      }
      else
      {
        unint64_t v143 = 0;
      }
      unsigned int v220 = v587[0];
      if (v587[0])
      {
        uint64_t v221 = 0;
        unint64_t v222 = (int *)(v586 + 8);
        while (1)
        {
          int v223 = *v222;
          v222 += 18;
          if (v223 < 0) {
            break;
          }
          if (v587[0] == ++v221)
          {
            int v224 = v9;
            LODWORD(v221) = v587[0];
            goto LABEL_260;
          }
        }
        int v224 = v9;
      }
      else
      {
        int v224 = v9;
        LODWORD(v221) = 0;
      }
LABEL_260:
      if (v587[0] != v221)
      {
        uint64_t v225 = v221;
        uint64_t v226 = v586;
        while (1)
        {
          v227 = (void *)MEMORY[0x263F83F10];
          id v228 = *(id *)(v226 + 72 * v225 + 56);
          v229 = [v227 firstUVMeshAttributeNameInMaterial:v228];

          if (v229) {
            break;
          }
          uint64_t v226 = v586;
          if (v587[0] <= (int)v221 + 1) {
            unsigned int v230 = v221 + 1;
          }
          else {
            unsigned int v230 = v587[0];
          }
          while (1)
          {
            uint64_t v225 = (v221 + 1);
            if (v230 - 1 == v221) {
              break;
            }
            LODWORD(v221) = v221 + 1;
            unsigned int v231 = v225;
            if ((*(_DWORD *)(v586 + 72 * v225 + 8) & 0x80000000) != 0) {
              goto LABEL_270;
            }
          }
          unsigned int v231 = v230;
LABEL_270:
          LODWORD(v221) = v231;
          if (v220 == v231) {
            goto LABEL_273;
          }
        }
        *(void *)buf = "primvars:";
        *(void *)&uint8_t buf[8] = 9;
        re::DynamicString::operator=((re::DynamicString *)&v577, (uint64_t)buf);
        id v232 = v229;
        v233 = (const char *)[v232 UTF8String];
        size_t v234 = strlen(v233);
        re::DynamicString::append((re::DynamicString *)&v577, v233, v234);
      }
LABEL_273:
      char v235 = obj;
      if (!v224) {
        char v235 = 1;
      }
      id v8 = v548;
      if ((v235 & 1) == 0)
      {
        int v236 = *(unsigned __int8 *)(v575 + 164);
        v237 = [v548 customMetadataWithKey:@"RE:mesh:v1:importAllMeshAttributes"];
        v238 = v237;
        int v239 = v236 != 0;
        if (v237) {
          int v239 = [v237 BOOLValue];
        }
        re::makeGeomModelDescriptorFromUSKNode(v548, (uint64_t)&v577, (uint64_t)&v585, *(unsigned __int8 *)(v575 + 165), *(unsigned __int8 *)(v575 + 166), v239, (uint64_t)&v579, v143, (uint64_t)buf);
        if (buf[0])
        {
          id v552 = v548;
          unsigned int v241 = [v552 property:@"skel:blendShapeTargets"];
          if (v241)
          {
            v529 = v241;
            v532 = v238;
            id obja = [v241 objectPathArray];
            if (obja)
            {
              long long v619 = 0u;
              memset(v618, 0, sizeof(v618));
              uint64_t v242 = [obja countByEnumeratingWithState:v618 objects:__s count:16];
              if (v242)
              {
                uint64_t v243 = v242;
                uint64_t v244 = *(void *)v618[0].__r_.__value_.__r.__words[2];
                do
                {
                  uint64_t v245 = 0;
                  do
                  {
                    if (*(void *)v618[0].__r_.__value_.__r.__words[2] != v244) {
                      objc_enumerationMutation(obja);
                    }
                    id v246 = *(id *)(v618[0].__r_.__value_.__l.__size_ + 8 * v245);
                    v247 = v246;
                    if (v246)
                    {
                      id v248 = [v246 stringValue];
                      int v249 = (char *)[v248 UTF8String];
                      if (v249)
                      {
                        uint64_t v250 = *v249;
                        if (*v249)
                        {
                          char v251 = v249[1];
                          if (v251)
                          {
                            v252 = (unsigned __int8 *)(v249 + 2);
                            do
                            {
                              uint64_t v250 = 31 * v250 + v251;
                              int v253 = *v252++;
                              char v251 = v253;
                            }
                            while (v253);
                          }
                        }
                      }
                      else
                      {
                        uint64_t v250 = 0;
                      }
                      v620[0] = 2 * v250;
                      v620[1] = v249;
                      v254 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)v562 + 320, v620);
                      if (!v254)
                      {
                        re::StringID::destroyString((re::StringID *)v620);

                        goto LABEL_323;
                      }
                      unint64_t v255 = *v254;
                      re::StringID::destroyString((re::StringID *)v620);

                      uint64_t v256 = re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[]((uint64_t)v562 + 264, v255);
                      unint64_t v257 = *(void *)(v256 + 40);
                      unint64_t v258 = *(void *)&buf[24];
                      if (v257 >= *(void *)&buf[24])
                      {
                        id v260 = [MEMORY[0x263EFF990] dataWithLength:12 * v257];
                        memcpy((void *)[v260 mutableBytes], *(const void **)(v256 + 48), 12 * *(void *)(v256 + 40));
                        uint64_t v262 = *(void *)(v256 + 40);
                      }
                      else
                      {
                        id v259 = [MEMORY[0x263EFF990] dataWithLength:12 * v257 + 12];
                        memcpy((void *)[v259 mutableBytes], *(const void **)(v256 + 48), 12 * v257);
                        id v260 = v259;
                        uint64_t v261 = [v260 mutableBytes] + 12 * *(void *)(v256 + 40);
                        *(void *)uint64_t v261 = 0;
                        *(_DWORD *)(v261 + 8) = 0;
                        uint64_t v262 = *(void *)(v256 + 40) + 1;
                      }
                      id v263 = v260;
                      int v264 = v263;
                      id v591 = v263;
                      LOBYTE(v592) = 11;
                      uint64_t v593 = v262;
                      long long v594 = xmmword_23437DC60;
                      uint64_t v265 = *(void *)(v256 + 88);
                      if (v265 == *(void *)&buf[24])
                      {
                        if (v265)
                        {
                          char v266 = [MEMORY[0x263EFF990] dataWithLength:4 * v265];
                          if (v257 < v258 && *(void *)&buf[24])
                          {
                            unint64_t v267 = 0;
                            do
                              *(_DWORD *)([v266 mutableBytes] + 4 * v267++) = v262 - 1;
                            while (v267 < *(void *)&buf[24]);
                          }
                          id v268 = v266;
                          memcpy((void *)[v268 mutableBytes], *(const void **)(v256 + 96), 4 * *(void *)(v256 + 88));
                          id v269 = v268;
                          v589.__r_.__value_.__r.__words[0] = (std::string::size_type)v269;
                          v589.__r_.__value_.__s.__data_[8] = 5;
                          v589.__r_.__value_.__r.__words[2] = *(void *)&buf[24];
                          long long v590 = xmmword_23437DC70;
                          re::DynamicString::format((re::DynamicString *)"%s|blendTargetPosDeltas", (re::DynamicString *)v609, *(void *)(v256 + 24));
                          re::GeomModelDescriptor::setAttribute(&buf[8], (uint64_t)v609, 1, (uint64_t)&v591, (uint64_t)&v589, (uint64_t)v620);
                          uint64_t v270 = *(re **)v609;
                          if (*(void *)v609 && (v609[8] & 1) != 0) {
                            uint64_t v270 = (re *)(*(uint64_t (**)(void))(**(void **)v609 + 40))();
                          }
                          if (!LOBYTE(v620[0]))
                          {
                            v271 = *re::pipelineLogObjects(v270);
                            if (os_log_type_enabled(v271, OS_LOG_TYPE_ERROR))
                            {
                              long long v279 = v271;
                              uint64_t v535 = *(void *)(v256 + 24);
                              if (v603[40]) {
                                long long v280 = *(unsigned char **)&v604[7];
                              }
                              else {
                                long long v280 = v604;
                              }
                              v281 = [v552 name];
                              id v282 = [v281 stringValue];
                              uint64_t v283 = [v282 UTF8String];
                              *(_DWORD *)v609 = 136315650;
                              *(void *)&v609[4] = v535;
                              __int16 v610 = 2080;
                              v611 = v280;
                              __int16 v612 = 2080;
                              uint64_t v613 = v283;
                              _os_log_error_impl(&dword_233120000, v279, OS_LOG_TYPE_ERROR, "Could not store blend shape '%s' in geomModel '%s' for node '%s'\n", v609, 0x20u);
                            }
                            if (!LOBYTE(v620[0]) && v620[3] && (v621 & 1) != 0) {
                              (*(void (**)(void))(*(void *)v620[3] + 40))();
                            }
                          }

LABEL_322:
                          goto LABEL_323;
                        }
                      }
                      else
                      {
                        BOOL v272 = *re::pipelineLogObjects((re *)v263);
                        if (os_log_type_enabled(v272, OS_LOG_TYPE_DEFAULT))
                        {
                          long long v273 = v272;
                          uint64_t v274 = *(void *)(v256 + 24);
                          uint64_t v275 = [v552 name];
                          id v276 = [v275 stringValue];
                          uint64_t v277 = [v276 UTF8String];
                          uint64_t v278 = *(void *)(v256 + 88);
                          LODWORD(v620[0]) = 136315906;
                          *(void *)((char *)v620 + 4) = v274;
                          WORD2(v620[1]) = 2080;
                          *(void *)((char *)&v620[1] + 6) = v277;
                          HIWORD(v620[2]) = 2048;
                          v620[3] = v278;
                          __int16 v621 = 2048;
                          *(void *)v622 = *(void *)&buf[24];
                          _os_log_impl(&dword_233120000, v273, OS_LOG_TYPE_DEFAULT, "Blend shape '%s' in node '%s' has %zu indices but model has %zu vertices. Point indices will be ignored.", (uint8_t *)v620, 0x2Au);
                        }
                      }
                      re::DynamicString::format((re::DynamicString *)"%s|blendTargetPosDeltas", (re::DynamicString *)v620, *(void *)(v256 + 24));
                      re::GeomModelDescriptor::setAttribute(&buf[8], (uint64_t)v620, 1, (uint64_t)&v591, 0, (uint64_t)v588);
                      if (!LOBYTE(v588[0]) && *((void *)&v588[1] + 1))
                      {
                        if (v588[2]) {
                          (*(void (**)(void))(**((void **)&v588[1] + 1) + 40))();
                        }
                        memset((char *)&v588[1] + 8, 0, 32);
                      }
                      if (v620[0] && (v620[1] & 1) != 0) {
                        (*(void (**)(void))(*(void *)v620[0] + 40))();
                      }
                      goto LABEL_322;
                    }
LABEL_323:

                    ++v245;
                  }
                  while (v245 != v243);
                  uint64_t v284 = [obja countByEnumeratingWithState:v618 objects:__s count:16];
                  uint64_t v243 = v284;
                }
                while (v284);
              }
            }

            a3 = v562;
            id v8 = v548;
            unsigned int v241 = v529;
            v238 = v532;
          }

          re::USDImportContext::setModel((uint64_t)a3, (uint64_t)&buf[8]);
          uint64_t v285 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(void *)(*((void *)a3 + 106) + 8 * *((void *)a3 + 104) - 8));
          re::DynamicArray<re::AssetHandle>::operator=(v285 + 808, (uint64_t)v606);
        }
        else
        {
          long long v286 = (id)*re::pipelineLogObjects(v240);
          if (os_log_type_enabled(v286, OS_LOG_TYPE_ERROR))
          {
            std::error_code::message((std::string *)__s, (const std::error_code *)&buf[8]);
            v467 = __s[23] >= 0 ? __s : *(unsigned char **)__s;
            v468 = (buf[32] & 1) != 0 ? *(unsigned char **)&buf[40] : &buf[33];
            LODWORD(v618[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v618[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v467;
            WORD2(v618[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v618[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v468;
            _os_log_error_impl(&dword_233120000, v286, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", (uint8_t *)v618, 0x16u);
            if ((__s[23] & 0x80000000) != 0) {
              operator delete(*(void **)__s);
            }
          }
        }
        re::updateMeshOverrideCompileOptions(a3, v8);
        re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)buf);
      }
      if (v577 && (v578 & 1) != 0) {
        (*(void (**)(void))(*(void *)v577 + 40))();
      }
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)&v585);
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v606);
      uint64_t v86 = v539;
    }

    uint64_t v28 = v541;
    goto LABEL_343;
  }
  if ([v10 isEqualToString:*MEMORY[0x263F84010]])
  {
    int32x4_t v93 = v28;
    float32x4_t v94 = [v8 path];
    id v95 = [v94 stringValue];
    float32x4_t v96 = (_anonymous_namespace_ *)[v95 UTF8String];
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = "";
    uint64_t v97 = (_anonymous_namespace_ **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 112, buf);
    float32x4_t v98 = v97;
    if (v97) {
      float32x4_t v96 = *v97;
    }
    re::StringID::destroyString((re::StringID *)buf);

    if (v98)
    {
      unint64_t v152 = *(void *)(*((void *)a3 + 106) + 8 * *((void *)a3 + 104) - 8);
      unint64_t v153 = *(void *)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, v152)
                       + 872);
      uint64_t v28 = v93;
      if (v153 == -1) {
        unint64_t v153 = v152;
      }
      re::USDImportContext::setSkeletonEntity(a3, v153, (unint64_t)v96);
    }
    else
    {
      v154 = *re::pipelineLogObjects(v151);
      uint64_t v28 = v93;
      if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
      {
        long long v155 = v154;
        id v156 = [v8 path];
        id v157 = [v156 stringValue];
        uint64_t v158 = [v157 UTF8String];
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v158;
        _os_log_error_impl(&dword_233120000, v155, OS_LOG_TYPE_ERROR, "Skeleton entity (%s) does not have a valid skeleton index.", buf, 0xCu);

        uint64_t v28 = v93;
      }
    }
    goto LABEL_343;
  }
  float32x4_t v99 = (void *)*MEMORY[0x263F83FE0];
  if (([v10 isEqualToString:*MEMORY[0x263F83FE0]] & 1) != 0
    || ([v10 isEqualToString:*MEMORY[0x263F83FD8]] & 1) != 0
    || ([v10 isEqualToString:*MEMORY[0x263F84020]] & 1) != 0
    || ([v10 isEqualToString:*MEMORY[0x263F83FD0]] & 1) != 0
    || ([v10 isEqualToString:*MEMORY[0x263F83FE8]] & 1) != 0
    || re::importPhysicsIsSceneGroundPlane(v8))
  {
    if (v9)
    {
      v618[1].__r_.__value_.__l.__size_ = 0;
      memset(v618, 0, 28);
      memset(buf, 0, 36);
      *(void *)&buf[36] = 0x7FFFFFFFLL;
      float32x4_t v100 = [v8 inheritedMaterialBinding];
      if (v100)
      {
        unint64_t v9 = (unint64_t)v28;
        *(void *)&v588[0] = 0;
        BYTE12(v588[0]) = 0;
        re::ObjCObject::operator=((void **)v588, v100);
        DWORD2(v588[0]) = *(_DWORD *)&buf[28];
        BYTE12(v588[0]) = 0;
        id v101 = [v100 path];
        id v102 = [v101 stringValue];
        uint64_t v103 = (_anonymous_namespace_ *)[v102 UTF8String];
        __s[0] = 0;
        re::DynamicString::DynamicString((re::DynamicString *)&__s[8], (const re::DynamicString *)v620);
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, __s, (uint64_t)v588);
        if (*(void *)&__s[8])
        {
          if (__s[16]) {
            (*(void (**)(void))(**(void **)&__s[8] + 40))();
          }
          memset(&__s[8], 0, 32);
        }
        id v8 = v548;
        if (v620[0])
        {
          if (v620[1]) {
            (*(void (**)(void))(*(void *)v620[0] + 40))();
          }
          memset(v620, 0, sizeof(v620));
        }

        uint64_t v28 = (void *)v9;
      }
      re::createMaterialAssetsFromMaterialTableUSK((void *)v575, (uint64_t)buf, (_anonymous_namespace_ *)v618);
      if (obj) {
        goto LABEL_239;
      }
      uint64_t v104 = v28;
      id v105 = v8;
      *(void *)&__s[40] = 0x3F80000000000000;
      *(void *)&__s[32] = 0;
      long long v106 = [v105 type];

      if (v106 == v99)
      {
        uint64_t v159 = [v105 property:@"size"];
        v160 = v159;
        float v161 = 2.0;
        if (v159)
        {
          unint64_t v162 = [v159 data];

          if (v162)
          {
            [v160 floatValue];
            float v161 = v163;
          }
        }
        __s[0] = 0;
        *(void *)&__s[4] = 0x1000100010001;
        *(_DWORD *)&__s[12] = 0;
        *(float *)&__s[16] = v161;
        *(float *)&__s[20] = v161;
        *(float *)&__s[24] = v161;
        *(_WORD *)&__s[28] = 257;
        __s[30] = 0;
        goto LABEL_237;
      }
      uint64_t v107 = [v105 type];
      long long v108 = (void *)*MEMORY[0x263F83FD8];

      if (v107 == v108)
      {
        uint64_t v166 = [v105 property:@"radius"];
        v160 = v166;
        float v167 = 1.0;
        if (v166)
        {
          int v168 = [v166 data];

          if (v168)
          {
            [v160 floatValue];
            float v167 = v169;
          }
        }
        v170 = [v105 property:@"height"];
        unint64_t v171 = v170;
        float v172 = 2.0;
        if (v170)
        {
          unint64_t v173 = [v170 data];

          if (v173)
          {
            v170 = (void *)[v171 floatValue];
            float v172 = v174;
          }
        }
        __s[0] = 1;
        *(_DWORD *)&__s[4] = 65544;
        *(float *)&__s[8] = v172;
        *(float *)&__s[12] = v167;
        *(_DWORD *)&__s[16] = 65793;
        uint64_t v175 = [v105 property:@"axis"];
        uint64_t v176 = v175;
        if (v175)
        {
          v177 = [v175 data];

          if (v177)
          {
            id v178 = [v176 stringValue];
            unint64_t v179 = (const char *)[v178 UTF8String];
            size_t v180 = strlen(v179);
            *(void *)&v588[0] = v179;
            *((void *)&v588[0] + 1) = v180;
            re::DynamicString::operator=((re::DynamicString *)v620, (uint64_t)v588);
          }
        }
      }
      else
      {
        long long v109 = [v105 type];
        int v110 = (void *)*MEMORY[0x263F83FE8];

        if (v109 == v110)
        {
          unint64_t v181 = [v105 property:@"radius"];
          v160 = v181;
          float v182 = 1.0;
          if (v181)
          {
            uint64_t v183 = [v181 data];

            if (v183)
            {
              [v160 floatValue];
              float v182 = v184;
            }
          }
          v185 = [v105 property:@"height"];
          unint64_t v171 = v185;
          float v186 = 2.0;
          if (v185)
          {
            v187 = [v185 data];

            if (v187)
            {
              v185 = (void *)[v171 floatValue];
              float v186 = v188;
            }
          }
          v189 = [v105 property:@"axis"];
          uint64_t v176 = v189;
          if (v189)
          {
            unint64_t v190 = [v189 data];

            if (v190)
            {
              id v191 = [v176 stringValue];
              unint64_t v192 = (const char *)[v191 UTF8String];
              size_t v193 = strlen(v192);
              *(void *)&v588[0] = v192;
              *((void *)&v588[0] + 1) = v193;
              re::DynamicString::operator=((re::DynamicString *)v620, (uint64_t)v588);
            }
          }
          __s[0] = 2;
          *(_DWORD *)&__s[4] = 65544;
          *(float *)&__s[8] = v186;
          *(float *)&__s[12] = v182;
          *(float *)&__s[16] = v182;
          *(_DWORD *)&__s[20] = 16843009;
          __s[24] = 0;
        }
        else
        {
          int v111 = [v105 type];
          uint64_t v112 = (void *)*MEMORY[0x263F83FD0];

          if (v111 != v112)
          {
            uint64_t v113 = [v105 type];
            long long v114 = (void *)*MEMORY[0x263F84020];

            if (v113 != v114)
            {

              size_t v116 = (id)*re::pipelineLogObjects(v115);
              if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
              {
                v496 = [v105 name];
                v497 = [v496 stringValue];
                if (v497)
                {
                  id v105 = [v105 name];
                  unint64_t v9 = [v105 stringValue];
                  v498 = (const char *)[(id)v9 UTF8String];
                }
                else
                {
                  v498 = "unnamed";
                }
                LODWORD(v620[0]) = 136315138;
                *(void *)((char *)v620 + 4) = v498;
                _os_log_error_impl(&dword_233120000, v116, OS_LOG_TYPE_ERROR, "Unsupported primitive for node '%s'", (uint8_t *)v620, 0xCu);
                if (v497)
                {
                }
                id v8 = v548;
              }

              goto LABEL_238;
            }
            v469 = [v105 property:@"radius"];
            v160 = v469;
            float v470 = 1.0;
            if (v469)
            {
              v471 = [v469 data];

              if (v471)
              {
                [v160 floatValue];
                float v470 = v472;
              }
            }
            __s[0] = 3;
            *(_WORD *)&__s[4] = 8;
            *(float *)&__s[8] = v470;
            *(_WORD *)&__s[12] = 257;
            __s[14] = 0;
LABEL_237:

            re::USDImportContext::setPrimitiveShape((uint64_t)a3, __s);
            uint64_t v211 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(void *)(*((void *)a3 + 106) + 8 * *((void *)a3 + 104) - 8));
            re::DynamicArray<re::AssetHandle>::operator=(v211 + 808, (uint64_t)v618);
            re::addPhysicsMaterialAsset(v100, (uint64_t)a3, v575, (uint64_t)buf);
LABEL_238:
            uint64_t v28 = v104;
LABEL_239:

            re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
            re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v618);
            goto LABEL_343;
          }
          uint64_t v194 = [v105 property:@"radius"];
          v160 = v194;
          float v195 = 0.5;
          if (v194)
          {
            unint64_t v196 = [v194 data];

            if (v196)
            {
              [v160 floatValue];
              float v195 = v197;
            }
          }
          unint64_t v198 = [v105 property:@"height"];
          unint64_t v171 = v198;
          double v199 = 1.0;
          if (v198)
          {
            uint64_t v200 = [v198 data];

            if (v200)
            {
              unint64_t v198 = (void *)[v171 floatValue];
              double v199 = v201;
            }
          }
          float v202 = v199 + v195 * 2.0;
          uint64_t v203 = [v105 property:@"axis"];
          uint64_t v176 = v203;
          if (v203)
          {
            int v204 = [v203 data];

            if (v204)
            {
              id v205 = [v176 stringValue];
              unsigned int v206 = (const char *)[v205 UTF8String];
              size_t v207 = strlen(v206);
              *(void *)&v588[0] = v206;
              *((void *)&v588[0] + 1) = v207;
              re::DynamicString::operator=((re::DynamicString *)v620, (uint64_t)v588);
            }
          }
          __s[0] = 4;
          *(_DWORD *)&__s[4] = 65544;
          *(_WORD *)&__s[8] = 4;
          *(float *)&__s[12] = v195;
          *(float *)&__s[16] = v202;
          *(_WORD *)&__s[20] = 257;
          __s[22] = 0;
        }
      }
      if (v620[1]) {
        uint64_t v208 = (const char *)v620[2];
      }
      else {
        uint64_t v208 = (char *)&v620[1] + 1;
      }
      if (!strcmp(v208, "X"))
      {
        uint64_t v210 = 0;
        uint64_t v209 = 0x3F3504F33F3504F3;
        a3 = v562;
      }
      else
      {
        a3 = v562;
        if (strcmp(v208, "Z")) {
          goto LABEL_233;
        }
        uint64_t v209 = 0x3F3504F300000000;
        uint64_t v210 = 1060439283;
      }
      *(void *)&__s[32] = v210;
      *(void *)&__s[40] = v209;
LABEL_233:

      if (v620[0] && (v620[1] & 1) != 0) {
        (*(void (**)(void))(*(void *)v620[0] + 40))();
      }

      id v8 = v548;
      goto LABEL_237;
    }
  }
  else
  {
    v543 = v28;
    v473 = (re *)[v10 isEqualToString:*MEMORY[0x263F84018]];
    if (v473)
    {
      v474 = re::globalAllocators(v473);
      uint64_t v475 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v474[2] + 32))(v474[2], 72, 8);
      *(_OWORD *)uint64_t v475 = 0u;
      *(_OWORD *)(v475 + 16) = 0u;
      *(_OWORD *)(v475 + 32) = 0u;
      *(void *)(v475 + 20) = 0x13F800000;
      *(void *)(v475 + 56) = 0;
      *(void *)(v475 + 64) = 0;
      *(void *)(v475 + 48) = 0;
      *(void *)buf = v475;
      operator new();
    }
    v476 = [v8 typeName];
    v477 = [v476 stringValue];
    int v478 = [v477 isEqualToString:@"Preliminary_Text"];

    if (v478)
    {
      v479 = [v8 property:@"content"];
      objb = v479;
      if (v479)
      {
        v554 = [v8 property:@"content"];
        id v551 = [v554 stringValue];
        v479 = (_anonymous_namespace_ *)[v551 UTF8String];
        v480 = (const char *)v479;
      }
      else
      {
        v480 = "";
      }
      v499 = [v8 property:@"font"];
      v570 = v499;
      if (v499)
      {
        v549 = [v8 property:@"font"];
        v544 = [v549 stringArray];
        id v538 = [v544 objectAtIndex:0];
        v499 = (_anonymous_namespace_ *)[v538 UTF8String];
        v500 = (const char *)v499;
      }
      else
      {
        v500 = "Helvetica";
      }
      v501 = [v8 property:@"pointSize"];
      if (v501)
      {
        v534 = [v8 property:@"pointSize"];
        [v534 doubleValue];
        double v503 = v502 * 0.00035277723;
      }
      else
      {
        double v503 = 0.0507999211;
      }
      *((double *)&v596 + 1) = v503;
      v566 = [v8 property:@"width"];
      if (v566)
      {
        v531 = [v8 property:@"width"];
        [v531 doubleValue];
      }
      else
      {
        uint64_t v504 = 0x3FE3333333333333;
      }
      uint64_t v597 = v504;
      uint64_t v505 = [v8 property:@"height"];
      if (v505)
      {
        v528 = [v8 property:@"height"];
        [v528 doubleValue];
      }
      else
      {
        uint64_t v506 = 0x3FC3333333333333;
      }
      *(void *)&long long v598 = v506;
      v507 = [v8 property:@"depth"];
      v561 = (void *)v505;
      if (v507)
      {
        v526 = [v8 property:@"depth"];
        [(std::error_code *)v526 doubleValue];
      }
      else
      {
        uint64_t v508 = 0x3FC999999999999ALL;
      }
      *((void *)&v598 + 1) = v508;
      v509 = &v599;
      v510 = [v8 property:@"wrapMode"];
      v511 = v510;
      if (v510)
      {
        v525 = [v8 property:@"wrapMode"];
        id v524 = [v525 stringValue];
        v510 = (_anonymous_namespace_ *)[v524 UTF8String];
        v512 = (const char *)v510;
      }
      else
      {
        v512 = "flowing";
      }
      v513 = [v8 property:@"horizontalAlignment"];
      v514 = v513;
      if (v513)
      {
        v522 = [v8 property:@"horizontalAlignment"];
        v509 = [v522 stringValue];
        v513 = (_anonymous_namespace_ *)[v509 UTF8String];
        v515 = (const char *)v513;
      }
      else
      {
        v515 = "center";
      }
      v516 = [v8 property:@"verticalAlignment"];
      v517 = v516;
      if (v516)
      {
        unint64_t v4 = [v8 property:@"verticalAlignment"];
        a3 = [v4 stringValue];
        v516 = (_anonymous_namespace_ *)[(re::USDImportContext *)a3 UTF8String];
        v518 = (const char *)v516;
      }
      else
      {
        v518 = "center";
      }
      re::USDImportContext::setText3D(v562, (const re::USDImportContext::GeomText3D *)buf);
      re::USDImportContext::GeomText3D::~GeomText3D((re::USDImportContext::GeomText3D *)buf);
      if (v517)
      {
      }
      id v8 = v548;
      if (v514)
      {
      }
      a3 = v562;
      uint64_t v28 = v543;
      if (v511)
      {
      }
      if (v507) {

      }
      if (v561) {
      if (v566)
      }

      if (v501) {
      if (v570)
      }
      {
      }
      if (objb)
      {
      }
      v490 = [v548 inheritedMaterialBinding];
      if (v490)
      {
        *(void *)&v588[0] = 0;
        BYTE12(v588[0]) = 0;
        re::ObjCObject::operator=((void **)v588, v490);
        *(void *)&__s[32] = 0;
        memset(__s, 0, 28);
        memset(buf, 0, 36);
        *(void *)&buf[36] = 0x7FFFFFFFLL;
        v519 = [v490 path];
        id v520 = [v519 stringValue];
        v521 = (_anonymous_namespace_ *)[v520 UTF8String];
        v618[0].__r_.__value_.__s.__data_[0] = 0;
        re::DynamicString::DynamicString((re::DynamicString *)&v618[0].__r_.__value_.__r.__words[1], (const re::DynamicString *)v620);
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, (char *)v618, (uint64_t)v588);
        if (v618[0].__r_.__value_.__l.__size_)
        {
          if (v618[0].__r_.__value_.__s.__data_[16]) {
            (*(void (**)(void))(*(void *)v618[0].__r_.__value_.__l.__size_ + 40))();
          }
          memset(&v618[0].__r_.__value_.__r.__words[1], 0, 32);
        }
        if (v620[0])
        {
          if (v620[1]) {
            (*(void (**)(void))(*(void *)v620[0] + 40))();
          }
          memset(v620, 0, sizeof(v620));
        }

        re::createMaterialAssetsFromMaterialTableUSK((void *)v575, (uint64_t)buf, (_anonymous_namespace_ *)__s);
        re::USDImportContext::setMeshMaterials((uint64_t)v562, (uint64_t)__s);
        re::addPhysicsMaterialAsset(v490, (uint64_t)v562, v575, (uint64_t)buf);
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
        re::DynamicArray<re::AssetHandle>::deinit((uint64_t)__s);

        uint64_t v28 = v543;
      }
    }
    else
    {
      int v489 = [MEMORY[0x263F83F10] isTransformNode:v8];
      uint64_t v28 = v543;
      if (!v9 || !v489) {
        goto LABEL_343;
      }
      v490 = [v8 inheritedMaterialBinding];
      memset(buf, 0, 36);
      *(void *)&buf[36] = 0x7FFFFFFFLL;
      if (v490)
      {
        v620[0] = 0;
        BYTE4(v620[1]) = 0;
        re::ObjCObject::operator=((void **)v620, v490);
        LODWORD(v620[1]) = *(_DWORD *)&buf[28];
        BYTE4(v620[1]) = 0;
        v491 = [v490 path];
        id v492 = [v491 stringValue];
        v493 = (_anonymous_namespace_ *)[v492 UTF8String];
        __s[0] = 0;
        re::DynamicString::DynamicString((re::DynamicString *)&__s[8], (const re::DynamicString *)v618);
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, __s, (uint64_t)v620);
        if (*(void *)&__s[8])
        {
          if (__s[16]) {
            (*(void (**)(void))(**(void **)&__s[8] + 40))();
          }
          memset(&__s[8], 0, 32);
        }
        if (v618[0].__r_.__value_.__r.__words[0])
        {
          if (v618[0].__r_.__value_.__s.__data_[8]) {
            (*(void (**)(void))(*(void *)v618[0].__r_.__value_.__l.__data_ + 40))();
          }
          memset(v618, 0, 32);
        }

        re::addPhysicsMaterialAsset(v490, (uint64_t)a3, v575, (uint64_t)buf);
        uint64_t v28 = v543;
      }
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
    }
  }
LABEL_343:

LABEL_344:
  long long v287 = re::variantNamesInLodVariantSet(v8);
  uint64_t v288 = [v287 count];

  if (v288)
  {
    id v289 = v537;
    id v290 = v8;
    long long v291 = re::variantNamesInLodVariantSet(v290);
    if ([v291 count])
    {
      int v292 = [v291 objectAtIndexedSubscript:0];
      unsigned int v293 = [v292 isEqualToString:@"card"];

      v542 = v291;
      long long v294 = [v291 objectAtIndexedSubscript:v293];
      int v295 = [v294 isEqualToString:@"default"];

      uint64_t v296 = *((void *)a3 + 5);
      int v297 = *(unsigned __int8 *)(v296 + 165);
      v540 = (void *)v296;
      int v298 = *(unsigned __int8 *)(v296 + 96);
      uint64_t v592 = 0;
      id v591 = 0;
      uint64_t v593 = 0;
      int v299 = [v290 dictionaryMetadataWithKey:@"assetInfo" dictionaryKey:@"lodComplexityThresholds"];
      uint64_t v300 = v299;
      if (v299)
      {
        v301 = (_anonymous_namespace_ *)[v299 arraySize];
        unint64_t v302 = v301;
        if (v301)
        {
          [v300 floatArray:v593 maxCount:v302];
        }
      }

      id v545 = objc_alloc_init(MEMORY[0x263EFF980]);
      int v303 = [v290 childIterator];
      uint64_t v304 = [v303 nextObject];
      if (v304)
      {
        v305 = (void *)v304;
        int v565 = v297;
        unsigned int v306 = 0;
        uint64_t v307 = *MEMORY[0x263F83FF8];
        do
        {
          v308 = [v305 type];
          int v309 = [v308 isEqualToString:v307];
          if (v298 && (v309 & v295) != 0)
          {
            v310 = [v305 path];
            [v545 addObject:v310];

            ++v306;
          }
          else
          {
            re::loadTransformAndMeshNodes(v289, v305, v562, 0);
          }

          uint64_t v311 = [v303 nextObject];

          v305 = (void *)v311;
        }
        while (v311);

        id v8 = v548;
        long long v291 = v542;
        if (v306)
        {
          uint64_t v312 = 0;
          uint64_t v530 = v306;
          id v533 = v290;
          id v536 = v289;
          do
          {
            v313 = [v545 objectAtIndexedSubscript:v312];
            long long v314 = [v289 nodeAtPath:v313];
            long long v315 = [v314 property:@"purpose"];
            char v316 = v315;
            uint64_t v547 = v312;
            if (v315)
            {
              char v317 = [v315 stringValue];
              char v318 = [v317 isEqualToString:@"guide"];
            }
            else
            {
              char v318 = 0;
            }
            char v319 = v562;

            id v320 = v289;
            id v321 = v290;
            id v322 = v313;
            id v323 = v291;
            uint64_t v324 = [v320 nodeAtPath:v322];
            char v325 = [v324 inheritedSkeletonBinding];

            v576 = v322;
            if (v325)
            {
              unsigned int v326 = [v323 count];
              if (v326)
              {
                LOBYTE(v32re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
                for (unsigned int j = 0; j != v326; LOBYTE(v327) = j >= v326)
                {
                  unsigned int v329 = [v323 objectAtIndexedSubscript:0];
                  [v321 selectVariant:v329 variantSet:@"lodVariant"];

                  uint64_t v330 = [v320 nodeAtPath:v576];
                  v331 = [v330 inheritedSkeletonBinding];

                  if (!v331) {
                    break;
                  }
                  ++j;
                }
                goto LABEL_379;
              }
            }
            else
            {
              uint64_t v332 = (void *)MEMORY[0x263F83F10];
              unsigned int v333 = [v320 nodeAtPath:v322];
              [v332 localTransformWithNode:v333 time:0.0];
              float32x4_t v555 = v335;
              float32x4_t v557 = v334;
              float32x4_t v550 = v337;
              float32x4_t v553 = v336;

              int v338 = [v323 count];
              if (v338)
              {
                int v339 = v338 - 1;
                while (1)
                {
                  __int16 v340 = [v323 objectAtIndexedSubscript:0];
                  [v321 selectVariant:v340 variantSet:@"lodVariant"];

                  v341 = [v320 nodeAtPath:v576];
                  int v342 = [MEMORY[0x263F83F10] transformKeyTimesWithNode:v341];
                  if ((unint64_t)[v342 arraySize] >= 2)
                  {

                    LOBYTE(v32re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
                    goto LABEL_379;
                  }
                  [MEMORY[0x263F83F10] localTransformWithNode:v341 time:0.0];
                  unsigned int v347 = vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v557, v343), (int8x16_t)vceqq_f32(v555, v344)), vandq_s8((int8x16_t)vceqq_f32(v553, v345), (int8x16_t)vceqq_f32(v550, v346))));
                  unsigned int v327 = v347 >> 31;

                  BOOL v348 = v339-- != 0;
                  BOOL v349 = v348;
                  if ((v347 & 0x80000000) == 0) {
                    break;
                  }
                  char v319 = v562;
                  if (!v349) {
                    goto LABEL_379;
                  }
                }
                char v319 = v562;
                goto LABEL_379;
              }
            }
            LOBYTE(v32re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 1;
LABEL_379:
            [v321 selectVariant:@"default" variantSet:@"lodVariant"];

            if (v318 & 1 | ((v327 & 1) == 0))
            {
              uint64_t v351 = (id)*re::pipelineLogObjects(v350);
              id v8 = v548;
              id v290 = v533;
              if (os_log_type_enabled(v351, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__s = 0;
                _os_log_impl(&dword_233120000, v351, OS_LOG_TYPE_DEFAULT, "Lods specified, but leaf level mesh nodes have inconsistent transforms and/or possess animations.  Lods will be ignored.", __s, 2u);
              }
              long long v291 = v542;

              v352 = v576;
              v353 = [v320 nodeAtPath:v576];
              re::loadTransformAndMeshNodes(v320, v353, v319, v542 != 0);

              id v289 = v536;
              uint64_t v354 = v547;
            }
            else
            {
              v355 = [v320 nodeAtPath:v576];
              v356 = [v355 name];
              id v357 = [v356 stringValue];
              v358 = (const char *)[v357 UTF8String];
              id v359 = [v576 stringValue];
              re::USDImportContext::pushNodePath(v319, v358, "(default)", (const char *)[v359 UTF8String]);

              v360 = [v355 inheritedSkeletonBinding];

              if (!v360)
              {
                [MEMORY[0x263F83F10] localTransformWithNode:v355 time:0.0];
                long long v558 = v364;
                float32x4_t v365 = vmulq_f32(v361, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v363, (int8x16_t)v363, 0xCuLL), (int8x16_t)v363, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v362, (int32x4_t)v362), (int8x16_t)v362, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v363, (int32x4_t)v363), (int8x16_t)v363, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v362, (int8x16_t)v362, 0xCuLL), (int8x16_t)v362, 8uLL)));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v365, 2), vaddq_f32(v365, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v365.f32, 1))).f32[0] <= 0.0)float v366 = -1.0; {
                else
                }
                  float v366 = 1.0;
                float32x4_t v367 = vmulq_f32(v361, v361);
                float32x4_t v368 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v367, 2), vaddq_f32(v367, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v367.f32, 1)));
                v368.f32[0] = sqrtf(v368.f32[0]);
                float32x4_t v369 = vmulq_f32(v362, v362);
                float32x4_t v370 = vmulq_f32(v363, v363);
                v368.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v369, 2), vaddq_f32(v369, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v369.f32, 1))).f32[0]);
                v368.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v370, 2), vaddq_f32(v370, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v370.f32, 1))).f32[0]);
                long long v556 = (__int128)vmulq_n_f32(v368, v366);
                float32x4_t v371 = vdivq_f32(v361, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v556, 0));
                float32x4_t v372 = vdivq_f32(v362, (float32x4_t)vdupq_lane_s32((int32x2_t)(v556 >> 32), 0));
                float32x4_t v373 = vdivq_f32(v363, (float32x4_t)vdupq_laneq_s32((int32x4_t)v556, 2));
                int32x4_t v374 = (int32x4_t)vmulq_f32(v371, v371);
                v374.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v374, 2), vadd_f32(*(float32x2_t *)v374.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v374.i8, 1))).u32[0];
                *(float32x2_t *)v368.f32 = vrsqrte_f32((float32x2_t)v374.u32[0]);
                *(float32x2_t *)v368.f32 = vmul_f32(*(float32x2_t *)v368.f32, vrsqrts_f32((float32x2_t)v374.u32[0], vmul_f32(*(float32x2_t *)v368.f32, *(float32x2_t *)v368.f32)));
                v625.columns[0] = (simd_float3)vmulq_n_f32(v371, vmul_f32(*(float32x2_t *)v368.f32, vrsqrts_f32((float32x2_t)v374.u32[0], vmul_f32(*(float32x2_t *)v368.f32, *(float32x2_t *)v368.f32))).f32[0]);
                float32x4_t v375 = vmulq_f32((float32x4_t)v625.columns[0], v372);
                float32x4_t v376 = vmulq_f32((float32x4_t)v625.columns[0], (float32x4_t)v625.columns[0]);
                float32x4_t v377 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v376, 2), vaddq_f32(v376, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v376.f32, 1)));
                float32x4_t v378 = vsubq_f32(v372, vmulq_n_f32((float32x4_t)v625.columns[0], vdivq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v375, 2), vaddq_f32(v375, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v375.f32, 1))), v377).f32[0]));
                int32x4_t v379 = (int32x4_t)vmulq_f32(v378, v378);
                v379.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v379, 2), vadd_f32(*(float32x2_t *)v379.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v379.i8, 1))).u32[0];
                *(float32x2_t *)v369.f32 = vrsqrte_f32((float32x2_t)v379.u32[0]);
                *(float32x2_t *)v369.f32 = vmul_f32(*(float32x2_t *)v369.f32, vrsqrts_f32((float32x2_t)v379.u32[0], vmul_f32(*(float32x2_t *)v369.f32, *(float32x2_t *)v369.f32)));
                v379.i32[0] = vmul_f32(*(float32x2_t *)v369.f32, vrsqrts_f32((float32x2_t)v379.u32[0], vmul_f32(*(float32x2_t *)v369.f32, *(float32x2_t *)v369.f32))).u32[0];
                float32x4_t v380 = vmulq_f32((float32x4_t)v625.columns[0], v373);
                v625.columns[1] = (simd_float3)vmulq_n_f32(v378, *(float *)v379.i32);
                float32x4_t v381 = vsubq_f32(v373, vmulq_n_f32((float32x4_t)v625.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v380, 2), vaddq_f32(v380, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v380.f32, 1))).f32[0]/ v377.f32[0]));
                float32x4_t v382 = vmulq_f32(v373, (float32x4_t)v625.columns[1]);
                float32x4_t v383 = vmulq_f32((float32x4_t)v625.columns[1], (float32x4_t)v625.columns[1]);
                float32x4_t v384 = vsubq_f32(v381, vmulq_n_f32((float32x4_t)v625.columns[1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v382, 2), vaddq_f32(v382, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v382.f32, 1))).f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v383, 2), vaddq_f32(v383, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v383.f32, 1))).f32[0]));
                int32x4_t v385 = (int32x4_t)vmulq_f32(v384, v384);
                v385.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v385, 2), vadd_f32(*(float32x2_t *)v385.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v385.i8, 1))).u32[0];
                *(float32x2_t *)v383.f32 = vrsqrte_f32((float32x2_t)v385.u32[0]);
                *(float32x2_t *)v383.f32 = vmul_f32(*(float32x2_t *)v383.f32, vrsqrts_f32((float32x2_t)v385.u32[0], vmul_f32(*(float32x2_t *)v383.f32, *(float32x2_t *)v383.f32)));
                v625.columns[2] = (simd_float3)vmulq_n_f32(v384, vmul_f32(*(float32x2_t *)v383.f32, vrsqrts_f32((float32x2_t)v385.u32[0], vmul_f32(*(float32x2_t *)v383.f32, *(float32x2_t *)v383.f32))).f32[0]);
                *(double *)v386.i64 = simd_quaternion(v625);
                uint64_t v387 = v386.i64[1];
                float32x4_t v388 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v386.f32, 1);
                unsigned __int8 v389 = vmovn_s32((int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v386, v388), (int8x16_t)vcgeq_f32(v388, v386)))).u8[0];
                uint64_t v390 = v386.i64[0];
                *(int32x2_t *)v386.f32 = vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v386, (int8x16_t)v386, 8uLL));
                *(int8x8_t *)v386.f32 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v386.f32), (int8x8_t)vcgez_f32(*(float32x2_t *)v386.f32)));
                char v391 = v389 | v386.i8[4] | v386.i8[0];
                BOOL v392 = (v391 & 1) == 0;
                if (v391) {
                  uint64_t v393 = 0;
                }
                else {
                  uint64_t v393 = v390;
                }
                *(_OWORD *)__s = v556;
                if (!v392) {
                  uint64_t v387 = 0x3F80000000000000;
                }
                *(void *)&__s[24] = v387;
                *(void *)&__s[16] = v393;
                *(_OWORD *)&__s[32] = v558;
                re::USDImportContext::concatenateLocalTransform((uint64_t)v319, (float32x4_t *)__s);
              }
              int v394 = v565;

              id v395 = v320;
              id v396 = v321;
              id v397 = v576;
              id v398 = v323;
              memset(v588, 0, 36);
              *(void *)((char *)&v588[2] + 4) = 0x7FFFFFFFLL;
              v399 = [v398 objectAtIndexedSubscript:0];
              int v400 = [v399 isEqualToString:@"card"];

              unsigned int v401 = [v398 count];
              [v396 selectVariant:@"default" variantSet:@"lodVariant"];
              v402 = [v395 nodeAtPath:v397];
              re::appendUsedMaterialsByMeshNodeToTableForHelper(v402, v565 != 0, (uint64_t)v588);

              char v559 = v400;
              if (v400) {
                uint64_t v403 = 2;
              }
              else {
                uint64_t v403 = 1;
              }
              if (v403 < v401)
              {
                do
                {
                  v404 = [v398 objectAtIndexedSubscript:v403];
                  [v396 selectVariant:v404 variantSet:@"lodVariant"];

                  v405 = [v395 nodeAtPath:v397];
                  BOOL v406 = v394 != 0;
                  int v394 = v565;
                  re::appendUsedMaterialsByMeshNodeToTableForHelper(v405, v406, (uint64_t)v588);

                  ++v403;
                }
                while (v401 != v403);
              }
              if (v559)
              {
                [v396 selectVariant:@"card" variantSet:@"lodVariant"];
                v407 = [v395 nodeAtPath:v397];
                re::appendUsedMaterialsByMeshNodeToTableForHelper(v407, v394 != 0, (uint64_t)v588);
              }
              [v396 selectVariant:@"default" variantSet:@"lodVariant"];

              *(void *)v587 = 0;
              *(void *)&long long v586 = 0;
              long long v585 = 0uLL;
              DWORD2(v586) = 0;
              re::createMaterialAssetsFromMaterialTableUSK(v540, (uint64_t)v588, (_anonymous_namespace_ *)&v585);
              v408 = [v395 nodeAtPath:v397];
              v409 = [MEMORY[0x263F83F10] meshGroupsWithNode:v408];
              if ([v409 count])
              {
                long long v619 = 0u;
                memset(v618, 0, sizeof(v618));
                id v410 = v409;
                uint64_t v411 = [v410 countByEnumeratingWithState:v618 objects:buf count:16];
                if (v411)
                {
                  uint64_t v412 = v411;
                  v560 = v408;
                  uint64_t v413 = *(void *)v618[0].__r_.__value_.__r.__words[2];
                  while (2)
                  {
                    for (uint64_t k = 0; k != v412; ++k)
                    {
                      if (*(void *)v618[0].__r_.__value_.__r.__words[2] != v413) {
                        objc_enumerationMutation(v410);
                      }
                      uint64_t v415 = [*(id *)(v618[0].__r_.__value_.__l.__size_ + 8 * k) inheritedMaterialBinding];
                      if (v415)
                      {
                        v416 = (void *)v415;
                        goto LABEL_411;
                      }
                    }
                    uint64_t v412 = [v410 countByEnumeratingWithState:v618 objects:buf count:16];
                    if (v412) {
                      continue;
                    }
                    break;
                  }
                  v416 = 0;
LABEL_411:
                  char v319 = v562;
                  v408 = v560;
                }
                else
                {
                  v416 = 0;
                }
              }
              else
              {
                v416 = [v408 inheritedMaterialBinding];
              }
              re::addPhysicsMaterialAsset(v416, (uint64_t)v319, (uint64_t)v540, (uint64_t)v588);

              id v417 = v395;
              id v418 = v396;
              id v419 = v397;
              id v420 = v398;
              v421 = [v420 objectAtIndexedSubscript:0];
              int v422 = [v421 isEqualToString:@"card"];

              unsigned int v423 = [v420 count];
              memset(__s, 0, 28);
              uint64_t v617 = 0;
              *(_OWORD *)&__s[32] = 0u;
              long long v615 = 0u;
              int v616 = 0;
              if (v423)
              {
                re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(__s, v423);
                unint64_t v424 = v615;
              }
              else
              {
                unint64_t v424 = 0;
              }
              if (v424 < v423) {
                re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(&__s[40], v423);
              }
              [v418 selectVariant:@"default" variantSet:@"lodVariant"];
              v425 = [v417 nodeAtPath:v419];
              re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v620, v425, (uint64_t)v319);
              if (LOBYTE(v620[1])) {
                BOOL v426 = LOBYTE(v620[0]) == 0;
              }
              else {
                BOOL v426 = 1;
              }
              if (v426) {
                v427 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
              }
              else {
                v427 = &v620[2];
              }
              re::DynamicArray<unsigned long>::add(__s, v427);
              if (LOBYTE(v620[3])) {
                BOOL v428 = LOBYTE(v620[0]) == 0;
              }
              else {
                BOOL v428 = 1;
              }
              if (v428) {
                v429 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
              }
              else {
                v429 = &v621;
              }
              re::DynamicArray<unsigned long>::add(&__s[40], v429);
              if (!LOBYTE(v620[0]) && v620[3] && (v621 & 1) != 0) {
                (*(void (**)(void))(*(void *)v620[3] + 40))();
              }

              if (v422) {
                uint64_t v430 = 2;
              }
              else {
                uint64_t v430 = 1;
              }
              if (v430 < v423)
              {
                do
                {
                  v431 = [v420 objectAtIndexedSubscript:v430];
                  [v418 selectVariant:v431 variantSet:@"lodVariant"];

                  v432 = [v417 nodeAtPath:v419];
                  re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v620, v432, (uint64_t)v319);
                  if (LOBYTE(v620[1])) {
                    BOOL v433 = LOBYTE(v620[0]) == 0;
                  }
                  else {
                    BOOL v433 = 1;
                  }
                  if (v433) {
                    v434 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
                  }
                  else {
                    v434 = &v620[2];
                  }
                  re::DynamicArray<unsigned long>::add(__s, v434);
                  if (LOBYTE(v620[3])) {
                    BOOL v435 = LOBYTE(v620[0]) == 0;
                  }
                  else {
                    BOOL v435 = 1;
                  }
                  if (v435) {
                    v436 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
                  }
                  else {
                    v436 = &v621;
                  }
                  re::DynamicArray<unsigned long>::add(&__s[40], v436);
                  if (!LOBYTE(v620[0]) && v620[3] && (v621 & 1) != 0) {
                    (*(void (**)(void))(*(void *)v620[3] + 40))();
                  }

                  ++v430;
                }
                while (v423 != v430);
              }
              id v8 = v548;
              id v290 = v533;
              if (v422)
              {
                [v418 selectVariant:@"card" variantSet:@"lodVariant"];
                v437 = [v417 nodeAtPath:v419];
                re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v620, v437, (uint64_t)v319);
                if (LOBYTE(v620[1])) {
                  BOOL v438 = LOBYTE(v620[0]) == 0;
                }
                else {
                  BOOL v438 = 1;
                }
                if (v438) {
                  v439 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
                }
                else {
                  v439 = &v620[2];
                }
                re::DynamicArray<unsigned long>::add(__s, v439);
                if (LOBYTE(v620[3])) {
                  BOOL v440 = LOBYTE(v620[0]) == 0;
                }
                else {
                  BOOL v440 = 1;
                }
                if (v440) {
                  v441 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
                }
                else {
                  v441 = &v621;
                }
                re::DynamicArray<unsigned long>::add(&__s[40], v441);
                if (!LOBYTE(v620[0]) && v620[3] && (v621 & 1) != 0) {
                  (*(void (**)(void))(*(void *)v620[3] + 40))();
                }
              }
              [v418 selectVariant:@"default" variantSet:@"lodVariant"];

              re::loadAllLodModelsForModelPathHelper((uint64_t)v620, v417, v418, v419, (uint64_t)v319, (uint64_t)v588, v420, (uint64_t)__s);
              if (LOBYTE(v620[0]))
              {
                re::FixedArray<float>::FixedArray((uint64_t *)&v589, (uint64_t)&v591);
                re::USDImportContext::setModelsWithLods((uint64_t)v319, (uint64_t)&v620[1], (uint64_t)__s, (uint64_t)&__s[40], (uint64_t *)&v589);
                uint64_t v443 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v562 + 624, *(void *)(*((void *)v319 + 106) + 8 * *((void *)v319 + 104) - 8));
                re::DynamicArray<re::AssetHandle>::operator=(v443 + 808, (uint64_t)&v585);
                id v289 = v536;
                long long v291 = v542;
                if (v589.__r_.__value_.__r.__words[0] && v589.__r_.__value_.__l.__size_) {
                  (*(void (**)(void))(*(void *)v589.__r_.__value_.__l.__data_ + 40))();
                }
              }
              else
              {
                v444 = (id)*re::pipelineLogObjects(v442);
                id v289 = v536;
                long long v291 = v542;
                if (os_log_type_enabled(v444, OS_LOG_TYPE_ERROR))
                {
                  std::error_code::message(&v589, (const std::error_code *)&v620[1]);
                  v446 = &v589;
                  if ((v589.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    v446 = (std::string *)v589.__r_.__value_.__r.__words[0];
                  }
                  v447 = (char *)&v621 + 1;
                  if (v621) {
                    v447 = *(char **)&v622[6];
                  }
                  *(_DWORD *)v606 = 136315394;
                  *(void *)&v606[4] = v446;
                  *(_WORD *)&v606[12] = 2080;
                  *(void *)&v606[14] = v447;
                  _os_log_error_impl(&dword_233120000, v444, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", v606, 0x16u);
                  if (SHIBYTE(v589.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v589.__r_.__value_.__l.__data_);
                  }
                }
              }
              v445 = [v417 nodeAtPath:v419];
              re::updateMeshOverrideCompileOptions(v319, v445);

              if (LOBYTE(v620[0]))
              {
                re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v620[1]);
                uint64_t v354 = v547;
              }
              else
              {
                uint64_t v354 = v547;
                if (v620[3] && (v621 & 1) != 0) {
                  (*(void (**)(void))(*(void *)v620[3] + 40))();
                }
              }
              if (*(void *)&__s[40])
              {
                if (v617) {
                  (*(void (**)(void))(**(void **)&__s[40] + 40))();
                }
                uint64_t v617 = 0;
                long long v615 = 0uLL;
                *(void *)&__s[40] = 0;
                ++v616;
              }
              if (*(void *)__s && *(void *)&__s[32]) {
                (*(void (**)(void))(**(void **)__s + 40))();
              }
              re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v585);
              re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v588);
              re::USDImportContext::popNodePath(v319);
              v352 = v576;
            }

            uint64_t v312 = v354 + 1;
          }
          while (v312 != v530);
        }
      }
      else
      {

        long long v291 = v542;
      }

      if (v591 && v592) {
        (*(void (**)(void))(*(void *)v591 + 40))();
      }
      a3 = v562;
    }

    goto LABEL_517;
  }
  BOOL IsBlendShapeRoot = re::uskNodeIsBlendShapeRoot(v8);
  v449 = v527;
  if (!IsBlendShapeRoot || !*(unsigned char *)(*((void *)a3 + 5) + 166))
  {
    v450 = [v8 childIterator];
    uint64_t v451 = [v450 nextObject];
    if (v451)
    {
      v452 = (void *)v451;
      do
      {
        v453 = [v548 metadataWithKey:@"kind"];
        v454 = [v453 stringValue];
        char v455 = [v454 isEqual:@"sceneLibrary"];

        if ((v455 & 1) == 0) {
          re::loadTransformAndMeshNodes(v537, v452, a3, 0);
        }
        uint64_t v456 = [v450 nextObject];

        v452 = (void *)v456;
      }
      while (v456);
    }

    id v8 = v548;
LABEL_517:
    v449 = v527;
  }

  if (v523) {
    re::USDImportContext::popNodePath(a3);
  }
}

void re::addPhysicsMaterialAsset(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  id v5 = a1;
  memset(v48, 0, sizeof(v48));
  if (re::hasPhysicsMaterialAPI(v5))
  {
    uint64_t v6 = *(unsigned int *)(a4 + 32);
    if (v6)
    {
      uint64_t v7 = 0;
      id v8 = (int *)(*(void *)(a4 + 16) + 8);
      do
      {
        int v9 = *v8;
        v8 += 18;
        if (v9 < 0) {
          goto LABEL_8;
        }
        ++v7;
      }
      while (v6 != v7);
      LODWORD(vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = *(_DWORD *)(a4 + 32);
    }
    else
    {
      LODWORD(vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
    }
LABEL_8:
    if (v6 == v7) {
      goto LABEL_9;
    }
    uint64_t v10 = v7;
    uint64_t v11 = *(void *)(a4 + 16);
    do
    {
      id v12 = *(id *)(v11 + 72 * v10 + 56);
      id v13 = v12;
      if (v12)
      {
        id v14 = v12;
        uint64_t v15 = [v14 path];
        unsigned int v16 = [v15 stringValue];

        if (!v16) {
          unsigned int v16 = &stru_26E738380;
        }
        if (!re::hasPhysicsMaterialAPI(v14)) {
          goto LABEL_20;
        }
        re::importPhysicsMaterial(v14, (uint64_t)&v49);
        if (!(_BYTE)v49)
        {
          unint64_t v19 = *re::pipelineLogObjects(v17);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            float32x4_t v45 = v16;
            int v22 = v19;
            uint64_t v23 = [(__CFString *)v45 UTF8String];
            uint64_t v24 = v54;
            if (v53) {
              uint64_t v24 = *(unsigned char **)&v54[7];
            }
            *(_DWORD *)buf = 136315394;
            uint64_t v56 = v23;
            __int16 v57 = 2080;
            float32x4_t v58 = v24;
            _os_log_error_impl(&dword_233120000, v22, OS_LOG_TYPE_ERROR, "Physics material (%s) import error: %s.", buf, 0x16u);
          }
          if (!(_BYTE)v49 && v52 && (v53 & 1) != 0) {
            (*(void (**)(void))(*(void *)v52 + 40))();
          }
LABEL_20:

          goto LABEL_21;
        }
        id v18 = v50;

        if (v18)
        {
          uint64_t v25 = [v14 path];
          id v26 = [v25 stringValue];
          long long v27 = (const char *)[v26 UTF8String];

          uint64_t v28 = *(void *)(a3 + 104);
          unint64_t v29 = (re::PhysicsMaterialAsset *)strlen(v27);
          float32x4_t v30 = re::PhysicsMaterialAsset::assetType(v29);
          uint64_t v31 = re::ImportAssetTable::importedAsset(v28, (uint64_t)v27, (uint64_t)v29, (re **)v30);
          if (v31)
          {
            uint64_t v32 = v31;
            uint64_t v33 = re::PhysicsFactory::m_defaultAllocator;
            (**(void (***)(re::PhysicsMaterial *))v18)(v18);
            float32x4_t v34 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, re::PhysicsMaterial *))(*(void *)v33 + 40))(v33, v18);
          }
          else
          {
            BOOL v35 = re::globalAllocators(0);
            re::PhysicsMaterial::createGenericMaterial(v18, (re::Allocator *)v35[2]);
            float32x4_t v37 = v36;
            float32x4_t v38 = re::globalAllocators(v36);
            float32x4_t v39 = (re **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v38[2] + 32))(v38[2], 16, 8);
            *float32x4_t v39 = v37;
            v39[1] = v18;
            float32x4_t v40 = *(_anonymous_namespace_ **)(a3 + 104);
            float32x4_t v41 = (re::PhysicsMaterialAsset *)strlen(v27);
            float32x4_t v42 = re::PhysicsMaterialAsset::assetType(v41);
            float32x4_t v34 = (_anonymous_namespace_ *)re::ImportAssetTable::addAsset(v40, (uint64_t)v27, (uint64_t)v41, v39, (re **)v42);
            uint64_t v32 = (uint64_t)v34;
          }
          float32x4_t v50 = 0;
          uint64_t v51 = 0;
          uint64_t v49 = 0;
          if (*(unsigned char *)(v32 + 8)) {
            float32x4_t v43 = *(re::AssetPath **)(v32 + 16);
          }
          else {
            float32x4_t v43 = (re::AssetPath *)(v32 + 9);
          }
          re::AssetHandle::operator=((uint64_t)v48, &v49);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v49);

          uint64_t v44 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a2 + 624, *(void *)(*(void *)(a2 + 848) + 8 * *(void *)(a2 + 832) - 8));
          re::AssetHandle::operator=(v44 + 848, v48);
          break;
        }
      }
LABEL_21:

      uint64_t v11 = *(void *)(a4 + 16);
      if (*(_DWORD *)(a4 + 32) <= (v7 + 1)) {
        int v20 = v7 + 1;
      }
      else {
        int v20 = *(_DWORD *)(a4 + 32);
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v20 - 1 == v7) {
          break;
        }
        LODWORD(vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v7 + 1;
        int v21 = v10;
        if ((*(_DWORD *)(v11 + 72 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_28;
        }
      }
      int v21 = v20;
LABEL_28:
      LODWORD(vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v21;
    }
    while (v6 != v21);
  }
LABEL_9:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v48);
}

void re::updateMeshOverrideCompileOptions(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1[106] + 8 * a1[104] - 8);
  id v5 = [v3 path];
  id v6 = [v5 stringValue];
  uint64_t v7 = (_anonymous_namespace_ *)[v6 UTF8String];
  unint64_t v43 = 0;
  uint64_t v44 = "";

  unint64_t v8 = 0;
  unint64_t v10 = v43;
  int v9 = v44;
  uint64_t v11 = v4 + 1;
  while (1)
  {
    uint64_t v12 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)(a1 + 78), v8);
    if ((v10 ^ *(void *)(v12 + 24)) <= 1)
    {
      uint64_t v13 = v12;
      id v14 = *(const char **)(v12 + 32);
      if (v14 == v9 || !strcmp(v14, v9)) {
        break;
      }
    }
    if (v11 == ++v8) {
      goto LABEL_32;
    }
  }
  uint64_t v15 = (unsigned char *)a1[5];
  id v16 = v3;
  v41[0] = 0;
  *(_WORD *)&_OWORD v41[2] = 257;
  v41[4] = 1;
  *(_DWORD *)&v41[5] = 0;
  v41[9] = 0;
  *(_DWORD *)&v41[12] = 1036831949;
  *(_DWORD *)&v41[16] = 16843008;
  memset(v42, 0, sizeof(v42));
  DWORD1(v42[2]) = 0x7FFFFFFF;
  v41[10] = v15[161];
  v41[1] = v15[162];
  *(_WORD *)&v41[6] = v15[165];
  v41[20] = v15[165];
  uint64_t v17 = [v16 customMetadataWithKey:@"RE:mesh:v1:decimationFactor"];
  id v18 = v17;
  if (v17)
  {
    [v17 floatValue];
    *(_DWORD *)&v41[12] = v19;
  }
  int v20 = [v16 customMetadataWithKey:@"RE:mesh:v1:generateVertexFaceAdjacencyAttributes"];
  int v21 = v20;
  if (v20) {
    v41[0] = [v20 BOOLValue];
  }

  int v22 = [v16 customMetadataWithKey:@"RE:mesh:v1:reorderVertexCaching"];
  uint64_t v23 = v22;
  if (v22) {
    v41[1] = [v22 BOOLValue];
  }

  uint64_t v24 = [v16 customMetadataWithKey:@"RE:mesh:v1:repairTangents"];
  uint64_t v25 = v24;
  if (v24) {
    _OWORD v41[2] = [v24 BOOLValue];
  }

  id v26 = [v16 customMetadataWithKey:@"RE:mesh:v1:mergeVerticesIfPolygonSoup"];
  long long v27 = v26;
  if (v26) {
    v41[3] = [v26 BOOLValue];
  }

  uint64_t v28 = [v16 customMetadataWithKey:@"RE:mesh:v1:preserveSharpFeatures"];
  unint64_t v29 = v28;
  if (v28) {
    v41[5] = [v28 BOOLValue];
  }

  float32x4_t v30 = [v16 customMetadataWithKey:@"RE:mesh:v1:forceRetainFaceNormals"];
  uint64_t v31 = v30;
  if (v30) {
    v41[7] = [v30 BOOLValue];
  }

  uint64_t v32 = [v16 customMetadataWithKey:@"RE:mesh:v1:generateLaplacianStencilDataAttributes"];
  uint64_t v33 = v32;
  if (v32) {
    unsigned char v41[8] = [v32 BOOLValue];
  }

  float32x4_t v34 = [v16 customMetadataWithKey:@"RE:mesh:v1:computeAdjacentFaceArea"];
  BOOL v35 = v34;
  if (v34) {
    v41[9] = [v34 BOOLValue];
  }

  float v36 = [v16 customMetadataWithKey:@"RE:mesh:v1:decimateMesh"];
  float32x4_t v37 = v36;
  if (v36) {
    v41[10] = [v36 BOOLValue];
  }

  *(_OWORD *)(v13 + 168) = *(_OWORD *)v41;
  *(void *)(v13 + 181) = *(void *)&v41[13];
  float32x4_t v38 = (void *)(v13 + 192);
  if ((_OWORD *)(v13 + 192) != v42)
  {
    if (*v38)
    {
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)v38);
    }
    else
    {
      *(void *)&v42[0] = 0;
      long long v39 = *(_OWORD *)(v13 + 200);
      *(void *)(v13 + 192) = 0;
      *(void *)(v13 + 200) = 0;
      *(void *)(v13 + 208) = 0;
      long long v40 = *(_OWORD *)(v13 + 216);
      *(_OWORD *)(v13 + 216) = xmmword_23436F740;
      *(_OWORD *)((char *)v42 + 8) = v39;
      *(_OWORD *)((char *)&v42[1] + 8) = v40;
    }
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v42);
LABEL_32:
  re::StringID::destroyString((re::StringID *)&v43);
}

void re::USDImportContext::GeomText3D::~GeomText3D(re::USDImportContext::GeomText3D *this)
{
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, const re::DynamicString *a2, uint64_t a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 88 * v11;
    return v12 + 48;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 88 * v9 + 16, (uint64_t)a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 88 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 88 * v9;
  return v12 + 48;
}

double re::createAnimationAssets(re *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = a1;
  uint64_t v41 = *MEMORY[0x263EF8340];
  int v25 = 0;
  memset(v24, 0, sizeof(v24));
  uint64_t v26 = 0x7FFFFFFFLL;
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      unint64_t v9 = *(void *)(a3 + 136);
      if (v9 <= v8)
      {
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 789;
        __int16 v32 = 2048;
        unint64_t v33 = v8;
        __int16 v34 = 2048;
        unint64_t v35 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_14:
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 789;
        __int16 v32 = 2048;
        unint64_t v33 = v8;
        __int16 v34 = 2048;
        unint64_t v35 = v3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = (_anonymous_namespace_ *)*((void *)v23 + 13);
      uint64_t v11 = *(void *)(a3 + 152) + v6;
      unint64_t v12 = *(void *)(v11 + 8);
      uint64_t v13 = *(void *)(v11 + 16);
      char v14 = re::globalAllocators(a1);
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14[2] + 32))(v14[2], 120, 8);
      unint64_t v3 = *(void *)(a2 + 16);
      if (v3 <= v8) {
        goto LABEL_14;
      }
      if (v12) {
        unint64_t v3 = v12 >> 1;
      }
      else {
        unint64_t v3 = v12 >> 1;
      }
      if (v12) {
        uint64_t v16 = v13;
      }
      else {
        uint64_t v16 = v11 + 9;
      }
      uint64_t v17 = *(void *)(a2 + 32) + v7;
      re::SampledAnimation<re::SkeletalPose>::SampledAnimation(v15, (void *)v17);
      *(void *)uint64_t v18 = &unk_26E6C1190;
      __int16 v19 = *(_WORD *)(v17 + 112);
      *(unsigned char *)(v18 + 114) = *(unsigned char *)(v17 + 114);
      *(_WORD *)(v18 + 112) = v19;
      TimelineAsset = re::AssetHelper::makeTimelineAsset((re *)v18, (uint64_t)v24);
      int v21 = re::TimelineAsset::assetType((re::TimelineAsset *)TimelineAsset);
      a1 = (re *)re::ImportAssetTable::addAsset(v10, v16, v3, TimelineAsset, (re **)v21);
      ++v8;
      v7 += 120;
      v6 += 32;
    }
    while (v8 < *(void *)(a2 + 16));
  }
  return re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v24);
}

uint64_t re::importSceneWithMDLAsset(void *a1, id *a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v249 = *MEMORY[0x263EF8340];
  if (*(void *)(a3 + 40)) {
    uint64_t v6 = *(const char **)(a3 + 48);
  }
  else {
    uint64_t v6 = (const char *)(a3 + 41);
  }
  uint64_t v7 = (_anonymous_namespace_ *)(a1 + 13);
  char v8 = *(unsigned char *)(a3 + 72);
  char v9 = *(unsigned char *)(a3 + 73);
  uint64_t v10 = (_anonymous_namespace_ *)*a2;
  id v144 = *(id *)a3;
  id v145 = *(id *)(a3 + 8);
  __int16 v146 = *(_WORD *)(a3 + 16);
  char v147 = *(unsigned char *)(a3 + 18);
  if (*(unsigned char *)(a3 + 19)) {
    char v149 = *(unsigned char *)(a3 + 20);
  }
  uint64_t v150 = *(void *)(a3 + 24);
  uint64_t v11 = [(_anonymous_namespace_ *)v10 URL];

  id v151 = v11;
  *((void *)&v152 + 1) = 0;
  long long v153 = 0uLL;
  re::DynamicString::setCapacity(&v152, 0);
  memset(v154, 0, 3);
  id v155 = 0;
  __int16 v156 = 257;
  id v157 = v7;
  memset(v158, 0, 36);
  *(void *)&v158[36] = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v158, (uint64_t)v143, 3);
  char v159 = 0;
  char v160 = v8;
  char v161 = v9;
  int v162 = 1;
  memset(v163, 0, sizeof(v163));
  uint64_t v165 = 0x7FFFFFFFLL;
  memset(v166, 0, sizeof(v166));
  int v164 = 0;
  int v167 = 0;
  uint64_t v168 = 0x7FFFFFFFLL;
  memset(v169, 0, sizeof(v169));
  int v170 = 0;
  uint64_t v171 = 0x7FFFFFFFLL;
  memset(v172, 0, sizeof(v172));
  int v173 = 0;
  uint64_t v174 = 0x7FFFFFFFLL;
  char v175 = 0;
  if (v6)
  {
    size_t v13 = strlen(v6);
    v224.n128_u64[0] = (unint64_t)v6;
    v224.n128_u64[1] = v13;
    re::DynamicString::operator=((re::DynamicString *)&v152, (uint64_t)&v224);
  }
  v218[0].__r_.__value_.__r.__words[0] = *MEMORY[0x263F0F600];
  v224.n128_u64[0] = MEMORY[0x263EFFA80];
  char v14 = [NSDictionary dictionaryWithObjects:&v224 forKeys:v218 count:1];
  id v15 = v155;
  id v155 = v14;

  LOBYTE(v154[0]) = *(unsigned char *)(a3 + 64);
  *(_WORD *)((char *)v154 + 1) = *(_WORD *)(a3 + 65);
  BYTE2(v162) = *(unsigned char *)(a3 + 75);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v163, a3 + 88);
  re::ImportedScene::ImportedScene((re::ImportedScene *)&v224);
  re::DynamicArray<re::ImportedScene>::add((uint64_t)(a1 + 36), &v224);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v230 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v228 + 8));
  if (*(void *)&v227[8])
  {
    if (v227[16]) {
      (*(void (**)(void))(**(void **)&v227[8] + 40))();
    }
    memset(&v227[8], 0, 32);
  }
  uint64_t v16 = (re *)v225;
  if (void)v225 && (BYTE8(v225)) {
    uint64_t v16 = (re *)(*(uint64_t (**)(void))(*(void *)v225 + 40))();
  }
  uint64_t v17 = re::globalAllocators(v16);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17[2] + 32))(v17[2], 40, 8);
  *(_OWORD *)uint64_t v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(void *)(v18 + 32) = 0;
  if (!a1[38])
  {
    *(void *)buf = 0;
    memset(v227, 0, 32);
    long long v225 = 0uLL;
    long long v226 = 0uLL;
    __n128 v224 = 0uLL;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v218[0].__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)v218[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"operator[]";
    WORD2(v218[0].__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&v218[0].__r_.__value_.__r.__words[1] + 6) = 789;
    WORD1(v218[0].__r_.__value_.__r.__words[2]) = 2048;
    *(std::string::size_type *)((char *)&v218[0].__r_.__value_.__r.__words[2] + 4) = 0;
    WORD2(v218[1].__r_.__value_.__r.__words[0]) = 2048;
    *(std::string::size_type *)((char *)v218[1].__r_.__value_.__r.__words + 6) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v19 = v18;
  char v140 = a1;
  *(void *)(a1[40] + 48) = v18;
  int v20 = *(unsigned __int8 *)(a3 + 67);
  id v21 = *a2;
  if (v20)
  {
    id v142 = v21;
    int32x2_t v137 = *(int32x2_t *)(a3 + 68);
    uint64_t v209 = 0;
    uint64_t v207 = 0;
    uint64_t v205 = 0;
    uint64_t v206 = 0;
    int v208 = 0;
    uint64_t v204 = 0;
    uint64_t v202 = 0;
    uint64_t v200 = 0;
    uint64_t v201 = 0;
    int v203 = 0;
    uint64_t v199 = 0;
    uint64_t v197 = 0;
    uint64_t v195 = 0;
    uint64_t v196 = 0;
    int v198 = 0;
    __n128 v224 = 0uLL;
    *(void *)&long long v225 = 0;
    long long v226 = 0u;
    memset(v227, 0, 20);
    DWORD2(v225) = 0;
    *(_OWORD *)&v227[24] = 0u;
    long long v228 = 0u;
    long long v230 = 0u;
    long long v231 = 0u;
    int v229 = 0;
    int v232 = 0;
    long long v233 = 0u;
    memset(v234, 0, sizeof(v234));
    uint64_t v235 = 0x7FFFFFFFLL;
    long long v236 = 0u;
    long long v237 = 0u;
    uint64_t v239 = 0x7FFFFFFFLL;
    long long v240 = 0u;
    long long v241 = 0u;
    int v238 = 0;
    int v242 = 0;
    uint64_t v243 = 0x7FFFFFFFLL;
    uint64_t v248 = 0;
    uint64_t v246 = 0;
    int v247 = 0;
    uint64_t v244 = 0;
    uint64_t v245 = 0;
    id v22 = [v21 resolver];

    long long v219 = 0u;
    uint64_t v221 = 0;
    memset(v220, 0, sizeof(v220));
    memset(v218, 0, sizeof(v218));
    v218[0].__r_.__value_.__r.__words[2] = (std::string::size_type)"";
    v218[1].__r_.__value_.__s.__data_[0] = 1;
    *(void *)&long long v219 = 0;
    DWORD2(v2re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
    re::DynamicArray<re::ecs2::EntityAssetData>::add(v19, (uint64_t)v218);
    re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)v218);
    uint64_t v23 = (_DWORD *)(*(void *)(v19 + 32) + 112 * *(void *)(v19 + 16) - 112);
    uint64_t v24 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(v23);
    *((void *)v24 + 4) = 0x3F8000003F800000;
    *((void *)v24 + 5) = 1065353216;
    *((void *)v24 + 6) = 0;
    *((void *)v24 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0x3F80000000000000;
    *((void *)v24 + 8) = 0;
    *((void *)v24 + 9) = 0;
    [v142 upAxis];
    float32x4_t v26 = vmulq_f32(v25, v25);
    float32x4_t v27 = vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1));
    float32x4_t v28 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), v27);
    v28.f32[0] = fabsf(v28.f32[0]);
    v27.i32[0] = 786163454;
    float32x4_t v29 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v27, v28), 0), (int8x16_t)xmmword_23435FD60, (int8x16_t)v25);
    float32x4_t v30 = vmulq_f32(v29, v29);
    LODWORD(v31) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).u32[0];
    if (fabsf(v31) >= 1.0e-10)
    {
      float v32 = v31;
      float32x2_t v33 = vrsqrte_f32((float32x2_t)LODWORD(v31));
      float32x2_t v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)LODWORD(v32), vmul_f32(v33, v33)));
      float32x4_t v29 = vmulq_n_f32(v29, vmul_f32(v34, vrsqrts_f32((float32x2_t)LODWORD(v32), vmul_f32(v34, v34))).f32[0]);
    }
    float32x2_t v35 = vrsqrte_f32((float32x2_t)1065353216);
    float32x2_t v36 = vmul_f32(v35, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v35, v35)));
    float32x4_t v37 = vmulq_n_f32((float32x4_t)xmmword_23435FD60, vmul_f32(v36, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v36, v36))).f32[0]);
    float32x4_t v38 = vmulq_f32(v29, v37);
    int32x2_t v39 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).u64[0];
    if (*(float *)v39.i32 == -1.0
      || (float v40 = (float)((float)(fabsf(*(float *)v39.i32) + 1.0) + 1.0) * 0.00001,
          *(float *)v39.i32 = *(float *)v39.i32 + 1.0,
          fabsf(*(float *)v39.i32) < v40))
    {
      if (fabsf(v29.f32[2]) >= 0.00001)
      {
        v41.i32[0] = 0;
        v41.f32[1] = -v29.f32[2];
        v41.i64[1] = v29.u32[1];
      }
      else
      {
        float32x4_t v41 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v29.f32[1]), (int32x4_t)v29);
      }
      int32x2_t v49 = v137;
      float32x4_t v50 = v22;
      int32x4_t v51 = (int32x4_t)vmulq_f32(v41, v41);
      v51.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v51, 2), vadd_f32(*(float32x2_t *)v51.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v51.i8, 1))).u32[0];
      float32x2_t v52 = vrsqrte_f32((float32x2_t)v51.u32[0]);
      float32x2_t v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v52, v52)));
      float32x4_t v54 = vmulq_n_f32(v41, vmul_f32(v53, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v53, v53))).f32[0]);
      float v55 = 0.0;
    }
    else
    {
      float32x4_t v50 = v22;
      int8x16_t v126 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), (int8x16_t)v37, 0xCuLL), vnegq_f32(v29)), v37, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL));
      *(float *)v39.i32 = sqrtf(*(float *)v39.i32 + *(float *)v39.i32);
      float v55 = *(float *)v39.i32 * 0.5;
      float32x4_t v54 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v126, (int32x4_t)v126), v126, 0xCuLL), (float32x4_t)vdupq_lane_s32(v39, 0));
      int32x2_t v49 = v137;
    }
    v54.f32[3] = v55;
    *((int32x4_t *)v24 + 2) = vdupq_lane_s32(v49, 0);
    *((float32x4_t *)v24 + 3) = v54;
    LOBYTE(v189) = 0;
    WORD1(v189) = 257;
    BYTE4(v189) = 1;
    *(_DWORD *)((char *)&v189 + 5) = 0;
    BYTE9(v189) = 0;
    HIDWORD(v189) = 1036831949;
    LODWORD(v190[0]) = 16843008;
    memset(&v190[1], 0, 48);
    HIDWORD(v190[5]) = 0x7FFFFFFF;
    BYTE10(v189) = v160;
    BYTE1(v189) = v161;
    BYTE6(v189) = BYTE2(v162);
    BYTE4(v190[0]) = BYTE2(v162);
    memset(v218, 0, 28);
    *(_OWORD *)&v218[1].__r_.__value_.__r.__words[1] = 0u;
    long long v219 = 0u;
    LODWORD(v220[0]) = 0;
    memset(&v220[1], 0, 32);
    LODWORD(v221) = 0;
    memset(v222, 0, sizeof(v222));
    uint64_t v223 = 0x7FFFFFFFLL;
    int v193 = 0;
    long long v191 = 0u;
    long long v192 = 0u;
    *(void *)uint64_t v194 = 0x7FFFFFFFLL;
    if (re::convertMDLAssetToGeomSceneAndImportAnimation(&v142, "", (uint64_t)v218, (uint64_t)&v191, (uint64_t)&v205, (uint64_t)&v200, &v195, (re::AnimationMetaData *)&v224, v190, a4))
    {
      re::makeMeshAssetDataFromGeomScene(v218, (uint64_t)&v189, (uint64_t)buf);
      if (buf[0])
      {
        re::createAnimationAssets((re *)&v143, (uint64_t)&v195, (uint64_t)&v224);
        uint64_t v188 = 0;
        float v186 = 0;
        uint64_t v184 = 0;
        uint64_t v185 = 0;
        int v187 = 0;
        if (*((void *)&v231 + 1))
        {
          __int16 v57 = (uint64_t *)(v233 + 16);
          uint64_t v58 = 32 * *((void *)&v231 + 1);
          do
          {
            unint64_t v59 = *(v57 - 1);
            if (v59) {
              uint64_t v60 = *v57;
            }
            else {
              uint64_t v60 = (uint64_t)v57 - 7;
            }
            uint64_t v61 = v59 >> 1;
            uint64_t v62 = v59 >> 1;
            if (*(v57 - 1)) {
              uint64_t v63 = v61;
            }
            else {
              uint64_t v63 = v62;
            }
            float v64 = re::TimelineAsset::assetType(v56);
            re::ImportAssetTable::compiledAssetPath(v60, v63, (re **)v64, (re::DynamicString *)&v176);
            double v65 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&v184, &v176);
            uint64_t v56 = v176;
            if (v176 && (v177 & 1) != 0) {
              uint64_t v56 = (re::TimelineAsset *)(*(uint64_t (**)(double))(*(void *)v176 + 40))(v65);
            }
            v57 += 4;
            v58 -= 32;
          }
          while (v58);
        }
        uint64_t v66 = (re *)re::AnimationLibraryAsset::buildAsset(&buf[8], (uint64_t)&v230 + 8, (uint64_t)&v227[32], (uint64_t)&v226 + 8, (uint64_t)&v184);
        long long v67 = re::globalAllocators(v66);
        int v68 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v67[2] + 32))(v67[2], 960, 8);
        uint64_t v69 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v68, (uint64_t)&buf[8]);
        *((_DWORD *)v69 + 231) = 1;
        int v70 = v157;
        uint64_t v71 = re::MeshAsset::assetType(v69);
        long long v72 = (const re::DynamicString *)re::ImportAssetTable::addAsset(v70, (uint64_t)"singleMesh", 10, v68, (re **)v71);
        re::DynamicString::DynamicString((re::DynamicString *)&v181, v72);
        uint64_t v180 = 0;
        uint64_t v177 = 0;
        uint64_t v178 = 0;
        uint64_t v176 = 0;
        int v179 = 0;
        re::createMaterialAssetsFromMaterialTable((uint64_t)&v143, (uint64_t)&v191, (_anonymous_namespace_ *)&v176);
        re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>(v23);
        re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>(v23);
        re::ecs2::EntityAssetData::addComponent<re::ecs2::BlendShapeWeightsComponent>(v23);
        if (v207 && v202) {
          re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>(v23);
        }
        int v73 = re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>(v23);
        uint64_t v74 = v73;
        uint64_t v75 = (re::DynamicString *)(v73 + 4);
        if (v182) {
          double v76 = *(re::AssetPath **)&v183[7];
        }
        else {
          double v76 = (re::AssetPath *)v183;
        }
        id v77 = (re::AnimationLibraryAsset *)re::DynamicArray<re::AssetHandle>::operator=((uint64_t)(v74 + 7), (uint64_t *)&v176);
        if (v66)
        {
          float v78 = v157;
          long long v79 = re::AnimationLibraryAsset::assetType(v77);
          uint64_t v80 = re::ImportAssetTable::addAsset(v78, (uint64_t)"animationLibrary", 16, v66, (re **)v79);
          unint64_t v81 = (_anonymous_namespace_ *)re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationLibraryComponent>(v23);
          uint64_t v82 = (_anonymous_namespace_ *)((char *)v81 + 32);
          if (*(unsigned char *)(v80 + 8)) {
            float32x4_t v83 = *(re::AssetPath **)(v80 + 16);
          }
          else {
            float32x4_t v83 = (re::AssetPath *)(v80 + 9);
          }
        }
        re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v176);
        if (v181 && (v182 & 1) != 0) {
          (*(void (**)(void))(*(void *)v181 + 40))();
        }
        re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v184);
        re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)buf);
      }
      else
      {
        re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)buf);
      }
    }
    re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)&v191);
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v222[8]);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v220[2]);
    if (v218[1].__r_.__value_.__r.__words[2])
    {
      if (v220[1]) {
        (*(void (**)(void))(*(void *)v218[1].__r_.__value_.__r.__words[2] + 40))();
      }
      v220[1] = 0;
      long long v219 = 0uLL;
      v218[1].__r_.__value_.__r.__words[2] = 0;
      ++LODWORD(v220[0]);
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v218);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(&v190[1]);

    id v125 = v140;
    if (v244)
    {
      if (v248) {
        (*(void (**)(void))(*(void *)v244 + 40))();
      }
      uint64_t v248 = 0;
      uint64_t v245 = 0;
      uint64_t v246 = 0;
      uint64_t v244 = 0;
      ++v247;
    }
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v240);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v236);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v233 + 1);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v230 + 8);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v227[32]);
    if (*((void *)&v226 + 1))
    {
      if (*(void *)&v227[24]) {
        (*(void (**)(void))(**((void **)&v226 + 1) + 40))();
      }
      *(void *)&v227[24] = 0;
      *(void *)v227 = 0;
      *(void *)&v227[8] = 0;
      *((void *)&v226 + 1) = 0;
      ++*(_DWORD *)&v227[16];
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v224);
    re::DynamicArray<re::SkeletalPoseSampledAnimation>::deinit((uint64_t)&v195);
    re::DynamicArray<re::ModelIOSkinningData>::deinit((uint64_t)&v200);
    re::DynamicArray<re::ModelIOSkeleton>::deinit((uint64_t)&v205);
    id v113 = v142;
  }
  else
  {
    int32x2_t v138 = *(int32x2_t *)(a3 + 68);
    uint64_t v209 = 0;
    uint64_t v207 = 0;
    uint64_t v205 = 0;
    uint64_t v206 = 0;
    int v208 = 0;
    uint64_t v204 = 0;
    uint64_t v202 = 0;
    uint64_t v200 = 0;
    uint64_t v201 = 0;
    int v203 = 0;
    uint64_t v199 = 0;
    uint64_t v197 = 0;
    uint64_t v195 = 0;
    uint64_t v196 = 0;
    int v198 = 0;
    __n128 v224 = 0uLL;
    *(void *)&long long v225 = 0;
    long long v226 = 0u;
    memset(v227, 0, 20);
    DWORD2(v225) = 0;
    *(_OWORD *)&v227[24] = 0u;
    long long v228 = 0u;
    long long v230 = 0u;
    long long v231 = 0u;
    int v229 = 0;
    int v232 = 0;
    long long v233 = 0u;
    memset(v234, 0, sizeof(v234));
    uint64_t v235 = 0x7FFFFFFFLL;
    long long v236 = 0u;
    long long v237 = 0u;
    uint64_t v239 = 0x7FFFFFFFLL;
    long long v240 = 0u;
    long long v241 = 0u;
    int v238 = 0;
    int v242 = 0;
    uint64_t v243 = 0x7FFFFFFFLL;
    uint64_t v248 = 0;
    uint64_t v246 = 0;
    int v247 = 0;
    uint64_t v244 = 0;
    uint64_t v245 = 0;
    LOBYTE(v191) = 1;
    float32x4_t v42 = v21;
    re::importSkinningAndSkeletalAnimations(v21, (uint64_t)&v205, (uint64_t)&v200, &v195, (re::AnimationMetaData *)&v224, (unsigned __int8 *)v218);
    data = (re *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)&v191, (uint64_t)v218);
    if (!v218[0].__r_.__value_.__s.__data_[0])
    {
      data = (re *)v218[1].__r_.__value_.__l.__data_;
      if (v218[1].__r_.__value_.__r.__words[0])
      {
        if (v218[1].__r_.__value_.__s.__data_[8]) {
          data = (re *)(*(uint64_t (**)(void))(*(void *)v218[1].__r_.__value_.__l.__data_ + 40))();
        }
      }
    }
    if (!(_BYTE)v191)
    {
      uint64_t v44 = (id)*re::pipelineLogObjects(data);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(v218, (const std::error_code *)((char *)&v191 + 8));
        long long v135 = (v218[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
             ? v218
             : (std::string *)v218[0].__r_.__value_.__r.__words[0];
        float v136 = (v193 & 1) != 0 ? *(int **)&v194[4] : (int *)((char *)&v193 + 1);
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v135;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v136;
        _os_log_error_impl(&dword_233120000, v44, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", buf, 0x16u);
        if (SHIBYTE(v218[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v218[0].__r_.__value_.__l.__data_);
        }
      }

      if (a4) {
        *a4 = CFErrorCreate(0, @"REPipelineErrorDomain", 3, 0);
      }
    }
    long long v219 = 0u;
    uint64_t v221 = 0;
    memset(v220, 0, sizeof(v220));
    memset(v218, 0, sizeof(v218));
    v218[0].__r_.__value_.__r.__words[2] = (std::string::size_type)"";
    v218[1].__r_.__value_.__s.__data_[0] = 1;
    *(void *)&long long v219 = 0;
    DWORD2(v2re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
    re::DynamicArray<re::ecs2::EntityAssetData>::add(v19, (uint64_t)v218);
    re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)v218);
    uint64_t v45 = *(void *)(v19 + 32);
    uint64_t v46 = *(void *)(v19 + 16) - 1;
    if (v151)
    {
      id v47 = [v151 lastPathComponent];
      re::DynamicString::format((re::DynamicString *)"rootEntity-%s", (re::DynamicString *)&v184, [v47 UTF8String]);
    }
    else
    {
      float32x4_t v48 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"rootEntity-%s", (re::DynamicString *)&v184, "mdlAsset");
    }
    if (v185) {
      float v84 = v186;
    }
    else {
      float v84 = (char *)&v185 + 1;
    }
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = "";
    uint64_t v85 = v45 + 112 * v46;
    uint64_t v86 = *(void *)buf;
    uint64_t v87 = *(void *)&buf[8];
    *(void *)&uint8_t buf[8] = "";
    *(void *)buf = 0;
    std::string::size_type v88 = *(void *)(v85 + 16);
    unint64_t v89 = v86 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v85 + 8) & 1;
    *(void *)(v85 + 16) = v87;
    v218[0].__r_.__value_.__l.__size_ = v88;
    v218[0].__r_.__value_.__r.__words[0] = v89;
    *(void *)(v85 + 8) = v86;
    re::StringID::destroyString((re::StringID *)v218);
    re::StringID::destroyString((re::StringID *)buf);
    float32x4_t v90 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>((_DWORD *)(v45 + 112 * v46));
    [v42 upAxis];
    float32x4_t v92 = vmulq_f32(v91, v91);
    float32x4_t v93 = vaddq_f32(v92, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v92.f32, 1));
    float32x4_t v94 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 2), v93);
    v94.f32[0] = fabsf(v94.f32[0]);
    v93.i32[0] = 786163454;
    float32x4_t v95 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v93, v94), 0), (int8x16_t)xmmword_23435FD60, (int8x16_t)v91);
    float32x4_t v96 = vmulq_f32(v95, v95);
    LODWORD(v9re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 2), vaddq_f32(v96, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v96.f32, 1))).u32[0];
    if (fabsf(v97) >= 1.0e-10)
    {
      float v98 = v97;
      float32x2_t v99 = vrsqrte_f32((float32x2_t)LODWORD(v97));
      float32x2_t v100 = vmul_f32(v99, vrsqrts_f32((float32x2_t)LODWORD(v98), vmul_f32(v99, v99)));
      float32x4_t v95 = vmulq_n_f32(v95, vmul_f32(v100, vrsqrts_f32((float32x2_t)LODWORD(v98), vmul_f32(v100, v100))).f32[0]);
    }
    float32x2_t v101 = vrsqrte_f32((float32x2_t)1065353216);
    float32x2_t v102 = vmul_f32(v101, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v101, v101)));
    float32x4_t v103 = vmulq_n_f32((float32x4_t)xmmword_23435FD60, vmul_f32(v102, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v102, v102))).f32[0]);
    float32x4_t v104 = vmulq_f32(v95, v103);
    int32x2_t v105 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v104, 2), vaddq_f32(v104, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.f32, 1))).u64[0];
    if (*(float *)v105.i32 == -1.0
      || (float v106 = (float)((float)(fabsf(*(float *)v105.i32) + 1.0) + 1.0) * 0.00001,
          *(float *)v105.i32 = *(float *)v105.i32 + 1.0,
          fabsf(*(float *)v105.i32) < v106))
    {
      if (fabsf(v95.f32[2]) >= 0.00001)
      {
        v107.i32[0] = 0;
        v107.f32[1] = -v95.f32[2];
        v107.i64[1] = v95.u32[1];
      }
      else
      {
        float32x4_t v107 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v95.f32[1]), (int32x4_t)v95);
      }
      int32x4_t v108 = (int32x4_t)vmulq_f32(v107, v107);
      v108.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v108, 2), vadd_f32(*(float32x2_t *)v108.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v108.i8, 1))).u32[0];
      float32x2_t v109 = vrsqrte_f32((float32x2_t)v108.u32[0]);
      float32x2_t v110 = vmul_f32(v109, vrsqrts_f32((float32x2_t)v108.u32[0], vmul_f32(v109, v109)));
      float32x4_t v111 = vmulq_n_f32(v107, vmul_f32(v110, vrsqrts_f32((float32x2_t)v108.u32[0], vmul_f32(v110, v110))).f32[0]);
      float v112 = 0.0;
    }
    else
    {
      int8x16_t v127 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL), vnegq_f32(v95)), v103, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL));
      *(float *)v105.i32 = sqrtf(*(float *)v105.i32 + *(float *)v105.i32);
      float v112 = *(float *)v105.i32 * 0.5;
      float32x4_t v111 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v127, (int32x4_t)v127), v127, 0xCuLL), (float32x4_t)vdupq_lane_s32(v105, 0));
    }
    v111.f32[3] = v112;
    *((int32x4_t *)v90 + 2) = vdupq_lane_s32(v138, 0);
    *((float32x4_t *)v90 + 3) = v111;
    long long v189 = 0u;
    memset(v190, 0, 48);
    id v113 = v42;
    uint64_t v114 = [v113 countByEnumeratingWithState:&v189 objects:v218 count:16];
    if (v114)
    {
      uint64_t v115 = v114;
      uint64_t v116 = v45 + 112 * v46;
      uint64_t v117 = v116 + 72;
      uint64_t v118 = *(void *)v190[0];
      uint64_t v119 = (void *)(v116 + 104);
      uint64_t v120 = (void *)(v116 + 88);
      do
      {
        uint64_t v121 = v113;
        for (uint64_t i = 0; i != v115; ++i)
        {
          if (*(void *)v190[0] != v118) {
            objc_enumerationMutation(v121);
          }
          float v123 = *(void **)(*((void *)&v189 + 1) + 8 * i);
          uint64_t v217 = 0;
          uint64_t v216 = 0;
          long long v213 = 0u;
          memset(buf, 0, sizeof(buf));
          *(void *)&uint8_t buf[16] = "";
          unsigned char buf[24] = 1;
          uint64_t v211 = 0;
          uint64_t v212 = 0;
          *(void *)&long long v213 = 0;
          DWORD2(v2re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13) = 0;
          long long v214 = 0u;
          long long v215 = 0u;
          re::DynamicArray<re::ecs2::EntityAssetData>::add(v117, (uint64_t)buf);
          re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)buf);
          re::loadMDLObject((uint64_t)&v143, v123, *v119 + 112 * *v120 - 112, (uint64_t)&v205, (uint64_t)&v200, (uint64_t)&v224);
        }
        id v113 = v121;
        uint64_t v115 = [v121 countByEnumeratingWithState:&v189 objects:v218 count:16];
      }
      while (v115);
    }

    v124.n128_f64[0] = re::createAnimationAssets((re *)&v143, (uint64_t)&v195, (uint64_t)&v224);
    if (v184 && (v185 & 1) != 0) {
      (*(void (**)(double))(*(void *)v184 + 40))(v124.n128_f64[0]);
    }
    id v125 = v140;
    if (!(_BYTE)v191 && *((void *)&v192 + 1) && (v193 & 1) != 0) {
      (*(void (**)(__n128))(**((void **)&v192 + 1) + 40))(v124);
    }
    if (v244)
    {
      if (v248) {
        (*(void (**)(__n128))(*(void *)v244 + 40))(v124);
      }
      uint64_t v248 = 0;
      uint64_t v245 = 0;
      uint64_t v246 = 0;
      uint64_t v244 = 0;
      ++v247;
    }
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v240);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v236);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v233 + 1);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v230 + 8);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v227[32]);
    if (*((void *)&v226 + 1))
    {
      if (*(void *)&v227[24]) {
        (*(void (**)(void))(**((void **)&v226 + 1) + 40))();
      }
      *(void *)&v227[24] = 0;
      *(void *)v227 = 0;
      *(void *)&v227[8] = 0;
      *((void *)&v226 + 1) = 0;
      ++*(_DWORD *)&v227[16];
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v224);
    re::DynamicArray<re::SkeletalPoseSampledAnimation>::deinit((uint64_t)&v195);
    re::DynamicArray<re::ModelIOSkinningData>::deinit((uint64_t)&v200);
    re::DynamicArray<re::ModelIOSkeleton>::deinit((uint64_t)&v205);
  }

  unint64_t v128 = v125 + 1;
  if (v125 + 1 != (void *)v158)
  {
    uint64_t v129 = *(void *)v158;
    if (!*v128 || *v128 == *(void *)v158)
    {
      *(void *)uint64_t v158 = *v128;
      uint64_t v130 = *(void *)&v158[8];
      uint64_t v131 = *(void *)&v158[16];
      long long v132 = *((_OWORD *)v125 + 1);
      long long v133 = *((_OWORD *)v125 + 2);
      v125[1] = v129;
      v125[2] = v130;
      v125[3] = v131;
      *(_OWORD *)&v158[8] = v132;
      *((_OWORD *)v125 + 2) = *(_OWORD *)&v158[24];
      *(_OWORD *)&v158[24] = v133;
    }
    else if (*(void *)v158)
    {
      re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy((uint64_t)v128, (uint64_t)v158);
      ++*((_DWORD *)v125 + 12);
    }
    else
    {
      re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)v128);
    }
  }
  re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v172);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v169);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v166);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v163);
  re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v158);

  if ((void)v152)
  {
    if (BYTE8(v152)) {
      (*(void (**)(void))(*(void *)v152 + 40))();
    }
    long long v152 = 0u;
    long long v153 = 0u;
  }

  return 1;
}

__n128 re::DynamicArray<re::ImportedScene>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::ImportedScene>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::ImportedScene>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 160 * v5;
  __n128 result = *a2;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + 32) = 0u;
  *(__n128 *)uint64_t v11 = result;
  *(void *)(v11 + 40) = a2[2].n128_u64[1];
  unint64_t v13 = a2[1].n128_u64[1];
  *(void *)(v11 + 16) = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = 0;
  unint64_t v14 = a2[2].n128_u64[0];
  a2[2].n128_u64[1] = 0;
  unint64_t v16 = *(void *)(v11 + 24);
  unint64_t v15 = *(void *)(v11 + 32);
  *(void *)(v11 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v13;
  *(void *)(v11 + 32) = v14;
  a2[1].n128_u64[1] = v16;
  a2[2].n128_u64[0] = v15;
  *(void *)(v11 + 48) = a2[3].n128_u64[0];
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *(void *)(v11 + 80) = a2[5].n128_u64[0];
  unint64_t v17 = a2[4].n128_u64[0];
  *(void *)(v11 + 56) = a2[3].n128_u64[1];
  a2[3].n128_u64[1] = 0;
  unint64_t v18 = a2[4].n128_u64[1];
  a2[5].n128_u64[0] = 0;
  unint64_t v20 = *(void *)(v11 + 64);
  unint64_t v19 = *(void *)(v11 + 72);
  *(void *)(v11 + 64) = v17;
  *(void *)(v11 + 72) = v18;
  a2[4].n128_u64[0] = v20;
  a2[4].n128_u64[1] = v19;
  *(unsigned char *)(v11 + 88) = a2[5].n128_u8[8];
  *(void *)(v11 + 104) = 0;
  *(void *)(v11 + 112) = 0;
  *(void *)(v11 + 96) = 0;
  *(void *)(v11 + 104) = a2[6].n128_u64[1];
  a2[6].n128_u64[1] = 0;
  unint64_t v21 = *(void *)(v11 + 96);
  *(void *)(v11 + 96) = 0;
  *(void *)(v11 + 96) = a2[6].n128_u64[0];
  a2[6].n128_u64[0] = v21;
  unint64_t v22 = *(void *)(v11 + 112);
  *(void *)(v11 + 112) = a2[7].n128_u64[0];
  a2[7].n128_u64[0] = v22;
  *(void *)(v11 + 152) = 0;
  *(void *)(v11 + 128) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 120) = 0;
  *(_DWORD *)(v11 + 144) = 0;
  unint64_t v23 = a2[8].n128_u64[0];
  *(void *)(v11 + 120) = a2[7].n128_u64[1];
  *(void *)(v11 + 128) = v23;
  a2[7].n128_u64[1] = 0;
  a2[8].n128_u64[0] = 0;
  unint64_t v24 = *(void *)(v11 + 136);
  *(void *)(v11 + 136) = a2[8].n128_u64[1];
  a2[8].n128_u64[1] = v24;
  unint64_t v25 = *(void *)(v11 + 152);
  *(void *)(v11 + 152) = a2[9].n128_u64[1];
  a2[9].n128_u64[1] = v25;
  ++a2[9].n128_u32[0];
  ++*(_DWORD *)(v11 + 144);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::importSceneWithUSDScene(uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v371 = *MEMORY[0x263EF8340];
  unint64_t v6 = re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v283, 2004, (uint64_t)a2);
  uint64_t v7 = (uint64_t *)(a1 + 8);
  if (*(void *)(a3 + 40)) {
    BOOL v8 = *(const char **)(a3 + 48);
  }
  else {
    BOOL v8 = (const char *)(a3 + 41);
  }
  uint64_t v227 = a1;
  unint64_t v9 = (char *)(a1 + 104);
  char v10 = *(unsigned char *)(a3 + 72);
  char v11 = *(unsigned char *)(a3 + 73);
  id v250 = *(id *)a3;
  id v12 = *(id *)(a3 + 8);
  id v251 = v12;
  __int16 v252 = *(_WORD *)(a3 + 16);
  char v253 = *(unsigned char *)(a3 + 18);
  if (*(unsigned char *)(a3 + 19)) {
    char v255 = *(unsigned char *)(a3 + 20);
  }
  uint64_t v224 = a3;
  uint64_t v256 = *(void *)(a3 + 24);
  id v257 = 0;
  memset(&v258[1], 0, 24);
  re::DynamicString::setCapacity(v258, 0);
  memset(&v258[4], 0, 3);
  id v259 = 0;
  __int16 v260 = 257;
  uint64_t v261 = v9;
  memset(v262, 0, sizeof(v262));
  int v263 = 0;
  uint64_t v264 = 0x7FFFFFFFLL;
  if (*v7)
  {
    if (*(_DWORD *)(v227 + 36) <= 3u) {
      signed int v13 = 3;
    }
    else {
      signed int v13 = *(_DWORD *)(v227 + 36);
    }
    re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v262, *v7, v13);
    re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy((uint64_t)v262, (uint64_t)v7);
  }
  char v265 = 0;
  char v266 = v10;
  char v267 = v11;
  int v268 = 1;
  memset(v269, 0, sizeof(v269));
  uint64_t v271 = 0x7FFFFFFFLL;
  memset(v272, 0, sizeof(v272));
  int v270 = 0;
  int v273 = 0;
  uint64_t v274 = 0x7FFFFFFFLL;
  long long v275 = 0u;
  long long v276 = 0u;
  unsigned int v277 = 0;
  uint64_t v278 = 0x7FFFFFFFLL;
  memset(v279, 0, sizeof(v279));
  int v280 = 0;
  uint64_t v281 = 0x7FFFFFFFLL;
  char v282 = 0;
  if (v8)
  {
    size_t v14 = strlen(v8);
    v312.n128_u64[0] = (unint64_t)v8;
    v312.n128_u64[1] = v14;
    re::DynamicString::operator=((re::DynamicString *)v258, (uint64_t)&v312);
  }
  *(void *)&long long __dst = *MEMORY[0x263F0F600];
  v312.n128_u64[0] = MEMORY[0x263EFFA80];
  unint64_t v15 = [NSDictionary dictionaryWithObjects:&v312 forKeys:&__dst count:1];
  id v16 = v259;
  id v259 = v15;

  LOBYTE(v258[4]) = *(unsigned char *)(a3 + 64);
  *(_WORD *)((char *)&v258[4] + 1) = *(_WORD *)(a3 + 65);
  BYTE1(v268) = *(unsigned char *)(a3 + 74);
  HIWORD(v268) = *(_WORD *)(a3 + 75);
  LOBYTE(v260) = *(unsigned char *)(a3 + 77);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v269, a3 + 88);
  char v265 = *(unsigned char *)(a3 + 79);
  char v282 = *(unsigned char *)(a3 + 80);
  LOBYTE(v268) = *(unsigned char *)(a3 + 81);
  unint64_t v17 = a2;
  id v18 = *a2;
  unint64_t v19 = [v18 metadata];
  unint64_t v20 = [v19 allKeys];
  if ([v20 containsObject:@"autoPlay"])
  {
    id v21 = *a2;
    unint64_t v22 = [v21 metadataWithKey:@"autoPlay"];

    if (!v22) {
      goto LABEL_18;
    }
    id v18 = *a2;
    unint64_t v19 = [v18 metadataWithKey:@"autoPlay"];
    *(unsigned char *)(v227 + 329) = [v19 BOOLValue];
  }
  else
  {
  }
  unint64_t v17 = a2;
LABEL_18:
  id v23 = *v17;
  unint64_t v24 = [v23 metadataWithKey:@"timeCodesPerSecond"];

  if (v24)
  {
    id v25 = *v17;
    float32x4_t v26 = [v25 metadataWithKey:@"timeCodesPerSecond"];
    [v26 doubleValue];
    double v28 = v27;

    if (v28 <= 0.0) {
      double v29 = 0.0416666667;
    }
    else {
      double v29 = 1.0 / v28;
    }
  }
  else
  {
    double v29 = 0.0416666667;
  }
  id v30 = *v17;
  float v31 = [v30 metadataWithKey:@"startTimeCode"];

  unint64_t v222 = v31;
  if (v31)
  {
    id v32 = *v17;
    float32x2_t v33 = [v32 metadataWithKey:@"startTimeCode"];
    [v33 floatValue];
    float v35 = v29 * v34;
    float v216 = v35;

    unsigned __int8 v221 = 1;
  }
  else
  {
    unsigned __int8 v221 = 0;
  }
  id v36 = *v17;
  float32x4_t v37 = [v36 metadataWithKey:@"endTimeCode"];

  unsigned int v220 = v37;
  if (v37)
  {
    id v38 = *v17;
    int32x2_t v39 = [v38 metadataWithKey:@"endTimeCode"];
    [v39 floatValue];
    float v3 = v29 * v40;

    unsigned __int8 v219 = 1;
  }
  else
  {
    unsigned __int8 v219 = 0;
  }
  id v41 = *v17;
  float32x4_t v42 = [v41 metadataWithKey:@"upAxis"];

  if (v42)
  {
    id v43 = *v17;
    uint64_t v44 = [v43 metadataWithKey:@"upAxis"];
    uint64_t v45 = [v44 stringValue];

    int v46 = [v45 isEqualToString:@"Z"];
    if (v46) {
      uint64_t v47 = 1065353216;
    }
    else {
      uint64_t v47 = 0;
    }
    if (v46) {
      uint64_t v48 = 0;
    }
    else {
      uint64_t v48 = 0x3F80000000000000;
    }

    *(void *)&long long v49 = v48;
    *((void *)&v49 + 1) = v47;
  }
  else
  {
    long long v49 = xmmword_23435FD60;
  }
  float32x4_t v223 = (float32x4_t)v49;
  uint64_t v248 = 0;
  unint64_t v246 = 0;
  uint64_t v244 = 0;
  unint64_t v245 = 0;
  int v247 = 0;
  id v50 = *v17;
  int32x4_t v51 = [v50 nodeIterator];
  uint64_t v52 = [v51 nextObject];
  if (v52)
  {
    float32x2_t v53 = (void *)v52;
    int v54 = 0;
    float v55 = 0;
    unint64_t v56 = 0;
    do
    {
      __int16 v57 = [v53 metadataWithKey:@"kind"];
      uint64_t v58 = [v57 stringValue];
      int v59 = [v58 isEqual:@"sceneLibrary"];

      if (v59)
      {
        uint64_t v60 = [v53 loadedChildIterator];
        uint64_t v61 = [v60 nextObject];
        while (v61)
        {
          if (v56 >= v245)
          {
            re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::growCapacity(&v244, v56 + 1);
            unint64_t v56 = v246;
            float v55 = v248;
          }
          id v62 = v61;
          v55[v56] = v62;
          unint64_t v56 = ++v246;
          int v54 = ++v247;
          uint64_t v61 = [v60 nextObject];
        }
      }
      uint64_t v63 = [v51 nextObject];

      float32x2_t v53 = (void *)v63;
    }
    while (v63);
    unint64_t v17 = a2;
    if (v56)
    {
      float v64 = v248;
      goto LABEL_54;
    }
  }
  else
  {
    int v54 = 0;
  }
  double v65 = [v50 rootNode];
  if (v245)
  {
    unint64_t v66 = 0;
  }
  else
  {
    re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::growCapacity(&v244, 1uLL);
    unint64_t v66 = v246;
    int v54 = v247;
  }
  float v64 = v248;
  id v67 = v65;
  v64[v66] = v67;
  unint64_t v56 = v66 + 1;
  unint64_t v246 = v66 + 1;
  int v247 = v54 + 1;

LABEL_54:
  if (v56)
  {
    uint64_t v217 = &v64[v56];
    float32x4_t v68 = vmulq_f32(v223, v223);
    v68.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).u32[0];
    float v69 = fabsf(v68.f32[0]);
    float32x2_t v70 = vrsqrte_f32((float32x2_t)v68.u32[0]);
    float32x2_t v71 = vmul_f32(v70, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v70, v70)));
    float32x4_t v215 = vmulq_n_f32(v223, vmul_f32(v71, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v71, v71))).f32[0]);
    float32x2_t v72 = vrsqrte_f32((float32x2_t)1065353216);
    float32x2_t v73 = vmul_f32(v72, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v72, v72)));
    float32x4_t v225 = vmulq_n_f32((float32x4_t)xmmword_23435FD60, vmul_f32(v73, vrsqrts_f32((float32x2_t)1065353216, vmul_f32(v73, v73))).f32[0]);
    float32x4_t v214 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v225, (int32x4_t)v225), (int8x16_t)v225, 0xCuLL);
    uint64_t v218 = *MEMORY[0x263F83FC0];
    while (1)
    {
      id v74 = *v64;
      re::ImportedScene::ImportedScene((re::ImportedScene *)&v312);
      re::DynamicArray<re::ImportedScene>::add(v227 + 288, &v312);
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v320);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v318);
      if ((void)v316)
      {
        if (BYTE8(v316)) {
          (*(void (**)(void))(*(void *)v316 + 40))();
        }
        long long v316 = 0u;
        long long v317 = 0u;
      }
      if (v313 && (v314 & 1) != 0) {
        (*(void (**)(void))(*(void *)v313 + 40))();
      }
      uint64_t v75 = v17;
      uint64_t v233 = *(void *)(v227 + 320);
      uint64_t v76 = *(void *)(v227 + 304);
      id v77 = [v74 metadataWithKey:@"sceneName"];
      if (!v77)
      {
        id v77 = [v74 customMetadataWithKey:@"sceneName"];
      }
      uint64_t v78 = v76 - 1;
      id v79 = [v77 stringValue];
      uint64_t v80 = [v79 UTF8String];

      if (v80)
      {
        id v81 = [v77 stringValue];
        uint64_t v82 = (const char *)[v81 UTF8String];
        size_t v83 = strlen(v82);
        v312.n128_u64[0] = (unint64_t)v82;
        v312.n128_u64[1] = v83;
        re::DynamicString::operator=((re::DynamicString *)(v233 + 160 * v78 + 16), (uint64_t)&v312);
      }
      char isRootNodeByPath = re::isRootNodeByPath(v74);
      uint64_t v85 = [v74 specifier];
      uint64_t v86 = v233 + 160 * v78;
      *(unsigned char *)(v86 + 88) = [v85 isEqual:v218];
      uint64_t v87 = (unsigned char *)(v86 + 88);

      int v232 = v64;
      if (isRootNodeByPath) {
        *uint64_t v87 = 1;
      }
      else {
        std::string::size_type v88 = (re *)[v74 setSpecifier:v218];
      }
      unint64_t v89 = re::globalAllocators(v88);
      uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v89[2] + 32))(v89[2], 40, 8);
      *(_OWORD *)uint64_t v90 = 0u;
      *(_OWORD *)(v90 + 16) = 0u;
      *(void *)(v90 + 32) = 0;
      uint64_t v237 = v90;
      *(void *)(v233 + 160 * v78 + 48) = v90;
      id v91 = *v75;
      size_t v92 = *(unsigned __int8 *)(v224 + 67);
      int32x2_t v243 = *(int32x2_t *)(v224 + 68);
      char v93 = BYTE2(*(_DWORD *)(v224 + 76));
      id v94 = v91;
      id v95 = v74;
      uint64_t v230 = v78;
      if (v92)
      {
        HIBYTE(v260) = 0;
        float32x4_t v96 = re::USDImportContext::USDImportContext((re::USDImportContext *)&v312);
        v286[0] = v221;
        if (v222) {
          float v287 = v216;
        }
        v284[0] = v219;
        if (v220) {
          float v285 = v3;
        }
        unint64_t v97 = re::USDImportContext::pushNodeLevel((re::USDImportContext *)&v312, "", "", "", 0);
      }
      else
      {
        float v98 = re::USDImportContext::USDImportContext((re::USDImportContext *)&v312);
        v286[0] = v221;
        if (v222) {
          float v287 = v216;
        }
        v284[0] = v219;
        if (v220) {
          float v285 = v3;
        }
        uint64_t v85 = [v95 name];
        id v99 = [v85 stringValue];
        float32x2_t v100 = (const char *)[v99 UTF8String];
        float32x2_t v101 = [v95 path];
        id v102 = [v101 stringValue];
        unint64_t v97 = re::USDImportContext::pushNodeLevel((re::USDImportContext *)&v312, v100, "(default)", (const char *)[v102 UTF8String], 1);
      }
      float32x4_t v103 = v223;
      float32x4_t v104 = v223;
      if (v69 >= 1.0e-10)
      {
        float32x4_t v103 = v215;
        float32x4_t v104 = v215;
      }
      float32x4_t v105 = vmulq_f32(v103, v225);
      int32x2_t v106 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 2), vaddq_f32(v105, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.f32, 1))).u64[0];
      if (*(float *)v106.i32 == -1.0
        || (float v107 = (float)((float)(fabsf(*(float *)v106.i32) + 1.0) + 1.0) * 0.00001,
            *(float *)v106.i32 = *(float *)v106.i32 + 1.0,
            fabsf(*(float *)v106.i32) < v107))
      {
        if (fabsf(v103.f32[2]) >= 0.00001)
        {
          v108.i32[0] = 0;
          v108.f32[1] = -v103.f32[2];
          v108.i64[1] = v103.u32[1];
        }
        else
        {
          float32x4_t v108 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v103.f32[1]), (int32x4_t)v103);
        }
        int32x4_t v109 = (int32x4_t)vmulq_f32(v108, v108);
        v109.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v109, 2), vadd_f32(*(float32x2_t *)v109.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v109.i8, 1))).u32[0];
        float32x2_t v110 = vrsqrte_f32((float32x2_t)v109.u32[0]);
        float32x2_t v111 = vmul_f32(v110, vrsqrts_f32((float32x2_t)v109.u32[0], vmul_f32(v110, v110)));
        float32x4_t v112 = vmulq_n_f32(v108, vmul_f32(v111, vrsqrts_f32((float32x2_t)v109.u32[0], vmul_f32(v111, v111))).f32[0]);
        float v113 = 0.0;
      }
      else
      {
        int8x16_t v192 = (int8x16_t)vmlaq_f32(vmulq_f32(v214, vnegq_f32(v104)), v225, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
        *(float *)v106.i32 = sqrtf(*(float *)v106.i32 + *(float *)v106.i32);
        float v113 = *(float *)v106.i32 * 0.5;
        float32x4_t v112 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v192, (int32x4_t)v192), v192, 0xCuLL), (float32x4_t)vdupq_lane_s32(v106, 0));
      }
      long long v231 = v77;
      v112.f32[3] = v113;
      float32x4_t v241 = v112;
      uint64_t v114 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v331, *(void *)(v344 + 8 * v342 - 8));
      *(int32x4_t *)(v114 + 432) = vdupq_lane_s32(v243, 0);
      *(float32x4_t *)(v114 + 448) = v241;
      *(void *)(v114 + 464) = 0;
      *(void *)(v114 + 472) = 0;
      id v115 = v94;
      id v116 = v95;
      re::loadUSKSkeletalAnimationNodes(v116, (uint64_t)&v312);
      re::loadUSKSkeletonNodes(v116, (uint64_t)&v312);
      re::loadUSKBlendShapeNodes(v116, (uint64_t)&v312);
      re::loadTransformAndMeshNodes(v115, v116, (re::USDImportContext *)&v312, 1);
      re::loadUSKDeformerStackNodes(v115, v116, (uint64_t)&v312);
      long long v228 = v115;

      re::loadUSKPhysicsNodes(v116, (uint64_t)&v312);
      int v229 = v116;

      --v342;
      ++v343;
      if (!v92)
      {
        while (v97 < v333)
          uint64_t v117 = (_anonymous_namespace_ *)re::USDImportContext::setNodeAsEntity((re::USDImportContext *)&v312, v97++);
      }
      uint64_t v118 = v318;
      if (v318 && *(unsigned char *)(v315 + 96))
      {
        unint64_t v119 = 0;
        do
        {
          uint64_t v120 = (const StringID *)re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)&v316, v119);
          uint64_t v85 = v261;
          uint64_t v121 = *(const char **)(re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)&v316, v119)+ 8);
          uint64_t v122 = (re *)strlen(v121);
          float v123 = re::globalAllocators(v122);
          size_t v92 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v123[2] + 32))(v123[2], 248, 8);
          re::StringID::StringID((re::StringID *)&__dst, v120 + 1);
          re::FixedArray<re::StringID>::FixedArray((unint64_t *)&v355, (uint64_t)&v120[2]);
          re::FixedArray<unsigned int>::FixedArray((uint64_t *)&v356 + 1, (uint64_t)&v120[3].var1);
          re::FixedArray<re::GenericSRT<float>>::FixedArray(&v358, (uint64_t)&v120[5]);
          re::SkeletonAsset::SkeletonAsset(v92, (uint64_t *)&__dst);
          id v125 = re::SkeletonAsset::assetType(v124);
          re::ImportAssetTable::addAsset((_anonymous_namespace_ *)v85, (uint64_t)v121, (uint64_t)v122, (void *)v92, (re **)v125);
          if ((void)v358)
          {
            if (*((void *)&v358 + 1))
            {
              (*(void (**)(void))(*(void *)v358 + 40))();
              *((void *)&v358 + 1) = 0;
              *(void *)&long long v359 = 0;
            }
            *(void *)&long long v358 = 0;
          }
          if (*((void *)&v356 + 1))
          {
            if ((void)v357)
            {
              (*(void (**)(void))(**((void **)&v356 + 1) + 40))();
              long long v357 = 0uLL;
            }
            *((void *)&v356 + 1) = 0;
          }
          re::FixedArray<re::StringID>::deinit(&v355);
          re::StringID::destroyString((re::StringID *)&__dst);
          ++v119;
        }
        while (v118 != v119);
      }
      uint64_t v126 = v336;
      int v309 = 0;
      uint64_t v308 = 0;
      uint64_t v310 = 0;
      unsigned int v306 = 0;
      long long v304 = 0u;
      long long v305 = 0u;
      uint64_t v307 = 0x7FFFFFFFLL;
      unint64_t v128 = (const char *)v331;
      if (v126) {
        break;
      }
LABEL_162:
      uint64_t v153 = *(void *)(v237 + 16);
      if (v153)
      {
        uint64_t v154 = *(void *)(v237 + 32);
        uint64_t v155 = 112 * v153;
        do
        {
          re::addPhysicsFromImportContext((uint64_t)&v312, (uint64_t)&v249, v154);
          v154 += 112;
          v155 -= 112;
        }
        while (v155);
      }
      v156.n128_f64[0] = re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v304);
      if (v308) {
        BOOL v157 = v309 == 0;
      }
      else {
        BOOL v157 = 1;
      }
      if (!v157) {
        (*(void (**)(__n128))(*(void *)v308 + 40))(v156);
      }
      if (v333)
      {
        for (unint64_t i = 0; i < v333; ++i)
        {
          char v159 = (_anonymous_namespace_ *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v331, i);
          if (*((void *)v159 + 20) != -1)
          {
            char v160 = v159;
            char v161 = (const char *)*((void *)v159 + 6);
            v346[0] = *((const char **)v160 + 4);
            re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(v227 + 56, (re::DynamicString *)&__dst, v346);
            if ((void)__dst)
            {
              if (BYTE8(__dst)) {
                (*(void (**)(void))(*(void *)__dst + 40))();
              }
            }
          }
        }
      }
      re::USDImportContext::deinit((re::USDImportContext *)&v312);
      v162.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v345);
      if (v340)
      {
        if (v344) {
          (*(void (**)(double))(*(void *)v340 + 40))(v162.n128_f64[0]);
        }
        uint64_t v344 = 0;
        uint64_t v341 = 0;
        uint64_t v342 = 0;
        uint64_t v340 = 0;
        ++v343;
      }
      if ((void)v338)
      {
        if (BYTE8(v338)) {
          (*(void (**)(__n128))(*(void *)v338 + 40))(v162);
        }
        long long v338 = 0u;
        long long v339 = 0u;
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v337);
      re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v334);
      if (v334[0])
      {
        int v163 = v335;
        if ((v335 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v334[0] + 40))();
          int v163 = v335;
        }
        v334[0] = 0;
        v334[1] = 0;
        int v335 = (v163 | 1) + 2;
      }
      re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::deinit((uint64_t)v331);
      if (v331[0])
      {
        int v164 = v332;
        if ((v332 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v331[0] + 40))();
          int v164 = v332;
        }
        v331[0] = 0;
        v331[1] = 0;
        int v332 = (v164 | 1) + 2;
      }
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v330);
      re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)v328);
      if (v328[0])
      {
        int v165 = v329;
        if ((v329 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v328[0] + 40))();
          int v165 = v329;
        }
        v328[0] = 0;
        v328[1] = 0;
        int v329 = (v165 | 1) + 2;
      }
      re::USDImportContext::PhysicsColliderTable::~PhysicsColliderTable((re::USDImportContext::PhysicsColliderTable *)&v327);
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v326);
      re::BucketArray<re::USDImportContextBlendShapeData,8ul>::deinit((uint64_t)v324);
      if (v324[0])
      {
        int v166 = v325;
        if ((v325 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v324[0] + 40))();
          int v166 = v325;
        }
        v324[0] = 0;
        v324[1] = 0;
        int v325 = (v166 | 1) + 2;
      }
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v323);
      re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::deinit((uint64_t)v321);
      if (v321[0])
      {
        int v167 = v322;
        if ((v322 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v321[0] + 40))();
          int v167 = v322;
        }
        v321[0] = 0;
        v321[1] = 0;
        int v322 = (v167 | 1) + 2;
      }
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(&v319);
      re::BucketArray<re::USDImportContextSkeletonData,4ul>::deinit((uint64_t)&v316);
      if ((void)v316 && (v317 & 1) == 0) {
        (*(void (**)(void))(*(void *)v316 + 40))();
      }

      uint64_t v168 = [v229 path];
      id v169 = [v168 stringValue];
      int v170 = (const char *)[v169 UTF8String];
      size_t v171 = strlen(v170);
      v312.n128_u64[0] = (unint64_t)v170;
      v312.n128_u64[1] = v171;
      re::DynamicString::operator=((re::DynamicString *)(v233 + 160 * v230 + 56), (uint64_t)&v312);

      float v64 = v232 + 1;
      unint64_t v17 = a2;
      if (v232 + 1 == v217) {
        goto LABEL_259;
      }
    }
    for (unsigned int j = 0; j != (const char *)v126; ++j)
    {
      size_t v130 = (size_t)v309;
      if (v309 <= j)
      {
        uint64_t p_dst = 0;
        long long v357 = 0u;
        long long v358 = 0u;
        long long v355 = 0u;
        long long v356 = 0u;
        long long __dst = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v346[0]) = 136315906;
        *(const char **)((char *)v346 + 4) = "operator[]";
        WORD2(v346[1]) = 1024;
        *(_DWORD *)((char *)&v346[1] + 6) = 468;
        WORD1(v346[2]) = 2048;
        *(const char **)((char *)&v346[2] + 4) = j;
        WORD2(v346[3]) = 2048;
        *(const char **)((char *)&v346[3] + 6) = (const char *)v130;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_293:
        uint64_t p_dst = 0;
        size_t v130 = (size_t)v346;
        long long v357 = 0u;
        long long v358 = 0u;
        long long v355 = 0u;
        long long v356 = 0u;
        long long __dst = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v346[0]) = 136315906;
        *(const char **)((char *)v346 + 4) = "operator[]";
        WORD2(v346[1]) = 1024;
        *(_DWORD *)((char *)&v346[1] + 6) = 789;
        WORD1(v346[2]) = 2048;
        *(const char **)((char *)&v346[2] + 4) = v128;
        WORD2(v346[3]) = 2048;
        *(const char **)((char *)&v346[3] + 6) = j;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_294;
      }
      if (!j[v310])
      {
        uint64_t v131 = (unint64_t *)re::BucketArray<unsigned long,32ul>::operator[]((uint64_t)v334, (unint64_t)j);
        long long v132 = v261;
        long long v133 = (const char *)v312.n128_u64[1];
        int v134 = *(const char **)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v331, *v131)+ 32);
        size_t v92 = strlen(v134);
        *(void *)&long long __dst = v134;
        *((void *)&__dst + 1) = v92;
        v346[0] = v132;
        memset(&v346[2], 0, 24);
        if (v92) {
          size_t v135 = v92 + 1;
        }
        else {
          size_t v135 = 0;
        }
        re::DynamicString::setCapacity(&v346[1], v135);
        re::DynamicString::operator=((re::DynamicString *)&v346[1], (uint64_t)&__dst);
        v346[5] = v133;
        *((void *)&v347 + 1) = 0;
        *(void *)&long long v348 = 0;
        LODWORD(v34re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = -8388609;
        DWORD2(v348) = 1;
        *(void *)&long long v350 = 0;
        long long v349 = 0uLL;
        DWORD2(v350) = 0;
        uint64_t p_dst = 0;
        uint64_t v296 = (uint64_t)"";
        uint64_t v301 = 0;
        uint64_t v298 = 0;
        uint64_t v299 = 0;
        uint64_t v297 = 0;
        int v300 = 0;
        char v302 = 0;
        memset(v303, 0, sizeof(v303));
        unint64_t v289 = 0;
        uint64_t v288 = 0;
        LODWORD(v290) = 1;
        uint64_t v292 = 0;
        unsigned int v293 = 0;
        uint64_t v291 = 0;
        int v294 = 0;
        *(void *)re::BucketArray<re::TimelineGroupBuilder *,8ul>::addUninitialized((uint64_t)&v288) = v346;
        re::createEntityFromImportContext((_anonymous_namespace_ *)&__dst, (unint64_t)&v312, (uint64_t)&v249, (unint64_t)j, (uint64_t)&v288, (uint64_t)&p_dst, (uint64_t)&v308, (const char *)&v304, 1);
        if ((_BYTE)__dst)
        {
          re::DynamicArray<re::ecs2::EntityAssetData>::add(v237, (uint64_t)&__dst + 8);
          if ((_BYTE)__dst) {
            re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)((char *)&__dst + 8));
          }
        }
        size_t v130 = (size_t)v293;
        if (v293)
        {
          uint64_t v85 = 0;
          do
            re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[]((uint64_t)&v288, (unint64_t)v85++);
          while ((char *)v130 != v85);
        }
        while (v289)
          re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)&v288);
        if (v288 && (v290 & 1) == 0) {
          (*(void (**)(void))(*v288 + 40))();
        }
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v303);
        re::DynamicArray<re::AnimationSceneEntityData>::deinit((uint64_t)&v297);
        re::StringID::destroyString((re::StringID *)&p_dst);
        re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::deinit((uint64_t)&v347 + 8);
        if (*((void *)&v347 + 1))
        {
          int v136 = DWORD2(v348);
          if ((BYTE8(v348) & 1) == 0)
          {
            (*(void (**)(void))(**((void **)&v347 + 1) + 40))();
            int v136 = DWORD2(v348);
          }
          *((void *)&v347 + 1) = 0;
          *(void *)&long long v348 = 0;
          DWORD2(v348) = (v136 | 1) + 2;
        }
        int8x16_t v127 = (re::MeshDeformationAsset *)v346[1];
        if (v346[1] && ((uint64_t)v346[2] & 1) != 0) {
          int8x16_t v127 = (re::MeshDeformationAsset *)(*(uint64_t (**)(void))(*(void *)v346[1] + 40))();
        }
      }
    }
    if (!HIDWORD(v305)) {
      goto LABEL_162;
    }
    int32x2_t v137 = v261;
    int32x2_t v138 = re::MeshDeformationAsset::assetType(v127);
    uint64_t v139 = *(uint64_t **)v137;
    unint64_t v289 = 0;
    unint64_t v290 = 0;
    LODWORD(v291) = 0;
    uint64_t v292 = 0;
    uint64_t v288 = v139;
    re::DynamicArray<float *>::setCapacity(&v288, 0);
    int v141 = v291 + 1;
    LODWORD(v291) = v291 + 1;
    uint64_t v142 = *((void *)v137 + 5);
    if (v142)
    {
      size_t v92 = 0;
      while (1)
      {
        size_t v143 = *((void *)v137 + 5);
        if (v143 <= v92) {
          break;
        }
        size_t v130 = v92 >> 5;
        uint64_t v85 = (char *)*((void *)v137 + 1);
        if ((unint64_t)v85 <= v92 >> 5) {
          goto LABEL_295;
        }
        id v144 = v137 + 24;
        if ((v137[16] & 1) == 0) {
          id v144 = (char *)*((void *)v137 + 4);
        }
        uint64_t v85 = (char *)(*(void *)&v144[8 * v130] + 48 * (v92 & 0x1F));
        size_t v130 = v138[1];
        size_t v145 = strlen((const char *)v130);
        __int16 v146 = re::DynamicString::find((re::DynamicString *)v85, (char *)v130, v145, 0, (uint64_t)&__dst);
        if ((_BYTE)__dst)
        {
          unint64_t v147 = v290;
          if (v290 >= v289)
          {
            unint64_t v148 = v290 + 1;
            if (v289 < v290 + 1)
            {
              if (v288)
              {
                unint64_t v149 = 2 * v289;
                if (!v289) {
                  unint64_t v149 = 8;
                }
                if (v149 <= v148) {
                  unint64_t v150 = v290 + 1;
                }
                else {
                  unint64_t v150 = v149;
                }
                re::DynamicArray<float *>::setCapacity(&v288, v150);
                int v141 = v291;
              }
              else
              {
                re::DynamicArray<float *>::setCapacity(&v288, v148);
                int v141 = v291 + 1;
              }
            }
            unint64_t v147 = v290;
          }
          *(void *)(v292 + 8 * v14re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v85;
          unint64_t v290 = v147 + 1;
          LODWORD(v291) = ++v141;
        }
        if (v142 == ++v92) {
          goto LABEL_153;
        }
      }
LABEL_294:
      re::internal::assertLog((re::internal *)6, v140, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, v92, v143);
      _os_crash();
      __break(1u);
LABEL_295:
      uint64_t p_dst = 0;
      long long v357 = 0u;
      long long v358 = 0u;
      long long v355 = 0u;
      long long v356 = 0u;
      long long __dst = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v346[0]) = 136315906;
      *(const char **)((char *)v346 + 4) = "operator[]";
      WORD2(v346[1]) = 1024;
      *(_DWORD *)((char *)&v346[1] + 6) = 866;
      WORD1(v346[2]) = 2048;
      *(const char **)((char *)&v346[2] + 4) = (const char *)v130;
      WORD2(v346[3]) = 2048;
      *(const char **)((char *)&v346[3] + 6) = v85;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_153:
    unsigned int v238 = v306;
    size_t v92 = 0;
    if (v306)
    {
      id v151 = (int *)v305;
      do
      {
        int v152 = *v151;
        v151 += 14;
        if (v152 < 0) {
          goto LABEL_158;
        }
        ++v92;
      }
      while (v306 != v92);
      size_t v92 = v306;
    }
LABEL_158:
    if (v306 == v92) {
      goto LABEL_159;
    }
    size_t v172 = v92;
    uint64_t v173 = v305;
    uint64_t v235 = v292;
    unint64_t v236 = v290;
    uint64_t v234 = v292 + 8 * v290;
LABEL_211:
    if (!v236) {
      goto LABEL_244;
    }
    uint64_t v174 = v173 + 56 * v172;
    uint64_t v85 = (char *)(v174 + 40);
    uint64_t v239 = (unsigned char **)(v174 + 48);
    uint64_t v175 = v235;
    while (1)
    {
      uint64_t v176 = *(void **)(*(void *)v175 + 40);
      uint64_t v177 = v176[7];
      if (v177) {
        break;
      }
LABEL_231:
      v175 += 8;
      if (v175 == v234) {
        goto LABEL_244;
      }
    }
    uint64_t v178 = v176[9];
    uint64_t v242 = v178 + 48 * v177;
    while (1)
    {
      if (!re::StringID::operator==((void *)(v178 + 8), (void *)(v173 + 56 * v172 + 8))) {
        goto LABEL_230;
      }
      unint64_t v128 = *(const char **)(v178 + 40);
      unsigned int j = (const char *)v176[2];
      if (j <= v128) {
        goto LABEL_293;
      }
      int v179 = (_anonymous_namespace_ *)(v176[4] + 40 * (void)v128);
      if (*(void *)v85 >= 0xFFFFFFFFFFFFFFFELL && (*(void *)v85 & 1) == 0)
      {
        uint64_t v181 = *v239;
      }
      else
      {
        if (*(void *)v85 > 1uLL) {
          goto LABEL_226;
        }
        uint64_t v181 = *v239;
        if (!*v239) {
          goto LABEL_226;
        }
      }
      if (!*v181)
      {
        long long v368 = 0u;
        long long v369 = 0u;
        long long v366 = 0u;
        long long v367 = 0u;
        long long v364 = 0u;
        long long v365 = 0u;
        long long v362 = 0u;
        long long v363 = 0u;
        long long v360 = 0u;
        long long v361 = 0u;
        long long v358 = 0u;
        long long v359 = 0u;
        long long v356 = 0u;
        long long v357 = 0u;
        long long __dst = 0u;
        long long v355 = 0u;
        char v370 = -1;
        long long v191 = (_anonymous_namespace_ *)strlcpy((char *)&__dst, *(const char **)(v173 + 56 * v172 + 16), 0x80uLL);
        v346[0] = (const char *)0x4425D6C2BB3546C6;
        v346[1] = "FenceDeformer";
        uint64_t p_dst = (uint64_t)&__dst;
        uint64_t v296 = 257;
        memset(&v346[2], 0, 24);
        re::FixedArray<unsigned char>::copy(&v346[2], (const void **)&p_dst);
        re::DynamicArray<re::DeformationDefinition>::add(v179, (uint64_t *)v346);
        if (v346[2])
        {
          if (v346[3])
          {
            (*(void (**)(void))(*(void *)v346[2] + 40))();
            v346[3] = 0;
            v346[4] = 0;
          }
          v346[2] = 0;
        }
        p_uint64_t p_dst = (re::StringID *)v346;
        goto LABEL_243;
      }
LABEL_226:
      long long v240 = v179;
      unint64_t v182 = *((void *)v179 + 2);
      if (v182)
      {
        unint64_t v183 = 0;
        uint64_t v184 = *((void *)v179 + 4);
        unsigned int v185 = 2;
        while (!re::StringID::operator==((void *)(v184 + 40 * v183), v85))
        {
          unint64_t v183 = v185++ - 1;
          if (v182 <= v183) {
            goto LABEL_230;
          }
        }
        long long v368 = 0u;
        long long v369 = 0u;
        long long v366 = 0u;
        long long v367 = 0u;
        long long v364 = 0u;
        long long v365 = 0u;
        long long v362 = 0u;
        long long v363 = 0u;
        long long v360 = 0u;
        long long v361 = 0u;
        long long v358 = 0u;
        long long v359 = 0u;
        long long v356 = 0u;
        long long v357 = 0u;
        long long __dst = 0u;
        long long v355 = 0u;
        char v370 = -1;
        float v186 = (_anonymous_namespace_ *)strlcpy((char *)&__dst, *(const char **)(v173 + 56 * v172 + 16), 0x80uLL);
        v346[0] = (const char *)0x4425D6C2BB3546C6;
        v346[1] = "FenceDeformer";
        uint64_t p_dst = (uint64_t)&__dst;
        uint64_t v296 = 257;
        memset(&v346[2], 0, 24);
        re::FixedArray<unsigned char>::copy(&v346[2], (const void **)&p_dst);
        re::DynamicArray<re::DeformationDefinition>::insert(v240, v185 - 1, (uint64_t *)v346);
        if (v346[2])
        {
          if (v346[3])
          {
            (*(void (**)(void))(*(void *)v346[2] + 40))();
            v346[3] = 0;
            v346[4] = 0;
          }
          v346[2] = 0;
        }
        re::StringID::destroyString((re::StringID *)v346);
        if (*((void *)v240 + 2) > (unint64_t)v185)
        {
          memset(v352, 0, sizeof(v352));
          long long v350 = 0u;
          long long v351 = 0u;
          long long v348 = 0u;
          long long v349 = 0u;
          long long v347 = 0u;
          memset(v346, 0, sizeof(v346));
          char v353 = -1;
          int v187 = (_anonymous_namespace_ *)strlcpy(v352, *(const char **)(v173 + 56 * v172 + 32), 0x80uLL);
          char v353 = 14;
          uint64_t p_dst = 0x4425D6C2BB3546C6;
          uint64_t v296 = (uint64_t)"FenceDeformer";
          v311[0] = v346;
          v311[1] = (const void *)257;
          uint64_t v298 = 0;
          uint64_t v299 = 0;
          uint64_t v297 = 0;
          re::FixedArray<unsigned char>::copy(&v297, v311);
          re::DynamicArray<re::DeformationDefinition>::insert(v240, v185, &p_dst);
          if (v297)
          {
            if (v298)
            {
              (*(void (**)(void))(*(void *)v297 + 40))();
              uint64_t v298 = 0;
              uint64_t v299 = 0;
            }
            uint64_t v297 = 0;
          }
          p_uint64_t p_dst = (re::StringID *)&p_dst;
LABEL_243:
          re::StringID::destroyString(p_p_dst);
        }
LABEL_244:
        uint64_t v173 = v305;
        if (v306 <= (int)v92 + 1) {
          size_t v189 = (v92 + 1);
        }
        else {
          size_t v189 = v306;
        }
        while (1)
        {
          size_t v172 = (v92 + 1);
          if (v189 - 1 == v92) {
            break;
          }
          LODWORD(v92) = v92 + 1;
          size_t v190 = v172;
          if ((*(_DWORD *)(v305 + 56 * v172) & 0x80000000) != 0) {
            goto LABEL_251;
          }
        }
        size_t v190 = v189;
LABEL_251:
        size_t v92 = v190;
        if (v238 == v190)
        {
LABEL_159:
          if (v288 && v292) {
            (*(void (**)(void))(*v288 + 40))();
          }
          goto LABEL_162;
        }
        goto LABEL_211;
      }
LABEL_230:
      v178 += 48;
      if (v178 == v242) {
        goto LABEL_231;
      }
    }
  }
LABEL_259:
  int v193 = [MEMORY[0x263EFF9A0] dictionaryWithCapacity:HIDWORD(v276)];
  unsigned int v194 = v277;
  if (v277)
  {
    uint64_t v195 = 0;
    uint64_t v196 = (int *)(v276 + 8);
    while (1)
    {
      int v197 = *v196;
      v196 += 20;
      if (v197 < 0) {
        break;
      }
      if (v277 == ++v195)
      {
        LODWORD(v195) = v277;
        break;
      }
    }
  }
  else
  {
    LODWORD(v195) = 0;
  }
  if (v277 != v195)
  {
    uint64_t v198 = v195;
    uint64_t v199 = v276;
    do
    {
      uint64_t v200 = v199 + 80 * v198;
      if (*(unsigned char *)(v200 + 56)) {
        uint64_t v201 = *(void *)(v199 + 80 * v198 + 64);
      }
      else {
        uint64_t v201 = v199 + 80 * v198 + 57;
      }
      uint64_t v202 = [NSString stringWithUTF8String:v201];
      if (*(unsigned char *)(v199 + 80 * v198 + 24)) {
        uint64_t v203 = *(void *)(v199 + 80 * v198 + 32);
      }
      else {
        uint64_t v203 = v200 + 25;
      }
      uint64_t v204 = [NSString stringWithUTF8String:v203];
      [v193 setObject:v202 forKeyedSubscript:v204];

      uint64_t v199 = v276;
      if (v277 <= (int)v195 + 1) {
        unsigned int v205 = v195 + 1;
      }
      else {
        unsigned int v205 = v277;
      }
      while (1)
      {
        uint64_t v198 = (v195 + 1);
        if (v205 - 1 == v195) {
          break;
        }
        LODWORD(v195) = v195 + 1;
        unsigned int v206 = v198;
        if ((*(_DWORD *)(v276 + 80 * v198 + 8) & 0x80000000) != 0) {
          goto LABEL_280;
        }
      }
      unsigned int v206 = v205;
LABEL_280:
      LODWORD(v195) = v206;
    }
    while (v194 != v206);
  }
  uint64_t v207 = (void *)[v193 copy];
  re::ObjCObject::operator=((void **)(v227 + 336), v207);

  uint64_t v208 = v244;
  if (v244)
  {
    uint64_t v209 = v248;
    if (v248)
    {
      if (v246)
      {
        uint64_t v210 = 8 * v246;
        uint64_t v211 = v248;
        do
        {
          uint64_t v212 = *v211++;

          v210 -= 8;
        }
        while (v210);
      }
      (*(void (**)(uint64_t, id *))(*(void *)v208 + 40))(v208, v209);
    }
  }
  re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v279);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v275);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v272);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v269);
  re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v262);

  if (v258[0])
  {
    if (v258[1]) {
      (*(void (**)(void))(*(void *)v258[0] + 40))();
    }
    memset(v258, 0, 32);
  }

  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v283);
  return 1;
}

uint64_t re::buildTexturesTable(uint64_t a1, id *a2, uint64_t a3, uint64_t *a4)
{
  v155[4] = *MEMORY[0x263EF8340];
  uint64_t v144 = 0;
  unint64_t v141 = 0;
  unint64_t v142 = 0;
  int v143 = 0;
  uint64_t v140 = a4;
  re::DynamicArray<re::ImportedTexturesTable::Entry>::setCapacity(&v140, 0);
  ++v143;
  int32x4_t v109 = [*a2 loadedNodeIterator];
  uint64_t v5 = [v109 nextObject];
  if (v5)
  {
    unint64_t v6 = (void *)v5;
    uint64_t v7 = *MEMORY[0x263F83FF0];
    uint64_t v106 = *MEMORY[0x263F83FF0];
    do
    {
      BOOL v8 = [v6 type];
      int v9 = [v8 isEqualToString:v7];

      if (v9)
      {
        float32x4_t v108 = v6;
        re::gatherMaterialTextureProperties((uint64_t)v6, (uint64_t)&v129);
        int v10 = HIDWORD(v132);
        if (HIDWORD(v132))
        {
          uint64_t v11 = 0;
          id v12 = (int *)(*((void *)&v130 + 1) + 8);
          while (1)
          {
            int v13 = *v12;
            v12 += 14;
            if (v13 < 0) {
              break;
            }
            if (HIDWORD(v132) == ++v11)
            {
              LODWORD(v11) = HIDWORD(v132);
              break;
            }
          }
        }
        else
        {
          LODWORD(v11) = 0;
        }
        if (HIDWORD(v132) != v11)
        {
          uint64_t v14 = v11;
          uint64_t v15 = *((void *)&v130 + 1);
          int v110 = HIDWORD(v132);
          while (1)
          {
            uint64_t v16 = v15 + 56 * v14;
            id v17 = *(id *)(v16 + 48);
            id ResourcePathAndColorSpaceForTextureProperty = re::getResourcePathAndColorSpaceForTextureProperty(v17);
            unint64_t v20 = ResourcePathAndColorSpaceForTextureProperty;
            if (ResourcePathAndColorSpaceForTextureProperty) {
              break;
            }
LABEL_124:

            uint64_t v15 = *((void *)&v130 + 1);
            if (HIDWORD(v132) <= (v11 + 1)) {
              int v81 = v11 + 1;
            }
            else {
              int v81 = HIDWORD(v132);
            }
            while (1)
            {
              uint64_t v14 = (v11 + 1);
              if (v81 - 1 == v11) {
                break;
              }
              LODWORD(v11) = v11 + 1;
              int v82 = v14;
              if ((*(_DWORD *)(*((void *)&v130 + 1) + 56 * v14 + 8) & 0x80000000) != 0) {
                goto LABEL_131;
              }
            }
            int v82 = v81;
LABEL_131:
            LODWORD(v11) = v82;
            if (v10 == v82) {
              goto LABEL_132;
            }
          }
          uint64_t v21 = v19;
          unint64_t v22 = [ResourcePathAndColorSpaceForTextureProperty path];
          id v23 = [v20 resolvedPath];
          unint64_t v24 = v23;
          if (v23 && (id v23 = (re *)[(re *)v23 length]) != 0)
          {
            uint64_t v125 = v21;
            uint64_t v25 = v16 + 16;
            float32x4_t v26 = (const char *)(v16 + 25);
            if (*(void *)(v16 + 24)) {
              double v27 = *(const char **)(v16 + 32);
            }
            else {
              double v27 = (const char *)(v16 + 25);
            }
            int v111 = strcmp(v27, "textureRMAS");
            int8x16_t v127 = v24;
            if (v111)
            {
              if (!strcmp(v27, "textureBaseColor") && v136 | BYTE1(v136))
              {
                int v112 = 0;
                int v118 = 5;
                int v120 = 4;
                int v122 = 3;
                int v33 = 2;
              }
              else
              {
                double v29 = [v17 name];
                id v30 = [v29 stringValue];

                unsigned int v32 = re::swizzleForTextureOutputProperty(v30, v31);
                int v122 = BYTE1(v32);
                int v33 = v32;
                int v120 = BYTE2(v32);
                int v118 = HIBYTE(v32);

                int v112 = 1;
              }
              goto LABEL_49;
            }
            id v116 = v26;
            if (*(void *)&v133[12])
            {
              float v35 = [*(id *)&v133[12] name];
              id v36 = [v35 stringValue];
            }
            else
            {
              id v36 = 0;
            }
            if ((void)v134)
            {
              float32x4_t v37 = [(id)v134 name];
              id v38 = [v37 stringValue];
            }
            else
            {
              id v38 = 0;
            }
            float v123 = v22;
            if (*((void *)&v134 + 1))
            {
              int32x2_t v39 = [*((id *)&v134 + 1) name];
              uint64_t v40 = [v39 stringValue];
            }
            else
            {
              uint64_t v40 = 0;
            }
            float v113 = (re *)v40;
            if (v135)
            {
              [v135 name];
              id v41 = v38;
              v43 = float32x4_t v42 = v36;
              uint64_t v44 = [v43 stringValue];

              id v36 = v42;
              id v38 = v41;
              if (v36) {
                goto LABEL_35;
              }
LABEL_37:
              int v33 = 1;
            }
            else
            {
              uint64_t v44 = 0;
              if (!v36) {
                goto LABEL_37;
              }
LABEL_35:
              int v33 = re::swizzleForTextureOutputProperty(v36, v28);
            }
            if (v38) {
              int v45 = re::swizzleForTextureOutputProperty(v38, v28);
            }
            else {
              int v45 = 1;
            }
            int v122 = v45;
            if (v113) {
              int v46 = re::swizzleForTextureOutputProperty(v113, v28);
            }
            else {
              int v46 = 1;
            }
            int v120 = v46;
            if (v44) {
              int v47 = re::swizzleForTextureOutputProperty(v44, v28);
            }
            else {
              int v47 = 1;
            }
            int v118 = v47;

            int v112 = 2;
            unint64_t v22 = v123;
            float32x4_t v26 = v116;
LABEL_49:
            if (*(void *)(v25 + 8)) {
              uint64_t v48 = *(const char **)(v25 + 16);
            }
            else {
              uint64_t v48 = v26;
            }
            int v124 = v33;
            if (!strcmp(v48, "textureNormal"))
            {
              BOOL v50 = 0;
              int v51 = 5;
            }
            else if (!strcmp(v48, "textureEmissive"))
            {
              BOOL v50 = 0;
              int v51 = 4;
            }
            else if (!strcmp(v48, "textureBaseColor"))
            {
              BOOL v50 = 0;
              int v51 = 3;
            }
            else if (v33 == 2 {
                   && ((int v49 = strcmp(v48, "textureOpacity"), !strcmp(v48, "textureMetallic"))
            }
                    || !strcmp(v48, "textureRoughness")
                    || !strcmp(v48, "textureSpecular")
                    || !strcmp(v48, "textureAmbientOcclusion")
                    || !strcmp(v48, "textureClearcoat")
                    || !strcmp(v48, "textureClearcoatRoughness")
                    || !v49))
            {
              BOOL v50 = v49 != 0;
              int v51 = 2;
            }
            else
            {
              BOOL v50 = 0;
              int v51 = 6;
            }
            unsigned int v117 = v51;
            uint64_t v52 = v22;
            float32x2_t v53 = (const char *)[(re::DynamicString *)v22 UTF8String];
            size_t v54 = strlen(v53);
            unint64_t v24 = v127;
            float v55 = (_anonymous_namespace_ *)[v127 UTF8String];
            if (!*(unsigned char *)(a3 + 66)
              || ((v139[0] & 1) != 0 ? (__int16 v57 = (char *)v139[1]) : (__int16 v57 = (char *)v139 + 1),
                  (v139[0] & 1) != 0 ? (size_t v58 = v139[0] >> 1) : (size_t v58 = LOBYTE(v139[0]) >> 1),
                  uint64_t isPackageRelativePath = (re::TextureAsset *)re::isPackageRelativePath(v57, v58),
                  isPackageRelativePath))
            {
              BOOL v114 = v50;
              int v59 = re::TextureAsset::assetType(isPackageRelativePath);
              re::ImportAssetTable::compiledAssetPath((uint64_t)v53, v54, (re **)v59, (re::DynamicString *)&v145);
              uint64_t v60 = v144;
              unint64_t v61 = v142;
              if (v142)
              {
                uint64_t v62 = 96 * v142;
                uint64_t v63 = v144;
                while (!re::DynamicString::operator==(v63, (uint64_t)&v145))
                {
                  v63 += 96;
                  v62 -= 96;
                  if (!v62) {
                    goto LABEL_80;
                  }
                }
                uint64_t v67 = v125;
              }
              else
              {
LABEL_80:
                double v65 = re::DynamicString::DynamicString((re::DynamicString *)&buf, (const re::DynamicString *)&v145);
                *(void *)&long long v150 = 0x600000000;
                DWORD2(v150) = 67305984;
                BYTE12(v150) = 5;
                int v151 = 0;
                long long v152 = 0u;
                long long v153 = 0u;
                unint64_t v66 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v152, 0);
                uint64_t v154 = 0;
                uint64_t v67 = v125;
                if (v61 >= v141)
                {
                  if (v141 < v61 + 1)
                  {
                    if (v140)
                    {
                      unint64_t v68 = 8;
                      if (v141) {
                        unint64_t v68 = 2 * v141;
                      }
                      if (v68 <= v61 + 1) {
                        unint64_t v69 = v61 + 1;
                      }
                      else {
                        unint64_t v69 = v68;
                      }
                      re::DynamicArray<re::ImportedTexturesTable::Entry>::setCapacity(&v140, v69);
                    }
                    else
                    {
                      re::DynamicArray<re::ImportedTexturesTable::Entry>::setCapacity(&v140, v61 + 1);
                      ++v143;
                    }
                  }
                  unint64_t v61 = v142;
                  uint64_t v60 = v144;
                }
                uint64_t v63 = v60 + 96 * v61;
                *(_OWORD *)uint64_t v63 = 0u;
                *(_OWORD *)(v63 + 16) = 0u;
                *(void *)uint64_t v63 = buf;
                *(void *)&long long buf = 0;
                uint64_t v70 = *(void *)(v63 + 16);
                *(void *)(v63 + 16) = v148;
                uint64_t v148 = v70;
                *(void *)(v63 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v149;
                uint64_t v149 = 0;
                uint64_t v71 = *(void *)(v63 + 8);
                *(void *)(v63 + 8) = *((void *)&buf + 1);
                *((void *)&buf + 1) = v71;
                long long v72 = v150;
                *(_DWORD *)(v63 + 48) = v151;
                *(_OWORD *)(v63 + 32) = v72;
                *(_OWORD *)(v63 + 72) = 0u;
                *(_OWORD *)(v63 + 56) = 0u;
                *(void *)(v63 + 56) = v152;
                *(void *)&long long v152 = 0;
                uint64_t v73 = *(void *)(v63 + 72);
                *(void *)(v63 + 72) = v153;
                *(void *)&long long v153 = v73;
                *(void *)(v63 + 80) = *((void *)&v153 + 1);
                *((void *)&v153 + 1) = 0;
                uint64_t v74 = *(void *)(v63 + 64);
                *(void *)(v63 + 64) = *((void *)&v152 + 1);
                *((void *)&v152 + 1) = v74;
                *(void *)(v63 + 88) = v154;
                unint64_t v142 = v61 + 1;
                ++v143;
                if ((void)v152)
                {
                  if (BYTE8(v152)) {
                    (*(void (**)(void))(*(void *)v152 + 40))();
                  }
                  long long v152 = 0u;
                  long long v153 = 0u;
                }
                if (void)buf && (BYTE8(buf)) {
                  (*(void (**)(void))(*(void *)buf + 40))();
                }
              }
              if (v145 && (v146 & 1) != 0) {
                (*(void (**)(void))(*(void *)v145 + 40))();
              }
              int v75 = *(_DWORD *)(v63 + 32);
              if (v75 == 1)
              {
                uint64_t v76 = v117 - 2;
                if (v76 > 3) {
                  unint64_t v77 = 0;
                }
                else {
                  unint64_t v77 = qword_23437FA48[v76];
                }
                uint64_t v78 = *(int *)(v63 + 36);
                if (v78 > 5) {
                  unint64_t v79 = 0;
                }
                else {
                  unint64_t v79 = qword_23437FA68[v78];
                }
                if (v77 > v79)
                {
                  *(_DWORD *)(v63 + 36) = v117;
                  *(unsigned char *)(v63 + 40) = v114;
                }
                if (v111)
                {
                  if (*(_DWORD *)(v63 + 41) == ((v120 << 16) | (v118 << 24) | (v122 << 8) | v124)
                    || *(_DWORD *)(v63 + 48) == 2)
                  {
                    goto LABEL_119;
                  }
                  *(_DWORD *)(v63 + 41) = 84148994;
                  int v80 = 3;
                }
                else
                {
                  *(unsigned char *)(v63 + 41) = v124;
                  *(unsigned char *)(v63 + 42) = v122;
                  *(unsigned char *)(v63 + 43) = v120;
                  *(unsigned char *)(v63 + 44) = v118;
                  int v80 = 2;
                }
                *(_DWORD *)(v63 + 48) = v80;
                goto LABEL_119;
              }
              if (v75)
              {
                re::internal::assertLog((re::internal *)4, v64, "assertion failure: '%s' (%s:line %i) Unexpected imported texture source", "!\"Unreachable code\"", "buildTexturesTable", 6014);
                _os_crash();
                __break(1u);
              }
              *(_DWORD *)(v63 + 32) = 1;
              re::DynamicString::operator=((re::DynamicString *)(v63 + 56), (re::DynamicString *)&v138);
              *(unsigned char *)(v63 + 41) = v124;
              *(unsigned char *)(v63 + 42) = v122;
              *(unsigned char *)(v63 + 43) = v120;
              *(unsigned char *)(v63 + 44) = v118;
              *(_DWORD *)(v63 + 48) = v112;
              *(_DWORD *)(v63 + 36) = v117;
              *(unsigned char *)(v63 + 40) = v114;
              *(void *)(v63 + 88) = v67;
            }
LABEL_119:
            if (v138 && (v139[0] & 1) != 0) {
              (*(void (**)(void))(*(void *)v138 + 40))();
            }
            int v10 = v110;
            unint64_t v22 = v52;
          }
          else
          {
            float v34 = *re::pipelineLogObjects(v23);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v22;
              _os_log_error_impl(&dword_233120000, v34, OS_LOG_TYPE_ERROR, "Failed to resolve reference to texture '%@'", (uint8_t *)&buf, 0xCu);
            }
          }

          goto LABEL_124;
        }
LABEL_132:

        re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v129);
        unint64_t v6 = v108;
        uint64_t v7 = v106;
      }

      unint64_t v6 = [v109 nextObject];
    }
    while (v6);
  }
  unint64_t v119 = v142;
  if (v142)
  {
    uint64_t v83 = v144;
    uint64_t v84 = v144 + 96 * v142;
    uint64_t v126 = (void *)(a1 + 8);
    uint64_t v121 = v84;
    while (*(_DWORD *)(v83 + 32) != 1)
    {
LABEL_180:
      v83 += 96;
      if (v83 == v84) {
        goto LABEL_181;
      }
    }
    uint64_t v85 = *(void **)(v83 + 88);
    int v86 = *(unsigned __int8 *)(a3 + 64);
    int v87 = *(unsigned __int8 *)(a3 + 65);
    id v129 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
    *(_OWORD *)&v133[4] = 0u;
    long long v134 = 0u;
    long long v130 = 0u;
    uint64_t v132 = 0;
    *(void *)long long v133 = 0;
    v133[8] = 0;
    int v131 = 1;
    DWORD2(v134) = 6;
    uint64_t v136 = 0;
    uint64_t v137 = 0;
    id v135 = 0;
    objc_msgSend(v129, sel_setResourceOptions_, 32);
    DWORD2(v134) = *(_DWORD *)(v83 + 36);
    if (DWORD2(v134) == 6)
    {
      if (v130 == 2) {
        LODWORD(v130) = 0;
      }
      if (DWORD1(v130) == 3) {
        DWORD1(v130) = 0;
      }
    }
    else
    {
      *(void *)&long long v130 = 0x300000002;
    }
    objc_storeStrong(&v135, v85);
    if (v87) {
      BYTE4(v134) = 1;
    }
    if (v86)
    {
      int v88 = *(_DWORD *)(v83 + 36);
      if (v88 != 2)
      {
        LODWORD(v130) = 1;
        if ((v88 - 3) >= 2) {
          uint64_t v89 = 204;
        }
        else {
          uint64_t v89 = 186;
        }
        objc_msgSend(v129, sel_setPixelFormat_, v89);
        LODWORD(v132) = 3;
      }
    }
    if (*(unsigned char *)(v83 + 40))
    {
      LODWORD(v130) = 1;
      objc_msgSend(v129, sel_setPixelFormat_, 10);
    }
    if (*(_DWORD *)(v83 + 41) != 84148994) {
      objc_msgSend(v129, sel_setSwizzle_);
    }
    int v90 = *(unsigned __int8 *)(a3 + 65);
    re::DynamicString::DynamicString((re::DynamicString *)v128, (const re::DynamicString *)(v83 + 56));
    re::USKTextureProvider::USKTextureProvider((re::TextureProvider *)&buf, (id *)a3, v90, (const re::DynamicString *)v128);
    if (*(void *)&v128[0])
    {
      if (BYTE8(v128[0])) {
        (*(void (**)(void))(**(void **)&v128[0] + 40))();
      }
      memset(v128, 0, sizeof(v128));
    }
    re::TextureProvider::setTemplateDescriptor((uint64_t)&buf, &v129);
    re::TextureProvider::setOptions((uint64_t)&buf, &v130);
    re::DynamicString::operator=((re::DynamicString *)((char *)&buf + 8), (re::DynamicString *)(v83 + 56));
    unint64_t v91 = re::Hash<re::DynamicString>::operator()((uint64_t)&v145, v83);
    unint64_t v92 = v91;
    if (*v126)
    {
      uint64_t v93 = a1;
      unint64_t v94 = v91 % *(unsigned int *)(a1 + 32);
      uint64_t v95 = *(unsigned int *)(*(void *)(a1 + 16) + 4 * v94);
      if (v95 != 0x7FFFFFFF)
      {
        uint64_t v96 = *(void *)(a1 + 24);
        while (!re::DynamicString::operator==(v96 + 288 * v95 + 16, v83))
        {
          uint64_t v95 = *(_DWORD *)(v96 + 288 * v95 + 8) & 0x7FFFFFFF;
          if (v95 == 0x7FFFFFFF) {
            goto LABEL_167;
          }
        }
        goto LABEL_174;
      }
    }
    else
    {
      unint64_t v94 = 0;
LABEL_167:
      uint64_t v93 = a1;
    }
    uint64_t v97 = *(unsigned int *)(v93 + 44);
    if (v97 == 0x7FFFFFFF)
    {
      uint64_t v97 = *(unsigned int *)(v93 + 40);
      int v98 = v97;
      if (v97 == *(_DWORD *)(v93 + 32))
      {
        re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)v126, 2 * *(_DWORD *)(v93 + 36));
        uint64_t v93 = a1;
        unint64_t v94 = v92 % *(unsigned int *)(a1 + 32);
        int v98 = *(_DWORD *)(a1 + 40);
      }
      *(_DWORD *)(v93 + 40) = v98 + 1;
      uint64_t v99 = *(void *)(v93 + 24);
      int v100 = *(_DWORD *)(v99 + 288 * v97 + 8);
    }
    else
    {
      uint64_t v99 = *(void *)(v93 + 24);
      int v100 = *(_DWORD *)(v99 + 288 * v97 + 8);
      *(_DWORD *)(v93 + 44) = v100 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v99 + 288 * v97 + 8) = v100 | 0x80000000;
    *(_DWORD *)(*(void *)(v93 + 24) + 288 * v97 + 8) = *(_DWORD *)(*(void *)(v93 + 24) + 288 * v97 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v93 + 16) + 4 * v94);
    *(void *)(*(void *)(v93 + 24) + 288 * v9re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = v92;
    uint64_t v101 = v93;
    re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(v93 + 24) + 288 * v97 + 16), (const re::DynamicString *)v83);
    uint64_t v102 = *(void *)(v101 + 24) + 288 * v97;
    re::TextureProvider::TextureProvider((re::TextureProvider *)(v102 + 48), (const re::TextureProvider *)&buf);
    *(void *)(v102 + 48) = &unk_26E6E0A08;
    re::DynamicString::DynamicString((re::DynamicString *)(v102 + 256), (const re::DynamicString *)v155);
    *(void *)(v102 + 48) = &unk_26E715260;
    *(_DWORD *)(*(void *)(v101 + 16) + 4 * v94) = v97;
    ++*(_DWORD *)(v101 + 36);
    ++*(_DWORD *)(v101 + 48);
    uint64_t v84 = v121;
LABEL_174:
    *(void *)&long long buf = &unk_26E6E0A08;
    if (v155[0])
    {
      if (v155[1]) {
        (*(void (**)(void))(*(void *)v155[0] + 40))();
      }
      memset(v155, 0, 32);
    }
    re::TextureProvider::~TextureProvider((id *)&buf);

    if (v129) {
    goto LABEL_180;
    }
  }
LABEL_181:

  uint64_t result = (uint64_t)v140;
  if (v140)
  {
    uint64_t v104 = v144;
    if (v144)
    {
      if (v119)
      {
        uint64_t v105 = 96 * v119;
        do
        {
          re::DynamicString::deinit((re::DynamicString *)(v104 + 56));
          re::DynamicString::deinit((re::DynamicString *)v104);
          v104 += 96;
          v105 -= 96;
        }
        while (v105);
        uint64_t result = (uint64_t)v140;
        uint64_t v104 = v144;
      }
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v104);
    }
  }
  return result;
}

id re::getResourcePathAndColorSpaceForTextureProperty(void *a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v1 = [a1 parentNode];
  uint64_t v2 = [MEMORY[0x263F83F10] shaderNodeType:v1];
  int v3 = [v2 isEqualToString:*MEMORY[0x263F84060]];

  if (v3)
  {
    unint64_t v4 = [v1 property:@"inputs:file"];
    uint64_t v5 = v4;
    if (v4)
    {
      unint64_t v6 = [v4 metadataWithKey:@"colorSpace"];
      uint64_t v7 = v6;
      if (v6)
      {
        BOOL v8 = [v6 stringValue];
        if (!re::CGColorSpaceNameFromOCIOString(v8, v9))
        {
          int v10 = *re::pipelineLogObjects(0);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            int v18 = 138412290;
            uint64_t v19 = v8;
            _os_log_impl(&dword_233120000, v10, OS_LOG_TYPE_DEFAULT, "Warning, no suitable convertion to CGColorSpace found for OpenColorIO tag: %@.", (uint8_t *)&v18, 0xCu);
          }
        }
      }
      id v12 = [v5 type];
      int v13 = [v12 isEqualToString:*MEMORY[0x263F83FA0]];

      if (v13)
      {
        uint64_t v14 = [v5 resourcePath];
        uint64_t v15 = [v14 path];
        uint64_t v16 = v15;
        if (v15 && [v15 length]) {
          id v11 = v14;
        }
        else {
          id v11 = 0;
        }
      }
      else
      {
        id v11 = 0;
      }
    }
    else
    {
      id v11 = 0;
    }
  }
  else
  {
    id v11 = 0;
  }

  return v11;
}

uint64_t re::swizzleForTextureOutputProperty(re *this, NSString *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = this;
  if (([(re *)v2 isEqualToString:@"outputs:r"] & 1) == 0)
  {
    if ([(re *)v2 isEqualToString:@"outputs:g"])
    {
      int v3 = 0x1000000;
      int v4 = 196608;
      int v5 = 3;
    }
    else
    {
      if ([(re *)v2 isEqualToString:@"outputs:b"])
      {
        int v3 = 0x1000000;
        int v4 = 0x40000;
        int v5 = 4;
        int v6 = 1024;
        goto LABEL_10;
      }
      if ([(re *)v2 isEqualToString:@"outputs:a"])
      {
        int v3 = 0x1000000;
        int v4 = 327680;
        int v5 = 5;
        int v6 = 1280;
        goto LABEL_10;
      }
      if ([(re *)v2 isEqualToString:@"outputs:rgb"])
      {
        int v3 = 0x1000000;
      }
      else
      {
        BOOL v8 = (re *)[(re *)v2 isEqualToString:@"outputs:rgba"];
        if ((v8 & 1) == 0)
        {
          CFStringRef v9 = *re::pipelineLogObjects(v8);
          int v5 = 2;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            int v10 = 138412290;
            id v11 = v2;
            _os_log_debug_impl(&dword_233120000, v9, OS_LOG_TYPE_DEBUG, "Unexpected texture output property '%@' during scene import", (uint8_t *)&v10, 0xCu);
          }
          int v3 = 83886080;
          int v4 = 0x40000;
          goto LABEL_5;
        }
        int v3 = 83886080;
      }
      int v4 = 0x40000;
      int v5 = 2;
    }
LABEL_5:
    int v6 = 768;
    goto LABEL_10;
  }
  int v3 = 0x1000000;
  int v4 = 0x20000;
  int v5 = 2;
  int v6 = 512;
LABEL_10:

  return v5 | v3 | v6 | v4;
}

uint64_t re::isRootNodeByPath(void *a1)
{
  id v1 = [a1 path];
  uint64_t v2 = [v1 stringValue];
  uint64_t v3 = [v2 isEqual:@"/"];

  return v3;
}

void re::convertActionAssetsToAssetPaths(id *a1@<X0>, const re::AssetPath *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  id v5 = *a1;
  unint64_t v22 = objc_msgSend(MEMORY[0x263EFF9A0], "dictionaryWithCapacity:", objc_msgSend(v5, "count"));
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id v6 = v5;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v35 objects:v39 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v20 = *(void *)v36;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v36 != v20) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void *)(*((void *)&v35 + 1) + 8 * i);
        id v11 = [v6 objectForKeyedSubscript:v10];
        int v30 = 0;
        memset(v31, 0, sizeof(v31));
        uint64_t v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v31, 0);
        long long v32 = 0u;
        long long v33 = 0u;
        re::DynamicString::setCapacity(&v32, 0);
        uint64_t v34 = 0;
        int v13 = v11;
        double v14 = re::AssetPath::parse((re::AssetPath *)&v30, (char *)[(_anonymous_namespace_ *)v13 UTF8String], a2, *(const re::internal::AssetTypeRegistry **)(a3 + 1040), *(os_unfair_lock_s **)(a3 + 1128), v27);
        if (!v27[0] && (void)v28)
        {
          if (BYTE8(v28)) {
            (*(void (**)(double))(*(void *)v28 + 40))(v14);
          }
          long long v28 = 0u;
          long long v29 = 0u;
        }
        uint64_t v15 = NSString;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        uint64_t v24 = 0;
        uint64_t v23 = v31[0];
        re::DynamicString::setCapacity(&v23, 0);
        re::AssetPath::fullAssetPath((re::DynamicString *)&v30, (re::DynamicString *)&v23);
        if (v24) {
          uint64_t v16 = v25;
        }
        else {
          uint64_t v16 = (char *)&v24 + 1;
        }
        id v17 = [v15 stringWithUTF8String:v16];
        [v22 setObject:v17 forKeyedSubscript:v10];

        if (v23 && (v24 & 1) != 0) {
          (*(void (**)(void))(*(void *)v23 + 40))();
        }
        if ((void)v32)
        {
          if (BYTE8(v32)) {
            (*(void (**)(void))(*(void *)v32 + 40))();
          }
          long long v32 = 0u;
          long long v33 = 0u;
        }
        if (v31[0] && (v31[1] & 1) != 0) {
          (*(void (**)(void))(*(void *)v31[0] + 40))();
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v35 objects:v39 count:16];
    }
    while (v8);
  }

  id v18 = (id)[v22 copy];
  *a4 = v18;
}

_anonymous_namespace_ *re::registerImportedScene(re *this, re::SceneImportResult *a2, const re::mtl::Device *a3, const re::AssetPath *a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)this;
  int v49 = *(_DWORD *)a3;
  int v45 = (const re::mtl::Device *)((char *)a3 + 8);
  re::DynamicString::DynamicString((re::DynamicString *)v50, (const re::mtl::Device *)((char *)a3 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)v51, (const re::mtl::Device *)((char *)a3 + 40));
  v51[4] = *((void *)a3 + 9);
  if (*((void *)this + 18))
  {
    uint64_t v7 = *((void *)this + 18);
    unint64_t v8 = 0;
    do
    {
      CFStringRef v9 = (char *)re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[]((uint64_t)this + 104, v8);
      int v61 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      uint64_t v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v62, 0);
      long long v64 = 0u;
      long long v65 = 0u;
      re::DynamicString::setCapacity(&v64, 0);
      uint64_t v66 = 0;
      if (*((void *)v9 + 1)) {
        id v11 = (char *)*((void *)v9 + 2);
      }
      else {
        id v11 = v9 + 9;
      }
      v12.n128_f64[0] = re::AssetPath::parse((re::AssetPath *)&v61, v11, (const re::AssetPath *)&v49, *(const re::internal::AssetTypeRegistry **)(v6 + 1040), *(os_unfair_lock_s **)(v6 + 1128), &v57);
      if (!(_BYTE)v57 && (void)v59)
      {
        if (BYTE8(v59)) {
          (*(void (**)(double))(*(void *)v59 + 40))(v12.n128_f64[0]);
        }
        __n128 v12 = 0uLL;
        long long v59 = 0u;
        long long v60 = 0u;
      }
      int v13 = (re *)(**(void *(***)(uint64_t *__return_ptr, uint64_t, int *, __n128))v6)(&v55, v6, &v61, v12);
      if (v56 && (unsigned int v14 = atomic_load((unsigned int *)(v56 + 704)), v14 == 2))
      {
        uint64_t v15 = *re::pipelineLogObjects(v13);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          long long v28 = v15;
          float32x2_t v53 = 0;
          uint64_t v54 = 0;
          long long v52 = (unint64_t)v62;
          re::DynamicString::setCapacity(&v52, 0);
          re::AssetPath::fullAssetPath((re::DynamicString *)&v61, (re::DynamicString *)&v52);
          long long v29 = (char *)&v52 + 9;
          if (BYTE8(v52)) {
            long long v29 = v53;
          }
          *(_DWORD *)long long buf = 136315138;
          unint64_t v68 = v29;
          _os_log_debug_impl(&dword_233120000, v28, OS_LOG_TYPE_DEBUG, "Ignoring loaded asset '%s' since it is already loaded", buf, 0xCu);

          if (void)v52 && (BYTE8(v52)) {
            (*(void (**)(void))(*(void *)v52 + 40))();
          }
        }
        uint64_t v16 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(v6 + 1040), *((void *)v9 + 4));
        (*(void (**)(uint64_t, void))(*(void *)v16 + 16))(v16, *((void *)v9 + 5));
        *((void *)v9 + 5) = 0;
      }
      else
      {
        re::AssetHandle::internalForceUnloadAsync((re::AssetHandle *)&v55);
        id v17 = (re::AudioFileAsset *)(*(uint64_t (**)(uint64_t, void, uint64_t *, void, void))(*(void *)v6 + 200))(v6, *((void *)v9 + 5), &v55, 0, 0);
        if (v56 && (unsigned int v18 = atomic_load((unsigned int *)(v56 + 704)), v18 == 2))
        {
          uint64_t v19 = (uint64_t *)*((void *)v9 + 4);
          uint64_t v20 = re::AudioFileAsset::assetType(v17);
          if (v19 == v20)
          {
            uint64_t v21 = re::AudioFileAsset::assetType((re::AudioFileAsset *)v20);
            uint64_t v22 = re::AssetHandle::assetWithType((re::AssetHandle *)&v55, (const re::AssetType *)v21, 0);
            if (v22)
            {
              uint64_t v23 = (re::AudioFileAsset *)v22;
              uint64_t v24 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(v6 + 1040), *((void *)v9 + 4));
              re::AudioFileAsset::completeLoad(v23, *(AudioSceneService **)(v24 + 8));
            }
          }
        }
        else
        {
          uint64_t v25 = *re::pipelineLogObjects(v17);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v26 = v25;
            float32x2_t v53 = 0;
            uint64_t v54 = 0;
            long long v52 = (unint64_t)v62;
            re::DynamicString::setCapacity(&v52, 0);
            re::AssetPath::fullAssetPath((re::DynamicString *)&v61, (re::DynamicString *)&v52);
            double v27 = (char *)&v52 + 9;
            if (BYTE8(v52)) {
              double v27 = v53;
            }
            *(_DWORD *)long long buf = 136315138;
            unint64_t v68 = v27;
            _os_log_debug_impl(&dword_233120000, v26, OS_LOG_TYPE_DEBUG, "Asset failed to load: %s", buf, 0xCu);

            if (void)v52 && (BYTE8(v52)) {
              (*(void (**)(void))(*(void *)v52 + 40))();
            }
          }
        }
      }
      re::DynamicArray<re::AssetHandle>::add((re *)((char *)this + 248), (re::AssetHandle *)&v55);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v55);
      if ((void)v64)
      {
        if (BYTE8(v64)) {
          (*(void (**)(void))(*(void *)v64 + 40))();
        }
        long long v64 = 0u;
        long long v65 = 0u;
      }
      if (void)v62 && (BYTE8(v62)) {
        (*(void (**)(void))(*(void *)v62 + 40))();
      }
      ++v8;
    }
    while (v7 != v8);
  }
  if (v51[0])
  {
    if (v51[1]) {
      (*(void (**)(void))(*(void *)v51[0] + 40))();
    }
    memset(v51, 0, 32);
  }
  uint64_t result = (_anonymous_namespace_ *)v50[0];
  if (v50[0])
  {
    if (v50[1]) {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v50[0] + 40))();
    }
    memset(v50, 0, sizeof(v50));
  }
  if (*((void *)this + 38))
  {
    unint64_t v31 = 0;
    uint64_t v32 = 48;
    do
    {
      uint64_t v33 = *((void *)this + 40);
      int v61 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      uint64_t v34 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v62, 0);
      long long v64 = 0u;
      long long v65 = 0u;
      re::DynamicString::setCapacity(&v64, 0);
      uint64_t v66 = 0;
      long long v52 = 0uLL;
      float32x2_t v53 = 0;
      if (*((void *)this + 38) == 1)
      {
        int v61 = *(_DWORD *)a3;
        re::DynamicString::operator=((re::DynamicString *)&v62, v45);
        re::DynamicString::operator=((re::DynamicString *)&v64, (const re::mtl::Device *)((char *)a3 + 40));
        uint64_t v66 = *((void *)a3 + 9);
        (**(void (***)(long long *__return_ptr, uint64_t, const re::mtl::Device *))v6)(&v57, v6, a3);
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"scene%02zu.compiledscene", (re::DynamicString *)&v57, v31);
        if (BYTE8(v57)) {
          long long v35 = v58;
        }
        else {
          long long v35 = (char *)&v57 + 9;
        }
        v36.n128_f64[0] = re::AssetPath::parse((re::AssetPath *)&v61, v35, a3, *(const re::internal::AssetTypeRegistry **)(v6 + 1040), *(os_unfair_lock_s **)(v6 + 1128), v46);
        if (!v46[0] && (void)v47)
        {
          if (BYTE8(v47)) {
            (*(void (**)(double))(*(void *)v47 + 40))(v36.n128_f64[0]);
          }
          __n128 v36 = 0uLL;
          long long v47 = 0u;
          long long v48 = 0u;
        }
        if (void)v57 && (BYTE8(v57)) {
          (*(void (**)(__n128))(*(void *)v57 + 40))(v36);
        }
        (**(void (***)(long long *__return_ptr, uint64_t, int *, __n128))v6)(&v57, v6, &v61, v36);
      }
      long long v37 = v52;
      long long v52 = v57;
      long long v57 = v37;
      long long v38 = v53;
      float32x2_t v53 = v58;
      size_t v58 = v38;
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v57);
      if (!*((void *)&v52 + 1) || (unsigned int v39 = atomic_load((unsigned int *)(*((void *)&v52 + 1) + 704)), v39 != 2))
      {
        re::AssetHandle::internalForceUnloadAsync((re::AssetHandle *)&v52);
        uint64_t v40 = *(void *)(v33 + v32);
        float32x4_t v42 = re::SceneAsset::assetType(v41);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t *, int *))(*(void *)v6 + 192))(&v57, v6, v40, v42, &v61);
        long long v43 = v52;
        long long v52 = v57;
        long long v57 = v43;
        uint64_t v44 = v53;
        float32x2_t v53 = v58;
        size_t v58 = v44;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v57);
      }
      re::AssetHandle::operator=(v33 + v32 + 48, (uint64_t *)&v52);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v52);
      if ((void)v64)
      {
        if (BYTE8(v64)) {
          (*(void (**)(void))(*(void *)v64 + 40))();
        }
        long long v64 = 0u;
        long long v65 = 0u;
      }
      uint64_t result = (_anonymous_namespace_ *)v62;
      if (void)v62 && (BYTE8(v62)) {
        uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v62 + 40))();
      }
      ++v31;
      v32 += 160;
    }
    while (v31 < *((void *)this + 38));
  }
  *((unsigned char *)this + 328) = 1;
  return result;
}

uint64_t re::estimateSceneMemoryCost(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  int v4 = NSURL;
  id v5 = [NSString stringWithUTF8String:a1];
  uint64_t v6 = [v4 URLWithString:v5];

  id v51 = 0;
  long long v43 = v6;
  int v7 = [v6 getResourceValue:&v51 forKey:*MEMORY[0x263EFF688] error:0];
  id v8 = v51;
  uint64_t v9 = 0;
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v9 = [v8 unsignedIntValue];
    }
    else {
      uint64_t v9 = 0;
    }
  }
  uint64_t v41 = v9;
  id v42 = v8;
  uint64_t v10 = (re *)getpagesize();
  uint64_t v12 = *(void *)(a2 + 8);
  if (!v12)
  {
    uint64_t v13 = 0;
LABEL_31:
    long long v37 = *re::pipelineLogObjects(v10);
    long long v35 = v43;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412802;
      *(void *)&uint8_t buf[4] = v43;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v13;
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)&unsigned char buf[24] = v41;
      _os_log_impl(&dword_233120000, v37, OS_LOG_TYPE_INFO, "Preflight for scene '%@' estimates '%zu' bytes will be used for textures and the file at the url takes '%zu' bytes.", buf, 0x20u);
    }
    uint64_t v36 = v13 + v41;
    goto LABEL_34;
  }
  uint64_t v13 = 0;
  unsigned int v14 = *(id ***)a2;
  key = (void *)*MEMORY[0x263F0F4F8];
  uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)(int)v10);
  v15.i16[0] = vaddlv_u8(v15);
  uint64_t v48 = v15.u32[0];
  int v49 = (void *)*MEMORY[0x263F0F4F0];
  unint64_t v45 = (int)v10;
  uint64_t v46 = -(uint64_t)(int)v10;
  uint64_t v47 = (int)v10 - 1;
  uint64_t v16 = 8 * v12;
  while (1)
  {
    id v17 = *v14;
    re::TextureProvider::lazyFetchProperties(*v14, v11);
    CFDictionaryRef v19 = (const __CFDictionary *)v17[22];
    if (!v19) {
      break;
    }
    uint64_t v20 = CFDictionaryGetValue((CFDictionaryRef)v17[22], key);
    uint64_t v21 = v20;
    int v22 = v20 ? [v20 intValue] : -1;
    uint64_t v23 = CFDictionaryGetValue(v19, v49);
    uint64_t v24 = v23;
    int v25 = v23 ? [v23 intValue] : -1;

    if (v22 == -1 || v25 == -1) {
      break;
    }
    uint64_t v10 = (re *)objc_msgSend(v17[5], sel_pixelFormat);
    if (v10)
    {
      uint64_t v54 = 0;
      long long v53 = 0u;
      memset(buf, 0, sizeof(buf));
      id v26 = v17[5];
      id v27 = *a3;
      objc_msgSend(v26, sel_pixelFormat);
      MTLPixelFormatGetInfoForDevice();

      uint64_t v28 = 4;
      if ((*(_WORD *)&buf[8] & 0x400) == 0) {
        uint64_t v28 = *(void *)&buf[24];
      }
    }
    else
    {
      uint64_t v28 = 4;
    }
    unint64_t v29 = v28 * v25 * v22;
    if (*((_DWORD *)v17 + 17) == 2) {
      float v30 = 1.0;
    }
    else {
      float v30 = 1.3333;
    }
    unint64_t v31 = v47 + (unint64_t)(float)(v30 * (float)v29);
    uint64_t v32 = v31 / v45 * v45;
    uint64_t v33 = v31 & v46;
    if (v48 != 1) {
      uint64_t v33 = v32;
    }
    v13 += v33;
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_31;
    }
  }
  uint64_t v34 = *re::pipelineLogObjects(v18);
  long long v35 = v43;
  if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    uint64_t v36 = 0;
LABEL_34:
    long long v38 = v42;
    goto LABEL_35;
  }
  long long v38 = v42;
  if ((_BYTE)v17[2]) {
    uint64_t v40 = (char *)v17[3];
  }
  else {
    uint64_t v40 = (char *)v17 + 17;
  }
  *(_DWORD *)long long buf = 136315138;
  *(void *)&uint8_t buf[4] = v40;
  _os_log_error_impl(&dword_233120000, v34, OS_LOG_TYPE_ERROR, "Failed to retrieve image properties from CGImageSource for '%s' during scene memory estimation", buf, 0xCu);
  uint64_t v36 = 0;
LABEL_35:

  return v36;
}

uint64_t re::ImportAssetTable::addAssetWithPath(re::ImportAssetTable *this, const re::DynamicString *a2, void *a3, const re::AssetType *a4)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  re::DynamicString::DynamicString((re::DynamicString *)&v25, a2);
  *(void *)&long long v29 = a4;
  *((void *)&v29 + 1) = a3;
  unint64_t v9 = *((void *)this + 5);
  unint64_t v10 = *((void *)this + 1);
  if (v9 + 1 > 32 * v10)
  {
    re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::setBucketsCapacity(this, (v9 + 32) >> 5);
    unint64_t v10 = *((void *)this + 1);
  }
  if (v10 <= v9 >> 5)
  {
    uint64_t v30 = 0;
    memset(v39, 0, sizeof(v39));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v31 = 136315906;
    uint64_t v32 = "operator[]";
    __int16 v33 = 1024;
    int v34 = 858;
    __int16 v35 = 2048;
    unint64_t v36 = v9 >> 5;
    __int16 v37 = 2048;
    unint64_t v38 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_22:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
LABEL_23:
    re::internal::assertLog((re::internal *)4, v22, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  if (*((unsigned char *)this + 16)) {
    id v11 = (char *)this + 24;
  }
  else {
    id v11 = (char *)*((void *)this + 4);
  }
  uint64_t v12 = *(void *)&v11[8 * (v9 >> 5)];
  ++*((void *)this + 5);
  ++*((_DWORD *)this + 12);
  uint64_t v13 = v12 + 48 * (v9 & 0x1F);
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(void *)uint64_t v13 = v25;
  uint64_t v25 = 0;
  uint64_t v14 = *(void *)(v13 + 16);
  *(void *)(v13 + 16) = v27;
  uint64_t v27 = v14;
  *(void *)(v13 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v28;
  uint64_t v28 = 0;
  uint64_t v15 = *(void *)(v13 + 8);
  *(void *)(v13 + 8) = v26;
  uint64_t v26 = v15;
  *(_OWORD *)(v13 + 32) = v29;
  if (v25 && (v26 & 1) != 0) {
    (*(void (**)(void))(*(void *)v25 + 40))();
  }
  uint64_t v16 = *((void *)this + 5);
  if (!v16) {
    goto LABEL_22;
  }
  *(void *)&v39[0] = re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[]((uint64_t)this, v16 - 1);
  unint64_t v17 = re::Hash<re::DynamicString>::operator()((uint64_t)&v25, (uint64_t)a2);
  unint64_t v18 = v17;
  if (!*((void *)this + 7))
  {
    LODWORD(vre::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
    goto LABEL_18;
  }
  unint64_t v19 = v17 % *((unsigned int *)this + 20);
  uint64_t v20 = *(unsigned int *)(*((void *)this + 8) + 4 * v19);
  if (v20 == 0x7FFFFFFF)
  {
LABEL_18:
    re::HashTable<re::DynamicString,re::ImportAssetTable::ImportedAsset *,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)this + 56, v19, v18, a2, v39);
    ++*((_DWORD *)this + 24);
    goto LABEL_19;
  }
  uint64_t v21 = *((void *)this + 9);
  while (!re::DynamicString::operator==(v21 + 56 * v20 + 16, (uint64_t)a2))
  {
    uint64_t v20 = *(_DWORD *)(v21 + 56 * v20 + 8) & 0x7FFFFFFF;
    if (v20 == 0x7FFFFFFF) {
      goto LABEL_18;
    }
  }
LABEL_19:
  uint64_t v23 = *((void *)this + 5);
  if (!v23) {
    goto LABEL_23;
  }
  return re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[]((uint64_t)this, v23 - 1);
}

re::ImportedScene *re::ImportedScene::ImportedScene(re::ImportedScene *this)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v2 = (void *)((char *)this + 16);
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *((void *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  re::DynamicString::setCapacity((void *)this + 7, 0);
  *((unsigned char *)this + 88) = 0;
  *((void *)this + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  int v4 = [MEMORY[0x263F08C38] UUID];
  [v4 getUUIDBytes:this];

  return this;
}

void re::SceneImportResult::~SceneImportResult(re::SceneImportResult *this)
{
  if (!*((unsigned char *)this + 328))
  {
    uint64_t v14 = *(void *)this;
    if (*(void *)this)
    {
      uint64_t v15 = re::SceneAsset::assetType(this);
      uint64_t v16 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(v14 + 1040), (unint64_t)v15);
      uint64_t v17 = *((void *)this + 38);
      if (v17)
      {
        uint64_t v18 = v16;
        uint64_t v19 = 160 * v17;
        uint64_t v20 = (uint64_t *)(*((void *)this + 40) + 48);
        do
        {
          uint64_t v21 = *v20;
          v20 += 20;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 16))(v18, v21);
          v19 -= 160;
        }
        while (v19);
      }
      re::DynamicArray<re::ImportedScene>::clear((uint64_t)this + 288);
      uint64_t v22 = *((void *)this + 18);
      if (v22)
      {
        for (unint64_t i = 0; i != v22; ++i)
        {
          uint64_t v24 = re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[]((uint64_t)this + 104, i);
          uint64_t v25 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(v14 + 1040), *(void *)(v24 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v25 + 16))(v25, *(void *)(v24 + 40));
        }
      }
    }
  }

  uint64_t v2 = *((void *)this + 36);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 40);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 38);
      if (v4)
      {
        uint64_t v5 = 160 * v4;
        uint64_t v6 = v3 + 120;
        do
        {
          re::DynamicArray<re::AssetHandle>::deinit(v6);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 - 24));
          re::DynamicString::deinit((re::DynamicString *)(v6 - 64));
          re::DynamicString::deinit((re::DynamicString *)(v6 - 104));
          v6 += 160;
          v5 -= 160;
        }
        while (v5);
        uint64_t v2 = *((void *)this + 36);
        uint64_t v3 = *((void *)this + 40);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    *((void *)this + 40) = 0;
    *((void *)this + 3re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
    *((void *)this + 38) = 0;
    *((void *)this + 36) = 0;
    ++*((_DWORD *)this + 78);
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 248);
  uint64_t v7 = *((void *)this + 26);
  if (v7)
  {
    uint64_t v8 = (void *)*((void *)this + 30);
    if (v8)
    {
      uint64_t v9 = *((void *)this + 28);
      if (v9)
      {
        uint64_t v10 = 160 * v9;
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)(v8 + 15));
          re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)(v8 + 10));
          re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)(v8 + 5));
          re::DynamicArray<re::MeshAssetModel>::deinit(v8);
          v8 += 20;
          v10 -= 160;
        }
        while (v10);
        uint64_t v7 = *((void *)this + 26);
        uint64_t v8 = (void *)*((void *)this + 30);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 40))(v7, v8);
    }
    *((void *)this + 30) = 0;
    *((void *)this + 2re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = 0;
    *((void *)this + 28) = 0;
    *((void *)this + 26) = 0;
    ++*((_DWORD *)this + 58);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 20);
  uint64_t v11 = *((void *)this + 18);
  if (v11)
  {
    for (unint64_t j = 0; j != v11; ++j)
    {
      uint64_t v13 = (re::DynamicString *)re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[]((uint64_t)this + 104, j);
      re::DynamicString::deinit(v13);
    }
  }
  while (*((void *)this + 14))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 13);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 104);
  *((void *)this + 18) = 0;
  ++*((_DWORD *)this + 38);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 104);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 7);
  re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 1);
}

void re::DynamicArray<re::ImportedScene>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 160 * v2;
    uint64_t v4 = *(void *)(a1 + 32) + 120;
    do
    {
      re::DynamicArray<re::AssetHandle>::deinit(v4);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 - 24));
      re::DynamicString::deinit((re::DynamicString *)(v4 - 64));
      re::DynamicString::deinit((re::DynamicString *)(v4 - 104));
      v4 += 160;
      v3 -= 160;
    }
    while (v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::MaterialParameterData::operator=(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1, a2);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1 + 48, a2 + 48);
  re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1 + 96, a2 + 96);
  re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1 + 144, a2 + 144);
  re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1 + 192, a2 + 192);
  return a1;
}

unsigned char *re::MaterialRenderFlags::operator=(unsigned char *result, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (*result) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = v2 == 0;
  }
  if (!v3)
  {
    if (*result) {
      BOOL v4 = v2 == 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      *uint64_t result = 0;
    }
    else
    {
      if (*result) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v2 == 0;
      }
      if (!v5) {
        *uint64_t result = 1;
      }
      result[1] = a2[1];
    }
  }
  int v6 = a2[2];
  if (result[2]) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = v6 == 0;
  }
  if (!v7)
  {
    if (result[2]) {
      BOOL v8 = v6 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      result[2] = 0;
    }
    else
    {
      if (!result[2] && a2[2]) {
        result[2] = 1;
      }
      result[3] = a2[3];
    }
  }
  if (result[4]) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = a2[4] == 0;
  }
  if (!v9)
  {
    if (!result[4] || a2[4])
    {
      if (!result[4] && a2[4]) {
        result[4] = 1;
      }
      result[5] = a2[5];
    }
    else
    {
      result[4] = 0;
    }
  }
  if (result[6] || a2[6])
  {
    if (!result[6] || a2[6])
    {
      if (!result[6] && a2[6]) {
        result[6] = 1;
      }
      result[7] = a2[7];
    }
    else
    {
      result[6] = 0;
    }
  }
  if (result[8] || a2[8])
  {
    if (!result[8] || a2[8])
    {
      if (!result[8] && a2[8]) {
        result[8] = 1;
      }
      result[9] = a2[9];
    }
    else
    {
      result[8] = 0;
    }
  }
  if (result[10] || a2[10])
  {
    if (!result[10] || a2[10])
    {
      if (!result[10] && a2[10]) {
        result[10] = 1;
      }
      result[11] = a2[11];
    }
    else
    {
      result[10] = 0;
    }
  }
  if (result[12] || a2[12])
  {
    if (!result[12] || a2[12])
    {
      if (!result[12] && a2[12]) {
        result[12] = 1;
      }
      result[13] = a2[13];
    }
    else
    {
      result[12] = 0;
    }
  }
  if (result[14] || a2[14])
  {
    if (!result[14] || a2[14])
    {
      if (!result[14] && a2[14]) {
        result[14] = 1;
      }
      result[15] = a2[15];
    }
    else
    {
      result[14] = 0;
    }
  }
  if (result[16] || a2[16])
  {
    if (!result[16] || a2[16])
    {
      if (!result[16])
      {
        if (a2[16]) {
          result[16] = 1;
        }
      }
      result[17] = a2[17];
    }
    else
    {
      result[16] = 0;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::FunctionLink>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::FunctionLink>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::FunctionLink>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::FunctionLink>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::FunctionLink>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), (unsigned int *)(v8 + 48));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 88;
    }
  }
}

void re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free((_DWORD *)(*(void *)(a1 + 16) + v3));
        ++v4;
        v3 += 88;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 88;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, unsigned int *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  uint64_t v14 = 88 * v10;
  *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + v14 + 16), a4);
  uint64_t v15 = *(void *)(a1 + 16) + 88 * v10;
  *(unsigned char *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1> const&>((unsigned int *)v15, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  uint64_t v14 = 88 * v10;
  *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + v14 + 16), a4);
  uint64_t v15 = *(void *)(a1 + 16) + 88 * v10;
  *(unsigned char *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1>>((unsigned int *)v15, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

unsigned int *std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1>>(unsigned int *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[8];
  if (v4 != -1) {
    uint64_t result = (unsigned int *)off_26E6DF7C8[v4]((int)&v7, (re::DynamicString *)result);
  }
  v3[8] = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5 != -1)
  {
    uint64_t result = (unsigned int *)((uint64_t (*)(char *, unsigned int *, uint64_t))off_26E6DF7D8[v5])(&v6, v3, a2);
    v3[8] = v5;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_11AssetHandleEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, void *a3)
{
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = a3[3];
  uint64_t v4 = a3[1];
  *(void *)a2 = *a3;
  *a3 = 0;
  uint64_t v5 = a3[2];
  a3[3] = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = v5;
  a3[1] = v7;
  a3[2] = v6;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_11AssetHandleEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[1] = a3[1];
  a3[1] = 0;
  uint64_t v3 = *a2;
  *a2 = 0;
  *a2 = *a3;
  *a3 = v3;
  uint64_t v4 = a2[2];
  a2[2] = a3[2];
  a3[2] = v4;
}

unsigned int *std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1> const&>(unsigned int *result, unsigned int *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[8];
  if (v4 != -1) {
    double result = (unsigned int *)off_26E6DF7C8[v4]((int)&v7, (re::DynamicString *)result);
  }
  v3[8] = -1;
  uint64_t v5 = a2[8];
  if (v5 != -1)
  {
    double result = (unsigned int *)off_26E6DF7E8[v5]((int)&v6, (re::DynamicString *)v3, (re::DynamicString *)a2);
    v3[8] = v5;
  }
  return result;
}

re::DynamicString *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_11AssetHandleEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSS_EEEDcSK_DpT0_(int a1, re::DynamicString *this, re::DynamicString *a3)
{
  return re::DynamicString::DynamicString(this, a3);
}

re::AssetHandle *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_11AssetHandleEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSS_EEEDcSK_DpT0_(int a1, re::AssetHandle *this, re::AssetHandle *a3)
{
  return re::AssetHandle::AssetHandle(this, a3);
}

void re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    char v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 160 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), v8 + 48);
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 160;
    }
  }
}

void re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free((_DWORD *)(*(void *)(a1 + 16) + v3));
        ++v4;
        v3 += 160;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 160;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 160 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 160 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 160 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 160 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 160 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 160 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 160 * v9 + 16), a4);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = v14 + 160 * v9;
  *(unsigned char *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1> const&>((unsigned int *)v15, (unsigned int *)a5);
  re::DynamicString::DynamicString((re::DynamicString *)(v15 + 40), (const re::DynamicString *)(a5 + 40));
  re::DynamicString::DynamicString((re::DynamicString *)(v15 + 72), (const re::DynamicString *)(a5 + 72));
  int v16 = *(unsigned __int8 *)(a5 + 104);
  *(unsigned char *)(v15 + 104) = v16;
  if (v16) {
    *(_DWORD *)(v14 + 160 * v9 + 156) = *(_DWORD *)(a5 + 108);
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 160 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 160 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 160 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 160 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 160 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 160 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 160 * v9 + 16), a4);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = v14 + 160 * v9;
  *(unsigned char *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1>>((unsigned int *)v15, a5);
  *(_OWORD *)(v15 + 56) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(void *)(v15 + 64) = *(void *)(a5 + 64);
  uint64_t v16 = *(void *)(a5 + 48);
  *(void *)(v15 + 40) = *(void *)(a5 + 40);
  *(void *)(a5 + 40) = 0;
  uint64_t v17 = *(void *)(a5 + 56);
  *(void *)(a5 + 64) = 0;
  uint64_t v19 = *(void *)(v15 + 48);
  uint64_t v18 = *(void *)(v15 + 56);
  *(void *)(v15 + 48) = v16;
  *(void *)(v15 + 56) = v17;
  *(void *)(a5 + 48) = v19;
  *(void *)(a5 + 56) = v18;
  *(_OWORD *)(v15 + 88) = 0u;
  *(_OWORD *)(v15 + 72) = 0u;
  *(void *)(v15 + 96) = *(void *)(a5 + 96);
  uint64_t v20 = *(void *)(a5 + 80);
  *(void *)(v15 + 72) = *(void *)(a5 + 72);
  *(void *)(a5 + 72) = 0;
  uint64_t v21 = *(void *)(a5 + 88);
  *(void *)(a5 + 96) = 0;
  uint64_t v23 = *(void *)(v15 + 80);
  uint64_t v22 = *(void *)(v15 + 88);
  *(void *)(v15 + 80) = v20;
  *(void *)(v15 + 88) = v21;
  *(void *)(a5 + 80) = v23;
  *(void *)(a5 + 88) = v22;
  LODWORD(v21) = *(unsigned __int8 *)(a5 + 104);
  *(unsigned char *)(v15 + 104) = v21;
  if (v21) {
    *(_DWORD *)(v14 + 160 * v9 + 156) = *(_DWORD *)(a5 + 108);
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 152 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), v8 + 48);
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 152;
    }
  }
}

void re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        ++v4;
        v5 += 152;
      }
      while (v4 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 152;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 152 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 152 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 152 * v10 + 8) = v13 | 0x80000000;
  uint64_t v14 = 152 * v10;
  *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + v14 + 16), a4);
  re::OptionalMaterialSamplerData::OptionalMaterialSamplerData(*(void *)(a1 + 16) + 152 * v10 + 48, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::DynamicArray<re::FunctionLink>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::FunctionLink>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::FunctionLink *,re::FunctionLink *,re::FunctionLink *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 272 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = a1[4];
      uint64_t v12 = 272 * v9;
      uint64_t v13 = 272 * v4;
      do
      {
        *(unsigned char *)(v11 + v12) = *(unsigned char *)(v10 + v12);
        re::DynamicString::DynamicString((re::DynamicString *)(v11 + v12 + 8), (const re::DynamicString *)(v10 + v12 + 8));
        re::DynamicString::DynamicString((re::DynamicString *)(v11 + v12 + 40), (const re::DynamicString *)(v10 + v12 + 40));
        re::AssetHandle::AssetHandle((re::AssetHandle *)(v11 + v12 + 72), (const re::AssetHandle *)(v10 + v12 + 72));
        re::DynamicArray<re::ShaderAPIFlags::Values>::DynamicArray(v11 + v12 + 96, (uint64_t *)(v10 + v12 + 96));
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v11 + v12 + 136, v10 + v12 + 136);
        re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v11 + v12 + 184, v10 + v12 + 184);
        re::DynamicArray<BOOL>::DynamicArray(v11 + v12 + 232, (uint64_t *)(v10 + v12 + 232));
        v13 -= 272;
        v10 += 272;
        v11 += 272;
      }
      while (v12 != v13);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::FunctionLink *,re::FunctionLink *,re::FunctionLink *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 272 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4];
      uint64_t v7 = 272 * v4;
      uint64_t v8 = 272 * v5;
      do
      {
        re::DynamicArray<unsigned long>::deinit(v6 + v7 + 232);
        re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v6 + v7 + 184));
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v6 + v7 + 136));
        re::DynamicArray<unsigned long>::deinit(v6 + v7 + 96);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 + v7 + 72));
        re::DynamicString::deinit((re::DynamicString *)(v6 + v7 + 40));
        re::DynamicString::deinit((re::DynamicString *)(v6 + v7 + 8));
        v8 -= 272;
        v6 += 272;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::FunctionLink>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = 272 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 232);
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v4 + v3 + 184));
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v4 + v3 + 136));
      re::DynamicArray<unsigned long>::deinit(v4 + v3 + 96);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 + v3 + 72));
      re::DynamicString::deinit((re::DynamicString *)(v4 + v3 + 40));
      re::DynamicString::deinit((re::DynamicString *)(v4 + v3 + 8));
      v3 += 272;
    }
    while (v5 != v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<re::FunctionLink>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::FunctionLink>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x110uLL))
        {
          uint64_t v2 = 272 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 272 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 272, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 272 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::FunctionLink>(v8, v11);
          v8 += 272;
          v11 += 272;
          v10 -= 272;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::ObjectHelper::move<re::FunctionLink>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  *(unsigned char *)a2 = *(unsigned char *)a1;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  uint64_t v4 = (re::DynamicString *)(a1 + 8);
  *(void *)(a2 + 8) = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v7;
  *(void *)(a1 + 16) = v6;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v5;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  uint64_t v8 = (re::DynamicString *)(a1 + 40);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  uint64_t v10 = *(void *)(a2 + 48);
  uint64_t v9 = *(void *)(a2 + 56);
  uint64_t v11 = *(void *)(a1 + 56);
  *(void *)(a2 + 48) = *(void *)(a1 + 48);
  *(void *)(a2 + 56) = v11;
  *(void *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = v9;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 80) = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  uint64_t v12 = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = 0;
  uint64_t v13 = (re::AssetHandle *)(a1 + 72);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v12;
  uint64_t v14 = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v14;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  *(_DWORD *)(a2 + 120) = 0;
  uint64_t v15 = a1 + 96;
  uint64_t v16 = *(void *)(a1 + 104);
  *(void *)(a2 + 96) = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  *(void *)(a2 + 104) = v16;
  *(void *)(a1 + 104) = 0;
  uint64_t v17 = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = v17;
  uint64_t v18 = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v18;
  ++*(_DWORD *)(a1 + 120);
  ++*(_DWORD *)(a2 + 120);
  uint64_t v19 = (uint64_t *)(a1 + 136);
  *(_OWORD *)(a2 + 152) = 0u;
  *(_DWORD *)(a2 + 168) = 0;
  *(_OWORD *)(a2 + 136) = 0u;
  *(void *)(a2 + 172) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a2 + 136), (uint64_t *)(a1 + 136));
  *(_OWORD *)(v2 + 184) = 0u;
  v2 += 184;
  uint64_t v20 = (uint64_t *)(v3 + 184);
  *(_DWORD *)(v2 + 32) = 0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(void *)(v2 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v2, (uint64_t *)(v3 + 184));
  *(void *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 72) = 0;
  *(void *)(v2 + 56) = 0;
  *(void *)(v2 + 64) = 0;
  *(void *)(v2 + 48) = 0;
  uint64_t v21 = *(void *)(v3 + 232);
  uint64_t v22 = *(void *)(v3 + 240);
  v3 += 232;
  *(void *)(v2 + 48) = v21;
  *(void *)(v2 + 56) = v22;
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  uint64_t v23 = *(void *)(v2 + 64);
  *(void *)(v2 + 64) = *(void *)(v3 + 16);
  *(void *)(v3 + 16) = v23;
  uint64_t v24 = *(void *)(v2 + 80);
  *(void *)(v2 + 80) = *(void *)(v3 + 32);
  *(void *)(v3 + 32) = v24;
  ++*(_DWORD *)(v3 + 24);
  ++*(_DWORD *)(v2 + 72);
  re::DynamicArray<unsigned long>::deinit(v3);
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v20);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v19);
  re::DynamicArray<unsigned long>::deinit(v15);
  re::AssetHandle::~AssetHandle(v13);
  re::DynamicString::deinit(v8);
  return re::DynamicString::deinit(v4);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::FunctionLink *,re::FunctionLink *,re::FunctionLink *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    uint64_t v8 = a2 + v7;
    *(unsigned char *)(a4 + vre::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7) = *(unsigned char *)(a2 + v7);
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7 + 8), (re::DynamicString *)(a2 + v7 + 8));
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7 + 40), (re::DynamicString *)(a2 + v7 + 40));
    re::AssetHandle::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::DynamicArray<re::ShaderAPIFlags::Values>::operator=(a4 + v7 + 96, (uint64_t *)(a2 + v7 + 96));
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a4 + v7 + 136, a2 + v7 + 136);
    re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a4 + v7 + 184, a2 + v7 + 184);
    re::DynamicArray<BOOL>::operator=(a4 + v7 + 232, (uint64_t *)(a2 + v7 + 232));
    v7 += 272;
  }
  while (v8 + 272 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::ShaderAPIFlags::Values>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4) {
        re::DynamicArray<re::ShaderAPIFlags::Values>::copy((void **)a1, (uint64_t)a2);
      }
      else {
        *(void *)(a1 + 16) = 0;
      }
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::EvaluationCommand>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::ShaderAPIFlags::Values>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void **re::DynamicArray<re::ShaderAPIFlags::Values>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::EvaluationCommand>::setCapacity(result, *(void *)(a2 + 16));
    signed int v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 4 * (void)v5);
      signed int v5 = v3[2];
    }
    double result = (void **)memcpy((char *)v3[4] + 4 * (void)v5, (const void *)(*(void *)(a2 + 32) + 4 * (void)v5), 4 * v4 - 4 * (void)v5);
  }
  else if (v4)
  {
    double result = (void **)memmove(result[4], *(const void **)(a2 + 32), 4 * v4);
  }
  void v3[2] = (void *)v4;
  return result;
}

void re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), (_OWORD *)(v8 + 48));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 64;
    }
  }
}

void re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        ++v4;
        v5 += 64;
      }
      while (v4 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 64;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _OWORD *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v10 << 6)) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + (v10 << 6) + 16), a4);
  *(_OWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 48) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::DynamicArray<re::ShaderAPIFlags::Values>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::EvaluationCommand>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::ShaderAPIFlags::Values>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v8, a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v6 + 288 * v5 + 16, a2))
  {
    uint64_t v5 = *(_DWORD *)(v6 + 288 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v6 + 288 * v5 + 48;
}

uint64_t re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 8) = v1 & 0x7FFFFFFF;
    v3.n128_f64[0] = re::DynamicString::deinit((re::DynamicString *)(result + 16));
    unint64_t v4 = **(uint64_t (***)(uint64_t, __n128))(v2 + 48);
    return v4(v2 + 48, v3);
  }
  return result;
}

void re::HashTable<re::DynamicString,re::TextureProvider const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v21, 0, 36);
      *(void *)&v21[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v21, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v21;
      uint64_t v6 = *(unint64_t **)(a1 + 16);
      long long v7 = *(_OWORD *)&v21[8];
      *(_OWORD *)uint64_t v21 = v5;
      *(void *)&v21[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v21[24];
      *(_OWORD *)&v21[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v21[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            unint64_t v13 = *v6;
            unint64_t v14 = *(unsigned int *)(a1 + 24);
            unint64_t v15 = *v6 % v14;
            uint64_t v16 = *(unsigned int *)(a1 + 36);
            if (v16 == 0x7FFFFFFF)
            {
              uint64_t v16 = *(unsigned int *)(a1 + 32);
              int v17 = v16;
              if (v16 == v14)
              {
                re::HashTable<re::DynamicString,re::TextureProvider const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v15 = v13 % *(unsigned int *)(a1 + 24);
                int v17 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
            }
            else
            {
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v18 + 56 * v16 + 8) = v19 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 56 * v16 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v16 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(void *)(*(void *)(a1 + 16) + 56 * v16) = v13;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v16 + 16), (const re::DynamicString *)(v6 + 2));
            *(void *)(*(void *)(a1 + 16) + 56 * v16 + 48) = v6[6];
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v21);
    }
  }
  else
  {
    if (a2) {
      signed int v20 = a2;
    }
    else {
      signed int v20 = 3;
    }
  }
}

BOOL re::hasPhysicsMaterialAPI(void *a1)
{
  id v1 = a1;
  if (re::isRootNodeByPath(v1))
  {
    BOOL v2 = 0;
  }
  else
  {
    __n128 v3 = [v1 property:@"preliminary:physics:material:restitution"];
    BOOL v2 = v3 != 0;
  }
  return v2;
}

void re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 288 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::ecs2::TransformComponent *re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  __n128 v3 = (re::ecs2::TransformComponent *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::TransformComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                                             + 7)
                                                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::TransformComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 208, 0);
  unint64_t v4 = re::ecs2::TransformComponent::TransformComponent(v3);
  v6.n128_u64[0] = *(void *)((*(uint64_t (**)(re::ecs2::TransformComponent *))(*(void *)v4 + 40))(v4)
                             + 24) >> 1;
  v6.n128_u64[1] = (unint64_t)v3;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  return v3;
}

unint64_t re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                             + 7)
                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 440, 0);
  re::make::shared::inplace<re::ecs2::MeshDeformationComponent>(v3, &v10);
  unint64_t v4 = v10;
  unint64_t v5 = *(void *)((*(uint64_t (**)(unint64_t))(*(void *)v10 + 40))(v10) + 24) >> 1;
  unint64_t v6 = v10;
  unint64_t v10 = 0;
  v8.n128_u64[0] = v5;
  v8.n128_u64[1] = v6;
  char v9 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v8);
  if (v10) {

  }
  return v4;
}

void re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                                + 7)
                                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 496, 0);
  re::make::shared::inplace<re::ecs2::RigComponent>(v3, &v8);
  unint64_t v4 = v8;
  unint64_t v5 = *((void *)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
       + 3) >> 1;
  __n128 v8 = 0;
  v6.n128_u64[0] = v5;
  v6.n128_u64[1] = (unint64_t)v4;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  if (v8) {
}
  }

void re::ecs2::EntityAssetData::addComponent<re::ecs2::BlendShapeWeightsComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                                + 7)
                                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 368, 0);
  re::make::shared::inplace<re::ecs2::BlendShapeWeightsComponent>(v3, &v8);
  unint64_t v4 = v8;
  unint64_t v5 = *((void *)re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
       + 3) >> 1;
  unint64_t v8 = 0;
  v6.n128_u64[0] = v5;
  v6.n128_u64[1] = v4;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  if (v8) {
}
  }

void re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (void *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                       + 7)
                                                                    + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 3952, 0);
  double v4 = re::make::shared::inplace<re::ecs2::SkeletalPoseComponent>(v3, &v9);
  unint64_t v5 = *(void *)((*(uint64_t (**)(unint64_t, double))(*(void *)v9 + 40))(v9, v4) + 24) >> 1;
  unint64_t v6 = v9;
  unint64_t v9 = 0;
  v7.n128_u64[0] = v5;
  v7.n128_u64[1] = v6;
  char v8 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v7);
  if (v9) {
}
  }

id *re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (id *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                   + 7)
                                                                + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 336, 0);
  double v4 = re::ecs2::MeshComponent::MeshComponent(v3);
  v6.n128_u64[0] = *(void *)((*((uint64_t (**)(id *))*v4 + 5))(v4) + 24) >> 1;
  v6.n128_u64[1] = (unint64_t)v3;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  return v3;
}

uint64_t re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationLibraryComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                             + 7)
                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 120, 0);
  *(_OWORD *)uint64_t v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(void *)(v3 + 112) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v3, 0);
  *(void *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)unint64_t v4 = &unk_26E6DFB38;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 76) = 0u;
  *(void *)(v4 + 92) = 0x7FFFFFFFLL;
  *(void *)(v4 + 104) = 0;
  *(void *)(v4 + 112) = -1;
  v6.n128_u64[0] = *((void *)re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                   + 3) >> 1;
  v6.n128_u64[1] = v4;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  return v3;
}

uint64_t *re::make::shared::inplace<re::ecs2::MeshDeformationComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 432) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  unint64_t v4 = (id *)(a1 + 384);
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v5 + 16) = 0;
  *(unsigned char *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v5 = &unk_26E6DFE08;
  *(_OWORD *)(v5 + 104) = 0u;
  *(_OWORD *)(v5 + 120) = 0u;
  *(_DWORD *)(v5 + 136) = 0;
  *(_OWORD *)(v5 + 184) = 0u;
  *(_OWORD *)(v5 + 200) = 0u;
  *(_DWORD *)(v5 + 216) = 0;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_DWORD *)(v5 + 176) = 0;
  *(void *)(v5 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(v5 + 232) = 0;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_DWORD *)(v5 + 96) = 0;
  *(void *)(v5 + 240) = 0;
  *(void *)(v5 + 248) = -1;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  inited = (re *)objc_initWeak(v4, 0);
  *(void *)(a1 + 392) = 0;
  double result = re::globalAllocators(inited);
  *(void *)(a1 + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = result[2];
  *(void *)(a1 + 432) = 0;
  *a2 = a1;
  return result;
}

void re::ecs2::MeshDeformationComponent::~MeshDeformationComponent(re::ecs2::MeshDeformationComponent *this)
{
  *(void *)this = &unk_26E6DFE08;
  BOOL v2 = (char *)this + 192;
  re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::~FramePersistentPtr((id *)this + 48);
  re::FixedArray<re::MeshDeformationRuntimeData::DeformationMapping>::deinit((void *)this + 45);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 42);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 39);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 36);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 33);
  re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)v2);
  re::DynamicArray<re::DeformationStackDefinition>::deinit((uint64_t)this + 152);
  re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)this + 112);
  re::DynamicArray<re::DeformationStackDefinition>::deinit((uint64_t)this + 72);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshDeformationComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6DFE08;
  BOOL v2 = (char *)this + 192;
  re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::~FramePersistentPtr((id *)this + 48);
  re::FixedArray<re::MeshDeformationRuntimeData::DeformationMapping>::deinit((void *)this + 45);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 42);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 39);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 36);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 33);
  re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)v2);
  re::DynamicArray<re::DeformationStackDefinition>::deinit((uint64_t)this + 152);
  re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)this + 112);
  re::DynamicArray<re::DeformationStackDefinition>::deinit((uint64_t)this + 72);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshDeformationComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return 7;
}

void *re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::MeshDeformationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

id *re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      unint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6DFE90;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        unint64_t v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      uint64_t v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData>((re *)"reset", 161, (re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData *)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData>(re *result, uint64_t a2, re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData::~BuiltMeshDeformationData(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData **a2)
{
  return re::internal::destroyPersistent<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFE90;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFE90;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

void re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData::~BuiltMeshDeformationData(re::ecs2::MeshDeformationComponent::BuiltMeshDeformationData *this)
{
}

void *re::FixedArray<re::DeformationBufferAllocator>::deinit(void *result)
{
  if (*result)
  {
    id v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (void *)result[2];
      uint64_t v5 = &v4[6 * v2];
      do
      {
        re::FixedArray<re::DeformationBufferAllocator::DeformationStackAllocation>::deinit(v4);
        re::FixedArray<re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>>::deinit(v4 + 3);
        re::FixedArray<re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>>::deinit(v4 + 3);
        re::FixedArray<re::DeformationBufferAllocator::DeformationStackAllocation>::deinit(v4);
        v4 += 6;
      }
      while (v4 != v5);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *id v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>>::deinit(void *result)
{
  if (*result)
  {
    id v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = result[2];
      uint64_t v5 = 56 * v2;
      do
      {
        re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>::deinit(v4);
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
        v4 += 56;
        v5 -= 56;
      }
      while (v5);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *id v1 = 0;
  }
  return result;
}

uint64_t re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>::operator[](a1, i) + 16;
      re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::deinit(v4);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::DeformationBufferAllocator::DeformationStackAllocation,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 72 * (a2 & 3);
}

uint64_t re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](a1, i);
      uint64_t v5 = *(void **)(v4 + 24);
      if (v5)
      {

        *(void *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
      }
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 40 * (a2 & 3);
}

{
  unint64_t v2;
  uint64_t v3;

  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 40 * (a2 & 3);
}

void *re::FixedArray<re::DeformationBufferAllocator::DeformationStackAllocation>::deinit(void *result)
{
  if (*result)
  {
    id v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 72 * v2;
      uint64_t v5 = result[2] + 16;
      do
      {
        re::BucketArray<re::DeformationBufferAllocator::VertexBufferAllocation,4ul>::deinit(v5);
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v5);
        v5 += 72;
        v4 -= 72;
      }
      while (v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *id v1 = 0;
  }
  return result;
}

void *re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

id re::make::shared::inplace<re::ecs2::RigComponent>@<X0>(ArcSharedObject *a1@<X0>, ArcSharedObject **a2@<X8>)
{
  *((_OWORD *)a1 + 29) = 0u;
  *((_OWORD *)a1 + 30) = 0u;
  *((_OWORD *)a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 28) = 0u;
  *((_OWORD *)a1 + 25) = 0u;
  *((_OWORD *)a1 + 26) = 0u;
  *((_OWORD *)a1 + 23) = 0u;
  *((_OWORD *)a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *((_OWORD *)a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 22) = 0u;
  *((_OWORD *)a1 + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v4 = &unk_26E6E0690;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_DWORD *)(v4 + 128) = 0;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *(_DWORD *)(v4 + 168) = 0;
  *(void *)(v4 + 176) = 0;
  *(void *)(v4 + 18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 76) = 0u;
  *(void *)(v4 + 192) = -1;
  *(_OWORD *)(v4 + 248) = 0u;
  *(_OWORD *)(v4 + 232) = 0u;
  *(_OWORD *)(v4 + 216) = 0u;
  *(_OWORD *)(v4 + 200) = 0u;
  *(_OWORD *)(v4 + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 280) = 0u;
  *(_DWORD *)(v4 + 296) = 1;
  *(void *)(v4 + 312) = 0;
  *(void *)(v4 + 320) = 0;
  *(_DWORD *)(v4 + 328) = 0;
  *(void *)(v4 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_OWORD *)(v4 + 352) = 0u;
  *(_OWORD *)(v4 + 368) = 0u;
  *(_OWORD *)(v4 + 38re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_OWORD *)(v4 + 428) = 0u;
  *(void *)(v4 + 44re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0x7FFFFFFFLL;
  *(void *)(v4 + 46re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v4 + 472) = 0;
  *(void *)(v4 + 456) = 0;
  *((unsigned char *)a1 + 480) = 0;
  id result = objc_initWeak((id *)(v4 + 488), 0);
  *a2 = a1;
  return result;
}

void re::ecs2::RigComponent::~RigComponent(re::ecs2::RigComponent *this)
{
  re::ecs2::RigComponent::~RigComponent(this);
  JUMPOUT(0x237DBCBD0);
}

{
  objc_destroyWeak((id *)this + 61);
  *((void *)this + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
  re::FixedArray<re::DynamicArray<re::RigRuntimeData::RigGraphRunTimeBoundParameter>>::deinit((void *)this + 57);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 51);
  re::FixedArray<re::DynamicArray<re::RigHierarchyJointDescription>>::deinit((void *)this + 48);
  re::BindNode::deinit((re::ecs2::RigComponent *)((char *)this + 344));
  re::BucketArray<re::RigEnvironment::RigEnvironmentScope,8ul>::deinit((uint64_t)this + 280);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 280);
  re::FixedArray<re::RigEvaluation>::deinit((uint64_t)this + 248);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 28);
  re::FixedArray<re::FixedArray<float>>::deinit((void *)this + 25);
  re::DynamicArray<re::MeshRigGraphIndex>::deinit((uint64_t)this + 144);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 104);
  re::DynamicArray<re::RigDefinition>::deinit((uint64_t)this + 64);
  re::AssetHandle::~AssetHandle((re::ecs2::RigComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::BlendShapeWeightsComponent>@<D0>(ArcSharedObject *a1@<X0>, void *a2@<X8>)
{
  *((_OWORD *)a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 22) = 0u;
  *((_OWORD *)a1 + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  uint64_t v3 = (_OWORD *)((char *)a1 + 144);
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v4 = &unk_26E6DFBC0;
  double result = 0.0;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *(_DWORD *)(v4 + 168) = 0;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_DWORD *)(v4 + 208) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 116) = 0u;
  *(_OWORD *)(v4 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_DWORD *)(v4 + 80) = 0;
  *(void *)(v4 + 216) = 0;
  *(void *)(v4 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v4 + 104;
  *(void *)(v4 + 232) = v3;
  *(void *)(v4 + 240) = 0;
  *(void *)(v4 + 248) = -1;
  *(void *)(v4 + 360) = 0;
  *(_DWORD *)(v4 + 352) = 0;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_OWORD *)(v4 + 288) = 0u;
  *(_OWORD *)(v4 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 256) = 0u;
  *(_OWORD *)(v4 + 272) = 0u;
  *a2 = v4;
  return result;
}

void re::ecs2::BlendShapeWeightsComponent::~BlendShapeWeightsComponent(re::ecs2::BlendShapeWeightsComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)this + 328);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 35);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 184);
  re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)this + 144);
  re::DynamicArray<re::FixedArray<re::StringID>>::deinit((uint64_t)this + 104);
  re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::BlendShapeWeightsComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

uint64_t re::DynamicArray<re::BlendShapeWeights>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::BlendShapeWeights **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 32 * v4;
        do
        {
          re::BlendShapeWeights::~BlendShapeWeights(v3);
          uint64_t v3 = (re::BlendShapeWeights *)((char *)v3 + 32);
          v5 -= 32;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::BlendShapeWeights **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::BlendShapeWeights *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::make::shared::inplace<re::ecs2::SkeletalPoseComponent>@<D0>(void *a1@<X0>, void *a2@<X8>)
{
  bzero(a1, 0xF70uLL);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  a1[2] = 0;
  *((unsigned char *)a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *a1 = &unk_26E6E0718;
  *(_OWORD *)(a1 + 23) = 0u;
  *(_OWORD *)(a1 + 25) = 0u;
  *((_DWORD *)a1 + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_DWORD *)a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(a1 + 33) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 35) = 0u;
  *((_DWORD *)a1 + 7re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)a1 + re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_DWORD *)a1 + 8re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(a1 + 43) = 0u;
  *(_OWORD *)(a1 + 45) = 0u;
  *((_DWORD *)a1 + 9re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_DWORD *)a1 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *((_OWORD *)a1 + 25) = 0u;
  *((_DWORD *)a1 + 11re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(a1 + 53) = 0u;
  *(_OWORD *)(a1 + 55) = 0u;
  *((_DWORD *)a1 + 30) = 0;
  *(_OWORD *)(a1 + re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 0u;
  *(_OWORD *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_DWORD *)a1 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 29) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_DWORD *)a1 + 20) = 0;
  a1[60] = -1;
  *((_DWORD *)a1 + 186) = 0;
  *(_OWORD *)(a1 + 89) = 0u;
  *(_OWORD *)(a1 + 9re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *(_OWORD *)(a1 + 85) = 0u;
  *(_OWORD *)(a1 + 8re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *(_OWORD *)(a1 + 8re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  *(_OWORD *)(a1 + 7re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *(_OWORD *)(a1 + 79) = 0u;
  *(_OWORD *)(a1 + 73) = 0u;
  *(_OWORD *)(a1 + 75) = 0u;
  *(_OWORD *)(a1 + 69) = 0u;
  *(_OWORD *)(a1 + 7re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *(_OWORD *)(a1 + 65) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *(_OWORD *)(a1 + 63) = 0u;
  a1[94] = -1;
  a1[102] = 0;
  *(_OWORD *)(a1 + 95) = 0u;
  *(_OWORD *)(a1 + 9re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 7) = 0u;
  re::EvaluationContextManager::EvaluationContextManager((re::EvaluationContextManager *)(a1 + 103));
  double result = 0.0;
  *((_OWORD *)a1 + 239) = 0u;
  a1[474] = 0;
  *(_OWORD *)(a1 + 475) = 0u;
  *((unsigned char *)a1 + 3816) = 0;
  *((_DWORD *)a1 + 960) = 1;
  a1[493] = 0;
  *(_OWORD *)(a1 + 48re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *(_OWORD *)(a1 + 483) = 0u;
  *(_OWORD *)(a1 + 485) = 0u;
  *((_DWORD *)a1 + 97re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)a1 + 24re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + 245) = 0u;
  *((_DWORD *)a1 + 98re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *a2 = a1;
  return result;
}

void re::ecs2::SkeletalPoseComponent::~SkeletalPoseComponent(re::ecs2::SkeletalPoseComponent *this)
{
  re::ecs2::SkeletalPoseComponent::~SkeletalPoseComponent(this);
  JUMPOUT(0x237DBCBD0);
}

{
  char *v2;

  *(void *)this = &unk_26E6E0718;
  uint64_t v2 = (char *)this + 232;
  re::DynamicArray<re::SkeletalPose>::deinit((uint64_t)this + 3912);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 3872);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 3824);
  re::FixedArray<re::BindPoint>::deinit((void *)this + 474);
  re::EvaluationContextManager::~EvaluationContextManager((re::ecs2::SkeletalPoseComponent *)((char *)this + 824));
  std::unique_ptr<re::EvaluationModelBase,std::function<void ()(re::EvaluationModelBase*)>>::~unique_ptr[abi:nn180100]((uint64_t *)this + 98);
  re::FixedArray<re::EvaluationRigState>::deinit((void *)this + 95);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 88);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 85);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 82);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 79);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 76);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 73);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 70);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 67);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 64);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 61);
  re::DynamicArray<re::MeshRigGraphIndex>::deinit((uint64_t)this + 432);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)this + 392);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)this + 352);
  re::DynamicArray<re::FixedArray<re::StringID>>::deinit((uint64_t)this + 312);
  re::DynamicArray<re::FixedArray<re::StringID>>::deinit((uint64_t)this + 272);
  re::DynamicArray<re::StringID>::deinit((uint64_t)v2);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 192);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 152);
  re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)this + 96);
  re::DynamicArray<re::SkeletalPose>::deinit((uint64_t)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::SkeletalPoseComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return 13;
}

void *re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

id *re::ecs2::MeshComponent::MeshComponent(id *this)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)this, 0);
  *(void *)(v2 + 16) = 0;
  *(unsigned char *)(v2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v2 = &unk_26E6DFCD0;
  *(void *)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 96) = 0;
  *(void *)(v2 + 136) = 0;
  *(void *)(v2 + 112) = 0;
  *(void *)(v2 + 120) = 0;
  *(void *)(v2 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_DWORD *)(v2 + 128) = 0;
  *(_DWORD *)(v2 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(unsigned char *)(v2 + 192) = 0;
  *(_OWORD *)(v2 + 208) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 0;
  inited = (re *)objc_initWeak((id *)(v2 + 224), 0);
  this[29] = 0;
  this[33] = (id)re::globalAllocators(inited)[2];
  this[34] = 0;
  uint64_t v4 = (re *)objc_initWeak(this + 35, 0);
  this[36] = 0;
  this[40] = (id)re::globalAllocators(v4)[2];
  this[41] = 0;
  *((_DWORD *)this + 36) = atomic_fetch_add(re::ecs2::MeshComponent::MeshComponent(void)::s_atomicCounter, 1u);
  return this;
}

void re::ecs2::MeshComponent::~MeshComponent(id *this)
{
  *this = &unk_26E6DFCD0;
  uint64_t v2 = (re::AssetHandle *)(this + 4);
  re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::~FramePersistentPtr(this + 35);
  re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::~FramePersistentPtr(this + 28);
  re::DynamicArray<re::ecs2::EntityHandle>::deinit((uint64_t)(this + 13));
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)(this + 7));
  re::AssetHandle::~AssetHandle(v2);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *this = &unk_26E6DFCD0;
  uint64_t v2 = (re::AssetHandle *)(this + 4);
  re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::~FramePersistentPtr(this + 35);
  re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::~FramePersistentPtr(this + 28);
  re::DynamicArray<re::ecs2::EntityHandle>::deinit((uint64_t)(this + 13));
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)(this + 7));
  re::AssetHandle::~AssetHandle(v2);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return 6;
}

void *re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

id *re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      unint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6DFD58;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        unint64_t v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      uint64_t v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::MeshComponent::StaticBoundingBoxData>((re *)"reset", 161, (uint64_t *)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::MeshComponent::StaticBoundingBoxData>(re *result, uint64_t a2, uint64_t *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(a3 + 21));
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(a3 + 12));
    re::FixedArray<CoreIKTransform>::deinit(a3 + 3);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::StaticBoundingBoxData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::StaticBoundingBoxData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, uint64_t **a2)
{
  return re::internal::destroyPersistent<re::ecs2::MeshComponent::StaticBoundingBoxData>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::StaticBoundingBoxData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFD58;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::StaticBoundingBoxData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFD58;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::StaticBoundingBoxData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::StaticBoundingBoxData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

id *re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      unint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6DFDB0;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        unint64_t v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      uint64_t v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::MeshComponent::MaterialData>((re *)"reset", 161, (re::ecs2::MeshComponent::MaterialData *)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::MeshComponent::MaterialData>(re *result, uint64_t a2, re::ecs2::MeshComponent::MaterialData *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::ecs2::MeshComponent::MaterialData::~MaterialData(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, re::ecs2::MeshComponent::MaterialData *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::MaterialData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::MaterialData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, re::ecs2::MeshComponent::MaterialData **a2)
{
  return re::internal::destroyPersistent<re::ecs2::MeshComponent::MaterialData>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::MaterialData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFDB0;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::MaterialData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFDB0;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshComponent::MaterialData,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshComponent::MaterialData*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

void re::ecs2::MeshComponent::MaterialData::~MaterialData(re::ecs2::MeshComponent::MaterialData *this)
{
  uint64_t v2 = (char *)this + 456;
  re::BucketArray<re::SharedPtr<re::UnlitParameterTable>,8ul>::deinit((uint64_t)this + 456);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  re::BucketArray<re::SharedPtr<re::UnlitParameterTable>,8ul>::deinit((uint64_t)this + 400);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 400);
  re::BucketArray<re::SharedPtr<re::UnlitParameterTable>,8ul>::deinit((uint64_t)this + 344);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 344);
  re::FixedArray<re::FixedArray<float>>::deinit((void *)this + 40);
  re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::deinit((uint64_t)this + 264);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 264);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 27);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 24);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 21);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 18);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 15);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 12);
  re::DynamicArray<re::TextureHandle>::deinit((uint64_t)this + 48);
  re::FixedArray<re::FixedArray<float>>::deinit((void *)this + 3);
  re::FixedArray<re::FixedArray<float>>::deinit(this);
}

uint64_t re::BucketArray<re::SharedPtr<re::UnlitParameterTable>,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](a1, i);
      if (*(void *)v4)
      {
        uint64_t v5 = (void *)v4;

        *uint64_t v5 = 0;
      }
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::DynamicArray<re::TextureHandle>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::TextureHandle **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 16 * v4;
        do
        {
          re::TextureHandle::invalidate(v3);
          uint64_t v3 = (re::TextureHandle *)((char *)v3 + 16);
          v5 -= 16;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::TextureHandle **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::TextureHandle *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::ecs2::EntityHandle>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::ecs2::EntityHandle **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 24 * v4;
        do
        {
          re::ecs2::EntityHandle::reset(v3);
          objc_destroyWeak((id *)v3);
          *(void *)uint64_t v3 = 0;
          uint64_t v3 = (re::ecs2::EntityHandle *)((char *)v3 + 24);
          v5 -= 24;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::ecs2::EntityHandle **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::ecs2::EntityHandle *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

void re::ecs2::AnimationLibraryComponent::~AnimationLibraryComponent(re::ecs2::AnimationLibraryComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7);
  re::AssetHandle::~AssetHandle((re::ecs2::AnimationLibraryComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

uint64_t re::DynamicArray<re::SkeletalPoseSampledAnimation>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = &v3[15 * v4];
        uint64_t v6 = *(void *)(a1 + 32);
        do
        {
          *uint64_t v3 = &unk_26E6C0FD0;
          re::FixedArray<re::SkeletalPose>::deinit(v3 + 11);
          *uint64_t v3 = &unk_26E6BF1F0;
          re::DynamicString::deinit((re::DynamicString *)(v3 + 5));
          re::StringID::destroyString((re::StringID *)(v3 + 3));
          v6 += 120;
          v3 += 15;
        }
        while (v3 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::ModelIOSkinningData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 224 * v4;
        do
        {
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 200));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 176));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 152));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 128));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 104));
          re::DynamicString::deinit((re::DynamicString *)(v3 + v5 + 72));
          v5 += 224;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::ModelIOSkeleton>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 168 * v4;
        do
        {
          re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v3 + v5 + 120));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 96));
          re::FixedArray<re::StringID>::deinit((void *)(v3 + v5 + 72));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 48));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 24));
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 168;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::loadMDLObject(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v198 = *MEMORY[0x263EF8340];
  id v7 = a2;
  char v8 = [v7 name];
  if (!v8) {
    char v8 = &stru_26E738380;
  }
  unint64_t v9 = v8;
  unint64_t v10 = (_anonymous_namespace_ *)[(__CFString *)v9 UTF8String];
  *(void *)&long long v175 = 0;
  *((void *)&v175 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
  long long v11 = v175;
  *(void *)&long long v175 = 0;
  *((void *)&v175 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
  uint64_t v12 = *(void *)(a3 + 8);
  unint64_t v13 = *(objc_class **)(a3 + 16);
  *(_OWORD *)(a3 + 8) = v11;
  v184[1].super.isa = v13;
  v184[0].super.isa = (Class)(v11 & 0xFFFFFFFFFFFFFFFELL | v12 & 1);
  re::StringID::destroyString((re::StringID *)v184);
  re::StringID::destroyString((re::StringID *)&v175);
  id v14 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>((_DWORD *)a3);
  uint64_t v15 = [v7 transform];
  id v16 = v15;
  if (v15)
  {
    [v15 matrix];
    float32x4_t v18 = v17;
    float32x4_t v20 = v19;
    *((_OWORD *)v14 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v21;
    float32x4_t v22 = vmulq_f32(v17, v17);
    int32x2_t v145 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).u64[0];
    *(float32x2_t *)&long long v21 = vrsqrte_f32((float32x2_t)v145.u32[0]);
    *(float32x2_t *)&long long v21 = vmul_f32(*(float32x2_t *)&v21, vrsqrts_f32((float32x2_t)v145.u32[0], vmul_f32(*(float32x2_t *)&v21, *(float32x2_t *)&v21)));
    float32x4_t v142 = v18;
    v199.columns[0] = (simd_float3)vmulq_n_f32(v18, vmul_f32(*(float32x2_t *)&v21, vrsqrts_f32((float32x2_t)v145.u32[0], vmul_f32(*(float32x2_t *)&v21, *(float32x2_t *)&v21))).f32[0]);
    float32x4_t v24 = vmulq_f32(v23, (float32x4_t)v199.columns[0]);
    float32x4_t v25 = vmulq_f32((float32x4_t)v199.columns[0], (float32x4_t)v199.columns[0]);
    v25.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0];
    obuint64_t j = v23;
    float32x4_t v26 = vsubq_f32(v23, vmulq_n_f32((float32x4_t)v199.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0]/ v25.f32[0]));
    int32x4_t v27 = (int32x4_t)vmulq_f32(v26, v26);
    v27.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
    *(float32x2_t *)v18.f32 = vrsqrte_f32((float32x2_t)v27.u32[0]);
    *(float32x2_t *)v18.f32 = vmul_f32(*(float32x2_t *)v18.f32, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v18.f32)));
    v27.i32[0] = vmul_f32(*(float32x2_t *)v18.f32, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v18.f32))).u32[0];
    float32x4_t v28 = vmulq_f32(v20, (float32x4_t)v199.columns[0]);
    v199.columns[1] = (simd_float3)vmulq_n_f32(v26, *(float *)v27.i32);
    float32x4_t v29 = vsubq_f32(v20, vmulq_n_f32((float32x4_t)v199.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]/ v25.f32[0]));
    float32x4_t v149 = v20;
    float32x4_t v30 = vmulq_f32(v20, (float32x4_t)v199.columns[1]);
    float32x4_t v31 = vmulq_f32((float32x4_t)v199.columns[1], (float32x4_t)v199.columns[1]);
    float32x4_t v32 = vsubq_f32(v29, vmulq_n_f32((float32x4_t)v199.columns[1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0]));
    int32x4_t v33 = (int32x4_t)vmulq_f32(v32, v32);
    v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
    *(float32x2_t *)v31.f32 = vrsqrte_f32((float32x2_t)v33.u32[0]);
    *(float32x2_t *)v31.f32 = vmul_f32(*(float32x2_t *)v31.f32, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v31.f32)));
    v199.columns[2] = (simd_float3)vmulq_n_f32(v32, vmul_f32(*(float32x2_t *)v31.f32, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v31.f32))).f32[0]);
    double v34 = simd_quaternion(v199);
    uint64_t v36 = v35;
    double v37 = v34;
    float32x4_t v38 = vmulq_f32(v142, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v149, (int8x16_t)v149, 0xCuLL), (int8x16_t)v149, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)obj, (int32x4_t)obj), (int8x16_t)obj, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v149, (int32x4_t)v149), (int8x16_t)v149, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)obj, (int8x16_t)obj, 0xCuLL), (int8x16_t)obj, 8uLL)));
    *((double *)v14 + 6) = v37;
    *((void *)v14 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v36;
    BOOL v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0] <= 0.0;
    float v40 = -1.0;
    if (!v39) {
      float v40 = 1.0;
    }
    float32x4_t v41 = vmulq_f32(obj, obj);
    *(float32x2_t *)v41.f32 = vsqrt_f32((float32x2_t)vzip1_s32(v145, (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v41, 2), vadd_f32(*(float32x2_t *)v41.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v41.f32, 1)))));
    float32x4_t v42 = vmulq_f32(v149, v149);
    v41.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0]);
    *((float32x4_t *)v14 + 2) = vmulq_n_f32(v41, v40);
  }
  else
  {
    *((void *)v14 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0x3F8000003F800000;
    *((void *)v14 + 5) = 1065353216;
    *((void *)v14 + 6) = 0;
    *((void *)v14 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0x3F80000000000000;
    *((void *)v14 + 8) = 0;
    *((void *)v14 + 9) = 0;
  }
  id v43 = v7;
  objc_opt_class();
  BOOL v45 = 1;
  uint64_t v144 = v9;
  char v146 = v43;
  int v143 = v16;
  if (objc_opt_isKindOfClass())
  {
    id v46 = v43;
    uint64_t v47 = [v46 name];
    *(_WORD *)&buf[2] = 257;
    uint8_t buf[4] = 1;
    if (v47) {
      uint64_t v48 = (__CFString *)v47;
    }
    else {
      uint64_t v48 = &stru_26E738380;
    }
    *(_DWORD *)&buf[5] = 0;
    buf[9] = 0;
    *(_DWORD *)&unsigned char buf[12] = 1036831949;
    memset(&buf[24], 0, 48);
    *(_DWORD *)&buf[60] = 0x7FFFFFFF;
    buf[10] = *(unsigned char *)(a1 + 161);
    buf[1] = *(unsigned char *)(a1 + 162);
    buf[6] = *(unsigned char *)(a1 + 165);
    buf[20] = buf[6];
    *(_DWORD *)&uint8_t buf[16] = 256;
    buf[0] = 0;
    uint64_t v172 = 0;
    uint64_t v173 = 0;
    uint64_t v174 = 0;
    re::DynamicString::setCapacity(&v171, 0);
    re::GeomModel::GeomModel((re::GeomModel *)v184);
    id v150 = v46;
    *(void *)&long long v175 = v150;
    re::convertMDLMeshToGeomModel((id *)&v175, (unsigned __int8 *)v184, a4, a5, &buf[16]);

    MeshAssetDataWithGeomModel = (re::TimelineAsset *)re::makeMeshAssetDataWithGeomModel((re::DynamicString *)v184, 0, 0, (uint64_t)&v175);
    *(void *)&long long v158 = 0;
    *(void *)&long long v157 = 0;
    long long v156 = 0uLL;
    DWORD2(v15re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
    uint64_t v50 = *(void *)(a6 + 136);
    if (v50)
    {
      id v51 = (uint64_t *)(*(void *)(a6 + 152) + 16);
      uint64_t v52 = 32 * v50;
      do
      {
        unint64_t v53 = *(v51 - 1);
        if (v53) {
          uint64_t v54 = *v51;
        }
        else {
          uint64_t v54 = (uint64_t)v51 - 7;
        }
        uint64_t v55 = v53 >> 1;
        uint64_t v56 = v53 >> 1;
        if (*(v51 - 1)) {
          uint64_t v57 = v55;
        }
        else {
          uint64_t v57 = v56;
        }
        size_t v58 = re::TimelineAsset::assetType(MeshAssetDataWithGeomModel);
        re::ImportAssetTable::compiledAssetPath(v54, v57, (re **)v58, (re::DynamicString *)v162);
        double v59 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&v156, v162);
        MeshAssetDataWithGeomModel = *(re::TimelineAsset **)v162;
        if (*(void *)v162 && (v162[8] & 1) != 0) {
          MeshAssetDataWithGeomModel = (re::TimelineAsset *)(*(uint64_t (**)(double))(**(void **)v162 + 40))(v59);
        }
        v51 += 4;
        v52 -= 32;
      }
      while (v52);
    }
    if ((_BYTE)v175)
    {
      re::DynamicArray<re::MeshAssetModel>::DynamicArray((uint64_t)v162, (uint64_t *)&v175 + 1);
      re::DynamicArray<re::MeshAssetInstance>::DynamicArray((uint64_t)&v163 + 8, (uint64_t *)v179);
      re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray((uint64_t)&v166, (uint64_t *)&v180 + 1);
      re::DynamicArray<float>::DynamicArray((uint64_t)&v168 + 8, v183);
    }
    else
    {
      long long v169 = 0u;
      long long v170 = 0u;
      long long v167 = 0u;
      long long v168 = 0u;
      long long v165 = 0u;
      long long v166 = 0u;
      long long v163 = 0u;
      long long v164 = 0u;
      memset(v162, 0, sizeof(v162));
    }
    uint64_t v60 = re::AnimationLibraryAsset::buildAsset(v162, a6 + 120, a6 + 80, a6 + 40, (uint64_t)&v156);
    if (*((void *)&v168 + 1))
    {
      if (*((void *)&v170 + 1)) {
        (*(void (**)(void))(**((void **)&v168 + 1) + 40))();
      }
      *((void *)&v170 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      long long v169 = 0uLL;
      *((void *)&v168 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      LODWORD(v170) = v170 + 1;
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v166);
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v163 + 8);
    int v61 = (re *)re::DynamicArray<re::MeshAssetModel>::deinit(v162);
    int v62 = v175;
    long long v63 = re::globalAllocators(v61);
    long long v64 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v63[2] + 32))(v63[2], 960, 8);
    if (v62) {
      uint64_t v65 = re::MeshAsset::MeshAsset((uint64_t)v64, (uint64_t)&v175 + 8);
    }
    else {
      re::MeshAsset::MeshAsset(v64);
    }
    *(_DWORD *)(v65 + 9re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 1;
    if (a4 && a5 && *(void *)(a4 + 16))
    {
      uint64_t v66 = (void *)v65;
      uint64_t v67 = (void *)v60;
      uint64_t v68 = *(void *)(a5 + 16);
      re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>((_DWORD *)a3);
      re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>((_DWORD *)a3);
      if (v68) {
        re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>((_DWORD *)a3);
      }
    }
    else
    {
      uint64_t v66 = (void *)v65;
      uint64_t v67 = (void *)v60;
      re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>((_DWORD *)a3);
      re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>((_DWORD *)a3);
    }
    re::ecs2::EntityAssetData::addComponent<re::ecs2::BlendShapeWeightsComponent>((_DWORD *)a3);
    uint64_t v69 = v48;
    uint64_t v70 = (_anonymous_namespace_ *)[(__CFString *)v69 UTF8String];
    for (uint64_t i = 1; ; uint64_t i = (i + 1))
    {
      uint64_t v73 = *(void *)(a1 + 104);
      uint64_t v74 = (v162[8] & 1) != 0 ? *(unsigned char **)&v162[16] : &v162[9];
      uint64_t v75 = (v162[8] & 1) != 0 ? *(void *)&v162[8] >> 1 : v162[8] >> 1;
      uint64_t v76 = re::MeshAsset::assetType(v71);
      if (!re::ImportAssetTable::importedAsset(v73, (uint64_t)v74, v75, (re **)v76)) {
        break;
      }
      re::DynamicString::format((re::DynamicString *)"%s-%d", (re::DynamicString *)&v160, [(__CFString *)v69 UTF8String], i);
      re::DynamicString::operator=((re::DynamicString *)v162, (re::DynamicString *)&v160);
      uint64_t v71 = v160;
      if (v160)
      {
        if (v161[0]) {
          uint64_t v71 = (re::MeshAsset *)(*(uint64_t (**)(void))(*(void *)v160 + 40))();
        }
      }
    }
    unint64_t v77 = *(_anonymous_namespace_ **)(a1 + 104);
    uint64_t v78 = v69;
    unint64_t v79 = (const char *)[(__CFString *)v78 UTF8String];
    int v80 = (re::MeshAsset *)strlen(v79);
    int v81 = re::MeshAsset::assetType(v80);
    int v82 = (re::DynamicString *)re::ImportAssetTable::addAsset(v77, (uint64_t)v79, (uint64_t)v80, v66, (re **)v81);
    re::DynamicString::operator=((re::DynamicString *)&v171, v82);
    uint64_t v83 = v67;
    unint64_t v9 = v144;
    id v43 = v146;
    id v16 = v143;
    if (v83)
    {
      uint64_t v84 = (re::AnimationLibraryAsset *)re::DynamicString::format((re::DynamicString *)"%s_animationlibrary", (re::DynamicString *)&v160, *(void *)(a3 + 16));
      uint64_t v85 = *(_anonymous_namespace_ **)(a1 + 104);
      int v86 = (v161[0] & 1) != 0 ? (void *)v161[1] : (void *)((char *)v161 + 1);
      uint64_t v87 = (v161[0] & 1) != 0 ? v161[0] >> 1 : LOBYTE(v161[0]) >> 1;
      int v88 = re::AnimationLibraryAsset::assetType(v84);
      uint64_t v89 = re::ImportAssetTable::addAsset(v85, (uint64_t)v86, v87, v83, (re **)v88);
      int v90 = (_anonymous_namespace_ *)re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationLibraryComponent>((_DWORD *)a3);
      unint64_t v91 = (_anonymous_namespace_ *)((char *)v90 + 32);
      unint64_t v92 = (*(unsigned char *)(v89 + 8) & 1) != 0 ? *(re::AssetPath **)(v89 + 16) : (re::AssetPath *)(v89 + 9);
      if (v160)
      {
        if (v161[0]) {
          (*(void (**)(void))(*(void *)v160 + 40))();
        }
      }
    }
    if (*(void *)v162 && (v162[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)v162 + 40))();
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v156);
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v175);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)&v196);
    if (v194) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v195);
    }
    if ((_BYTE)v192) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v193);
    }
    if (v189)
    {
      if (*((void *)&v191 + 1)) {
        (*(void (**)(void))(*(void *)v189 + 40))();
      }
      *((void *)&v191 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      long long v190 = 0uLL;
      uint64_t v189 = 0;
      LODWORD(v19re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v191 + 1;
      id v43 = v146;
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v186);
    if (v184[0].super.isa && ((uint64_t)v184[1].super.isa & 1) != 0) {
      (*(void (**)(void))(*(void *)v184[0].super.isa + 40))();
    }
    *(void *)&long long v178 = 0;
    uint64_t v176 = 0;
    long long v175 = 0uLL;
    LODWORD(v17re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
    id v93 = v150;
    *(void *)__n128 v162 = v93;
    int v186 = 0;
    *(_OWORD *)&v184[0].super.isa = 0u;
    long long v185 = 0u;
    *(void *)int v187 = 0x7FFFFFFFLL;
    re::collectMeshMaterialsFromMDLMesh((id *)v162, (uint64_t)v184, *(unsigned __int8 *)(a1 + 165));
    re::createMaterialAssetsFromMaterialTable(a1, (uint64_t)v184, (_anonymous_namespace_ *)&v175);
    re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v184);

    unint64_t v94 = re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>((_DWORD *)a3);
    uint64_t v95 = v94;
    uint64_t v96 = (re::DynamicString *)(v94 + 4);
    if (v172) {
      uint64_t v97 = v173;
    }
    else {
      uint64_t v97 = (re::AssetPath *)((char *)&v172 + 1);
    }
    re::DynamicArray<re::AssetHandle>::operator=((uint64_t)(v95 + 7), (uint64_t *)&v175);
    BOOL v45 = !re::objectIsBlendShapeRoot((re *)v93, v98);
    re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v175);
    if (v171 && (v172 & 1) != 0) {
      (*(void (**)(void))(*v171 + 40))();
    }
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&buf[24]);
  }
  if (re::hasTransformAnimation((re *)v43, v44))
  {
    re::TimelineAssetData::TimelineAssetData((uint64_t)v184, 33);
    LOWORD(v189) = 256;
    HIDWORD(v189) = 1023969417;
    v193[0] = 0;
    long long v190 = 0u;
    long long v191 = 0u;
    int v192 = 0;
    v184[0].super.isa = (Class)&unk_26E6D0CB8;
    LOBYTE(v175) = 1;
    re::importSRTSampledAnimation((re *)v43, v184, 0.016667, (uint64_t)v162);
    uint64_t v99 = (re *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)&v175, (uint64_t)v162);
    if (!v162[0])
    {
      uint64_t v99 = *(re **)&v162[24];
      if (*(void *)&v162[24])
      {
        if (v163) {
          uint64_t v99 = (re *)(*(uint64_t (**)(void))(**(void **)&v162[24] + 40))();
        }
      }
    }
    if ((_BYTE)v175)
    {
      id v100 = [v43 name];
      uint64_t v101 = (const char *)[v100 UTF8String];

      float32x4_t v103 = re::globalAllocators(v102);
      uint64_t v104 = (re::AssetHelper *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v103[2] + 32))(v103[2], 128, 8);
      re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData((uint64_t)v104, (uint64_t)v184);
      *uint64_t v105 = &unk_26E6D0CB8;
      *(void *)__n128 v162 = "Transform.transform";
      *(void *)&v162[8] = 19;
      re::DynamicString::operator=((re::DynamicString *)(v105 + 5), (uint64_t)v162);
      TimelineAsset = re::AssetHelper::makeTimelineAsset(v104, v106);
      float32x4_t v108 = *(_anonymous_namespace_ **)(a1 + 104);
      int32x4_t v109 = (re::TimelineAsset *)strlen(v101);
      int v110 = re::TimelineAsset::assetType(v109);
      int v111 = (_anonymous_namespace_ *)re::ImportAssetTable::addAsset(v108, (uint64_t)v101, (uint64_t)v109, TimelineAsset, (re **)v110);
      *(void *)&long long v163 = 0;
      memset(v162, 0, 28);
      double v112 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v162, buf);
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(double))(**(void **)buf + 40))(v112);
      }
      *(void *)&uint8_t buf[32] = 0;
      memset(buf, 0, 28);
      re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)buf, v111);
      uint64_t v113 = re::AnimationLibraryAsset::buildAsset((_anonymous_namespace_ *)v162, (uint64_t)buf);
      if (v113)
      {
        BOOL v114 = (void *)v113;
        id v115 = (re::AnimationLibraryAsset *)re::DynamicString::format((re::DynamicString *)"%s_animationlibrary", (re::DynamicString *)&v156, *(void *)(a3 + 16));
        id v116 = *(_anonymous_namespace_ **)(a1 + 104);
        unsigned int v117 = (BYTE8(v156) & 1) != 0 ? (long long *)v157 : (long long *)((char *)&v156 + 9);
        uint64_t v118 = (BYTE8(v156) & 1) != 0 ? *((void *)&v156 + 1) >> 1 : BYTE8(v156) >> 1;
        unint64_t v119 = re::AnimationLibraryAsset::assetType(v115);
        uint64_t v120 = re::ImportAssetTable::addAsset(v116, (uint64_t)v117, v118, v114, (re **)v119);
        uint64_t v121 = (_anonymous_namespace_ *)re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationLibraryComponent>((_DWORD *)a3);
        int v122 = (_anonymous_namespace_ *)((char *)v121 + 32);
        float v123 = (*(unsigned char *)(v120 + 8) & 1) != 0 ? *(re::AssetPath **)(v120 + 16) : (re::AssetPath *)(v120 + 9);
        if ((void)v156)
        {
          if (BYTE8(v156)) {
            (*(void (**)(void))(*(void *)v156 + 40))();
          }
        }
      }
      re::DynamicArray<re::DynamicString>::deinit((uint64_t)buf);
      re::DynamicArray<re::DynamicString>::deinit((uint64_t)v162);
    }
    else
    {
      int v124 = (id)*re::pipelineLogObjects(v99);
      if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message((std::string *)v162, (const std::error_code *)((char *)&v175 + 8));
        uint64_t v140 = v162[23] >= 0 ? v162 : *(unsigned char **)v162;
        unint64_t v141 = (v178 & 1) != 0 ? (long long *)*((void *)&v178 + 1) : (long long *)((char *)&v178 + 1);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v140;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v141;
        _os_log_error_impl(&dword_233120000, v124, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", buf, 0x16u);
        if ((v162[23] & 0x80000000) != 0) {
          operator delete(*(void **)v162);
        }
      }
    }
    if (!(_BYTE)v175 && v177 && (v178 & 1) != 0) {
      (*(void (**)(void))(*(void *)v177 + 40))();
    }
    v184[0].super.isa = (Class)&unk_26E6D0D28;
    if (*((void *)&v190 + 1))
    {
      if (v193[0]) {
        (*(void (**)(void))(**((void **)&v190 + 1) + 40))();
      }
      v193[0] = 0;
      long long v191 = 0uLL;
      *((void *)&v190 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      ++v192;
    }
    v184[0].super.isa = (Class)&unk_26E6D3730;
    id v43 = v146;
    if (*(void *)&v187[4])
    {
      if (v187[12]) {
        (*(void (**)(void))(**(void **)&v187[4] + 40))();
      }
      *(_OWORD *)&v187[4] = 0u;
      long long v188 = 0u;
    }
    re::StringID::destroyString((re::StringID *)((char *)&v185 + 8));
  }
  uint64_t v125 = [v43 componentConformingToProtocol:&unk_26E75F6C8];
  if (v125)
  {
    unint64_t v126 = -1;
    do
    {
      int8x16_t v127 = [v125 targetShapes];
      unint64_t v128 = [v127 count];

      ++v126;
    }
    while (v128 > v126);
  }

  if (v45)
  {
    id obja = [v43 componentConformingToProtocol:&unk_26E75F868];
    if (obja)
    {
      memset(buf, 0, 64);
      uint64_t v129 = [obja countByEnumeratingWithState:buf objects:v184 count:16];
      if (v129)
      {
        uint64_t v130 = v129;
        uint64_t v131 = **(void **)&buf[16];
        do
        {
          for (uint64_t j = 0; j != v130; ++j)
          {
            if (**(void **)&buf[16] != v131) {
              objc_enumerationMutation(obja);
            }
            uint64_t v133 = *(void *)(*(void *)&buf[8] + 8 * j);
            uint64_t v182 = 0;
            uint64_t v181 = 0;
            memset(v179, 0, sizeof(v179));
            long long v175 = 0u;
            uint64_t v176 = "";
            uint64_t v177 = 1;
            long long v178 = 0uLL;
            *(void *)&v179[0] = 0;
            DWORD2(v179[0]) = 0;
            long long v180 = 0u;
            re::DynamicArray<re::ecs2::EntityAssetData>::add(a3 + 72, (uint64_t)&v175);
            re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)&v175);
            re::loadMDLObject(a1, v133, *(void *)(a3 + 104) + 112 * *(void *)(a3 + 88) - 112, a4, a5, a6);
          }
          uint64_t v130 = [obja countByEnumeratingWithState:buf objects:v184 count:16];
        }
        while (v130);
      }
    }
    uint64_t v134 = a3;
    long long v158 = 0u;
    long long v159 = 0u;
    long long v156 = 0u;
    long long v157 = 0u;
    int v151 = [v146 children];
    uint64_t v135 = [v151 countByEnumeratingWithState:&v156 objects:&v175 count:16];
    if (v135)
    {
      uint64_t v136 = v135;
      uint64_t v137 = *(void *)v157;
      do
      {
        for (uint64_t k = 0; k != v136; ++k)
        {
          if (*(void *)v157 != v137) {
            objc_enumerationMutation(v151);
          }
          uint64_t v139 = *(void *)(*((void *)&v156 + 1) + 8 * k);
          long long v167 = 0uLL;
          long long v164 = 0u;
          *(_OWORD *)__n128 v162 = 0u;
          *(void *)&v162[16] = "";
          *(void *)&v162[24] = 1;
          long long v163 = 0uLL;
          *(void *)&long long v164 = 0;
          DWORD2(v16re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
          long long v165 = 0u;
          long long v166 = 0u;
          LODWORD(v16re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
          re::DynamicArray<re::ecs2::EntityAssetData>::add(v134 + 72, (uint64_t)v162);
          re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)v162);
          re::loadMDLObject(a1, v139, *(void *)(v134 + 104) + 112 * *(void *)(v134 + 88) - 112, a4, a5, a6);
        }
        uint64_t v136 = [v151 countByEnumeratingWithState:&v156 objects:&v175 count:16];
      }
      while (v136);
    }

    id v16 = v143;
    unint64_t v9 = v144;
    id v43 = v146;
  }
}

double simd_quaternion(simd_float3x3 a1)
{
  float v1 = a1.columns[2].f32[2] + (float)(a1.columns[0].f32[0] + a1.columns[1].f32[1]);
  if (v1 >= 0.0)
  {
    float v8 = sqrtf(v1 + 1.0);
    float32x2_t v9 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8));
    float32x2_t v10 = vmul_f32(v9, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v9));
    float32x2_t v20 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL), *(int32x2_t *)a1.columns[2].f32), (float32x2_t)vext_s8(*(int8x8_t *)a1.columns[2].f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), 4uLL)), vmul_f32(v10, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v10)).f32[0]);
  }
  else if (a1.columns[0].f32[0] < a1.columns[1].f32[1] || a1.columns[0].f32[0] < a1.columns[2].f32[2])
  {
    float v3 = 1.0 - a1.columns[0].f32[0];
    if (a1.columns[1].f32[1] >= a1.columns[2].f32[2])
    {
      float v21 = sqrtf(a1.columns[1].f32[1] + (float)(v3 - a1.columns[2].f32[2]));
      *(float *)&unsigned int v22 = v21 + v21;
      float32x2_t v23 = vrecpe_f32((float32x2_t)v22);
      float32x2_t v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v22, v23));
      v25.i32[0] = vmul_f32(v24, vrecps_f32((float32x2_t)v22, v24)).u32[0];
      v24.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)a1.columns[0].f32, 1), *(float32x2_t *)a1.columns[1].f32).u32[0];
      v24.i32[1] = v22;
      v25.i32[1] = 0.25;
      float32x2_t v20 = vmul_f32(v24, v25);
    }
    else
    {
      float32x2_t v4 = (float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[2].f32[2] + (float)(v3 - a1.columns[1].f32[1]))));
      *(float32x2_t *)a1.columns[2].f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL)), *(float32x2_t *)a1.columns[2].f32);
      *(int32x2_t *)a1.columns[1].f32 = vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
      a1.columns[1].i32[0] = 2.0;
      a1.columns[1].i32[0] = vmul_f32(v4, *(float32x2_t *)a1.columns[1].f32).u32[0];
      float32x2_t v5 = vrecpe_f32((float32x2_t)a1.columns[1].u32[0]);
      float32x2_t v6 = vmul_f32(v5, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v5));
      float32x2_t v20 = vmul_n_f32(*(float32x2_t *)a1.columns[2].f32, vmul_f32(v6, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v6)).f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
    }
  }
  else
  {
    float32x2_t v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
    float32x2_t v12 = vadd_f32(*(float32x2_t *)a1.columns[0].f32, v11);
    v11.i32[0] = 2.0;
    v11.i32[0] = vmul_f32((float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[0].f32[0]+ (float)((float)(1.0 - a1.columns[1].f32[1]) - a1.columns[2].f32[2])))), v11).u32[0];
    v11.i32[1] = v12.i32[1];
    float32x2_t v13 = vrecpe_f32((float32x2_t)v11.u32[0]);
    float32x2_t v14 = vmul_f32(v13, vrecps_f32((float32x2_t)v11.u32[0], v13));
    unsigned __int32 v15 = vmul_f32(v14, vrecps_f32((float32x2_t)v11.u32[0], v14)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v15;
    float32x2_t v20 = vmul_f32(v11, _D5);
  }
  return *(double *)&v20;
}

double re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + 16));
          re::DynamicArray<re::AssetHandle>::deinit(v6 + 48);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 88;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void *re::DynamicArray<re::ImportedTexturesTable::Entry>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    float32x2_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::ImportedTexturesTable::Entry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x60uLL))
        {
          uint64_t v2 = 96 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      int v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 96 * v9;
        float32x2_t v11 = v7;
        do
        {
          *(_OWORD *)float32x2_t v11 = 0u;
          *((_OWORD *)v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *float32x2_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          void v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          long long v16 = *(_OWORD *)(v8 + 32);
          *((_DWORD *)v11 + 12) = *(_DWORD *)(v8 + 48);
          *((_OWORD *)v11 + 2) = v16;
          *(_OWORD *)(v11 + 9) = 0u;
          *(_OWORD *)(v11 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
          v11[7] = *(void *)(v8 + 56);
          *(void *)(v8 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
          v11[10] = *(void *)(v8 + 80);
          *(void *)(v8 + 80) = 0;
          uint64_t v18 = v11[8];
          uint64_t v17 = v11[9];
          uint64_t v19 = *(void *)(v8 + 72);
          unsigned __int8 v11[8] = *(void *)(v8 + 64);
          v11[9] = v19;
          *(void *)(v8 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v18;
          *(void *)(v8 + 72) = v17;
          v11[11] = *(void *)(v8 + 88);
          re::DynamicString::deinit((re::DynamicString *)(v8 + 56));
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 96;
          v11 += 12;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::DynamicString::deinit((re::DynamicString *)(a1 + 16));
    uint64_t v3 = *(void **)(a1 + 48);
  }
}

void re::TextureProvider::~TextureProvider(id *this)
{
  *this = &unk_26E6E09A0;
  re::internal::TextureProviderProperties::~TextureProviderProperties((re::internal::TextureProviderProperties *)(this + 22));

  id v2 = this[5];
  if (v2)
  {

    this[5] = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(this + 1));
}

{
  uint64_t vars8;

  re::TextureProvider::~TextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

void re::ResourceTextureProvider::~ResourceTextureProvider(id *this)
{
  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
}

{
  uint64_t vars8;

  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

__n128 re::TextureProvider::tryReadHeaderBytes@<Q0>(re::TextureProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v7;
  uint64_t v5 = v8;
  uint64_t v6 = v9;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v5;
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v6;
  return result;
}

uint64_t re::TextureProvider::tryCreateImageSource(re::TextureProvider *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t re::TextureProvider::tryCreateOrDetachImageSource(re::TextureProvider *this, const __CFDictionary *a2)
{
  return (*(uint64_t (**)(re::TextureProvider *, const __CFDictionary *))(*(void *)this + 24))(this, a2);
}

uint64_t re::TextureProvider::tryCreateRawImageData(re::TextureProvider *this)
{
  return 0;
}

uint64_t re::TextureProvider::tryCreateOrDetachRawImageData(re::TextureProvider *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t re::TextureProvider::tryGetImage(re::TextureProvider *this)
{
  return 0;
}

const void *re::TextureProvider::tryCreateOrDetachImage(re::TextureProvider *this)
{
  int v1 = (const void *)(*(uint64_t (**)(re::TextureProvider *))(*(void *)this + 56))(this);
  id v2 = v1;
  if (v1) {
    CFRetain(v1);
  }
  return v2;
}

void re::TextureProvider::tryGetImageArray(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

void re::TextureProvider::tryGetTextureTypeForImageArray(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

void re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      uint64_t v9 = (unint64_t *)(v8 + v6);
      if ((*(_DWORD *)(v8 + v6 + 8) & 0x80000000) != 0)
      {
        float32x2_t v11 = (const re::TextureProvider *)(v9 + 6);
        unint64_t v10 = *v9;
        unint64_t v12 = *(unsigned int *)(a1 + 24);
        unint64_t v13 = *v9 % v12;
        uint64_t v14 = *(unsigned int *)(a1 + 36);
        if (v14 == 0x7FFFFFFF)
        {
          uint64_t v14 = *(unsigned int *)(a1 + 32);
          int v15 = v14;
          if (v14 == v12)
          {
            re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
            unint64_t v13 = v10 % *(unsigned int *)(a1 + 24);
            int v15 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v15 + 1;
          uint64_t v16 = *(void *)(a1 + 16);
          int v17 = *(_DWORD *)(v16 + 288 * v14 + 8);
        }
        else
        {
          uint64_t v16 = *(void *)(a1 + 16);
          int v17 = *(_DWORD *)(v16 + 288 * v14 + 8);
          *(_DWORD *)(a1 + 36) = v17 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v16 + 288 * v14 + 8) = v17 | 0x80000000;
        *(_DWORD *)(*(void *)(a1 + 16) + 288 * v14 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 288 * v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13);
        *(void *)(*(void *)(a1 + 16) + 288 * v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v10;
        re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 288 * v14 + 16), (const re::DynamicString *)(v9 + 2));
        uint64_t v18 = *(void *)(a1 + 16) + 288 * v14;
        re::TextureProvider::TextureProvider((re::TextureProvider *)(v18 + 48), v11);
        *(void *)(v18 + 48) = &unk_26E6E0A08;
        re::DynamicString::DynamicString((re::DynamicString *)(v18 + 256), (const re::DynamicString *)(v8 + v6 + 256));
        *(void *)(v18 + 48) = &unk_26E715260;
        *(_DWORD *)(*(void *)(a1 + 8) + 4 * vre::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = v14;
        ++*(_DWORD *)(a1 + 28);
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 288;
    }
  }
}

void re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(void *)(a1 + 16) + v3);
        ++v4;
        v3 += 288;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v25, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v25;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)float32x2_t v25 = v5;
      *(void *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        unint64_t v13 = (void *)(v6 + 256);
        do
        {
          if ((*(_DWORD *)(v13 - 31) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 32);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 288 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 288 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 288 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 288 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 288 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 288 * v1re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v14;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 288 * v17 + 16), (const re::DynamicString *)(v13 - 30));
            uint64_t v21 = *(void *)(a1 + 16) + 288 * v17;
            re::TextureProvider::TextureProvider(v21 + 48, (uint64_t)(v13 - 26));
            *(_OWORD *)(v21 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
            *(_OWORD *)(v21 + 272) = 0u;
            *(void *)(v21 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *v13;
            *unint64_t v13 = 0;
            uint64_t v22 = *(void *)(v21 + 272);
            *(void *)(v21 + 272) = v13[2];
            void v13[2] = v22;
            *(void *)(v21 + 280) = v13[3];
            v13[3] = 0;
            uint64_t v23 = *(void *)(v21 + 264);
            *(void *)(v21 + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v13[1];
            v13[1] = v23;
            *(void *)(v21 + 48) = &unk_26E715260;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 36;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

re::USDImportContext *re::USDImportContext::USDImportContext(re::USDImportContext *this)
{
  *(void *)this = 0;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0xFF7FFFFF7F7FFFFFLL;
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *((unsigned char *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 1;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
  *(_OWORD *)((char *)this + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *((_DWORD *)this + 18) = 1;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *((_OWORD *)this + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *(void *)((char *)this + 148) = 0x7FFFFFFFLL;
  *((_OWORD *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0u;
  *((_DWORD *)this + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 52) = 0;
  *(_OWORD *)((char *)this + 18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *((_DWORD *)this + 62) = 0;
  *(void *)((char *)this + 252) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_DWORD *)this + 70) = 1;
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = 0;
  *((_DWORD *)this + 78) = 0;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_DWORD *)this + 88) = 0;
  *(void *)((char *)this + 3re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 23) = 0u;
  *((_DWORD *)this + 96) = 1;
  *(_OWORD *)((char *)this + 392) = 0u;
  *((_DWORD *)this + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((void *)this + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
  *(_OWORD *)((char *)this + 4re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *((_DWORD *)this + 11re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)((char *)this + 460) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 126) = 0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(void *)((char *)this + 508) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_DWORD *)this + 13re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
  *((_OWORD *)this + 3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_DWORD *)this + 142) = 0;
  *((void *)this + 70) = 0;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 3re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
  *((_DWORD *)this + 152) = 0;
  *(void *)((char *)this + 612) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 39) = 0u;
  *((_DWORD *)this + 160) = 1;
  *((_DWORD *)this + 168) = 0;
  *((void *)this + 83) = 0;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *((_DWORD *)this + 17re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
  *((_DWORD *)this + 182) = 0;
  *((void *)this + 90) = 0;
  *((_OWORD *)this + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_DWORD *)this + 192) = 0;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 4re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
  *(void *)((char *)this + 772) = 0x7FFFFFFFLL;
  uint64_t v2 = (void *)((char *)this + 784);
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 50) = 0u;
  re::DynamicString::setCapacity(v2, 0);
  *((_DWORD *)this + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0;
  *((void *)this + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *((_OWORD *)this + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 876) = 0u;
  *(void *)((char *)this + 892) = 0x7FFFFFFFLL;
  return this;
}

void re::loadUSKSkeletalAnimationNodes(void *a1, uint64_t a2)
{
  v38[6] = *MEMORY[0x263EF8340];
  id v3 = a1;
  uint64_t v4 = [v3 type];
  long long v5 = (void *)*MEMORY[0x263F84008];

  if (v4 != v5) {
    goto LABEL_15;
  }
  re::importSkeletalAnimation(v3, *(unsigned char *)(a2 + 32), (uint64_t)v28, *(double *)a2);
  if (v28[0])
  {
    long long v7 = [v3 name];
    id v8 = [v7 stringValue];
    long long v9 = (const char *)[v8 UTF8String];

    if (!v9 || !*v9) {
      long long v9 = "(UnnamedAnimation)";
    }
    uint64_t v10 = [v3 path];
    id v11 = [v10 stringValue];
    uint64_t v12 = (_anonymous_namespace_ *)[v11 UTF8String];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = "";
    uint64_t v25 = 0;
    float32x4_t v26 = "";
    re::USDImportContext::addSkeletalAnimation(a2, (StringID *)buf, &v25, (uint64_t)&v29);
    re::StringID::destroyString((re::StringID *)&v25);
    re::StringID::destroyString((re::StringID *)buf);
    goto LABEL_7;
  }
  unint64_t v14 = *re::pipelineLogObjects(v6);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v22 = v14;
    uint64_t v10 = [v3 path];
    id v11 = [v10 stringValue];
    uint64_t v23 = [v11 UTF8String];
    if (v31) {
      signed int v24 = v33;
    }
    else {
      signed int v24 = v32;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v24;
    _os_log_error_impl(&dword_233120000, v22, OS_LOG_TYPE_ERROR, "Skeletal Animation (%s) import error: %s.", buf, 0x16u);

LABEL_7:
  }
  if (v28[0])
  {
    re::DynamicArray<re::StringID>::deinit((uint64_t)v38);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v37);
    float32x4_t v29 = &unk_26E6D0DD8;
    re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v36);
    float32x4_t v29 = &unk_26E6D3730;
    if ((void)v34)
    {
      if (BYTE8(v34)) {
        (*(void (**)(void, void))(*(void *)v34 + 40))(v34, v35);
      }
      long long v34 = 0u;
      long long v35 = 0u;
    }
    re::StringID::destroyString((re::StringID *)&v31);
  }
  else if (v30 && (v31 & 1) != 0)
  {
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v30 + 40))(v30, v33);
  }
LABEL_15:
  unint64_t v15 = objc_msgSend(v3, "childIterator", v25, v26, *(void *)buf, *(void *)&buf[8]);
  uint64_t v16 = [v15 nextObject];
  if (v16)
  {
    uint64_t v17 = (void *)v16;
    do
    {
      int v18 = [v3 metadataWithKey:@"kind"];
      uint64_t v19 = [v18 stringValue];
      char v20 = [v19 isEqual:@"sceneLibrary"];

      if ((v20 & 1) == 0) {
        re::loadUSKSkeletalAnimationNodes(v17, a2);
      }
      uint64_t v21 = [v15 nextObject];

      uint64_t v17 = (void *)v21;
    }
    while (v21);
  }
}

void re::loadUSKSkeletonNodes(void *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v3 = a1;
  uint64_t v4 = [v3 type];
  long long v5 = (void *)*MEMORY[0x263F84010];

  if (v4 != v5) {
    goto LABEL_20;
  }
  re::importSkeleton(v3, (uint64_t)v23);
  if (v23[0])
  {
    long long v7 = [v3 path];
    id v8 = [v7 stringValue];
    long long v9 = (_anonymous_namespace_ *)[v8 UTF8String];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = "";
    re::USDImportContext::addSkeleton(a2, (StringID *)buf, v24);
    re::StringID::destroyString((re::StringID *)buf);

LABEL_4:
    goto LABEL_6;
  }
  uint64_t v10 = *re::pipelineLogObjects(v6);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v19 = v10;
    long long v7 = [v3 path];
    id v20 = [v7 stringValue];
    uint64_t v21 = [v20 UTF8String];
    if (v26) {
      uint64_t v22 = *(unsigned char **)&v27[7];
    }
    else {
      uint64_t v22 = v27;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v22;
    _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, "Skeleton (%s) import error: %s.", buf, 0x16u);

    goto LABEL_4;
  }
LABEL_6:
  if (v23[0])
  {
    v11.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v37);
    if (v34)
    {
      if (v35)
      {
        (*(void (**)(double))(*(void *)v34 + 40))(v11.n128_f64[0]);
        uint64_t v35 = 0;
        uint64_t v36 = 0;
      }
      uint64_t v34 = 0;
    }
    if (v31)
    {
      if (v32)
      {
        (*(void (**)(__n128))(*(void *)v31 + 40))(v11);
        uint64_t v32 = 0;
        uint64_t v33 = 0;
      }
      uint64_t v31 = 0;
    }
    if (v28)
    {
      if (v29)
      {
        (*(void (**)(__n128))(*(void *)v28 + 40))(v11);
        uint64_t v29 = 0;
        uint64_t v30 = 0;
      }
      uint64_t v28 = 0;
    }
    re::FixedArray<re::StringID>::deinit(&v25);
    re::StringID::destroyString((re::StringID *)v24);
  }
  else if (v25 && (v26 & 1) != 0)
  {
    (*(void (**)(void))(*(void *)v25 + 40))();
  }
LABEL_20:
  uint64_t v12 = [v3 childIterator];
  uint64_t v13 = [v12 nextObject];
  if (v13)
  {
    unint64_t v14 = (void *)v13;
    do
    {
      unint64_t v15 = [v3 metadataWithKey:@"kind"];
      uint64_t v16 = [v15 stringValue];
      char v17 = [v16 isEqual:@"sceneLibrary"];

      if ((v17 & 1) == 0) {
        re::loadUSKSkeletonNodes(v14, a2);
      }
      uint64_t v18 = [v12 nextObject];

      unint64_t v14 = (void *)v18;
    }
    while (v18);
  }
}

void re::loadUSKBlendShapeNodes(void *a1, uint64_t a2)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  id v4 = a1;
  long long v5 = [v4 type];
  uint64_t v6 = (void *)*MEMORY[0x263F83FC8];

  if (v5 == v6)
  {
    uint64_t v91 = 0;
    unint64_t v92 = "";
    long long v93 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    uint64_t v97 = 0;
    long long v7 = [v4 name];
    id v8 = [v7 stringValue];
    long long v9 = (_anonymous_namespace_ *)[v8 UTF8String];

    if (v89) {
      __n128 v11 = *(const char **)&v90[7];
    }
    else {
      __n128 v11 = v90;
    }
    *(void *)uint64_t v99 = 0;
    *(void *)&v99[8] = "";
    uint64_t v12 = *(void *)v99;
    uint64_t v13 = *(const char **)&v99[8];
    *(void *)uint64_t v99 = 0;
    *(void *)&v99[8] = "";
    char v14 = v91;
    unint64_t v15 = v92;
    uint64_t v91 = v12;
    unint64_t v92 = v13;
    *(void *)long long buf = v12 & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
    *(void *)&uint8_t buf[8] = v15;
    re::StringID::destroyString((re::StringID *)buf);
    re::StringID::destroyString((re::StringID *)v99);
    uint64_t v16 = [v4 property:@"normalOffsets"];
    char v17 = v16;
    if (v16)
    {
      uint64_t v18 = [v16 data];
      uint64_t v19 = [v18 dataNoCopy];
      uint64_t v20 = [v19 length];
      uint64_t v21 = 3 * [v18 arraySize];

      if (v20 == 4 * v21)
      {
        id v23 = [v18 dataNoCopy];
        uint64_t v24 = [v23 bytes];
        unint64_t v25 = 3 * [v18 arraySize];

        if (v25 >= 3)
        {
          uint64_t v28 = 0;
          uint64_t v29 = v95;
          if (v25 / 3 <= 1) {
            unint64_t v30 = 1;
          }
          else {
            unint64_t v30 = v25 / 3;
          }
          uint64_t v31 = (_DWORD *)(*((void *)&v95 + 1) + 4);
          uint64_t v32 = (int *)(v24 + 4);
          unint64_t v33 = 2;
          do
          {
            unint64_t v34 = v33 - 2;
            if (v25 <= v33 - 2) {
              goto LABEL_70;
            }
            unint64_t v35 = v33 - 1;
            if (v25 <= v33 - 1) {
              goto LABEL_71;
            }
            if (v25 <= v33) {
              goto LABEL_72;
            }
            if (v29 == v28) {
              goto LABEL_73;
            }
            int v36 = *v32;
            int v37 = v32[1];
            *(v31 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(v32 - 1);
            *uint64_t v31 = v36;
            ++v28;
            v31[1] = v37;
            v33 += 3;
            v31 += 3;
            v32 += 3;
          }
          while (v30 != v28);
        }
      }
      else
      {
        float32x4_t v38 = *re::pipelineLogObjects(v22);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          int v82 = v38;
          uint64_t v83 = [v18 arraySize];
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v83;
          _os_log_error_impl(&dword_233120000, v82, OS_LOG_TYPE_ERROR, "Invalid array size (%lu)", buf, 0xCu);
        }
      }
    }
    uint64_t v39 = [v4 property:@"offsets"];
    float v40 = v39;
    if (v39)
    {
      float32x4_t v41 = [v39 data];
      float32x4_t v42 = [v41 dataNoCopy];
      uint64_t v43 = [v42 length];
      uint64_t v44 = 3 * [v41 arraySize];

      if (v43 == 4 * v44)
      {
        id v46 = [v41 dataNoCopy];
        uint64_t v47 = [v46 bytes];
        unint64_t v2 = 3 * [v41 arraySize];

        if (v2 >= 3)
        {
          uint64_t v50 = 0;
          unint64_t v25 = *((void *)&v93 + 1);
          if (v2 / 3 <= 1) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = v2 / 3;
          }
          uint64_t v52 = (_DWORD *)(v94 + 4);
          unint64_t v53 = (int *)(v47 + 4);
          unint64_t v54 = 2;
          do
          {
            unint64_t v55 = v54 - 2;
            if (v2 <= v54 - 2) {
              goto LABEL_74;
            }
            unint64_t v56 = v54 - 1;
            if (v2 <= v54 - 1) {
              goto LABEL_75;
            }
            if (v2 <= v54) {
              goto LABEL_76;
            }
            if (v25 == v50) {
              goto LABEL_77;
            }
            int v57 = *v53;
            int v58 = v53[1];
            *(v52 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(v53 - 1);
            *uint64_t v52 = v57;
            ++v50;
            v52[1] = v58;
            v54 += 3;
            v52 += 3;
            v53 += 3;
          }
          while (v51 != v50);
        }
      }
      else
      {
        double v59 = *re::pipelineLogObjects(v45);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          uint64_t v84 = v59;
          uint64_t v85 = [v41 arraySize];
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v85;
          _os_log_error_impl(&dword_233120000, v84, OS_LOG_TYPE_ERROR, "Invalid array size (%lu)", buf, 0xCu);
        }
      }
    }
    uint64_t v60 = [v4 property:@"pointIndices"];
    int v61 = v60;
    if (v60)
    {
      int v62 = [v60 data];
      long long v63 = [v62 dataNoCopy];
      uint64_t v64 = [v63 length];
      uint64_t v65 = [v62 arraySize];

      if (v64 == 4 * v65)
      {
        id v67 = [v62 dataNoCopy];
        uint64_t v29 = [v67 bytes];
        unint64_t v25 = [v62 arraySize];

        if (v25)
        {
          uint64_t v69 = 0;
          unint64_t v2 = *((void *)&v96 + 1);
          uint64_t v70 = v97;
          while (v2 != v69)
          {
            *(_DWORD *)(v70 + 4 * v69) = *(_DWORD *)(v29 + 4 * v69);
            if (v25 == ++v69) {
              goto LABEL_46;
            }
          }
          uint64_t v98 = 0;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v99 = 136315906;
          *(void *)&v99[4] = "operator[]";
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = 468;
          __int16 v100 = 2048;
          unint64_t v101 = v2;
          __int16 v102 = 2048;
          unint64_t v103 = v2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_70:
          re::internal::assertLog((re::internal *)6, v27, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v34, v25);
          _os_crash();
          __break(1u);
LABEL_71:
          re::internal::assertLog((re::internal *)6, v27, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v35, v25);
          _os_crash();
          __break(1u);
LABEL_72:
          re::internal::assertLog((re::internal *)6, v27, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v33, v25);
          _os_crash();
          __break(1u);
LABEL_73:
          uint64_t v98 = 0;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v99 = 136315906;
          *(void *)&v99[4] = "operator[]";
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = 468;
          __int16 v100 = 2048;
          unint64_t v101 = v29;
          __int16 v102 = 2048;
          unint64_t v103 = v29;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_74:
          re::internal::assertLog((re::internal *)6, v49, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v55, v2);
          _os_crash();
          __break(1u);
LABEL_75:
          re::internal::assertLog((re::internal *)6, v49, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v56, v2);
          _os_crash();
          __break(1u);
LABEL_76:
          re::internal::assertLog((re::internal *)6, v49, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v54, v2);
          _os_crash();
          __break(1u);
LABEL_77:
          uint64_t v98 = 0;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v99 = 136315906;
          *(void *)&v99[4] = "operator[]";
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = 468;
          __int16 v100 = 2048;
          unint64_t v101 = v25;
          __int16 v102 = 2048;
          unint64_t v103 = v25;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      else
      {
        uint64_t v71 = *re::pipelineLogObjects(v66);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          int v86 = v71;
          uint64_t v87 = [v62 arraySize];
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v87;
          _os_log_error_impl(&dword_233120000, v86, OS_LOG_TYPE_ERROR, "Invalid array size (%lu)", buf, 0xCu);
        }
      }
LABEL_46:
    }
    long long v72 = [v4 path];
    id v73 = [v72 stringValue];
    uint64_t v74 = (_anonymous_namespace_ *)[v73 UTF8String];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = "";
    re::USDImportContext::addBlendShape(a2, (StringID *)buf, &v91);
    re::StringID::destroyString((re::StringID *)buf);

    if (v88 && (v89 & 1) != 0) {
      (*(void (**)(void))(*(void *)v88 + 40))();
    }
    if ((void)v96)
    {
      if (*((void *)&v96 + 1))
      {
        (*(void (**)(void))(*(void *)v96 + 40))();
        *((void *)&v96 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        uint64_t v97 = 0;
      }
      *(void *)&long long v96 = 0;
    }
    if (*((void *)&v94 + 1))
    {
      if ((void)v95)
      {
        (*(void (**)(void))(**((void **)&v94 + 1) + 40))();
        long long v95 = 0uLL;
      }
      *((void *)&v94 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    }
    if ((void)v93)
    {
      if (*((void *)&v93 + 1))
      {
        (*(void (**)(void))(*(void *)v93 + 40))();
        *((void *)&v93 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        *(void *)&long long v94 = 0;
      }
      *(void *)&long long v93 = 0;
    }
    re::StringID::destroyString((re::StringID *)&v91);
  }
  uint64_t v75 = [v4 childIterator];
  uint64_t v76 = [v75 nextObject];
  if (v76)
  {
    unint64_t v77 = (void *)v76;
    do
    {
      uint64_t v78 = [v4 metadataWithKey:@"kind"];
      unint64_t v79 = [v78 stringValue];
      char v80 = [v79 isEqual:@"sceneLibrary"];

      if ((v80 & 1) == 0) {
        re::loadUSKBlendShapeNodes(v77, a2);
      }
      uint64_t v81 = [v75 nextObject];

      unint64_t v77 = (void *)v81;
    }
    while (v81);
  }
}

void re::loadUSKDeformerStackNodes(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  long long v7 = [v6 typeName];
  id v8 = [v7 stringValue];
  if ([v8 isEqualToString:@"Preliminary_DeformerStack"])
  {
  }
  else
  {
    long long v9 = [v6 typeName];
    uint64_t v10 = [v9 stringValue];
    int v11 = [v10 isEqualToString:@"DeformerStack"];

    if (!v11) {
      goto LABEL_34;
    }
  }
  unint64_t v80 = 0;
  uint64_t v81 = "";
  uint64_t v12 = [v6 properties];
  uint64_t v13 = [v12 objectForKeyedSubscript:@"mesh"];

  if (v13)
  {
    char v14 = [v6 property:@"mesh"];
    unint64_t v15 = [v14 objectPath];
  }
  else
  {
    uint64_t v69 = [v6 parent];
    if (!v69) {
      goto LABEL_7;
    }
    uint64_t v70 = (void *)v69;
    uint64_t v71 = [v6 parent];
    long long v72 = [v71 typeName];
    id v73 = [v72 stringValue];
    int v74 = [v73 isEqualToString:@"Mesh"];

    if (!v74) {
      goto LABEL_7;
    }
    char v14 = [v6 parent];
    unint64_t v15 = [v14 path];
  }
  uint64_t v16 = v15;
  id v17 = [v15 stringValue];
  uint64_t v18 = (_anonymous_namespace_ *)[v17 UTF8String];
  unint64_t v82 = 0;
  uint64_t v83 = "";
  unint64_t v19 = v82;
  uint64_t v20 = v83;
  unint64_t v21 = v82 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v82 = 0;
  uint64_t v83 = "";
  unint64_t v89 = v21;
  int v90 = "";
  unint64_t v80 = v19;
  uint64_t v81 = v20;
  re::StringID::destroyString((re::StringID *)&v89);
  re::StringID::destroyString((re::StringID *)&v82);

LABEL_7:
  uint64_t v22 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3 + 856, &v80);
  if (v22)
  {
    uint64_t v76 = a3;
    uint64_t v23 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a3 + 624, *v22);
    id v75 = v6;
    uint64_t v78 = [v6 childIterator];
    uint64_t v24 = [v78 nextObject];
    if (v24)
    {
      unint64_t v25 = (void *)v24;
      char v26 = @"Preliminary_DeformerAffector";
      id v77 = v5;
      while (1)
      {
        id v27 = v5;
        id v28 = v25;
        uint64_t v29 = [v28 typeName];
        unint64_t v30 = [v29 stringValue];
        if ([v30 isEqualToString:@"Preliminary_Deformer"]) {
          break;
        }
        uint64_t v31 = [v28 typeName];
        uint64_t v32 = [v31 stringValue];
        int v33 = [v32 isEqualToString:@"Deformer"];

        if (v33) {
          goto LABEL_13;
        }
LABEL_31:

        unint64_t v25 = [v78 nextObject];

        id v5 = v77;
        if (!v25) {
          goto LABEL_32;
        }
      }

LABEL_13:
      unint64_t v89 = 0;
      int v90 = "";
      uint64_t v91 = 0;
      unint64_t v92 = "";
      memset(v93, 0, sizeof(v93));
      int v94 = 0;
      long long v95 = 0u;
      long long v96 = 0u;
      int v97 = 0;
      uint64_t v99 = 0;
      uint64_t v100 = 0;
      uint64_t v98 = 0;
      uint64_t v103 = 0;
      uint64_t v104 = 0;
      uint64_t v102 = 0;
      int v105 = 0;
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      int v101 = 1;
      int v108 = 1;
      uint64_t v109 = 0;
      uint64_t v110 = 0;
      int v112 = 0;
      uint64_t v111 = 0;
      uint64_t v113 = 0;
      uint64_t v114 = 0;
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      int v119 = 0;
      uint64_t v118 = 0;
      uint64_t v120 = 0;
      uint64_t v121 = 0;
      int v115 = 1;
      int v122 = 1;
      uint64_t v123 = 0;
      uint64_t v124 = 0;
      int v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      uint64_t v128 = 0;
      int v129 = 1;
      uint64_t v130 = 0;
      uint64_t v131 = 0;
      int v133 = 0;
      uint64_t v132 = 0;
      uint64_t v134 = 0;
      uint64_t v135 = 0;
      int v136 = 1;
      uint64_t v137 = 0;
      uint64_t v138 = 0;
      int v140 = 0;
      uint64_t v139 = 0;
      unint64_t v34 = [v28 name];
      id v35 = [v34 stringValue];
      int v36 = (_anonymous_namespace_ *)[v35 UTF8String];
      uint64_t v87 = 0;
      uint64_t v88 = "";
      uint64_t v37 = v87;
      float32x4_t v38 = v88;
      uint64_t v87 = 0;
      uint64_t v88 = "";
      char v39 = v89;
      float v40 = v90;
      unint64_t v89 = v37;
      int v90 = v38;
      unint64_t v82 = v37 & 0xFFFFFFFFFFFFFFFELL | v39 & 1;
      uint64_t v83 = v40;
      re::StringID::destroyString((re::StringID *)&v82);
      re::StringID::destroyString((re::StringID *)&v87);

      float32x4_t v41 = [v28 property:@"info:id"];
      id v42 = [v41 stringValue];
      uint64_t v43 = (_anonymous_namespace_ *)[v42 UTF8String];
      uint64_t v87 = 0;
      uint64_t v88 = "";
      uint64_t v44 = v87;
      BOOL v45 = v88;
      uint64_t v87 = 0;
      uint64_t v88 = "";
      char v46 = v91;
      uint64_t v47 = v92;
      uint64_t v91 = v44;
      unint64_t v92 = v45;
      unint64_t v82 = v44 & 0xFFFFFFFFFFFFFFFELL | v46 & 1;
      uint64_t v83 = v47;
      re::StringID::destroyString((re::StringID *)&v82);
      re::StringID::destroyString((re::StringID *)&v87);

      re::loadUSKDeformerAttributes(v27, v28, (uint64_t *)&v89, (uint64_t)v93, v23);
      id v79 = v28;
      uint64_t v48 = [v28 childIterator];
      uint64_t v49 = [v48 nextObject];
      if (v49)
      {
        while (1)
        {
          uint64_t v50 = [v49 typeName];
          unint64_t v51 = [v50 stringValue];
          if ([v51 isEqualToString:v26]) {
            break;
          }
          uint64_t v52 = [v49 typeName];
          [v52 stringValue];
          v54 = unint64_t v53 = v26;
          int v55 = [v54 isEqualToString:@"DeformerAffector"];

          char v26 = v53;
          if (v55) {
            goto LABEL_17;
          }
LABEL_29:
          uint64_t v64 = [v48 nextObject];

          uint64_t v49 = (void *)v64;
          if (!v64) {
            goto LABEL_30;
          }
        }

LABEL_17:
        uint64_t v86 = 0;
        uint64_t v83 = 0;
        uint64_t v84 = 0;
        unint64_t v82 = 0;
        int v85 = 0;
        re::loadUSKDeformerAttributes(v27, v49, (uint64_t *)&v89, (uint64_t)&v82, v23);
        uint64_t v57 = *((void *)&v96 + 1);
        if (*((void *)&v96 + 1) >= (unint64_t)v96)
        {
          unint64_t v58 = *((void *)&v96 + 1) + 1;
          if ((unint64_t)v96 < *((void *)&v96 + 1) + 1)
          {
            if (*((void *)&v95 + 1))
            {
              unint64_t v59 = 8;
              if ((void)v96) {
                unint64_t v59 = 2 * v96;
              }
              if (v59 <= v58) {
                unint64_t v60 = *((void *)&v96 + 1) + 1;
              }
              else {
                unint64_t v60 = v59;
              }
              re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((void *)&v95 + 1, v60);
            }
            else
            {
              re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((void *)&v95 + 1, v58);
              ++v97;
            }
          }
          uint64_t v57 = *((void *)&v96 + 1);
        }
        uint64_t v61 = v98 + 40 * v57;
        *(void *)(v61 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
        *(void *)(v61 + 8) = 0;
        *(void *)(v61 + 16) = 0;
        *(void *)uint64_t v61 = 0;
        *(_DWORD *)(v61 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
        *(void *)uint64_t v61 = v82;
        unint64_t v82 = 0;
        *(void *)(v61 + 8) = v83;
        uint64_t v83 = 0;
        uint64_t v62 = *(void *)(v61 + 16);
        *(void *)(v61 + 16) = v84;
        uint64_t v84 = v62;
        uint64_t v63 = *(void *)(v61 + 32);
        *(void *)(v61 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v86;
        uint64_t v86 = v63;
        ++v85;
        ++*(_DWORD *)(v61 + 24);
        ++*((void *)&v96 + 1);
        ++v97;
        re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)&v82);
        goto LABEL_29;
      }
LABEL_30:
      re::DynamicArray<re::GeomDeformer>::add((_anonymous_namespace_ *)(v23 + 1024), (uint64_t *)&v89);

      re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)&v89);
      id v28 = v79;
      goto LABEL_31;
    }
LABEL_32:

    id v6 = v75;
    a3 = v76;
  }
  re::StringID::destroyString((re::StringID *)&v80);
LABEL_34:
  uint64_t v65 = [v6 childIterator];
  uint64_t v66 = [v65 nextObject];
  if (v66)
  {
    id v67 = (void *)v66;
    do
    {
      re::loadUSKDeformerStackNodes(v5, v67, a3);
      uint64_t v68 = [v65 nextObject];

      id v67 = (void *)v68;
    }
    while (v68);
  }
}

void re::loadUSKPhysicsNodes(void *a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  id v3 = a1;
  if (!re::hasColliderAPI(v3)) {
    goto LABEL_7;
  }
  re::importPhysicsCollider(v3, (uint64_t)&v40);
  if (v40.i8[0])
  {
    id v5 = [v3 path];
    id v6 = [v5 stringValue];
    long long v7 = (_anonymous_namespace_ *)[v6 UTF8String];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = "";
    uint64_t v8 = v41;
    int IsSceneGroundPlane = re::importPhysicsIsSceneGroundPlane(v3);
    char v10 = re::importPhysicsCollidesWithEnvironment(v3);
    re::USDImportContext::addPhysicsCollider(a2, (StringID *)buf, v8, &v42, IsSceneGroundPlane, v10);
    re::StringID::destroyString((re::StringID *)buf);
  }
  else
  {
    int v11 = *re::pipelineLogObjects(v4);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    uint64_t v32 = v11;
    id v5 = [v3 path];
    id v33 = [v5 stringValue];
    uint64_t v34 = [v33 UTF8String];
    if (BYTE8(v42)) {
      id v35 = v43;
    }
    else {
      id v35 = (char *)&v42 + 9;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v34;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v35;
    _os_log_error_impl(&dword_233120000, v32, OS_LOG_TYPE_ERROR, "Physics collider (%s) import error: %s.", buf, 0x16u);
  }
LABEL_6:
  if (!v40.i8[0] && (void)v42 && (BYTE8(v42) & 1) != 0) {
    (*(void (**)(void))(*(void *)v42 + 40))();
  }
LABEL_7:
  id v12 = v3;
  if (re::isRootNodeByPath(v12))
  {

    goto LABEL_25;
  }
  uint64_t v13 = [v12 property:@"preliminary:physics:rigidBody:mass"];

  if (v13)
  {
    re::importPhysicsRigidBody(v12, &v40);
    if (v40.i8[0])
    {
      BOOL hasColliderAPI = re::hasColliderAPI(v12);
      if (!hasColliderAPI)
      {
        uint64_t v24 = *re::pipelineLogObjects((re *)hasColliderAPI);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          int v36 = v24;
          uint64_t v37 = [v12 path];
          id v38 = [v37 stringValue];
          uint64_t v39 = [v38 UTF8String];
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v39;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "Rigid body is required to have a collider associated to it.";
          _os_log_error_impl(&dword_233120000, v36, OS_LOG_TYPE_ERROR, "Physics rigid body (%s) import error: %s.", buf, 0x16u);
        }
        goto LABEL_24;
      }
      uint64_t v16 = [v12 path];
      id v17 = [v16 stringValue];
      uint64_t v18 = (_anonymous_namespace_ *)[v17 UTF8String];
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = "";
      re::USDImportContext::addPhysicsRigidBody(a2, (StringID *)buf, &v41);
      re::StringID::destroyString((re::StringID *)buf);
    }
    else
    {
      unint64_t v19 = *re::pipelineLogObjects(v14);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      uint64_t v20 = v19;
      uint64_t v16 = [v12 path];
      id v21 = [v16 stringValue];
      uint64_t v22 = [v21 UTF8String];
      if (BYTE8(v42)) {
        uint64_t v23 = v43;
      }
      else {
        uint64_t v23 = (char *)&v42 + 9;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v23;
      _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "Physics rigid body (%s) import error: %s.", buf, 0x16u);
    }
LABEL_24:
    if (!v40.i8[0] && (void)v42 && (BYTE8(v42) & 1) != 0) {
      (*(void (**)(void))(*(void *)v42 + 40))();
    }
  }
LABEL_25:
  unint64_t v25 = [v12 childIterator];
  uint64_t v26 = [v25 nextObject];
  if (v26)
  {
    id v27 = (void *)v26;
    do
    {
      id v28 = [v12 metadataWithKey:@"kind"];
      uint64_t v29 = [v28 stringValue];
      char v30 = [v29 isEqual:@"sceneLibrary"];

      if ((v30 & 1) == 0) {
        re::loadUSKPhysicsNodes(v27, a2);
      }
      uint64_t v31 = [v25 nextObject];

      id v27 = (void *)v31;
    }
    while (v31);
  }
}

void re::loadUSKDeformerAttributes(void *a1, void *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v221 = *MEMORY[0x263EF8340];
  id v195 = a1;
  id v194 = a2;
  uint64_t v8 = [v194 propertyList];
  uint64_t v9 = [v8 nextObject];
  if (v9)
  {
    char v10 = (void *)v9;
    uint64_t v176 = (uint64_t)(a3 + 49);
    long long v190 = a3 + 14;
    uint64_t v182 = (uint64_t)(a3 + 42);
    long long v175 = a3 + 35;
    uint64_t v181 = a3 + 21;
    uint64_t v198 = *MEMORY[0x263F83F78];
    int v186 = a3 + 28;
    long long v178 = a3 + 38;
    uint64_t v197 = *MEMORY[0x263F83F18];
    int v179 = a3 + 24;
    uint64_t v196 = *MEMORY[0x263F83F40];
    uint64_t v191 = *MEMORY[0x263F83F58];
    uint64_t v192 = *MEMORY[0x263F83F80];
    uint64_t v188 = *MEMORY[0x263F83F70];
    uint64_t v185 = *MEMORY[0x263F83F88];
    uint64_t v183 = *MEMORY[0x263F83FA8];
    uint64_t v180 = *MEMORY[0x263F83FA0];
    uint64_t v177 = *MEMORY[0x263F83F30];
    uint64_t v174 = *MEMORY[0x263F83F68];
    uint64_t v184 = a3 + 31;
    int v187 = a3 + 17;
    int v193 = v8;
    while (1)
    {
      int v11 = [v10 name];
      id v12 = [v11 stringValue];
      char v13 = [v12 containsString:@"info:"];

      if ((v13 & 1) == 0) {
        break;
      }
LABEL_34:
      uint64_t v55 = [v8 nextObject];

      char v10 = (void *)v55;
      if (!v55) {
        goto LABEL_107;
      }
    }
    char v14 = [v10 name];
    id v15 = [v14 stringValue];
    uint64_t v16 = (_anonymous_namespace_ *)[v15 UTF8String];
    *(void *)float v216 = 0;
    *(void *)&v216[8] = "";
    uint64_t v17 = *(void *)v216;
    uint64_t v18 = *(const char **)&v216[8];
    *(void *)float v216 = 0;
    *(void *)&v216[8] = "";
    *(void *)&buf[0].f64[1] = "";
    *(void *)&buf[0].f64[0] = v17 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v205 = v17;
    unsigned int v206 = v18;
    re::StringID::destroyString((re::StringID *)buf);
    re::StringID::destroyString((re::StringID *)v216);

    unint64_t v19 = [v10 type];
    LODWORD(v15) = [v19 isEqualToString:v198];

    if (v15)
    {
      LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 1;
      uint64_t v20 = (_anonymous_namespace_ *)[v10 intValue];
LABEL_8:
      DWORD2(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v20;
      uint64_t v204 = 1;
LABEL_9:
      uint64_t v23 = 1;
LABEL_10:
      unint64_t v24 = *(void *)(a4 + 8);
      unint64_t v25 = *(void *)(a4 + 16);
      if (v25 >= v24)
      {
        unint64_t v26 = v25 + 1;
        if (v24 < v25 + 1)
        {
          if (*(void *)a4)
          {
            uint64_t v27 = 2 * v24;
            BOOL v28 = v24 == 0;
            unint64_t v29 = 8;
            if (!v28) {
              unint64_t v29 = v27;
            }
            if (v29 <= v26) {
              unint64_t v30 = v26;
            }
            else {
              unint64_t v30 = v29;
            }
            re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((void *)a4, v30);
          }
          else
          {
            re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((void *)a4, v26);
            ++*(_DWORD *)(a4 + 24);
          }
        }
        unint64_t v25 = *(void *)(a4 + 16);
      }
      uint64_t v54 = *(void *)(a4 + 32) + 40 * v25;
      *(void *)uint64_t v54 = v23;
      *(void *)(v54 + 8) = v17;
      *(void *)(v54 + 16) = v18;
      uint64_t v205 = 0;
      unsigned int v206 = "";
      *(_OWORD *)(v54 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v207;
      ++*(void *)(a4 + 16);
      ++*(_DWORD *)(a4 + 24);
      goto LABEL_33;
    }
    id v21 = [v10 type];
    int v22 = [v21 isEqualToString:v197];

    if (v22)
    {
      LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 1;
      uint64_t v20 = (_anonymous_namespace_ *)[v10 BOOLValue];
      goto LABEL_8;
    }
    uint64_t v31 = [v10 type];
    int v32 = [v31 isEqualToString:v196];

    if (v32)
    {
      LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
      uint64_t v20 = (_anonymous_namespace_ *)[v10 floatValue];
      DWORD2(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v33;
      uint64_t v204 = 1;
      goto LABEL_9;
    }
    uint64_t v34 = [v10 type];
    int v35 = [v34 isEqualToString:v192];

    if (v35)
    {
      LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 2;
      *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[19];
      int v36 = [v10 data];
      id v37 = [v36 dataNoCopy];
      uint64_t v23 = [v37 bytes];

      id v38 = [v36 dataNoCopy];
      uint64_t v39 = [v38 length];
      int32x4_t v40 = a3;
      uint64_t v41 = [v36 arraySize];

      if (v39 == 4 * v41)
      {
        __src = (const void *)v23;
        unint64_t v43 = [v36 arraySize];
        v199.uint64_t var1 = 0;
        *(void *)&v200.var0 = 0;
        *(void *)&v199.var0 = 0;
        unint64_t v45 = v40[19];
        unint64_t v46 = v40[15];
        if (v45 + 1 > 8 * v46)
        {
          re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity(v190, (v45 + 8) >> 3);
          unint64_t v46 = v40[15];
        }
        unint64_t v47 = v45 >> 3;
        if (v46 <= v45 >> 3)
        {
          uint64_t v208 = 0;
          float64x2_t v211 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v210 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float v216 = 136315906;
          *(void *)&v216[4] = "operator[]";
          *(_WORD *)&v216[12] = 1024;
          *(_DWORD *)&v216[14] = 858;
          __int16 v217 = 2048;
          unint64_t v218 = v45 >> 3;
          __int16 v219 = 2048;
          unint64_t v220 = v46;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_109:
          re::internal::assertLog((re::internal *)4, v44, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
          _os_crash();
          __break(1u);
LABEL_110:
          uint64_t v208 = 0;
          float64x2_t v211 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v210 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float v216 = 136315906;
          *(void *)&v216[4] = "operator[]";
          *(_WORD *)&v216[12] = 1024;
          *(_DWORD *)&v216[14] = 858;
          __int16 v217 = 2048;
          unint64_t v218 = v47;
          __int16 v219 = 2048;
          unint64_t v220 = v46;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_111:
          re::internal::assertLog((re::internal *)4, v65, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
          _os_crash();
          __break(1u);
LABEL_112:
          *(void *)&v199.var0 = 0;
          float64x2_t v211 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v210 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float v216 = 136315906;
          *(void *)&v216[4] = "operator[]";
          *(_WORD *)&v216[12] = 1024;
          *(_DWORD *)&v216[14] = 789;
          __int16 v217 = 2048;
          unint64_t v218 = 0;
          __int16 v219 = 2048;
          unint64_t v220 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_113:
          uint64_t v208 = 0;
          float64x2_t v211 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v210 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float v216 = 136315906;
          *(void *)&v216[4] = "operator[]";
          *(_WORD *)&v216[12] = 1024;
          *(_DWORD *)&v216[14] = 858;
          __int16 v217 = 2048;
          unint64_t v218 = v47;
          __int16 v219 = 2048;
          unint64_t v220 = v46;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_114:
          re::internal::assertLog((re::internal *)4, v97, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
          _os_crash();
          __break(1u);
LABEL_115:
          uint64_t v208 = 0;
          float64x2_t v211 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v210 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float v216 = 136315906;
          *(void *)&v216[4] = "operator[]";
          *(_WORD *)&v216[12] = 1024;
          *(_DWORD *)&v216[14] = 858;
          __int16 v217 = 2048;
          unint64_t v218 = v47;
          __int16 v219 = 2048;
          unint64_t v220 = v46;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v48 = (void *)v40[18];
        if (v40[16]) {
          uint64_t v48 = v187;
        }
        uint64_t v49 = v48[v47];
        ++v40[19];
        ++*((_DWORD *)v40 + 40);
        uint64_t v50 = (void *)(v49 + 24 * (v45 & 7));
        *uint64_t v50 = 0;
        v50[1] = 0;
        v50[2] = 0;
        *uint64_t v50 = *(void *)&v199.var0;
        *(void *)&v199.var0 = 0;
        v50[1] = v199.var1;
        v50[2] = *(void *)&v200.var0;
        uint64_t v51 = v40[19];
        if (!v51) {
          goto LABEL_109;
        }
        a3 = v40;
        uint64_t v52 = *(void **)(re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[]((uint64_t)v190, v51 - 1) + 16);
        size_t v53 = 4 * [v36 arraySize];
        goto LABEL_45;
      }
      uint64_t v71 = *re::pipelineLogObjects(v42);
      a3 = v40;
      if (!os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      goto LABEL_104;
    }
    unint64_t v56 = [v10 type];
    int v57 = [v56 isEqualToString:v191];

    if (v57)
    {
      LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 4;
      *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[33];
      int v36 = [v10 data];
      id v58 = [v36 dataNoCopy];
      uint64_t v23 = [v58 bytes];

      unint64_t v59 = [v36 dataNoCopy];
      uint64_t v60 = [v59 length];
      uint64_t v61 = a3;
      uint64_t v62 = 3 * [v36 arraySize];

      if (v60 == 4 * v62)
      {
        __src = (const void *)v23;
        unint64_t v64 = [v36 arraySize];
        v199.uint64_t var1 = 0;
        *(void *)&v200.var0 = 0;
        *(void *)&v199.var0 = 0;
        unint64_t v66 = v61[33];
        unint64_t v46 = v61[29];
        if (v66 + 1 > 8 * v46)
        {
          re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity(v186, (v66 + 8) >> 3);
          unint64_t v46 = v61[29];
        }
        unint64_t v47 = v66 >> 3;
        if (v46 <= v66 >> 3) {
          goto LABEL_110;
        }
        id v67 = (void *)v61[32];
        if (v61[30]) {
          id v67 = v184;
        }
        uint64_t v68 = v67[v47];
        ++v61[33];
        ++*((_DWORD *)v61 + 68);
        uint64_t v69 = (void *)(v68 + 24 * (v66 & 7));
        *uint64_t v69 = 0;
        v69[1] = 0;
        v69[2] = 0;
        *uint64_t v69 = *(void *)&v199.var0;
        *(void *)&v199.var0 = 0;
        v69[1] = v199.var1;
        v69[2] = *(void *)&v200.var0;
        uint64_t v70 = v61[33];
        if (!v70) {
          goto LABEL_111;
        }
        a3 = v61;
        uint64_t v52 = *(void **)(re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[]((uint64_t)v186, v70 - 1) + 16);
        size_t v53 = 12 * [v36 arraySize];
LABEL_45:
        memcpy(v52, __src, v53);
        uint64_t v23 = [v36 arraySize];
        uint64_t v204 = v23;
LABEL_54:

LABEL_55:
        uint64_t v8 = v193;
        goto LABEL_10;
      }
      uint64_t v71 = *re::pipelineLogObjects(v63);
      a3 = v61;
      if (!os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
LABEL_104:
      uint64_t v154 = v71;
      uint64_t v155 = [v36 arraySize];
      LODWORD(buf[0].f64[0]) = 134217984;
      *(void *)((char *)buf[0].f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v155;
      _os_log_error_impl(&dword_233120000, v154, OS_LOG_TYPE_ERROR, "Invalid array size (%lu)", (uint8_t *)buf, 0xCu);

      goto LABEL_54;
    }
    long long v72 = [v10 type];
    int v73 = [v72 isEqualToString:v188];

    if (v73)
    {
      int v74 = [v10 name];
      id v75 = [v74 stringValue];
      uint64_t v76 = [v75 componentsSeparatedByString:@":"];

      id v77 = [v76 objectAtIndexedSubscript:0];
      LODWORD(v75) = [v77 isEqualToString:@"primvars"];

      if (v75)
      {
        uint64_t v78 = NSString;
        uint64_t v23 = (uint64_t)a3;
        unint64_t v46 = [NSString stringWithUTF8String:a3[3]];
        unint64_t v47 = [v10 name];
        id v79 = [(id)v47 stringValue];
        unint64_t v80 = [v78 stringWithFormat:@"%@:%@", v46, v79];

        if (!*(void *)(a5 + 304)) {
          goto LABEL_112;
        }
        uint64_t v81 = (void *)(**(void **)(a5 + 320) + 24);
        id v82 = v80;
        re::addPropertyToGeomModelDescriptor(v10, 0, @"vertex", v81, (const char *)[v82 UTF8String], 0, (uint64_t)v201);
        a3 = (uint64_t *)v23;
        if (!v201[0])
        {
          uint64_t v8 = v193;
          if ((void)v202)
          {
            if (BYTE8(v202)) {
              (*(void (**)(void))(*(void *)v202 + 40))();
            }
            long long v202 = 0u;
            long long v203 = 0u;
          }
          goto LABEL_83;
        }
      }
      else
      {
        __srcb = v76;
        LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 3;
        *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[26];
        id v82 = [v10 data];
        id v90 = [v82 dataNoCopy];
        uint64_t v23 = [v90 bytes];

        uint64_t v91 = [v82 dataNoCopy];
        uint64_t v92 = [v91 length];
        long long v93 = a3;
        uint64_t v94 = [v82 arraySize];

        if (v92 != 4 * v94)
        {
          a3 = v93;
          uint64_t v110 = *re::pipelineLogObjects(v95);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
          {
            long long v164 = v110;
            uint64_t v165 = [v82 arraySize];
            LODWORD(buf[0].f64[0]) = 134217984;
            *(void *)((char *)buf[0].f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v165;
            _os_log_error_impl(&dword_233120000, v164, OS_LOG_TYPE_ERROR, "Invalid array size (%lu)", (uint8_t *)buf, 0xCu);
          }
          uint64_t v8 = v193;
          uint64_t v76 = __srcb;
          goto LABEL_83;
        }
        long long v168 = (const void *)v23;
        unint64_t v96 = [v82 arraySize];
        v199.uint64_t var1 = 0;
        *(void *)&v200.var0 = 0;
        *(void *)&v199.var0 = 0;
        unint64_t v98 = v93[26];
        uint64_t v99 = v93;
        unint64_t v46 = v93[22];
        if (v98 + 1 > 8 * v46)
        {
          re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity(v181, (v98 + 8) >> 3);
          unint64_t v46 = v93[22];
        }
        unint64_t v47 = v98 >> 3;
        uint64_t v76 = __srcb;
        if (v46 <= v98 >> 3) {
          goto LABEL_113;
        }
        uint64_t v100 = (void *)v99[25];
        if (v99[23]) {
          uint64_t v100 = v179;
        }
        uint64_t v101 = v100[v47];
        ++v99[26];
        ++*((_DWORD *)v99 + 54);
        uint64_t v102 = (void *)(v101 + 24 * (v98 & 7));
        *uint64_t v102 = 0;
        v102[1] = 0;
        v102[2] = 0;
        *uint64_t v102 = *(void *)&v199.var0;
        *(void *)&v199.var0 = 0;
        v102[1] = v199.var1;
        v102[2] = *(void *)&v200.var0;
        uint64_t v103 = v99[26];
        if (!v103) {
          goto LABEL_114;
        }
        a3 = v99;
        uint64_t v104 = *(void **)(re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[]((uint64_t)v181, v103 - 1) + 16);
        memcpy(v104, v168, 4 * [v82 arraySize]);
        uint64_t v23 = [v82 arraySize];
        uint64_t v204 = v23;
      }
      uint64_t v8 = v193;
LABEL_83:

      goto LABEL_10;
    }
    uint64_t v83 = [v10 type];
    int v84 = [v83 isEqualToString:v185];

    if (!v84)
    {
      int v105 = [v10 type];
      int v106 = [v105 isEqualToString:v183];

      if (v106)
      {
        LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 6;
        *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[47];
        id v107 = [v10 stringValue];
        int v108 = (_anonymous_namespace_ *)[v107 UTF8String];
        buf[0].f64[0] = 0.0;
        *(void *)&buf[0].f64[1] = "";
        uint64_t v109 = (float64x2_t *)re::BucketArray<re::StringID,8ul>::addUninitialized(v182);
        *uint64_t v109 = buf[0];
        *(void *)&buf[0].f64[1] = "";
        buf[0].f64[0] = 0.0;
        re::StringID::destroyString((re::StringID *)buf);
      }
      else
      {
        uint64_t v111 = [v10 type];
        int v112 = [v111 isEqualToString:v180];

        if (!v112)
        {
          uint64_t v144 = [v10 type];
          if ([v144 isEqualToString:v177])
          {

            uint64_t v8 = v193;
          }
          else
          {
            int v151 = [v10 type];
            int v152 = [v151 isEqualToString:v174];

            uint64_t v8 = v193;
            if (!v152)
            {
              long long v156 = *re::pipelineLogObjects(v153);
              if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
              {
                long long v157 = v156;
                long long v158 = [v10 name];
                id v159 = [v158 stringValue];
                uint64_t v160 = [v159 UTF8String];
                [v10 type];
                char v161 = a3;
                id v162 = objc_claimAutoreleasedReturnValue();
                uint64_t v163 = [v162 UTF8String];
                LODWORD(buf[0].f64[0]) = 136315394;
                *(void *)((char *)buf[0].f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v160;
                WORD2(buf[0].f64[1]) = 2080;
                *(void *)((char *)&buf[0].f64[1] + 6) = v163;
                _os_log_impl(&dword_233120000, v157, OS_LOG_TYPE_DEFAULT, "Deformer attribute [%s] has an invalid type [%s], skipping.", (uint8_t *)buf, 0x16u);

                a3 = v161;
                uint64_t v8 = v193;
              }
              goto LABEL_33;
            }
          }
          float64x2_t v214 = 0u;
          float64x2_t v215 = 0u;
          float64x2_t v212 = 0u;
          float64x2_t v213 = 0u;
          float64x2_t v210 = 0u;
          float64x2_t v211 = 0u;
          memset(buf, 0, sizeof(buf));
          [v10 double4x4Value];
          LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 7;
          *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[54];
          *(float32x4_t *)__srcc = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(buf[0]), buf[1]);
          *(float32x4_t *)long long v169 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v210), v211);
          float32x4_t v167 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v212), v213);
          float32x4_t v166 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v214), v215);
          uint64_t v20 = (_anonymous_namespace_ *)re::BucketArray<re::Matrix4x4<float>,8ul>::addUninitialized(v176);
          *(_OWORD *)uint64_t v20 = *(_OWORD *)__srcc;
          *((_OWORD *)v20 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(_OWORD *)v169;
          *((float32x4_t *)v20 + 2) = v167;
          *((float32x4_t *)v20 + 3) = v166;
          uint64_t v23 = 1;
          uint64_t v204 = 1;
          goto LABEL_10;
        }
        LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 6;
        uint64_t v113 = [v10 resourcePath];
        id v114 = [v113 resolvedPath];
        re::StringID::StringID((re::StringID *)buf, (const char *)[v114 UTF8String]);
        uint64_t v115 = re::BucketArray<re::StringID,8ul>::addUninitialized(v182);
        char v116 = LOBYTE(buf[0].f64[0]);
        *(void *)uint64_t v115 = *(void *)v115 & 0xFFFFFFFFFFFFFFFELL | LOBYTE(buf[0].f64[0]) & 1;
        *(void *)uint64_t v115 = *(void *)&buf[0].f64[0] & 0xFFFFFFFFFFFFFFFELL | v116 & 1;
        *(float64_t *)(v115 + 8) = buf[0].f64[1];
        *(void *)&buf[0].f64[1] = "";
        buf[0].f64[0] = 0.0;
        re::StringID::destroyString((re::StringID *)buf);

        *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[47];
      }
      uint64_t v204 = 1;
      goto LABEL_101;
    }
    LODWORD(v20re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 5;
    *((void *)&v207 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = a3[40];
    *(void *)&v199.var0 = 0;
    v199.uint64_t var1 = "";
    *(void *)&v200.var0 = 0;
    v200.uint64_t var1 = "";
    int v85 = [v10 objectPath];
    uint64_t v86 = [v195 nodeAtPath:v85];

    if (v86)
    {
      __srca = a3;
      uint64_t v88 = [v86 typeName];
      unint64_t v89 = [v88 stringValue];
      if ([v89 isEqualToString:@"Preliminary_Deformer"])
      {
      }
      else
      {
        uint64_t v124 = [v86 typeName];
        uint64_t v125 = [v124 stringValue];
        int v126 = [v125 isEqualToString:@"Deformer"];

        if (!v126)
        {
          uint64_t v137 = [v86 path];
          id v138 = [v137 stringValue];
          re::StringID::StringID((re::StringID *)v216, (const char *)[v138 UTF8String]);
          uint64_t v145 = *(void *)v216;
          char v146 = *(char **)&v216[8];
          *(void *)float v216 = 0;
          *(void *)&v216[8] = "";
          *(void *)&buf[0].f64[1] = "";
          *(void *)&buf[0].f64[0] = v145 & 0xFFFFFFFFFFFFFFFELL;
          *(void *)&v199.var0 = v145;
          v199.uint64_t var1 = v146;
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)v216);
          goto LABEL_95;
        }
      }
      uint64_t v127 = [v86 parent];
      if (v127)
      {
        uint64_t v128 = v127;
        int v129 = [v86 parent];
        uint64_t v130 = [v129 parent];

        if (v130)
        {
          uint64_t v131 = [v86 parent];
          uint64_t v132 = [v131 parent];
          int v133 = [v132 path];
          id v134 = [v133 stringValue];
          re::StringID::StringID((re::StringID *)v216, (const char *)[v134 UTF8String]);
          uint64_t v135 = *(void *)v216;
          int v136 = *(char **)&v216[8];
          *(void *)float v216 = 0;
          *(void *)&v216[8] = "";
          *(void *)&buf[0].f64[1] = "";
          *(void *)&buf[0].f64[0] = v135 & 0xFFFFFFFFFFFFFFFELL;
          *(void *)&v199.var0 = v135;
          v199.uint64_t var1 = v136;
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)v216);

          uint64_t v137 = [v86 properties];
          id v138 = [v137 objectForKeyedSubscript:@"info:id"];
          id v139 = [v138 stringValue];
          re::StringID::StringID((re::StringID *)v216, (const char *)[v139 UTF8String]);
          uint64_t v140 = *(void *)v216;
          unint64_t v141 = *(char **)&v216[8];
          *(void *)float v216 = 0;
          *(void *)&v216[8] = "";
          *(void *)&buf[0].f64[1] = "";
          *(void *)&buf[0].f64[0] = v140 & 0xFFFFFFFFFFFFFFFELL;
          *(void *)&v200.var0 = v140;
          v200.uint64_t var1 = v141;
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)v216);

LABEL_95:
          a3 = __srca;
          unint64_t v147 = __srca[40];
          unint64_t v46 = __srca[36];
          if (v147 + 1 > 8 * v46)
          {
            re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity(v175, (v147 + 8) >> 3);
            unint64_t v46 = __srca[36];
          }
          unint64_t v47 = v147 >> 3;
          if (v46 <= v147 >> 3) {
            goto LABEL_115;
          }
          uint64_t v148 = (void *)__srca[39];
          if (__srca[37]) {
            uint64_t v148 = v178;
          }
          uint64_t v149 = v148[v47];
          ++__srca[40];
          ++*((_DWORD *)__srca + 82);
          id v150 = re::StringID::StringID((re::StringID *)(v149 + 32 * (v147 & 7)), &v199);
          re::StringID::StringID((re::StringID *)((char *)v150 + 16), &v200);
          uint64_t v204 = 1;

          re::StringID::destroyString((re::StringID *)&v200);
          re::StringID::destroyString((re::StringID *)&v199);
LABEL_101:
          uint64_t v23 = 1;
          goto LABEL_55;
        }
      }
      float32x4_t v142 = *re::pipelineLogObjects(v127);
      a3 = __srca;
      if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v118 = v142;
        int v119 = [v10 objectPath];
        id v120 = [v119 stringValue];
        uint64_t v143 = [v120 UTF8String];
        LODWORD(buf[0].f64[0]) = 136315138;
        *(void *)((char *)buf[0].f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v143;
        int v122 = v118;
        uint64_t v123 = "Invalid path: %s";
        goto LABEL_90;
      }
    }
    else
    {
      uint64_t v117 = *re::pipelineLogObjects(v87);
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v118 = v117;
        int v119 = [v10 objectPath];
        id v120 = [v119 stringValue];
        uint64_t v121 = [v120 UTF8String];
        LODWORD(buf[0].f64[0]) = 136315138;
        *(void *)((char *)buf[0].f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v121;
        int v122 = v118;
        uint64_t v123 = "Failed to find target at path: %s";
LABEL_90:
        _os_log_impl(&dword_233120000, v122, OS_LOG_TYPE_DEFAULT, v123, (uint8_t *)buf, 0xCu);
      }
    }

    re::StringID::destroyString((re::StringID *)&v200);
    re::StringID::destroyString((re::StringID *)&v199);
    uint64_t v8 = v193;
LABEL_33:
    re::StringID::destroyString((re::StringID *)&v205);
    goto LABEL_34;
  }
LABEL_107:
}

uint64_t re::BucketArray<re::StringID,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::StringID,8ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 16 * (v2 & 7);
}

uint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + ((v2 & 7) << 6);
}

BOOL re::hasColliderAPI(void *a1)
{
  id v1 = a1;
  if (re::isRootNodeByPath(v1))
  {
    BOOL v2 = 0;
  }
  else
  {
    unint64_t v3 = [v1 property:@"preliminary:physics:collider:convexShape"];
    BOOL v2 = v3 != 0;
  }
  return v2;
}

uint64_t re::createEntityFromImportContext(_anonymous_namespace_ *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const char *a8, char a9)
{
  unint64_t v10 = a4;
  int v11 = v718;
  uint64_t v762 = *MEMORY[0x263EF8340];
  id v12 = *(__n128 **)(a7 + 8);
  if ((unint64_t)v12 <= a4) {
    goto LABEL_670;
  }
  size_t v14 = 1;
  *(unsigned char *)(*(void *)(a7 + 16) + are::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
  uint64_t v689 = 0;
  uint64_t v688 = 0;
  int v690 = 1;
  unint64_t v693 = 0;
  uint64_t v691 = 0;
  uint64_t v692 = 0;
  int v694 = 0;
  unint64_t v677 = 0;
  uint64_t v676 = 0;
  int v678 = 1;
  size_t v681 = 0;
  uint64_t v679 = 0;
  v680 = 0;
  int v682 = 0;
  unint64_t v684 = 0;
  v683[0] = 0;
  v683[1] = 0;
  int v685 = 0;
  memset(v686, 0, sizeof(v686));
  uint64_t v687 = 0x7FFFFFFFLL;
  long long v582 = (_anonymous_namespace_ *)v683;
  uint64_t v17 = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicString>::setCapacity(v683, 0x40uLL);
  ++v685;
  long long v584 = (uint64_t *)&v686[8];
  uint64_t v19 = *(void *)(a2 + 720);
  uint64_t v675 = 0;
  uint64_t v673 = 0;
  uint64_t v674 = 0;
  unint64_t v21 = *(void *)(a2 + 720);
  *(void *)&long long v732 = -1;
  uint64_t v672 = 0;
  uint64_t v670 = 0;
  uint64_t v671 = 0;
  LOBYTE(v7re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *((void *)&v732 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(void *)re::BucketArray<unsigned long,32ul>::operator[](a2 + 680, v10);
  long long v733 = xmmword_23435FD50;
  long long v734 = xmmword_23435FD60;
  long long v735 = xmmword_23435FD80;
  *(_OWORD *)v736 = xmmword_23435FBB0;
  re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::add((uint64_t)&v688, (uint64_t)&v732);
  uint64_t v661 = 0;
  uint64_t v660 = 0;
  v662 = "";
  char v663 = 1;
  uint64_t v665 = 0;
  v664[0] = 0;
  v664[1] = 0;
  uint64_t v669 = 0;
  memset(v667, 0, sizeof(v667));
  int v666 = 0;
  int v668 = 0;
  uint64_t v558 = a2 + 680;
  unint64_t v569 = v10;
  int v22 = (unint64_t *)re::BucketArray<unsigned long,32ul>::operator[](a2 + 680, v10);
  uint64_t v583 = a2;
  uint64_t v581 = a2 + 624;
  uint64_t v23 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a2 + 624, *v22);
  re::StringID::operator=((unint64_t *)&v661, (uint64_t *)(v23 + 8));
  unint64_t v24 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v660);
  long long v25 = *(_OWORD *)(v23 + 464);
  long long v26 = *(_OWORD *)(v23 + 432);
  *((_OWORD *)v24 + 3) = *(_OWORD *)(v23 + 448);
  *((_OWORD *)v24 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v25;
  *((_OWORD *)v24 + 2) = v26;
  uint64_t v27 = *(const char **)(v23 + 32);
  size_t v28 = strlen(v27);
  v658 = v27;
  size_t v659 = v28;
  unint64_t v29 = (unint64_t *)a6;
  if ((a9 & 1) == 0)
  {
    *(void *)&long long v732 = 0;
    long long v734 = 0u;
    long long v735 = 0u;
    *((void *)&v732 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
    long long v733 = 0uLL;
    *(void *)&long long v734 = 0;
    DWORD2(v73re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    memset(v736, 0, 24);
    re::DynamicArray<re::AnimationSceneEntityData>::add((void *)(a6 + 16), (uint64_t *)&v732);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v736);
    re::DynamicArray<re::AnimationSceneEntityData>::deinit((uint64_t)&v733);
    re::StringID::destroyString((re::StringID *)&v732);
    unint64_t v29 = (unint64_t *)(*(void *)(a6 + 48) + 88 * *(void *)(a6 + 32) - 88);
  }
  unint64_t v10 = (unint64_t)buf;
  size_t v9 = (size_t)&v701;
  unsigned int v567 = v29;
  unint64_t v30 = re::StringID::operator=(v29, &v661);
  uint64_t v652 = 0;
  uint64_t v651 = 0;
  int v653 = 1;
  size_t v656 = 0;
  uint64_t v654 = 0;
  v655 = 0;
  int v657 = 0;
  long long v732 = 0uLL;
  *(void *)&long long v733 = 0;
  v753 = 0;
  long long v734 = 0u;
  long long v735 = 0u;
  DWORD2(v733) = 0;
  *(_DWORD *)v736 = 0;
  memset(&v736[8], 0, 32);
  long long v738 = 0u;
  long long v739 = 0u;
  int v737 = 0;
  int v740 = 0;
  long long v741 = 0u;
  long long v742 = 0u;
  long long v744 = 0u;
  long long v745 = 0u;
  int v743 = 0;
  int v746 = 0;
  int v749 = 0;
  long long v748 = 0u;
  long long v747 = 0u;
  int v752 = 0;
  long long v750 = 0u;
  long long v751 = 0u;
  unint64_t v31 = a2;
  unint64_t v32 = *(void *)(a2 + 200);
  *(_DWORD *)v722 = -1;
  uint64_t v650 = 0;
  uint64_t v648 = 0;
  v649 = 0;
  memset(v722, 0, sizeof(v722));
  *(_OWORD *)&v724[2] = 0u;
  long long v725 = 0u;
  int v726 = 0;
  long long v727 = 0u;
  long long v728 = 0u;
  int v729 = 0;
  memset(v730, 0, sizeof(v730));
  uint64_t v731 = 0x7FFFFFFFLL;
  unint64_t v642 = 0;
  uint64_t v641 = 0;
  int v643 = 1;
  v646 = 0;
  uint64_t v644 = 0;
  v645 = 0;
  int v647 = 0;
  unint64_t v635 = 0;
  uint64_t v634 = 0;
  int v636 = 1;
  int v565 = &v644;
  v639 = 0;
  uint64_t v637 = 0;
  v638 = 0;
  int v640 = 0;
  unint64_t v628 = 0;
  uint64_t v627 = 0;
  int v629 = 1;
  v632 = 0;
  uint64_t v630 = 0;
  v631 = 0;
  int v633 = 0;
  uint64_t v33 = re::TimelineGroupBuilder::TimelineGroupBuilder((uint64_t)v622, *(void *)(a3 + 104), (uint64_t)v27, v28);
  unint64_t v36 = v693;
  if (v693)
  {
    std::string v589 = 0;
    size_t v14 = (size_t)buf;
    a2 += 56;
    uint64_t v566 = v583 + 160;
    v588 = (re::StringID *)(v583 + 56);
    while (1)
    {
      unint64_t v38 = v36 - 1;
      uint64_t v39 = (float32x4_t *)re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)&v688, v36 - 1);
      unint64_t v31 = v39->u8[0];
      unint64_t v40 = v39->u64[1];
      float32x4_t v612 = v39[2];
      float32x4_t v614 = v39[1];
      float32x4_t v608 = v39[4];
      float32x4_t v609 = v39[3];
      re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)&v688, v38);
      unint64_t v693 = v38;
      ++v694;
      uint64_t v33 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v581, v40);
      uint64_t v41 = v33;
      int v592 = v31;
      if (v31) {
        break;
      }
      uint64_t v42 = *(void *)(v33 + 160);
      _ZF = v42 == -1 || v42 == v569;
      if (_ZF) {
        break;
      }
      *(void *)re::BucketArray<re::TimelineGroupBuilder *,8ul>::addUninitialized(a5) = v622;
      LOBYTE(v5re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
      re::createEntityFromImportContext(&v701, v583, a3, *(void *)(v41 + 160), a5, v567, a7, a8, v556);
      uint64_t v33 = re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](a5, *(void *)(a5 + 40) - 1);
      --*(void *)(a5 + 40);
      ++*(_DWORD *)(a5 + 48);
      if (v701.n128_u8[0])
      {
        uint64_t v33 = re::DynamicArray<re::ecs2::EntityAssetData>::add((uint64_t)&v667[1], (uint64_t)&v701.n128_i64[1]);
        if (v701.n128_u8[0]) {
          re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)&v701.n128_i8[8]);
        }
      }
LABEL_349:
      unint64_t v36 = v693;
      if (!v693) {
        goto LABEL_352;
      }
    }
    unint64_t v44 = *(void *)(v33 + 624);
    if (v44) {
      unint64_t v45 = v44 >> 1;
    }
    else {
      unint64_t v45 = v44 >> 1;
    }
    size_t k = (size_t)&v703;
    if (!v45)
    {
      unint64_t v46 = *(void *)(v33 + 656);
      if (!((v46 & 1) != 0 ? v46 >> 1 : v46 >> 1))
      {
LABEL_126:
        if (*(unsigned __int8 *)(v41 + 240) != 255) {
        unint64_t v115 = *(void *)(v41 + 344);
        }
        uint64_t v116 = *(void *)(v41 + 304);
        if (v115)
        {
          if (!v116) {
            goto LABEL_317;
          }
          uint64_t v117 = 0;
          uint64_t v118 = v116 - 1;
          do
          {
            if (v115 == v117)
            {
              v712 = 0;
              float32x4_t v704 = 0u;
              float32x4_t v705 = 0u;
              float32x4_t v702 = 0u;
              float32x4_t v703 = 0u;
              __n128 v701 = 0u;
              uint64_t v333 = &_os_log_internal;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              buf[0].n128_u32[0] = 136315906;
              *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = (unint64_t)"operator[]";
              buf[0].n128_u16[6] = 1024;
              *(unsigned __int32 *)((char *)&buf[0].n128_u32[3] + 2) = 789;
              buf[1].n128_u16[1] = 2048;
              *(unint64_t *)((char *)buf[1].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v115;
              buf[1].n128_u16[6] = 2048;
              *(unint64_t *)((char *)&buf[1].n128_u64[1] + 6) = v115;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_451;
            }
            uint64_t v119 = *(void *)(*(void *)(v41 + 360) + 8 * v117);
            _ZF = v119 == -1;
            BOOL v120 = v119 == -1;
          }
          while (_ZF && v118 != v117++);
          uint64_t v116 = 1;
        }
        else
        {
          BOOL v120 = 1;
        }
        if (v592) {
          int v122 = 1;
        }
        else {
          int v122 = v120;
        }
        if (v116 && v122)
        {
          uint64_t v590 = *(void *)(v41 + 416);
          uint64_t v716 = 0;
          unint64_t v714 = 0;
          v712 = 0;
          unint64_t v713 = 0;
          LODWORD(v715) = 0;
          __n128 v701 = 0u;
          float32x4_t v702 = 0u;
          uint64_t v123 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v701, 0);
          float32x4_t v703 = 0uLL;
          v704.i32[2] = 0;
          v704.i64[0] = 0;
          uint64_t v711 = 0;
          float32x4_t v705 = 0u;
          long long v706 = 0u;
          int v707 = 0;
          long long v708 = 0u;
          long long v709 = 0u;
          int v710 = 0;
          uint64_t v124 = *(const char **)(v41 + 32);
          re::DynamicString::operator=((re::DynamicString *)&v701, (re::DynamicString *)buf);
          if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
            (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
          }
          uint64_t v125 = *(void *)(v41 + 304);
          unint64_t v31 = v125;
          if (v703.i64[1] < (unint64_t)v125) {
            re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v703, *(void *)(v41 + 304));
          }
          uint64_t v126 = v590;
          if (v713 < v125) {
          if (v125)
          }
          {
            unint64_t v10 = 0;
            v587 = (re::DynamicString *)(v125 - 1);
            BOOL v127 = v125 == 1;
            if (v125 == 1) {
              float v128 = INFINITY;
            }
            else {
              float v128 = (float)(100 * (unint64_t)(v125 + 1) - 500);
            }
            if (v125 > 5) {
              BOOL v127 = 1;
            }
            BOOL v602 = v127;
            unint64_t v598 = v125;
            do
            {
              unint64_t v129 = *(void *)(v41 + 304);
              if (v129 <= v10) {
                goto LABEL_452;
              }
              uint64_t v130 = *(void *)(v41 + 320);
              uint64_t v131 = *(void *)(v130 + 8 * v10);
              if (*(void *)(v131 + 48))
              {
                uint64_t v132 = v704.i64[0];
                if (v704.i64[0] >= (unint64_t)v703.i64[1])
                {
                  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(&v703, v704.i64[0] + 1);
                  uint64_t v132 = v704.i64[0];
                  uint64_t v131 = *(void *)(v130 + 8 * v10);
                }
                *(void *)(v705.i64[0] + 8 * v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v131;
                *(void *)(v130 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0;
                v704.i64[0] = v132 + 1;
                ++v704.i32[2];
                if (v126 && v10)
                {
                  unint64_t v133 = v10 - 1;
                  unint64_t v40 = *(void *)(v41 + 416);
                  if (v40 <= v10 - 1)
                  {
                    *(void *)v758 = 0;
                    memset(buf, 0, sizeof(buf));
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v718 = 136315906;
                    *(void *)&v718[4] = "operator[]";
                    *(_WORD *)v719 = 1024;
                    *(_DWORD *)&v719[2] = 468;
                    *(_WORD *)&v719[6] = 2048;
                    *(void *)&v719[8] = v10 - 1;
                    *(_WORD *)&v719[16] = 2048;
                    *(void *)&v719[18] = v40;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
LABEL_646:
                    *(void *)v758 = 0;
                    memset(buf, 0, sizeof(buf));
                    long long v316 = &_os_log_internal;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v718 = 136315906;
                    *(void *)&v718[4] = "operator[]";
                    *(_WORD *)v719 = 1024;
                    *(_DWORD *)&v719[2] = 468;
                    *(_WORD *)&v719[6] = 2048;
                    *(void *)&v719[8] = v10 - 1;
                    *(_WORD *)&v719[16] = 2048;
                    *(void *)&v719[18] = v40;
                    LODWORD(v55re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 38;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
                    goto LABEL_647;
                  }
                  float v134 = 1.0 - *(float *)(*(void *)(v41 + 424) + 4 * v133);
                  if (v134 < 0.0) {
                    float v134 = 0.0;
                  }
                  buf[0].n128_f32[0] = v134 * v134;
                  re::DynamicArray<float>::add((_anonymous_namespace_ *)((char *)&v708 + 8), (float *)buf);
                  unint64_t v40 = *(void *)(v41 + 416);
                  if (v40 <= v133) {
                    goto LABEL_646;
                  }
                  float v135 = v128;
                  if (!v602) {
                    float v135 = __const__ZN2re29computeDefaultLodMaxViewDepthEjj_kViewDepthTable[(void)v587];
                  }
                  buf[0].n128_f32[0] = v135 * *(float *)(*(void *)(v41 + 424) + 4 * v133);
                  re::DynamicArray<float>::add((_anonymous_namespace_ *)&v705.u32[2], (float *)buf);
                }
                if (*(void *)(v41 + 344) > v10)
                {
                  uint64_t v136 = *(void *)(v41 + 360);
                  unint64_t v137 = *(void *)(v136 + 8 * v10);
                  if (v137 != -1)
                  {
                    unint64_t v40 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](a2, *(void *)(v136 + 8 * v10));
                    uint64_t v138 = *(void *)(a3 + 104);
                    id v139 = *(const char **)(v40 + 8);
                    size_t v9 = strlen(v139);
                    uint64_t v140 = re::SkeletonAsset::assetType((re::SkeletonAsset *)v9);
                    uint64_t v141 = re::ImportAssetTable::importedAsset(v138, (uint64_t)v139, v9, (re **)v140);
                    if (!v141)
                    {
                      uint64_t v143 = *re::pipelineLogObjects(0);
                      a2 = v583 + 56;
                      unint64_t v31 = v598;
                      if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v144 = v143;
                        unint64_t v145 = *(void *)(v40 + 8);
                        buf[0].n128_u32[0] = 136315138;
                        *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v145;
                        _os_log_error_impl(&dword_233120000, v144, OS_LOG_TYPE_ERROR, "Could not locate skeleton asset: %s", (uint8_t *)buf, 0xCu);
                      }
                      goto LABEL_256;
                    }
                    buf[0].n128_u32[0] = 0;
                    buf[1] = 0uLL;
                    buf[0].n128_u64[1] = 0;
                    if (*(unsigned char *)(v141 + 8)) {
                      float32x4_t v142 = *(re::AssetPath **)(v141 + 16);
                    }
                    else {
                      float32x4_t v142 = (re::AssetPath *)(v141 + 9);
                    }
                    a2 = v583 + 56;
                    char v146 = (unsigned __int32 *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&v730[8], (void *)v40);
                    if (v146)
                    {
                      unsigned __int32 v147 = *v146;
                      buf[0].n128_u32[0] = *v146;
                      unint64_t v40 = (unint64_t)&buf[0].n128_u64[1];
                    }
                    else
                    {
                      uint64_t v148 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)v588, v137);
                      buf[0].n128_u32[0] = DWORD2(v728);
                      uint64_t v149 = re::globalAllocators((re *)v148);
                      size_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v149[2] + 32))(v149[2], 184, 8);
                      ArcSharedObject::ArcSharedObject((ArcSharedObject *)v9, 0);
                      *(void *)size_t v9 = &unk_26E6DF818;
                      re::StringID::StringID((re::StringID *)(v9 + 24), (const StringID *)(v148 + 16));
                      re::FixedArray<re::StringID>::FixedArray((unint64_t *)(v9 + 40), v148 + 32);
                      re::FixedArray<unsigned int>::FixedArray((uint64_t *)(v9 + 64), v148 + 56);
                      re::FixedArray<re::GenericSRT<float>>::FixedArray((void *)(v9 + 88), v148 + 80);
                      re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(v9 + 112), v148 + 104);
                      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(v9 + 136, v148 + 128);
                      *(void *)v759 = v9;
                      re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add((void *)&v727 + 1, v759);
                      if (*(void *)v759) {

                      }
                      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<unsigned int &>((uint64_t)&v730[8], (StringID *)v40, buf);
                      re::StringID::StringID((re::StringID *)&v617, (const StringID *)(v148 + 16));
                      uint64_t v150 = *(void *)(v148 + 40);
                      *(void *)v759 = *(void *)(v148 + 48);
                      *(void *)&v759[8] = v150;
                      uint64_t v151 = *(void *)(v148 + 88);
                      uint64_t v695 = *(void *)(v148 + 96);
                      uint64_t v696 = v151;
                      unint64_t v40 = (unint64_t)&buf[0].n128_u64[1];
                      re::AssetHandle::AssetHandle((re::AssetHandle *)v758, (const re::AssetHandle *)&buf[0].n128_i8[8]);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)v758);
                      re::StringID::destroyString((re::StringID *)&v617);
                      unsigned __int32 v147 = buf[0].n128_u32[0];
                      a2 = v583 + 56;
                    }
                    v718[0] = 1;
                    *(_DWORD *)&v718[8] = v147;
                    *(__n128 *)&v719[4] = *(__n128 *)((char *)buf + 8);
                    buf[1].n128_u64[0] = 0;
                    buf[0].n128_u64[1] = 0;
                    *(void *)&v719[20] = buf[1].n128_u64[1];
                    buf[1].n128_u64[1] = 0;
                    re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[0].n128_i8[8]);
                    unint64_t v31 = v598;
                    if (v718[0])
                    {
                      buf[0].n128_u64[0] = 0xFFFFFFFFLL;
                      buf[0].n128_u64[1] = -1;
                      buf[1].n128_u64[0] = -1;
                      *(__n128 *)((char *)&buf[1] + 8) = 0u;
                      *(__n128 *)((char *)&buf[2] + 8) = 0u;
                      *(__n128 *)((char *)&buf[3] + 8) = 0u;
                      if (v714 >= v713)
                      {
                        unint64_t v153 = v714 + 1;
                        if (v713 < v714 + 1)
                        {
                          if (v712)
                          {
                            unint64_t v154 = 8;
                            if (v713) {
                              unint64_t v154 = 2 * v713;
                            }
                            if (v154 <= v153) {
                              unint64_t v155 = v714 + 1;
                            }
                            else {
                              unint64_t v155 = v154;
                            }
                          }
                          else
                          {
                            LODWORD(v715) = v715 + 1;
                          }
                        }
                      }
                      long long v156 = (__n128 *)(v716 + 72 * v714);
                      unint64_t v157 = buf[1].n128_u64[0];
                      *long long v156 = buf[0];
                      v156[1].n128_u64[0] = v157;
                      v156[1].n128_u64[1] = 0;
                      v156[2].n128_u64[0] = 0;
                      v156[2].n128_u64[1] = 0;
                      v156[2].n128_u64[0] = buf[2].n128_u64[0];
                      buf[2].n128_u64[0] = 0;
                      unint64_t v158 = v156[1].n128_u64[1];
                      v156[1].n128_u64[1] = 0;
                      v156[1].n128_u64[1] = buf[1].n128_u64[1];
                      buf[1].n128_u64[1] = v158;
                      unint64_t v159 = v156[2].n128_u64[1];
                      v156[2].n128_u64[1] = buf[2].n128_u64[1];
                      buf[2].n128_u64[1] = v159;
                      v156[3].n128_u64[0] = 0;
                      v156[3].n128_u64[1] = 0;
                      v156[4].n128_u64[0] = 0;
                      v156[3].n128_u64[1] = buf[3].n128_u64[1];
                      buf[3].n128_u64[1] = 0;
                      unint64_t v160 = v156[3].n128_u64[0];
                      v156[3].n128_u64[0] = 0;
                      v156[3].n128_u64[0] = buf[3].n128_u64[0];
                      buf[3].n128_u64[0] = v160;
                      unint64_t v161 = v156[4].n128_u64[0];
                      v156[4].n128_u64[0] = buf[4].n128_u64[0];
                      buf[4].n128_u64[0] = v161;
                      ++v714;
                      LODWORD(v715) = v715 + 1;
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[3]);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1].n128_i8[8]);
                      uint64_t v162 = v716;
                      size_t v9 = v714 - 1;
                      unint64_t v31 = v716 + 72 * (v714 - 1);
                      *(void *)(v31 + 8) = v137;
                      unint64_t v40 = v31 + 8;
                      uint64_t v163 = (re *)re::AssetHandle::operator=(v31 + 24, (uint64_t *)&v719[4]);
                      long long v164 = *(__n128 **)(v41 + 384);
                      if (v164)
                      {
                        size_t v570 = v9;
                        uint64_t v572 = v162;
                        size_t k = (size_t)&v703;
                        if ((unint64_t)v164 <= v10) {
                          goto LABEL_661;
                        }
                        unint64_t v165 = *(void *)(*(void *)(v41 + 400) + 8 * v10);
                        size_t v166 = v572 + 72 * v9;
                        *(void *)(v166 + 16) = v165;
                        float32x4_t v167 = (unint64_t *)(v166 + 16);
                        size_t v9 = *(unsigned int *)&v718[8];
                        *(_DWORD *)unint64_t v31 = *(_DWORD *)&v718[8];
                        if (v165 != -1)
                        {
                          if (!v589)
                          {
                            long long v168 = re::globalAllocators(v163);
                            uint64_t v169 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v168[2] + 32))(v168[2], 224, 8);
                            *(_OWORD *)(v169 + 176) = 0u;
                            *(_OWORD *)(v169 + 192) = 0u;
                            *(_OWORD *)uint64_t v169 = 0u;
                            *(_OWORD *)(v169 + 16) = 0u;
                            *(_OWORD *)(v169 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
                            *(_OWORD *)(v169 + 48) = 0u;
                            *(_OWORD *)(v169 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
                            *(_OWORD *)(v169 + 80) = 0u;
                            *(_OWORD *)(v169 + 96) = 0u;
                            *(_OWORD *)(v169 + 112) = 0u;
                            *(_OWORD *)(v169 + 128) = 0u;
                            *(_OWORD *)(v169 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
                            *(_OWORD *)(v169 + 160) = 0u;
                            *(_DWORD *)(v169 + 196) = 0x7FFFFFFF;
                            *(void *)(v169 + 208) = 0;
                            *(void *)(v169 + 216) = "";
                            std::string v589 = (_anonymous_namespace_ *)v169;
                            unint64_t v165 = *v167;
                            size_t v9 = *(unsigned int *)&v718[8];
                          }
                          unint64_t v31 = *(void *)v40;
                          re::AssetHandle::AssetHandle((re::AssetHandle *)v621, (const re::AssetHandle *)&v719[4]);
                          unint64_t v568 = v165;
                          uint64_t v170 = *(void *)(re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](v566, v165)+ 8);
                          size_t v171 = "_additive";
                          if (!*(unsigned char *)(*(void *)(v583 + 40) + 160)) {
                            size_t v171 = "";
                          }
                          size_t v564 = v9;
                          uint64_t v172 = (re::TimelineAsset *)re::DynamicString::format((re::DynamicString *)"%s_skeleton[%u]%s", (re::DynamicString *)&v617, v170, v9, v171);
                          uint64_t v173 = *(void *)(a3 + 104);
                          if ((uint64_t)v617.var1) {
                            uint64_t v174 = v618;
                          }
                          else {
                            uint64_t v174 = (int32x2_t *)((char *)&v617.var1 + 1);
                          }
                          if ((uint64_t)v617.var1) {
                            uint64_t v175 = (unint64_t)v617.var1 >> 1;
                          }
                          else {
                            uint64_t v175 = LOBYTE(v617.var1) >> 1;
                          }
                          uint64_t v176 = re::TimelineAsset::assetType(v172);
                          uint64_t v177 = (_anonymous_namespace_ *)re::ImportAssetTable::importedAsset(v173, (uint64_t)v174, v175, (re **)v176);
                          unint64_t v40 = (unint64_t)v177;
                          if (!v177)
                          {
                            long long v178 = re::globalAllocators(0);
                            uint64_t v179 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v178[2] + 32))(v178[2], 200, 8);
                            uint64_t v180 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](v566, v568);
                            re::AnimationAssetData<re::SkeletalPoseAssetData>::AnimationAssetData(v179, v180 + 32);
                            *(void *)uint64_t v179 = &unk_26E6D0DD8;
                            uint64_t v181 = *(void *)(v180 + 105);
                            *(void *)(v179 + 80) = *(void *)(v180 + 112);
                            *(void *)(v179 + 73) = v181;
                            re::DynamicArray<re::SkeletalPoseAssetData>::DynamicArray(v179 + 88, (uint64_t *)(v180 + 120));
                            *(void *)uint64_t v179 = &unk_26E6D0D68;
                            re::AssetHandle::AssetHandle((re::AssetHandle *)(v179 + 128), (const re::AssetHandle *)(v180 + 160));
                            re::DynamicArray<re::StringID>::DynamicArray(v179 + 152, (uint64_t *)(v180 + 184));
                            __int16 v182 = *(_WORD *)(v180 + 224);
                            *(unsigned char *)(v179 + 19re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(unsigned char *)(v180 + 226);
                            *(_WORD *)(v179 + 192) = v182;
                            re::DynamicString::format((re::DynamicString *)"SkeletalPose.SkeletalPoses[%u]", (re::DynamicString *)buf, v564);
                            re::DynamicString::operator=((re::DynamicString *)(v179 + 40), (re::DynamicString *)buf);
                            if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
                              (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
                            }
                            re::AssetHandle::operator=(v179 + 128, v621);
                            if (*(unsigned char *)(*(void *)(v583 + 40) + 160))
                            {
                              uint64_t v184 = (_anonymous_namespace_ *)re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)v588, v31);
                              memset(v759, 0, 24);
                              unint64_t v185 = *(void *)(v179 + 168);
                              long long v586 = *(__n128 **)(v179 + 168);
                              if (v586)
                              {
                                a2 = 0;
                                long long v164 = 0;
                                uint64_t v574 = (uint64_t)v184 + 128;
                                size_t k = 8;
                                uint64_t v561 = v179;
                                while (1)
                                {
                                  size_t v9 = *(void *)(v179 + 168);
                                  if (v9 <= (unint64_t)v164) {
                                    break;
                                  }
                                  unint64_t v31 = *(void *)(v179 + 184);
                                  int v186 = (unsigned int *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v574, (void *)(v31 + k - 8));
                                  if (v186)
                                  {
                                    size_t v9 = *v186;
                                    unint64_t v31 = *((void *)v184 + 11);
                                    if (v31 <= v9) {
                                      goto LABEL_656;
                                    }
                                    unint64_t v31 = *(void *)&v759[8];
                                    if (*(void *)&v759[8] <= (unint64_t)v164) {
                                      goto LABEL_657;
                                    }
                                    int v187 = (long long *)(*((void *)v184 + 12) + 48 * v9);
                                    uint64_t v188 = (_OWORD *)(*(void *)&v759[16] + a2);
                                    long long v189 = v187[2];
                                    long long v190 = *v187;
                                    v188[1] = v187[1];
                                    v188[2] = v189;
                                    _OWORD *v188 = v190;
                                  }
                                  else
                                  {
                                    uint64_t v191 = *re::pipelineLogObjects(0);
                                    if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
                                    {
                                      uint64_t v192 = v184;
                                      if ((uint64_t)v617.var1) {
                                        int v193 = v618;
                                      }
                                      else {
                                        int v193 = (int32x2_t *)((char *)&v617.var1 + 1);
                                      }
                                      id v194 = v191;
                                      unint64_t v195 = *(void *)(v31 + k);
                                      buf[0].n128_u32[0] = 136315394;
                                      *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = (unint64_t)v193;
                                      uint64_t v184 = v192;
                                      uint64_t v179 = v561;
                                      buf[0].n128_u16[6] = 2080;
                                      *(unint64_t *)((char *)&buf[0].n128_u64[1] + 6) = v195;
                                      _os_log_impl(&dword_233120000, v194, OS_LOG_TYPE_DEFAULT, "[%s] Unknown animated joint: %s\n", (uint8_t *)buf, 0x16u);
                                    }
                                    size_t v9 = *(void *)&v759[8];
                                    if (*(void *)&v759[8] <= (unint64_t)v164) {
                                      goto LABEL_660;
                                    }
                                    uint64_t v196 = (void *)(*(void *)&v759[16] + a2);
                                    v196[1] = 1065353216;
                                    v196[2] = 0;
                                    *uint64_t v196 = 0x3F8000003F800000;
                                    v196[3] = 0x3F80000000000000;
                                    v196[4] = 0;
                                    v196[5] = 0;
                                  }
                                  long long v164 = (__n128 *)((char *)v164 + 1);
                                  k += 16;
                                  a2 += 48;
                                  if (v586 == v164) {
                                    goto LABEL_229;
                                  }
                                }
LABEL_655:
                                uint64_t v695 = 0;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 789;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v164;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v9;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_656:
                                uint64_t v695 = 0;
                                long long v164 = buf;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 476;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v9;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v31;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_657:
                                uint64_t v695 = 0;
                                unint64_t v40 = (unint64_t)buf;
                                memset(buf, 0, sizeof(buf));
                                unint64_t v309 = &_os_log_internal;
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 468;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v164;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v31;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_658:
                                *(void *)v759 = 0;
                                *(_OWORD *)(v10 + 48) = 0u;
                                *(_OWORD *)(v10 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
                                *(_OWORD *)(v10 + 16) = 0u;
                                *(_OWORD *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
                                *(_OWORD *)unint64_t v10 = 0u;
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)(v10 + 142) = 789;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)(v10 + 148) = v309;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)(v10 + 158) = v31;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_659:
                                *(void *)v759 = 0;
                                long long v164 = buf;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 797;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = a2;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v40;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_660:
                                uint64_t v695 = 0;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 468;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v164;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v9;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_661:
                                *(void *)&v617.var0 = 0;
                                unint64_t v40 = (unint64_t)buf;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 789;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v10;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v164;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_662:
                                *(void *)v759 = 0;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 797;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = a2;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v40;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_663:
                                *(void *)v759 = 0;
                                unint64_t v129 = (unint64_t)buf;
                                memset(buf, 0, sizeof(buf));
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v758 = 136315906;
                                *(void *)&v758[4] = "operator[]";
                                *(_WORD *)&v758[12] = 1024;
                                *(_DWORD *)&v758[14] = 789;
                                *(_WORD *)&v758[18] = 2048;
                                *(void *)&v758[20] = v14;
                                *(_WORD *)&v758[28] = 2048;
                                *(void *)&v758[30] = v31;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
LABEL_664:
                                *(void *)v758 = 0;
                                *(_OWORD *)(a2 + 48) = 0u;
                                *(_OWORD *)(a2 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
                                *(_OWORD *)(a2 + 16) = 0u;
                                *(_OWORD *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
                                *(_OWORD *)a2 = 0u;
                                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                                *(_DWORD *)v718 = 136315906;
                                *(void *)&v718[4] = "operator[]";
                                *(_WORD *)v719 = 1024;
                                *(_DWORD *)&v719[2] = 858;
                                *(_WORD *)&v719[6] = 2048;
                                *(void *)&v719[8] = v40;
                                *(_WORD *)&v719[16] = 2048;
                                *(void *)&v719[18] = v129;
                                _os_log_send_and_compose_impl();
                                _os_crash_msg();
                                __break(1u);
                                goto LABEL_665;
                              }
LABEL_229:
                              uint64_t v197 = *(uint64_t **)(v179 + 104);
                              *(void *)v758 = *(void *)(v179 + 120);
                              *(void *)&v758[8] = v197;
                              buf[0].n128_u64[0] = (unint64_t)v759;
                              buf[0].n128_u64[1] = 1;
                              *(unsigned char *)(v179 + 72) = re::AnimationHelper::makeAdditiveForValues<re::SkeletalPoseAssetData>((re *)v758, (uint64_t *)buf, *(uint64_t *)v758, v197);
                              if (*(void *)v759 && *(void *)&v759[8]) {
                                (*(void (**)(void))(**(void **)v759 + 40))();
                              }
                              size_t k = (size_t)&v703;
                            }
                            uint64_t v198 = *(_anonymous_namespace_ **)(a3 + 104);
                            if ((uint64_t)v617.var1) {
                              StringID v199 = v618;
                            }
                            else {
                              StringID v199 = (int32x2_t *)((char *)&v617.var1 + 1);
                            }
                            if ((uint64_t)v617.var1) {
                              uint64_t v200 = (unint64_t)v617.var1 >> 1;
                            }
                            else {
                              uint64_t v200 = LOBYTE(v617.var1) >> 1;
                            }
                            TimelineAsset = re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v179, v183);
                            long long v202 = re::TimelineAsset::assetType((re::TimelineAsset *)TimelineAsset);
                            uint64_t v177 = (_anonymous_namespace_ *)re::ImportAssetTable::addAsset(v198, (uint64_t)v199, v200, TimelineAsset, (re **)v202);
                            unint64_t v40 = (unint64_t)v177;
                          }
                          memset(v759, 0, 24);
                          if (*(unsigned char *)(v40 + 8)) {
                            long long v203 = *(re::AssetPath **)(v40 + 16);
                          }
                          else {
                            long long v203 = (re::AssetPath *)(v40 + 9);
                          }
                          a2 = v583 + 56;
                          uint64_t v126 = v590;
                          size_t v9 = v568;
                          unint64_t v129 = (unint64_t)v649;
                          if ((unint64_t)v649 <= v568) {
                            goto LABEL_668;
                          }
                          unint64_t v31 = v598;
                          if (*(_DWORD *)(v650 + 4 * v568) == -1)
                          {
                            uint64_t v204 = *(void *)(*(void *)(v40 + 40) + 8);
                            if (*(void *)(v204 + 104))
                            {
                              uint64_t v205 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](v566, v568);
                              double v206 = (float)(*(float *)(v204 + 84) - *(float *)(v204 + 80));
                              buf[0].n128_u64[0] = *(void *)(v205 + 232);
                              buf[0].n128_f64[1] = v206;
                              re::AssetHandle::AssetHandle((re::AssetHandle *)&buf[1], (const re::AssetHandle *)v759);
                              re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1]);
                              id v12 = v649;
                              if ((unint64_t)v649 <= v568) {
                                goto LABEL_671;
                              }
                              *(_DWORD *)(v650 + 4 * v568) = v564;
                            }
                          }
                          if (*(void *)&v617.var0 && ((uint64_t)v617.var1 & 1) != 0) {
                            (*(void (**)(void))(**(void **)&v617.var0 + 40))();
                          }
                          long long v207 = (void *)(v572 + 72 * v570);
                          uint64_t v208 = v207[7];
                          v207[7] = *(void *)&v759[8];
                          *(void *)&v759[8] = v208;
                          uint64_t v209 = v207[6];
                          v207[6] = 0;
                          v207[6] = *(void *)v759;
                          *(void *)v759 = v209;
                          uint64_t v210 = v207[8];
                          v207[8] = *(void *)&v759[16];
                          *(void *)&v759[16] = v210;
                          re::AssetHandle::~AssetHandle((re::AssetHandle *)v759);
                          re::AssetHandle::~AssetHandle((re::AssetHandle *)v621);
                          goto LABEL_254;
                        }
                      }
                      else
                      {
                        *(void *)(v162 + 72 * v9 + 16) = -1;
                        *(_DWORD *)unint64_t v31 = *(_DWORD *)&v718[8];
                        size_t k = (size_t)&v703;
                      }
                      uint64_t v126 = v590;
                      unint64_t v31 = v598;
LABEL_254:
                      if (v718[0]) {
                        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v719[4]);
                      }
                      goto LABEL_256;
                    }
                    size_t k = (size_t)&v703;
                    uint64_t v126 = v590;
                  }
                }
              }
LABEL_256:
              ++v10;
            }
            while (v10 != v31);
          }
          a2 = (unint64_t)buf;
          size_t v9 = 24;
          if (v704.i64[0])
          {
            unint64_t v31 = (unint64_t)v646;
            unint64_t v129 = v642;
            if ((unint64_t)v646 + 1 > 8 * v642)
            {
              unint64_t v129 = v642;
            }
            unint64_t v40 = v31 >> 3;
            if (v129 <= v31 >> 3) {
              goto LABEL_664;
            }
            float64x2_t v211 = v645;
            if (v643) {
              float64x2_t v211 = &v644;
            }
            uint64_t v212 = v211[v40];
            v646 = (int32x2_t *)((char *)v646 + 1);
            ++v647;
            uint64_t v213 = v212 + 40 * (v31 & 7);
            *(void *)(v213 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
            *(void *)(v213 + 8) = 0;
            *(void *)(v213 + 16) = 0;
            *(void *)uint64_t v213 = 0;
            *(_DWORD *)(v213 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
            *(void *)uint64_t v213 = v712;
            v712 = 0;
            *(void *)(v213 + 8) = v713;
            unint64_t v713 = 0;
            unint64_t v214 = *(void *)(v213 + 16);
            *(void *)(v213 + 16) = v714;
            unint64_t v714 = v214;
            uint64_t v215 = *(void *)(v213 + 32);
            *(void *)(v213 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v716;
            uint64_t v716 = v215;
            LODWORD(v715) = v715 + 1;
            ++*(_DWORD *)(v213 + 24);
            re::DynamicArray<re::ModelWithLodsDescriptor>::add((_anonymous_namespace_ *)v722, (uint64_t)&v701);
            buf[0] = (__n128)v614;
            buf[1] = (__n128)v612;
            float64x2_t buf[2] = (__n128)v609;
            buf[3] = (__n128)v608;
            buf[4].n128_u32[0] = *(_DWORD *)&v722[16] - 1;
            re::make::shared::object<re::ShareableInternal<re::GeomInstance>,re::GeomInstance>((uint64_t)buf, (uint64_t *)v718);
            float v216 = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(&v724[10], v718);
            if (*(void *)v718) {

            }
            unint64_t v129 = *(unsigned __int16 *)(v41 + 824);
            memset(v758, 0, 24);
            size_t k = v681;
            unint64_t v40 = v677;
            if (v681 + 1 > 16 * v677)
            {
              re::BucketArray<re::FixedArray<unsigned short>,16ul>::setBucketsCapacity(&v676, (v681 + 16) >> 4);
              unint64_t v40 = v677;
            }
            unint64_t v31 = k >> 4;
            if (v40 <= k >> 4)
            {
LABEL_665:
              *(void *)&v617.var0 = 0;
              *(_OWORD *)(a2 + 48) = 0u;
              *(_OWORD *)(a2 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
              *(_OWORD *)(a2 + 16) = 0u;
              *(_OWORD *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
              *(_OWORD *)a2 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v718 = 136315906;
              *(void *)&v718[4] = "operator[]";
              *(_WORD *)v719 = 1024;
              *(_DWORD *)&v719[2] = 858;
              *(_WORD *)&v719[6] = 2048;
              *(void *)&v719[8] = v31;
              *(_WORD *)&v719[16] = 2048;
              *(void *)&v719[18] = v40;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_666:
              *(void *)v758 = 0;
              *(_OWORD *)(k + 48) = 0u;
              *(_OWORD *)(k + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
              *(_OWORD *)(k + 16) = 0u;
              *(_OWORD *)(k + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
              *(_OWORD *)size_t k = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v718 = 136315906;
              *(void *)&v718[4] = "operator[]";
              *(_WORD *)v719 = 1024;
              *(_DWORD *)&v719[2] = 858;
              *(_WORD *)&v719[6] = 2048;
              *(void *)&v719[8] = v40;
              *(_WORD *)&v719[16] = 2048;
              *(void *)&v719[18] = v129;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_667:
              *(void *)v758 = 0;
              *(_OWORD *)(k + 48) = 0u;
              *(_OWORD *)(k + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
              *(_OWORD *)(k + 16) = 0u;
              *(_OWORD *)(k + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
              *(_OWORD *)size_t k = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v718 = 136315906;
              *(void *)&v718[4] = "operator[]";
              *(_WORD *)v719 = 1024;
              *(_DWORD *)&v719[2] = 858;
              *(_WORD *)&v719[6] = 2048;
              *(void *)&v719[8] = v40;
              *(_WORD *)&v719[16] = 2048;
              *(void *)&v719[18] = v129;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_668:
              uint64_t v695 = 0;
              long long v317 = buf;
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v758 = 136315906;
              *(void *)&v758[4] = "operator[]";
              *(_WORD *)&v758[12] = 1024;
              *(_DWORD *)&v758[14] = 468;
              *(_WORD *)&v758[18] = 2048;
              *(void *)&v758[20] = v9;
              *(_WORD *)&v758[28] = 2048;
              *(void *)&v758[30] = v129;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_669:
              *(void *)v759 = 0;
              id v12 = buf;
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v758 = 136315906;
              *(void *)&v758[4] = "operator[]";
              *(_WORD *)&v758[12] = 1024;
              *(_DWORD *)&v758[14] = 797;
              *(_WORD *)&v758[18] = 2048;
              *(void *)&v758[20] = a2;
              *(_WORD *)&v758[28] = 2048;
              *(void *)&v758[30] = v317;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_670:
              v701.n128_u64[0] = 0;
              v11[19] = 0u;
              v11[20] = 0u;
              v11[17] = 0u;
              v11[18] = 0u;
              v11[16] = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v722 = 136315906;
              *(void *)&v722[4] = "operator[]";
              *(_WORD *)&v722[12] = 1024;
              *(_DWORD *)&v722[14] = 468;
              *(_WORD *)&v722[18] = 2048;
              *(void *)&v722[20] = v10;
              __int16 v723 = 2048;
              *(void *)v724 = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_671:
              uint64_t v695 = 0;
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)v758 = 136315906;
              *(void *)&v758[4] = "operator[]";
              *(_WORD *)&v758[12] = 1024;
              *(_DWORD *)&v758[14] = 468;
              *(_WORD *)&v758[18] = 2048;
              *(void *)&v758[20] = v9;
              *(_WORD *)&v758[28] = 2048;
              *(void *)&v758[30] = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_672:
              re::internal::assertLog((re::internal *)4, v34, *(double *)v35.i64, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
              _os_crash();
              __break(1u);
LABEL_673:
              re::internal::assertLog((re::internal *)4, v463, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 754);
              _os_crash();
              __break(1u);
              goto LABEL_674;
            }
            __int16 v217 = v680;
            if (v678) {
              __int16 v217 = &v679;
            }
            uint64_t v218 = v217[v31];
            ++v681;
            ++v682;
            __int16 v219 = (void *)(v218 + 24 * (k & 0xF));
            void *v219 = 0;
            v219[1] = 0;
            v219[2] = 0;
            void *v219 = *(void *)v758;
            v219[1] = *(void *)&v758[8];
            v219[2] = *(void *)&v758[16];
            if (v129)
            {
              unint64_t v10 = 0;
              unint64_t v40 = v681 - 1;
              while (1)
              {
                unint64_t v31 = *(void *)(v41 + 824);
                if (v31 <= v10) {
                  goto LABEL_454;
                }
                re::AssetHandle::serializationString((re::AssetHandle *)(*(void *)(v41 + 840) + 24 * v10), (re::DynamicString *)v758);
                unint64_t v220 = (__int16 *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v686[8], (uint64_t)v758);
                if (!v220) {
                  break;
                }
                __int16 v221 = *v220;
LABEL_284:
                uint64_t v226 = re::BucketArray<re::FixedArray<unsigned short>,16ul>::operator[]((uint64_t)&v676, v40);
                unint64_t v31 = *(void *)(v226 + 8);
                if (v31 <= v10) {
                  goto LABEL_455;
                }
                *(_WORD *)(*(void *)(v226 + 16) + 2 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = v221;
                if (*(void *)v758 && (v758[8] & 1) != 0) {
                  (*(void (**)(void))(**(void **)v758 + 40))();
                }
                if (++v10 == v129) {
                  goto LABEL_289;
                }
              }
              re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v683, (re::DynamicString *)v758);
              buf[0].n128_u16[0] = v684 - 1;
              unint64_t v222 = re::Hash<re::DynamicString>::operator()((uint64_t)v718, (uint64_t)v758);
              unint64_t v223 = v222;
              if (*(void *)&v686[8])
              {
                a2 = v222 % *(unsigned int *)&v686[32];
                uint64_t v224 = *(unsigned int *)(*(void *)&v686[16] + 4 * a2);
                if (v224 != 0x7FFFFFFF)
                {
                  uint64_t v225 = *(void *)&v686[24];
                  while (!re::DynamicString::operator==(v225 + 56 * v224 + 16, (uint64_t)v758))
                  {
                    uint64_t v224 = *(_DWORD *)(v225 + 56 * v224 + 8) & 0x7FFFFFFF;
                    if (v224 == 0x7FFFFFFF) {
                      goto LABEL_282;
                    }
                  }
                  goto LABEL_283;
                }
              }
              else
              {
                a2 = 0;
              }
LABEL_282:
              re::HashTable<re::DynamicString,unsigned short,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)&v686[8], a2, v223, (re::DynamicString *)v758, buf);
              ++HIDWORD(v687);
LABEL_283:
              __int16 v221 = v684 - 1;
              size_t v9 = 24;
              goto LABEL_284;
            }
LABEL_289:
            uint64_t v227 = v639;
            unint64_t v129 = v635;
            if ((unint64_t)v639 + 1 > 8 * v635)
            {
              unint64_t v129 = v635;
            }
            unint64_t v40 = (unint64_t)v227 >> 3;
            size_t k = (size_t)buf;
            if (v129 <= (unint64_t)v227 >> 3) {
              goto LABEL_666;
            }
            long long v228 = v638;
            if (v636) {
              long long v228 = &v637;
            }
            uint64_t v229 = v228[v40];
            v639 = (int32x2_t *)((char *)v639 + 1);
            ++v640;
            re::DynamicArray<re::GeomDeformer>::DynamicArray(v229 + 40 * (v227 & 7), (uint64_t *)(v41 + 1024));
            unint64_t v31 = (unint64_t)v632;
            unint64_t v129 = v628;
            if ((unint64_t)v632 + 1 > 8 * v628)
            {
              re::BucketArray<re::TimelineGroupBuilder *,8ul>::setBucketsCapacity(&v627, (unint64_t)&v632[1] >> 3);
              unint64_t v129 = v628;
            }
            unint64_t v40 = v31 >> 3;
            if (v129 <= v31 >> 3) {
              goto LABEL_667;
            }
            uint64_t v230 = v631;
            if (v629) {
              uint64_t v230 = &v630;
            }
            uint64_t v231 = v230[v40];
            v632 = (int32x2_t *)((char *)v632 + 1);
            ++v633;
            *(void *)(v231 + 8 * (v31 & 7)) = v41 + 992;
          }
          uint64_t v232 = *(void *)(v41 + 304);
          *(void *)(v41 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
          if (v232)
          {
            uint64_t v233 = *(void *)(v41 + 320);
            uint64_t v234 = 8 * v232;
            do
            {
              if (*(void *)v233)
              {

                *(void *)uint64_t v233 = 0;
              }
              v233 += 8;
              v234 -= 8;
            }
            while (v234);
          }
          ++*(_DWORD *)(v41 + 312);
          *(void *)(v41 + 34re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
          ++*(_DWORD *)(v41 + 352);
          *(void *)(v41 + 38re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
          ++*(_DWORD *)(v41 + 392);
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v41 + 408));
          if (*((void *)&v708 + 1))
          {
            if (v711) {
              (*(void (**)(void))(**((void **)&v708 + 1) + 40))();
            }
            uint64_t v711 = 0;
            long long v709 = 0uLL;
            *((void *)&v708 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
            ++v710;
          }
          if (v705.i64[1])
          {
            if ((void)v708) {
              (*(void (**)(void))(*(void *)v705.i64[1] + 40))();
            }
            *(void *)&long long v708 = 0;
            long long v706 = 0uLL;
            v705.i64[1] = 0;
            ++v707;
          }
          re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v703);
          if (v701.n128_u64[0] && (v701.n128_u8[8] & 1) != 0) {
            (*(void (**)(void))(*(void *)v701.n128_u64[0] + 40))();
          }
        }
LABEL_317:
        v35.i32[0] = *(_DWORD *)(v41 + 564);
        if (v35.f32[0] != 0.0 && *(unsigned char *)(*(void *)(v583 + 40) + 96))
        {
          uint64_t v235 = (uint64_t)v589;
          if (!v589)
          {
            unint64_t v236 = re::globalAllocators((re *)v33);
            uint64_t v235 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v236[2] + 32))(v236[2], 224, 8);
            *(_OWORD *)(v235 + 176) = 0u;
            *(_OWORD *)(v235 + 192) = 0u;
            *(_OWORD *)uint64_t v235 = 0u;
            *(_OWORD *)(v235 + 16) = 0u;
            *(_OWORD *)(v235 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
            *(_OWORD *)(v235 + 48) = 0u;
            *(_OWORD *)(v235 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
            *(_OWORD *)(v235 + 80) = 0u;
            *(_OWORD *)(v235 + 96) = 0u;
            *(_OWORD *)(v235 + 112) = 0u;
            *(_OWORD *)(v235 + 128) = 0u;
            *(_OWORD *)(v235 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
            *(_OWORD *)(v235 + 160) = 0u;
            *(_DWORD *)(v235 + 196) = 0x7FFFFFFF;
            *(void *)(v235 + 208) = 0;
            *(void *)(v235 + 216) = "";
          }
          unint64_t v237 = *(void *)(v41 + 608);
          unsigned int v238 = re::globalAllocators((re *)v33);
          uint64_t v239 = (float *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v238[2] + 32))(v238[2], 128, 8);
          re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData((uint64_t)v239, v41 + 480);
          *long long v240 = &unk_26E6D0CB8;
          v701.n128_u64[0] = (unint64_t)"Transform.transform";
          v701.n128_u64[1] = 19;
          re::DynamicString::operator=((re::DynamicString *)(v240 + 5), (uint64_t)&v701);
          uint64_t v242 = re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v239, v241);
          re::StringID::StringID((re::StringID *)buf, (const StringID *)(v41 + 24));
          int32x2_t v243 = v242[2];
          __n128 v244 = buf[0];
          buf[0].n128_u64[1] = (unint64_t)"";
          buf[0].n128_u64[0] = 0;
          uint64_t v245 = *((void *)v243 + 3);
          unint64_t v246 = *((void *)v243 + 4);
          *(__n128 *)((char *)v243 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v244;
          v701.n128_u64[1] = v246;
          v701.n128_u64[0] = v244.n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v245 & 1;
          re::StringID::destroyString((re::StringID *)&v701);
          re::StringID::destroyString((re::StringID *)buf);
          int v247 = *(_anonymous_namespace_ **)(a3 + 104);
          uint64_t v248 = *(const char **)(v41 + 32);
          uint64_t v249 = (re::TimelineAsset *)strlen(v248);
          id v250 = re::TimelineAsset::assetType(v249);
          uint64_t v251 = re::ImportAssetTable::addAsset(v247, (uint64_t)v248, (uint64_t)v249, v242, (re **)v250);
          __n128 v701 = 0uLL;
          v702.i64[0] = 0;
          re::DynamicArray<re::AssetHandle>::add((void *)(v235 + 120), (uint64_t *)&v701);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v701);
          std::string v589 = (_anonymous_namespace_ *)v235;
          if (*(unsigned char *)(v251 + 8)) {
            char v253 = *(re::AssetPath **)(v251 + 16);
          }
          else {
            char v253 = (re::AssetPath *)(v251 + 9);
          }
          v254 = (re::DynamicString *)(*(void *)(v235 + 152) + 24 * *(void *)(v235 + 136) - 24);
          v701.n128_u64[0] = 0;
          v701.n128_u64[1] = (unint64_t)"";
          v703.i64[0] = 0;
          float32x4_t v702 = 0uLL;
          re::DynamicArray<re::NamedAnimationLibraryEntry>::add((void *)(v235 + 40), (uint64_t *)&v701);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v702);
          re::StringID::destroyString((re::StringID *)&v701);
          uint64_t v255 = *(void *)(v235 + 72);
          uint64_t v256 = *((void *)v589 + 7) - 1;
          id v257 = re::StringID::operator=((unint64_t *)(v255 + 40 * v256), (uint64_t *)(v41 + 24));
          if (*(unsigned char *)(v251 + 8)) {
            unint64_t v258 = *(re::AssetPath **)(v251 + 16);
          }
          else {
            unint64_t v258 = (re::AssetPath *)(v251 + 9);
          }
          unint64_t v31 = v255 + 40 * v256 + 16;
          double v259 = (float)(v239[21] - v239[20]);
          v701.n128_u64[0] = v237;
          v701.n128_f64[1] = v259;
          re::AssetHandle::AssetHandle((re::AssetHandle *)&v702, (const re::AssetHandle *)(*((void *)v589 + 19) + 24 * *((void *)v589 + 17) - 24));
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v702);
          *(unsigned char *)(v583 + 48) = 1;
        }
        uint64_t v260 = *(void *)(v41 + 968);
        if (v260)
        {
          unint64_t v261 = *(void *)(v41 + 608);
          uint64_t v262 = *(uint64_t **)(v41 + 984);
          uint64_t v263 = 8 * v260;
          do
          {
            uint64_t v264 = *v262;
            uint64_t v265 = re::globalAllocators((re *)v33)[2];
            v703.i32[0] = 0;
            __n128 v701 = 0u;
            float32x4_t v702 = 0u;
            *(uint64_t *)((char *)v703.i64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0x7FFFFFFFLL;
            char v266 = (re *)re::internal::convertToAssetData(v264, (uint64_t)&v701, v265);
            char v267 = re::globalAllocators(v266);
            unint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v267[2] + 32))(v267[2], 24, 8);
            *(void *)unint64_t v31 = v264;
            *(void *)(v31 + 8) = v266;
            *(void *)(v31 + 16) = v264;
            int v268 = *(_anonymous_namespace_ **)(a3 + 104);
            id v269 = *(const char **)(v41 + 32);
            int v270 = (re::TimelineAsset *)strlen(v269);
            uint64_t v271 = re::TimelineAsset::assetType(v270);
            uint64_t v272 = re::ImportAssetTable::addAsset(v268, (uint64_t)v269, (uint64_t)v270, (void *)v31, (re **)v271);
            unint64_t v714 = 0;
            unint64_t v713 = 0;
            v712 = 0;
            if (*(unsigned char *)(v272 + 8)) {
              int v273 = *(re::AssetPath **)(v272 + 16);
            }
            else {
              int v273 = (re::AssetPath *)(v272 + 9);
            }
            buf[0].n128_u64[0] = v261;
            buf[0].n128_u64[1] = (*(double (**)(uint64_t))(*(void *)v264 + 40))(v264);
            re::AssetHandle::AssetHandle((re::AssetHandle *)&buf[1], (const re::AssetHandle *)&v712);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1]);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&v712);
            *(double *)v35.i64 = re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v701);
            ++v262;
            v263 -= 8;
          }
          while (v263);
        }
        if (v592)
        {
          unint64_t v10 = (unint64_t)buf;
          size_t v9 = (size_t)&v701;
          a2 = v583 + 56;
        }
        else
        {
          uint64_t v274 = *(void *)(v41 + 920);
          unint64_t v10 = (unint64_t)buf;
          size_t v9 = (size_t)&v701;
          a2 = v583 + 56;
          if (v274)
          {
            for (uint64_t i = 0; i != v274; ++i)
            {
              unint64_t v31 = ~i;
              long long v276 = (unint64_t *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v41 + 880, v274 + ~i);
              uint64_t v277 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v581, *v276);
              uint64_t v278 = 0;
              float v279 = *(float *)(v277 + 448);
              float v280 = *(float *)(v277 + 452);
              float v281 = *(float *)(v277 + 456);
              float v282 = *(float *)(v277 + 460);
              float32x4_t v283 = *(float32x4_t *)(v277 + 432);
              __n128 v284 = *(__n128 *)(v277 + 464);
              float v285 = v279 + v279;
              float v286 = v280 + v280;
              float v287 = v279 * (float)(v279 + v279);
              float v288 = v280 * (float)(v280 + v280);
              float v289 = v281 * (float)(v281 + v281);
              float v290 = v285 * v280;
              float v291 = (float)(v281 + v281) * v282;
              v292.i32[3] = 0;
              v292.f32[0] = 1.0 - (float)(v288 + v289);
              v292.f32[1] = v290 + v291;
              float v293 = v285 * v281;
              float v294 = v286 * v281;
              float v295 = v285 * v282;
              float v296 = v286 * v282;
              v292.f32[2] = v293 - v296;
              v297.i32[3] = 0;
              v297.f32[0] = v290 - v291;
              v297.f32[1] = 1.0 - (float)(v287 + v289);
              v297.f32[2] = v294 + v295;
              v298.i32[3] = 0;
              v298.f32[0] = v293 + v296;
              v298.f32[1] = v294 - v295;
              v298.f32[2] = 1.0 - (float)(v287 + v288);
              v284.n128_u32[3] = 1.0;
              buf[0] = (__n128)vmulq_n_f32(v292, v283.f32[0]);
              buf[1] = (__n128)vmulq_n_f32(v297, *(float *)vshrq_n_u64((uint64x2_t)v283, 0x20uLL).i32);
              float64x2_t buf[2] = (__n128)vmulq_laneq_f32(v298, v283, 2);
              buf[3] = v284;
              do
              {
                *(float32x4_t *)((char *)&v701 + v278 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v614, COERCE_FLOAT(*(_OWORD *)&buf[v278])), v612, (float32x2_t)buf[v278].n128_u64[0], 1), v609, (float32x4_t)buf[v278], 2), v608, (float32x4_t)buf[v278], 3);
                ++v278;
              }
              while (v278 != 4);
              *(__n128 *)id v591 = v701;
              float32x4_t v593 = v702;
              float32x4_t v599 = v703;
              float32x4_t v603 = v704;
              v701.n128_u8[0] = 0;
              v701.n128_u64[1] = *(void *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v41 + 880, *(void *)(v41 + 920) + v31);
              float32x4_t v702 = *(float32x4_t *)v591;
              float32x4_t v703 = v593;
              float32x4_t v704 = v599;
              float32x4_t v705 = v603;
              v35.i64[0] = re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::add((uint64_t)&v688, (uint64_t)&v701).n128_u64[0];
              uint64_t v274 = *(void *)(v41 + 920);
            }
          }
          uint64_t v299 = *(void *)(v41 + 144);
          if (v299)
          {
            for (uint64_t j = 0; j != v299; ++j)
            {
              uint64_t v301 = (unint64_t *)re::BucketArray<unsigned long,4ul>::operator[](v41 + 104, v299 + ~j);
              uint64_t v33 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)v588, *v301);
              uint64_t v302 = *(void *)(v33 + 392);
              float32x4_t v303 = v612;
              float32x4_t v35 = v614;
              float32x4_t v305 = v608;
              float32x4_t v304 = v609;
              if (v302)
              {
                unint64_t v31 = 8 * v302;
                uint64_t v306 = *(void *)(v33 + 408) - 8;
                do
                {
                  v701.n128_u8[0] = 1;
                  v701.n128_u64[1] = *(void *)(v306 + v31);
                  float32x4_t v702 = v35;
                  float32x4_t v703 = v303;
                  float32x4_t v704 = v304;
                  float32x4_t v705 = v305;
                  re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::add((uint64_t)&v688, (uint64_t)&v701);
                  float32x4_t v305 = v608;
                  float32x4_t v304 = v609;
                  float32x4_t v303 = v612;
                  float32x4_t v35 = v614;
                  v31 -= 8;
                }
                while (v31);
              }
              uint64_t v299 = *(void *)(v41 + 144);
            }
          }
        }
        goto LABEL_349;
      }
    }
    float64x2_t v595 = *(float64x2_t *)(v33 + 688);
    __n128 v701 = 0uLL;
    v702.i64[0] = (uint64_t)"";
    v702.i8[8] = 1;
    v704.i64[0] = 0;
    float32x4_t v703 = 0uLL;
    v704.i32[2] = 0;
    *(void *)&long long v708 = 0;
    float32x4_t v705 = 0u;
    long long v706 = 0u;
    int v707 = 0;
    re::StringID::destroyString((re::StringID *)&v701.n128_i8[8]);
    v702.i64[0] = (uint64_t)"Text";
    v701.n128_u64[1] = 5206682;
    if (!v703.i64[0])
    {
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v703, 0);
      ++v704.i32[2];
    }
    uint64_t v49 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                + 7)
                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 288, 0);
    re::make::shared::inplace<re::ecs2::Static3DTextComponent>(v49, &v712);
    uint64_t v50 = v712;
    unint64_t v51 = *((void *)re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
          + 3) >> 1;
    v712 = 0;
    buf[0].n128_u64[0] = v51;
    buf[0].n128_u64[1] = (unint64_t)v50;
    buf[1].n128_u8[0] = 1;
    re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v703, buf);
    if (v712) {

    }
    int32x4_t v601 = vdupq_n_s32(0x7F800000u);
    if (!re::DynamicString::operator==((uint64_t)(v50 + 12), v41 + 648))
    {
      re::DynamicString::operator=((re::DynamicString *)(v50 + 12), (re::DynamicString *)(v41 + 648));
      *(void *)&long long v52 = 0x7F0000007FLL;
      *((void *)&v52 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v52;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    if (!re::DynamicString::operator==((uint64_t)(v50 + 16), v41 + 616))
    {
      re::DynamicString::operator=((re::DynamicString *)(v50 + 16), (re::DynamicString *)(v41 + 616));
      *(void *)&long long v53 = 0x7F0000007FLL;
      *((void *)&v53 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v53;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    float v54 = *(double *)(v41 + 680);
    if (*((float *)v50 + 8) != v54)
    {
      *((float *)v50 + 8) = v54;
      *(void *)&long long v55 = 0x7F0000007FLL;
      *((void *)&v55 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v55;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    float v56 = *(double *)(v41 + 704);
    if (*((float *)v50 + 7) != v56)
    {
      *((float *)v50 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v56;
      *(void *)&long long v57 = 0x7F0000007FLL;
      *((void *)&v57 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v57;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    float32x2_t v58 = vcvt_f32_f64(v595);
    uint32x2_t v59 = (uint32x2_t)vceq_f32((float32x2_t)v50[11], v58);
    if ((vpmin_u32(v59, v59).u32[0] & 0x80000000) == 0)
    {
      v50[11] = (uint64_t)v58;
      *(void *)&long long v60 = 0x7F0000007FLL;
      *((void *)&v60 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v60;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    if (*(void *)(v41 + 752)) {
      uint64_t v61 = *(const char **)(v41 + 760);
    }
    else {
      uint64_t v61 = (const char *)(v41 + 753);
    }
    float64x2_t v596 = 0u;
    if (!strcmp(v61, "left")) {
      goto LABEL_46;
    }
    if (!strcmp(v61, "right"))
    {
      float v66 = *(double *)(v41 + 688);
      float64x2_t v596 = (float64x2_t)COERCE_UNSIGNED_INT(-v66);
      int v65 = 1;
    }
    else if (!strcmp(v61, "center"))
    {
      *(float *)&unsigned int v67 = *(double *)(v41 + 688) * -0.5;
      float64x2_t v596 = (float64x2_t)v67;
      int v65 = 2;
    }
    else
    {
      uint64_t v62 = (re *)strcmp(v61, "justified");
      if (v62)
      {
        uint64_t v63 = *re::pipelineLogObjects(v62);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          if (*(void *)(v41 + 752)) {
            unint64_t v64 = *(void *)(v41 + 760);
          }
          else {
            unint64_t v64 = v41 + 753;
          }
          buf[0].n128_u32[0] = 136315138;
          *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v64;
          _os_log_impl(&dword_233120000, v63, OS_LOG_TYPE_DEFAULT, "Invalid text horizontal alignment value %s", (uint8_t *)buf, 0xCu);
        }
LABEL_46:
        int v65 = 0;
        goto LABEL_53;
      }
      int v65 = 3;
    }
LABEL_53:
    if (*((unsigned __int8 *)v50 + 37) != v65)
    {
      *((unsigned char *)v50 + 3re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v65;
      *(void *)&long long v68 = 0x7F0000007FLL;
      *((void *)&v68 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v68;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    char v585 = v65;
    if (*(void *)(v41 + 720)) {
      uint64_t v69 = *(const char **)(v41 + 728);
    }
    else {
      uint64_t v69 = (const char *)(v41 + 721);
    }
    if (strcmp(v69, "singleLine"))
    {
      float64x2_t v597 = *(float64x2_t *)(v41 + 688);
      if (!strcmp(v69, "hardBreaks"))
      {
        int v72 = 2;
      }
      else
      {
        uint64_t v70 = (re *)strcmp(v69, "flowing");
        if (v70)
        {
          uint64_t v71 = *re::pipelineLogObjects(v70);
          int v72 = 0;
          if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_83;
          }
          if (*(void *)(v41 + 720)) {
            unint64_t v73 = *(void *)(v41 + 728);
          }
          else {
            unint64_t v73 = v41 + 721;
          }
          buf[0].n128_u32[0] = 136315138;
          *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v73;
          _os_log_impl(&dword_233120000, v71, OS_LOG_TYPE_DEFAULT, "Invalid text word wrap value %s", (uint8_t *)buf, 0xCu);
        }
        int v72 = 0;
      }
LABEL_83:
      if (*((unsigned __int8 *)v50 + 38) != v72)
      {
        *((unsigned char *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = v72;
        *(void *)&long long v82 = 0x7F0000007FLL;
        *((void *)&v82 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
        *((int32x4_t *)v50 + 3) = v601;
        *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v82;
        *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
      }
      if (*(void *)(v41 + 784)) {
        uint64_t v83 = *(const char **)(v41 + 792);
      }
      else {
        uint64_t v83 = (const char *)(v41 + 785);
      }
      if (!strcmp(v83, "top"))
      {
        int v87 = 0;
      }
      else if (!strcmp(v83, "middle"))
      {
        int v87 = 2;
      }
      else
      {
        int v84 = (re *)strcmp(v83, "bottom");
        if (v84)
        {
          int v85 = *re::pipelineLogObjects(v84);
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
          {
            if (*(void *)(v41 + 784)) {
              unint64_t v86 = *(void *)(v41 + 792);
            }
            else {
              unint64_t v86 = v41 + 785;
            }
            buf[0].n128_u32[0] = 136315138;
            *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v86;
            _os_log_impl(&dword_233120000, v85, OS_LOG_TYPE_DEFAULT, "Invalid text vertical alignment value %s", (uint8_t *)buf, 0xCu);
          }
        }
        int v87 = 1;
      }
      size_t v9 = (size_t)&v703;
      __asm { FMOV            V0.2D, #-0.5 }
      float64x2_t v92 = vmulq_f64(v597, _Q0);
      *(float32x2_t *)&v92.f64[0] = vcvt_f32_f64(v92);
      LODWORD(v92.f64[1]) = 0;
      float64x2_t v596 = v92;
      if (*((unsigned __int8 *)v50 + 39) == v87) {
        goto LABEL_115;
      }
      goto LABEL_114;
    }
    if (*((unsigned char *)v50 + 38) != 2)
    {
      *((unsigned char *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = 2;
      *(void *)&long long v74 = 0x7F0000007FLL;
      *((void *)&v74 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
      *((int32x4_t *)v50 + 3) = v601;
      *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v74;
      *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    }
    if (*(void *)(v41 + 784)) {
      id v75 = *(const char **)(v41 + 792);
    }
    else {
      id v75 = (const char *)(v41 + 785);
    }
    if (!strcmp(v75, "top"))
    {
      int v87 = 0;
      float v93 = *(double *)(v41 + 696);
      float64x2_t v94 = v596;
      *((float *)v94.f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = -v93;
      float64x2_t v596 = v94;
    }
    else
    {
      if (strcmp(v75, "middle"))
      {
        if (!strcmp(v75, "bottom"))
        {
          float64x2_t v97 = v596;
          HIDWORD(v97.f64[0]) = 0;
          float64x2_t v596 = v97;
LABEL_110:
          int v87 = 1;
          goto LABEL_111;
        }
        uint64_t v76 = (re *)strcmp(v75, "lowerMiddle");
        if (v76)
        {
          id v77 = (re *)strcmp(v75, "baseline");
          int v78 = (int)v77;
          id v79 = *re::pipelineLogObjects(v77);
          BOOL v80 = os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT);
          if (v78)
          {
            if (v80)
            {
              if (*(void *)(v41 + 784)) {
                unint64_t v81 = *(void *)(v41 + 792);
              }
              else {
                unint64_t v81 = v41 + 785;
              }
              buf[0].n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v81;
              _os_log_impl(&dword_233120000, v79, OS_LOG_TYPE_DEFAULT, "Invalid text vertical alignment value %s", (uint8_t *)buf, 0xCu);
            }
            goto LABEL_110;
          }
          if (!v80) {
            goto LABEL_109;
          }
          buf[0].n128_u16[0] = 0;
          uint64_t v99 = v79;
          uint64_t v100 = "Single line vertical alignment value baseline not supported, falling back to bottom";
        }
        else
        {
          unint64_t v98 = *re::pipelineLogObjects(v76);
          if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
          {
LABEL_109:
            float v101 = *(double *)(v41 + 696) * -0.5;
            float64x2_t v102 = v596;
            *((float *)v102.f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v101;
            float64x2_t v596 = v102;
            goto LABEL_110;
          }
          buf[0].n128_u16[0] = 0;
          uint64_t v99 = v98;
          uint64_t v100 = "Single line vertical alignment value lowerMiddle not supported, falling back to bottom";
        }
        _os_log_impl(&dword_233120000, v99, OS_LOG_TYPE_DEFAULT, v100, (uint8_t *)buf, 2u);
        goto LABEL_109;
      }
      float v95 = *(double *)(v41 + 696) * -0.5;
      float64x2_t v96 = v596;
      *((float *)v96.f64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v95;
      float64x2_t v596 = v96;
      int v87 = 2;
    }
LABEL_111:
    size_t v9 = (size_t)&v703;
    if (*((unsigned __int8 *)v50 + 39) == v87)
    {
      LOBYTE(v72) = 0;
LABEL_115:
      *((float64x2_t *)re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v701) + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v596;
      unint64_t v40 = (unint64_t)re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>(&v701);
      uint64_t v104 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetHandle>::operator=(v40 + 56, (uint64_t *)(v41 + 808));
      memset(buf, 0, 32);
      int v105 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(buf, 0);
      memset(&buf[2], 0, 32);
      re::DynamicString::setCapacity((__n128 *)buf[2].n128_u64, 0);
      __asm { FMOV            V0.2S, #1.0 }
      buf[4].n128_u64[0] = _D0;
      buf[4].n128_u8[8] = 5;
      uint64_t v755 = 0;
      float32x2_t v756 = 0;
      v757[0] = 0x1010101000400;
      re::DynamicString::operator=((re::DynamicString *)&buf[2], (re::DynamicString *)(v41 + 648));
      re::DynamicString::operator=((re::DynamicString *)buf, (re::DynamicString *)(v41 + 616));
      *(float *)&unsigned int v107 = *(double *)(v41 + 680);
      *(float *)&unsigned int v108 = *(double *)(v41 + 704);
      buf[4].n128_u64[0] = __PAIR64__(v108, v107);
      buf[4].n128_u8[8] = 5;
      uint64_t v755 = 0;
      float32x2_t v756 = v58;
      LOBYTE(v757[0]) = v72;
      BYTE1(v757[0]) = v585;
      BYTE2(v757[0]) = v87;
      *(_WORD *)((char *)v757 + 3) = 257;
      HIBYTE(v757[0]) = 1;
      Asset = (_DWORD *)re::MeshPrimitiveProvider::makeAsset((re::MeshPrimitiveProvider *)buf, 0, 1);
      Asset[231] = 1;
      unint64_t v31 = *(void *)(v41 + 32);
      uint64_t v110 = *(_anonymous_namespace_ **)(a3 + 104);
      uint64_t v111 = (re::MeshAsset *)strlen((const char *)v31);
      int v112 = re::MeshAsset::assetType(v111);
      uint64_t v113 = re::ImportAssetTable::addAsset(v110, v31, (uint64_t)v111, Asset, (re **)v112);
      unint64_t v714 = 0;
      unint64_t v713 = 0;
      v712 = 0;
      if (*(unsigned char *)(v113 + 8)) {
        id v114 = *(re::AssetPath **)(v113 + 16);
      }
      else {
        id v114 = (re::AssetPath *)(v113 + 9);
      }
      a2 = v583 + 56;
      size_t k = (size_t)&v703;
      re::AssetHandle::setSerializationString((re::DynamicString *)&v712, v114, *(re::Allocator **)a3);
      re::AssetHandle::operator=(v40 + 32, (uint64_t *)&v712);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v712);
      unint64_t v10 = (unint64_t)buf;
      if (buf[2].n128_u64[0])
      {
        if (buf[2].n128_u8[8]) {
          (*(void (**)(void))(*(void *)buf[2].n128_u64[0] + 40))();
        }
        memset(&buf[2], 0, 32);
      }
      if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
        (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
      }
      re::DynamicArray<re::ecs2::EntityAssetData>::add((uint64_t)&v667[1], (uint64_t)&v701);
      re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)&v701);
      goto LABEL_126;
    }
    LOBYTE(v72) = 0;
LABEL_114:
    *((unsigned char *)v50 + 39) = v87;
    *(void *)&long long v103 = 0x7F0000007FLL;
    *((void *)&v103 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
    *((int32x4_t *)v50 + 3) = v601;
    *((_OWORD *)v50 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v103;
    *((unsigned char *)v50 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
    goto LABEL_115;
  }
  std::string v589 = 0;
LABEL_352:
  if (*((void *)&v725 + 1))
  {
    v718[0] = 0;
    *(_WORD *)&v718[2] = 257;
    v718[4] = 1;
    *(_DWORD *)&v718[5] = 0;
    v718[9] = 0;
    *(_DWORD *)v719 = 1036831949;
    *(_DWORD *)&v719[4] = 16843008;
    unint64_t v133 = (unint64_t)v718;
    long long v721 = 0u;
    *(_OWORD *)&v719[12] = 0u;
    long long v720 = 0u;
    DWORD1(v72re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7FFFFFFF;
    v718[10] = *(unsigned char *)(a3 + 161);
    v718[1] = *(unsigned char *)(a3 + 162);
    v718[6] = *(unsigned char *)(a3 + 165);
    v719[8] = v718[6];
    re::USDImportContext::generatePerMeshCompileOptions(v583, (uint64_t)v718, (uint64_t)&v712);
    MeshAssetDataFromDescriptor = (re *)re::makeMeshAssetDataFromDescriptor(v722, (uint64_t)&v712, (uint64_t)&v701);
    if (v701.n128_u8[0])
    {
      uint64_t v620 = 0;
      v618 = 0;
      *(void *)&v617.var0 = 0;
      v617.uint64_t var1 = 0;
      int v619 = 0;
      re::DynamicArray<re::AssetHandle>::resize((uint64_t)&v617, v708);
      unint64_t v129 = v702.u64[1];
      if (v702.i64[1])
      {
        unint64_t v309 = 0;
        unint64_t v40 = (unsigned __int16)v684;
        do
        {
          unint64_t v31 = v702.u64[1];
          if (v702.i64[1] <= v309) {
            goto LABEL_658;
          }
          unint64_t v310 = v703.i64[1] + (v309 << 9);
          uint64_t v311 = *(void *)(v310 + 208);
          if (v311)
          {
            size_t v14 = v311 << 8;
            size_t k = *(void *)(v310 + 224) + 56;
            do
            {
              unint64_t v31 = *(unsigned __int16 *)k;
              uint64_t v308 = (_anonymous_namespace_ *)re::BucketArray<re::FixedArray<unsigned short>,16ul>::operator[]((uint64_t)&v676, v309);
              __int16 v312 = v40;
              if (*((void *)v308 + 1) > v31)
              {
                uint64_t v308 = (_anonymous_namespace_ *)re::BucketArray<re::FixedArray<unsigned short>,16ul>::operator[]((uint64_t)&v676, v309);
                a2 = *((void *)v308 + 1);
                if (a2 <= v31) {
                  goto LABEL_453;
                }
                __int16 v312 = *(_WORD *)(*((void *)v308 + 2) + 2 * v31);
              }
              *(_WORD *)size_t k = v312;
              k += 256;
              v14 -= 256;
            }
            while (v14);
          }
        }
        while (++v309 != v129);
      }
      a2 = *(unsigned int *)&v730[40];
      if (*(_DWORD *)&v730[40])
      {
        unint64_t v10 = 0;
        uint64_t v313 = *(int **)&v730[24];
        uint64_t v314 = a3;
        while (1)
        {
          int v315 = *v313;
          v313 += 8;
          if (v315 < 0) {
            break;
          }
          if (*(unsigned int *)&v730[40] == ++v10)
          {
            unint64_t v10 = *(unsigned int *)&v730[40];
            break;
          }
        }
      }
      else
      {
        unint64_t v10 = 0;
        uint64_t v314 = a3;
      }
      if (*(_DWORD *)&v730[40] != v10)
      {
        unint64_t v342 = v10;
        uint64_t v343 = *(void *)&v730[24];
        v614.i64[0] = 136315138;
        size_t v9 = 24;
        do
        {
          uint64_t v344 = *(void *)(v314 + 104);
          uint64_t v345 = v343 + 32 * v342;
          float32x4_t v346 = *(const char **)(v345 + 16);
          size_t k = strlen(v346);
          long long v347 = re::SkeletonAsset::assetType((re::SkeletonAsset *)k);
          uint64_t v348 = re::ImportAssetTable::importedAsset(v344, (uint64_t)v346, k, (re **)v347);
          if (v348)
          {
            size_t v14 = *(unsigned int *)(v345 + 24);
            unint64_t v31 = (unint64_t)v618;
            if ((unint64_t)v618 <= v14) {
              goto LABEL_663;
            }
            if (*(unsigned char *)(v348 + 8)) {
              long long v349 = *(re::AssetPath **)(v348 + 16);
            }
            else {
              long long v349 = (re::AssetPath *)(v348 + 9);
            }
            uint64_t v314 = a3;
            long long v351 = (re::DynamicString *)(v620 + 24 * v14);
          }
          else
          {
            long long v350 = (id)*re::pipelineLogObjects(0);
            if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR))
            {
              unint64_t v354 = *(void *)(v345 + 16);
              buf[0].n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v354;
              _os_log_error_impl(&dword_233120000, v350, OS_LOG_TYPE_ERROR, "Could not locate skeleton asset: %s", (uint8_t *)buf, 0xCu);
            }

            uint64_t v314 = a3;
          }
          uint64_t v343 = *(void *)&v730[24];
          if (*(_DWORD *)&v730[40] <= (v10 + 1)) {
            unint64_t v352 = (v10 + 1);
          }
          else {
            unint64_t v352 = *(unsigned int *)&v730[40];
          }
          while (1)
          {
            unint64_t v342 = (v10 + 1);
            if (v352 - 1 == v10) {
              break;
            }
            LODWORD(vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = v10 + 1;
            unint64_t v353 = v342;
            if ((*(_DWORD *)(*(void *)&v730[24] + 32 * v342) & 0x80000000) != 0) {
              goto LABEL_448;
            }
          }
          unint64_t v353 = v352;
LABEL_448:
          unint64_t v10 = v353;
        }
        while (a2 != v353);
      }
      if (v589)
      {
        if (v646)
        {
          uint64_t v571 = v702.i64[1];
          if (v702.i64[1])
          {
            a2 = 0;
            v614.i64[0] = (uint64_t)&v758[8];
            unint64_t v31 = (unint64_t)&buf[2].n128_u64[1];
            size_t v14 = (size_t)&buf[4].n128_u64[1];
            size_t k = (size_t)v757;
            while (1)
            {
              long long v317 = (__n128 *)v702.i64[1];
              if (v702.i64[1] <= a2) {
                goto LABEL_669;
              }
              unint64_t v318 = v703.i64[1] + (a2 << 9);
              uint64_t v319 = *(re::AssetHandle **)(v318 + 288);
              uint64_t v577 = v319;
              uint64_t v320 = v319 ? v319 : 1;
              uint64_t v578 = v320;
              if (v320 && *((void *)v308 + 2) == v320) {
                break;
              }
LABEL_385:
              if (++a2 == v571) {
                goto LABEL_416;
              }
            }
            size_t v9 = 0;
            v573 = (unint64_t *)(v318 + 288);
            uint64_t v575 = (re::StringID *)a2;
            v576 = (re::AssetHandle *)(v318 + 304);
            v604 = (unsigned int *)(v318 + 208);
            long long v594 = (void *)(v318 + 224);
            int v600 = (void *)(v318 + 8);
            while (1)
            {
              size_t v322 = *((void *)v308 + 2);
              if (v322 <= v9)
              {
                *(void *)v759 = 0;
                long long v164 = buf;
                memset(buf, 0, sizeof(buf));
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v758 = 136315906;
                *(void *)&v758[4] = "operator[]";
                *(_WORD *)&v758[12] = 1024;
                *(_DWORD *)&v758[14] = 797;
                *(_WORD *)&v758[18] = 2048;
                *(void *)&v758[20] = v9;
                *(_WORD *)&v758[28] = 2048;
                *(void *)&v758[30] = v322;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_652;
              }
              uint64_t v323 = *((void *)v308 + 4);
              size_t v610 = v323 + 72 * v9;
              unint64_t v324 = *(void *)(v610 + 8);
              if (v324 == -1) {
                goto LABEL_413;
              }
              size_t v325 = v323 + 72 * v9;
              uint64_t v327 = *(void *)(v325 + 16);
              unsigned int v326 = (unint64_t *)(v325 + 16);
              if (v327 == -1) {
                goto LABEL_413;
              }
              long long v328 = (const StringID *)re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](v583 + 56, v324);
              re::StringID::StringID((re::StringID *)&v699, v328 + 1);
              int v329 = (const StringID *)re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](v583 + 160, *v326);
              re::StringID::StringID((re::StringID *)&v698, v329 + 1);
              unint64_t v580 = v9;
              if (v577)
              {
                if (v9) {
                  break;
                }
              }
              if (v577)
              {
                size_t v9 = 0;
                unint64_t v40 = *v573;
LABEL_397:
                a2 = v580;
                if (v40 <= v580) {
                  goto LABEL_659;
                }
                unint64_t v10 = *(unsigned int *)(*(void *)v576 + 12 * v580 + 8);
                goto LABEL_399;
              }
              size_t v9 = 0;
              unint64_t v10 = *v604;
LABEL_399:
              if (v9 < v10)
              {
                v605 = (re::AssetHandle *)(v323 + 72 * v580 + 48);
                uint64_t v330 = (v9 << 8) | 0x50;
                v608.i64[0] = v10;
                while (1)
                {
                  v758[0] = 1;
                  v331 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-0", (re::DynamicString *)&v695, *v600);
                  int v332 = (v696 & 1) != 0 ? v697 : (char *)&v696 + 1;
                  *(void *)&v758[8] = 0;
                  *(void *)&v758[16] = "";
                  uint64_t v333 = *(void *)v604;
                  if (*(void *)v604 <= v9) {
                    break;
                  }
                  if (*(void *)(*v594 + v330))
                  {
                    re::StringID::StringID((re::StringID *)&v758[24], (const StringID *)(*v594 + v330 - 8));
                  }
                  else
                  {
                    *(void *)&v758[24] = 0;
                    *(void *)&v758[32] = "";
                  }
                  if (v695 && (v696 & 1) != 0) {
                    (*(void (**)(void))(*(void *)v695 + 40))();
                  }
                  buf[0].n128_u8[0] = v758[0];
                  a2 = (unint64_t)&buf[0].n128_u64[1];
                  re::StringID::StringID((re::StringID *)&buf[0].n128_i8[8], (const StringID *)&v758[8]);
                  re::StringID::StringID((re::StringID *)&buf[1].n128_i8[8], (const StringID *)&v758[24]);
                  re::StringID::StringID((re::StringID *)&buf[2].n128_i8[8], &v699);
                  re::StringID::StringID((re::StringID *)&buf[3].n128_i8[8], &v698);
                  re::AssetHandle::AssetHandle((re::AssetHandle *)&buf[4].n128_i8[8], v605);
                  memset(v757, 0, 24);
                  re::DynamicArray<re::SkeletalAnimationLibraryEntry>::add(v589, (uint64_t)buf);
                  re::AssetHandle::~AssetHandle((re::AssetHandle *)v757);
                  re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[4].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[3].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[2].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[1].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[0].n128_i8[8]);
                  re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)((char *)v589 + 120), v605);
                  buf[0].n128_u8[0] = v758[0];
                  re::StringID::StringID((re::StringID *)&buf[0].n128_i8[8], (const StringID *)&v758[8]);
                  re::StringID::StringID((re::StringID *)&buf[1].n128_i8[8], (const StringID *)&v758[24]);
                  re::StringID::StringID((re::StringID *)&buf[2].n128_i8[8], &v699);
                  buf[3].n128_u8[8] = 0;
                  buf[3].n128_u32[3] = *(_DWORD *)v610;
                  re::DynamicArray<re::SkeletalPoseMeshMap>::add((void *)&v750 + 1, (uint64_t)buf);
                  re::StringID::destroyString((re::StringID *)&buf[2].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[1].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&buf[0].n128_i8[8]);
                  re::StringID::destroyString((re::StringID *)&v758[24]);
                  re::StringID::destroyString((re::StringID *)&v758[8]);
                  ++v9;
                  v330 += 256;
                  unint64_t v10 = v608.i64[0];
                  if (v608.i64[0] == v9) {
                    goto LABEL_412;
                  }
                }
LABEL_451:
                uint64_t v700 = 0;
                unint64_t v40 = (unint64_t)buf;
                memset(buf, 0, sizeof(buf));
                unint64_t v129 = &_os_log_internal;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v759 = 136315906;
                *(void *)&v759[4] = "operator[]";
                *(_WORD *)&v759[12] = 1024;
                *(_DWORD *)&v759[14] = 797;
                *(_WORD *)&v759[18] = 2048;
                *(void *)&v759[20] = v9;
                __int16 v760 = 2048;
                uint64_t v761 = v333;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_452:
                *(void *)v758 = 0;
                memset(buf, 0, sizeof(buf));
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v718 = 136315906;
                *(void *)&v718[4] = "operator[]";
                *(_WORD *)v719 = 1024;
                *(_DWORD *)&v719[2] = 789;
                *(_WORD *)&v719[6] = 2048;
                *(void *)&v719[8] = v10;
                *(_WORD *)&v719[16] = 2048;
                *(void *)&v719[18] = v129;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_453:
                *(void *)v759 = 0;
                *(_OWORD *)(v10 + 48) = 0u;
                *(_OWORD *)(v10 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
                *(_OWORD *)(v10 + 16) = 0u;
                *(_OWORD *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
                *(_OWORD *)unint64_t v10 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v758 = 136315906;
                *(void *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "operator[]";
                *(_WORD *)&v758[12] = 1024;
                *(_DWORD *)(v10 + 142) = 468;
                *(_WORD *)&v758[18] = 2048;
                *(void *)(v10 + 148) = v31;
                *(_WORD *)&v758[28] = 2048;
                *(void *)(v10 + 158) = a2;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_454:
                *(void *)v758 = 0;
                memset(buf, 0, sizeof(buf));
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v718 = 136315906;
                *(void *)&v718[4] = "operator[]";
                *(_WORD *)v719 = 1024;
                *(_DWORD *)&v719[2] = 789;
                *(_WORD *)&v719[6] = 2048;
                *(void *)&v719[8] = v10;
                *(_WORD *)&v719[16] = 2048;
                *(void *)&v719[18] = v31;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_455:
                *(void *)&v617.var0 = 0;
                memset(buf, 0, sizeof(buf));
                float32x4_t v334 = (uint64_t *)&_os_log_internal;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)v718 = 136315906;
                *(void *)&v718[4] = "operator[]";
                *(_WORD *)v719 = 1024;
                *(_DWORD *)&v719[2] = 468;
                *(_WORD *)&v719[6] = 2048;
                *(void *)&v719[8] = v10;
                *(_WORD *)&v719[16] = 2048;
                *(void *)&v719[18] = v31;
                LODWORD(v55re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 38;
                _os_log_send_and_compose_impl();
                uint64_t v308 = (_anonymous_namespace_ *)_os_crash_msg();
                __break(1u);
LABEL_456:
                *(void *)(v31 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v14;
                re::DynamicArray<re::MeshAssetData>::setCapacity((void *)v40, v129);
                ++*(_DWORD *)(v31 + 128);
                goto LABEL_457;
              }
LABEL_412:
              re::StringID::destroyString((re::StringID *)&v698);
              re::StringID::destroyString((re::StringID *)&v699);
              a2 = (unint64_t)v575;
              size_t v9 = v580;
LABEL_413:
              if (++v9 == v578) {
                goto LABEL_385;
              }
            }
            a2 = v9 - 1;
            unint64_t v40 = *v573;
            if (*v573 <= v9 - 1) {
              goto LABEL_662;
            }
            size_t v9 = *(unsigned int *)(*(void *)v576 + 12 * a2 + 8);
            goto LABEL_397;
          }
        }
      }
LABEL_416:
      float32x4_t v334 = &v701.n128_i64[1];
      if (a8 && v639) {
      unint64_t v10 = (unint64_t)buf;
      }
      uint64_t v335 = a3;
      if (v632)
      {
        float v336 = *(double *)v583;
      }
      size_t v9 = (size_t)&v701;
      if (*(unsigned char *)(a3 + 360))
      {
        unint64_t v31 = *(void *)(a3 + 104);
        unint64_t v337 = *(void *)(v31 + 112);
        unint64_t v338 = *(void *)(v31 + 120);
        if (v338 >= v337)
        {
          unint64_t v129 = v338 + 1;
          if (v337 < v338 + 1)
          {
            unint64_t v40 = v31 + 104;
            if (!*(void *)(v31 + 104)) {
              goto LABEL_456;
            }
            uint64_t v339 = 2 * v337;
            _ZF = v337 == 0;
            unint64_t v340 = 8;
            if (!_ZF) {
              unint64_t v340 = v339;
            }
            if (v340 <= v129) {
              unint64_t v341 = v129;
            }
            else {
              unint64_t v341 = v340;
            }
            re::DynamicArray<re::MeshAssetData>::setCapacity((void *)(v31 + 104), v341);
          }
LABEL_457:
          unint64_t v338 = *(void *)(v31 + 120);
        }
        uint64_t v355 = *(void *)(v31 + 136) + 160 * v338;
        re::DynamicArray<re::MeshAssetModel>::DynamicArray(v355, v334);
        re::DynamicArray<re::MeshAssetInstance>::DynamicArray(v355 + 40, (uint64_t *)&v704);
        re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray(v355 + 80, (uint64_t *)&v706 + 1);
        uint64_t v308 = (_anonymous_namespace_ *)re::DynamicArray<float>::DynamicArray(v355 + 120, (uint64_t *)&v709 + 1);
        ++*(void *)(v31 + 120);
        ++*(_DWORD *)(v31 + 128);
        uint64_t v335 = a3;
      }
      long long v356 = re::globalAllocators(v308);
      long long v357 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v356[2] + 32))(v356[2], 960, 8);
      uint64_t v358 = re::MeshAsset::MeshAsset((uint64_t)v357, (uint64_t)v334);
      *(_DWORD *)(v358 + 9re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 1;
      re::DynamicArray<re::AssetHandle>::operator=(v358 + 208, (uint64_t)&v617);
      long long v359 = re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>(&v660);
      unint64_t v31 = *(void *)(v335 + 104);
      uint64_t v360 = (uint64_t)v658;
      uint64_t v361 = v659;
      long long v362 = re::MeshAsset::assetType((re::MeshAsset *)v359);
      uint64_t v363 = re::ImportAssetTable::addAsset((_anonymous_namespace_ *)v31, v360, v361, v357, (re **)v362);
      if (*(unsigned char *)(v363 + 8)) {
        long long v364 = *(re::AssetPath **)(v363 + 16);
      }
      else {
        long long v364 = (re::AssetPath *)(v363 + 9);
      }
      unint64_t v366 = v684;
      if ((unint64_t)v359[8] < v684)
      {
        long long v365 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetHandle>::setCapacity(v359 + 7, v684);
        unint64_t v366 = v684;
      }
      if (v366)
      {
        unint64_t v31 = 32 * v366;
        long long v367 = (re::AssetPath **)(*(void *)v686 + 16);
        do
        {
          memset(buf, 0, 24);
          if (*(unsigned char *)(v367 - 1)) {
            long long v368 = *v367;
          }
          else {
            long long v368 = (re::AssetPath *)((char *)v367 - 7);
          }
          re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)(v359 + 7), (re::AssetHandle *)buf);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
          v367 += 4;
          v31 -= 32;
        }
        while (v31);
      }
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v617);
      unint64_t v133 = (unint64_t)v718;
    }
    else
    {
      long long v316 = (id)*re::pipelineLogObjects(MeshAssetDataFromDescriptor);
      if (os_log_type_enabled(v316, OS_LOG_TYPE_ERROR))
      {
LABEL_647:
        if (v703.i8[0]) {
          v540 = (char *)v703.i64[1];
        }
        else {
          v540 = &v703.i8[1];
        }
        buf[0].n128_u32[0] = 136315394;
        *(void *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v662;
        buf[0].n128_u16[6] = 2080;
        *(void *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v540;
        _os_log_error_impl(&dword_233120000, v316, OS_LOG_TYPE_ERROR, "Skipping mesh for entity '%s' due to error: %s", (uint8_t *)buf, 0x16u);
      }
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v701);
    re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v717);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(&v715);
    *(double *)v35.i64 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v133 + 24));
  }
  v608.i64[0] = (uint64_t)&v654;
  size_t v14 = v656;
  if (!v589)
  {
    if (!v656)
    {
      std::string v589 = 0;
      uint64_t v397 = v581;
      uint64_t v398 = a5;
      goto LABEL_557;
    }
    long long v369 = re::globalAllocators((re *)v33);
    uint64_t v370 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v369[2] + 32))(v369[2], 224, 8);
    *(_OWORD *)(v370 + 176) = 0u;
    *(_OWORD *)(v370 + 192) = 0u;
    *(_OWORD *)uint64_t v370 = 0u;
    *(_OWORD *)(v370 + 16) = 0u;
    *(_OWORD *)(v370 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
    *(_OWORD *)(v370 + 48) = 0u;
    *(_OWORD *)(v370 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
    *(_OWORD *)(v370 + 80) = 0u;
    *(_OWORD *)(v370 + 96) = 0u;
    *(_OWORD *)(v370 + 112) = 0u;
    *(_OWORD *)(v370 + 128) = 0u;
    *(_OWORD *)(v370 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
    *(_OWORD *)(v370 + 160) = 0u;
    *(_DWORD *)(v370 + 196) = 0x7FFFFFFF;
    *(void *)(v370 + 208) = 0;
    *(void *)(v370 + 216) = "";
    std::string v589 = (_anonymous_namespace_ *)v370;
  }
  char v606 = *(unsigned char *)(v583 + 48);
  uint64_t v371 = v658;
  re::TimelineGroupBuilder::TimelineGroupBuilder((uint64_t)&v701, *(void *)(a3 + 104), (uint64_t)v658, v659);
  if (v14)
  {
    unint64_t v10 = 0;
    v614.i64[0] = v652;
    float32x4_t v372 = v655;
    if (v653) {
      float32x4_t v372 = &v654;
    }
    v611 = v372;
    unint64_t v31 = (unint64_t)"childSceneClip";
    size_t v613 = v14;
    long long v164 = (__n128 *)a5;
    while (1)
    {
      unint64_t v373 = v10 >> 3;
      if (v614.i64[0] <= v10 >> 3) {
        break;
      }
      int32x4_t v374 = (double *)(v611[v373] + 40 * (v10 & 7));
      float32_t v375 = *v374;
      float v376 = *v374 + v374[1];
      re::AssetHandle::AssetHandle((re::AssetHandle *)v758, (const re::AssetHandle *)(v374 + 2));
      size_t v377 = strlen(v371);
      re::TimelineGroupBuilder::addTimeline((uint64_t)&v701, (const re::AssetHandle *)v758, (uint64_t)v371, v377, "entitySceneClip", v375, v376);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v758);
      float32_t v378 = *v374;
      float v379 = *v374 + v374[1];
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v617, (const re::AssetHandle *)(v374 + 2));
      size_t v380 = strlen(v371);
      re::TimelineGroupBuilder::addTimeline((uint64_t)v622, (const re::AssetHandle *)&v617, (uint64_t)v371, v380, "defaultSceneClip", v378, v379);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v617);
      uint64_t v381 = *(void *)(a5 + 40);
      if (v381)
      {
        for (size_t k = 0; k != v381; ++k)
        {
          a2 = *(void *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](a5, k);
          float32_t v382 = *v374;
          float v383 = *v374 + v374[1];
          re::AssetHandle::AssetHandle((re::AssetHandle *)v759, (const re::AssetHandle *)(v374 + 2));
          size_t v384 = strlen(v371);
          re::TimelineGroupBuilder::addTimeline(a2, (const re::AssetHandle *)v759, (uint64_t)v371, v384, "childSceneClip", v382, v383);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v759);
        }
      }
      ++v10;
      size_t v14 = v613;
      size_t v9 = (size_t)&v701;
      if (v10 == v613) {
        goto LABEL_484;
      }
    }
LABEL_654:
    *(void *)v718 = 0;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v712) = 136315906;
    *(void *)(v9 + 180) = "operator[]";
    WORD2(v7re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 1024;
    *(_DWORD *)(v9 + 190) = 866;
    WORD1(v71re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 2048;
    *(void *)(v9 + 196) = v373;
    WORD2(v715) = 2048;
    *(void *)(v9 + 206) = v614.i64[0];
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_655;
  }
LABEL_484:
  uint64_t v696 = 0;
  uint64_t v695 = 0;
  v697 = 0;
  if (*((void *)&v739 + 1) | *((void *)&v742 + 1))
  {
    re::DynamicString::format((re::DynamicString *)"%s_defaultTimelineGroupPoses", (re::DynamicString *)buf, v371);
    int32x4_t v385 = *(_anonymous_namespace_ **)(a3 + 104);
    if (buf[0].n128_u8[8]) {
      float32x4_t v386 = (const char *)buf[1].n128_u64[0];
    }
    else {
      float32x4_t v386 = &buf[0].n128_i8[9];
    }
    uint64_t v387 = (re *)strlen(v386);
    float32x4_t v388 = re::globalAllocators(v387);
    uint64_t v389 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v388[2] + 32))(v388[2], 320, 8);
    uint64_t v390 = re::DynamicArray<re::AssetHandle>::DynamicArray(v389, (uint64_t *)&v732);
    re::DynamicArray<re::StringID>::DynamicArray(v390 + 40, (uint64_t *)&v734 + 1);
    re::DynamicArray<re::StringID>::DynamicArray(v389 + 80, (uint64_t *)&v736[16]);
    re::DynamicArray<re::FixedArray<re::StringID>>::DynamicArray(v389 + 120, (uint64_t *)&v738 + 1);
    char v391 = (uint64_t *)re::DynamicArray<re::FixedArray<re::StringID>>::DynamicArray(v389 + 160, (uint64_t *)&v741 + 1);
    *(void *)(v389 + 200) = 0;
    *(void *)(v389 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(v389 + 208) = 0;
    *(void *)(v389 + 216) = 0;
    *(_DWORD *)(v389 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    if (*((void *)&v744 + 1))
    {
      unint64_t v392 = *((void *)&v745 + 1);
      *(void *)(v389 + 200) = *((void *)&v744 + 1);
      re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)(v389 + 200), v392);
      ++*(_DWORD *)(v389 + 224);
      uint64_t v393 = *((void *)&v745 + 1);
      if (*((void *)&v745 + 1) >= *(void *)(v389 + 216))
      {
        re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)(v389 + 200), *((unint64_t *)&v745 + 1));
        char v391 = (uint64_t *)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,0>(v747, v747 + 24 * *(void *)(v389 + 216), *(void **)(v389 + 232));
        uint64_t v399 = *(void *)(v389 + 216);
        if (v399 != v393)
        {
          uint64_t v400 = 3 * v399;
          uint64_t v401 = v747 + 8 * v400;
          char v391 = (uint64_t *)(*(void *)(v389 + 232) + 8 * v400);
          uint64_t v402 = 24 * v393 - 8 * v400;
          do
          {
            uint64_t v403 = re::FixedArray<re::GenericSRT<float>>::FixedArray(v391, v401);
            v401 += 24;
            char v391 = v403 + 3;
            v402 -= 24;
          }
          while (v402);
        }
      }
      else
      {
        char v391 = (uint64_t *)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,0>(v747, v747 + 24 * *((void *)&v745 + 1), *(void **)(v389 + 232));
        uint64_t v394 = *(void *)(v389 + 216);
        if (v393 != v394)
        {
          id v395 = (uint64_t *)(*(void *)(v389 + 232) + 24 * v393);
          uint64_t v396 = 24 * v394 - 24 * v393;
          do
          {
            char v391 = (uint64_t *)re::FixedArray<CoreIKTransform>::deinit(v395);
            v395 += 3;
            v396 -= 24;
          }
          while (v396);
        }
      }
      *(void *)(v389 + 216) = v393;
    }
    *(void *)(v389 + 240) = 0;
    *(void *)(v389 + 272) = 0;
    *(void *)(v389 + 248) = 0;
    *(void *)(v389 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
    *(_DWORD *)(v389 + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    if (*((void *)&v747 + 1))
    {
      unint64_t v404 = *((void *)&v748 + 1);
      *(void *)(v389 + 240) = *((void *)&v747 + 1);
      re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)(v389 + 240), v404);
      ++*(_DWORD *)(v389 + 264);
      uint64_t v405 = *((void *)&v748 + 1);
      if (*((void *)&v748 + 1) >= *(void *)(v389 + 256))
      {
        re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((void *)(v389 + 240), *((unint64_t *)&v748 + 1));
        char v391 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,0>((uint64_t *)v750, (uint64_t *)(v750 + 24 * *(void *)(v389 + 256)), *(uint64_t **)(v389 + 272));
        uint64_t v409 = *(void *)(v389 + 256);
        if (v409 != v405)
        {
          uint64_t v410 = 3 * v409;
          uint64_t v411 = v750 + 8 * v410;
          char v391 = (uint64_t *)(*(void *)(v389 + 272) + 8 * v410);
          uint64_t v412 = 24 * v405 - 8 * v410;
          do
          {
            uint64_t v413 = re::FixedArray<re::Matrix4x4<float>>::FixedArray(v391, v411);
            v411 += 24;
            char v391 = v413 + 3;
            v412 -= 24;
          }
          while (v412);
        }
      }
      else
      {
        char v391 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,0>((uint64_t *)v750, (uint64_t *)(v750 + 24 * *((void *)&v748 + 1)), *(uint64_t **)(v389 + 272));
        uint64_t v406 = *(void *)(v389 + 256);
        if (v405 != v406)
        {
          v407 = (uint64_t *)(*(void *)(v389 + 272) + 24 * v405);
          uint64_t v408 = 24 * v406 - 24 * v405;
          do
          {
            char v391 = (uint64_t *)re::FixedArray<CoreIKTransform>::deinit(v407);
            v407 += 3;
            v408 -= 24;
          }
          while (v408);
        }
      }
      *(void *)(v389 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v405;
    }
    *(void *)(v389 + 312) = 0;
    *(void *)(v389 + 288) = 0;
    *(void *)(v389 + 296) = 0;
    *(void *)(v389 + 280) = 0;
    *(_DWORD *)(v389 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    if (*((void *)&v750 + 1))
    {
      v614.i64[0] = (uint64_t)v386;
      unint64_t v414 = *((void *)&v751 + 1);
      *(void *)(v389 + 280) = *((void *)&v750 + 1);
      re::DynamicArray<re::SkeletalPoseMeshMap>::setCapacity((void *)(v389 + 280), v414);
      ++*(_DWORD *)(v389 + 304);
      uint64_t v415 = *((void *)&v751 + 1);
      if (*((void *)&v751 + 1) >= *(void *)(v389 + 296))
      {
        re::DynamicArray<re::SkeletalPoseMeshMap>::setCapacity((void *)(v389 + 280), *((unint64_t *)&v751 + 1));
        char v391 = (uint64_t *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *>(v753, &v753[8 * *(void *)(v389 + 296)], *(void *)(v389 + 312));
        uint64_t v419 = *(void *)(v389 + 296);
        if (v419 != v415)
        {
          id v420 = v753;
          v421 = &v753[8 * v415];
          uint64_t v422 = *(void *)(v389 + 312);
          uint64_t v423 = v419 << 6;
          do
          {
            unint64_t v424 = (char *)v420 + v423;
            *(unsigned char *)(v422 + v423) = *((unsigned char *)v420 + v423);
            re::StringID::StringID((re::StringID *)(v422 + v423 + 8), (const StringID *)((char *)v420 + v423 + 8));
            re::StringID::StringID((re::StringID *)(v422 + v423 + 24), (const StringID *)((char *)v420 + v423 + 24));
            char v391 = (uint64_t *)re::StringID::StringID((re::StringID *)(v422 + v423 + 40), (const StringID *)((char *)v420 + v423 + 40));
            *(void *)(v422 + v423 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(unint64_t *)((char *)v420 + v423 + 56);
            v420 += 8;
            v422 += 64;
          }
          while (v424 + 64 != (char *)v421);
        }
      }
      else
      {
        char v391 = (uint64_t *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *>(v753, &v753[8 * *((void *)&v751 + 1)], *(void *)(v389 + 312));
        uint64_t v416 = *(void *)(v389 + 296);
        if (v415 != v416)
        {
          uint64_t v417 = (v416 << 6) - (v415 << 6);
          id v418 = (re::StringID *)(*(void *)(v389 + 312) + (v415 << 6) + 40);
          do
          {
            re::StringID::destroyString(v418);
            re::StringID::destroyString((re::StringID *)((char *)v418 - 16));
            re::StringID::destroyString((re::StringID *)((char *)v418 - 32));
            id v418 = (re::StringID *)((char *)v418 + 64);
            v417 -= 64;
          }
          while (v417);
        }
      }
      *(void *)(v389 + 296) = v415;
      size_t v9 = (size_t)&v701;
    }
    v425 = re::SkeletalPoseDefinitionAsset::assetType((re::SkeletalPoseDefinitionAsset *)v391);
    uint64_t v426 = re::ImportAssetTable::addAsset(v385, (uint64_t)v386, (uint64_t)v387, (void *)v389, (re **)v425);
    if (*(unsigned char *)(v426 + 8)) {
      v427 = *(re::AssetPath **)(v426 + 16);
    }
    else {
      v427 = (re::AssetPath *)(v426 + 9);
    }
    if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
      (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
    }
  }
  *((unsigned char *)v567 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v606;
  BOOL v428 = (re *)re::AssetHandle::operator=((uint64_t)(v567 + 8), &v695);
  v429 = re::globalAllocators(v428);
  uint64_t v430 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v429[2] + 32))(v429[2], 112, 8);
  *(_OWORD *)(v430 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v430 + 48) = 0u;
  *(_OWORD *)(v430 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)uint64_t v430 = 0u;
  *(_OWORD *)(v430 + 16) = 0u;
  *(void *)(v430 + 80) = 0;
  *(void *)(v430 + 88) = 0;
  *(void *)(v430 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "";
  *(void *)(v430 + 40) = 0;
  *(void *)(v430 + 48) = 0;
  *(void *)(v430 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(_DWORD *)(v430 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v430 + 96) = 0;
  *(void *)(v430 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  re::TimelineGroupBuilder::createTimelineAsset((re::TimelineGroupBuilder *)buf, (const char *)&v701, "default scene animation");
  unint64_t v431 = *(void *)(v430 + 8);
  unint64_t v432 = *(void *)(v430 + 16);
  *(void *)(v430 + 8) = buf[0].n128_u64[1];
  buf[0].n128_u64[1] = v431;
  unint64_t v433 = *(void *)v430;
  *(void *)uint64_t v430 = 0;
  *(void *)uint64_t v430 = buf[0].n128_u64[0];
  *(void *)(v430 + 16) = buf[1].n128_u64[0];
  buf[0].n128_u64[0] = v433;
  buf[1].n128_u64[0] = v432;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  re::StringID::operator=((unint64_t *)(v430 + 24), &v661);
  *(unsigned char *)(v430 + 80) = v606;
  re::AssetHandle::operator=(v430 + 88, &v695);
  re::DynamicString::format((re::DynamicString *)"%s_defaultEntityScene", (re::DynamicString *)&v712, v658);
  v434 = *(_anonymous_namespace_ **)(a3 + 104);
  if (v713) {
    BOOL v435 = (const char *)v714;
  }
  else {
    BOOL v435 = (char *)&v713 + 1;
  }
  size_t v436 = strlen(v435);
  v437 = re::BasicAsset<re::AnimationScene,&re::kAnimationSceneAssetName,&re::kAnimationSceneAssetExtension>::assetType();
  uint64_t v438 = re::ImportAssetTable::addAsset(v434, (uint64_t)v435, v436, (void *)v430, (re **)v437);
  buf[0].n128_u64[0] = 0;
  buf[0].n128_u64[1] = (unint64_t)"";
  memset(&buf[1], 0, 24);
  re::DynamicArray<re::NamedAnimationLibraryEntry>::add((void *)v589 + 10, (uint64_t *)buf);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1]);
  re::StringID::destroyString((re::StringID *)buf);
  uint64_t v439 = *((void *)v589 + 14) + 40 * *((void *)v589 + 12);
  re::StringID::destroyString((re::StringID *)(v439 - 40));
  *(void *)(v439 - 40) = 0x7AAA0A2456EA1222;
  *(void *)(v439 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "default scene animation";
  v441 = (re::DynamicString *)(v439 - 24);
  if (*(unsigned char *)(v438 + 8)) {
    v442 = *(re::AssetPath **)(v438 + 16);
  }
  else {
    v442 = (re::AssetPath *)(v438 + 9);
  }
  memset(buf, 0, 24);
  re::DynamicArray<re::AssetHandle>::add((void *)v589 + 15, (uint64_t *)buf);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  v444 = (re::DynamicString *)(*((void *)v589 + 19) + 24 * *((void *)v589 + 17) - 24);
  if (*(unsigned char *)(v438 + 8)) {
    v445 = *(re::AssetPath **)(v438 + 16);
  }
  else {
    v445 = (re::AssetPath *)(v438 + 9);
  }
  v447 = re::globalAllocators(v446);
  uint64_t v448 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v447[2] + 32))(v447[2], 112, 8);
  *(_OWORD *)(v448 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v448 + 48) = 0u;
  *(_OWORD *)(v448 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)uint64_t v448 = 0u;
  *(_OWORD *)(v448 + 16) = 0u;
  *(void *)(v448 + 80) = 0;
  *(void *)(v448 + 88) = 0;
  *(void *)(v448 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "";
  *(void *)(v448 + 48) = 0;
  *(void *)(v448 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(_DWORD *)(v448 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v448 + 40) = 0;
  *(void *)(v448 + 96) = 0;
  *(void *)(v448 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  unint64_t v31 = (unint64_t)"default subtree animation";
  re::TimelineGroupBuilder::createTimelineAsset((re::TimelineGroupBuilder *)buf, v622, "default subtree animation");
  unint64_t v449 = *(void *)(v448 + 8);
  unint64_t v450 = *(void *)(v448 + 16);
  *(void *)(v448 + 8) = buf[0].n128_u64[1];
  buf[0].n128_u64[1] = v449;
  unint64_t v451 = *(void *)v448;
  *(void *)uint64_t v448 = 0;
  *(void *)uint64_t v448 = buf[0].n128_u64[0];
  *(void *)(v448 + 16) = buf[1].n128_u64[0];
  buf[0].n128_u64[0] = v451;
  buf[1].n128_u64[0] = v450;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  re::StringID::operator=((unint64_t *)(v448 + 24), (uint64_t *)v567);
  re::DynamicArray<re::AnimationSceneEntityData>::operator=(v448 + 40, (uint64_t *)v567 + 2);
  *(unsigned char *)(v448 + 80) = *((unsigned char *)v567 + 56);
  re::AssetHandle::operator=(v448 + 88, (uint64_t *)v567 + 8);
  re::DynamicString::format((re::DynamicString *)"%s_defaultAnimationScene", (re::DynamicString *)v718, v658);
  v452 = *(_anonymous_namespace_ **)(a3 + 104);
  if (v718[8]) {
    v453 = *(const char **)&v719[4];
  }
  else {
    v453 = &v718[9];
  }
  a2 = strlen(v453);
  v454 = re::BasicAsset<re::AnimationScene,&re::kAnimationSceneAssetName,&re::kAnimationSceneAssetExtension>::assetType();
  uint64_t v455 = re::ImportAssetTable::addAsset(v452, (uint64_t)v453, a2, (void *)v448, (re **)v454);
  memset(buf, 0, 24);
  re::DynamicArray<re::AssetHandle>::add((void *)v589 + 15, (uint64_t *)buf);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  v457 = (re::DynamicString *)(*((void *)v589 + 19) + 24 * *((void *)v589 + 17) - 24);
  if (*(unsigned char *)(v455 + 8)) {
    size_t v14 = *(void *)(v455 + 16);
  }
  else {
    size_t v14 = v455 + 9;
  }
  unint64_t v10 = (unint64_t)buf;
  buf[0].n128_u64[0] = 0;
  buf[0].n128_u64[1] = (unint64_t)"";
  memset(&buf[1], 0, 24);
  re::DynamicArray<re::NamedAnimationLibraryEntry>::add((void *)v589 + 10, (uint64_t *)buf);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1]);
  re::StringID::destroyString((re::StringID *)buf);
  uint64_t v458 = *((void *)v589 + 14) + 40 * *((void *)v589 + 12);
  re::StringID::destroyString((re::StringID *)(v458 - 40));
  *(void *)(v458 - 40) = 0x68ABFF436306FF46;
  *(void *)(v458 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "default subtree animation";
  v460 = (re::DynamicString *)(v458 - 24);
  if (*(unsigned char *)(v455 + 8)) {
    v461 = *(re::AssetPath **)(v455 + 16);
  }
  else {
    v461 = (re::AssetPath *)(v455 + 9);
  }
  if (*(void *)v718 && (v718[8] & 1) != 0) {
    (*(void (**)(void))(**(void **)v718 + 40))();
  }
  uint64_t v398 = a5;
  if (v712 && (v713 & 1) != 0) {
    (*(void (**)(void))(*v712 + 40))();
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v695);
  re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::deinit((uint64_t)&v704.i64[1]);
  if (v704.i64[1])
  {
    __int32 v462 = v705.i32[2];
    if ((v705.i8[8] & 1) == 0)
    {
      (*(void (**)(void))(*(void *)v704.i64[1] + 40))();
      __int32 v462 = v705.i32[2];
    }
    v704.i64[1] = 0;
    v705.i64[0] = 0;
    v705.i32[2] = (v462 | 1) + 2;
  }
  if (v701.n128_u64[1] && (v702.i8[0] & 1) != 0) {
    (*(void (**)(void))(*(void *)v701.n128_u64[1] + 40))();
  }
  uint64_t v397 = v581;
LABEL_557:
  if (!a9) {
    goto LABEL_568;
  }
  if (!*(void *)(v398 + 40)) {
    goto LABEL_672;
  }
  if (!*(void *)(*(void *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v398, 0) + 96))
  {
LABEL_568:
    unint64_t v484 = (unint64_t)v589;
    if (!v589)
    {
LABEL_600:
      id v520 = (unint64_t *)re::BucketArray<unsigned long,32ul>::operator[](v558, v569);
      v521 = (_anonymous_namespace_ *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v397, *v520);
      v522 = v521;
      if (*((void *)v521 + 117))
      {
        int v523 = re::ecs2::EntityAssetData::addComponent<re::ecs2::AudioPlayerComponent>(&v660);
        uint64_t v524 = (uint64_t)v523;
        if (!v664[0])
        {
          v664[0] = k;
          re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v664, 0);
          ++v666;
        }
        unint64_t v31 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AudioAnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                    + 7)
                                                                 + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AudioAnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 248, 0);
        double v525 = re::ecs2::AudioAnimationComponent::AudioAnimationComponent((re::ecs2::AudioAnimationComponent *)v31);
        v701.n128_u64[0] = *(void *)((*(uint64_t (**)(uint64_t, double))(*(void *)v526 + 40))(v526, v525)
                                     + 24) >> 1;
        v701.n128_u64[1] = v31;
        v702.i8[0] = 1;
        re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)v664, &v701);
        v527 = (int32x2_t *)*((void *)v522 + 117);
        *(int32x2_t *)(v31 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = vrev64_s32(v527[2]);
        if (*(unsigned char *)(*(void *)(v583 + 40) + 96))
        {
          re::AssetHandle::AssetHandle((re::AssetHandle *)&v701, (const re::AssetHandle *)&v527[6]);
          re::AssetHandle::AssetHandle((re::AssetHandle *)v616, (const re::AssetHandle *)&v701);
          re::ecs2::AudioPlayerComponent::registerAudioAsset(v524, (re::AssetHandle *)v616);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v616);
          re::AssetHandle::operator=(v31 + 72, (uint64_t *)&v701);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v701);
        }
      }
      v528 = (const char *)*((void *)v522 + 6);
      uint64_t v529 = re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(a3 + 312, (uint64_t)&v701);
      if (v529)
      {
        uint64_t v530 = v529;
        if (!v664[0] || !v665) {
          goto LABEL_613;
        }
        v531 = (re::ecs2::AudioPlayerComponent **)(v667[0] + 8);
        uint64_t v532 = 24 * v665;
        while (*(v531 - 1) != (re::ecs2::AudioPlayerComponent *)(*((void *)re::ecs2::ComponentImpl<re::ecs2::AudioPlayerComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                  + 3) >> 1))
        {
          v531 += 3;
          v532 -= 24;
          if (!v532) {
            goto LABEL_613;
          }
        }
        id v533 = *v531;
        if (!*v531) {
LABEL_613:
        }
          id v533 = re::ecs2::EntityAssetData::addComponent<re::ecs2::AudioPlayerComponent>(&v660);
        uint64_t v534 = *(void *)(v530 + 16);
        if (v534)
        {
          uint64_t v535 = *(const re::AssetHandle **)(v530 + 32);
          uint64_t v536 = 24 * v534;
          do
          {
            re::AssetHandle::AssetHandle((re::AssetHandle *)v615, v535);
            re::ecs2::AudioPlayerComponent::registerAudioAsset((uint64_t)v533, (re::AssetHandle *)v615);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)v615);
            uint64_t v535 = (const re::AssetHandle *)((char *)v535 + 24);
            v536 -= 24;
          }
          while (v536);
        }
      }
      if (v701.n128_u64[0] && (v701.n128_u8[8] & 1) != 0) {
        (*(void (**)(unint64_t))(*(void *)v701.n128_u64[0] + 40))(v701.n128_u64[0]);
      }
      *(unsigned char *)a1 = 1;
      re::ecs2::EntityAssetData::EntityAssetData((uint64_t)a1 + 8, (uint64_t)&v660);
      re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::deinit((uint64_t)v625);
      if (v625[0])
      {
        int v537 = v626;
        if ((v626 & 1) == 0)
        {
          (*(void (**)(void))(*(void *)v625[0] + 40))(v625[0]);
          int v537 = v626;
        }
        v625[0] = 0;
        v625[1] = 0;
        int v626 = (v537 | 1) + 2;
      }
      if (v623 && (v624 & 1) != 0) {
        (*(void (**)(uint64_t))(*(void *)v623 + 40))(v623);
      }
      long long v164 = (__n128 *)v628;
      if (v632)
      {
        unint64_t v538 = 0;
        while (v628 > v538 >> 3)
        {
          if (v632 == (int32x2_t *)++v538) {
            goto LABEL_633;
          }
        }
LABEL_652:
        unint64_t v373 = v538 >> 3;
        v712 = 0;
        *(_OWORD *)(v9 + 48) = 0u;
        *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
        *(_OWORD *)(v9 + 16) = 0u;
        *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
        *(_OWORD *)size_t v9 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        buf[0].n128_u32[0] = 136315906;
        *(void *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
        buf[0].n128_u16[6] = 1024;
        *(_DWORD *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 858;
        buf[1].n128_u16[1] = 2048;
        *(void *)(v10 + 20) = v373;
        buf[1].n128_u16[6] = 2048;
        *(void *)(v10 + 30) = v164;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      else
      {
        while (v628)
LABEL_633:
          re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v627);
        if (v627 && (v629 & 1) == 0) {
          (*(void (**)(uint64_t))(*(void *)v627 + 40))(v627);
        }
        v539 = v639;
        if (!v639) {
          goto LABEL_676;
        }
        unint64_t v31 = 0;
        long long v164 = (__n128 *)v635;
        if (v636) {
          size_t v14 = (size_t)&v637;
        }
        else {
          size_t v14 = (size_t)v638;
        }
        size_t k = 40;
        while (1)
        {
          unint64_t v373 = v31 >> 3;
          if ((unint64_t)v164 <= v31 >> 3) {
            break;
          }
          re::DynamicArray<re::GeomDeformer>::deinit(*(void *)(v14 + 8 * v373) + 40 * (v31++ & 7));
          if (v539 == (int32x2_t *)v31) {
            goto LABEL_675;
          }
        }
      }
      v712 = 0;
      *(_OWORD *)(v9 + 48) = 0u;
      *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
      *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
      *(_OWORD *)size_t v9 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      buf[0].n128_u32[0] = 136315906;
      *(void *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
      buf[0].n128_u16[6] = 1024;
      *(_DWORD *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 858;
      buf[1].n128_u16[1] = 2048;
      *(void *)(v10 + 20) = v373;
      buf[1].n128_u16[6] = 2048;
      *(void *)(v10 + 30) = v164;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_654;
    }
LABEL_587:
    re::DynamicString::format((re::DynamicString *)"%s_animationlibrary", (re::DynamicString *)&v701, v658, v557);
    v513 = (re::AnimationLibraryAsset *)re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationLibraryComponent>(&v660);
    v514 = (re::AnimationLibraryAsset *)((char *)v513 + 32);
    v515 = *(_anonymous_namespace_ **)(a3 + 104);
    if (v701.n128_u8[8]) {
      v516 = (__int8 *)v702.i64[0];
    }
    else {
      v516 = &v701.n128_i8[9];
    }
    if (v701.n128_u8[8]) {
      unint64_t v31 = v701.n128_u64[1] >> 1;
    }
    else {
      unint64_t v31 = v701.n128_u8[8] >> 1;
    }
    v517 = re::AnimationLibraryAsset::assetType(v513);
    uint64_t v518 = re::ImportAssetTable::addAsset(v515, (uint64_t)v516, v31, (void *)v484, (re **)v517);
    if (*(unsigned char *)(v518 + 8)) {
      v519 = *(re::AssetPath **)(v518 + 16);
    }
    else {
      v519 = (re::AssetPath *)(v518 + 9);
    }
    re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationComponent>(&v660);
    if (v701.n128_u64[0] && (v701.n128_u8[8] & 1) != 0) {
      (*(void (**)(void))(*(void *)v701.n128_u64[0] + 40))();
    }
    uint64_t v397 = v581;
    goto LABEL_600;
  }
  if (!*(void *)(v398 + 40)) {
    goto LABEL_673;
  }
  v464 = (re *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v398, 0);
  int v465 = *(const char **)v464;
  a2 = (unint64_t)v589;
  if (!v589)
  {
    uint64_t v466 = re::globalAllocators(v464);
    a2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v466[2] + 32))(v466[2], 224, 8);
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_DWORD *)(a2 + 196) = 0x7FFFFFFF;
    *(void *)(a2 + 208) = 0;
    *(void *)(a2 + 216) = "";
  }
  v467 = re::globalAllocators(v464);
  uint64_t v468 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v467[2] + 32))(v467[2], 112, 8);
  *(_OWORD *)(v468 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v468 + 48) = 0u;
  *(_OWORD *)(v468 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)uint64_t v468 = 0u;
  *(_OWORD *)(v468 + 16) = 0u;
  *(void *)(v468 + 80) = 0;
  *(void *)(v468 + 88) = 0;
  *(void *)(v468 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "";
  *(void *)(v468 + 48) = 0;
  *(void *)(v468 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(_DWORD *)(v468 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v468 + 40) = 0;
  *(void *)(v468 + 96) = 0;
  *(void *)(v468 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  re::TimelineGroupBuilder::createTimelineAsset((re::TimelineGroupBuilder *)&v701, v465, "global scene animation");
  unint64_t v469 = *(void *)(v468 + 8);
  uint64_t v470 = *(void *)(v468 + 16);
  *(void *)(v468 + 8) = v701.n128_u64[1];
  v701.n128_u64[1] = v469;
  unint64_t v471 = *(void *)v468;
  *(void *)uint64_t v468 = 0;
  *(void *)uint64_t v468 = v701.n128_u64[0];
  *(void *)(v468 + 16) = v702.i64[0];
  v701.n128_u64[0] = v471;
  v702.i64[0] = v470;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v701);
  unint64_t v472 = *(void *)a6;
  uint64_t v473 = *(void *)(a6 + 8);
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = "";
  uint64_t v474 = *(void *)(v468 + 24);
  unint64_t v475 = *(void *)(v468 + 32);
  *(void *)(v468 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v472;
  *(void *)(v468 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v473;
  v701.n128_u64[1] = v475;
  v701.n128_u64[0] = v472 & 0xFFFFFFFFFFFFFFFELL | v474 & 1;
  re::StringID::destroyString((re::StringID *)&v701);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v468 + 40, a6 + 16);
  *(unsigned char *)(v468 + 80) = *(unsigned char *)(a6 + 56);
  uint64_t v476 = *(void *)(v468 + 96);
  *(void *)(v468 + 96) = *(void *)(a6 + 72);
  *(void *)(a6 + 72) = v476;
  uint64_t v477 = *(void *)(v468 + 88);
  *(void *)(v468 + 88) = 0;
  *(void *)(v468 + 88) = *(void *)(a6 + 64);
  *(void *)(a6 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v477;
  uint64_t v478 = *(void *)(v468 + 104);
  *(void *)(v468 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(a6 + 80);
  *(void *)(a6 + 80) = v478;
  re::DynamicString::format((re::DynamicString *)"%s_globalAnimationScene", (re::DynamicString *)v718, v658);
  v479 = *(_anonymous_namespace_ **)(a3 + 104);
  if (v718[8]) {
    v480 = *(const char **)&v719[4];
  }
  else {
    v480 = &v718[9];
  }
  size_t v14 = strlen(v480);
  v481 = re::BasicAsset<re::AnimationScene,&re::kAnimationSceneAssetName,&re::kAnimationSceneAssetExtension>::assetType();
  uint64_t v482 = re::ImportAssetTable::addAsset(v479, (uint64_t)v480, v14, (void *)v468, (re **)v481);
  __n128 v701 = 0uLL;
  v702.i64[0] = 0;
  re::DynamicArray<re::AssetHandle>::insert((void *)(a2 + 120), 0, (uint64_t *)&v701);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v701);
  unint64_t v484 = a2;
  id v485 = *(re::DynamicString **)(a2 + 152);
  if (*(unsigned char *)(v482 + 8)) {
    uint64_t v486 = *(re::AssetPath **)(v482 + 16);
  }
  else {
    uint64_t v486 = (re::AssetPath *)(v482 + 9);
  }
  buf[0].n128_u64[0] = 0;
  buf[0].n128_u64[1] = (unint64_t)"";
  memset(&buf[1], 0, 24);
  unint64_t v487 = *(void *)(a2 + 96);
  if (v487 != -1)
  {
    unint64_t v488 = a2;
    if (v487 >= *(void *)(a2 + 88))
    {
      re::DynamicArray<re::NamedAnimationLibraryEntry>::growCapacity((void *)(a2 + 80), v487 + 1);
      unint64_t v488 = a2;
      unint64_t v487 = *(void *)(a2 + 96);
    }
    int v489 = *(void **)(v488 + 112);
    v490 = &v489[5 * v487];
    if (v487)
    {
      v491 = &v489[5 * v487];
      unint64_t *v490 = *(v491 - 5);
      v491[3] = 0;
      v491[4] = 0;
      long long v492 = *((_OWORD *)v491 - 2);
      *(v491 - 5) = 0;
      *(v491 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "";
      *(_OWORD *)(v490 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v492;
      uint64_t v493 = *(v491 - 2);
      uint64_t v494 = *(v491 - 1);
      *(v491 - 3) = 0;
      *(v491 - 2) = 0;
      v491[3] = v493;
      v491[4] = v494;
      *(v491 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      int v489 = *(void **)(v488 + 112);
      uint64_t v495 = *(void *)(v488 + 96);
      if (&v489[5 * v495 - 5] != v489)
      {
        size_t v14 = 40 * v495;
        uint64_t v496 = 40;
        do
        {
          a2 = (unint64_t)v489 + v14;
          uint64_t v497 = *(void *)((char *)v489 + v14 - 80);
          uint64_t v498 = *(void *)((char *)v489 + v14 - 72);
          *(void *)(a2 - 80) = 0;
          *(void *)(a2 - 72) = "";
          unint64_t v499 = *(void *)((char *)v489 + v14 - 32);
          unint64_t v500 = v497 & 0xFFFFFFFFFFFFFFFELL | *(void *)((char *)v489 + v14 - 40) & 1;
          *(void *)(a2 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v498;
          v701.n128_u64[1] = v499;
          v701.n128_u64[0] = v500;
          *(void *)(a2 - 40) = v497;
          re::StringID::destroyString((re::StringID *)&v701);
          long long v501 = *(_OWORD *)((char *)v489 + v14 - 24);
          *(_OWORD *)(a2 - re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(_OWORD *)(a2 - 64);
          *(_OWORD *)(a2 - 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v501;
          uint64_t v502 = *(void *)((char *)v489 + v14 - 8);
          *(void *)(a2 - 8) = *(void *)(a2 - 48);
          *(void *)(a2 - 48) = v502;
          v489 -= 5;
          v496 += 40;
        }
        while (v14 != v496);
        int v489 = *(void **)(v484 + 112);
      }
      __n128 v503 = buf[0];
      buf[0].n128_u64[1] = (unint64_t)"";
      buf[0].n128_u64[0] = 0;
      unint64_t v504 = v489[1];
      unint64_t v505 = v503.n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | *v489 & 1;
      v489[1] = v503.n128_u64[1];
      v701.n128_u64[1] = v504;
      v701.n128_u64[0] = v505;
      *int v489 = v503.n128_u64[0];
      re::StringID::destroyString((re::StringID *)&v701);
      unint64_t v506 = v489[3];
      v489[3] = buf[1].n128_u64[1];
      buf[1].n128_u64[1] = v506;
    }
    else
    {
      unsigned __int8 v507 = buf[0].n128_u8[0];
      unint64_t *v490 = *v490 & 0xFFFFFFFFFFFFFFFELL | buf[0].n128_u8[0] & 1;
      unint64_t *v490 = buf[0].n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v507 & 1;
      v490[1] = buf[0].n128_u64[1];
      buf[0].n128_u64[1] = (unint64_t)"";
      buf[0].n128_u64[0] = 0;
      v489[3] = 0;
      v489[4] = 0;
      v489[2] = 0;
      v489[3] = buf[1].n128_u64[1];
      buf[1].n128_u64[1] = 0;
    }
    unint64_t v508 = v489[2];
    v489[2] = 0;
    v489[2] = buf[1].n128_u64[0];
    unint64_t v509 = v489[4];
    v489[4] = buf[2].n128_u64[0];
    buf[1].n128_u64[0] = v508;
    buf[2].n128_u64[0] = v509;
    ++*(void *)(v484 + 96);
    ++*(_DWORD *)(v484 + 104);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[1]);
    re::StringID::destroyString((re::StringID *)buf);
    v510 = *(void **)(v484 + 112);
    re::StringID::destroyString((re::StringID *)v510);
    void *v510 = 0x7802B65BF0AE64E6;
    v510[1] = "global scene animation";
    if (*(unsigned char *)(v482 + 8)) {
      v512 = *(re::AssetPath **)(v482 + 16);
    }
    else {
      v512 = (re::AssetPath *)(v482 + 9);
    }
    if (*(void *)v718 && (v718[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)v718 + 40))();
    }
    goto LABEL_587;
  }
LABEL_674:
  *(void *)v758 = 0;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)size_t v9 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  LODWORD(v712) = 136315906;
  *(void *)(v9 + 180) = "insert";
  WORD2(v7re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 1024;
  *(_DWORD *)(v9 + 190) = 887;
  WORD1(v71re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 2048;
  *(void *)(v9 + 196) = 0;
  WORD2(v715) = 2048;
  *(void *)(v9 + 206) = 0;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
  do
  {
LABEL_675:
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v634);
LABEL_676:
    ;
  }
  while (v635);
  if (v634 && (v636 & 1) == 0) {
    (*(void (**)(uint64_t))(*(void *)v634 + 40))(v634);
  }
  v541 = v646;
  if (!v646) {
    goto LABEL_689;
  }
  v542 = 0;
  unint64_t v543 = v642;
  if (v643) {
    v544 = v565;
  }
  else {
    v544 = v645;
  }
  while (1)
  {
    unint64_t v545 = (unint64_t)v542 >> 3;
    if (v543 <= (unint64_t)v542 >> 3) {
      break;
    }
    v542 = (int32x2_t *)((char *)v542 + 1);
    if (v541 == v542) {
      goto LABEL_688;
    }
  }
  v712 = 0;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)size_t v9 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  buf[0].n128_u32[0] = 136315906;
  *(void *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
  buf[0].n128_u16[6] = 1024;
  *(_DWORD *)(v10 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 858;
  buf[1].n128_u16[1] = 2048;
  *(void *)(v10 + 20) = v545;
  buf[1].n128_u16[6] = 2048;
  *(void *)(v10 + 30) = v543;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
  do
  {
LABEL_688:
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v641);
LABEL_689:
    ;
  }
  while (v642);
  if (v641 && (v643 & 1) == 0) {
    (*(void (**)(uint64_t))(*(void *)v641 + 40))(v641);
  }
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v730[8]);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v727 + 8);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v724[10]);
  re::DynamicArray<re::ModelWithLodsDescriptor>::deinit((uint64_t)v722);
  if (v648 && v649) {
    (*(void (**)(uint64_t))(*(void *)v648 + 40))(v648);
  }
  re::DynamicArray<re::MeshRigGraphIndex>::deinit((uint64_t)&v750 + 8);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v747 + 8);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v744 + 8);
  re::DynamicArray<re::FixedArray<re::StringID>>::deinit((uint64_t)&v741 + 8);
  re::DynamicArray<re::FixedArray<re::StringID>>::deinit((uint64_t)&v738 + 8);
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v736[16]);
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v734 + 8);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v732);
  size_t v546 = v656;
  if (!v656) {
    goto LABEL_705;
  }
  unint64_t v547 = 0;
  unint64_t v548 = v652;
  if (v653) {
    uint64_t v549 = v608.i64[0];
  }
  else {
    uint64_t v549 = (uint64_t)v655;
  }
  while (v548 > v547 >> 3)
  {
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(*(void *)(v549 + 8 * (v547 >> 3)) + 40 * (v547 & 7) + 16));
    if (v546 == ++v547) {
      goto LABEL_704;
    }
  }
  v701.n128_u64[0] = 0;
  long long v735 = 0u;
  *(_OWORD *)v736 = 0u;
  long long v733 = 0u;
  long long v734 = 0u;
  long long v732 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)v722 = 136315906;
  *(void *)&v722[4] = "operator[]";
  *(_WORD *)&v722[12] = 1024;
  *(_DWORD *)&v722[14] = 858;
  *(_WORD *)&v722[18] = 2048;
  *(void *)&v722[20] = v547 >> 3;
  __int16 v723 = 2048;
  *(void *)v724 = v548;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
  do
  {
LABEL_704:
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v651);
LABEL_705:
    ;
  }
  while (v652);
  if (v651 && (v653 & 1) == 0) {
    (*(void (**)(uint64_t))(*(void *)v651 + 40))(v651);
  }
  re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)&v660);
  if (v670 && v671) {
    (*(void (**)(uint64_t))(*(void *)v670 + 40))(v670);
  }
  if (v673 && v674) {
    (*(void (**)(uint64_t))(*(void *)v673 + 40))(v673);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v584);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)v582);
  size_t v550 = v681;
  if (v681)
  {
    unint64_t v551 = 0;
    do
    {
      id v552 = (uint64_t *)re::BucketArray<re::FixedArray<unsigned short>,16ul>::operator[]((uint64_t)&v676, v551);
      re::FixedArray<CoreIKTransform>::deinit(v552);
      ++v551;
    }
    while (v550 != v551);
  }
  while (v677)
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v676);
  if (v676 && (v678 & 1) == 0) {
    (*(void (**)(uint64_t))(*(void *)v676 + 40))(v676);
  }
  unint64_t v553 = v693;
  if (v693)
  {
    unint64_t v554 = 0;
    do
      re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)&v688, v554++);
    while (v553 != v554);
  }
  while (v689)
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(&v688);
  uint64_t result = v688;
  if (v688)
  {
    if ((v690 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v688 + 40))(v688);
    }
  }
  return result;
}

uint64_t re::addPhysicsFromImportContext(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (re::USDImportContext *)result;
  uint64_t v100 = *MEMORY[0x263EF8340];
  if (!*(void *)(result + 664)) {
    goto LABEL_62;
  }
  unint64_t v6 = 0;
  unint64_t v7 = -1;
  do
  {
    uint64_t v8 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v5 + 624, v6);
    uint64_t result = re::StringID::operator==((void *)(v8 + 8), (void *)(a3 + 8));
    if (result) {
      unint64_t v7 = v6;
    }
    ++v6;
  }
  while (v6 < *((void *)v5 + 83));
  if (v7 == -1) {
    goto LABEL_62;
  }
  uint64_t v9 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v5 + 624, v7);
  v91[0] = 0;
  PhysicsColliderData = re::USDImportContext::getPhysicsColliderData(v5, v7);
  uint64_t v12 = re::cloneCollisionShapeData((uint64_t)PhysicsColliderData, v11);
  CollidesWithEnvironment = re::USDImportContext::getCollidesWithEnvironment(v5, v7);
  if (v12)
  {
    char v14 = (char)CollidesWithEnvironment;
    id v15 = re::globalAllocators((re *)CollidesWithEnvironment);
    int v16 = *(_DWORD *)(v12 + 8);
    char v82 = v14;
    if (v16 == 7)
    {
      uint64_t v18 = re::convertCompoundToCollisionShape(v12, (uint64_t)v5, a2, v7);
      uint64_t v12 = (uint64_t)v18;
      v91[0] = v19;
      goto LABEL_30;
    }
    uint64_t v17 = (re::CollisionShape **)v15[2];
    if (v16 == 6)
    {
      uint64_t v18 = (re *)re::convertFromSerializable((re *)v12, (const re::CollisionShapeData *)v91, v17, (re::Allocator *)v17, (re::Allocator *)1);
LABEL_30:
      uint64_t v41 = re::globalAllocators(v18);
      uint64_t v42 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v41[2] + 32))(v41[2], 16, 8);
      unint64_t v43 = v91[0];
      *uint64_t v42 = v12;
      v42[1] = (uint64_t)v43;
      unint64_t v44 = *(_anonymous_namespace_ **)(a2 + 104);
      unint64_t v45 = *(const char **)(v9 + 16);
      unint64_t v46 = (re::CollisionShapeAsset *)strlen(v45);
      unint64_t v47 = re::CollisionShapeAsset::assetType(v46);
      uint64_t v48 = re::ImportAssetTable::addAsset(v44, (uint64_t)v45, (uint64_t)v46, v42, (re **)v47);
      memset(v92, 0, 24);
      if (*(unsigned char *)(v48 + 8)) {
        uint64_t v49 = *(re::AssetPath **)(v48 + 16);
      }
      else {
        uint64_t v49 = (re::AssetPath *)(v48 + 9);
      }
      uint64_t v50 = v9;
      long long v52 = (void *)(a3 + 32);
      if (!*(void *)(a3 + 32))
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a3 + 32), 0);
        ++*(_DWORD *)(a3 + 56);
      }
      uint64_t v53 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                  + 7)
                                                               + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 168, 0);
      re::make::shared::inplace<re::ecs2::ColliderComponent>(v53, &v87);
      float v54 = v87;
      unint64_t v55 = *(void *)((*(uint64_t (**)(re *))(*(void *)v87 + 40))(v87) + 24) >> 1;
      unint64_t v56 = (unint64_t)v87;
      int v87 = 0;
      v95.n128_u64[0] = v55;
      v95.n128_u64[1] = v56;
      LOBYTE(v96) = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)(a3 + 32), &v95);
      if (v87) {

      }
      re::AssetHandle::operator=((uint64_t)v54 + 32, (uint64_t *)v92);
      if ((v82 & 1) == 0) {
        *((void *)v54 + 8) = 0x100000001;
      }
      unint64_t v57 = re::ecs2::EntityAssetData::addComponent<re::ecs2::RigidBodyComponent>((_DWORD *)a3);
      *(_DWORD *)(v57 + 120) = 0;
      re::AssetHandle::operator=(v57 + 96, (uint64_t *)(v50 + 848));
      if ((*(unsigned int (**)(re::MassFrame *))(*(void *)v91[0] + 24))(v91[0]) == 6)
      {
        uint64_t v58 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v5 + 624, v7);
        uint32x2_t v59 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)v5 + 472, (void *)(v58 + 40));
        if (v59)
        {
          if (!*v52)
          {
            re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a3 + 32), 0);
            ++*(_DWORD *)(a3 + 56);
          }
          re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::create(&v87);
          long long v60 = v87;
          unint64_t v61 = *(void *)((*(uint64_t (**)(re *))(*(void *)v87 + 40))(v87) + 24) >> 1;
          unint64_t v62 = (unint64_t)v87;
          int v87 = 0;
          v95.n128_u64[0] = v61;
          v95.n128_u64[1] = v62;
          LOBYTE(v96) = 1;
          re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)(a3 + 32), &v95);
          if (v87) {

          }
          *((unsigned char *)v60 + 25) = v82;
          if (!*v52)
          {
            re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((void *)(a3 + 32), 0);
            ++*(_DWORD *)(a3 + 56);
          }
          re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(&v87);
          unint64_t v64 = *(void *)((*(uint64_t (**)(re *))(*(void *)v87 + 40))(v87) + 24) >> 1;
          unint64_t v65 = (unint64_t)v87;
          int v87 = 0;
          v95.n128_u64[0] = v64;
          v95.n128_u64[1] = v65;
          LOBYTE(v96) = 1;
          re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)(a3 + 32), &v95);
          if (v87) {
        }
          }
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v92);
      goto LABEL_50;
    }
    uint64_t v90 = 0;
    uint64_t v20 = (re *)re::convertFromSerializable((re *)v12, (const re::CollisionShapeData *)&v90, v17, (re::Allocator *)v17, (re::Allocator *)1);
    unint64_t v21 = re::globalAllocators(v20);
    int v22 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21[2] + 32))(v21[2], 16, 8);
    uint64_t v23 = v9;
    unint64_t v24 = v22;
    uint64_t v25 = v90;
    *int v22 = v12;
    v22[1] = v25;
    uint64_t v81 = v23;
    long long v26 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s_primitive", (re::DynamicString *)&v87, *(void *)(v23 + 16));
    uint64_t v27 = *(_anonymous_namespace_ **)(a2 + 104);
    if (v88) {
      size_t v28 = *(const char **)&v89[7];
    }
    else {
      size_t v28 = v89;
    }
    v95.n128_u64[0] = 0;
    v95.n128_u64[1] = (unint64_t)"";
    uint64_t v29 = v95.n128_i64[1];
    unint64_t v30 = (re::CollisionShapeAsset *)strlen((const char *)v95.n128_u64[1]);
    unint64_t v31 = re::CollisionShapeAsset::assetType(v30);
    uint64_t v32 = re::ImportAssetTable::addAsset(v27, v29, (uint64_t)v30, v24, (re **)v31);
    re::StringID::destroyString((re::StringID *)&v95);
    memset(v86, 0, sizeof(v86));
    if (*(unsigned char *)(v32 + 8)) {
      uint64_t v34 = *(re::AssetPath **)(v32 + 16);
    }
    else {
      uint64_t v34 = (re::AssetPath *)(v32 + 9);
    }
    unint64_t v36 = re::globalAllocators(v35);
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v36[2] + 32))(v36[2], 72, 8);
    *(_DWORD *)(v12 + 8) = 7;
    *(void *)uint64_t v12 = &unk_26E6D8C18;
    *(void *)(v12 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    *(void *)(v12 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(v12 + 16) = 0;
    *(void *)(v12 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
    *(void *)(v12 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    *(void *)(v12 + 48) = 0;
    uint64_t v9 = v81;
    if (*(void *)(v12 + 24))
    {
      re::AssetHandle::operator=(*(void *)(v12 + 32) + 48, v86);
      if (*(void *)(v12 + 24))
      {
        id v37 = *(void **)(v12 + 32);
        void v37[2] = 0;
        v37[3] = 0;
        v37[4] = 0;
        v37[5] = 0x3F80000000000000;
        PhysicsColliderPose = re::USDImportContext::getPhysicsColliderPose(v5, v7);
        if (PhysicsColliderPose)
        {
          if (!*(void *)(v12 + 24)) {
            goto LABEL_69;
          }
          uint64_t v39 = *(void *)(v12 + 32);
          long long v40 = *((_OWORD *)PhysicsColliderPose + 1);
          *(_OWORD *)(v39 + 16) = *(_OWORD *)PhysicsColliderPose;
          *(_OWORD *)(v39 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v40;
        }
        *(unsigned char *)(v12 + 40) = 1;
        uint64_t v83 = 0;
        uint64_t v84 = 0;
        int v85 = 0;
        re::FixedArray<unsigned long>::init<>(&v83, (uint64_t)v17, 1uLL);
        if (v84)
        {
          *int v85 = v90;
          v91[0] = (re::MassFrame *)re::convertToCompoundPrimitiveCollisionShape(v12, (uint64_t)&v83, (uint64_t)v17, (uint64_t)v17);
          if (v83 && v84) {
            (*(void (**)(void))(*(void *)v83 + 40))();
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v86);
          uint64_t v18 = v87;
          if (v87 && (v88 & 1) != 0) {
            uint64_t v18 = (re *)(*(uint64_t (**)(void))(*(void *)v87 + 40))();
          }
          goto LABEL_30;
        }
LABEL_68:
        v91[1] = 0;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        __n128 v95 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)float64x2_t v92 = 136315906;
        *(void *)&v92[4] = "operator[]";
        *(_WORD *)&v92[12] = 1024;
        *(_DWORD *)&v92[14] = 468;
        *(_WORD *)&v92[18] = 2048;
        *(void *)&v92[20] = 0;
        __int16 v93 = 2048;
        uint64_t v94 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_69:
        uint64_t v83 = 0;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        __n128 v95 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)float64x2_t v92 = 136315906;
        *(void *)&v92[4] = "operator[]";
        *(_WORD *)&v92[12] = 1024;
        *(_DWORD *)&v92[14] = 468;
        *(_WORD *)&v92[18] = 2048;
        *(void *)&v92[20] = 0;
        __int16 v93 = 2048;
        uint64_t v94 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else
    {
      uint64_t v83 = 0;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      __n128 v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float64x2_t v92 = 136315906;
      *(void *)&v92[4] = "operator[]";
      *(_WORD *)&v92[12] = 1024;
      *(_DWORD *)&v92[14] = 468;
      *(_WORD *)&v92[18] = 2048;
      *(void *)&v92[20] = 0;
      __int16 v93 = 2048;
      uint64_t v94 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v83 = 0;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    __n128 v95 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float64x2_t v92 = 136315906;
    *(void *)&v92[4] = "operator[]";
    *(_WORD *)&v92[12] = 1024;
    *(_DWORD *)&v92[14] = 468;
    *(_WORD *)&v92[18] = 2048;
    *(void *)&v92[20] = 0;
    __int16 v93 = 2048;
    uint64_t v94 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_68;
  }
LABEL_50:
  uint64_t result = (uint64_t)re::USDImportContext::getPhysicsRigidBodyProperties(v5, v7);
  if (result)
  {
    uint64_t v67 = result;
    if (!*(void *)(a3 + 32)) {
      goto LABEL_58;
    }
    uint64_t v68 = *(void *)(a3 + 48);
    if (!v68) {
      goto LABEL_58;
    }
    uint64_t v69 = (unint64_t *)(*(void *)(a3 + 64) + 8);
    uint64_t v70 = 24 * v68;
    while (*(v69 - 1) != *((void *)re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                          + 3) >> 1)
    {
      v69 += 3;
      v70 -= 24;
      if (!v70) {
        goto LABEL_58;
      }
    }
    unint64_t v71 = *v69;
    if (!*v69) {
LABEL_58:
    }
      unint64_t v71 = re::ecs2::EntityAssetData::addComponent<re::ecs2::RigidBodyComponent>((_DWORD *)a3);
    long long v72 = *(_OWORD *)v67;
    long long v73 = *(_OWORD *)(v67 + 16);
    long long v74 = *(_OWORD *)(v67 + 32);
    *(_DWORD *)(v71 + 80) = *(_DWORD *)(v67 + 48);
    *(_OWORD *)(v71 + 48) = v73;
    *(_OWORD *)(v71 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v74;
    *(_OWORD *)(v71 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v72;
    uint64_t result = (uint64_t)v91[0];
    if (v91[0])
    {
      uint64_t result = re::MassFrame::makeFromShapeAndMass(v91[0], v66, *(float *)(v67 + 48), (float32x4_t *)&v95);
      int v75 = v98;
      long long v77 = v96;
      long long v76 = v97;
      *(__n128 *)(v71 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v95;
      *(_OWORD *)(v71 + 48) = v77;
      *(_OWORD *)(v71 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v76;
      *(_DWORD *)(v71 + 80) = v75;
    }
    *(_DWORD *)(v71 + 120) = 2;
  }
LABEL_62:
  uint64_t v78 = *(void *)(a3 + 88);
  if (v78)
  {
    uint64_t v79 = *(void *)(a3 + 104);
    uint64_t v80 = 112 * v78;
    do
    {
      uint64_t result = re::addPhysicsFromImportContext(v5, a2, v79);
      v79 += 112;
      v80 -= 112;
    }
    while (v80);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 5) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 5)) + 8 * (a2 & 0x1F);
}

uint64_t re::BucketArray<re::TimelineGroupBuilder *,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::TimelineGroupBuilder *,8ul>::setBucketsCapacity((void *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 7);
}

void *re::BucketArray<re::TimelineGroupBuilder *,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 64, 0);
          unint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_22:
          id v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            id v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::TimelineGroupBuilder *,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

__n128 re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 8);
  if (v4 + 1 > 8 * v5)
  {
    re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::setBucketsCapacity((void *)a1, (v4 + 8) >> 3);
    unint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5 <= v4 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v6 + 8 * (v4 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  int v8 = (_OWORD *)(v7 + 80 * (v4 & 7));
  long long v9 = *(_OWORD *)(a2 + 64);
  long long v11 = *(_OWORD *)(a2 + 16);
  long long v10 = *(_OWORD *)(a2 + 32);
  void v8[3] = *(_OWORD *)(a2 + 48);
  unsigned char v8[4] = v9;
  v8[1] = v11;
  void v8[2] = v10;
  __n128 result = *(__n128 *)a2;
  *int v8 = *(_OWORD *)a2;
  return result;
}

void re::anonymous namespace'::wireupPrimitiveShapeHelper(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v161 = *MEMORY[0x263EF8340];
  switch(a3->i8[0])
  {
    case 0:
      unint64_t v139 = 0;
      uint64_t v138 = 0;
      uint64_t v140 = "";
      char v141 = 1;
      uint64_t v144 = 0;
      float32x4_t v142 = 0;
      uint64_t v143 = 0;
      int v145 = 0;
      uint64_t v149 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      int v148 = 0;
      re::StringID::destroyString((re::StringID *)&v139);
      uint64_t v140 = "PrimitiveShape";
      unint64_t v139 = 0xD2B975F2D13A2E34;
      if (!v142)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v142, 0);
        ++v145;
      }
      int v8 = a3 + 2;
      long long v9 = &a3->i8[4];
      long long v10 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                                     + 7)
                                                                                  + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 144, 0);
      re::make::shared::inplace<re::ecs2::PrimitiveBoxComponent>(v10, &v100);
      unint64_t v11 = v100;
      unint64_t v12 = *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
            + 3) >> 1;
      unint64_t v100 = 0;
      v98.n128_u64[0] = v12;
      v98.n128_u64[1] = v11;
      char v99 = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v142, &v98);
      if (v100) {

      }
      long long v13 = *(_OWORD *)v9;
      *(_OWORD *)(v11 + 39) = *(_OWORD *)(v9 + 11);
      *(_OWORD *)(v11 + 28) = v13;
      *(unsigned char *)(v11 + 5re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = *(unsigned char *)(a2 + 161);
      unint64_t v14 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v138);
      if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*v8, (float32x4_t)xmmword_23435FBB0))) & 0x80000000) != 0) {
        *((float32x4_t *)v14 + 3) = *v8;
      }
      uint64_t v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      long long v129 = 0u;
      long long v130 = 0u;
      int v128 = 0;
      int v131 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      int v134 = 0;
      long long v135 = 0u;
      memset(v136, 0, sizeof(v136));
      uint64_t v137 = 0x7FFFFFFFLL;
      re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v112);
      re::GeomModel::GeomModel((re::GeomModel *)&v100);
      re::GeomMesh::GeomMesh((re::GeomMesh *)&v98, 0);
      re::internal::buildBoxHelper((re::internal *)&v98, &v150, (unsigned __int16 *)v9);
      re::DynamicArray<re::GeomMesh>::add((uint64_t)v102, (uint64_t)&v98);
      re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v114, (uint64_t)&v100);
      re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)&v125, (uint64_t)&v112);
      long long v150 = xmmword_23435FD50;
      long long v151 = xmmword_23435FD60;
      *(_OWORD *)int v152 = xmmword_23435FD80;
      *(_OWORD *)&v152[16] = xmmword_23435FBB0;
      *(_DWORD *)&v152[32] = 0;
      re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v129 + 8), (uint64_t)&v150);
      int v87 = 16842752;
      char v88 = 1;
      int v89 = 0;
      char v90 = 0;
      int v92 = 1036831949;
      int v93 = 16843008;
      char v94 = 0;
      long long v97 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      DWORD1(v9re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0x7FFFFFFF;
      char v91 = *(unsigned char *)(a2 + 161);
      re::makeMeshAssetDataFromGeomScene(&v125, (uint64_t)&v87, (uint64_t)&v150);
      unint64_t v16 = re::globalAllocators(v15);
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16[2] + 32))(v16[2], 960, 8);
      uint64_t v18 = (_DWORD *)v17;
      if ((_BYTE)v150)
      {
        *(void *)&v80[0] = *((void *)&v150 + 1);
        *((void *)&v150 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        *(_OWORD *)((char *)v80 + 8) = v151;
        long long v151 = 0u;
        DWORD2(v80[1]) = 1;
        long long v19 = *(_OWORD *)&v152[8];
        memset(&v152[8], 0, 32);
        long long v81 = v19;
        long long v82 = *(_OWORD *)&v152[24];
        ++*(_DWORD *)v152;
        ++v153;
        LODWORD(v83[0]) = 1;
        *(_OWORD *)((char *)v83 + 8) = v154;
        *(_OWORD *)((char *)&v83[1] + 8) = v155;
        long long v154 = 0u;
        long long v155 = 0u;
        DWORD2(v83[2]) = 1;
        long long v20 = v157;
        long long v157 = 0u;
        long long v84 = v20;
        long long v85 = v158;
        long long v158 = 0u;
        *((void *)&v86 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v160;
        uint64_t v160 = 0;
        ++v156;
        ++v159;
        LODWORD(v86) = 1;
      }
      else
      {
        long long v85 = 0u;
        long long v86 = 0u;
        long long v84 = 0u;
        memset(v83, 0, sizeof(v83));
        long long v81 = 0u;
        long long v82 = 0u;
        memset(v80, 0, sizeof(v80));
      }
      re::MeshAsset::MeshAsset(v17, (uint64_t)v80);
      if (*((void *)&v84 + 1))
      {
        if (*((void *)&v86 + 1)) {
          (*(void (**)(void))(**((void **)&v84 + 1) + 40))();
        }
        *((void *)&v86 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        long long v85 = 0uLL;
        *((void *)&v84 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        LODWORD(v86) = v86 + 1;
      }
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v83[1]);
      re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v81 + 8);
      re::DynamicArray<re::MeshAssetModel>::deinit(v80);
      v18[231] = 1;
      uint64_t v70 = *(const char **)(a4 + 8);
      unint64_t v71 = *(_anonymous_namespace_ **)(a2 + 104);
      long long v72 = (re::MeshAsset *)strlen(v70);
      unint64_t v61 = re::MeshAsset::assetType(v72);
      unint64_t v62 = v71;
      uint64_t v63 = (uint64_t)v70;
      uint64_t v64 = (uint64_t)v72;
      goto LABEL_48;
    case 1:
      unint64_t v139 = 0;
      uint64_t v138 = 0;
      uint64_t v140 = "";
      char v141 = 1;
      uint64_t v144 = 0;
      float32x4_t v142 = 0;
      uint64_t v143 = 0;
      int v145 = 0;
      uint64_t v149 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      int v148 = 0;
      re::StringID::destroyString((re::StringID *)&v139);
      uint64_t v140 = "PrimitiveShape";
      unint64_t v139 = 0xD2B975F2D13A2E34;
      if (!v142)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v142, 0);
        ++v145;
      }
      int v22 = a3 + 2;
      uint64_t v23 = &a3->u16[2];
      uint64_t v24 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                  + 7)
                                                               + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 120, 0);
      re::make::shared::inplace<re::ecs2::PrimitiveConeComponent>(v24, &v100);
      unint64_t v25 = v100;
      unint64_t v26 = *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
            + 3) >> 1;
      unint64_t v100 = 0;
      v98.n128_u64[0] = v26;
      v98.n128_u64[1] = v25;
      char v99 = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v142, &v98);
      if (v100) {

      }
      *(_OWORD *)(v25 + 28) = *(_OWORD *)v23;
      *(unsigned char *)(v25 + 45) = *(unsigned char *)(a2 + 161);
      uint64_t v27 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v138);
      long long v73 = xmmword_23435FBB0;
      if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*v22, (float32x4_t)xmmword_23435FBB0))) & 0x80000000) != 0) {
        *((float32x4_t *)v27 + 3) = *v22;
      }
      uint64_t v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      long long v129 = 0u;
      long long v130 = 0u;
      int v128 = 0;
      int v131 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      int v134 = 0;
      long long v135 = 0u;
      memset(v136, 0, sizeof(v136));
      uint64_t v137 = 0x7FFFFFFFLL;
      re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v112);
      re::GeomModel::GeomModel((re::GeomModel *)&v100);
      re::GeomMesh::GeomMesh((re::GeomMesh *)&v98, 0);
      re::buildCone((uint64_t)&v98, v23);
      goto LABEL_31;
    case 2:
      unint64_t v139 = 0;
      uint64_t v138 = 0;
      uint64_t v140 = "";
      char v141 = 1;
      uint64_t v144 = 0;
      float32x4_t v142 = 0;
      uint64_t v143 = 0;
      int v145 = 0;
      uint64_t v149 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      int v148 = 0;
      re::StringID::destroyString((re::StringID *)&v139);
      uint64_t v140 = "PrimitiveShape";
      unint64_t v139 = 0xD2B975F2D13A2E34;
      if (!v142)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v142, 0);
        ++v145;
      }
      uint64_t v29 = a3 + 2;
      unint64_t v30 = &a3->i8[4];
      uint64_t v31 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                  + 7)
                                                               + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 136, 0);
      re::make::shared::inplace<re::ecs2::PrimitiveCylinderComponent>(v31, &v100);
      unint64_t v32 = v100;
      unint64_t v33 = *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
            + 3) >> 1;
      unint64_t v100 = 0;
      v98.n128_u64[0] = v33;
      v98.n128_u64[1] = v32;
      char v99 = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v142, &v98);
      if (v100) {

      }
      long long v34 = *(_OWORD *)v30;
      *(void *)(v32 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(void *)(v30 + 13);
      *(_OWORD *)(v32 + 28) = v34;
      *(unsigned char *)(v32 + 53) = *(unsigned char *)(a2 + 161);
      float32x4_t v35 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v138);
      long long v74 = xmmword_23435FBB0;
      if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*v29, (float32x4_t)xmmword_23435FBB0))) & 0x80000000) != 0) {
        *((float32x4_t *)v35 + 3) = *v29;
      }
      uint64_t v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      long long v129 = 0u;
      long long v130 = 0u;
      int v128 = 0;
      int v131 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      int v134 = 0;
      long long v135 = 0u;
      memset(v136, 0, sizeof(v136));
      uint64_t v137 = 0x7FFFFFFFLL;
      re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v112);
      re::GeomModel::GeomModel((re::GeomModel *)&v100);
      re::GeomMesh::GeomMesh((re::GeomMesh *)&v98, 0);
      re::buildCylinder((uint64_t)&v98, (unsigned __int16 *)v30);
      goto LABEL_40;
    case 3:
      unint64_t v139 = 0;
      uint64_t v138 = 0;
      uint64_t v140 = "";
      char v141 = 1;
      uint64_t v144 = 0;
      float32x4_t v142 = 0;
      uint64_t v143 = 0;
      int v145 = 0;
      uint64_t v149 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      int v148 = 0;
      re::StringID::destroyString((re::StringID *)&v139);
      uint64_t v140 = "PrimitiveShape";
      unint64_t v139 = 0xD2B975F2D13A2E34;
      if (!v142)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v142, 0);
        ++v145;
      }
      id v37 = a3 + 2;
      unint64_t v38 = &a3->i8[4];
      uint64_t v39 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                                     + 7)
                                                                                  + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 112, 0);
      re::make::shared::inplace<re::ecs2::PrimitiveSphereComponent>(v39, &v100);
      unint64_t v40 = v100;
      unint64_t v41 = *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
            + 3) >> 1;
      unint64_t v100 = 0;
      v98.n128_u64[0] = v41;
      v98.n128_u64[1] = v40;
      char v99 = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v142, &v98);
      if (v100) {

      }
      uint64_t v42 = *(void *)v38;
      *(_DWORD *)(v40 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 35) = *(_DWORD *)(v38 + 7);
      *(void *)(v40 + 28) = v42;
      *(unsigned char *)(v40 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(unsigned char *)(a2 + 161);
      unint64_t v43 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v138);
      long long v73 = xmmword_23435FBB0;
      if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*v37, (float32x4_t)xmmword_23435FBB0))) & 0x80000000) != 0) {
        *((float32x4_t *)v43 + 3) = *v37;
      }
      uint64_t v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      long long v129 = 0u;
      long long v130 = 0u;
      int v128 = 0;
      int v131 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      int v134 = 0;
      long long v135 = 0u;
      memset(v136, 0, sizeof(v136));
      uint64_t v137 = 0x7FFFFFFFLL;
      re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v112);
      re::GeomModel::GeomModel((re::GeomModel *)&v100);
      re::GeomMesh::GeomMesh((re::GeomMesh *)&v98, 0);
      re::buildSphere((uint64_t)&v98, (unsigned __int16 *)v38);
LABEL_31:
      re::DynamicArray<re::GeomMesh>::add((uint64_t)v102, (uint64_t)&v98);
      re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v114, (uint64_t)&v100);
      re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)&v125, (uint64_t)&v112);
      long long v150 = xmmword_23435FD50;
      long long v151 = xmmword_23435FD60;
      *(_OWORD *)int v152 = xmmword_23435FD80;
      *(_OWORD *)&v152[16] = v73;
      *(_DWORD *)&v152[32] = 0;
      re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v129 + 8), (uint64_t)&v150);
      int v87 = 16842752;
      char v88 = 1;
      int v89 = 0;
      char v90 = 0;
      int v92 = 1036831949;
      int v93 = 16843008;
      char v94 = 0;
      long long v97 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      DWORD1(v9re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0x7FFFFFFF;
      char v91 = *(unsigned char *)(a2 + 161);
      re::makeMeshAssetDataFromGeomScene(&v125, (uint64_t)&v87, (uint64_t)&v150);
      unint64_t v45 = re::globalAllocators(v44);
      uint64_t v18 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v45[2] + 32))(v45[2], 960, 8);
      if ((_BYTE)v150) {
        goto LABEL_41;
      }
      goto LABEL_42;
    case 4:
      unint64_t v139 = 0;
      uint64_t v138 = 0;
      uint64_t v140 = "";
      char v141 = 1;
      uint64_t v144 = 0;
      float32x4_t v142 = 0;
      uint64_t v143 = 0;
      int v145 = 0;
      uint64_t v149 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      int v148 = 0;
      re::StringID::destroyString((re::StringID *)&v139);
      uint64_t v140 = "PrimitiveShape";
      unint64_t v139 = 0xD2B975F2D13A2E34;
      if (!v142)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v142, 0);
        ++v145;
      }
      unint64_t v47 = a3 + 2;
      uint64_t v48 = &a3->i8[4];
      uint64_t v49 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                                     + 7)
                                                                                  + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 128, 0);
      re::make::shared::inplace<re::ecs2::PrimitiveCapsuleComponent>(v49, &v100);
      unint64_t v50 = v100;
      unint64_t v51 = *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
            + 3) >> 1;
      unint64_t v100 = 0;
      v98.n128_u64[0] = v51;
      v98.n128_u64[1] = v50;
      char v99 = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)&v142, &v98);
      if (v100) {

      }
      long long v52 = *(_OWORD *)v48;
      *(_DWORD *)(v50 + 43) = *(_DWORD *)(v48 + 15);
      *(_OWORD *)(v50 + 28) = v52;
      *(unsigned char *)(v50 + 49) = *(unsigned char *)(a2 + 161);
      uint64_t v53 = re::ecs2::EntityAssetData::addComponent<re::ecs2::TransformComponent>(&v138);
      long long v74 = xmmword_23435FBB0;
      if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*v47, (float32x4_t)xmmword_23435FBB0))) & 0x80000000) != 0) {
        *((float32x4_t *)v53 + 3) = *v47;
      }
      uint64_t v126 = 0;
      uint64_t v125 = 0;
      uint64_t v127 = 0;
      long long v129 = 0u;
      long long v130 = 0u;
      int v128 = 0;
      int v131 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      int v134 = 0;
      long long v135 = 0u;
      memset(v136, 0, sizeof(v136));
      uint64_t v137 = 0x7FFFFFFFLL;
      re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v112);
      re::GeomModel::GeomModel((re::GeomModel *)&v100);
      re::GeomMesh::GeomMesh((re::GeomMesh *)&v98, 0);
      re::buildCapsule((uint64_t)&v98, (unsigned __int16 *)v48);
LABEL_40:
      re::DynamicArray<re::GeomMesh>::add((uint64_t)v102, (uint64_t)&v98);
      re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v114, (uint64_t)&v100);
      re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)&v125, (uint64_t)&v112);
      long long v150 = xmmword_23435FD50;
      long long v151 = xmmword_23435FD60;
      *(_OWORD *)int v152 = xmmword_23435FD80;
      *(_OWORD *)&v152[16] = v74;
      *(_DWORD *)&v152[32] = 0;
      re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v129 + 8), (uint64_t)&v150);
      int v87 = 16842752;
      char v88 = 1;
      int v89 = 0;
      char v90 = 0;
      int v92 = 1036831949;
      int v93 = 16843008;
      char v94 = 0;
      long long v97 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      DWORD1(v9re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0x7FFFFFFF;
      char v91 = *(unsigned char *)(a2 + 161);
      re::makeMeshAssetDataFromGeomScene(&v125, (uint64_t)&v87, (uint64_t)&v150);
      unint64_t v55 = re::globalAllocators(v54);
      uint64_t v18 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v55[2] + 32))(v55[2], 960, 8);
      if ((_BYTE)v150)
      {
LABEL_41:
        *(void *)&v80[0] = *((void *)&v150 + 1);
        *((void *)&v150 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        *(_OWORD *)((char *)v80 + 8) = v151;
        long long v151 = 0u;
        DWORD2(v80[1]) = 1;
        long long v56 = *(_OWORD *)&v152[8];
        memset(&v152[8], 0, 32);
        long long v81 = v56;
        long long v82 = *(_OWORD *)&v152[24];
        ++*(_DWORD *)v152;
        ++v153;
        LODWORD(v83[0]) = 1;
        *(_OWORD *)((char *)v83 + 8) = v154;
        *(_OWORD *)((char *)&v83[1] + 8) = v155;
        long long v154 = 0u;
        long long v155 = 0u;
        DWORD2(v83[2]) = 1;
        long long v57 = v157;
        long long v157 = 0u;
        long long v84 = v57;
        long long v85 = v158;
        long long v158 = 0u;
        *((void *)&v86 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v160;
        uint64_t v160 = 0;
        ++v156;
        ++v159;
        LODWORD(v86) = 1;
      }
      else
      {
LABEL_42:
        long long v85 = 0u;
        long long v86 = 0u;
        long long v84 = 0u;
        memset(v83, 0, sizeof(v83));
        long long v81 = 0u;
        long long v82 = 0u;
        memset(v80, 0, sizeof(v80));
      }
      re::MeshAsset::MeshAsset((uint64_t)v18, (uint64_t)v80);
      if (*((void *)&v84 + 1))
      {
        if (*((void *)&v86 + 1)) {
          (*(void (**)(void))(**((void **)&v84 + 1) + 40))();
        }
        *((void *)&v86 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        long long v85 = 0uLL;
        *((void *)&v84 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        LODWORD(v86) = v86 + 1;
      }
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v83[1]);
      re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v81 + 8);
      re::DynamicArray<re::MeshAssetModel>::deinit(v80);
      v18[231] = 1;
      uint64_t v58 = *(const char **)(a4 + 8);
      uint32x2_t v59 = *(_anonymous_namespace_ **)(a2 + 104);
      long long v60 = (re::MeshAsset *)strlen(v58);
      unint64_t v61 = re::MeshAsset::assetType(v60);
      unint64_t v62 = v59;
      uint64_t v63 = (uint64_t)v58;
      uint64_t v64 = (uint64_t)v60;
LABEL_48:
      uint64_t v65 = re::ImportAssetTable::addAsset(v62, v63, v64, v18, (re **)v61);
      memset(v79, 0, sizeof(v79));
      if (*(unsigned char *)(v65 + 8)) {
        float v66 = *(re::AssetPath **)(v65 + 16);
      }
      else {
        float v66 = (re::AssetPath *)(v65 + 9);
      }
      re::AssetHandle::setSerializationString((re::DynamicString *)v79, v66, *(re::Allocator **)a2);
      uint64_t v67 = re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshComponent>(&v138);
      re::AssetHandle::operator=((uint64_t)(v67 + 4), v79);
      if (*(void *)(a5 + 16))
      {
        memset(v78, 0, sizeof(v78));
        uint64_t v68 = re::AssetHandle::serializationString(*(re::AssetHandle **)(a5 + 32), (re::DynamicString *)v80);
        if (BYTE8(v80[0])) {
          uint64_t v69 = *(re::AssetPath **)&v80[1];
        }
        else {
          uint64_t v69 = (re::AssetPath *)((char *)v80 + 9);
        }
        if (*(void *)&v80[0] && (BYTE8(v80[0]) & 1) != 0) {
          (*(void (**)(void))(**(void **)&v80[0] + 40))();
        }
        re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)(v67 + 7), (re::AssetHandle *)v78);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v78);
      }
      re::DynamicArray<re::ecs2::EntityAssetData>::add(a1 + 72, (uint64_t)&v138);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v79);
      re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v150);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v95);
      re::GeomMesh::~GeomMesh((re::GeomMesh *)&v98);
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)&v111);
      if (v109[40]) {
        re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v110);
      }
      if (v108) {
        re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v109);
      }
      if (v103)
      {
        if (v107) {
          (*(void (**)(void))(*(void *)v103 + 40))();
        }
        uint64_t v107 = 0;
        uint64_t v104 = 0;
        uint64_t v105 = 0;
        uint64_t v103 = 0;
        ++v106;
      }
      re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v102);
      if (v100 && (v101 & 1) != 0) {
        (*(void (**)(void))(*(void *)v100 + 40))();
      }
      if (v120)
      {
        if (v124) {
          (*(void (**)(void))(*(void *)v120 + 40))();
        }
        uint64_t v124 = 0;
        uint64_t v121 = 0;
        uint64_t v122 = 0;
        uint64_t v120 = 0;
        ++v123;
      }
      if (v115)
      {
        if (v119) {
          (*(void (**)(void))(*(void *)v115 + 40))();
        }
        uint64_t v119 = 0;
        uint64_t v116 = 0;
        uint64_t v117 = 0;
        uint64_t v115 = 0;
        ++v118;
      }
      re::DynamicArray<re::GeomModel>::deinit((uint64_t)v114);
      if (v112 && (v113 & 1) != 0) {
        (*(void (**)(void))(*(void *)v112 + 40))();
      }
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v135 + 1);
      re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v132 + 8);
      if (*((void *)&v129 + 1))
      {
        if ((void)v132) {
          (*(void (**)(void))(**((void **)&v129 + 1) + 40))();
        }
        *(void *)&long long v132 = 0;
        long long v130 = 0uLL;
        *((void *)&v129 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        ++v131;
      }
      re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)&v125);
      re::ecs2::EntityAssetData::~EntityAssetData((re::ecs2::EntityAssetData *)&v138);
      break;
    default:
      return;
  }
}

double re::DynamicArray<re::ModelWithLodsDescriptor>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::ModelWithLodsDescriptor>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 152 * v4;
  double result = 0.0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  uint64_t v10 = *(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v7;
  *(void *)(v5 + 16) = v8;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 16) = v9;
  *(void *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_DWORD *)(v5 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v11;
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v12 = *(void *)(v5 + 48);
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v12;
  uint64_t v13 = *(void *)(v5 + 64);
  *(void *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(a2 + 64);
  *(void *)(a2 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v13;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(void *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v5 + 80) = 0;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  uint64_t v14 = *(void *)(a2 + 80);
  *(void *)(v5 + 72) = *(void *)(a2 + 72);
  *(void *)(v5 + 80) = v14;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v15 = *(void *)(v5 + 88);
  *(void *)(v5 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v15;
  uint64_t v16 = *(void *)(v5 + 104);
  *(void *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(a2 + 104);
  *(void *)(a2 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v16;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  *(void *)(v5 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v5 + 120) = 0;
  *(void *)(v5 + 128) = 0;
  *(void *)(v5 + 112) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  uint64_t v17 = *(void *)(a2 + 120);
  *(void *)(v5 + 112) = *(void *)(a2 + 112);
  *(void *)(v5 + 120) = v17;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  uint64_t v18 = *(void *)(v5 + 128);
  *(void *)(v5 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v18;
  uint64_t v19 = *(void *)(v5 + 144);
  *(void *)(v5 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(a2 + 144);
  *(void *)(a2 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v19;
  ++*(_DWORD *)(a2 + 136);
  ++*(_DWORD *)(v5 + 136);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(void *this, void *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *a2;
  *a2 = 0;
  void v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t *re::DynamicArray<re::anonymous namespace'::SkeletonAndAnimationInfoPerLodLevel>::~DynamicArray(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (v3)
    {
      uint64_t v4 = a1[2];
      if (v4)
      {
        uint64_t v5 = 72 * v4;
        uint64_t v6 = v3 + 24;
        do
        {
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 + 24));
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v6);
          v6 += 72;
          v5 -= 72;
        }
        while (v5);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[4];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetModel>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + (a3 << 9);
}

uint64_t re::BucketArray<re::FixedArray<unsigned short>,16ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 4) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 4)) + 24 * (a2 & 0xF);
}

uint64_t *re::anonymous namespace'::wireupDeformers(re *a1, uint64_t *a2, uint64_t a3, void *a4, uint64_t a5, const char *a6)
{
  unint64_t v9 = (unint64_t)buf;
  v351[4] = *MEMORY[0x263EF8340];
  uint64_t v10 = re::globalAllocators(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 80, 8);
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_OWORD *)(v11 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  buf[0].n128_u64[0] = (unint64_t)&unk_26E6DF8A8;
  buf[1].n128_u64[1] = (unint64_t)buf;
  v351[3] = v351;
  long long v350 = (re::MeshDeformationAsset *)v11;
  v351[0] = &unk_26E6DF8A8;
  uint64_t v12 = (_anonymous_namespace_ *)std::__function::__value_func<void ()(re::MeshDeformationAsset *)>::~__value_func[abi:nn180100](buf);
  uint64_t v13 = v350;
  int v311 = 0;
  long long v309 = 0u;
  long long v310 = 0u;
  uint64_t v312 = 0x7FFFFFFFLL;
  float v279 = a4;
  if (!a4[7]) {
    goto LABEL_467;
  }
  int v270 = a6;
  unint64_t v15 = 0;
  int v16 = 0;
  uint64_t v17 = v344;
  uint64_t v267 = a5;
  uint64_t v268 = a5 + 24;
  uint64_t v18 = a1;
  float v281 = (re *)((char *)a1 + 32);
  while (1)
  {
    uint64_t v19 = a4[9] + 96 * v15;
    unint64_t v20 = *(unsigned int *)(v19 + 80);
    float v280 = (unsigned int *)(v19 + 80);
    unint64_t v21 = *(void *)(a5 + 40);
    if (v21 <= v20) {
      goto LABEL_495;
    }
    unint64_t v9 = v20 >> 3;
    a6 = *(const char **)(a5 + 8);
    if ((unint64_t)a6 <= v20 >> 3) {
      goto LABEL_496;
    }
    int v269 = v16;
    unint64_t v273 = v15;
    uint64_t v22 = *(void *)(a5 + 32);
    if (*(unsigned char *)(a5 + 16)) {
      uint64_t v22 = v268;
    }
    uint64_t v272 = *(void *)(v22 + 8 * v9) + 40 * (v20 & 7);
    if (*(void *)(v272 + 16))
    {
      unint64_t v9 = a4[2];
      if (v9 <= v20) {
        goto LABEL_501;
      }
      uint64_t v23 = a4[4] + (v20 << 9);
      if (*(void *)(v23 + 208)) {
        break;
      }
    }
LABEL_435:
    unint64_t v15 = (v269 + 1);
    int v16 = v269 + 1;
    a5 = v267;
    if (a4[7] <= v15)
    {
      if (HIDWORD(v310))
      {
        LODWORD(v14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v311;
        if (!v311) {
          goto LABEL_445;
        }
        uint64_t v212 = 0;
        uint64_t v213 = (int *)(v310 + 8);
        while (1)
        {
          int v214 = *v213;
          v213 += 14;
          if (v214 < 0) {
            goto LABEL_446;
          }
          if (v311 == ++v212)
          {
            LODWORD(v212) = v311;
            goto LABEL_446;
          }
        }
      }
      goto LABEL_467;
    }
  }
  unint64_t v24 = 0;
  unsigned int v278 = 0;
  while (1)
  {
    unint64_t v276 = v24;
    uint64_t v308 = 0;
    unint64_t v306 = 0;
    uint64_t v304 = 0;
    unint64_t v305 = 0;
    int v307 = 0;
    uint64_t v25 = *(void *)(v272 + 16);
    if (v25) {
      break;
    }
LABEL_431:
    re::DynamicArray<re::DeformationStackDefinition>::add(v350, (uint64_t)&v304);
    uint64_t v208 = v350;
    v313[0] = 1;
    unint64_t v20 = a4[7];
    uint64_t v209 = (__n128 *)v273;
    if (v20 <= v273) {
      goto LABEL_490;
    }
    re::StringID::StringID((re::StringID *)&v313[8], (const StringID *)(a4[9] + 96 * v273));
    unint64_t v20 = *v280;
    unint64_t v9 = a4[2];
    if (v9 <= v20) {
      goto LABEL_491;
    }
    unint64_t v210 = a4[4] + (v20 << 9);
    unint64_t v20 = *(void *)(v210 + 208);
    float64x2_t v211 = (__n128 *)v276;
    if (v20 <= v276) {
      goto LABEL_492;
    }
    re::StringID::StringID((re::StringID *)&v313[24], (const StringID *)(*(void *)(v210 + 224) + (v276 << 8) + 72));
    *(void *)&v313[40] = *((void *)v350 + 2) - 1;
    re::DynamicArray<re::MeshDeformationIndex>::add((void *)v208 + 5, (uint64_t)v313);
    re::StringID::destroyString((re::StringID *)&v313[24]);
    re::StringID::destroyString((re::StringID *)&v313[8]);
    re::DynamicArray<re::DeformationDefinition>::deinit((uint64_t)&v304);
    unint64_t v24 = ++v278;
    if (*(void *)(v23 + 208) <= (unint64_t)v278) {
      goto LABEL_435;
    }
  }
  unint64_t v20 = *(void *)(v272 + 32);
  unint64_t v282 = v20 + 448 * v25;
  while (1)
  {
    unint64_t v26 = *(const char **)(v20 + 24);
    uint64_t v27 = (_anonymous_namespace_ *)strcmp(v26, "BlendShape");
    if (!v27)
    {
LABEL_19:
      *(_DWORD *)uint64_t v344 = 0;
      buf[0].n128_u64[0] = 0x1954B86F1FEF5A4;
      buf[0].n128_u64[1] = (unint64_t)"Blend Shape";
      *(void *)uint64_t v313 = v344;
      *(void *)&v313[8] = 4;
      *(void *)&long long v329 = 0;
      buf[1] = 0uLL;
      re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
      re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
      if (buf[1].n128_u64[0])
      {
        if (buf[1].n128_u64[1])
        {
          (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
          buf[1].n128_u64[1] = 0;
          *(void *)&long long v329 = 0;
        }
        buf[1].n128_u64[0] = 0;
      }
      re::StringID::destroyString((re::StringID *)buf);
      if (!*(void *)v281) {
        goto LABEL_50;
      }
      uint64_t v30 = *((void *)v18 + 6);
      if (!v30) {
        goto LABEL_50;
      }
      uint64_t v31 = (void *)(*((void *)v18 + 8) + 8);
      uint64_t v32 = 24 * v30;
      while (*(v31 - 1) != *((void *)re::ecs2::ComponentImpl<re::ecs2::BlendShapeWeightsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                            + 3) >> 1)
      {
        v31 += 3;
        v32 -= 24;
        if (!v32) {
          goto LABEL_50;
        }
      }
      if (!*v31) {
LABEL_50:
      }
        re::ecs2::EntityAssetData::addComponent<re::ecs2::BlendShapeWeightsComponent>(v18);
      goto LABEL_251;
    }
    a6 = (const char *)(v20 + 16);
    uint64_t v28 = *(void *)(v20 + 16) >> 1;
    if (v28 == 0xCAA5C378FF7AD2)
    {
      if (v26 == "Blend Shape") {
        goto LABEL_19;
      }
      uint64_t v27 = (_anonymous_namespace_ *)strcmp(v26, "Blend Shape");
      if (!v27) {
        goto LABEL_19;
      }
      uint64_t v29 = (_anonymous_namespace_ *)strcmp(v26, "Skinning");
      if (!v29)
      {
LABEL_34:
        *(_WORD *)uint64_t v344 = 0;
        uint64_t v34 = *(void *)(v20 + 48);
        a6 = "deformUserTangentsAndNormals";
        if (v34)
        {
          uint64_t v35 = *(void *)(v20 + 64);
          uint64_t v36 = 40 * v34;
          do
          {
            uint64_t v29 = (_anonymous_namespace_ *)strcmp(*(const char **)(v35 + 16), "deformUserTangentsAndNormals");
            if (!v29)
            {
              if (*(_DWORD *)(v35 + 24) == 1) {
                v344[1] = *(_DWORD *)(v35 + 32) != 0;
              }
              else {
            }
              }
            v35 += 40;
            v36 -= 40;
          }
          while (v36);
        }
        buf[0].n128_u64[0] = 0x4550755B7A2;
        buf[0].n128_u64[1] = (unint64_t)"Skinning";
        *(void *)uint64_t v313 = v344;
        *(void *)&v313[8] = 2;
        *(void *)&long long v329 = 0;
        buf[1] = 0uLL;
        re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
        re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
        if (buf[1].n128_u64[0])
        {
          if (buf[1].n128_u64[1])
          {
            (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
            buf[1].n128_u64[1] = 0;
            *(void *)&long long v329 = 0;
          }
          buf[1].n128_u64[0] = 0;
        }
        re::StringID::destroyString((re::StringID *)buf);
        if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::SkeletalPoseComponent>(v18)) {
          re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>(v18);
        }
        if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::RigComponent>(v18)) {
          re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>(v18);
        }
        goto LABEL_251;
      }
LABEL_32:
      unint64_t v33 = (_anonymous_namespace_ *)strcmp(v26, "SmoothDeformer");
      if (!v33) {
        goto LABEL_61;
      }
      goto LABEL_56;
    }
    uint64_t v29 = (_anonymous_namespace_ *)strcmp(v26, "Skinning");
    if (!v29) {
      goto LABEL_34;
    }
    if (v28 == 0x22A83AADBD1)
    {
      if (v26 == "Skinning") {
        goto LABEL_34;
      }
      goto LABEL_32;
    }
    unint64_t v33 = (_anonymous_namespace_ *)strcmp(v26, "SmoothDeformer");
    if (!v33) {
      goto LABEL_61;
    }
    if (v28 == 0x2D6F1CB4C5FBF820)
    {
      if (v26 == "SmoothDeformer")
      {
LABEL_61:
        v293[0] = 0;
        buf[0].n128_u64[0] = 0x5ADE39698BF7F040;
        buf[0].n128_u64[1] = (unint64_t)"SmoothDeformer";
        *(void *)uint64_t v313 = v293;
        *(void *)&v313[8] = 1;
        *(void *)&long long v329 = 0;
        buf[1] = 0uLL;
        re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
        re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
        if (buf[1].n128_u64[0])
        {
          if (buf[1].n128_u64[1])
          {
            (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
            buf[1].n128_u64[1] = 0;
            *(void *)&long long v329 = 0;
          }
          buf[1].n128_u64[0] = 0;
        }
        re::StringID::destroyString((re::StringID *)buf);
        if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshSmoothComponent>(v18))
        {
          if (!*(void *)v281)
          {
            re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v281, 0);
            ++*((_DWORD *)v18 + 14);
          }
          uint64_t v39 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                      + 7)
                                                                   + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 336, 0);
          double v40 = re::make::shared::inplace<re::ecs2::MeshSmoothComponent>(v39, v313);
          unint64_t v41 = *(void *)((*(uint64_t (**)(void, double))(**(void **)v313 + 40))(*(void *)v313, v40)
                          + 24) >> 1;
          unint64_t v42 = *(void *)v313;
          *(void *)uint64_t v313 = 0;
          buf[0].n128_u64[0] = v41;
          buf[0].n128_u64[1] = v42;
          buf[1].n128_u8[0] = 1;
          re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v281, buf);
          if (*(void *)v313) {

          }
          v344[0] = 11;
          unint64_t v44 = re::globalAllocators(v43);
          uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v44[2] + 32))(v44[2], 40, 8);
          *(_OWORD *)uint64_t v45 = 0u;
          *(_OWORD *)(v45 + 16) = 0u;
          *(void *)(v45 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
          *(void *)uint64_t v313 = &unk_26E6DF938;
          *(void *)&v313[24] = v313;
          buf[0].n128_u64[0] = v45;
          *(void *)&long long v329 = &buf[0].n128_u64[1];
          buf[0].n128_u64[1] = (unint64_t)&unk_26E6DF938;
          re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::add((uint64_t)&v309, v344, (uint64_t *)buf);
          std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>::~unique_ptr[abi:nn180100]((uint64_t *)buf);
          std::__function::__value_func<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__value_func[abi:nn180100](v313);
        }
        *(void *)&v299.var0 = 0;
        v299.uint64_t var1 = "";
        LOWORD(v300) = v278;
        uint64_t v46 = *(void *)(v20 + 48);
        if (v46)
        {
          uint64_t v47 = *(void *)(v20 + 64);
          uint64_t v48 = re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshSmoothComponent>(a1);
          uint64_t v49 = (void *)(v48 + 32);
          unint64_t v50 = (_anonymous_namespace_ *)(v48 + 72);
          for (uint64_t i = 40 * v46; i; i -= 40)
          {
            long long v52 = *(const char **)(v47 + 16);
            if (!strcmp(v52, "lambda"))
            {
              if (*(_DWORD *)(v47 + 24))
              {
                buf[0].n128_u8[0] = 0;
                uint64_t v54 = v47;
                int v55 = 0;
LABEL_85:
                goto LABEL_90;
              }
              buf[0].n128_u32[1] = *(_DWORD *)(v47 + 32);
              buf[0].n128_u8[0] = 1;
              re::DynamicArray<float>::add(v50, &buf[0].n128_f32[1]);
            }
            else if (!strcmp(v52, "iterations"))
            {
              if (*(_DWORD *)(v47 + 24) != 1)
              {
                uint64_t v54 = v47;
                int v55 = 1;
                goto LABEL_85;
              }
              buf[0].n128_u32[0] = *(_DWORD *)(v47 + 32);
              re::DynamicArray<int>::add(v49, buf);
            }
            else if (!strcmp(v52, "envelopeVarName"))
            {
              if (*(_DWORD *)(v47 + 24) == 6)
              {
                uint64_t v53 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *(void *)(v47 + 32));
                buf[0].n128_u8[0] = 1;
                re::StringID::StringID((re::StringID *)&buf[0].n128_i8[8], v53);
                if (buf[0].n128_u8[0])
                {
                  re::StringID::operator=((unint64_t *)&v299, &buf[0].n128_i64[1]);
                  goto LABEL_88;
                }
              }
              else
              {
                buf[0].n128_u8[0] = 0;
              }
LABEL_88:
              if (buf[0].n128_u8[0]) {
                re::StringID::destroyString((re::StringID *)&buf[0].n128_i8[8]);
              }
            }
LABEL_90:
            v47 += 40;
          }
        }
        unint64_t v56 = *v280;
        a4 = v279;
        a6 = (const char *)v279[2];
        if ((unint64_t)a6 <= v56)
        {
          *(void *)uint64_t v344 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v313 = 136315906;
          *(void *)&v313[4] = "operator[]";
          *(_WORD *)&v313[12] = 1024;
          *(_DWORD *)&v313[14] = 789;
          *(_WORD *)&v313[18] = 2048;
          *(void *)&v313[20] = v56;
          *(_WORD *)&v313[28] = 2048;
          *(void *)&v313[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_487:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v262 = v59;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v262;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = v56;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_488:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v56;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_489:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v20 = v132;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v20;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = v56;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_490:
          *(void *)&v299.var0 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v9 = (unint64_t)v209;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v9;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = v20;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_491:
          *(void *)&v299.var0 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v20;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_492:
          *(void *)&v299.var0 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v9 = (unint64_t)v211;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v9;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = v20;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_493:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v313 = 136315906;
          *(void *)&v313[4] = "operator[]";
          *(_WORD *)&v313[12] = 1024;
          *(_DWORD *)&v313[14] = 789;
          *(_WORD *)&v313[18] = 2048;
          *(void *)&v313[20] = v9;
          *(_WORD *)&v313[28] = 2048;
          *(void *)&v313[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_494:
          *(void *)&v299.var0 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)&v344[4] = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)&v344[14] = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)&v344[20] = v9;
          *(_WORD *)&v344[28] = 2048;
          *(void *)&v344[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_495:
          re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, v20, v21);
          _os_crash();
          __break(1u);
LABEL_496:
          *(void *)uint64_t v344 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v313 = 136315906;
          *(void *)&v313[4] = "operator[]";
          *(_WORD *)&v313[12] = 1024;
          *(_DWORD *)&v313[14] = 866;
          *(_WORD *)&v313[18] = 2048;
          *(void *)&v313[20] = v9;
          *(_WORD *)&v313[28] = 2048;
          *(void *)&v313[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_497:
          *(void *)uint64_t v344 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v313 = 136315906;
          *(void *)&v313[4] = "operator[]";
          *(_WORD *)&v313[12] = 1024;
          *(_DWORD *)&v313[14] = 789;
          *(_WORD *)&v313[18] = 2048;
          *(void *)&v313[20] = v9;
          *(_WORD *)&v313[28] = 2048;
          *(void *)&v313[30] = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_498:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v263 = v196;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)(v17 + 20) = v263;
          *(_WORD *)&v344[28] = 2048;
          *(void *)(v17 + 30) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_499:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)(v17 + 20) = v9;
          *(_WORD *)&v344[28] = 2048;
          *(void *)(v17 + 30) = a6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_500:
          uint64_t v296 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          unint64_t v20 = v132;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)(v17 + 20) = v20;
          *(_WORD *)&v344[28] = 2048;
          *(void *)(v17 + 30) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_501:
          *(void *)uint64_t v344 = 0;
          long long v330 = 0u;
          long long v331 = 0u;
          long long v329 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v313 = 136315906;
          *(void *)&v313[4] = "operator[]";
          *(_WORD *)&v313[12] = 1024;
          *(_DWORD *)&v313[14] = 789;
          *(_WORD *)&v313[18] = 2048;
          *(void *)&v313[20] = v20;
          *(_WORD *)&v313[28] = 2048;
          *(void *)&v313[30] = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_502:
          uint64_t v296 = 0;
          long long v314 = 0u;
          long long v315 = 0u;
          memset(v313, 0, sizeof(v313));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)(v17 + 20) = v9;
          *(_WORD *)&v344[28] = 2048;
          *(void *)(v17 + 30) = a4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_503:
          uint64_t v296 = 0;
          long long v314 = 0u;
          long long v315 = 0u;
          memset(v313, 0, sizeof(v313));
          unint64_t v264 = v165;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v344 = 136315906;
          *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
          *(_WORD *)&v344[12] = 1024;
          *(_DWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 789;
          *(_WORD *)&v344[18] = 2048;
          *(void *)(v17 + 20) = v264;
          *(_WORD *)&v344[28] = 2048;
          *(void *)(v17 + 30) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        re::DynamicArray<re::MeshAssetSmoothDeformerData>::add((void *)(v279[4] + (v56 << 9) + 352), (uint64_t *)&v299);
        if ((void)v309)
        {
          uint64_t v57 = v310;
          uint64_t v58 = *(unsigned int *)(*((void *)&v309 + 1) + 4 * (0x3462D848F53ABB6DuLL % DWORD2(v310)));
          uint64_t v18 = a1;
          unint64_t v59 = v273;
          if (v58 == 0x7FFFFFFF)
          {
LABEL_96:
            LODWORD(v58) = 0x7FFFFFFF;
          }
          else
          {
            while (*(unsigned char *)(v310 + 56 * v58 + 12) != 11)
            {
              uint64_t v58 = *(_DWORD *)(v310 + 56 * v58 + 8) & 0x7FFFFFFF;
              if (v58 == 0x7FFFFFFF) {
                goto LABEL_96;
              }
            }
          }
        }
        else
        {
          uint64_t v57 = v310;
          LODWORD(v58) = 0x7FFFFFFF;
          uint64_t v18 = a1;
          unint64_t v59 = v273;
        }
        long long v130 = *(void **)(v57 + 56 * v58 + 16);
        v313[0] = 1;
        unint64_t v56 = v279[7];
        if (v56 <= v59) {
          goto LABEL_487;
        }
        re::StringID::StringID((re::StringID *)&v313[8], (const StringID *)(v279[9] + 96 * v59));
        unint64_t v56 = *v280;
        a6 = (const char *)v279[2];
        if ((unint64_t)a6 <= v56) {
          goto LABEL_488;
        }
        unint64_t v131 = v279[4] + (v56 << 9);
        unint64_t v56 = *(void *)(v131 + 208);
        unint64_t v132 = v276;
        if (v56 <= v276) {
          goto LABEL_489;
        }
        goto LABEL_248;
      }
      id v37 = (_anonymous_namespace_ *)strcmp(v26, "WrapDeformer");
      if (!v37) {
        goto LABEL_97;
      }
      goto LABEL_59;
    }
LABEL_56:
    id v37 = (_anonymous_namespace_ *)strcmp(v26, "WrapDeformer");
    if (!v37) {
      goto LABEL_97;
    }
    if (v28 == 0x2002D25A84007EBCLL)
    {
      if (v26 != "WrapDeformer")
      {
LABEL_59:
        unint64_t v38 = (_anonymous_namespace_ *)strcmp(v26, "ContactDeformer");
        if (!v38) {
          goto LABEL_263;
        }
        goto LABEL_258;
      }
LABEL_97:
      char v303 = 0;
      *(void *)&v299.var0 = 0;
      v299.uint64_t var1 = "";
      uint64_t v301 = 0;
      uint64_t v302 = 0;
      uint64_t v300 = 0;
      if (*(void *)(v20 + 88))
      {
        uint64_t v60 = *(void *)(v20 + 104);
        *(void *)uint64_t v344 = 0;
        *(void *)&v344[8] = "";
        *(void *)&v344[16] = 0;
        *(void *)&v344[24] = "";
        *(_OWORD *)&v344[32] = 0u;
        long long v345 = 0u;
        long long v346 = 0u;
        long long v347 = 0u;
        uint64_t v348 = 0;
        __int16 v349 = v278;
        uint64_t v61 = *(void *)(v60 + 16);
        if (v61)
        {
          uint64_t v62 = *(void *)(v60 + 32);
          uint64_t v63 = v62 + 40 * v61;
          uint64_t v64 = v20 + 280;
          uint64_t v274 = v20 + 224;
          do
          {
            uint64_t v65 = *(const char **)(v62 + 16);
            if (!strcmp(v65, "faceIndices"))
            {
              if (*(_DWORD *)(v62 + 24) != 2)
              {
                uint64_t v104 = v62;
                int v105 = 2;
LABEL_169:
                goto LABEL_170;
              }
              int v92 = (_anonymous_namespace_ *)re::BucketArray<re::FixedArray<int>,8ul>::operator[](v20 + 112, *(void *)(v62 + 32));
              int v93 = (const void *)*((void *)v92 + 2);
              unint64_t v94 = *(void *)v62;
              size_t v95 = 4 * v94;
              a4 = v279;
              memcpy((void *)v345, v93, v95);
            }
            else
            {
              if (!strcmp(v65, "faceCoordinates"))
              {
                if (*(_DWORD *)(v62 + 24) == 4)
                {
                  long long v96 = (_anonymous_namespace_ *)re::BucketArray<re::FixedArray<int>,8ul>::operator[](v274, *(void *)(v62 + 32));
                  uint64_t v97 = *((void *)v96 + 2);
                  unint64_t v98 = *(void *)v62;
                  if (v98)
                  {
                    char v99 = (int *)(v97 + 8);
                    unint64_t v100 = (_DWORD *)(*((void *)&v346 + 1) + 8);
                    unsigned int v101 = 1;
                    do
                    {
                      *(v100 - 2) = *(v99 - 2);
                      *(v100 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(v99 - 1);
                      int v102 = *v99;
                      v99 += 3;
                      *unint64_t v100 = v102;
                      v100 += 4;
                      BOOL v103 = v98 > v101++;
                    }
                    while (v103);
                  }
                  goto LABEL_170;
                }
LABEL_168:
                uint64_t v104 = v62;
                int v105 = 4;
                goto LABEL_169;
              }
              if (!strcmp(v65, "offsets"))
              {
                if (*(_DWORD *)(v62 + 24) == 4)
                {
                  int v106 = (_anonymous_namespace_ *)re::BucketArray<re::FixedArray<int>,8ul>::operator[](v274, *(void *)(v62 + 32));
                  uint64_t v107 = *((void *)v106 + 2);
                  unint64_t v108 = *(void *)v62;
                  if (v108)
                  {
                    uint64_t v109 = (int *)(v107 + 8);
                    uint64_t v110 = (_DWORD *)(v348 + 8);
                    unsigned int v111 = 1;
                    do
                    {
                      *(v110 - 2) = *(v109 - 2);
                      *(v110 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(v109 - 1);
                      int v112 = *v109;
                      v109 += 3;
                      *uint64_t v110 = v112;
                      v110 += 4;
                      BOOL v103 = v108 > v111++;
                    }
                    while (v103);
                  }
                  goto LABEL_170;
                }
                goto LABEL_168;
              }
              if (!strcmp(v65, "target"))
              {
                if (*(_DWORD *)(v62 + 24) == 5)
                {
                  float v66 = (const StringID *)re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](v64, *(void *)(v62 + 32));
                  LOBYTE(v296) = 1;
                  re::StringID::StringID((re::StringID *)&v297, v66);
                  re::StringID::StringID((re::StringID *)&v298, v66 + 1);
                  if ((_BYTE)v296)
                  {
                    re::StringID::StringID((re::StringID *)v293, &v297);
                    re::StringID::StringID((re::StringID *)&v295, &v298);
                    uint64_t v67 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-0", (re::DynamicString *)buf, v294);
                    if (buf[0].n128_u8[8]) {
                      uint64_t v68 = (const char *)buf[1].n128_u64[0];
                    }
                    else {
                      uint64_t v68 = &buf[0].n128_i8[9];
                    }
                    uint64_t v290 = 0;
                    float v291 = "";
                    uint64_t v69 = v290;
                    uint64_t v70 = v291;
                    float v291 = "";
                    uint64_t v290 = 0;
                    char v71 = v344[0];
                    uint64_t v72 = *(void *)&v344[8];
                    *(void *)uint64_t v344 = v69;
                    *(void *)&v344[8] = v70;
                    *(void *)&v313[8] = v72;
                    *(void *)uint64_t v313 = v69 & 0xFFFFFFFFFFFFFFFELL | v71 & 1;
                    re::StringID::destroyString((re::StringID *)v313);
                    re::StringID::destroyString((re::StringID *)&v290);
                    if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
                      (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
                    }
                    re::DynamicString::format((re::DynamicString *)"%s", (re::DynamicString *)&v290, *(void *)&v344[8]);
                    uint64_t v73 = (uint64_t)v270;
                    if (unint64_t)v291 >= 0x100 && (v291)
                    {
                      re::DynamicString::DynamicString((re::DynamicString *)v313, (const re::DynamicString *)&v290);
                      re::DynamicString::substr((re::DynamicString *)&v290, 0, 0x7FuLL, (re::DynamicString *)buf);
                      re::DynamicString::operator=((re::DynamicString *)&v290, (re::DynamicString *)buf);
                      long long v74 = (re *)buf[0].n128_u64[0];
                      if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
                        long long v74 = (re *)(*(uint64_t (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
                      }
                      int v75 = *re::pipelineLogObjects(v74);
                      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                      {
                        long long v76 = *(uint8_t **)&v313[16];
                        if ((v313[8] & 1) == 0) {
                          long long v76 = &v313[9];
                        }
                        unint64_t v77 = v313[8] >> 1;
                        if (v313[8]) {
                          unint64_t v77 = *(void *)&v313[8] >> 1;
                        }
                        uint64_t v78 = (char *)&v291 + 1;
                        if (v291) {
                          uint64_t v78 = v292;
                        }
                        buf[0].n128_u32[0] = 136315906;
                        *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = (unint64_t)v76;
                        buf[0].n128_u16[6] = 2048;
                        *(unint64_t *)((char *)&buf[0].n128_u64[1] + 6) = v77;
                        buf[1].n128_u16[3] = 2048;
                        buf[1].n128_u64[1] = 127;
                        LOWORD(v329) = 2080;
                        *(void *)((char *)&v329 + 2) = v78;
                        _os_log_impl(&dword_233120000, v75, OS_LOG_TYPE_DEFAULT, "Name '%s' was too long (%zu characters, max %zu), shortened into '%s' for wait fence ID name. This may cause conflicts.", (uint8_t *)buf, 0x2Au);
                      }
                      if (*(void *)v313 && (v313[8] & 1) != 0) {
                        (*(void (**)(void))(**(void **)v313 + 40))();
                      }
                    }
                    uint64_t v79 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-0", (re::DynamicString *)&v287, *(void *)(v23 + 8));
                    if (v288 >= 0x100 && (v288 & 1) != 0)
                    {
                      uint64_t v80 = *(const char **)(v23 + 8);
                      re::DynamicString::substr((re::DynamicString *)buf, 0, 0x7DuLL, (re::DynamicString *)v313);
                      if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
                        (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
                      }
                      long long v81 = &v313[9];
                      if (v313[8]) {
                        long long v81 = *(uint8_t **)&v313[16];
                      }
                      re::DynamicString::format((re::DynamicString *)"%s-0", (re::DynamicString *)buf, v81);
                      re::DynamicString::operator=((re::DynamicString *)&v287, (re::DynamicString *)buf);
                      long long v82 = (re *)buf[0].n128_u64[0];
                      if (buf[0].n128_u64[0] && (buf[0].n128_u8[8] & 1) != 0) {
                        long long v82 = (re *)(*(uint64_t (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
                      }
                      uint64_t v83 = *re::pipelineLogObjects(v82);
                      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
                      {
                        long long v84 = v83;
                        long long v85 = *(const char **)(v23 + 8);
                        size_t v86 = strlen(v85);
                        int v87 = &v313[9];
                        if (v313[8]) {
                          int v87 = *(uint8_t **)&v313[16];
                        }
                        buf[0].n128_u32[0] = 136315906;
                        *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = (unint64_t)v85;
                        buf[0].n128_u16[6] = 2048;
                        *(unint64_t *)((char *)&buf[0].n128_u64[1] + 6) = v86;
                        buf[1].n128_u16[3] = 2048;
                        buf[1].n128_u64[1] = 125;
                        LOWORD(v329) = 2080;
                        *(void *)((char *)&v329 + 2) = v87;
                        _os_log_impl(&dword_233120000, v84, OS_LOG_TYPE_DEFAULT, "Name '%s' was too long (%zu characters, max %zu), shortened into '%s' for fence ID name. This may cause conflicts.", (uint8_t *)buf, 0x2Au);
                      }
                      if (*(void *)v313 && (v313[8] & 1) != 0) {
                        (*(void (**)(void))(**(void **)v313 + 40))();
                      }
                    }
                    long long v341 = 0u;
                    long long v342 = 0u;
                    long long v339 = 0u;
                    long long v340 = 0u;
                    long long v337 = 0u;
                    long long v338 = 0u;
                    long long v335 = 0u;
                    long long v336 = 0u;
                    long long v333 = 0u;
                    long long v334 = 0u;
                    long long v331 = 0u;
                    long long v332 = 0u;
                    long long v329 = 0u;
                    long long v330 = 0u;
                    memset(buf, 0, sizeof(buf));
                    if (v291) {
                      char v88 = v292;
                    }
                    else {
                      char v88 = (char *)&v291 + 1;
                    }
                    char v343 = -1;
                    int v89 = (_anonymous_namespace_ *)strlcpy((char *)&v335, v88, 0x80uLL);
                    char v343 = 14;
                    *(void *)uint64_t v313 = 0x4425D6C2BB3546C6;
                    *(void *)&v313[8] = "FenceDeformer";
                    __n128 v284 = buf;
                    uint64_t v285 = 257;
                    memset(&v313[16], 0, 24);
                    re::FixedArray<unsigned char>::copy(&v313[16], (const void **)&v284);
                    re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)v313);
                    if (*(void *)&v313[16])
                    {
                      if (*(void *)&v313[24])
                      {
                        (*(void (**)(void))(**(void **)&v313[16] + 40))();
                        *(void *)&v313[24] = 0;
                        *(void *)&v313[32] = 0;
                      }
                      *(void *)&v313[16] = 0;
                    }
                    re::StringID::destroyString((re::StringID *)v313);
                    if (*(void *)&v295.var0 >= 0xFFFFFFFFFFFFFFFELL && (*(unsigned char *)&v295.var0 & 1) == 0)
                    {
                      uint64_t var1 = v295.var1;
                      goto LABEL_176;
                    }
                    if (*(void *)&v295.var0 <= 1uLL && (uint64_t var1 = v295.var1) != 0)
                    {
LABEL_176:
                      if (*var1) {
                        goto LABEL_177;
                      }
                    }
                    else
                    {
LABEL_177:
                      long long v325 = 0u;
                      long long v326 = 0u;
                      long long v323 = 0u;
                      long long v324 = 0u;
                      long long v321 = 0u;
                      long long v322 = 0u;
                      long long v319 = 0u;
                      long long v320 = 0u;
                      long long v317 = 0u;
                      long long v318 = 0u;
                      long long v315 = 0u;
                      long long v316 = 0u;
                      long long v314 = 0u;
                      memset(v313, 0, sizeof(v313));
                      if (v288) {
                        char v113 = v289;
                      }
                      else {
                        char v113 = (char *)&v288 + 1;
                      }
                      char v327 = -1;
                      strlcpy((char *)v313, v113, 0x80uLL);
                      re::StringID::destroyString((re::StringID *)&v299);
                      v299.uint64_t var1 = "FenceDeformer";
                      *(void *)&v299.var0 = 0x4425D6C2BB3546C6;
                      v283[0] = v313;
                      v283[1] = (const void *)257;
                      uint64_t v286 = 0;
                      __n128 v284 = 0;
                      uint64_t v285 = 0;
                      re::FixedArray<unsigned char>::copy(&v284, v283);
                      re::FixedArray<float>::operator=(&v300, (uint64_t *)&v284);
                      char v90 = (_anonymous_namespace_ *)v284;
                      if (v284 && v285) {
                        char v90 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(v284->n128_u64[0] + 40))();
                      }
                    }
                    if (v288) {
                      uint64_t v115 = v289;
                    }
                    else {
                      uint64_t v115 = (char *)&v288 + 1;
                    }
                    __n128 v284 = 0;
                    uint64_t v285 = (uint64_t)"";
                    *(void *)uint64_t v313 = v284;
                    *(void *)&v313[8] = v285;
                    uint64_t v285 = (uint64_t)"";
                    __n128 v284 = 0;
                    re::StringID::StringID((re::StringID *)&v313[16], &v295);
                    unint64_t v116 = *(void *)v344;
                    unint64_t v117 = 0x94D049BB133111EBLL
                         * ((0xBF58476D1CE4E5B9 * ((v116 >> 31) ^ (v116 >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                                    * ((v116 >> 31) ^ (v116 >> 1))) >> 27));
                    unint64_t v118 = v117 ^ (v117 >> 31);
                    uint64_t v271 = v64;
                    if (*(void *)v270)
                    {
                      unint64_t v119 = v118 % *((unsigned int *)v270 + 6);
                      uint64_t v120 = *(unsigned int *)(*((void *)v270 + 1) + 4 * v119);
                      if (v120 != 0x7FFFFFFF)
                      {
                        uint64_t v121 = *((void *)v270 + 2);
                        uint64_t v122 = *(const char **)&v344[8];
                        while (1)
                        {
                          if ((*(void *)(v121 + 56 * v120 + 8) ^ v116) <= 1)
                          {
                            int v123 = *(const char **)(v121 + 56 * v120 + 16);
                            if (v123 == v122 || !strcmp(v123, v122)) {
                              break;
                            }
                          }
                          uint64_t v120 = *(_DWORD *)(v121 + 56 * v120) & 0x7FFFFFFF;
                          if (v120 == 0x7FFFFFFF)
                          {
                            uint64_t v73 = (uint64_t)v270;
                            goto LABEL_195;
                          }
                        }
LABEL_196:
                        re::StringID::destroyString((re::StringID *)&v313[16]);
                        re::StringID::destroyString((re::StringID *)v313);
                        re::StringID::destroyString((re::StringID *)&v284);
                        if (v287 && (v288 & 1) != 0) {
                          (*(void (**)(void))(*(void *)v287 + 40))();
                        }
                        uint64_t v17 = v344;
                        uint64_t v18 = a1;
                        a4 = v279;
                        uint64_t v64 = v271;
                        if (v290 && (v291 & 1) != 0) {
                          (*(void (**)(void))(*(void *)v290 + 40))();
                        }
                        re::StringID::destroyString((re::StringID *)&v295);
                        re::StringID::destroyString((re::StringID *)v293);
LABEL_203:
                        if ((_BYTE)v296)
                        {
                          re::StringID::destroyString((re::StringID *)&v298);
                          re::StringID::destroyString((re::StringID *)&v297);
                        }
                        goto LABEL_170;
                      }
                    }
                    else
                    {
                      LODWORD(v1re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19) = 0;
                    }
LABEL_195:
                    re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(v73, v119, v118, (const StringID *)v344, (uint64_t *)v313);
                    ++*(_DWORD *)(v73 + 40);
                    goto LABEL_196;
                  }
                }
                else
                {
                  LOBYTE(v296) = 0;
                }
                goto LABEL_203;
              }
            }
LABEL_170:
            v62 += 40;
          }
          while (v62 != v63);
        }
        uint64_t v124 = *(void *)(v20 + 48);
        if (v124)
        {
          uint64_t v125 = *(void *)(v20 + 64);
          uint64_t v126 = 40 * v124;
          while (strcmp(*(const char **)(v125 + 16), "envelopeVarName"))
          {
LABEL_215:
            v125 += 40;
            v126 -= 40;
            if (!v126) {
              goto LABEL_216;
            }
          }
          if (*(_DWORD *)(v125 + 24) == 6)
          {
            uint64_t v127 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *(void *)(v125 + 32));
            buf[0].n128_u8[0] = 1;
            re::StringID::StringID((re::StringID *)&buf[0].n128_i8[8], v127);
            if (buf[0].n128_u8[0])
            {
              re::StringID::operator=((unint64_t *)&v344[16], &buf[0].n128_i64[1]);
              goto LABEL_213;
            }
          }
          else
          {
            buf[0].n128_u8[0] = 0;
          }
LABEL_213:
          if (buf[0].n128_u8[0]) {
            re::StringID::destroyString((re::StringID *)&buf[0].n128_i8[8]);
          }
          goto LABEL_215;
        }
LABEL_216:
        unint64_t v9 = *v280;
        a6 = (const char *)a4[2];
        if ((unint64_t)a6 <= v9) {
          goto LABEL_493;
        }
        re::DynamicArray<re::MeshAssetWrapDeformerData>::add((void *)(a4[4] + (v9 << 9) + 392), (uint64_t *)v344);
        if ((void)v347)
        {
          if (*((void *)&v347 + 1))
          {
            (*(void (**)(void))(*(void *)v347 + 40))();
            *((void *)&v347 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
            uint64_t v348 = 0;
          }
          *(void *)&long long v347 = 0;
        }
        if (*((void *)&v345 + 1))
        {
          if ((void)v346)
          {
            (*(void (**)(void))(**((void **)&v345 + 1) + 40))();
            long long v346 = 0uLL;
          }
          *((void *)&v345 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        }
        if (*(void *)&v344[32])
        {
          if (*(void *)&v344[40])
          {
            (*(void (**)(void))(**(void **)&v344[32] + 40))();
            *(void *)&v344[40] = 0;
            *(void *)&long long v345 = 0;
          }
          *(void *)&v344[32] = 0;
        }
        re::StringID::destroyString((re::StringID *)&v344[16]);
        re::StringID::destroyString((re::StringID *)v344);
      }
      buf[0].n128_u64[0] = 0x4005A4B50800FD78;
      buf[0].n128_u64[1] = (unint64_t)"WrapDeformer";
      *(void *)uint64_t v313 = &v303;
      *(void *)&v313[8] = 1;
      *(void *)&long long v329 = 0;
      buf[1] = 0uLL;
      re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
      re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
      if (buf[1].n128_u64[0])
      {
        if (buf[1].n128_u64[1])
        {
          (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
          buf[1].n128_u64[1] = 0;
          *(void *)&long long v329 = 0;
        }
        buf[1].n128_u64[0] = 0;
      }
      re::StringID::destroyString((re::StringID *)buf);
      if (*(void *)&v299.var0 > 1uLL || !v299.var1 || *v299.var1)
      {
        unint64_t v128 = v306;
        if (v306 >= v305)
        {
          re::DynamicArray<re::DeformationDefinition>::growCapacity(&v304, v306 + 1);
          unint64_t v128 = v306;
        }
        long long v129 = re::StringID::StringID((re::StringID *)(v308 + 40 * v128), &v299);
        re::FixedArray<unsigned char>::FixedArray((void *)v129 + 2, &v300);
        ++v306;
        ++v307;
      }
      if (v300)
      {
        if (v301)
        {
          (*(void (**)(void))(*(void *)v300 + 40))();
          uint64_t v301 = 0;
          uint64_t v302 = 0;
        }
        uint64_t v300 = 0;
      }
      goto LABEL_249;
    }
    unint64_t v38 = (_anonymous_namespace_ *)strcmp(v26, "ContactDeformer");
    if (!v38) {
      goto LABEL_263;
    }
    if (v28 == 0x1179C3D2A9790052) {
      break;
    }
LABEL_258:
    int v134 = (_anonymous_namespace_ *)strcmp(v26, "Renormalization");
    if (!v134) {
      goto LABEL_306;
    }
    if (v28 == 0x55E7643F91509A2ALL)
    {
      if (v26 == "Renormalization")
      {
LABEL_306:
        v344[0] = 0;
        buf[0].n128_u64[0] = 0xABCEC87F22A13454;
        buf[0].n128_u64[1] = (unint64_t)"Renormalization";
        goto LABEL_387;
      }
      goto LABEL_261;
    }
    long long v135 = (_anonymous_namespace_ *)strcmp(v26, "OffsetsDeformer");
    if (v135)
    {
      if (v28 != 0x3875EE4E6B5AEA72)
      {
LABEL_311:
        int v134 = (_anonymous_namespace_ *)strcmp(v26, "TensionDeformer");
        if (!v134) {
          goto LABEL_363;
        }
        if (v28 == 0x120E28E032)
        {
          if (v26 != "Tension")
          {
            int v153 = v26;
            long long v154 = "Tension";
LABEL_315:
            int v134 = (_anonymous_namespace_ *)strcmp(v153, v154);
            if (v134)
            {
              long long v155 = v26;
              int v156 = "BoundingBoxCalculation";
              goto LABEL_317;
            }
          }
LABEL_363:
          v344[0] = 0;
          buf[0].n128_u64[0] = 0x241C51C064;
          unint64_t v185 = "Tension";
LABEL_386:
          buf[0].n128_u64[1] = (unint64_t)v185;
LABEL_387:
          *(void *)uint64_t v313 = v344;
          *(void *)&v313[8] = 1;
          *(void *)&long long v329 = 0;
          buf[1] = 0uLL;
          re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
LABEL_388:
          re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
          if (buf[1].n128_u64[0])
          {
            if (buf[1].n128_u64[1])
            {
              (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
              buf[1].n128_u64[1] = 0;
              *(void *)&long long v329 = 0;
            }
            buf[1].n128_u64[0] = 0;
          }
LABEL_392:
          long long v133 = (re::StringID *)buf;
          goto LABEL_250;
        }
        int v134 = (_anonymous_namespace_ *)strcmp(v26, "BoundingBoxCalculation");
        if (!v134)
        {
LABEL_385:
          v344[0] = 0;
          buf[0].n128_u64[0] = 0x32458CCC0A585AB0;
          unint64_t v185 = "Bounding Box Calculation";
          goto LABEL_386;
        }
        if (v28 == 0x535C1C60DF8DDA89)
        {
          if (v26 != "OpenSubdivViewIndependentComputeStep" && strcmp(v26, "OpenSubdivViewIndependentComputeStep")) {
            goto LABEL_395;
          }
          goto LABEL_398;
        }
        if (v28 == 0x1922C666052C2D58)
        {
          if (v26 == "Bounding Box Calculation") {
            goto LABEL_385;
          }
          long long v155 = v26;
          int v156 = "Bounding Box Calculation";
LABEL_317:
          int v134 = (_anonymous_namespace_ *)strcmp(v155, v156);
          if (!v134) {
            goto LABEL_385;
          }
        }
LABEL_395:
        buf[0].n128_u64[0] = 0x637BDBD40E8681E4;
        buf[0].n128_u64[1] = (unint64_t)"OpenSubdivViewDependentComputeStep";
        if (re::StringID::operator==((void *)(v20 + 16), buf)
          || (*(void *)uint64_t v313 = 0x48358EA73269F98CLL,
              *(void *)&v313[8] = "PrepareSimplifiedMeshBuffer",
              re::StringID::operator==((void *)(v20 + 16), v313))
          || (*(void *)uint64_t v344 = 0x10444A02DC81C1ELL,
              *(void *)&v344[8] = "VertexCache",
              re::StringID::operator==((void *)(v20 + 16), v344)))
        {
LABEL_398:
          re::StringID::StringID((re::StringID *)buf, (const StringID *)(v20 + 16));
          buf[1] = 0uLL;
          *(void *)&long long v329 = 0;
          goto LABEL_388;
        }
        if (strcmp(v26, "JiggleDeformer"))
        {
          buf[0].n128_u64[0] = 0x150A9604D758308ALL;
          buf[0].n128_u64[1] = (unint64_t)"JiggleDeformer";
          BOOL v197 = re::StringID::operator==((void *)(v20 + 16), buf);
          if (!v197)
          {
            uint64_t v205 = *re::pipelineLogObjects((re *)v197);
            if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
            {
              double v206 = v205;
              unint64_t v207 = *(void *)(v20 + 24);
              buf[0].n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf[0].n128_u64 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v207;
              _os_log_impl(&dword_233120000, v206, OS_LOG_TYPE_DEFAULT, "Unsupported deformer type: %s", (uint8_t *)buf, 0xCu);
            }
            goto LABEL_251;
          }
        }
        buf[0].n128_u64[0] = 0x2A152C09AEB06114;
        buf[0].n128_u64[1] = (unint64_t)"JiggleDeformer";
        *(void *)&long long v329 = 0;
        buf[1] = 0uLL;
        re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
        if (buf[1].n128_u64[0])
        {
          if (buf[1].n128_u64[1])
          {
            (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
            buf[1].n128_u64[1] = 0;
            *(void *)&long long v329 = 0;
          }
          buf[1].n128_u64[0] = 0;
        }
        re::StringID::destroyString((re::StringID *)buf);
        buf[0].n128_u64[0] = 0;
        buf[0].n128_u64[1] = (unint64_t)"";
        buf[1].n128_u64[0] = 0;
        buf[1].n128_u64[1] = (unint64_t)"";
        WORD4(v329) = v278;
        uint64_t v198 = *(void *)(v20 + 48);
        if (!v198)
        {
LABEL_428:
          a4 = v279;
          uint64_t v204 = re::DynamicArray<re::MeshAssetModel>::operator[](v279[2], v279[4], *v280);
          re::DynamicArray<re::MeshAssetJiggleDeformerData>::add((_anonymous_namespace_ *)(v204 + 472), (uint64_t *)buf);
          re::StringID::destroyString((re::StringID *)&buf[1]);
          goto LABEL_392;
        }
        a6 = *(const char **)(v20 + 64);
        uint64_t v199 = 40 * v198;
        while (2)
        {
          uint64_t v200 = (const char *)*((void *)a6 + 2);
          if (!strcmp(v200, "envelopeVarName"))
          {
            if (*((_DWORD *)a6 + 6) == 6)
            {
              uint64_t v201 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *((void *)a6 + 4));
              v313[0] = 1;
              re::StringID::StringID((re::StringID *)&v313[8], v201);
              if (v313[0])
              {
                long long v202 = &buf[1];
                goto LABEL_419;
              }
              goto LABEL_421;
            }
          }
          else
          {
            if (strcmp(v200, "massVarName"))
            {
              if (!strcmp(v200, "stiffness"))
              {
                if (*((_DWORD *)a6 + 6)) {
                  goto LABEL_425;
                }
                LODWORD(v329) = *((_DWORD *)a6 + 8);
              }
              else
              {
                if (strcmp(v200, "damping")) {
                  goto LABEL_427;
                }
                if (!*((_DWORD *)a6 + 6))
                {
                  DWORD1(v329) = *((_DWORD *)a6 + 8);
                  goto LABEL_427;
                }
LABEL_425:
              }
LABEL_427:
              a6 += 40;
              v199 -= 40;
              if (!v199) {
                goto LABEL_428;
              }
              continue;
            }
            if (*((_DWORD *)a6 + 6) == 6)
            {
              long long v203 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *((void *)a6 + 4));
              v313[0] = 1;
              re::StringID::StringID((re::StringID *)&v313[8], v203);
              if (v313[0])
              {
                long long v202 = buf;
LABEL_419:
                re::StringID::operator=(v202->n128_u64, (uint64_t *)&v313[8]);
LABEL_422:
                if (v313[0]) {
                  re::StringID::destroyString((re::StringID *)&v313[8]);
                }
                goto LABEL_427;
              }
LABEL_421:
              goto LABEL_422;
            }
          }
          break;
        }
        v313[0] = 0;
        goto LABEL_421;
      }
      if (v26 != "OffsetsDeformer")
      {
        int v153 = v26;
        long long v154 = "TensionDeformer";
        goto LABEL_315;
      }
    }
LABEL_319:
    v293[0] = 0;
    buf[0].n128_u64[0] = 0x70EBDC9CD6B5D4E4;
    buf[0].n128_u64[1] = (unint64_t)"OffsetsDeformer";
    *(void *)uint64_t v313 = v293;
    *(void *)&v313[8] = 1;
    *(void *)&long long v329 = 0;
    buf[1] = 0uLL;
    re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
    re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
    if (buf[1].n128_u64[0])
    {
      if (buf[1].n128_u64[1])
      {
        (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
        buf[1].n128_u64[1] = 0;
        *(void *)&long long v329 = 0;
      }
      buf[1].n128_u64[0] = 0;
    }
    re::StringID::destroyString((re::StringID *)buf);
    if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshOffsetsComponent>(v18))
    {
      if (!*(void *)v281)
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v281, 0);
        ++*((_DWORD *)v18 + 14);
      }
      uint64_t v157 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                   + 7)
                                                                + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 216, 0);
      re::make::shared::inplace<re::ecs2::MeshOffsetsComponent>(v157, v313);
      unint64_t v158 = *(void *)((*(uint64_t (**)(void))(**(void **)v313 + 40))(*(void *)v313) + 24) >> 1;
      unint64_t v159 = *(void *)v313;
      *(void *)uint64_t v313 = 0;
      buf[0].n128_u64[0] = v158;
      buf[0].n128_u64[1] = v159;
      buf[1].n128_u8[0] = 1;
      re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v281, buf);
      if (*(void *)v313) {

      }
      v344[0] = 10;
      uint64_t v161 = re::globalAllocators(v160);
      uint64_t v162 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v161[2] + 32))(v161[2], 40, 8);
      *(_OWORD *)uint64_t v162 = 0u;
      *(_OWORD *)(v162 + 16) = 0u;
      *(void *)(v162 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
      *(void *)uint64_t v313 = &unk_26E6DF9C8;
      *(void *)&v313[24] = v313;
      buf[0].n128_u64[0] = v162;
      *(void *)&long long v329 = &buf[0].n128_u64[1];
      buf[0].n128_u64[1] = (unint64_t)&unk_26E6DF9C8;
      re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::add((uint64_t)&v309, v344, (uint64_t *)buf);
      std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>::~unique_ptr[abi:nn180100]((uint64_t *)buf);
      std::__function::__value_func<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__value_func[abi:nn180100](v313);
    }
    *(void *)&v299.var0 = 0;
    v299.uint64_t var1 = "";
    LOWORD(v300) = v278;
    uint64_t v163 = re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshOffsetsComponent>(v18);
    if (*(void *)(v20 + 48))
    {
      *(void *)&long long v329 = 0;
      memset(buf, 0, 28);
      long long v330 = xmmword_23435FD50;
      long long v331 = xmmword_23435FD60;
      long long v332 = xmmword_23435FD80;
      long long v333 = xmmword_23435FBB0;
      long long v334 = xmmword_23435FD50;
      long long v335 = xmmword_23435FD60;
      long long v336 = xmmword_23435FD80;
      long long v337 = xmmword_23435FBB0;
      LODWORD(v3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = 0;
      unint64_t v9 = *v280;
      long long v164 = a4;
      a4 = (void *)a4[2];
      unint64_t v165 = v276;
      if ((unint64_t)a4 <= v9) {
        goto LABEL_502;
      }
      unint64_t v166 = v164[4] + (v9 << 9);
      unint64_t v9 = *(void *)(v166 + 208);
      if (v9 <= v276) {
        goto LABEL_503;
      }
      uint64_t v167 = v163;
      re::DynamicArray<float>::resize((uint64_t)buf, (3 * *(_DWORD *)(*(void *)(v166 + 224) + (v276 << 8) + 48)));
      uint64_t v168 = *(void *)(v20 + 48);
      if (v168)
      {
        uint64_t v169 = *(void *)(v20 + 64);
        uint64_t v275 = v20 + 392;
        for (uint64_t j = 40 * v168; j; j -= 40)
        {
          size_t v171 = *(const char **)(v169 + 16);
          if (!strcmp(v171, "preTransform"))
          {
            if (*(_DWORD *)(v169 + 24) != 7) {
              goto LABEL_347;
            }
            uint64_t v174 = (long long *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](v275, *(void *)(v169 + 32));
            long long v175 = v174[3];
            long long v177 = *v174;
            long long v176 = v174[1];
            long long v332 = v174[2];
            long long v333 = v175;
            long long v330 = v177;
            long long v331 = v176;
          }
          else if (!strcmp(v171, "postTransform"))
          {
            if (*(_DWORD *)(v169 + 24) != 7)
            {
LABEL_347:
              uint64_t v182 = v169;
              int v183 = 7;
LABEL_348:
              goto LABEL_349;
            }
            long long v178 = (long long *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](v275, *(void *)(v169 + 32));
            long long v179 = v178[3];
            long long v181 = *v178;
            long long v180 = v178[1];
            long long v336 = v178[2];
            long long v337 = v179;
            long long v334 = v181;
            long long v335 = v180;
          }
          else
          {
            if (!strcmp(v171, "blendingMode"))
            {
              if (*(_DWORD *)(v169 + 24) == 1)
              {
                LODWORD(v3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = *(_DWORD *)(v169 + 32);
                goto LABEL_349;
              }
              uint64_t v182 = v169;
              int v183 = 1;
              goto LABEL_348;
            }
            if (!strcmp(v171, "envelopeVarName"))
            {
              if (*(_DWORD *)(v169 + 24) == 6)
              {
                uint64_t v184 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *(void *)(v169 + 32));
                v313[0] = 1;
                re::StringID::StringID((re::StringID *)&v313[8], v184);
                if (v313[0])
                {
                  re::StringID::operator=((unint64_t *)&v299, (uint64_t *)&v313[8]);
                  goto LABEL_359;
                }
              }
              else
              {
                v313[0] = 0;
              }
LABEL_359:
              if (v313[0]) {
                re::StringID::destroyString((re::StringID *)&v313[8]);
              }
              goto LABEL_349;
            }
            if (!strcmp(v171, "offsets"))
            {
              if (*(_DWORD *)(v169 + 24) == 4)
              {
                uint64_t v172 = (const void **)re::BucketArray<re::FixedArray<int>,8ul>::operator[](v20 + 224, *(void *)(v169 + 32));
                if (3 * *(void *)v169 <= buf[1].n128_u64[0])
                {
                  memcpy((void *)v329, v172[2], 12 * *(void *)v169);
                }
                else
                {
                  uint64_t v173 = *re::pipelineLogObjects((re *)v172);
                  if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)uint64_t v313 = 0;
                    _os_log_impl(&dword_233120000, v173, OS_LOG_TYPE_DEFAULT, "Invalid number of offsets specified.", v313, 2u);
                  }
                }
                goto LABEL_349;
              }
              uint64_t v182 = v169;
              int v183 = 4;
              goto LABEL_348;
            }
          }
LABEL_349:
          v169 += 40;
        }
      }
      unint64_t v186 = *(void *)(v167 + 48);
      if (v186 >= *(void *)(v167 + 40))
      {
        re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::growCapacity((void *)(v167 + 32), v186 + 1);
        unint64_t v186 = *(void *)(v167 + 48);
      }
      uint64_t v187 = re::DynamicArray<float>::DynamicArray(*(void *)(v167 + 64) + 192 * v186, (uint64_t *)buf);
      *(_OWORD *)(v187 + 48) = v330;
      long long v188 = v331;
      long long v189 = v332;
      long long v190 = v334;
      *(_OWORD *)(v187 + 96) = v333;
      *(_OWORD *)(v187 + 112) = v190;
      *(_OWORD *)(v187 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v188;
      *(_OWORD *)(v187 + 80) = v189;
      long long v191 = v335;
      long long v192 = v336;
      long long v193 = v337;
      *(_DWORD *)(v187 + 176) = v338;
      *(_OWORD *)(v187 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v192;
      *(_OWORD *)(v187 + 160) = v193;
      *(_OWORD *)(v187 + 128) = v191;
      ++*(void *)(v167 + 48);
      ++*(_DWORD *)(v167 + 56);
      a4 = v279;
      if (buf[0].n128_u64[0] && (void)v329) {
        (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
      }
    }
    unint64_t v9 = *v280;
    a6 = (const char *)a4[2];
    if ((unint64_t)a6 <= v9) {
      goto LABEL_497;
    }
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::add((void *)(a4[4] + (v9 << 9) + 432), (uint64_t *)&v299);
    if ((void)v309)
    {
      uint64_t v194 = v310;
      uint64_t v195 = *(unsigned int *)(*((void *)&v309 + 1) + 4 * (0x75C8519A9320579uLL % DWORD2(v310)));
      unint64_t v196 = v273;
      if (v195 == 0x7FFFFFFF)
      {
LABEL_374:
        LODWORD(v195) = 0x7FFFFFFF;
      }
      else
      {
        while (*(unsigned char *)(v310 + 56 * v195 + 12) != 10)
        {
          uint64_t v195 = *(_DWORD *)(v310 + 56 * v195 + 8) & 0x7FFFFFFF;
          if (v195 == 0x7FFFFFFF) {
            goto LABEL_374;
          }
        }
      }
    }
    else
    {
      uint64_t v194 = v310;
      LODWORD(v195) = 0x7FFFFFFF;
      unint64_t v196 = v273;
    }
    long long v130 = *(void **)(v194 + 56 * v195 + 16);
    v313[0] = 1;
    unint64_t v9 = a4[7];
    if (v9 <= v196) {
      goto LABEL_498;
    }
    re::StringID::StringID((re::StringID *)&v313[8], (const StringID *)(a4[9] + 96 * v196));
    unint64_t v9 = *v280;
    a6 = (const char *)a4[2];
    if ((unint64_t)a6 <= v9) {
      goto LABEL_499;
    }
    unint64_t v131 = a4[4] + (v9 << 9);
    unint64_t v9 = *(void *)(v131 + 208);
    unint64_t v132 = v276;
    if (v9 <= v276) {
      goto LABEL_500;
    }
LABEL_248:
    re::StringID::StringID((re::StringID *)&v313[24], (const StringID *)(*(void *)(v131 + 224) + (v132 << 8) + 72));
    re::DynamicArray<re::MeshIdentifierAsset>::add(v130, (uint64_t)v313);
    re::StringID::destroyString((re::StringID *)&v313[24]);
    re::StringID::destroyString((re::StringID *)&v313[8]);
LABEL_249:
    long long v133 = (re::StringID *)&v299;
LABEL_250:
    re::StringID::destroyString(v133);
LABEL_251:
    v20 += 448;
    if (v20 == v282) {
      goto LABEL_431;
    }
  }
  if (v26 != "ContactDeformer")
  {
    int v134 = (_anonymous_namespace_ *)strcmp(v26, "Renormalization");
    if (!v134) {
      goto LABEL_306;
    }
LABEL_261:
    long long v135 = (_anonymous_namespace_ *)strcmp(v26, "OffsetsDeformer");
    if (v135) {
      goto LABEL_311;
    }
    goto LABEL_319;
  }
LABEL_263:
  v293[0] = 0;
  buf[0].n128_u64[0] = 0x22F387A552F200A4;
  buf[0].n128_u64[1] = (unint64_t)"ContactDeformer";
  *(void *)uint64_t v313 = v293;
  *(void *)&v313[8] = 1;
  *(void *)&long long v329 = 0;
  buf[1] = 0uLL;
  re::FixedArray<unsigned char>::copy((__n128 *)buf[1].n128_u64, (const void **)v313);
  re::DynamicArray<re::DeformationDefinition>::add(&v304, (uint64_t *)buf);
  if (buf[1].n128_u64[0])
  {
    if (buf[1].n128_u64[1])
    {
      (*(void (**)(void))(*(void *)buf[1].n128_u64[0] + 40))();
      buf[1].n128_u64[1] = 0;
      *(void *)&long long v329 = 0;
    }
    buf[1].n128_u64[0] = 0;
  }
  re::StringID::destroyString((re::StringID *)buf);
  *(void *)uint64_t v313 = 0;
  *(void *)&v313[8] = "";
  memset(&v313[16], 0, 24);
  *(_WORD *)&v313[40] = v278;
  unint64_t v136 = *(void *)(v20 + 88);
  uint64_t v138 = *(void *)(v20 + 48);
  if (v138)
  {
    uint64_t v139 = *(void *)(v20 + 64);
    uint64_t v140 = 40 * v138;
    while (strcmp(*(const char **)(v139 + 16), "offsetsVarName"))
    {
LABEL_277:
      v139 += 40;
      v140 -= 40;
      if (!v140) {
        goto LABEL_278;
      }
    }
    if (*(_DWORD *)(v139 + 24) == 6)
    {
      char v141 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](v20 + 336, *(void *)(v139 + 32));
      buf[0].n128_u8[0] = 1;
      re::StringID::StringID((re::StringID *)&buf[0].n128_i8[8], v141);
      if (buf[0].n128_u8[0])
      {
        re::StringID::operator=((unint64_t *)v313, &buf[0].n128_i64[1]);
        goto LABEL_275;
      }
    }
    else
    {
      buf[0].n128_u8[0] = 0;
    }
LABEL_275:
    if (buf[0].n128_u8[0]) {
      re::StringID::destroyString((re::StringID *)&buf[0].n128_i8[8]);
    }
    goto LABEL_277;
  }
LABEL_278:
  uint64_t v142 = *(void *)(v20 + 88);
  if (!v142)
  {
LABEL_300:
    unint64_t v9 = *v280;
    a4 = v279;
    a6 = (const char *)v279[2];
    if ((unint64_t)a6 <= v9) {
      goto LABEL_494;
    }
    re::DynamicArray<re::MeshAssetContactDeformerData>::add((void *)(v279[4] + (v9 << 9) + 312), (uint64_t *)v313);
    uint64_t v18 = a1;
    uint64_t v17 = v344;
    if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::SkeletalPoseComponent>(a1)) {
      re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>(a1);
    }
    if (!re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::RigComponent>(a1)) {
      re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>(a1);
    }
    re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit(&v313[16]);
    long long v133 = (re::StringID *)v313;
    goto LABEL_250;
  }
  unsigned int v143 = 0;
  uint64_t v144 = *(void *)(v20 + 104);
  uint64_t v17 = (unsigned char *)(v144 + 40 * v142);
  while (1)
  {
    uint64_t v145 = *(void *)(v144 + 16);
    if (v145) {
      break;
    }
LABEL_299:
    ++v143;
    v144 += 40;
    if ((unsigned char *)v144 == v17) {
      goto LABEL_300;
    }
  }
  uint64_t v146 = *(void *)(v144 + 32);
  uint64_t v147 = 40 * v145;
  while (2)
  {
    int v148 = *(const char **)(v146 + 16);
    if (strcmp(v148, "jointIndex"))
    {
      if (!strcmp(v148, "radius"))
      {
        if (!*(_DWORD *)(v146 + 24))
        {
          a4 = *(void **)&v313[24];
          if (*(void *)&v313[24] <= (unint64_t)v143) {
            goto LABEL_443;
          }
          *(_DWORD *)(*(void *)&v313[32] + 32 * v143 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(_DWORD *)(v146 + 32);
LABEL_298:
          v146 += 40;
          v147 -= 40;
          if (!v147) {
            goto LABEL_299;
          }
          continue;
        }
        uint64_t v151 = v146;
        int v152 = 0;
      }
      else
      {
        if (strcmp(v148, "heightMap")) {
          goto LABEL_298;
        }
        if (*(_DWORD *)(v146 + 24) == 3)
        {
          uint64_t v149 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](v20 + 168, *(void *)(v146 + 32));
          uint64_t v150 = *(void *)v146;
          v299.uint64_t var1 = *(char **)(v149 + 16);
          uint64_t v300 = v150;
          *(unsigned char *)&v299.var0 = 1;
          a4 = *(void **)&v313[24];
          if (*(void *)&v313[24] <= (unint64_t)v143) {
            goto LABEL_444;
          }
          re::FixedArray<int>::operator=((_anonymous_namespace_ *)(*(void *)&v313[32] + 32 * v143 + 8), (uint64_t)&v299.var1);
          goto LABEL_298;
        }
        *(unsigned char *)&v299.var0 = 0;
        uint64_t v151 = v146;
        int v152 = 3;
      }
LABEL_297:
      goto LABEL_298;
    }
    break;
  }
  if (*(_DWORD *)(v146 + 24) != 1)
  {
    uint64_t v151 = v146;
    int v152 = 1;
    goto LABEL_297;
  }
  a4 = *(void **)&v313[24];
  if (*(void *)&v313[24] > (unint64_t)v143)
  {
    *(_DWORD *)(*(void *)&v313[32] + 32 * v143) = *(_DWORD *)(v146 + 32);
    goto LABEL_298;
  }
  *(void *)&v299.var0 = 0;
  long long v330 = 0u;
  long long v331 = 0u;
  long long v329 = 0u;
  memset(buf, 0, sizeof(buf));
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)uint64_t v344 = 136315906;
  *(void *)&v344[4] = "operator[]";
  *(_WORD *)&v344[12] = 1024;
  *(_DWORD *)&v344[14] = 468;
  *(_WORD *)&v344[18] = 2048;
  *(void *)&v344[20] = v143;
  *(_WORD *)&v344[28] = 2048;
  *(void *)&v344[30] = a4;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_443:
  *(void *)&v299.var0 = 0;
  long long v330 = 0u;
  long long v331 = 0u;
  long long v329 = 0u;
  memset(buf, 0, sizeof(buf));
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)uint64_t v344 = 136315906;
  *(void *)&v344[4] = "operator[]";
  *(_WORD *)&v344[12] = 1024;
  *(_DWORD *)&v344[14] = 468;
  *(_WORD *)&v344[18] = 2048;
  *(void *)&v344[20] = v143;
  *(_WORD *)&v344[28] = 2048;
  *(void *)&v344[30] = a4;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_444:
  uint64_t v296 = 0;
  long long v330 = 0u;
  long long v331 = 0u;
  long long v329 = 0u;
  memset(buf, 0, sizeof(buf));
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)uint64_t v344 = 136315906;
  *(void *)&v344[4] = "operator[]";
  *(_WORD *)&v344[12] = 1024;
  *(_DWORD *)&v344[14] = 468;
  *(_WORD *)&v344[18] = 2048;
  *(void *)&v344[20] = v143;
  *(_WORD *)&v344[28] = 2048;
  *(void *)&v344[30] = a4;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_445:
  LODWORD(v212) = 0;
LABEL_446:
  if (v144 != v212)
  {
    uint64_t v215 = v212;
    uint64_t v216 = v310;
    while (1)
    {
      uint64_t v217 = v216 + 56 * v215;
      uint64_t v218 = (void **)(v217 + 16);
      int v219 = *(unsigned __int8 *)(v217 + 12);
      if (v219 == 10) {
        break;
      }
      if (v219 == 11)
      {
        uint64_t v220 = re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshSmoothComponent>(a1);
        __int16 v221 = *(_anonymous_namespace_ **)(a3 + 104);
        uint64_t v222 = *a2;
        uint64_t v223 = a2[1];
        uint64_t v224 = *v218;
        re *v218 = 0;
        uint64_t v225 = re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>::assetType();
        uint64_t v226 = re::ImportAssetTable::addAsset(v221, v222, v223, v224, (re **)v225);
        if (*(unsigned char *)(v226 + 8)) {
          uint64_t v227 = *(re::AssetPath **)(v226 + 16);
        }
        else {
          uint64_t v227 = (re::AssetPath *)(v226 + 9);
        }
        uint64_t v234 = (re::DynamicString *)(v220 + 112);
LABEL_458:
        a4 = v279;
      }
      if (v144 <= (int)v212 + 1) {
        int v235 = v212 + 1;
      }
      else {
        int v235 = v144;
      }
      while (1)
      {
        uint64_t v215 = (v212 + 1);
        if (v235 - 1 == v212) {
          break;
        }
        LODWORD(v212) = v212 + 1;
        int v236 = v215;
        if ((*(_DWORD *)(v216 + 56 * v215 + 8) & 0x80000000) != 0) {
          goto LABEL_466;
        }
      }
      int v236 = v235;
LABEL_466:
      LODWORD(v212) = v236;
      if (v144 == v236) {
        goto LABEL_467;
      }
    }
    uint64_t v228 = re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshOffsetsComponent>(a1);
    uint64_t v229 = *(_anonymous_namespace_ **)(a3 + 104);
    uint64_t v230 = *a2;
    uint64_t v231 = a2[1];
    uint64_t v232 = *v218;
    re *v218 = 0;
    uint64_t v233 = re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>::assetType();
    uint64_t v226 = re::ImportAssetTable::addAsset(v229, v230, v231, v232, (re **)v233);
    if (*(unsigned char *)(v226 + 8)) {
      uint64_t v227 = *(re::AssetPath **)(v226 + 16);
    }
    else {
      uint64_t v227 = (re::AssetPath *)(v226 + 9);
    }
    uint64_t v234 = (re::DynamicString *)(v228 + 72);
    goto LABEL_458;
  }
LABEL_467:
  unint64_t v237 = v350;
  if (*((void *)v350 + 7))
  {
    unsigned int v238 = (re::MeshDeformationAsset *)re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>(a1);
    uint64_t v239 = (re::MeshDeformationAsset *)((char *)v238 + 32);
    long long v240 = *(_anonymous_namespace_ **)(a3 + 104);
    uint64_t v241 = *a2;
    uint64_t v242 = a2[1];
    int32x2_t v243 = v350;
    long long v350 = 0;
    __n128 v244 = re::MeshDeformationAsset::assetType(v238);
    uint64_t v245 = re::ImportAssetTable::addAsset(v240, v241, v242, v243, (re **)v244);
    if (*(unsigned char *)(v245 + 8)) {
      unint64_t v246 = *(re::AssetPath **)(v245 + 16);
    }
    else {
      unint64_t v246 = (re::AssetPath *)(v245 + 9);
    }
  }
  else
  {
    re::DynamicArray<re::DeformationStackDefinition>::deinit((uint64_t)v350);
    int v247 = (_anonymous_namespace_ *)re::DynamicArray<re::MeshDeformationIndex>::deinit((uint64_t)v237 + 40);
    uint64_t v248 = v350;
    if (*((void *)v350 + 7))
    {
      uint64_t v249 = (re::MeshDeformationAsset *)re::ecs2::EntityAssetData::addComponent<re::ecs2::MeshDeformationComponent>(a1);
      id v250 = (re::MeshDeformationAsset *)((char *)v249 + 32);
      uint64_t v251 = *(_anonymous_namespace_ **)(a3 + 104);
      uint64_t v252 = *a2;
      uint64_t v253 = a2[1];
      v254 = v350;
      long long v350 = 0;
      uint64_t v255 = re::MeshDeformationAsset::assetType(v249);
      uint64_t v256 = re::ImportAssetTable::addAsset(v251, v252, v253, v254, (re **)v255);
      if (*(unsigned char *)(v256 + 8)) {
        id v257 = *(re::AssetPath **)(v256 + 16);
      }
      else {
        id v257 = (re::AssetPath *)(v256 + 9);
      }
      a4 = v279;
    }
    if (a4[12])
    {
      re::ecs2::EntityAssetData::addComponent<re::ecs2::SkeletalPoseComponent>(a1);
      re::ecs2::EntityAssetData::addComponent<re::ecs2::RigComponent>(a1);
    }
    uint64_t v259 = a4[2];
    if (v259)
    {
      uint64_t v260 = (void *)(a4[4] + 128);
      uint64_t v261 = v259 << 9;
      while (!*v260)
      {
        v260 += 64;
        v261 -= 512;
        if (!v261) {
          goto LABEL_475;
        }
      }
      re::ecs2::EntityAssetData::addComponent<re::ecs2::BlendShapeWeightsComponent>(a1);
    }
  }
LABEL_475:
  re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::deinit((uint64_t *)&v309);
  return std::unique_ptr<re::MeshDeformationAsset,std::function<void ()(re::MeshDeformationAsset*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v350);
}

re *re::anonymous namespace'::wireupVertexCacheAnimations(re *result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7)
{
  BOOL v103 = result;
  uint64_t v127 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a4 + 56);
  if (!v9) {
    return result;
  }
  uint64_t v11 = a4;
  uint64_t v13 = *(void *)(a4 + 72);
  uint64_t v14 = v13 + 96 * v9;
  uint64_t v15 = a5 + 24;
  uint64_t v105 = v14;
  int v106 = (re *)((char *)result + 32);
  uint64_t v104 = a5 + 24;
  do
  {
    unint64_t v16 = *(unsigned int *)(v13 + 80);
    unint64_t v17 = *(void *)(a5 + 40);
    if (v17 <= v16) {
      goto LABEL_80;
    }
    unint64_t i = v16 >> 3;
    uint64_t v8 = *(re::AssetPath **)(a5 + 8);
    if ((unint64_t)v8 <= v16 >> 3) {
      goto LABEL_81;
    }
    uint64_t v18 = *(void *)(a5 + 32);
    if (*(unsigned char *)(a5 + 16)) {
      uint64_t v18 = v15;
    }
    uint64_t v19 = *(void *)(*(void *)(v18 + 8 * i) + 8 * (v16 & 7));
    unint64_t v20 = *(void *)(v19 + 16);
    if (!v20) {
      goto LABEL_62;
    }
    unint64_t i = *(void *)(v11 + 16);
    if (i <= v16) {
      goto LABEL_82;
    }
    unint64_t v21 = *(void *)(v11 + 32) + (v16 << 9);
    if (*(void *)(v21 + 208) != 1) {
      goto LABEL_62;
    }
    unint64_t v16 = *(void *)(v21 + 224);
    uint64_t v22 = re::globalAllocators(result);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 120, 8);
    *(_OWORD *)(v23 + 8) = 0u;
    *(_OWORD *)(v23 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
    *(_OWORD *)(v23 + 40) = 0u;
    *(void *)(v23 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
    *(void *)uint64_t v23 = &unk_26E6D8A48;
    *(void *)(v23 + 16) = 0;
    *(void *)(v23 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = "";
    *(void *)(v23 + 40) = "";
    *(unsigned char *)(v23 + 49) = 0;
    *(_DWORD *)(v23 + 52) = 1023969417;
    *(_OWORD *)(v23 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(void *)(v23 + 112) = 0;
    v122.n128_u64[0] = (unint64_t)&unk_26E6DFA48;
    *((void *)&v123 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v122;
    *(void *)&v118[2] = &v114[8];
    *(void *)id v114 = v23;
    *(void *)&v114[8] = &unk_26E6DFA48;
    std::__function::__value_func<void ()(re::VertexCacheAsset *)>::~__value_func[abi:nn180100](&v122);
    v122.n128_u8[0] = 1;
    re::StringID::StringID((re::StringID *)&v122.n128_i8[8], (const StringID *)v13);
    re::StringID::StringID((re::StringID *)((char *)&v123 + 8), (const StringID *)(v16 + 72));
    unint64_t v24 = *(void **)v114;
    *(unsigned char *)(*(void *)v114 + 8) = v122.n128_u8[0];
    unint64_t v25 = v122.n128_u64[1];
    uint64_t v26 = v123;
    v122.n128_u64[1] = 0;
    *(void *)&long long v123 = "";
    uint64_t v27 = v24[2];
    uint64_t v28 = v24[3];
    uint64_t v24[2] = v25;
    v24[3] = v26;
    *(void *)unint64_t v119 = v25 & 0xFFFFFFFFFFFFFFFELL | v27 & 1;
    *(void *)&v119[8] = v28;
    re::StringID::destroyString((re::StringID *)v119);
    uint64_t v29 = *((void *)&v123 + 1);
    uint64_t v30 = v124;
    *((void *)&v123 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    *(void *)&long long v124 = "";
    uint64_t v31 = v24[4];
    uint64_t v32 = v24[5];
    v24[4] = v29;
    v24[5] = v30;
    *(void *)unint64_t v119 = v29 & 0xFFFFFFFFFFFFFFFELL | v31 & 1;
    *(void *)&v119[8] = v32;
    re::StringID::destroyString((re::StringID *)v119);
    re::StringID::destroyString((re::StringID *)((char *)&v123 + 8));
    re::StringID::destroyString((re::StringID *)&v122.n128_i8[8]);
    uint64_t v33 = *(void *)v114;
    *(unsigned char *)(*(void *)v114 + 48) = 1;
    *(float *)(v33 + 52) = a7;
    *(_DWORD *)(v33 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(_DWORD *)v19;
    *(void *)(v33 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v20;
    *(void *)(v33 + 80) = 12;
    uint64_t v34 = v33 + 88;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    for (unint64_t i = 0; i != v20; ++i)
    {
      uint64_t v8 = *(re::AssetPath **)(v19 + 16);
      if ((unint64_t)v8 <= i) {
        goto LABEL_78;
      }
      uint64_t v8 = *(re::AssetPath **)(*(void *)v114 + 96);
      if ((unint64_t)v8 <= i)
      {
LABEL_79:
        uint64_t v111 = 0;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        __n128 v122 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v119 = 136315906;
        *(void *)&v119[4] = "operator[]";
        *(_WORD *)&v119[12] = 1024;
        *(_DWORD *)&v119[14] = 468;
        *(_WORD *)&v119[18] = 2048;
        *(void *)&v119[20] = i;
        __int16 v120 = 2048;
        unint64_t v121 = (unint64_t)v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_80:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, v16, v17);
        _os_crash();
        __break(1u);
LABEL_81:
        *(void *)unint64_t v119 = 0;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        __n128 v122 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)id v114 = 136315906;
        *(void *)&v114[4] = "operator[]";
        *(_WORD *)&v114[12] = 1024;
        *(_DWORD *)&v114[14] = 866;
        __int16 v115 = 2048;
        unint64_t v116 = i;
        __int16 v117 = 2048;
        *(void *)unint64_t v118 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_82:
        *(void *)unint64_t v119 = 0;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        __n128 v122 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)id v114 = 136315906;
        *(void *)&v114[4] = "operator[]";
        *(_WORD *)&v114[12] = 1024;
        *(_DWORD *)&v114[14] = 789;
        __int16 v115 = 2048;
        unint64_t v116 = v16;
        __int16 v117 = 2048;
        *(void *)unint64_t v118 = i;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_83:
        uint64_t v111 = 0;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        __n128 v122 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v119 = 136315906;
        *(void *)&v119[4] = "operator[]";
        *(_WORD *)&v119[12] = 1024;
        *(_DWORD *)&v119[14] = 789;
        *(_WORD *)&v119[18] = 2048;
        *(void *)&v119[20] = i;
        __int16 v120 = 2048;
        unint64_t v121 = v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_84;
      }
      uint64_t v39 = (_OWORD *)(*(void *)(v19 + 24) + v38);
      double v40 = (_OWORD *)(*(void *)(*(void *)v114 + 104) + v37);
      long long v41 = v39[1];
      *double v40 = *v39;
      v40[1] = v41;
      v38 += 64;
      v37 += 32;
    }
    uint64_t v42 = *(void *)(v16 + 16);
    if (!v42) {
      goto LABEL_23;
    }
    unint64_t v43 = (unint64_t *)(*(void *)(v16 + 32) + 48);
    uint64_t v44 = 80 * v42;
    while (1)
    {
      uint64_t v45 = (*(v43 - 5) & 1) != 0 ? (const char *)*(v43 - 4) : (char *)v43 - 39;
      uint64_t v36 = strcmp(v45, "originalModelVertexIndex");
      if (!v36) {
        break;
      }
      v43 += 10;
      v44 -= 80;
      if (!v44) {
        goto LABEL_23;
      }
    }
    unint64_t v46 = *v43;
    if (*v43 <= 3)
    {
LABEL_23:
      if (*(void *)(v19 + 16))
      {
        uint64_t v47 = *(void *)(*(void *)(v19 + 24) + 40);
        uint64_t v48 = 12 * v20 * v47;
        uint64_t v11 = a4;
        if (v48)
        {
          uint64_t v49 = *(void *)v114;
          *(void *)(*(void *)v114 + 72) = v47;
          *(unsigned char *)(v49 + 49) = 30;
          v122.n128_u64[0] = (unint64_t)objc_msgSend(*(id *)(a3 + 8), sel_newBufferWithLength_options_, v48, 0);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(*(void *)v114 + 112), (void **)&v122);
          if (v122.n128_u64[0]) {

          }
          uint64_t v36 = (uint64_t)objc_msgSend(*(id *)(*(void *)v114 + 112), sel_contents);
          uint64_t v50 = *(void *)(v19 + 16);
          if (v50)
          {
            uint64_t v51 = *(void *)(v19 + 24);
            uint64_t v52 = v51 + (v50 << 6);
            do
            {
              uint64_t v53 = *(void *)(v51 + 40);
              if (v53)
              {
                uint64_t v54 = (_DWORD *)(*(void *)(v51 + 48) + 8);
                uint64_t v55 = 16 * v53;
                do
                {
                  int v56 = *v54;
                  uint64_t v57 = v36 + 12;
                  *(void *)uint64_t v36 = *((void *)v54 - 1);
                  *(_DWORD *)(v36 + 8) = v56;
                  v54 += 4;
                  v36 += 12;
                  v55 -= 16;
                }
                while (v55);
                uint64_t v36 = v57;
              }
              v51 += 64;
            }
            while (v51 != v52);
          }
        }
        goto LABEL_34;
      }
LABEL_84:
      uint64_t v111 = 0;
      long long v125 = 0u;
      long long v126 = 0u;
      long long v123 = 0u;
      long long v124 = 0u;
      __n128 v122 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v119 = 136315906;
      *(void *)&v119[4] = "operator[]";
      *(_WORD *)&v119[12] = 1024;
      *(_DWORD *)&v119[14] = 476;
      *(_WORD *)&v119[18] = 2048;
      *(void *)&v119[20] = 0;
      __int16 v120 = 2048;
      unint64_t v121 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_85:
      std::__throw_bad_function_call[abi:nn180100]();
    }
    unint64_t v89 = v46 >> 2;
    uint64_t v90 = 12 * v20 * (v46 >> 2);
    uint64_t v11 = a4;
    if (v90)
    {
      char v91 = (unsigned int *)v43[2];
      uint64_t v92 = *(void *)v114;
      *(void *)(*(void *)v114 + 72) = v89;
      *(unsigned char *)(v92 + 49) = 30;
      v122.n128_u64[0] = (unint64_t)objc_msgSend(*(id *)(a3 + 8), sel_newBufferWithLength_options_, v90, 0);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(*(void *)v114 + 112), (void **)&v122);
      if (v122.n128_u64[0]) {

      }
      uint64_t v36 = (uint64_t)objc_msgSend(*(id *)(*(void *)v114 + 112), sel_contents);
      uint64_t v93 = *(void *)(v19 + 16);
      if (v93)
      {
        uint64_t v94 = *(void *)(v19 + 24);
        uint64_t v95 = v94 + (v93 << 6);
        if (v89 <= 1) {
          uint64_t v96 = 1;
        }
        else {
          uint64_t v96 = v89;
        }
        do
        {
          unint64_t v16 = *(void *)(v94 + 40);
          uint64_t v97 = v91;
          uint64_t v98 = v96;
          do
          {
            unsigned int v99 = *v97++;
            unint64_t i = v99;
            if (v16 <= v99)
            {
              uint64_t v111 = 0;
              long long v125 = 0u;
              long long v126 = 0u;
              long long v123 = 0u;
              long long v124 = 0u;
              __n128 v122 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unint64_t v119 = 136315906;
              *(void *)&v119[4] = "operator[]";
              *(_WORD *)&v119[12] = 1024;
              *(_DWORD *)&v119[14] = 476;
              *(_WORD *)&v119[18] = 2048;
              *(void *)&v119[20] = i;
              __int16 v120 = 2048;
              unint64_t v121 = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_78:
              uint64_t v111 = 0;
              long long v125 = 0u;
              long long v126 = 0u;
              long long v123 = 0u;
              long long v124 = 0u;
              __n128 v122 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unint64_t v119 = 136315906;
              *(void *)&v119[4] = "operator[]";
              *(_WORD *)&v119[12] = 1024;
              *(_DWORD *)&v119[14] = 476;
              *(_WORD *)&v119[18] = 2048;
              *(void *)&v119[20] = i;
              __int16 v120 = 2048;
              unint64_t v121 = (unint64_t)v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_79;
            }
            uint64_t v100 = *(void *)(v94 + 48) + 16 * i;
            int v101 = *(_DWORD *)(v100 + 8);
            uint64_t v102 = v36 + 12;
            *(void *)uint64_t v36 = *(void *)v100;
            *(_DWORD *)(v36 + 8) = v101;
            v36 += 12;
            --v98;
          }
          while (v98);
          v94 += 64;
          uint64_t v36 = v102;
        }
        while (v94 != v95);
      }
    }
LABEL_34:
    if (!*(void *)v106)
    {
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v106, 0);
      ++*((_DWORD *)v103 + 14);
    }
    uint64_t v58 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                + 7)
                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 248, 0);
    re::make::shared::inplace<re::ecs2::VertexCacheComponent>(v58, v119);
    unint64_t v59 = *(void **)v119;
    unint64_t v60 = *((void *)re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
          + 3) >> 1;
    *(void *)unint64_t v119 = 0;
    v122.n128_u64[0] = v60;
    v122.n128_u64[1] = (unint64_t)v59;
    LOBYTE(v123) = 1;
    re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v106, &v122);
    if (*(void *)v119) {

    }
    unint64_t i = v59[6];
    __n128 v122 = 0uLL;
    *(void *)&long long v123 = 0;
    re::DynamicArray<re::AssetHandle>::add(v59 + 4, (uint64_t *)&v122);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v122);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v59 + 9), (float *)v19);
    unint64_t v16 = v59[6];
    if (v16 <= i) {
      goto LABEL_83;
    }
    uint64_t v62 = v59[8];
    uint64_t v63 = *(_anonymous_namespace_ **)(a3 + 104);
    uint64_t v65 = *a2;
    uint64_t v64 = a2[1];
    float v66 = *(void **)v114;
    *(void *)id v114 = 0;
    uint64_t v67 = re::VertexCacheAsset::assetType(v61);
    uint64_t v68 = re::ImportAssetTable::addAsset(v63, v65, v64, v66, (re **)v67);
    if (*(unsigned char *)(v68 + 8)) {
      uint64_t v69 = *(re::AssetPath **)(v68 + 16);
    }
    else {
      uint64_t v69 = (re::AssetPath *)(v68 + 9);
    }
    uint64_t v70 = (re *)re::DynamicString::format((re::DynamicString *)"VertexCacheTimeAnim[%zu]", (re::DynamicString *)v119, i);
    char v71 = re::globalAllocators(v70);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v71[2] + 32))(v71[2], 120, 8);
    uint64_t v73 = re::TimelineAssetData::TimelineAssetData(v72, 11);
    *(unsigned char *)(v73 + 72) = 0;
    *(void *)(v73 + 80) = 0x3FF0000000000000;
    *(unsigned char *)(v73 + 88) = 0;
    *(unsigned char *)(v73 + 96) = 0;
    *(unsigned char *)(v73 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    *(void *)(v73 + 112) = 0;
    *(void *)uint64_t v73 = &unk_26E6D3618;
    if (v119[8]) {
      long long v74 = *(const char **)&v119[16];
    }
    else {
      long long v74 = &v119[9];
    }
    uint64_t v111 = 0;
    int v112 = "";
    uint64_t v75 = v111;
    long long v76 = v112;
    uint64_t v111 = 0;
    int v112 = "";
    uint64_t v77 = *(void *)(v72 + 24);
    unint64_t v78 = *(void *)(v72 + 32);
    *(void *)(v72 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v75;
    *(void *)(v72 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v76;
    v122.n128_u64[0] = v75 & 0xFFFFFFFFFFFFFFFELL | v77 & 1;
    v122.n128_u64[1] = v78;
    re::StringID::destroyString((re::StringID *)&v122);
    re::StringID::destroyString((re::StringID *)&v111);
    float v79 = *(float *)v19;
    *(double *)(v72 + 80) = (float)(*(float *)(v19 + 4) - *(float *)v19);
    if (!*(unsigned char *)(v72 + 88)) {
      *(unsigned char *)(v72 + 88) = 1;
    }
    *(float *)(v72 + 92) = v79;
    int v80 = *(_DWORD *)(v19 + 4);
    if (!*(unsigned char *)(v72 + 96)) {
      *(unsigned char *)(v72 + 96) = 1;
    }
    *(_DWORD *)(v72 + 100) = v80;
    re::DynamicString::format((re::DynamicString *)"VertexCache.vertexCacheTimes[%zu]", (re::DynamicString *)&v122, i);
    re::DynamicString::operator=((re::DynamicString *)(v72 + 40), (re::DynamicString *)&v122);
    if (v122.n128_u64[0] && (v122.n128_u8[8] & 1) != 0) {
      (*(void (**)(void))(*(void *)v122.n128_u64[0] + 40))();
    }
    uint64_t v111 = 0;
    int v112 = 0;
    uint64_t v113 = 0;
    long long v82 = *(_anonymous_namespace_ **)(a3 + 104);
    uint64_t v83 = *a2;
    uint64_t v84 = a2[1];
    unint64_t i = (unint64_t)re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v72, v81);
    long long v85 = re::TimelineAsset::assetType((re::TimelineAsset *)i);
    uint64_t v86 = re::ImportAssetTable::addAsset(v82, v83, v84, (void *)i, (re **)v85);
    if (*(unsigned char *)(v86 + 8)) {
      uint64_t v8 = *(re::AssetPath **)(v86 + 16);
    }
    else {
      uint64_t v8 = (re::AssetPath *)(v86 + 9);
    }
    unint64_t v87 = *(void *)(v72 + 80);
    v122.n128_f64[0] = *(float *)v19;
    v122.n128_u64[1] = v87;
    re::AssetHandle::AssetHandle((re::AssetHandle *)&v123, (const re::AssetHandle *)&v111);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v123);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v111);
    uint64_t v14 = v105;
    if (*(void *)v119)
    {
      if (v119[8]) {
        (*(void (**)(void))(**(void **)v119 + 40))();
      }
    }
    unint64_t v88 = *(void *)v114;
    *(void *)id v114 = 0;
    if (v88)
    {
      v122.n128_u64[0] = v88;
      if (!*(void *)&v118[2]) {
        goto LABEL_85;
      }
      (*(void (**)(void, __n128 *))(**(void **)&v118[2] + 48))(*(void *)&v118[2], &v122);
    }
    double result = (re *)std::__function::__value_func<void ()(re::VertexCacheAsset *)>::~__value_func[abi:nn180100](&v114[8]);
    uint64_t v15 = v104;
LABEL_62:
    v13 += 96;
  }
  while (v13 != v14);
  return result;
}

uint64_t re::TimelineGroupBuilder::createTimelineAsset(re::TimelineGroupBuilder *this, const char *a2, const char *a3)
{
  re::DynamicString::format((re::DynamicString *)"%s", (re::DynamicString *)&v124, a3);
  unint64_t v5 = v125;
  uint64_t v6 = v126;
  if (v125) {
    uint64_t v7 = v126;
  }
  else {
    uint64_t v7 = (char *)&v125 + 1;
  }
  if (v7)
  {
    unint64_t v8 = v125 >> 1;
    if ((v125 & 1) == 0) {
      unint64_t v8 = v125 >> 1;
    }
    if (v8)
    {
      do
      {
        if (*v7 == 32)
        {
          *uint64_t v7 = 95;
          unint64_t v5 = v125;
          uint64_t v6 = v126;
        }
        ++v7;
        if (v5) {
          uint64_t v9 = v6;
        }
        else {
          uint64_t v9 = (char *)&v125 + 1;
        }
        unint64_t v10 = v5 >> 1;
        if ((v5 & 1) == 0) {
          unint64_t v10 = v5 >> 1;
        }
      }
      while (v7 != &v9[v10]);
    }
  }
  if (a2[16]) {
    uint64_t v11 = (const char *)*((void *)a2 + 3);
  }
  else {
    uint64_t v11 = a2 + 17;
  }
  uint64_t v102 = this;
  if (v5) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = (char *)&v125 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"%s_%s", (re::DynamicString *)&v120, v11, v12);
  re::TimelineAssetData::TimelineAssetData((uint64_t)v111, 2);
  uint64_t v119 = 0;
  v111[0] = &unk_26E6CEC28;
  uint64_t v116 = 0;
  long long v117 = 0uLL;
  int v118 = 0;
  uint64_t v103 = *((void *)a2 + 12);
  if (v103)
  {
    uint64_t v105 = 0;
    for (unint64_t i = 0; i != v103; ++i)
    {
      uint64_t v14 = re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::operator[]((uint64_t)(a2 + 56), i);
      *(void *)&long long v109 = 0;
      *((void *)&v109 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
      unint64_t v16 = *((void *)&v109 + 1);
      unint64_t v15 = v109;
      *(void *)&long long v109 = 0;
      *((void *)&v109 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
      unsigned long long v17 = v113;
      unsigned long long v113 = __PAIR128__(v16, v15);
      *(void *)&long long v129 = v15 & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
      *((void *)&v129 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *((void *)&v17 + 1);
      re::StringID::destroyString((re::StringID *)&v129);
      re::StringID::destroyString((re::StringID *)&v109);
      unint64_t v20 = *((void *)a2 + 2);
      unint64_t v21 = (const char *)*((void *)a2 + 3);
      if ((v20 & 1) == 0) {
        unint64_t v21 = a2 + 17;
      }
      uint64_t v22 = (const char *)(v20 >> 1);
      uint64_t v23 = (const char *)(v20 >> 1);
      if (*((void *)a2 + 2)) {
        unint64_t v24 = v22;
      }
      else {
        unint64_t v24 = v23;
      }
      int v106 = (re *)v21;
      unint64_t v107 = (unint64_t)v24;
      *((void *)&v129 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      long long v130 = 0uLL;
      if (v24) {
        size_t v25 = (size_t)(v24 + 1);
      }
      else {
        size_t v25 = 0;
      }
      re::DynamicString::setCapacity(&v129, v25);
      re::DynamicString::operator=((re::DynamicString *)&v129, (uint64_t)&v106);
      BOOL v26 = re::DynamicString::operator!=(v14 + 32, (uint64_t)&v129);
      uint64_t v27 = (re *)v129;
      if (void)v129 && (BYTE8(v129)) {
        uint64_t v27 = (re *)(*(uint64_t (**)(void))(*(void *)v129 + 40))();
      }
      if (v26)
      {
        unint64_t v28 = *((void *)a2 + 2);
        if (v28) {
          unint64_t v29 = v28 >> 1;
        }
        else {
          unint64_t v29 = v28 >> 1;
        }
        uint64_t v30 = (_anonymous_namespace_ *)re::DynamicString::operator[](v14 + 32, v29);
        unint64_t v31 = *((void *)a2 + 2);
        if (v31) {
          unint64_t v32 = v31 >> 1;
        }
        else {
          unint64_t v32 = v31 >> 1;
        }
        if (*(unsigned char *)v30 == 47) {
          unint64_t v33 = v32 + 1;
        }
        else {
          unint64_t v33 = v32;
        }
        unint64_t v34 = *(void *)(v14 + 40);
        uint64_t v35 = *(void *)(v14 + 48);
        if ((v34 & 1) == 0) {
          uint64_t v35 = v14 + 41;
        }
        uint64_t v36 = v35 + v33;
        unint64_t v37 = v34 >> 1;
        unint64_t v38 = v34 >> 1;
        if ((*(void *)(v14 + 40) & 1) == 0) {
          unint64_t v37 = v38;
        }
        size_t v39 = v35 + v37 - v36;
        long long v129 = 0u;
        long long v130 = 0u;
        double v40 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v129, 0);
        uint64_t v127 = v36;
        size_t v128 = v39;
        re::DynamicString::setCapacity(&v106, v39);
        while (v128)
        {
          v131[0] = "/";
          v131[1] = 1;
          re::StringSlice::findFirstOf(&v127, (uint64_t)v131, 0, (uint64_t)&v132);
          if ((_BYTE)v132)
          {
            unint64_t v41 = v133;
            uint64_t v42 = re::Slice<char>::range(&v127, 0, v133);
            unint64_t v44 = v43;
            uint64_t v127 = re::Slice<char>::range(&v127, v41 + 1, v128);
            size_t v128 = v45;
          }
          else
          {
            uint64_t v42 = v127;
            unint64_t v44 = v128;
            uint64_t v127 = 0;
            size_t v128 = 0;
          }
          uint64_t v132 = v42;
          unint64_t v133 = v44;
          re::internal::escapeBindingKey(&v132, (re::DynamicString *)&v129);
          if (v107) {
            unint64_t v46 = v107 >> 1;
          }
          else {
            unint64_t v46 = v107 >> 1;
          }
          if (v46) {
            re::DynamicString::append((re::DynamicString *)&v106, ".", 1uLL);
          }
          if (BYTE8(v129)) {
            uint64_t v47 = (const char *)v130;
          }
          else {
            uint64_t v47 = (char *)&v129 + 9;
          }
          re::DynamicString::appendf((re::DynamicString *)&v106, "entities[%s]", v47);
        }
        if (void)v129 && (BYTE8(v129)) {
          (*(void (**)(void))(*(void *)v129 + 40))();
        }
        re::DynamicString::operator=((re::DynamicString *)&v109, (re::DynamicString *)&v106);
        uint64_t v27 = v106;
        if (v106 && (v107 & 1) != 0) {
          uint64_t v27 = (re *)(*(uint64_t (**)(void))(*(void *)v106 + 40))();
        }
      }
      if (BYTE8(v109)) {
        uint64_t v48 = *((void *)&v109 + 1) >> 1;
      }
      else {
        uint64_t v48 = BYTE8(v109) >> 1;
      }
      if (!v48
        && ((float v62 = *(float *)(v14 + 64), v63 = *((float *)a2 + 10), v62 == v63)
         || vabds_f32(v62, v63) < (float)((float)((float)(fabsf(v62) + fabsf(v63)) + 1.0) * 0.00001))
        && ((float v64 = *(float *)(v14 + 68), v65 = *((float *)a2 + 11), v64 == v65)
         || vabds_f32(v64, v65) < (float)((float)((float)(fabsf(v64) + fabsf(v65)) + 1.0) * 0.00001)))
      {
        re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)&v116, (re::AssetHandle *)(v14 + 72));
      }
      else
      {
        uint64_t v49 = re::globalAllocators(v27);
        uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v49[2] + 32))(v49[2], 176, 8);
        uint64_t v51 = re::TimelineAssetData::TimelineAssetData(v50, 1);
        *(void *)uint64_t v51 = &unk_26E6CEBD0;
        *(unsigned char *)(v51 + 112) = 0;
        *(void *)(v51 + 128) = 0;
        *(unsigned char *)(v51 + 136) = 0;
        *(void *)(v51 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
        *(unsigned char *)(v51 + 152) = 0;
        *(void *)(v51 + 80) = 0;
        *(void *)(v51 + 88) = 0;
        *(unsigned char *)(v51 + 96) = 0;
        *(void *)(v51 + 72) = 0;
        *(_DWORD *)(v50 + 168) = 1065353216;
        *(unsigned char *)(v50 + 172) = 0;
        re::AssetHandle::operator=(v51 + 72, (uint64_t *)(v14 + 72));
        *(double *)(v50 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = (float)(*(float *)(v14 + 64) - *((float *)a2 + 10));
        *(unsigned char *)(v50 + 16) = 3;
        re::DynamicString::operator=((re::DynamicString *)(v50 + 40), (re::DynamicString *)&v109);
        uint64_t v52 = v123;
        if ((v121 & 1) == 0) {
          uint64_t v52 = v122;
        }
        uint64_t v53 = *(void *)(v14 + 16);
        if ((*(void *)(v14 + 8) & 1) == 0) {
          uint64_t v53 = v14 + 9;
        }
        re::DynamicString::format((re::DynamicString *)"%s_%s[%zu]", (re::DynamicString *)&v129, v52, v53, v105);
        uint64_t v54 = *(_anonymous_namespace_ **)a2;
        if (BYTE8(v129)) {
          uint64_t v55 = (const char *)v130;
        }
        else {
          uint64_t v55 = (char *)&v129 + 9;
        }
        size_t v56 = strlen(v55);
        TimelineAsset = re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v50, v57);
        unint64_t v59 = re::TimelineAsset::assetType((re::TimelineAsset *)TimelineAsset);
        uint64_t v60 = re::ImportAssetTable::addAsset(v54, (uint64_t)v55, v56, TimelineAsset, (re **)v59);
        unint64_t v107 = 0;
        uint64_t v108 = 0;
        int v106 = 0;
        if (*(unsigned char *)(v60 + 8)) {
          uint64_t v61 = *(re::AssetPath **)(v60 + 16);
        }
        else {
          uint64_t v61 = (re::AssetPath *)(v60 + 9);
        }
        re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)&v116, (re::AssetHandle *)&v106);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v106);
        if (void)v129 && (BYTE8(v129)) {
          (*(void (**)(void))(*(void *)v129 + 40))();
        }
        ++v105;
      }
      if (void)v109 && (BYTE8(v109)) {
        (*(void (**)(void))(*(void *)v109 + 40))();
      }
    }
  }
  float v66 = *(_anonymous_namespace_ **)a2;
  if (v121) {
    uint64_t v67 = v123;
  }
  else {
    uint64_t v67 = v122;
  }
  uint64_t v68 = (re *)strlen(v67);
  uint64_t v69 = re::globalAllocators(v68);
  uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v69[2] + 32))(v69[2], 112, 8);
  *(void *)uint64_t v70 = &unk_26E6D3730;
  char v71 = v112;
  *(void *)(v70 + 8) = v111[1];
  *(unsigned char *)(v70 + 16) = v71;
  char v72 = v113;
  *(void *)(v70 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(v70 + 24) & 0xFFFFFFFFFFFFFFFELL | v113 & 1;
  *(void *)(v70 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v113 & 0xFFFFFFFFFFFFFFFELL | v72 & 1;
  *(void *)(v70 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *((void *)&v113 + 1);
  *(void *)&unsigned long long v113 = 0;
  *((void *)&v113 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
  *(_OWORD *)(v70 + 40) = 0u;
  *(_OWORD *)(v70 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(void *)(v70 + 40) = v114;
  uint64_t v73 = *((void *)&v114 + 1);
  *(_OWORD *)(v70 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v115;
  long long v115 = 0uLL;
  uint64_t v74 = *(void *)(v70 + 48);
  *(void *)(v70 + 48) = v73;
  *(void *)&long long v114 = 0;
  *((void *)&v114 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v74;
  *(void *)uint64_t v70 = &unk_26E6CEC28;
  *(void *)(v70 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_DWORD *)(v70 + 96) = 0;
  *(void *)(v70 + 88) = 0;
  *(_OWORD *)(v70 + 72) = 0u;
  *(void *)(v70 + 72) = v116;
  uint64_t v116 = 0;
  *(_OWORD *)(v70 + 80) = v117;
  long long v117 = 0u;
  *(void *)(v70 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v119;
  uint64_t v119 = 0;
  ++v118;
  ++*(_DWORD *)(v70 + 96);
  long long v76 = re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v70, v75);
  uint64_t v77 = re::TimelineAsset::assetType((re::TimelineAsset *)v76);
  uint64_t v78 = re::ImportAssetTable::addAsset(v66, (uint64_t)v67, (uint64_t)v68, v76, (re **)v77);
  uint64_t v110 = 0;
  long long v109 = 0u;
  if (*(unsigned char *)(v78 + 8)) {
    float v79 = *(re::AssetPath **)(v78 + 16);
  }
  else {
    float v79 = (re::AssetPath *)(v78 + 9);
  }
  float v81 = *((float *)a2 + 11);
  float v82 = *((float *)a2 + 12);
  if (v81 == v82 || vabds_f32(v81, v82) < (float)((float)((float)(fabsf(v81) + fabsf(v82)) + 1.0) * 0.00001))
  {
    *(_OWORD *)uint64_t v102 = v109;
    long long v109 = 0uLL;
    *((void *)v102 + 2) = v110;
    uint64_t v110 = 0;
  }
  else
  {
    uint64_t v84 = re::globalAllocators(v80);
    uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v84[2] + 32))(v84[2], 176, 8);
    uint64_t v86 = re::TimelineAssetData::TimelineAssetData(v85, 1);
    *(void *)uint64_t v86 = &unk_26E6CEBD0;
    *(unsigned char *)(v86 + 112) = 0;
    *(void *)(v86 + 128) = 0;
    *(unsigned char *)(v86 + 136) = 0;
    *(void *)(v86 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    *(unsigned char *)(v86 + 152) = 0;
    *(void *)(v86 + 80) = 0;
    *(void *)(v86 + 88) = 0;
    *(void *)(v86 + 72) = 0;
    uint64_t v87 = v86 + 72;
    *(unsigned char *)(v86 + 96) = 0;
    *(_DWORD *)(v86 + 168) = 1065353216;
    *(unsigned char *)(v86 + 172) = 0;
    int v106 = 0;
    unint64_t v107 = (unint64_t)"";
    unint64_t v88 = v106;
    unint64_t v89 = v107;
    int v106 = 0;
    unint64_t v107 = (unint64_t)"";
    uint64_t v90 = *(void *)(v85 + 24);
    uint64_t v91 = *(void *)(v85 + 32);
    *(void *)(v85 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v88;
    *(void *)(v85 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v89;
    *(void *)&long long v129 = (unint64_t)v88 & 0xFFFFFFFFFFFFFFFELL | v90 & 1;
    *((void *)&v129 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v91;
    re::StringID::destroyString((re::StringID *)&v129);
    re::StringID::destroyString((re::StringID *)&v106);
    re::AssetHandle::operator=(v87, (uint64_t *)&v109);
    double v92 = (float)(*((float *)a2 + 11) - *((float *)a2 + 10));
    if (!*(unsigned char *)(v85 + 152)) {
      *(unsigned char *)(v85 + 152) = 1;
    }
    *(double *)(v85 + 160) = v92;
    *(unsigned char *)(v85 + 16) = 3;
    if (v121) {
      uint64_t v93 = v123;
    }
    else {
      uint64_t v93 = v122;
    }
    re::DynamicString::format((re::DynamicString *)"%s_Fill", (re::DynamicString *)&v129, v93);
    uint64_t v94 = *(_anonymous_namespace_ **)a2;
    if (BYTE8(v129)) {
      uint64_t v95 = (const char *)v130;
    }
    else {
      uint64_t v95 = (char *)&v129 + 9;
    }
    size_t v96 = strlen(v95);
    uint64_t v98 = re::AssetHelper::makeTimelineAsset((re::AssetHelper *)v85, v97);
    unsigned int v99 = re::TimelineAsset::assetType((re::TimelineAsset *)v98);
    uint64_t v100 = re::ImportAssetTable::addAsset(v94, (uint64_t)v95, v96, v98, (re **)v99);
    *((void *)v102 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    *((void *)v102 + 2) = 0;
    *(void *)uint64_t v102 = 0;
    if (*(unsigned char *)(v100 + 8)) {
      int v101 = *(re::AssetPath **)(v100 + 16);
    }
    else {
      int v101 = (re::AssetPath *)(v100 + 9);
    }
    if (void)v129 && (BYTE8(v129)) {
      (*(void (**)(void))(*(void *)v129 + 40))();
    }
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v109);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v116);
  v111[0] = &unk_26E6D3730;
  if ((void)v114)
  {
    if (BYTE8(v114)) {
      (*(void (**)(void))(*(void *)v114 + 40))();
    }
    long long v114 = 0u;
    long long v115 = 0u;
  }
  re::StringID::destroyString((re::StringID *)&v113);
  if (v120 && (v121 & 1) != 0) {
    (*(void (**)(void))(*(void *)v120 + 40))();
  }
  uint64_t result = v124;
  if (v124 && (v125 & 1) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v124 + 40))();
  }
  return result;
}

void *re::DynamicArray<re::AssetHandle>::insert(void *this, unint64_t a2, uint64_t *a3)
{
  unint64_t v4 = this[2];
  if (v4 + 1 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v6 = this;
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::AssetHandle>::growCapacity(this, v4 + 1);
    unint64_t v4 = v6[2];
  }
  uint64_t v7 = v6[4];
  unint64_t v8 = (uint64_t *)(v7 + 24 * v4);
  if (v4 <= a2)
  {
    uint64_t v18 = v7 + 24 * v4;
    unsigned long long v17 = (uint64_t *)(v18 + 16);
    *unint64_t v8 = 0;
    v8[1] = 0;
    void v8[2] = 0;
    *(void *)(v18 + 8) = a3[1];
    a3[1] = 0;
    uint64_t v19 = *v8;
    *unint64_t v8 = 0;
    *unint64_t v8 = *a3;
    *a3 = v19;
  }
  else
  {
    uint64_t v9 = v7 + 24 * v4;
    v8[1] = 0;
    void v8[2] = 0;
    uint64_t v10 = *(void *)(v9 - 16);
    *unint64_t v8 = *(void *)(v9 - 24);
    *(void *)(v9 - re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
    *(void *)(v9 - 16) = 0;
    uint64_t v11 = *(void *)(v9 + 16);
    uint64_t v12 = *(void *)(v9 - 8);
    *(void *)(v9 + 8) = v10;
    *(void *)(v9 + 16) = v12;
    *(void *)(v9 - 8) = v11;
    uint64_t v13 = 3 * a2;
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,re::AssetHandle *,re::AssetHandle *,re::AssetHandle *,0>((void *)(v6[4] + 8 * v13), (void *)(v6[4] + 24 * v6[2] - 24), (void *)(v6[4] + 24 * v6[2]));
    uint64_t v14 = (uint64_t *)(v6[4] + 8 * v13);
    uint64_t v15 = v14[1];
    v14[1] = a3[1];
    a3[1] = v15;
    uint64_t v16 = *v14;
    *uint64_t v14 = 0;
    *uint64_t v14 = *a3;
    unsigned long long v17 = v14 + 2;
    *a3 = v16;
  }
  uint64_t v20 = *v17;
  *unsigned long long v17 = a3[2];
  a3[2] = v20;
  ++v6[2];
  ++*((_DWORD *)v6 + 6);
  return this;
}

id **re::ecs2::EntityAssetData::addComponent<re::ecs2::AnimationComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (id **)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                    + 7)
                                                                 + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 248, 0);
  unint64_t v4 = re::ecs2::AnimationComponent::AnimationComponent(v3);
  v6.n128_u64[0] = *((void *)re::ecs2::ComponentImpl<re::ecs2::AnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                   + 3) >> 1;
  v6.n128_u64[1] = (unint64_t)v4;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  return v3;
}

re::ecs2::AudioPlayerComponent *re::ecs2::EntityAssetData::addComponent<re::ecs2::AudioPlayerComponent>(_DWORD *a1)
{
  id v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (re::ecs2::AudioPlayerComponent *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AudioPlayerComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                                               + 7)
                                                                                            + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AudioPlayerComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 496, 0);
  unint64_t v4 = re::ecs2::AudioPlayerComponent::AudioPlayerComponent(v3);
  v6.n128_u64[0] = *(void *)((*(uint64_t (**)(re::ecs2::AudioPlayerComponent *))(*(void *)v4 + 40))(v4)
                             + 24) >> 1;
  v6.n128_u64[1] = (unint64_t)v3;
  char v7 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v6);
  return v3;
}

uint64_t re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::createEntityFromImportContext(re::USDImportContext &,re::SceneImportOperation &,unsigned long,re::BucketArray<re::TimelineGroupBuilder *,8ul> &,re::AnimationSceneEntityData &,re::FixedArray<BOOL> &,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> *,BOOL)::TransformedMeshItem,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 640, 0);
          __n128 v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

void *re::BucketArray<re::FixedArray<unsigned short>,16ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::FixedArray<unsigned short>,16ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::FixedArray<unsigned short>,16ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 16 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 384, 0);
          __n128 v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::TimelineGroupBuilder::TimelineGroupBuilder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v8[0] = a3;
  v8[1] = a4;
  *(void *)a1 = a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  if (a4) {
    size_t v6 = a4 + 1;
  }
  else {
    size_t v6 = 0;
  }
  re::DynamicString::setCapacity((void *)(a1 + 8), v6);
  re::DynamicString::operator=((re::DynamicString *)(a1 + 8), (uint64_t)v8);
  *(void *)(a1 + 40) = 0xFF7FFFFF7F7FFFFFLL;
  *(_DWORD *)(a1 + 48) = -8388609;
  *(void *)(a1 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(void *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_DWORD *)(a1 + 72) = 1;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  return a1;
}

void *re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

void *re::make::shared::inplace<re::ecs2::Static3DTextComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(_OWORD *)(a1 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  unint64_t v4 = (void *)(a1 + 128);
  *(_OWORD *)(a1 + 96) = 0u;
  unint64_t v5 = (void *)(a1 + 96);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v6 + 16) = 0;
  *(unsigned char *)(v6 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v6 = &unk_26E6E07A0;
  *(void *)(v6 + 28) = 0x3F8000003E800000;
  *(_DWORD *)(v6 + 36) = 1029;
  *(unsigned char *)(v6 + 40) = 0;
  *(_DWORD *)(v6 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 16843009;
  *(void *)&long long v7 = 0x7F0000007FLL;
  *((void *)&v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0x7F0000007FLL;
  *(int32x4_t *)(v6 + 48) = vdupq_n_s32(0x7F800000u);
  *(_OWORD *)(v6 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v7;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)unint64_t v5 = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  int v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v5, 0);
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)unint64_t v4 = 0u;
  unint64_t v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0x3F8000003E800000;
  *(void *)(a1 + 192) = 0x101010000000405;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  unint64_t v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)(a1 + 216), 0);
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  uint64_t result = re::DynamicString::setCapacity((void *)(a1 + 248), 0);
  *a2 = a1;
  return result;
}

void re::ecs2::Static3DTextComponent::~Static3DTextComponent(re::ecs2::Static3DTextComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::DynamicString::deinit((re::ecs2::Static3DTextComponent *)((char *)this + 248));
  re::DynamicString::deinit((re::ecs2::Static3DTextComponent *)((char *)this + 216));
  re::AssetHandle::~AssetHandle((re::ecs2::Static3DTextComponent *)((char *)this + 160));
  re::DynamicString::deinit((re::ecs2::Static3DTextComponent *)((char *)this + 128));
  re::DynamicString::deinit((re::ecs2::Static3DTextComponent *)((char *)this + 96));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::Static3DTextComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::PrimitiveBoxComponent>@<D0>(ArcSharedObject *a1@<X0>, void *a2@<X8>)
{
  *((_OWORD *)a1 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)&double result = 0x1000100010001;
  *(void *)(v3 + 28) = 0x1000100010001;
  *(_OWORD *)(v3 + 36) = xmmword_234371EE0;
  *(_WORD *)(v3 + 52) = 257;
  *(unsigned char *)(v3 + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_WORD *)(v3 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(unsigned char *)(v3 + 58) = 1;
  *(_OWORD *)(v3 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(void *)(v3 + 112) = 0x1000100010001;
  *(_OWORD *)(v3 + 120) = xmmword_234371EE0;
  *(_WORD *)(v3 + 136) = 257;
  *(unsigned char *)(v3 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = 0;
  *(_WORD *)(v3 + 140) = 1;
  *(void *)uint64_t v3 = &unk_26E6E0130;
  *a2 = v3;
  return result;
}

void re::ecs2::PrimitiveBoxComponent::~PrimitiveBoxComponent(re::ecs2::PrimitiveBoxComponent *this)
{
  *(void *)this = &unk_26E6E01D0;
  unint64_t v2 = (re::ecs2::PrimitiveBoxComponent *)((char *)this + 64);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveBoxComponent *)((char *)this + 88));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6E01D0;
  unint64_t v2 = (re::ecs2::PrimitiveBoxComponent *)((char *)this + 64);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveBoxComponent *)((char *)this + 88));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveBoxComponent,re::GeomBuildBoxOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E01D0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 11));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveBoxComponent,re::GeomBuildBoxOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E01D0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 11));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::PrimitiveCylinderComponent>@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(v3 + 28) = 65544;
  double result = 0.0000305175853;
  *(void *)(v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0x3F0000003F800000;
  *(void *)(v3 + 40) = 0x10101013F000000;
  *(unsigned char *)(v3 + 48) = 0;
  *(_WORD *)(v3 + 52) = 0;
  *(unsigned char *)(v3 + 5re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
  *(_OWORD *)(v3 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_DWORD *)(v3 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 65544;
  *(void *)(v3 + 108) = 0x3F0000003F800000;
  *(void *)(v3 + 116) = 0x10101013F000000;
  *(unsigned char *)(v3 + 1re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_WORD *)(v3 + 128) = 1;
  *(void *)uint64_t v3 = &unk_26E6E0418;
  *a2 = v3;
  return result;
}

void re::ecs2::PrimitiveCylinderComponent::~PrimitiveCylinderComponent(re::ecs2::PrimitiveCylinderComponent *this)
{
  *(void *)this = &unk_26E6E04B8;
  unint64_t v2 = (re::ecs2::PrimitiveCylinderComponent *)((char *)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveCylinderComponent *)((char *)this + 80));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6E04B8;
  unint64_t v2 = (re::ecs2::PrimitiveCylinderComponent *)((char *)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveCylinderComponent *)((char *)this + 80));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveCylinderComponent,re::GeomBuildCylinderOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E04B8;
  unint64_t v2 = (re::AssetHandle *)(a1 + 7);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 10));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveCylinderComponent,re::GeomBuildCylinderOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E04B8;
  unint64_t v2 = (re::AssetHandle *)(a1 + 7);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 10));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::PrimitiveConeComponent>@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(v3 + 28) = 65544;
  double result = 0.0000305175853;
  *(void *)(v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0x3F0000003F800000;
  *(_DWORD *)(v3 + 40) = 65793;
  *(_WORD *)(v3 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(unsigned char *)(v3 + 46) = 1;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_DWORD *)(v3 + 96) = 65544;
  *(void *)(v3 + 100) = 0x3F0000003F800000;
  *(_DWORD *)(v3 + 108) = 65793;
  *(_WORD *)(v3 + 112) = 1;
  *(void *)uint64_t v3 = &unk_26E6E0320;
  *a2 = v3;
  return result;
}

void re::ecs2::PrimitiveConeComponent::~PrimitiveConeComponent(re::ecs2::PrimitiveConeComponent *this)
{
  *(void *)this = &unk_26E6E03C0;
  unint64_t v2 = (re::ecs2::PrimitiveConeComponent *)((char *)this + 48);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveConeComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6E03C0;
  unint64_t v2 = (re::ecs2::PrimitiveConeComponent *)((char *)this + 48);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveConeComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveConeComponent,re::GeomBuildConeOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E03C0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 6);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 9));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveConeComponent,re::GeomBuildConeOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E03C0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 6);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 9));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::PrimitiveSphereComponent>@<D0>(ArcSharedObject *a1@<X0>, void *a2@<X8>)
{
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_WORD *)(v3 + 28) = 8;
  *(_DWORD *)(v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 1056964608;
  *(_WORD *)(v3 + 36) = 257;
  *(unsigned char *)(v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = 0;
  *(_WORD *)(v3 + 40) = 0;
  *(unsigned char *)(v3 + 42) = 1;
  double result = 0.0;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_WORD *)(v3 + 96) = 8;
  *(_DWORD *)(v3 + 100) = 1056964608;
  *(_WORD *)(v3 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 257;
  *(unsigned char *)(v3 + 106) = 0;
  *(_WORD *)(v3 + 108) = 1;
  *(void *)uint64_t v3 = &unk_26E6E0510;
  *a2 = v3;
  return result;
}

void re::ecs2::PrimitiveSphereComponent::~PrimitiveSphereComponent(re::ecs2::PrimitiveSphereComponent *this)
{
  *(void *)this = &unk_26E6E05B0;
  unint64_t v2 = (re::ecs2::PrimitiveSphereComponent *)((char *)this + 48);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveSphereComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6E05B0;
  unint64_t v2 = (re::ecs2::PrimitiveSphereComponent *)((char *)this + 48);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveSphereComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveSphereComponent,re::GeomBuildSphereOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E05B0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 6);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 9));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveSphereComponent,re::GeomBuildSphereOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E05B0;
  unint64_t v2 = (re::AssetHandle *)(a1 + 6);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 9));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::make::shared::inplace<re::ecs2::PrimitiveCapsuleComponent>@<D0>(ArcSharedObject *a1@<X0>, void *a2@<X8>)
{
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(_DWORD *)(v3 + 28) = 65544;
  *(_WORD *)(v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 4;
  double result = 2.00000047;
  *(void *)(v3 + 36) = 0x400000003F000000;
  *(_WORD *)(v3 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 257;
  *(unsigned char *)(v3 + 46) = 0;
  *(_WORD *)(v3 + 48) = 0;
  *(unsigned char *)(v3 + 50) = 1;
  *(_OWORD *)(v3 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_DWORD *)(v3 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 65544;
  *(_WORD *)(v3 + 108) = 4;
  *(void *)(v3 + 112) = 0x400000003F000000;
  *(_WORD *)(v3 + 120) = 257;
  *(unsigned char *)(v3 + 122) = 0;
  *(_WORD *)(v3 + 1re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 1;
  *(void *)uint64_t v3 = &unk_26E6E0228;
  *a2 = v3;
  return result;
}

void re::ecs2::PrimitiveCapsuleComponent::~PrimitiveCapsuleComponent(re::ecs2::PrimitiveCapsuleComponent *this)
{
  *(void *)this = &unk_26E6E02C8;
  unint64_t v2 = (re::ecs2::PrimitiveCapsuleComponent *)((char *)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveCapsuleComponent *)((char *)this + 80));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetHandle *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6E02C8;
  unint64_t v2 = (re::ecs2::PrimitiveCapsuleComponent *)((char *)this + 56);
  re::AssetHandle::~AssetHandle((re::ecs2::PrimitiveCapsuleComponent *)((char *)this + 80));
  re::AssetHandle::~AssetHandle(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveCapsuleComponent,re::GeomBuildCapsuleOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E02C8;
  unint64_t v2 = (re::AssetHandle *)(a1 + 7);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 10));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ecs2::PrimitiveComponentBase<re::ecs2::PrimitiveCapsuleComponent,re::GeomBuildCapsuleOptions,(re::ecs2::ComponentTypeBase::Flags)2>::~PrimitiveComponentBase(void *a1)
{
  *a1 = &unk_26E6E02C8;
  unint64_t v2 = (re::AssetHandle *)(a1 + 7);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 10));
  re::AssetHandle::~AssetHandle(v2);
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::DynamicArray<re::anonymous namespace'::SkeletonAndAnimationInfoPerLodLevel>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x48uLL))
        {
          uint64_t v2 = 72 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 72 * a2, 8);
          if (result)
          {
            long long v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 72, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = (void *)(v8 + 72 * v9);
        BOOL v11 = (void *)(v8 + 24);
        unint64_t v12 = v7;
        do
        {
          uint64_t v13 = *(v11 - 1);
          *(_OWORD *)unint64_t v12 = *(_OWORD *)(v11 - 3);
          void v12[2] = v13;
          v12[3] = 0;
          v12[4] = 0;
          _OWORD v12[5] = 0;
          v12[4] = v11[1];
          v11[1] = 0;
          uint64_t v14 = v12[3];
          v12[3] = 0;
          v12[3] = *v11;
          *BOOL v11 = v14;
          uint64_t v15 = v12[5];
          _OWORD v12[5] = v11[2];
          void v11[2] = v15;
          v12[6] = 0;
          v12[7] = 0;
          v12[8] = 0;
          v12[7] = v11[4];
          v11[4] = 0;
          uint64_t v16 = v12[6];
          v12[6] = 0;
          v12[6] = v11[3];
          v11[3] = v16;
          uint64_t v17 = v12[8];
          v12[8] = v11[5];
          v11[5] = v17;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v11 + 3));
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v11);
          uint64_t v18 = v11 + 6;
          v11 += 9;
          v12 += 9;
        }
        while (v18 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t *re::ShareableInternal<re::GeomSkeleton>::~ShareableInternal(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6DF818;
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a1 + 17);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 14);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 8);
  re::FixedArray<re::StringID>::deinit(a1 + 5);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  *a1 = (uint64_t)&unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ShareableInternal<re::GeomSkeleton>::~ShareableInternal(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6DF818;
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a1 + 17);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 14);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 11);
  re::FixedArray<CoreIKTransform>::deinit(a1 + 8);
  re::FixedArray<re::StringID>::deinit(a1 + 5);
  re::StringID::destroyString((re::StringID *)(a1 + 3));
  *a1 = (uint64_t)&unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

__n128 re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 8);
  if (v4 + 1 > 8 * v5)
  {
    unint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5 <= v4 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v6 + 8 * (v4 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  uint64_t v8 = (__n128 *)(v7 + 40 * (v4 & 7));
  __n128 result = *a2;
  *uint64_t v8 = *a2;
  v8[1].n128_u64[1] = 0;
  v8[2].n128_u64[0] = 0;
  v8[1].n128_u64[0] = 0;
  v8[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = 0;
  unint64_t v10 = v8[1].n128_u64[0];
  v8[1].n128_u64[0] = 0;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v10;
  unint64_t v11 = v8[2].n128_u64[0];
  v8[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v11;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::SkeletalPoseAssetData>(re *a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  if (*((uint64_t **)a1 + 1) != a4)
  {
    uint64_t v16 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v17 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_27;
  }
  unint64_t v4 = a2;
  if (!a2[1])
  {
    uint64_t v16 = *re::animationLogObjects(a1);
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v17 = "Cannot make additive values, base values array size must not be zero.";
LABEL_27:
    _os_log_error_impl(&dword_233120000, v16, OS_LOG_TYPE_ERROR, v17, buf, 2u);
    return 0;
  }
  *(void *)long long buf = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  re::AnimationValueTraits<re::SkeletalPoseAssetData>::init((uint64_t *)buf, *a2);
  uint64_t v9 = 0;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10 && v4[1])
  {
    uint64_t v11 = 0;
    uint64_t v9 = 0;
    while (1)
    {
      re::AnimationValueTraits<re::SkeletalPoseAssetData>::invert(*v4 + v11, (uint64_t)buf);
      unint64_t v13 = *((void *)a1 + 1);
      if (v13 <= (unint64_t)v9) {
        break;
      }
      if (a4 == v9) {
        goto LABEL_30;
      }
      re::AnimationValueTraits<re::SkeletalPoseAssetData>::combine(*(void *)a1 + v11, (uint64_t)buf, a3 + v11);
      uint64_t v9 = (uint64_t *)((char *)v9 + 1);
      unint64_t v10 = *((void *)a1 + 1);
      if (v10 > (unint64_t)v9)
      {
        v11 += 24;
        if (v4[1] > (unint64_t)v9) {
          continue;
        }
      }
      uint64_t v9 = (uint64_t *)v9;
      goto LABEL_11;
    }
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v13);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_11:
    if (v10 <= (unint64_t)v9)
    {
LABEL_18:
      if (*(void *)buf)
      {
        if (v19) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
      }
      return 1;
    }
    if (a4 <= v9) {
      unint64_t v4 = v9;
    }
    else {
      unint64_t v4 = a4;
    }
    uint64_t v14 = 24 * (void)v9;
    while (v4 != v9)
    {
      re::AnimationValueTraits<re::SkeletalPoseAssetData>::combine(*(void *)a1 + v14, (uint64_t)buf, a3 + v14);
      uint64_t v9 = (uint64_t *)((char *)v9 + 1);
      v14 += 24;
      if (*((void *)a1 + 1) <= (unint64_t)v9) {
        goto LABEL_18;
      }
    }
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  _os_crash();
  __break(1u);
LABEL_30:
  re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::AnimationValueTraits<re::SkeletalPoseAssetData>::init(uint64_t *result, uint64_t a2)
{
  if (*(void *)(a2 + 8) != result[1])
  {
    uint64_t v3 = result;
    unint64_t v4 = (_anonymous_namespace_ *)re::FixedArray<CoreIKTransform>::deinit(result);
    unint64_t v5 = *(void *)(a2 + 8);
  }
  return result;
}

uint64_t re::AnimationValueTraits<re::SkeletalPoseAssetData>::invert(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 8))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    do
    {
      if (*(void *)(a2 + 8) <= v3)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v9 = (float32x4_t *)(*(void *)(result + 16) + v2);
      uint64_t v10 = *(void *)(a2 + 16) + v2;
      float32x4_t v11 = v9[1];
      float32x4_t v12 = v9[2];
      float32x4_t v13 = vdivq_f32(_Q0, *v9);
      int8x16_t v14 = (int8x16_t)vnegq_f32(v11);
      float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), v14, 0xCuLL);
      v14.i32[3] = v11.i32[3];
      float32x4_t v16 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), v11), v12, v15);
      int8x16_t v17 = (int8x16_t)vaddq_f32(v16, v16);
      float32x4_t v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), v17, 0xCuLL);
      float32x4_t v19 = vaddq_f32(v12, vmulq_laneq_f32(v18, v11, 3));
      int8x16_t v20 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v11), v18, v15);
      *(float32x4_t *)uint64_t v10 = v13;
      *(int8x16_t *)(v10 + 16) = v14;
      *(float32x4_t *)(v10 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = vmulq_f32(vaddq_f32(v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v20, 0xCuLL)), vnegq_f32(v13));
      ++v3;
      v2 += 48;
    }
    while (v3 < *(void *)(result + 8));
  }
  return result;
}

void re::AnimationValueTraits<re::SkeletalPoseAssetData>::combine(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      if (*(void *)(a2 + 8) <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (*(void *)(a3 + 8) <= v7) {
        goto LABEL_8;
      }
      re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(void *)(a1 + 16) + v6), (float32x4_t *)(*(void *)(a2 + 16) + v6), (float32x4_t *)(*(void *)(a3 + 16) + v6));
      ++v7;
      v6 += 48;
    }
    while (v7 < *(void *)(a1 + 8));
  }
}

void *re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        unint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 320, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_22:
          float32x4_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            float32x4_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::DynamicArray<re::ModelWithLodsDescriptor>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::ModelWithLodsDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::ModelWithLodsDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::ModelWithLodsDescriptor>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x98uLL))
        {
          uint64_t v2 = 152 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 152 * a2, 8);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::ModelWithLodsDescriptor>(v5[4], v5[4] + 152 * v5[2], v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 152, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::ModelWithLodsDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::ModelWithLodsDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(void *)(a3 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = *(void *)(v5 + 24);
      uint64_t v6 = *(void *)(v5 + 8);
      *(void *)a3 = *(void *)v5;
      *(void *)uint64_t v5 = 0;
      uint64_t v7 = *(void *)(v5 + 16);
      *(void *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
      uint64_t v9 = *(void *)(a3 + 8);
      uint64_t v8 = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = v6;
      *(void *)(a3 + 16) = v7;
      *(void *)(v5 + 8) = v9;
      *(void *)(v5 + 16) = v8;
      *(void *)(a3 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
      *(_DWORD *)(a3 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
      uint64_t v10 = *(void *)(v5 + 40);
      *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(v5 + 32);
      *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
      *(void *)(a3 + 40) = v10;
      *(void *)(v5 + 40) = 0;
      uint64_t v11 = *(void *)(a3 + 48);
      *(void *)(a3 + 48) = *(void *)(v5 + 48);
      *(void *)(v5 + 48) = v11;
      uint64_t v12 = *(void *)(a3 + 64);
      *(void *)(a3 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(v5 + 64);
      *(void *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v12;
      ++*(_DWORD *)(v5 + 56);
      ++*(_DWORD *)(a3 + 56);
      *(void *)(a3 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 88) = 0;
      *(void *)(a3 + 72) = 0;
      *(_DWORD *)(a3 + 96) = 0;
      uint64_t v13 = *(void *)(v5 + 80);
      *(void *)(a3 + 72) = *(void *)(v5 + 72);
      *(void *)(v5 + 72) = 0;
      *(void *)(a3 + 80) = v13;
      *(void *)(v5 + 80) = 0;
      uint64_t v14 = *(void *)(a3 + 88);
      *(void *)(a3 + 88) = *(void *)(v5 + 88);
      *(void *)(v5 + 88) = v14;
      uint64_t v15 = *(void *)(a3 + 104);
      *(void *)(a3 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(v5 + 104);
      *(void *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v15;
      ++*(_DWORD *)(v5 + 96);
      ++*(_DWORD *)(a3 + 96);
      *(void *)(a3 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
      *(void *)(a3 + 120) = 0;
      *(void *)(a3 + 128) = 0;
      *(void *)(a3 + 112) = 0;
      *(_DWORD *)(a3 + 136) = 0;
      uint64_t v16 = *(void *)(v5 + 120);
      *(void *)(a3 + 112) = *(void *)(v5 + 112);
      *(void *)(v5 + 112) = 0;
      *(void *)(a3 + 120) = v16;
      *(void *)(v5 + 120) = 0;
      uint64_t v17 = *(void *)(a3 + 128);
      *(void *)(a3 + 128) = *(void *)(v5 + 128);
      *(void *)(v5 + 128) = v17;
      uint64_t v18 = *(void *)(a3 + 144);
      *(void *)(a3 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(v5 + 144);
      *(void *)(v5 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v18;
      ++*(_DWORD *)(v5 + 136);
      ++*(_DWORD *)(a3 + 136);
      re::DynamicArray<unsigned long>::deinit(v5 + 112);
      re::DynamicArray<unsigned long>::deinit(v5 + 72);
      re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(v5 + 32);
      re::DynamicString::deinit((re::DynamicString *)v5);
      v5 += 152;
      a3 += 152;
    }
    while (v5 != a2);
  }
}

__n128 re::make::shared::object<re::ShareableInternal<re::GeomInstance>,re::GeomInstance>@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = re::globalAllocators((re *)a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 112, 16);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
  *(void *)uint64_t v5 = &unk_26E6DF860;
  *(_OWORD *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(_OWORD *)a1;
  __n128 result = *(__n128 *)(a1 + 16);
  long long v7 = *(_OWORD *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v5 + 96) = v8;
  *(__n128 *)(v5 + 48) = result;
  *(_OWORD *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v7;
  *a2 = v5;
  return result;
}

void *re::ShareableInternal<re::GeomInstance>::~ShareableInternal(void *a1)
{
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::ShareableInternal<re::GeomInstance>::~ShareableInternal(void *a1)
{
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::HashTable<re::DynamicString,unsigned short,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _WORD *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,unsigned short,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  uint64_t v14 = *(void *)(a1 + 8);
  *(_WORD *)(*(void *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(v14 + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,unsigned short,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,unsigned short,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::BucketArray<re::DynamicArray<re::anonymous namespace'::SkeletonAndAnimationInfoPerLodLevel>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 40 * (a2 & 7);
}

void re::anonymous namespace'::warnIgnoredAttribute(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (a5) {
    unsigned int v9 = " affector";
  }
  else {
    unsigned int v9 = "";
  }
  int v10 = *(_DWORD *)(a1 + 24);
  unint64_t v11 = *re::pipelineLogObjects((re *)a1);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v10 == a2)
  {
    if (!v12) {
      return;
    }
    int v13 = v11;
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v15 = *(const char **)(a3 + 24);
    uint64_t v16 = *(void *)(a4 + 8);
    int v26 = 136315906;
    uint64_t v27 = v14;
    __int16 v28 = 2080;
    unint64_t v29 = v9;
    __int16 v30 = 2080;
    unint64_t v31 = v15;
    __int16 v32 = 2080;
    uint64_t v33 = v16;
    uint64_t v17 = "Invalid attribute '%s' in %s%s for model %s, attribute ignored.";
    uint64_t v18 = v13;
    uint32_t v19 = 42;
  }
  else
  {
    if (!v12) {
      return;
    }
    int v13 = v11;
    if ((a2 - 1) > 6) {
      int8x16_t v20 = "float";
    }
    else {
      int8x16_t v20 = off_264BE3438[a2 - 1];
    }
    uint64_t v21 = *(void *)(a1 + 16);
    uint64_t v22 = *(const char **)(a3 + 24);
    uint64_t v23 = *(void *)(a4 + 8);
    unsigned int v24 = *(_DWORD *)(a1 + 24) - 1;
    if (v24 > 6) {
      size_t v25 = "float";
    }
    else {
      size_t v25 = off_264BE3438[v24];
    }
    int v26 = 136316418;
    uint64_t v27 = v21;
    __int16 v28 = 2080;
    unint64_t v29 = v22;
    __int16 v30 = 2080;
    unint64_t v31 = v9;
    __int16 v32 = 2080;
    uint64_t v33 = v23;
    __int16 v34 = 2080;
    uint64_t v35 = v20;
    __int16 v36 = 2080;
    unint64_t v37 = v25;
    uint64_t v17 = "Incorrect type for attribute '%s' in %s%s for model %s, attribute ignored (expected '%s', got '%s').";
    uint64_t v18 = v13;
    uint32_t v19 = 62;
  }
  _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v26, v19);
}

uint64_t re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::add(uint64_t result, unsigned char *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v6) ^ ((0xBF58476D1CE4E5B9 * v6) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(unsigned __int8 *)(v11 + 56 * v10 + 12) == v6) {
        return result;
      }
      while (1)
      {
        LODWORD(vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = *(_DWORD *)(v11 + 56 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(unsigned __int8 *)(v11 + 56 * v10 + 12) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  __n128 result = re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshSmoothComponent>(void *a1)
{
  if (!a1[4]) {
    return 0;
  }
  uint64_t v1 = a1[6];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[8] + 8;
  uint64_t v3 = 24 * v1;
  while (*(void *)(v2 - 8) != *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                 + 3) >> 1)
  {
    v2 += 24;
    v3 -= 24;
    if (!v3) {
      return 0;
    }
  }
  return *(void *)v2;
}

uint64_t re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::MeshOffsetsComponent>(void *a1)
{
  if (!a1[4]) {
    return 0;
  }
  uint64_t v1 = a1[6];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[8] + 8;
  uint64_t v3 = 24 * v1;
  while (*(void *)(v2 - 8) != *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                 + 3) >> 1)
  {
    v2 += 24;
    v3 -= 24;
    if (!v3) {
      return 0;
    }
  }
  return *(void *)v2;
}

_anonymous_namespace_ *re::DynamicArray<re::MeshAssetJiggleDeformerData>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)result)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        __n128 result = (_anonymous_namespace_ *)re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(result, v10);
      }
      else
      {
        __n128 result = (_anonymous_namespace_ *)re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v5 = *((void *)v3 + 2);
  }
  uint64_t v11 = *((void *)v3 + 4) + 48 * v5;
  uint64_t v12 = *a2;
  *(void *)uint64_t v11 = *(void *)v11 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)uint64_t v11 = *a2 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
  *(void *)(v11 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  uint64_t v13 = a2[2];
  *(void *)(v11 + 16) = *(void *)(v11 + 16) & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  *(void *)(v11 + 16) = a2[2] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  *(void *)(v11 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)"";
  uint64_t v14 = a2[4];
  *(_WORD *)(v11 + 40) = *((_WORD *)a2 + 20);
  *(void *)(v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v14;
  ++*((void *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::~__func()
{
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26E6DF8A8;
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DF8A8;
}

re *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::MeshDeformationAsset>((re *)"operator()", 3778, *a2);
}

uint64_t std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_0>,void ()(re::MeshDeformationAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::MeshDeformationAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::SkeletalPoseComponent>(void *a1)
{
  if (!a1[4]) {
    return 0;
  }
  uint64_t v1 = a1[6];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[8] + 8;
  uint64_t v3 = 24 * v1;
  while (*(void *)(v2 - 8) != *((void *)re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                 + 3) >> 1)
  {
    v2 += 24;
    v3 -= 24;
    if (!v3) {
      return 0;
    }
  }
  return *(void *)v2;
}

uint64_t re::ecs2::EntityAssetData::tryGetComponent<re::ecs2::RigComponent>(void *a1)
{
  if (!a1[4]) {
    return 0;
  }
  uint64_t v1 = a1[6];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[8] + 8;
  uint64_t v3 = 24 * v1;
  while (*(void *)(v2 - 8) != *((void *)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                 + 3) >> 1)
  {
    v2 += 24;
    v3 -= 24;
    if (!v3) {
      return 0;
    }
  }
  return *(void *)v2;
}

double re::make::shared::inplace<re::ecs2::MeshSmoothComponent>@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(_OWORD *)(a1 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v4 = &unk_26E6DFEE8;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_DWORD *)(v4 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(_OWORD *)(v4 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_DWORD *)(v4 + 96) = 0;
  *(_OWORD *)(a1 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  inited = (re *)objc_initWeak((id *)(v4 + 136), 0);
  *(void *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(a1 + 176) = re::globalAllocators(inited)[2];
  *(_DWORD *)(a1 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(void *)(a1 + 26re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = -1;
  *(_OWORD *)(a1 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *a2 = a1;
  return result;
}

void re::ecs2::MeshSmoothComponent::~MeshSmoothComponent(re::ecs2::MeshSmoothComponent *this)
{
  *(void *)this = &unk_26E6DFEE8;
  uint64_t v2 = (char *)this + 232;
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 39);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 36);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 192);
  re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::~FramePersistentPtr((id *)this + 17);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshSmoothComponent *)((char *)this + 112));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 72);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6DFEE8;
  uint64_t v2 = (char *)this + 232;
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 39);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 36);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 192);
  re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::~FramePersistentPtr((id *)this + 17);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshSmoothComponent *)((char *)this + 112));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 72);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::MeshSmoothComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

id *re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      unint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6DFF70;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        unint64_t v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      uint64_t v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs>((re *)"reset", 161, (uint64_t)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(a3 + 16));
    unint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshSmoothComponent::SmoothDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshSmoothComponent::SmoothDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshSmoothComponent::SmoothDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFF70;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshSmoothComponent::SmoothDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6DFF70;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshSmoothComponent::SmoothDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshSmoothComponent::SmoothDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

uint64_t re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, unsigned char *a4, uint64_t *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(void *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v31, v13, v12);
          long long v15 = *(_OWORD *)v31;
          *(_OWORD *)unint64_t v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v31[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v31[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&unsigned char v31[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21 - 4, v21);
              }
              v21 += 56;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 56 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 56 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v9) = a3;
  uint64_t v25 = a2;
  *(unsigned char *)(*(void *)(a1 + 16) + 56 * v9 + 12) = *a4;
  uint64_t v26 = *(void *)(a1 + 16) + 56 * v9;
  uint64_t v27 = *a5;
  *a5 = 0;
  *(void *)(v26 + 16) = v27;
  uint64_t v28 = v26 + 16;
  unint64_t v29 = (uint64_t *)a5[4];
  if (v29)
  {
    if (v29 == a5 + 1)
    {
      *(void *)(v28 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v28 + 8;
      (*(void (**)(uint64_t))(*(void *)a5[4] + 24))(a5[4]);
    }
    else
    {
      *(void *)(v28 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v29;
      a5[4] = 0;
    }
  }
  else
  {
    *(void *)(v28 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v25) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__func()
{
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26E6DF938;
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DF938;
}

re *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>>((re *)"operator()", 3837, *a2);
}

uint64_t std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_1>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::target_type()
{
}

uint64_t *std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (!v2) {
    goto LABEL_4;
  }
  uint64_t v3 = a1[4];
  uint64_t v6 = v2;
  if (v3)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v6);
LABEL_4:
    std::__function::__value_func<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__value_func[abi:nn180100](a1 + 1);
    return a1;
  }
  unint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__value_func[abi:nn180100](v5);
}

void *std::__function::__value_func<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

re::StringID *re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const StringID *a4, uint64_t *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v9 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v33, 0, 36);
          *(void *)&v33[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v33, v14, v13);
          long long v16 = *(_OWORD *)v33;
          *(_OWORD *)uint64_t v33 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v33[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v33[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v33[24];
          *(_OWORD *)&unsigned char v33[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v33[32];
          *(_OWORD *)(a1 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = v20;
          uint64_t v21 = v19;
          if (v19)
          {
            uint64_t v22 = v18 + 24;
            do
            {
              if ((*(_DWORD *)(v22 - 24) & 0x80000000) != 0)
              {
                unint64_t v23 = 0xBF58476D1CE4E5B9 * ((*(void *)(v22 - 16) >> 31) ^ (*(void *)(v22 - 16) >> 1));
                unint64_t v24 = (0x94D049BB133111EBLL * (v23 ^ (v23 >> 27))) ^ ((0x94D049BB133111EBLL * (v23 ^ (v23 >> 27))) >> 31);
                re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v24 % *(unsigned int *)(a1 + 24), v24, v22 - 16, v22);
              }
              v22 += 56;
              --v21;
            }
            while (v21);
          }
          re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v33);
        }
      }
      else
      {
        if (v13) {
          signed int v27 = 2 * v12;
        }
        else {
          signed int v27 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v10 + 1;
    uint64_t v25 = *(void *)(a1 + 16);
    int v26 = *(_DWORD *)(v25 + 56 * v9);
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 16);
    int v26 = *(_DWORD *)(v25 + 56 * v9);
    *(_DWORD *)(a1 + 36) = v26 & 0x7FFFFFFF;
  }
  uint64_t v28 = 56 * v9;
  *(_DWORD *)(v25 + v28) = v26 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v28) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  double result = re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 56 * v9 + 8), a4);
  __int16 v30 = (void *)(*(void *)(a1 + 16) + 56 * v9);
  uint64_t v31 = *a5;
  void v30[3] = v30[3] & 0xFFFFFFFFFFFFFFFELL | *a5 & 1;
  void v30[3] = *a5 & 0xFFFFFFFFFFFFFFFELL | v31 & 1;
  v30[4] = a5[1];
  *a5 = 0;
  a5[1] = (uint64_t)"";
  uint64_t v32 = a5[2];
  void v30[5] = v30[5] & 0xFFFFFFFFFFFFFFFELL | v32 & 1;
  void v30[5] = a5[2] & 0xFFFFFFFFFFFFFFFELL | v32 & 1;
  v30[6] = a5[3];
  a5[2] = 0;
  a5[3] = (uint64_t)"";
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t *re::make::shared::inplace<re::ecs2::MeshOffsetsComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  uint64_t v4 = (id *)(a1 + 160);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v5 + 16) = 0;
  *(unsigned char *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v5 = &unk_26E6DFFC8;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_DWORD *)(v5 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(_OWORD *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(void *)(v5 + 96) = 0;
  *(void *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = -1;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  inited = (re *)objc_initWeak(v4, 0);
  *(void *)(a1 + 168) = 0;
  double result = re::globalAllocators(inited);
  *(void *)(a1 + 200) = result[2];
  *(void *)(a1 + 208) = 0;
  *a2 = a1;
  return result;
}

void re::ecs2::MeshOffsetsComponent::~MeshOffsetsComponent(re::ecs2::MeshOffsetsComponent *this)
{
  *(void *)this = &unk_26E6DFFC8;
  uint64_t v2 = (uint64_t *)((char *)this + 136);
  re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::~FramePersistentPtr((id *)this + 20);
  re::FixedArray<CoreIKTransform>::deinit(v2);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 14);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshOffsetsComponent *)((char *)this + 72));
  re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6DFFC8;
  uint64_t v2 = (uint64_t *)((char *)this + 136);
  re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::~FramePersistentPtr((id *)this + 20);
  re::FixedArray<CoreIKTransform>::deinit(v2);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 14);
  re::AssetHandle::~AssetHandle((re::ecs2::MeshOffsetsComponent *)((char *)this + 72));
  re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::MeshOffsetsComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

id *re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      uint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6E0050;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        int v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      int v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs>((re *)"reset", 161, (uint64_t)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::FixedArray<re::OffsetDeformerInput>::deinit((void *)(a3 + 16));
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6E0050;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6E0050;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::MeshOffsetsComponent::OffsetsDeformerInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

void *re::FixedArray<re::OffsetDeformerInput>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 160 * v2;
      uint64_t v5 = (id *)(result[2] + 136);
      do
      {
        if (*v5)
        {

          *uint64_t v5 = 0;
        }
        v5 += 20;
        v4 -= 160;
      }
      while (v4);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 192 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 192;
          v5 -= 192;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::~__func()
{
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6DF9C8;
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DF9C8;
}

re *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>>((re *)"operator()", 4061, *a2);
}

uint64_t std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2,std::allocator<re::anonymous namespace'::wireupDeformers(re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::GeomDeformerStack,8ul> const&,re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false> &)::$_2>,void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension> *)>::target_type()
{
}

void *re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::ecs2::AssignedMeshOffsetsAttributes>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xC0uLL))
        {
          uint64_t v2 = 192 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 192 * a2, 16);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 192, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 192 * v9;
        uint64_t v11 = v7 + 3;
        do
        {
          v11[1] = 0;
          *(v11 - 2) = 0;
          *(v11 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
          *(v11 - 3) = 0;
          *(_DWORD *)uint64_t v11 = 0;
          uint64_t v12 = *(void *)(v8 + 8);
          *(v11 - 3) = *(void *)v8;
          *(v11 - 2) = v12;
          *(void *)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
          uint64_t v13 = *(v11 - 1);
          *(v11 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v13;
          uint64_t v14 = v11[1];
          v11[1] = *(void *)(v8 + 32);
          *(void *)(v8 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v14;
          ++*(_DWORD *)(v8 + 24);
          ++*(_DWORD *)v11;
          *(_OWORD *)(v11 + 3) = *(_OWORD *)(v8 + 48);
          long long v15 = *(_OWORD *)(v8 + 64);
          long long v16 = *(_OWORD *)(v8 + 80);
          long long v17 = *(_OWORD *)(v8 + 96);
          *(_OWORD *)(v11 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(_OWORD *)(v8 + 112);
          *(_OWORD *)(v11 + 9) = v17;
          *(_OWORD *)(v11 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v16;
          *(_OWORD *)(v11 + 5) = v15;
          long long v18 = *(_OWORD *)(v8 + 128);
          long long v19 = *(_OWORD *)(v8 + 144);
          long long v20 = *(_OWORD *)(v8 + 160);
          *((_DWORD *)v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 38) = *(_DWORD *)(v8 + 176);
          *(_OWORD *)(v11 + 1re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v20;
          *(_OWORD *)(v11 + 15) = v19;
          *(_OWORD *)(v11 + re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = v18;
          re::DynamicArray<unsigned long>::deinit(v8);
          v11 += 24;
          v8 += 192;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::HashTable<unsigned char,std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          std::unique_ptr<re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>,std::function<void ()(re::BasicAsset<re::AssignedMeshDeformation,&re::kAssignedMeshDeformationAssetName,&re::kAssignedMeshDeformationAssetExtension>*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(v6 + v5 + 8));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        ++v4;
        v5 += 56;
      }
      while (v4 < v3);
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t *std::unique_ptr<re::MeshDeformationAsset,std::function<void ()(re::MeshDeformationAsset*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::MeshDeformationAsset *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::MeshDeformationAsset *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t std::function<void ()(re::MeshDeformationAsset *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x23362AADCLL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::~__func()
{
}

void *std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26E6DFA48;
  return result;
}

void std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6DFA48;
}

re *std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::operator()(uint64_t a1, void (****a2)(void))
{
  return re::internal::destroyPersistent<re::VertexCacheAsset>((re *)"operator()", 4285, *a2);
}

uint64_t std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0,std::allocator<re::anonymous namespace'::wireupVertexCacheAnimations(float,re::ecs2::EntityAssetData &,re::StringSlice const&,re::SceneImportOperation &,re::MeshAssetData &,re::BucketArray<re::VertexCacheAnimationData *,8ul> const&,re::BucketArray<re::anonymous namespace'::EntityAnimationEntry,8ul> &)::$_0>,void ()(re::VertexCacheAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::VertexCacheAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

uint64_t *re::make::shared::inplace<re::ecs2::VertexCacheComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 2re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  uint64_t v4 = (id *)(a1 + 192);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v5 + 16) = 0;
  *(unsigned char *)(v5 + re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24) = 0;
  *(void *)uint64_t v5 = &unk_26E6E08B0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_DWORD *)(v5 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(void *)(v5 + 18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(_OWORD *)(v5 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_DWORD *)(v5 + 96) = 0;
  *(_OWORD *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v5 + 120) = 0u;
  *(_DWORD *)(v5 + 136) = 0;
  *(_OWORD *)(v5 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_DWORD *)(v5 + 176) = 0;
  inited = (re *)objc_initWeak(v4, 0);
  *(void *)(a1 + 200) = 0;
  double result = re::globalAllocators(inited);
  *(void *)(a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = result[2];
  *(void *)(a1 + 240) = 0;
  *a2 = a1;
  return result;
}

void re::ecs2::VertexCacheComponent::~VertexCacheComponent(id *this)
{
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24);
  re::DynamicArray<re::BindPoint>::deinit((uint64_t)(this + 19));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 14));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 9));
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)(this + 4));
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::VertexCacheComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

id *re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(id *a1)
{
  v5[5] = *MEMORY[0x263EF8340];
  inited = (re *)objc_initWeak(&location, 0);
  memset(v5, 0, 24);
  v5[3] = re::globalAllocators(inited)[2];
  v5[4] = 0;
  re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(a1, &location, 0, (uint64_t)v5);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v5);
  objc_destroyWeak(&location);
  id location = 0;
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)(a1 + 2));
  objc_destroyWeak(a1);
  *a1 = 0;
  return a1;
}

uint64_t re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(id *location, id *a2, void *a3, uint64_t a4)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (location[1])
  {
    WeakRetained = objc_loadWeakRetained(location);
    if (WeakRetained)
    {
      uint64_t v9 = WeakRetained;

      if (!location[6])
      {
        uint64_t v11 = re::globalAllocators(v10)[2];
        v18[0] = &unk_26E6E0938;
        v18[3] = v11;
        v18[4] = v18;
        re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), (uint64_t)v18);
        uint64_t v10 = (re *)re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)v18);
      }
      uint64_t v12 = re::globalAllocators(v10);
      unint64_t v13 = v9[2] & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v9[1] << 60);
      id v14 = location[1];
      uint64_t v15 = re::PerFrameAllocatorManager::perFrameAllocator(v12[6], v13);
      (*(void (**)(uint64_t, id, id *))(*(void *)v15 + 16))(v15, v14, location + 2);
    }
    else
    {
      id v16 = location[6];
      if (v16)
      {
        v18[0] = location[1];
        (*(void (**)(id, void *))(*(void *)v16 + 16))(v16, v18);
      }
      else
      {
        re::internal::destroyPersistent<re::ecs2::VertexCacheComponent::VertexCacheInputs>((re *)"reset", 161, (uint64_t)location[1]);
      }
    }
  }
  re::ArcWeakPtr<re::VideoHistogram>::operator=(location, a2);
  location[1] = a3;
  return re::FunctionBase<24ul,void ()(void *)>::operator=<24ul>((uint64_t)(location + 2), a4);
}

re *re::internal::destroyPersistent<re::ecs2::VertexCacheComponent::VertexCacheInputs>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::FixedArray<re::VertexCacheDeformerInput>::deinit((void *)(a3 + 16));
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::internal::Callable<re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::VertexCacheComponent::VertexCacheInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::~Callable()
{
}

re *re::internal::Callable<re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::VertexCacheComponent::VertexCacheInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::ecs2::VertexCacheComponent::VertexCacheInputs>((re *)"operator()", 149, *a2);
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::VertexCacheComponent::VertexCacheInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6E0938;
  return result;
}

void *re::internal::Callable<re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::VertexCacheComponent::VertexCacheInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E6E0938;
  return result;
}

uint64_t re::internal::Callable<re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::reset(re::ArcWeakPtr<re::FrameManager>,re::ecs2::VertexCacheComponent::VertexCacheInputs*,re::Function<void ()(void *)> &&)::{lambda(void *)#1},void ()(void *)>::size()
{
  return 16;
}

void *re::FixedArray<re::VertexCacheDeformerInput>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 40 * v2;
      uint64_t v5 = (id *)(result[2] + 16);
      do
      {
        if (*v5)
        {

          *uint64_t v5 = 0;
        }
        uint64_t v6 = *(v5 - 2);
        if (v6)
        {

          *(v5 - 2) = 0;
        }
        v5 += 5;
        v4 -= 40;
      }
      while (v4);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::BindPoint>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v3 + 8;
        uint64_t v6 = 48 * v4;
        do
        {
          re::DynamicArray<re::BindPoint::BindPointData>::deinit(v5);
          re::DynamicArray<re::BindPoint::BindPointData>::deinit(v5);
          v5 += 48;
          v6 -= 48;
        }
        while (v6);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::MeshAssetData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA0uLL))
        {
          uint64_t v2 = 160 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      int v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = v8 + 160 * v9;
        do
        {
          uint64_t v12 = &v7[v10 / 8];
          v12[4] = 0;
          uint64_t v13 = v8 + v10;
          v12[1] = 0;
          void v12[2] = 0;
          *uint64_t v12 = 0;
          *((_DWORD *)v12 + 6) = 0;
          uint64_t v14 = *(void *)(v8 + v10 + 8);
          *uint64_t v12 = *(void *)(v8 + v10);
          v12[1] = v14;
          *(void *)uint64_t v13 = 0;
          *(void *)(v13 + 8) = 0;
          uint64_t v15 = v7[v10 / 8 + 2];
          void v12[2] = *(void *)(v8 + v10 + 16);
          *(void *)(v13 + 16) = v15;
          uint64_t v16 = v7[v10 / 8 + 4];
          v12[4] = *(void *)(v8 + v10 + 32);
          *(void *)(v13 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v16;
          *(_DWORD *)(v13 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = *(_DWORD *)(v8 + v10 + 24) + 1;
          *((_DWORD *)v12 + 6) = LODWORD(v7[v10 / 8 + 3]) + 1;
          v12[9] = 0;
          v12[6] = 0;
          v12[7] = 0;
          _OWORD v12[5] = 0;
          *((_DWORD *)v12 + 16) = 0;
          uint64_t v17 = *(void *)(v8 + v10 + 48);
          _OWORD v12[5] = *(void *)(v8 + v10 + 40);
          *(void *)(v8 + v10 + 40) = 0;
          v12[6] = v17;
          *(void *)(v13 + 48) = 0;
          uint64_t v18 = v7[v10 / 8 + 7];
          v12[7] = *(void *)(v8 + v10 + 56);
          *(void *)(v13 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v18;
          uint64_t v19 = v7[v10 / 8 + 9];
          v12[9] = *(void *)(v8 + v10 + 72);
          *(void *)(v13 + 72) = v19;
          *(_DWORD *)(v13 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(_DWORD *)(v8 + v10 + 64) + 1;
          *((_DWORD *)v12 + 16) = LODWORD(v7[v10 / 8 + 8]) + 1;
          v12[14] = 0;
          v12[11] = 0;
          v12[12] = 0;
          v12[10] = 0;
          *((_DWORD *)v12 + 26) = 0;
          uint64_t v20 = *(void *)(v8 + v10 + 88);
          v12[10] = *(void *)(v8 + v10 + 80);
          *(void *)(v8 + v10 + 80) = 0;
          v12[11] = v20;
          *(void *)(v13 + 88) = 0;
          uint64_t v21 = v7[v10 / 8 + 12];
          v12[12] = *(void *)(v8 + v10 + 96);
          *(void *)(v13 + 96) = v21;
          uint64_t v22 = v7[v10 / 8 + 14];
          v12[14] = *(void *)(v8 + v10 + 112);
          *(void *)(v13 + 112) = v22;
          *(_DWORD *)(v13 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(_DWORD *)(v8 + v10 + 104) + 1;
          *((_DWORD *)v12 + 26) = LODWORD(v7[v10 / 8 + 13]) + 1;
          v12[19] = 0;
          v12[16] = 0;
          v12[17] = 0;
          v12[15] = 0;
          *((_DWORD *)v12 + 36) = 0;
          unint64_t v23 = (void *)(v8 + v10 + 120);
          uint64_t v24 = *(void *)(v8 + v10 + 128);
          v12[15] = *v23;
          void *v23 = 0;
          v12[16] = v24;
          *(void *)(v13 + 128) = 0;
          uint64_t v25 = v7[v10 / 8 + 17];
          v12[17] = *(void *)(v8 + v10 + 136);
          *(void *)(v13 + 136) = v25;
          uint64_t v26 = v7[v10 / 8 + 19];
          v12[19] = *(void *)(v8 + v10 + 152);
          *(void *)(v13 + 152) = v26;
          *(_DWORD *)(v13 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(_DWORD *)(v8 + v10 + 144) + 1;
          *((_DWORD *)v12 + 36) = LODWORD(v7[v10 / 8 + 18]) + 1;
          re::DynamicArray<unsigned long>::deinit((uint64_t)v23);
          re::DynamicArray<re::MeshAssetSkeleton>::deinit(v8 + v10 + 80);
          re::DynamicArray<re::MeshAssetInstance>::deinit(v8 + v10 + 40);
          re::DynamicArray<re::MeshAssetModel>::deinit((void *)(v8 + v10));
          v10 += 160;
        }
        while (v13 + 160 != v11);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::TimelineGroupBuilder::addTimeline(uint64_t a1, const re::AssetHandle *a2, uint64_t a3, uint64_t a4, const char *a5, float32_t a6, float a7)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  v40[0] = a3;
  v40[1] = a4;
  long long v35 = 0uLL;
  if (a4) {
    size_t v12 = a4 + 1;
  }
  else {
    size_t v12 = 0;
  }
  *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
  re::DynamicString::setCapacity(&v34, v12);
  re::DynamicString::operator=((re::DynamicString *)&v34, (uint64_t)v40);
  unint64_t v36 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  re::AssetHandle::AssetHandle((re::AssetHandle *)&v37, a2);
  unint64_t v13 = *(void *)(a1 + 96);
  unint64_t v14 = *(void *)(a1 + 64);
  if (v13 + 1 > 8 * v14)
  {
    re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::setBucketsCapacity((void *)(a1 + 56), (v13 + 8) >> 3);
    unint64_t v14 = *(void *)(a1 + 64);
  }
  if (v14 <= v13 >> 3)
  {
    void v40[2] = 0;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v41 = 136315906;
    uint64_t v42 = "operator[]";
    __int16 v43 = 1024;
    int v44 = 858;
    __int16 v45 = 2048;
    unint64_t v46 = v13 >> 3;
    __int16 v47 = 2048;
    unint64_t v48 = v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 72)) {
    uint64_t v15 = a1 + 80;
  }
  else {
    uint64_t v15 = *(void *)(a1 + 88);
  }
  uint64_t v16 = *(void *)(v15 + 8 * (v13 >> 3));
  ++*(void *)(a1 + 96);
  ++*(_DWORD *)(a1 + 104);
  uint64_t v17 = v16 + 96 * (v13 & 7);
  *(_OWORD *)uint64_t v17 = 0u;
  *(_OWORD *)(v17 + 16) = 0u;
  *(void *)uint64_t v17 = v30;
  uint64_t v30 = 0;
  uint64_t v18 = *(void *)(v17 + 16);
  *(void *)(v17 + 16) = v32;
  uint64_t v32 = v18;
  *(void *)(v17 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v33;
  uint64_t v33 = 0;
  uint64_t v19 = *(void *)(v17 + 8);
  *(void *)(v17 + 8) = v31;
  uint64_t v31 = v19;
  *(_OWORD *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v17 + 48) = 0u;
  *(void *)(v17 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v34;
  *(void *)&long long v34 = 0;
  uint64_t v20 = *(void *)(v17 + 48);
  *(void *)(v17 + 48) = v35;
  *(void *)&long long v35 = v20;
  *(void *)(v17 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *((void *)&v35 + 1);
  *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
  uint64_t v21 = *(void *)(v17 + 40);
  *(void *)(v17 + 40) = *((void *)&v34 + 1);
  *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v21;
  *(void *)(v17 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v36;
  *(void *)(v17 + 72) = 0;
  *(void *)(v17 + 80) = 0;
  *(void *)(v17 + 88) = 0;
  *(void *)(v17 + 80) = v38;
  uint64_t v38 = 0;
  uint64_t v22 = *(void *)(v17 + 72);
  *(void *)(v17 + 72) = 0;
  *(void *)(v17 + 72) = v37;
  uint64_t v37 = v22;
  uint64_t v23 = *(void *)(v17 + 88);
  *(void *)(v17 + 88) = v39;
  uint64_t v39 = v23;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v37);
  if ((void)v34)
  {
    if (BYTE8(v34)) {
      (*(void (**)(void))(*(void *)v34 + 40))();
    }
    long long v34 = 0u;
    long long v35 = 0u;
  }
  if (v30 && (v31 & 1) != 0) {
    (*(void (**)(void))(*(void *)v30 + 40))();
  }
  v24.i32[0] = *(void *)(a1 + 40);
  v24.f32[1] = a7;
  v25.i32[1] = HIDWORD(*(void *)(a1 + 40));
  v25.f32[0] = a6;
  int8x8_t v26 = (int8x8_t)vcgt_f32(v24, v25);
  v24.f32[0] = a6;
  *(int8x8_t *)(a1 + 40) = vbsl_s8(v26, (int8x8_t)v24, *(int8x8_t *)(a1 + 40));
  float v27 = *(float *)(a1 + 48);
  if (v27 < a7) {
    float v27 = a7;
  }
  *(float *)(a1 + 48) = v27;
}

void *re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 768, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    uint64_t result = (void *)re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::DynamicArray<re::FixedArray<re::StringID>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::FixedArray<re::StringID>>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    unint64_t v6 = a2[2];
    if (v6 >= *(void *)(a1 + 16))
    {
      re::DynamicArray<re::FixedArray<re::StringID>>::setCapacity((void *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,0>((unint64_t *)a2[4], (unint64_t *)(a2[4] + 24 * *(void *)(a1 + 16)), *(unint64_t **)(a1 + 32));
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10 != v6)
      {
        uint64_t v11 = 3 * v10;
        uint64_t v12 = a2[4] + 8 * v11;
        unint64_t v13 = (unint64_t *)(*(void *)(a1 + 32) + 8 * v11);
        uint64_t v14 = 24 * v6 - 8 * v11;
        do
        {
          uint64_t v15 = re::FixedArray<re::StringID>::FixedArray(v13, v12);
          v12 += 24;
          unint64_t v13 = v15 + 3;
          v14 -= 24;
        }
        while (v14);
      }
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,0>((unint64_t *)a2[4], (unint64_t *)(a2[4] + 24 * v6), *(unint64_t **)(a1 + 32));
      uint64_t v7 = *(void *)(a1 + 16);
      if (v6 != v7)
      {
        int v8 = (void *)(*(void *)(a1 + 32) + 24 * v6);
        uint64_t v9 = 24 * v7 - 24 * v6;
        do
        {
          re::FixedArray<re::StringID>::deinit(v8);
          v8 += 3;
          v9 -= 24;
        }
        while (v9);
      }
    }
    *(void *)(a1 + 16) = v6;
  }
  return a1;
}

unint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,re::FixedArray<re::StringID> *,0>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      uint64_t result = re::FixedArray<re::StringID>::operator=(a3, v5);
      v5 += 24;
      a3 += 3;
    }
    while ((unint64_t *)v5 != a2);
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,re::FixedArray<re::Matrix4x4<float>> *,0>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      uint64_t result = re::FixedArray<re::Matrix4x4<float>>::operator=(a3, v5);
      v5 += 24;
      a3 += 3;
    }
    while ((uint64_t *)v5 != a2);
  }
  return result;
}

unint64_t *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *,re::SkeletalPoseMeshMap *>(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = &v5[v6];
      *(unsigned char *)(a3 + v6 * 8) = v5[v6];
      re::StringID::operator=((unint64_t *)(a3 + v6 * 8 + 8), (uint64_t *)&v5[v6 + 1]);
      re::StringID::operator=((unint64_t *)(a3 + v6 * 8 + 24), (uint64_t *)&v5[v6 + 3]);
      uint64_t result = re::StringID::operator=((unint64_t *)(a3 + v6 * 8 + 40), (uint64_t *)&v5[v6 + 5]);
      *(void *)(a3 + v6 * 8 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v5[v6 + 7];
      v6 += 8;
    }
    while (v7 + 8 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::AnimationSceneEntityData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AnimationSceneEntityData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AnimationSceneEntityData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::AnimationSceneEntityData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AnimationSceneEntityData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::AnimationSceneEntityData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::AnimationSceneEntityData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AnimationSceneEntityData *,re::AnimationSceneEntityData *,re::AnimationSceneEntityData *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 88 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 88 * v8;
      uint64_t v12 = 88 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v10 + v11), (const StringID *)(v9 + v11));
        re::DynamicArray<re::AnimationSceneEntityData>::DynamicArray(v10 + v11 + 16, (uint64_t *)(v9 + v11 + 16));
        *(unsigned char *)(v10 + v11 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(unsigned char *)(v9 + v11 + 56);
        re::AssetHandle::AssetHandle((re::AssetHandle *)(v10 + v11 + 64), (const re::AssetHandle *)(v9 + v11 + 64));
        v9 += 88;
        v12 -= 88;
        v10 += 88;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AnimationSceneEntityData *,re::AnimationSceneEntityData *,re::AnimationSceneEntityData *>((uint64_t)&v13, *(void *)(a2 + 32), *(void *)(a2 + 32) + 88 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4] + 88 * v4;
      uint64_t v7 = -88 * v4 + 88 * v5;
      do
      {
        re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 + 64));
        re::DynamicArray<re::AnimationSceneEntityData>::deinit(v6 + 16);
        re::StringID::destroyString((re::StringID *)v6);
        v6 += 88;
        v7 -= 88;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AnimationSceneEntityData *,re::AnimationSceneEntityData *,re::AnimationSceneEntityData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::DynamicArray<re::AnimationSceneEntityData>::operator=(a4 + v7 + 16, a2 + v7 + 16);
    *(unsigned char *)(a4 + v7 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(unsigned char *)(a2 + v7 + 56);
    re::AssetHandle::operator=(a4 + v7 + 64, (uint64_t *)(a2 + v7 + 64));
    v7 += 88;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::AnimationSceneEntityData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::AnimationSceneEntityData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::AnimationSceneEntityData>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 96 * (a2 & 7);
}

uint64_t re::DynamicArray<re::ModelWithLodsDescriptor>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 152 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 112);
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 72);
          re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v3 + 32);
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 152);
          v5 -= 152;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      uint64_t v4 = re::BucketArray<re::TimelineGroupBuilder::TimelineData,8ul>::operator[](a1, i);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 + 72));
      re::DynamicString::deinit((re::DynamicString *)(v4 + 32));
      re::DynamicString::deinit((re::DynamicString *)v4);
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = *(void *)a1;
  if (*(void *)a1)
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if ((v6 & 1) == 0)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 40))(result, *(void *)(a1 + 32));
      int v6 = *(_DWORD *)(a1 + 16);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = (v6 | 1) + 2;
  }
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::DynamicArray<re::DeformationDefinition>::insert(void *this, unint64_t a2, uint64_t *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  unint64_t v4 = this[2];
  if (v4 + 1 <= a2)
  {
    memset(v22, 0, sizeof(v22));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  int v6 = this;
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::DeformationDefinition>::growCapacity(this, v4 + 1);
    unint64_t v4 = v6[2];
  }
  uint64_t v7 = v6[4];
  uint64_t v8 = (unint64_t *)(v7 + 40 * v4);
  if (v4 <= a2)
  {
    uint64_t v19 = *a3;
    *uint64_t v8 = *v8 & 0xFFFFFFFFFFFFFFFELL | *a3 & 1;
    *uint64_t v8 = *a3 & 0xFFFFFFFFFFFFFFFELL | v19 & 1;
    v8[1] = a3[1];
    *a3 = 0;
    a3[1] = (uint64_t)"";
    uint64_t v20 = (void *)(v7 + 40 * v4);
    void v20[2] = 0;
    float32x4_t v20[3] = 0;
    v20[4] = 0;
    void v20[2] = a3[2];
    a3[2] = 0;
    float32x4_t v20[3] = a3[3];
    a3[3] = 0;
    uint64_t v21 = v20[4];
    v20[4] = a3[4];
    a3[4] = v21;
  }
  else
  {
    uint64_t v9 = v7 + 40 * v4;
    *uint64_t v8 = *(void *)(v9 - 40);
    *(void *)(v9 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
    *(void *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    long long v10 = *(_OWORD *)(v9 - 32);
    *(void *)(v9 - 40) = 0;
    *(void *)(v9 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "";
    *(_OWORD *)(v8 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
    uint64_t v11 = *(void *)(v9 - 16);
    uint64_t v12 = *(void *)(v9 - 8);
    *(void *)(v9 - 16) = 0;
    *(void *)(v9 - 8) = 0;
    *(void *)(v9 - re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
    *(void *)(v9 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v11;
    *(void *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v12;
    uint64_t v13 = 5 * a2;
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::DeformationDefinition *,re::DeformationDefinition *,re::DeformationDefinition *>((uint64_t)v22, v6[4] + 8 * v13, v6[4] + 40 * v6[2] - 40, v6[4] + 40 * v6[2]);
    char v14 = (void *)(v6[4] + 8 * v13);
    uint64_t v15 = *a3;
    uint64_t v16 = a3[1];
    *a3 = 0;
    a3[1] = (uint64_t)"";
    uint64_t v17 = v14[1];
    unint64_t v18 = v15 & 0xFFFFFFFFFFFFFFFELL | *v14 & 1;
    v14[1] = v16;
    *(void *)&v22[0] = v18;
    *((void *)&v22[0] + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v17;
    *char v14 = v15;
    re::StringID::destroyString((re::StringID *)v22);
    this = re::FixedArray<float>::operator=(v14 + 2, a3 + 2);
  }
  ++v6[2];
  ++*((_DWORD *)v6 + 6);
  return this;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::DeformationDefinition *,re::DeformationDefinition *,re::DeformationDefinition *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      uint64_t v10 = *(void *)(a3 + v7 - 40);
      uint64_t v11 = *(void *)(a3 + v7 - 32);
      *(void *)(v8 - 40) = 0;
      *(void *)(v8 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = "";
      uint64_t v12 = *(void *)(a4 + v7 - 40);
      uint64_t v13 = *(void *)(a4 + v7 - 32);
      *(void *)(v9 - 40) = v10;
      *(void *)(v9 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11;
      v15[0] = v10 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
      v15[1] = v13;
      re::StringID::destroyString((re::StringID *)v15);
      re::FixedArray<float>::operator=((uint64_t *)(a4 + v7 - 24), (uint64_t *)(a3 + v7 - 24));
      v7 -= 40;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t re::cloneCollisionShapeData(uint64_t this, re::CollisionShapeData *a2)
{
  if (this)
  {
    uint64_t v2 = this;
    this = 0;
    switch(*(_DWORD *)(v2 + 8))
    {
      case 1:
        uint64_t v3 = re::globalAllocators(0);
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 16, 8);
        *(_DWORD *)(this + 8) = 1;
        *(void *)this = &unk_26E6D8CF8;
        break;
      case 2:
        unint64_t v4 = re::globalAllocators(0);
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 16, 8);
        *(_DWORD *)(this + 8) = 2;
        *(void *)this = &unk_26E6D8DA0;
        *(_DWORD *)(this + 12) = *(_DWORD *)(v2 + 12);
        break;
      case 3:
        uint64_t v5 = re::globalAllocators(0);
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 32, 16);
        *(_DWORD *)(this + 8) = 3;
        *(void *)this = &unk_26E6D8B78;
        *(_OWORD *)(this + 16) = 0u;
        *(_OWORD *)(this + 16) = *(_OWORD *)(v2 + 16);
        break;
      case 4:
        int v6 = re::globalAllocators(0);
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 24, 8);
        *(_DWORD *)(this + 8) = 4;
        *(void *)this = &unk_26E6D8BE0;
        *(void *)(this + 12) = *(void *)(v2 + 12);
        break;
      case 6:
        uint64_t v7 = re::globalAllocators(0);
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 48, 16);
        *(_DWORD *)(this + 8) = 6;
        *(void *)this = &unk_26E6D8D30;
        *(_OWORD *)(this + 16) = 0u;
        *(_OWORD *)(this + 16) = *(_OWORD *)(v2 + 16);
        *(_DWORD *)(this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(_DWORD *)(v2 + 32);
        break;
      case 7:
        this = v2;
        break;
      default:
        return this;
    }
  }
  return this;
}

re *re::convertCompoundToCollisionShape(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  long long v53 = 0;
  uint64_t v54 = 0;
  if (!a1) {
    return 0;
  }
  unint64_t v4 = a4;
  uint64_t v5 = a2;
  int v44 = (re *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a2 + 624, a4);
  uint64_t v7 = re::globalAllocators(v44);
  uint64_t v9 = (re::CollisionShape **)v7[2];
  if (*(_DWORD *)(a1 + 8) == 7)
  {
    uint64_t v10 = re::globalAllocators((re *)v7);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 72, 8);
    *(_DWORD *)(v11 + 8) = 7;
    *(void *)uint64_t v11 = &unk_26E6D8C18;
    *(void *)(v11 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
    *(void *)(v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(v11 + 16) = 0;
    *(void *)(v11 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
    *(void *)(v11 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
    *(void *)(v11 + 48) = 0;
    unint64_t v12 = *(void *)(a1 + 24);
    unint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v50 = 0;
    uint64_t v42 = (uint64_t)v9;
    re::FixedArray<unsigned long>::init<>(&v50, (uint64_t)v9, v12);
    uint64_t v14 = *(void *)(a1 + 24);
    if (v14)
    {
      uint64_t v15 = 0;
      unint64_t v16 = 0;
      uint64_t v17 = *(uint64_t **)(a1 + 32);
      __int16 v43 = &v17[6 * v14];
      do
      {
        uint64_t v18 = *v17;
        long long v19 = *(_OWORD *)(v17 + 3);
        *(_OWORD *)size_t v56 = *(_OWORD *)(v17 + 1);
        *(_OWORD *)&v56[16] = v19;
        *(void *)&v56[32] = v17[5];
        uint64_t v20 = v5;
        uint64_t v21 = v5;
        unint64_t v22 = v4;
        uint64_t v23 = (re *)re::convertCompoundToCollisionShape(v18, v21, a3, v4);
        unint64_t v25 = v51;
        if (v51 <= v16)
        {
          uint64_t v47 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          uint64_t v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 468;
          __int16 v61 = 2048;
          unint64_t v62 = v16;
          __int16 v63 = 2048;
          unint64_t v64 = v25;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_25:
          uint64_t v55 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          uint64_t v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 468;
          __int16 v61 = 2048;
          unint64_t v62 = v16;
          __int16 v63 = 2048;
          unint64_t v64 = v25;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_26:
          uint64_t v55 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          uint64_t v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 468;
          __int16 v61 = 2048;
          unint64_t v62 = v16;
          __int16 v63 = 2048;
          unint64_t v64 = v25;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        int8x8_t v26 = v23;
        float v27 = v24;
        *(void *)(v52 + 8 * v16) = v24;
        uint64_t v28 = re::globalAllocators(v23);
        unint64_t v29 = (re **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[2] + 32))(v28[2], 16, 8);
        *unint64_t v29 = v26;
        v29[1] = v27;
        uint64_t v30 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s_primitive", (re::DynamicString *)&v47, *((void *)v44 + 2));
        uint64_t v31 = *(_anonymous_namespace_ **)(a3 + 104);
        if (v48) {
          uint64_t v32 = *(const char **)&v49[7];
        }
        else {
          uint64_t v32 = v49;
        }
        *(void *)&long long v65 = 0;
        *((void *)&v65 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = "";
        uint64_t v33 = *((void *)&v65 + 1);
        long long v34 = (re::CollisionShapeAsset *)strlen(*((const char **)&v65 + 1));
        long long v35 = re::CollisionShapeAsset::assetType(v34);
        uint64_t v36 = re::ImportAssetTable::addAsset(v31, v33, (uint64_t)v34, v29, (re **)v35);
        re::StringID::destroyString((re::StringID *)&v65);
        memset(v46, 0, sizeof(v46));
        if (*(unsigned char *)(v36 + 8)) {
          uint64_t v38 = *(re::AssetPath **)(v36 + 16);
        }
        else {
          uint64_t v38 = (re::AssetPath *)(v36 + 9);
        }
        unint64_t v25 = *(void *)(v11 + 24);
        if (v25 <= v16) {
          goto LABEL_25;
        }
        re::AssetHandle::operator=(*(void *)(v11 + 32) + v15 + 48, v46);
        unint64_t v25 = *(void *)(v11 + 24);
        if (v25 <= v16) {
          goto LABEL_26;
        }
        uint64_t v39 = *(void *)(v11 + 32) + v15;
        long long v40 = *(_OWORD *)&v56[24];
        *(_OWORD *)(v39 + 16) = *(_OWORD *)&v56[8];
        *(_OWORD *)(v39 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v40;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v46);
        if (v47 && (v48 & 1) != 0) {
          (*(void (**)(void))(*(void *)v47 + 40))();
        }
        v15 += 80;
        v17 += 6;
        ++v16;
        unint64_t v4 = v22;
        uint64_t v5 = v20;
      }
      while (v17 != v43);
    }
    *(unsigned char *)(v11 + 40) = 1;
    re::convertToCompoundPrimitiveCollisionShape(v11, (uint64_t)&v50, v42, v42);
    if (v50 && v51) {
      (*(void (**)(void))(*(void *)v50 + 40))();
    }
  }
  else
  {
    long long v53 = (re *)re::cloneCollisionShapeData(a1, v8);
    re::convertFromSerializable(v53, (const re::CollisionShapeData *)&v54, v9, (re::Allocator *)v9, (re::Allocator *)1);
    return v53;
  }
  return (re *)v11;
}

uint64_t re::convertToCompoundPrimitiveCollisionShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(void *)(a1 + 24);
  uint64_t v24 = 0;
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  re::FixedArray<unsigned long>::init<>(&v24, a4, v8);
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  uint64_t v23 = 0;
  re::FixedArray<re::Pose<float>>::init<>(&v21, a4, v8);
  if (v8)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    uint64_t v11 = &v36;
    unint64_t v12 = v25;
    unint64_t v13 = v22;
    uint64_t v14 = 16;
    do
    {
      unint64_t v15 = *(void *)(a2 + 8);
      if (v15 <= v10)
      {
        uint64_t v27 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v38 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 476;
        __int16 v32 = 2048;
        unint64_t v33 = v10;
        __int16 v34 = 2048;
        unint64_t v35 = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_16:
        uint64_t v27 = 0;
        v11[3] = 0u;
        v11[4] = 0u;
        void v11[2] = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 468;
        __int16 v32 = 2048;
        unint64_t v33 = v12;
        __int16 v34 = 2048;
        unint64_t v35 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_17:
        uint64_t v27 = 0;
        v11[3] = 0u;
        v11[4] = 0u;
        void v11[2] = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 476;
        __int16 v32 = 2048;
        unint64_t v33 = v10;
        __int16 v34 = 2048;
        unint64_t v35 = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_18:
        uint64_t v27 = 0;
        v11[3] = 0u;
        v11[4] = 0u;
        void v11[2] = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v28 = 136315906;
        unint64_t v29 = "operator[]";
        __int16 v30 = 1024;
        int v31 = 468;
        __int16 v32 = 2048;
        unint64_t v33 = v13;
        __int16 v34 = 2048;
        unint64_t v35 = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (v12 == v10) {
        goto LABEL_16;
      }
      *(void *)(v26 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = *(void *)(*(void *)(a2 + 16) + 8 * v10);
      unint64_t v15 = *(void *)(a1 + 24);
      if (v15 <= v10) {
        goto LABEL_17;
      }
      if (v13 == v10) {
        goto LABEL_18;
      }
      unint64_t v16 = (_OWORD *)(*(void *)(a1 + 32) + v14);
      uint64_t v17 = (_OWORD *)(v23 + v9);
      long long v18 = v16[1];
      *uint64_t v17 = *v16;
      v17[1] = v18;
      ++v10;
      v14 += 80;
      v9 += 32;
    }
    while (v8 != v10);
  }
  if (v21 && v22) {
    (*(void (**)(void))(*(void *)v21 + 40))();
  }
  if (v24 && v25) {
    (*(void (**)(void))(*(void *)v24 + 40))();
  }
  return v19;
}

unint64_t re::ecs2::EntityAssetData::addComponent<re::ecs2::RigidBodyComponent>(_DWORD *a1)
{
  uint64_t v1 = (_anonymous_namespace_ *)(a1 + 8);
  if (!*((void *)a1 + 4))
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v1, 0);
    ++a1[14];
  }
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                             + 7)
                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 400, 0);
  re::make::shared::inplace<re::ecs2::RigidBodyComponent>(v3, &v10);
  unint64_t v4 = v10;
  unint64_t v5 = *(void *)((*(uint64_t (**)(unint64_t))(*(void *)v10 + 40))(v10) + 24) >> 1;
  unint64_t v6 = v10;
  unint64_t v10 = 0;
  v8.n128_u64[0] = v5;
  v8.n128_u64[1] = v6;
  char v9 = 1;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v1, &v8);
  if (v10) {

  }
  return v4;
}

id re::make::shared::inplace<re::ecs2::ColliderComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 160) = 0;
  unint64_t v4 = (id *)(a1 + 160);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v5 + 16) = 0;
  *(unsigned char *)(v5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  *(void *)uint64_t v5 = &unk_26E6DFC48;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(unsigned char *)(v5 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(void *)(v5 + 60) = 0x100000000;
  *(_DWORD *)(v5 + 68) = -1;
  *(void *)(v5 + 152) = 0;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_OWORD *)(v5 + 88) = 0u;
  *(_OWORD *)(v5 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(void *)(v5 + 120) = 0;
  id result = objc_initWeak(v4, 0);
  *a2 = a1;
  return result;
}

void re::ecs2::ColliderComponent::~ColliderComponent(re::ecs2::ColliderComponent *this)
{
  *(void *)this = &unk_26E6DFC48;
  objc_destroyWeak((id *)this + 20);
  *((void *)this + 20) = 0;
  std::unique_ptr<re::CollisionObject,std::function<void ()(re::CollisionObject*)>>::~unique_ptr[abi:nn180100]((uint64_t *)this + 15);
  re::AssetHandle::~AssetHandle((re::ecs2::ColliderComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle((re::ecs2::ColliderComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DFC48;
  objc_destroyWeak((id *)this + 20);
  *((void *)this + 20) = 0;
  std::unique_ptr<re::CollisionObject,std::function<void ()(re::CollisionObject*)>>::~unique_ptr[abi:nn180100]((uint64_t *)this + 15);
  re::AssetHandle::~AssetHandle((re::ecs2::ColliderComponent *)((char *)this + 72));
  re::AssetHandle::~AssetHandle((re::ecs2::ColliderComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

uint64_t *std::unique_ptr<re::CollisionObject,std::function<void ()(re::CollisionObject*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::CollisionObject *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::CollisionObject *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void *std::function<void ()(re::CollisionObject *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  unint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<void ()(re::CollisionObject *)>::~__value_func[abi:nn180100](v4);
}

void *std::__function::__value_func<void ()(re::CollisionObject *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id re::make::shared::inplace<re::ecs2::RigidBodyComponent>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 38re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 2re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v4 + 16) = 0;
  *(_WORD *)(v4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  *(void *)uint64_t v4 = &unk_26E6E0608;
  *(void *)(v4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0x3F80000000000000;
  *(int32x4_t *)(v4 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = vdupq_n_s32(0x3DCCCCCDu);
  *(_DWORD *)(v4 + 80) = 1065353216;
  *(void *)(v4 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v4 + 112) = 0;
  *(void *)(v4 + 96) = 0;
  *(_DWORD *)(v4 + 120) = 2;
  *(void *)(v4 + 1re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  *(unsigned char *)(v4 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(v4 + 136) = 0;
  *(_DWORD *)(v4 + 14re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 16842752;
  *(void *)(v4 + 148) = 0xBD4CCCCDBCA3D70ALL;
  *(unsigned char *)(v4 + 1re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 1;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 2re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 2re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0u;
  *(_DWORD *)(a1 + 272) = 0;
  id result = objc_initWeak((id *)(v4 + 280), 0);
  *(_DWORD *)(a1 + 288) = 2;
  *(void *)(a1 + 30re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)this + 328) = 0x3F80000000000000;
  *(void *)(a1 + 38re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(a1 + 34re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 336) = 0;
  *a2 = a1;
  return result;
}

void re::ecs2::RigidBodyComponent::~RigidBodyComponent(re::ecs2::RigidBodyComponent *this)
{
  *(void *)this = &unk_26E6E0608;
  std::unique_ptr<re::RigidBody,std::function<void ()(re::RigidBody*)>>::~unique_ptr[abi:nn180100]((uint64_t *)this + 44);
  objc_destroyWeak((id *)this + 35);
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 35) = 0;
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 248));
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 224));
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 96));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6E0608;
  std::unique_ptr<re::RigidBody,std::function<void ()(re::RigidBody*)>>::~unique_ptr[abi:nn180100]((uint64_t *)this + 44);
  objc_destroyWeak((id *)this + 35);
  *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 35) = 0;
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 248));
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 224));
  re::AssetHandle::~AssetHandle((re::ecs2::RigidBodyComponent *)((char *)this + 96));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

uint64_t *std::unique_ptr<re::RigidBody,std::function<void ()(re::RigidBody*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::RigidBody *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::RigidBody *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void *std::function<void ()(re::RigidBody *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<void ()(re::RigidBody *)>::~__value_func[abi:nn180100](v4);
}

void *std::__function::__value_func<void ()(re::RigidBody *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::create(void *a1@<X8>)
{
  uint64_t v2 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                                                                                + 7)
                                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType+ 7), 32, 0);
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  ArcSharedObject::ArcSharedObject(v2, 0);
  *(void *)(v3 + 16) = 0;
  *(_WORD *)(v3 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  *(void *)uint64_t v3 = &unk_26E6E0828;
  *a1 = v3;
}

void re::ecs2::GroundPlaneComponent::~GroundPlaneComponent(re::ecs2::GroundPlaneComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::GroundPlaneComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
}

void re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(void *a1@<X8>)
{
  uint64_t v2 = (ArcSharedObject *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                                + 7)
                                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 32, 0);
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
  ArcSharedObject::ArcSharedObject(v2, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  *(void *)uint64_t v3 = &unk_26E6E00A8;
  *a1 = v3;
}

void re::ecs2::PhysicsOriginComponent::~PhysicsOriginComponent(re::ecs2::PhysicsOriginComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::HashTable<re::StringID,re::Pair<re::StringID,re::StringID,true>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          uint64_t v8 = v6 + v4;
          *(_DWORD *)(v6 + vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v7 & 0x7FFFFFFF;
          char v9 = (re::StringID *)(v6 + v4 + 40);
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 8));
          re::StringID::destroyString(v9);
          re::StringID::destroyString((re::StringID *)(v8 + 24));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 56;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void *re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          double result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1536, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              double result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            double result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v8;
          }
LABEL_22:
          unint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            unint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    void v3[5] = 0;
    double result = (void *)re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

re::DynamicString *re::HashTable<re::DynamicString,re::ImportAssetTable::ImportedAsset *,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v10 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v27, 0, 36);
          *(void *)&v27[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v27, v14, v13);
          long long v16 = *(_OWORD *)v27;
          *(_OWORD *)uint64_t v27 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v27[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v27[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v27[24];
          *(_OWORD *)&char v27[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v27[32];
          *(_OWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v20;
          uint64_t v21 = v19;
          if (v19)
          {
            uint64_t v22 = v18 + 48;
            do
            {
              if ((*(_DWORD *)(v22 - 40) & 0x80000000) != 0) {
                re::HashTable<re::DynamicString,re::ImportAssetTable::ImportedAsset *,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(v22 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 48), v22 - 32, v22);
              }
              v22 += 56;
              --v21;
            }
            while (v21);
          }
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v27);
        }
      }
      else
      {
        if (v13) {
          signed int v25 = 2 * v12;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 56 * v10 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = a3;
  double result = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  *(void *)(*(void *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t re::BucketArray<re::ImportAssetTable::ImportedAsset,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 5) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 5)) + 48 * (a2 & 0x1F);
}

double re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 288;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[5]>(uint64_t a1, re::DynamicString *a2, int a3, const char *a4)
{
  unint64_t v8 = re::Hash<re::DynamicString>::operator()((uint64_t)&v18, (uint64_t)a2);
  unint64_t v9 = v8;
  if (!*(void *)a1)
  {
    LODWORD(vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0;
    goto LABEL_8;
  }
  unint64_t v10 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v10);
  if (v11 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const(&)[5]>(a1, v10, v9, a2, a4);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 16) + 80 * v13;
    return v14 + 48;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v12 + 80 * v11 + 16, (uint64_t)a2))
  {
    uint64_t v11 = *(_DWORD *)(v12 + 80 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  switch(a3)
  {
    case 0:
    case 1:
      uint64_t v14 = v12 + 80 * v11;
      break;
    case 2:
    case 3:
      re::DynamicString::deinit((re::DynamicString *)(v12 + 80 * v11 + 48));
      long long v16 = (re::DynamicString *)(*(void *)(a1 + 16) + 80 * v11 + 48);
      ++*(_DWORD *)(a1 + 40);
      uint64_t v14 = *(void *)(a1 + 16) + 80 * v11;
      break;
    default:
      goto LABEL_8;
  }
  return v14 + 48;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const(&)[5]>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, const char *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 80 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = a3;
  uint64_t v14 = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 80 * v10 + 16), a4);
  BOOL v15 = (re::DynamicString *)(*(void *)(a1 + 16) + 80 * v10 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[6]>(uint64_t a1, re::DynamicString *a2, int a3, const char *a4)
{
  unint64_t v8 = re::Hash<re::DynamicString>::operator()((uint64_t)&v18, (uint64_t)a2);
  unint64_t v9 = v8;
  if (!*(void *)a1)
  {
    LODWORD(vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = 0;
    goto LABEL_8;
  }
  unint64_t v10 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v10);
  if (v11 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const(&)[5]>(a1, v10, v9, a2, a4);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 16) + 80 * v13;
    return v14 + 48;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v12 + 80 * v11 + 16, (uint64_t)a2))
  {
    uint64_t v11 = *(_DWORD *)(v12 + 80 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  switch(a3)
  {
    case 0:
    case 1:
      uint64_t v14 = v12 + 80 * v11;
      break;
    case 2:
    case 3:
      re::DynamicString::deinit((re::DynamicString *)(v12 + 80 * v11 + 48));
      long long v16 = (re::DynamicString *)(*(void *)(a1 + 16) + 80 * v11 + 48);
      ++*(_DWORD *)(a1 + 40);
      uint64_t v14 = *(void *)(a1 + 16) + 80 * v11;
      break;
    default:
      goto LABEL_8;
  }
  return v14 + 48;
}

double re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 72;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
    uint64_t v3 = *(void **)(a1 + 56);
  }
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addEmplace<re::MaterialInfoUSK&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = a3;
  uint64_t v14 = *(void *)(a1 + 16) + 72 * v10;
  *(unsigned char *)(v14 + 16) = *(unsigned char *)a4;
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 24), (re::DynamicString *)((char *)a4 + 8));
  uint64_t v15 = *(void *)(a1 + 16) + 72 * v10;
  *(void *)(v15 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(id *)a5;
  int v16 = *(_DWORD *)(a5 + 8);
  *(unsigned char *)(v15 + 68) = *(unsigned char *)(a5 + 12);
  *(_DWORD *)(v15 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v16;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

unint64_t re::Hash<re::ImportMaterialSignature>::operator()(uint64_t a1, char *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  char v10 = *a2;
  unint64_t v3 = *((void *)a2 + 2);
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (v4)
  {
    uint64_t v5 = (uint64_t)(a2 + 17);
    uint64_t v6 = *((void *)a2 + 3);
    if (v3) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v5;
    }
    MurmurHash3_x64_128(v7, v4, 0, &v11);
    unint64_t v8 = (v12 - 0x61C8864680B583E9 + (v11 << 6) + (v11 >> 2)) ^ v11;
  }
  else
  {
    unint64_t v8 = 0;
  }
  MurmurHash3_x64_128((uint64_t)&v10, 1, 0, &v11);
  return ((v8 << 6) - 0x61C8864680B583E9 + (v8 >> 2) + ((v12 - 0x61C8864680B583E9 + (v11 << 6) + (v11 >> 2)) ^ v11)) ^ v8;
}

void re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16), (uint64_t *)(*(void *)&v13[16] + v10 + 56));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 72;
        }
        while (v11 < v9);
      }
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = a3;
  uint64_t v14 = *(void *)(a1 + 16) + 72 * v10;
  *(unsigned char *)(v14 + 16) = *(unsigned char *)a4;
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 24), (re::DynamicString *)((char *)a4 + 8));
  uint64_t v15 = *(void *)(a1 + 16) + 72 * v10;
  uint64_t v16 = *a5;
  *a5 = 0;
  *(void *)(v15 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v16;
  LODWORD(v16) = *((_DWORD *)a5 + 2);
  *(unsigned char *)(v15 + 68) = *((unsigned char *)a5 + 12);
  *(_DWORD *)(v15 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v16;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 192));
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 144));
    re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(a1 + 104);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 56));
    uint64_t v2 = *(void *)(a1 + 48);
    if (v2)
    {

      *(void *)(a1 + 48) = 0;
    }
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {

      *(void *)(a1 + 40) = 0;
    }
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {

      *(void *)(a1 + 16) = 0;
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomModelDescriptor>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 216 * v4;
        do
        {
          uint64_t v7 = v3 + v5;
          re::DynamicString::deinit((re::DynamicString *)(v3 + v5 + 184));
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v3 + v5 + 136));
          re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(v3 + v5 + 96);
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v3 + v5 + 48));
          uint64_t v8 = *(void *)(v3 + v5 + 40);
          if (v8)
          {

            *(void *)(v7 + 40) = 0;
          }
          uint64_t v9 = *(void *)(v7 + 32);
          if (v9)
          {

            *(void *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
          }
          uint64_t v10 = *(void *)(v3 + v5 + 8);
          if (v10)
          {

            *(void *)(v3 + v5 + 8) = 0;
          }
          v5 += 216;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::GeomModelDescriptor>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::GeomModelDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xD8uLL))
        {
          uint64_t v2 = 216 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 216 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_22;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 216, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_22:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 216 * v9;
        do
        {
          uint64_t v12 = v8 + v10;
          re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)&v7[v10 / 8], v8 + v10);
          re::DynamicString::deinit((re::DynamicString *)(v8 + v10 + 184));
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v8 + v10 + 136));
          re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(v8 + v10 + 96);
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v8 + v10 + 48));
          uint64_t v13 = *(void *)(v8 + v10 + 40);
          if (v13)
          {

            *(void *)(v12 + 40) = 0;
          }
          uint64_t v14 = *(void *)(v12 + 32);
          if (v14)
          {

            *(void *)(v12 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
          }
          uint64_t v15 = *(void *)(v8 + v10 + 8);
          if (v15)
          {

            *(void *)(v8 + v10 + 8) = 0;
          }
          v10 += 216;
        }
        while (v11 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_22;
    }
  }
  return result;
}

void std::__shared_ptr_pointer<re::usdimport::SpatialAudioNodeData *,re::loadTransformAndMeshNodes(USKScene *,USKNode *,re::USDImportContext &,BOOL)::$_0,std::allocator<re::usdimport::SpatialAudioNodeData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x237DBCBD0);
}

re *std::__shared_ptr_pointer<re::usdimport::SpatialAudioNodeData *,re::loadTransformAndMeshNodes(USKScene *,USKNode *,re::USDImportContext &,BOOL)::$_0,std::allocator<re::usdimport::SpatialAudioNodeData>>::__on_zero_shared(re *result)
{
  uint64_t v1 = *((void *)result + 3);
  if (v1)
  {
    uint64_t v2 = re::globalAllocators(result)[2];
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(v1 + 48));
    uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<re::usdimport::SpatialAudioNodeData *,re::loadTransformAndMeshNodes(USKScene *,USKNode *,re::USDImportContext &,BOOL)::$_0,std::allocator<re::usdimport::SpatialAudioNodeData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v10 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(void *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v31, v14, v13);
          long long v16 = *(_OWORD *)v31;
          *(_OWORD *)int v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v31[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v31[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v31[24];
          *(_OWORD *)&unsigned char v31[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v20;
          uint64_t v21 = v19;
          if (v19)
          {
            uint64_t v22 = v18 + 48;
            do
            {
              if ((*(_DWORD *)(v22 - 40) & 0x80000000) != 0) {
                re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(v22 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 48), v22 - 32, v22);
              }
              v22 += 88;
              --v21;
            }
            while (v21);
          }
          re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v13) {
          signed int v25 = 2 * v12;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 88 * v10 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 88 * v10 + 8) = v24 | 0x80000000;
  uint64_t v26 = 88 * v10;
  *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v26) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + v26 + 16), a4);
  uint64_t v27 = *(void *)(a1 + 16) + 88 * v10;
  *(void *)(v27 + 80) = 0;
  *(_DWORD *)(v27 + 72) = 0;
  *(void *)(v27 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
  *(void *)(v27 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v27 + 48) = 0;
  *(void *)(v27 + 48) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(v27 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  uint64_t v28 = *(void *)(v27 + 64);
  *(void *)(v27 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v28;
  uint64_t v29 = *(void *)(v27 + 80);
  *(void *)(v27 + 80) = *(void *)(a5 + 32);
  *(void *)(a5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v29;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v27 + 72);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void *re::DynamicArray<re::ImportedScene>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::ImportedScene>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA0uLL))
        {
          uint64_t v2 = 160 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 160 * v9;
        uint64_t v11 = v8 + 96;
        int v12 = v7;
        do
        {
          long long v13 = *(_OWORD *)(v11 - 96);
          *((_OWORD *)v12 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0u;
          *((_OWORD *)v12 + 2) = 0u;
          *(_OWORD *)int v12 = v13;
          void v12[2] = *(void *)(v11 - 80);
          *(void *)(v11 - 80) = 0;
          _OWORD v12[5] = *(void *)(v11 - 56);
          *(void *)(v11 - re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = 0;
          uint64_t v15 = v12[3];
          uint64_t v14 = v12[4];
          uint64_t v16 = *(void *)(v11 - 64);
          v12[3] = *(void *)(v11 - 72);
          v12[4] = v16;
          *(void *)(v11 - 72) = v15;
          *(void *)(v11 - 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v14;
          v12[6] = *(void *)(v11 - 48);
          *(_OWORD *)(v12 + 9) = 0u;
          *(_OWORD *)(v12 + re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0u;
          v12[7] = *(void *)(v11 - 40);
          *(void *)(v11 - 40) = 0;
          v12[10] = *(void *)(v11 - 16);
          *(void *)(v11 - 16) = 0;
          uint64_t v18 = v12[8];
          uint64_t v17 = v12[9];
          uint64_t v19 = *(void *)(v11 - 24);
          v12[8] = *(void *)(v11 - 32);
          v12[9] = v19;
          *(void *)(v11 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v18;
          *(void *)(v11 - re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v17;
          *((unsigned char *)v12 + 88) = *(unsigned char *)(v11 - 8);
          v12[13] = 0;
          v12[14] = 0;
          v12[12] = 0;
          v12[13] = *(void *)(v11 + 8);
          *(void *)(v11 + 8) = 0;
          uint64_t v20 = v12[12];
          v12[12] = 0;
          v12[12] = *(void *)v11;
          *(void *)uint64_t v11 = v20;
          uint64_t v21 = v12[14];
          v12[14] = *(void *)(v11 + 16);
          *(void *)(v11 + 16) = v21;
          v12[19] = 0;
          v12[16] = 0;
          v12[17] = 0;
          v12[15] = 0;
          *((_DWORD *)v12 + 36) = 0;
          uint64_t v22 = *(void *)(v11 + 32);
          v12[15] = *(void *)(v11 + 24);
          *(void *)(v11 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
          v12[16] = v22;
          *(void *)(v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
          uint64_t v23 = v12[17];
          v12[17] = *(void *)(v11 + 40);
          *(void *)(v11 + 40) = v23;
          uint64_t v24 = v12[19];
          v12[19] = *(void *)(v11 + 56);
          *(void *)(v11 + re::DynamicArray<re::BlendShapeWeights>::deinit((uint64_t)this + 56) = v24;
          ++*(_DWORD *)(v11 + 48);
          ++*((_DWORD *)v12 + 36);
          re::DynamicArray<re::AssetHandle>::deinit(v11 + 24);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v11);
          re::DynamicString::deinit((re::DynamicString *)(v11 - 40));
          re::DynamicString::deinit((re::DynamicString *)(v11 - 80));
          uint64_t v25 = v11 + 64;
          v11 += 160;
          v12 += 20;
        }
        while (v25 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::DynamicString *re::TimelineCompiler::getCurrentCompiledAssetInfo@<X0>(re::TimelineCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::TimelineAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TimelineAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::TimelineCompiler::assetIntrospectionType(re::TimelineCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TimelineAsset>(void)::info = re::introspect_TimelineAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[372];
}

uint64_t re::TimelineCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::TimelineCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 2;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

re *re::TimelineCompiler::compile@<X0>(re::TimelineCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v9 = re::globalAllocators(this);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9[2] + 32))(v9[2], 24, 8);
  *(void *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = 0;
  *(void *)uint64_t v10 = 0;
  uint64_t v11 = (*(uint64_t (**)(re::TimelineCompiler *))(*(void *)this + 24))(this);
  uint64_t result = (re *)re::AssetUtilities::readSourceJson(a2, (const char *)v10, v11, a3, (uint64_t)v21);
  if (v21[0])
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v10;
  }
  else
  {
    long long v13 = re::globalAllocators(result);
    uint64_t v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13[2] + 40))(v13[2], v10);
    long long v15 = v18;
    uint64_t v16 = v19;
    uint64_t v17 = v20;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 100;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v15;
    *(void *)(a4 + 40) = v16;
    *(void *)(a4 + 48) = v17;
    if (!v21[0])
    {
      uint64_t result = v22;
      if (v22)
      {
        if (v23) {
          return (re *)(*(uint64_t (**)(void))(*(void *)v22 + 40))();
        }
      }
    }
  }
  return result;
}

re *re::TimelineCompiler::deleteAsset(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::TimelineCompiler::~TimelineCompiler(re::TimelineCompiler *this)
{
}

re::DynamicString *re::HMTextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::HMTextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::TextureAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::HMTextureCompiler::assetIntrospectionType(re::HMTextureCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[262];
}

void *re::HMTextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::HMTextureCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re::DynamicString *re::HMTextureCompiler::compile@<X0>(re::HMTextureCompiler *this@<X0>, char *a2@<X1>, void *a3@<X2>, re::AssetSerializationScheme *a4@<X3>, uint64_t a5@<X8>)
{
  v49[4] = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    re::DynamicString::setCapacity(&v45, 0);
    uint64_t v10 = strrchr(a2, 46);
    uint64_t v11 = (_anonymous_namespace_ *)strcmp(v10, ".hmtexture");
    if (v11)
    {
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      long long v36 = 0uLL;
      re::DynamicString::setCapacity(&v35, 0);
      re::DynamicString::assignf((re::DynamicString *)&v35, "Unexpected file extension HMTextureCompiler cannot compile %s");
      goto LABEL_4;
    }
    v49[0] = &unk_26E6E0B68;
    v49[1] = this;
    void v49[3] = v49;
    re::pathsToFilesInDirectory((uint64_t)a2, (uint64_t)v49, (uint64_t)buf);
    uint64_t v20 = (_anonymous_namespace_ *)std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](v49);
    if (buf[0])
    {
      if (*((void *)&v42 + 1))
      {
        re::DynamicString::operator=((re::DynamicString *)&v45, v44);
        re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result(buf);
        if (v46) {
          uint64_t v21 = v47;
        }
        else {
          uint64_t v21 = (char *)&v46 + 1;
        }
        uint64_t v22 = strrchr(v21, 46);
        uint64_t v23 = *((void *)this + 1);
        {
          re::introspect<re::AssetCompilerService>(void)::info = re::introspect_AssetCompilerService(0);
        }
        uint64_t v24 = re::introspect<re::AssetCompilerService>(void)::info;
        re::StringID::invalid((re::StringID *)buf);
        uint64_t v25 = (uint64_t (***)(void, char *))(*(uint64_t (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v23 + 16))(v23, v24, buf);
        re::StringID::destroyString((re::StringID *)buf);
        if (!v25)
        {
          int v31 = (re::internal *)re::introspect<re::AssetCompilerService>();
          re::StringID::invalid((re::StringID *)&v35);
          re::internal::missingServiceErrorMessage(v31, (const re::IntrospectionBase *)&v35, (re::DynamicString *)buf);
          re::DynamicString::~DynamicString((re::DynamicString *)buf);
          re::StringID::~StringID((re::StringID *)&v35);
          __int16 v32 = (re::internal *)re::introspect<re::AssetCompilerService>();
          re::StringID::invalid((re::StringID *)&v35);
          re::internal::missingServiceErrorMessage(v32, (const re::IntrospectionBase *)&v35, (re::DynamicString *)buf);
          if (buf[8]) {
            __int16 v34 = (uint8_t *)v42;
          }
          else {
            __int16 v34 = &buf[9];
          }
          re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v34);
          re::DynamicString::~DynamicString((re::DynamicString *)buf);
          re::StringID::~StringID((re::StringID *)&v35);
          _os_crash();
          __break(1u);
        }
        uint64_t v26 = (**v25)(v25, v22 + 1);
        if (v26)
        {
          if (v46) {
            uint64_t v27 = v47;
          }
          else {
            uint64_t v27 = (char *)&v46 + 1;
          }
          (*(void (**)(uint64_t, char *, void *, re::AssetSerializationScheme *))(*(void *)v26 + 40))(v26, v27, a3, a4);
LABEL_28:
          uint64_t result = (re::DynamicString *)v45;
          if (v45)
          {
            if (v46) {
              return (re::DynamicString *)(*(uint64_t (**)(void))(*v45 + 40))();
            }
          }
          return result;
        }
        *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
        long long v36 = 0uLL;
        re::DynamicString::setCapacity(&v35, 0);
        re::DynamicString::assignf((re::DynamicString *)&v35, "Failed to load texture %s\nCould not find a compiler for file %s");
LABEL_4:
        *(void *)long long buf = 100;
        *(void *)&uint8_t buf[8] = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v42, (const re::DynamicString *)&v35);
        long long v12 = v42;
        *(_OWORD *)(a5 + 8) = *(_OWORD *)buf;
        uint64_t v13 = v43;
        uint64_t v14 = v44;
        *(unsigned char *)a5 = 0;
        *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a5 + 40) = v13;
        *(void *)(a5 + 48) = v14;
        if (void)v35 && (BYTE8(v35)) {
          (*(void (**)(void))(*(void *)v35 + 40))();
        }
        goto LABEL_28;
      }
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v39, (const re::DynamicString *)&buf[8]);
    }
    *(void *)&long long v35 = 100;
    *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v36, (const re::DynamicString *)&v39);
    long long v28 = v36;
    *(_OWORD *)(a5 + 8) = v35;
    uint64_t v29 = v37;
    uint64_t v30 = v38;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v28;
    *(void *)(a5 + 40) = v29;
    *(void *)(a5 + 48) = v30;
    if (v39 && (v40 & 1) != 0) {
      (*(void (**)(void))(*(void *)v39 + 40))();
    }
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result(buf);
    goto LABEL_28;
  }
  long long v15 = *re::pipelineLogObjects(this);
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
  }
  long long v18 = *(_OWORD *)buf;
  long long v19 = v42;
  *(unsigned char *)a5 = 0;
  *(void *)(a5 + 8) = 100;
  *(void *)(a5 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
  *(_OWORD *)(a5 + 40) = v19;
  return result;
}

re *re::HMTextureCompiler::deleteAsset(re::HMTextureCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::TextureAsset>((re *)"deleteAsset", 104, a2);
}

re *re::HMTextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::HMTextureCompiler::~HMTextureCompiler(re::HMTextureCompiler *this)
{
}

void std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::~__func()
{
}

void *std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6E0B68;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6E0B68;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::operator()(uint64_t a1, re **a2)
{
  return re::canLoadTextureFileWithExtension(*a2, (const char *)a2);
}

uint64_t std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::HMTextureCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,BOOL ()(char const*)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

unsigned __int8 *re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result(unsigned __int8 *a1)
{
  int v3 = *a1;
  uint64_t v2 = (re::DynamicString *)(a1 + 8);
  if (v3) {
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)v2);
  }
  else {
    re::DynamicString::deinit(v2);
  }
  return a1;
}

uint64_t re::introspect<re::AssetCompilerService>()
{
  v0 = &qword_268772000;
  {
    v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::AssetCompilerService>(void)::info = re::introspect_AssetCompilerService(0);
      v0 = &qword_268772000;
    }
  }
  return v0[341];
}

re::DynamicString *re::StateMachineCompiler::getCurrentCompiledAssetInfo@<X0>(re::StateMachineCompiler *this@<X0>, void *a2@<X8>)
{
  *a2 = 0x100000001;
  int v2 = (re::DynamicString *)(a2 + 1);
  int v3 = (_anonymous_namespace_ *)re::StateMachineAsset::assetType(this);
  uint64_t v4 = *(const char **)v3;
}

char **re::StateMachineCompiler::assetIntrospectionType(re::StateMachineCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::StateMachineAsset>(void)::info = re::introspect_StateMachineAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[352];
}

uint64_t re::StateMachineCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = "restatemachine";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

void *re::StateMachineCompiler::compile@<X0>(re::StateMachineCompiler *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v8 = re::globalAllocators(this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 104, 8);
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(void *)(v9 + 96) = 0;
  *(void *)&long long v26 = &unk_26E6E0C60;
  *((void *)&v27 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v26;
  __int16 v32 = v31;
  uint64_t v30 = (const char *)v9;
  v31[0] = &unk_26E6E0C60;
  std::__function::__value_func<void ()(re::StateMachineAsset *)>::~__value_func[abi:nn180100](&v26);
  uint64_t v10 = strrchr(a2, 46);
  if (!strcasecmp(v10 + 1, "restatemachine"))
  {
    uint64_t v14 = v30;
    long long v15 = &off_268773000;
    goto LABEL_7;
  }
  re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v26, a2);
  long long v11 = v26;
  long long v12 = v27;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = 200;
  *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v11;
  *(_OWORD *)(a4 + 40) = v12;
  while (1)
  {
    uint64_t v13 = v30;
    uint64_t v30 = 0;
    if (!v13) {
      break;
    }
    *(void *)&long long v26 = v13;
    if (v32)
    {
      (*(void (**)(void *, long long *))(*v32 + 48))(v32, &v26);
      return std::__function::__value_func<void ()(re::StateMachineAsset *)>::~__value_func[abi:nn180100](v31);
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_15:
    *(void *)uint64_t v22 = v14;
    long long v15 = &off_268773000;
    uint64_t v14 = *(const char **)v22;
    if (v21)
    {
      re::introspect<re::StateMachineAsset>(void)::info = re::introspect_StateMachineAsset(0);
      long long v15 = &off_268773000;
      uint64_t v14 = *(const char **)v22;
    }
LABEL_7:
    re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, v14, (uint64_t)v15[352], a3, (uint64_t)v23);
    if (v23[0])
    {
      BOOL v16 = v30;
      *(unsigned char *)a4 = 1;
      *(void *)(a4 + 8) = v16;
      uint64_t v30 = 0;
      return std::__function::__value_func<void ()(re::StateMachineAsset *)>::~__value_func[abi:nn180100](v31);
    }
    *(void *)&long long v26 = 100;
    *((void *)&v26 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v27, (const re::DynamicString *)&v24);
    long long v18 = v27;
    *(_OWORD *)(a4 + 8) = v26;
    uint64_t v19 = v28;
    uint64_t v20 = v29;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
    *(void *)(a4 + 40) = v19;
    *(void *)(a4 + 48) = v20;
    if (!v23[0] && v24 && (v25 & 1) != 0) {
      (*(void (**)(void))(*(void *)v24 + 40))();
    }
  }
  return std::__function::__value_func<void ()(re::StateMachineAsset *)>::~__value_func[abi:nn180100](v31);
}

re *re::StateMachineCompiler::deleteAsset(re::StateMachineCompiler *this, re::StateMachineAsset *a2)
{
  return re::internal::destroyPersistent<re::StateMachineAsset>((re *)"deleteAsset", 56, a2);
}

void re::StateMachineCompiler::~StateMachineCompiler(re::StateMachineCompiler *this)
{
}

void std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::~__func()
{
}

void *std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6E0C60;
  return result;
}

void std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6E0C60;
}

re *std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::operator()(uint64_t a1, re::StateMachineAsset **a2)
{
  return re::internal::destroyPersistent<re::StateMachineAsset>((re *)"operator()", 34, *a2);
}

uint64_t std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::StateMachineCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::StateMachineAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::StateMachineAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

re::DynamicString *re::IBLAssetCompiler::getCurrentCompiledAssetInfo@<X0>(re::IBLAssetCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::ImageBasedLightAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::ImageBasedLightAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::IBLAssetCompiler::assetIntrospectionType(re::IBLAssetCompiler *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::ImageBasedLightAsset>(void)::info = re::introspect_ImageBasedLightAsset(0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[358];
}

void *re::IBLAssetCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, &re::IBLAssetCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re *re::IBLAssetCompiler::compile@<X0>(re::IBLAssetCompiler *this@<X0>, re::IBLAssetCompiler *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = *re::pipelineLogObjects(this);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Compiling source .reibl is not handling colorspace/gamut conversion: use REAssetManagerImageBasedLightMemoryAssetCreateFromReiblFileAsync.", v10, 2u);
  }
  return re::IBLAssetCompiler::createFromJson(a2, a3, a4);
}

re *re::IBLAssetCompiler::createFromJson@<X0>(re::IBLAssetCompiler *this@<X0>, const re::IntrospectionBase *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v8 = re::globalAllocators(this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 104, 8);
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(void *)(v9 + 96) = 0;
  re::DynamicString::setCapacity((void *)(v9 + 72), 0);
  {
    re::introspect<re::ImageBasedLightFile>(void)::info = re::introspect_ImageBasedLightFile(0);
  }
  uint64_t result = (re *)re::AssetUtilities::readSourceJson(this, (const char *)v9, re::introspect<re::ImageBasedLightFile>(void)::info, a2, (uint64_t)v19);
  if (v19[0])
  {
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v9;
  }
  else
  {
    uint64_t v11 = re::globalAllocators(result)[2];
    re::ImageBasedLightAsset::~ImageBasedLightAsset((re::ImageBasedLightAsset *)v9);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 40))(v11, v9);
    *(void *)&long long v15 = 100;
    *((void *)&v15 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
    uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)&v16, (const re::DynamicString *)&v20);
    long long v12 = v16;
    *(_OWORD *)(a3 + 8) = v15;
    uint64_t v13 = v17;
    uint64_t v14 = v18;
    *(unsigned char *)a3 = 0;
    *(_OWORD *)(a3 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
    *(void *)(a3 + 40) = v13;
    *(void *)(a3 + 48) = v14;
    if (!v19[0])
    {
      uint64_t result = v20;
      if (v20)
      {
        if (v21) {
          return (re *)(*(uint64_t (**)(void))(*(void *)v20 + 40))();
        }
      }
    }
  }
  return result;
}

re *re::IBLAssetCompiler::deleteAsset(re::IBLAssetCompiler *this, re::ImageBasedLightAsset *a2)
{
  return re::internal::destroyPersistent<re::ImageBasedLightAsset>((re *)"deleteAsset", 76, a2);
}

void re::IBLAssetCompiler::~IBLAssetCompiler(re::IBLAssetCompiler *this)
{
}

re::sg::CachedCompilationMaterial *re::copyShaderGraphParamNames@<X0>(re::sg::CachedCompilationMaterial *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = result;
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  uint64_t v4 = *((void *)result + 1);
  if (v4)
  {
    uint64_t v5 = *((void *)result + 2);
    uint64_t v6 = 144 * v4;
    do
    {
      uint64_t result = re::extractShaderGraphUniforms(v5, (_anonymous_namespace_ *)a2);
      v5 += 144;
      v6 -= 144;
    }
    while (v6);
  }
  uint64_t v7 = *((void *)v2 + 4);
  if (v7)
  {
    uint64_t v8 = *((void *)v2 + 5);
    uint64_t v9 = 144 * v7;
    do
    {
      uint64_t result = re::extractShaderGraphUniforms(v8, (_anonymous_namespace_ *)a2);
      v8 += 144;
      v9 -= 144;
    }
    while (v9);
  }
  return result;
}

re::sg::CachedCompilationMaterial *re::extractShaderGraphUniforms(uint64_t a1, _anonymous_namespace_ *a2)
{
  uint64_t result = *(re::sg::CachedCompilationMaterial **)(a1 + 48);
  if (result)
  {
    re::sg::CachedCompilationMaterial::getPublicUniforms(result, &v6);
    if (v7)
    {
      uint64_t v4 = v8;
      uint64_t v5 = 8 * v7;
      do
      {
        re::DynamicArray<NS::SharedPtr<NS::String>>::add(a2, v4++);
        v5 -= 8;
      }
      while (v5);
    }
    return (re::sg::CachedCompilationMaterial *)re::FixedArray<NS::SharedPtr<NS::String>>::deinit(&v6);
  }
  return result;
}

void re::copyCustomParamFlattenedNames(void *a1, void **a2, void **a3, void **a4, void **a5)
{
  memset(v10, 0, sizeof(v10));
  if (a1[1] == 1)
  {
    re::extractFlattenedReflection((_anonymous_namespace_ *)(a1[2] + 96), v10, a4);
    v9[0] = objc_msgSend(objc_msgSend(MEMORY[0x263EFF8C0], sel_alloc), sel_initWithObjects_count_);
    NS::SharedPtr<MTL::Texture>::operator=(a2, v9);
    if (v9[0]) {
  }
    }
  memset(v9, 0, sizeof(v9));
  if (a1[4] == 1)
  {
    re::extractFlattenedReflection((_anonymous_namespace_ *)(a1[5] + 96), (char **)v9, a5);
    uint64_t v11 = (id *)objc_msgSend(objc_msgSend(MEMORY[0x263EFF8C0], sel_alloc), sel_initWithObjects_count_);
    NS::SharedPtr<MTL::Texture>::operator=(a3, (void **)&v11);
    if (v11) {
  }
    }
  uint64_t v11 = v9;
  std::vector<NS::SharedPtr<NS::String>>::__destroy_vector::operator()[abi:nn180100](&v11);
  v9[0] = v10;
  std::vector<NS::SharedPtr<NS::String>>::__destroy_vector::operator()[abi:nn180100]((void ***)v9);
}

void re::extractFlattenedReflection(_anonymous_namespace_ *a1, char **a2, void **a3)
{
  if (*((void *)a1 + 1) >= 2uLL)
  {
    uint64_t v30 = a3;
    int v3 = (void *)*((void *)a1 + 2);
    uint64_t v4 = v3[23];
    if (v4)
    {
      uint64_t v6 = v3[24];
      uint64_t v7 = v6 + 80 * v4;
      uint64_t v31 = v7;
      do
      {
        if (*(unsigned char *)(v6 + 77))
        {
          re::DynamicString::format(v8, (re::Allocator *)"%s.%s", (re::DynamicString *)&v32, v3[15], *(void *)(v6 + 24), v30);
          id v9 = objc_msgSend(NSString, sel_alloc);
          if (v33) {
            uint64_t v10 = *(unsigned char **)&v34[7];
          }
          else {
            uint64_t v10 = v34;
          }
          id v11 = objc_msgSend(v9, sel_initWithCString_encoding_, v10, 4);
          id v12 = v11;
          uint64_t v14 = a2[1];
          unint64_t v13 = (unint64_t)a2[2];
          if ((unint64_t)v14 >= v13)
          {
            long long v16 = v8;
            uint64_t v17 = *a2;
            uint64_t v18 = (v14 - *a2) >> 3;
            unint64_t v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 61) {
              abort();
            }
            uint64_t v20 = v13 - (void)v17;
            if (v20 >> 2 > v19) {
              unint64_t v19 = v20 >> 2;
            }
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v21 = v19;
            }
            if (v21)
            {
              if (v21 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              uint64_t v22 = (char *)operator new(8 * v21);
            }
            else
            {
              uint64_t v22 = 0;
            }
            uint64_t v23 = &v22[8 * v18];
            uint64_t v24 = &v22[8 * v21];
            *(void *)uint64_t v23 = v12;
            long long v15 = v23 + 8;
            if (v14 == v17)
            {
              *a2 = v23;
              a2[1] = v15;
              a2[2] = v24;
            }
            else
            {
              do
              {
                uint64_t v25 = *((void *)v14 - 1);
                v14 -= 8;
                *((void *)v23 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v25;
                v23 -= 8;
                *(void *)uint64_t v14 = 0;
              }
              while (v14 != v17);
              uint64_t v14 = *a2;
              long long v26 = a2[1];
              *a2 = v23;
              a2[1] = v15;
              a2[2] = v24;
              if (v26 != v14)
              {
                long long v27 = v26;
                do
                {
                  uint64_t v29 = (void *)*((void *)v27 - 1);
                  v27 -= 8;
                  uint64_t v28 = v29;
                  if (v29)
                  {

                    *((void *)v26 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
                  }
                  long long v26 = v27;
                }
                while (v27 != v14);
              }
            }
            uint64_t v8 = v16;
            if (v14) {
              operator delete(v14);
            }
            uint64_t v7 = v31;
          }
          else
          {
            *(void *)uint64_t v14 = v11;
            long long v15 = v14 + 8;
          }
          a2[1] = v15;
          a1 = (_anonymous_namespace_ *)v32;
          if (v32 && (v33 & 1) != 0) {
            a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v32 + 40))();
          }
        }
        v6 += 80;
      }
      while (v6 != v7);
    }
    id v32 = objc_msgSend(NSString, sel_stringWithCString_encoding_, v3[15], 4);
    NS::SharedPtr<MTL::Texture>::operator=(v30, &v32);
    if (v32) {
  }
    }
}

uint64_t re::parseMaterialAssetMetadata(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = a1;
  if (!*a4) {
    goto LABEL_22;
  }
  uint64_t v7 = (re::DynamicString *)(a4 + 8);
  int v8 = re::DynamicString::compare(v7, (const re::DynamicString *)&v156);
  id v9 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    id v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!v8)
  {
    unsigned __int16 v27 = 0;
LABEL_45:
    int v26 = 196608;
    return v26 & 0xF0000 | v27;
  }
  int v10 = re::DynamicString::compare(v7, (const re::DynamicString *)&v156);
  id v11 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    id v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!v10)
  {
    unsigned __int16 v27 = 1;
    goto LABEL_45;
  }
  int v12 = re::DynamicString::compare(v7, (const re::DynamicString *)&v156);
  unint64_t v13 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    unint64_t v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!v12)
  {
    unsigned __int16 v27 = 0;
LABEL_252:
    int v26 = 0x40000;
    return v26 & 0xF0000 | v27;
  }
  int v14 = re::DynamicString::compare(v7, (const re::DynamicString *)&v156);
  long long v15 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!v14)
  {
    unsigned __int16 v27 = 1;
    goto LABEL_252;
  }
  int v16 = re::DynamicString::compare(v7, (const re::DynamicString *)&v156);
  a1 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!v16)
  {
    unsigned __int16 v27 = 0;
    int v26 = 0x80000;
    return v26 & 0xF0000 | v27;
  }
LABEL_22:
  uint64_t MappedTechniqueForPass = re::getMappedTechniqueForPass(a2, (uint64_t)&v156);
  uint64_t v18 = MappedTechniqueForPass;
  unint64_t v19 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    unint64_t v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (!MappedTechniqueForPass)
  {
    uint64_t v18 = re::getMappedTechniqueForPass(a2, (uint64_t)&v156);
    unint64_t v19 = (_anonymous_namespace_ *)v156;
    if (void)v156 && (BYTE8(v156)) {
      unint64_t v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
    }
    if (!v18) {
      goto LABEL_42;
    }
  }
  int v20 = re::DynamicString::compare((re::DynamicString *)(v18 + 2472), (const re::DynamicString *)&v156);
  unint64_t v21 = (_anonymous_namespace_ *)v156;
  if (void)v156 && (BYTE8(v156)) {
    unint64_t v21 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
  }
  if (v20)
  {
    int v22 = re::DynamicString::compare((re::DynamicString *)(v18 + 2472), (const re::DynamicString *)&v156);
    uint64_t v23 = (_anonymous_namespace_ *)v156;
    if (void)v156 && (BYTE8(v156)) {
      uint64_t v23 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
    }
    if (v22)
    {
      int v24 = re::DynamicString::compare((re::DynamicString *)(v18 + 2472), (const re::DynamicString *)&v156);
      uint64_t v25 = (uint64_t *)v156;
      if (void)v156 && (BYTE8(v156)) {
        uint64_t v25 = (uint64_t *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
      }
      if (v24)
      {
LABEL_42:
        int v26 = 0;
        unsigned __int16 v27 = 0;
        return v26 & 0xF0000 | v27;
      }
      if (*((void *)v6 + 48))
      {
        unint64_t v78 = 0;
        uint64_t v79 = 80;
        do
        {
          uint64_t v80 = *(void *)(*((void *)v6 + 50) + v79);
          if (v80)
          {
            float v81 = *(uint64_t **)(v80 + 264);
            uint64_t v25 = re::ShaderGraphAsset::assetType((re::ShaderGraphAsset *)v25);
            if (v81 == v25)
            {
              int v26 = 458752;
              goto LABEL_262;
            }
          }
          else
          {
            uint64_t v25 = re::ShaderGraphAsset::assetType((re::ShaderGraphAsset *)v25);
          }
          ++v78;
          v79 += 272;
        }
        while (v78 < *((void *)v6 + 48));
      }
      int v26 = 393216;
LABEL_262:
      __int16 v82 = MappedTechniqueForPass == 0;
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v129);
      if ((_BYTE)v156) {
        BOOL v83 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v83 = 1;
      }
      int v84 = v83;
      uint64_t v85 = *(_anonymous_namespace_ **)&v129[0];
      if (*(void *)&v129[0])
      {
        if (BYTE8(v129[0])) {
          uint64_t v85 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v129[0] + 40))();
        }
        memset(v129, 0, sizeof(v129));
      }
      if (v84)
      {
        re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v128);
        if ((_BYTE)v156) {
          BOOL v86 = *((void *)&v156 + 1) == 0;
        }
        else {
          BOOL v86 = 0;
        }
        int v87 = v86;
        uint64_t v85 = *(_anonymous_namespace_ **)&v128[0];
        if (*(void *)&v128[0])
        {
          if (BYTE8(v128[0])) {
            uint64_t v85 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v128[0] + 40))();
          }
          memset(v128, 0, sizeof(v128));
        }
        if (v87) {
          __int16 v88 = 2;
        }
        else {
          __int16 v88 = 4;
        }
      }
      else
      {
        __int16 v88 = 8;
      }
      unsigned __int16 v89 = v88 | v82;
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v127);
      if ((_BYTE)v156) {
        BOOL v90 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v90 = 1;
      }
      int v91 = v90;
      double v92 = *(_anonymous_namespace_ **)&v127[0];
      if (*(void *)&v127[0])
      {
        if (BYTE8(v127[0])) {
          double v92 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v127[0] + 40))();
        }
        memset(v127, 0, sizeof(v127));
      }
      if (!v91) {
        v89 |= 0x10u;
      }
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v126);
      if ((_BYTE)v156) {
        BOOL v93 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v93 = 1;
      }
      int v94 = v93;
      uint64_t v95 = *(_anonymous_namespace_ **)&v126[0];
      if (*(void *)&v126[0])
      {
        if (BYTE8(v126[0])) {
          uint64_t v95 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v126[0] + 40))();
        }
        memset(v126, 0, sizeof(v126));
      }
      if (!v94) {
        v89 |= 0x20u;
      }
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v125);
      if ((_BYTE)v156) {
        BOOL v96 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v96 = 1;
      }
      int v97 = v96;
      uint64_t v98 = *(_anonymous_namespace_ **)&v125[0];
      if (*(void *)&v125[0])
      {
        if (BYTE8(v125[0])) {
          uint64_t v98 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v125[0] + 40))();
        }
        memset(v125, 0, sizeof(v125));
      }
      if (!v97) {
        v89 |= 0x40u;
      }
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v124);
      if ((_BYTE)v156) {
        BOOL v99 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v99 = 1;
      }
      int v100 = v99;
      int v101 = *(_anonymous_namespace_ **)&v124[0];
      if (*(void *)&v124[0])
      {
        if (BYTE8(v124[0])) {
          int v101 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v124[0] + 40))();
        }
        memset(v124, 0, sizeof(v124));
      }
      if (!v100) {
        v89 |= 0x80u;
      }
      FunctionConstant = re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)&v122);
      if ((_BYTE)v156 && *((void *)&v156 + 1))
      {
        uint64_t v103 = (_anonymous_namespace_ *)v122;
        if ((void)v122)
        {
          if (BYTE8(v122)) {
            uint64_t v103 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v122 + 40))();
          }
          long long v122 = 0u;
          long long v123 = 0u;
        }
      }
      else
      {
        re::getFunctionConstant((uint64_t)&v154, a3, v18, (const re::DynamicString *)v121);
        if ((_BYTE)v154) {
          BOOL v104 = *((void *)&v154 + 1) == 0;
        }
        else {
          BOOL v104 = 1;
        }
        int v105 = !v104;
        if (*(void *)&v121[0])
        {
          if (BYTE8(v121[0])) {
            (*(void (**)(void))(**(void **)&v121[0] + 40))();
          }
          memset(v121, 0, sizeof(v121));
        }
        uint64_t v103 = (_anonymous_namespace_ *)v122;
        if ((void)v122)
        {
          if (BYTE8(v122)) {
            uint64_t v103 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v122 + 40))();
          }
          long long v122 = 0u;
          long long v123 = 0u;
        }
        if (!v105) {
          goto LABEL_357;
        }
      }
      v89 |= 0x100u;
LABEL_357:
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v120);
      if ((_BYTE)v156) {
        BOOL v106 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v106 = 1;
      }
      int v107 = v106;
      uint64_t v108 = *(_anonymous_namespace_ **)&v120[0];
      if (*(void *)&v120[0])
      {
        if (BYTE8(v120[0])) {
          uint64_t v108 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v120[0] + 40))();
        }
        memset(v120, 0, sizeof(v120));
      }
      unsigned __int16 v109 = v89 | 0x200;
      if (v107) {
        unsigned __int16 v109 = v89;
      }
      if (*((unsigned char *)v6 + 358)) {
        v109 |= 0x400u;
      }
      if (*((unsigned char *)v6 + 360)) {
        unsigned __int16 v110 = v109 | 0x800;
      }
      else {
        unsigned __int16 v110 = v109;
      }
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v119);
      if ((_BYTE)v156) {
        BOOL v111 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v111 = 1;
      }
      int v112 = v111;
      unsigned long long v113 = *(_anonymous_namespace_ **)&v119[0];
      if (*(void *)&v119[0])
      {
        if (BYTE8(v119[0])) {
          unsigned long long v113 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v119[0] + 40))();
        }
        memset(v119, 0, sizeof(v119));
      }
      if (!v112) {
        v110 |= 0x1000u;
      }
      re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)&v117);
      if ((_BYTE)v156) {
        BOOL v114 = *((void *)&v156 + 1) == 0;
      }
      else {
        BOOL v114 = 1;
      }
      int v115 = v114;
      if (v117 && (v118 & 1) != 0) {
        (*(void (**)(void))(*(void *)v117 + 40))();
      }
      unsigned __int16 v27 = v110 | 0x2000;
      if (v115) {
        unsigned __int16 v27 = v110;
      }
      return v26 & 0xF0000 | v27;
    }
    unsigned __int16 v36 = MappedTechniqueForPass == 0;
    re::getFunctionConstant((uint64_t)&v154, a3, v18, (const re::DynamicString *)&v156);
    if ((_BYTE)v154) {
      BOOL v37 = *((void *)&v154 + 1) == 0;
    }
    else {
      BOOL v37 = 1;
    }
    int v38 = v37;
    uint64_t v39 = (_anonymous_namespace_ *)v156;
    if ((void)v156)
    {
      if (BYTE8(v156)) {
        uint64_t v39 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v156 + 40))(v156, v157);
      }
      long long v156 = 0u;
      long long v157 = 0u;
    }
    if (!v38) {
      v36 |= 4u;
    }
    re::getFunctionConstant((uint64_t)&v152, a3, v18, (const re::DynamicString *)&v154);
    if ((_BYTE)v152) {
      BOOL v40 = *((void *)&v152 + 1) == 0;
    }
    else {
      BOOL v40 = 1;
    }
    int v41 = v40;
    long long v42 = (_anonymous_namespace_ *)v154;
    if ((void)v154)
    {
      if (BYTE8(v154)) {
        long long v42 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v154 + 40))(v154, v155);
      }
      long long v154 = 0u;
      long long v155 = 0u;
    }
    if (!v41) {
      v36 |= 8u;
    }
    re::getFunctionConstant((uint64_t)&v150, a3, v18, (const re::DynamicString *)&v152);
    if ((_BYTE)v150) {
      BOOL v43 = *((void *)&v150 + 1) == 0;
    }
    else {
      BOOL v43 = 1;
    }
    int v44 = v43;
    __int16 v45 = (_anonymous_namespace_ *)v152;
    if ((void)v152)
    {
      if (BYTE8(v152)) {
        __int16 v45 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v152 + 40))(v152, v153);
      }
      long long v152 = 0u;
      long long v153 = 0u;
    }
    if (!v44) {
      v36 |= 0x10u;
    }
    re::getFunctionConstant((uint64_t)&v148, a3, v18, (const re::DynamicString *)&v150);
    if ((_BYTE)v148) {
      BOOL v46 = *((void *)&v148 + 1) == 0;
    }
    else {
      BOOL v46 = 1;
    }
    int v47 = v46;
    uint64_t v48 = (_anonymous_namespace_ *)v150;
    if ((void)v150)
    {
      if (BYTE8(v150)) {
        uint64_t v48 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v150 + 40))(v150, v151);
      }
      long long v150 = 0u;
      long long v151 = 0u;
    }
    if (!v47) {
      v36 |= 0x20u;
    }
    re::getFunctionConstant((uint64_t)&v146, a3, v18, (const re::DynamicString *)&v148);
    if ((_BYTE)v146) {
      BOOL v49 = *((void *)&v146 + 1) == 0;
    }
    else {
      BOOL v49 = 1;
    }
    int v50 = v49;
    unint64_t v51 = (_anonymous_namespace_ *)v148;
    if ((void)v148)
    {
      if (BYTE8(v148)) {
        unint64_t v51 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v148 + 40))(v148, v149);
      }
      long long v148 = 0u;
      long long v149 = 0u;
    }
    if (!v50) {
      v36 |= 0x40u;
    }
    re::getFunctionConstant((uint64_t)v145, a3, v18, (const re::DynamicString *)&v146);
    if (LOBYTE(v145[0])) {
      BOOL v52 = *((void *)&v145[0] + 1) == 0;
    }
    else {
      BOOL v52 = 1;
    }
    int v53 = v52;
    uint64_t v54 = (_anonymous_namespace_ *)v146;
    if ((void)v146)
    {
      if (BYTE8(v146)) {
        uint64_t v54 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(*(void *)v146 + 40))(v146, v147);
      }
      long long v146 = 0u;
      long long v147 = 0u;
    }
    if (!v53) {
      v36 |= 0x80u;
    }
    re::getFunctionConstant((uint64_t)v144, a3, v18, (const re::DynamicString *)v145);
    if (LOBYTE(v144[0])) {
      BOOL v55 = *((void *)&v144[0] + 1) == 0;
    }
    else {
      BOOL v55 = 1;
    }
    int v56 = v55;
    int v57 = *(_anonymous_namespace_ **)&v145[0];
    if (*(void *)&v145[0])
    {
      if (BYTE8(v145[0])) {
        int v57 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v145[0] + 40))();
      }
      memset(v145, 0, sizeof(v145));
    }
    if (!v56) {
      v36 |= 0x100u;
    }
    re::getFunctionConstant((uint64_t)v143, a3, v18, (const re::DynamicString *)v144);
    if (LOBYTE(v143[0])) {
      BOOL v58 = *((void *)&v143[0] + 1) == 0;
    }
    else {
      BOOL v58 = 1;
    }
    int v59 = v58;
    int v60 = *(_anonymous_namespace_ **)&v144[0];
    if (*(void *)&v144[0])
    {
      if (BYTE8(v144[0])) {
        int v60 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v144[0] + 40))();
      }
      memset(v144, 0, sizeof(v144));
    }
    if (!v59) {
      v36 |= 0x200u;
    }
    re::getFunctionConstant((uint64_t)v142, a3, v18, (const re::DynamicString *)v143);
    if (LOBYTE(v142[0])) {
      BOOL v61 = *((void *)&v142[0] + 1) == 0;
    }
    else {
      BOOL v61 = 1;
    }
    int v62 = v61;
    __int16 v63 = *(_anonymous_namespace_ **)&v143[0];
    if (*(void *)&v143[0])
    {
      if (BYTE8(v143[0])) {
        __int16 v63 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v143[0] + 40))();
      }
      memset(v143, 0, sizeof(v143));
    }
    if (!v62) {
      v36 |= 0x400u;
    }
    re::getFunctionConstant((uint64_t)v141, a3, v18, (const re::DynamicString *)v142);
    if (LOBYTE(v141[0])) {
      BOOL v64 = *((void *)&v141[0] + 1) == 0;
    }
    else {
      BOOL v64 = 1;
    }
    int v65 = v64;
    long long v66 = *(_anonymous_namespace_ **)&v142[0];
    if (*(void *)&v142[0])
    {
      if (BYTE8(v142[0])) {
        long long v66 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v142[0] + 40))();
      }
      memset(v142, 0, sizeof(v142));
    }
    if (!v65) {
      v36 |= 0x800u;
    }
    re::getFunctionConstant((uint64_t)v140, a3, v18, (const re::DynamicString *)v141);
    if (LOBYTE(v140[0])) {
      BOOL v67 = *((void *)&v140[0] + 1) == 0;
    }
    else {
      BOOL v67 = 1;
    }
    int v68 = v67;
    long long v69 = *(_anonymous_namespace_ **)&v141[0];
    if (*(void *)&v141[0])
    {
      if (BYTE8(v141[0])) {
        long long v69 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v141[0] + 40))();
      }
      memset(v141, 0, sizeof(v141));
    }
    if (!v68) {
      v36 |= 2u;
    }
    re::getFunctionConstant((uint64_t)v139, a3, v18, (const re::DynamicString *)v140);
    if (LOBYTE(v139[0])) {
      BOOL v70 = *((void *)&v139[0] + 1) == 0;
    }
    else {
      BOOL v70 = 1;
    }
    int v71 = v70;
    char v72 = *(_anonymous_namespace_ **)&v140[0];
    if (*(void *)&v140[0])
    {
      if (BYTE8(v140[0])) {
        char v72 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v140[0] + 40))();
      }
      memset(v140, 0, sizeof(v140));
    }
    if (!v71) {
      v36 |= 0x1000u;
    }
    re::getFunctionConstant((uint64_t)&v135, a3, v18, (const re::DynamicString *)v139);
    if ((_BYTE)v135) {
      BOOL v73 = v136 == 0;
    }
    else {
      BOOL v73 = 1;
    }
    int v74 = v73;
    uint64_t v75 = *(_anonymous_namespace_ **)&v139[0];
    if (*(void *)&v139[0])
    {
      if (BYTE8(v139[0])) {
        uint64_t v75 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v139[0] + 40))();
      }
      memset(v139, 0, sizeof(v139));
    }
    if (!v74) {
      v36 |= 0x2000u;
    }
    re::getFunctionConstant((uint64_t)v137, a3, v18, (const re::DynamicString *)&v135);
    if (v137[0]) {
      BOOL v76 = v138 == 0;
    }
    else {
      BOOL v76 = 1;
    }
    int v77 = v76;
    if (v135 && (v136 & 1) != 0) {
      (*(void (**)(void))(*(void *)v135 + 40))();
    }
    unsigned __int16 v27 = v36 | 0x4000;
    if (v77) {
      unsigned __int16 v27 = v36;
    }
    int v26 = 0x10000;
  }
  else
  {
    unsigned __int16 v28 = MappedTechniqueForPass == 0;
    re::getFunctionConstant((uint64_t)&v156, a3, v18, (const re::DynamicString *)v134);
    uint64_t v29 = *(_anonymous_namespace_ **)&v134[0];
    if (*(void *)&v134[0])
    {
      if (BYTE8(v134[0])) {
        uint64_t v29 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v134[0] + 40))();
      }
      memset(v134, 0, sizeof(v134));
    }
    if (*((void *)&v156 + 1)) {
      BOOL v30 = v156 == 0;
    }
    else {
      BOOL v30 = 1;
    }
    if (!v30) {
      v28 |= 2u;
    }
    re::getFunctionConstant((uint64_t)&v154, a3, v18, (const re::DynamicString *)v133);
    uint64_t v31 = *(_anonymous_namespace_ **)&v133[0];
    if (*(void *)&v133[0])
    {
      if (BYTE8(v133[0])) {
        uint64_t v31 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v133[0] + 40))();
      }
      memset(v133, 0, sizeof(v133));
    }
    if (*((void *)&v154 + 1)) {
      BOOL v32 = v154 == 0;
    }
    else {
      BOOL v32 = 1;
    }
    if (!v32) {
      v28 |= 4u;
    }
    re::getFunctionConstant((uint64_t)&v152, a3, v18, (const re::DynamicString *)v132);
    char v33 = *(_anonymous_namespace_ **)&v132[0];
    if (*(void *)&v132[0])
    {
      if (BYTE8(v132[0])) {
        char v33 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)&v132[0] + 40))();
      }
      memset(v132, 0, sizeof(v132));
    }
    if (*((void *)&v152 + 1)) {
      BOOL v34 = v152 == 0;
    }
    else {
      BOOL v34 = 1;
    }
    if (!v34) {
      v28 |= 8u;
    }
    re::getFunctionConstant((uint64_t)&v150, a3, v18, (const re::DynamicString *)&v130);
    if (v130 && (v131 & 1) != 0) {
      (*(void (**)(void))(*(void *)v130 + 40))();
    }
    if (*((void *)&v150 + 1)) {
      BOOL v35 = v150 == 0;
    }
    else {
      BOOL v35 = 1;
    }
    unsigned __int16 v27 = v28 | 0x10;
    if (v35) {
      unsigned __int16 v27 = v28;
    }
    int v26 = 0x20000;
  }
  return v26 & 0xF0000 | v27;
}

uint64_t re::getMappedTechniqueForPass(uint64_t a1, uint64_t a2)
{
  v9[2] = *MEMORY[0x263EF8340];
  if (*(void *)(a2 + 8)) {
    int v3 = *(const char **)(a2 + 16);
  }
  else {
    int v3 = (const char *)(a2 + 9);
  }
  size_t v4 = strlen(v3);
  if (v4)
  {
    MurmurHash3_x64_128((uint64_t)v3, v4, 0, (unint64_t *)v9);
    unint64_t v5 = (v9[1] + (v9[0] << 6) + ((unint64_t)v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0];
  }
  else
  {
    unint64_t v5 = 0;
  }
  v9[0] = v5;
  uint64_t result = re::HashTable<unsigned long,re::IntrospectionStructure const*,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 16, v9);
  if (result)
  {
    uint64_t result = re::HashTable<unsigned long,re::Pair<re::FixedArray<unsigned int>,signed char,true>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a1 + 136, (uint64_t *)result);
    if (result)
    {
      if (!*(void *)(result + 8)) {
        return 0;
      }
      int v7 = *(unsigned __int8 *)(result + 24);
      if (v7 == 255) {
        LOBYTE(vre::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
      }
      unint64_t v8 = (**(_DWORD **)(result + 16) + (char)v7);
      if (*(void *)(a1 + 120) > v8) {
        return *(void *)(*(void *)(a1 + 128) + 8 * v8);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

re::TechniqueFunctionConstant *re::getFunctionConstant(uint64_t a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4)
{
  uint64_t result = (re::TechniqueFunctionConstant *)re::HashTable<re::DynamicString,re::TechniqueFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(a2, (uint64_t)a4);
  if (result)
  {
LABEL_2:
    uint64_t result = (re::TechniqueFunctionConstant *)re::TechniqueFunctionConstant::getAs64Bits(result);
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = result;
    return result;
  }
  uint64_t v8 = *(void *)(a3 + 56);
  if (v8)
  {
    id v9 = *(re::DynamicString **)(a3 + 64);
    uint64_t v10 = v8 << 6;
    while (1)
    {
      uint64_t result = (re::TechniqueFunctionConstant *)re::DynamicString::compare(v9, a4);
      if (!result) {
        break;
      }
      id v9 = (re::DynamicString *)((char *)v9 + 64);
      v10 -= 64;
      if (!v10) {
        goto LABEL_7;
      }
    }
    uint64_t result = v9;
    goto LABEL_2;
  }
LABEL_7:
  *(unsigned char *)a1 = 0;
  return result;
}

id re::DynamicArray<NS::SharedPtr<NS::String>>::add(_anonymous_namespace_ *this, id *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4);
  id result = *a2;
  *(void *)(v5 + 8 * vre::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::FixedArray<NS::SharedPtr<NS::String>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    int v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      unint64_t v4 = (id *)result[2];
      uint64_t v5 = 8 * v2;
      do
      {
        if (*v4)
        {

          *unint64_t v4 = 0;
        }
        ++v4;
        v5 -= 8;
      }
      while (v5);
      id result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *int v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long,re::Pair<re::FixedArray<unsigned int>,signed char,true>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (*a2 % (unint64_t)*(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 48 * v3 + 8) != v2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 48 * v3) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 48 * v3 + 8) == v2) {
        return v5 + 48 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 48 * v3 + 16;
}

uint64_t re::HashTable<re::DynamicString,re::TechniqueFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v8, a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v6 + 112 * v5 + 16, a2))
  {
    uint64_t v5 = *(_DWORD *)(v6 + 112 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v6 + 112 * v5 + 48;
}

uint64_t re::TechniqueFunctionConstant::getAs64Bits(re::TechniqueFunctionConstant *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  __dst[0] = 0;
  unint64_t v1 = *((void *)this + 6);
  if (!v1)
  {
    __dst[1] = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v5 = 136315906;
    uint64_t v6 = "operator[]";
    __int16 v7 = 1024;
    int v8 = 476;
    __int16 v9 = 2048;
    uint64_t v10 = 0;
    __int16 v11 = 2048;
    uint64_t v12 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v1 >= 8) {
    size_t v2 = 8;
  }
  else {
    size_t v2 = *((void *)this + 6);
  }
  memcpy(__dst, *((const void **)this + 7), v2);
  return __dst[0];
}

void std::vector<NS::SharedPtr<NS::String>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  size_t v2 = *a1;
  if (*v2)
  {
    std::vector<NS::SharedPtr<NS::String>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<NS::SharedPtr<NS::String>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 8);
      v4 -= 8;
      int v5 = v6;
      if (v6)
      {

        *(void *)(v3 - 8) = 0;
      }
      uint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  a1[1] = v2;
}

void re::usdimport::createAudioFileAssetForResourcePath(_anonymous_namespace_ *a1@<X0>, void *a2@<X1>, char a3@<W2>, int a4@<W3>, double *a5@<X4>, re::DynamicString *a6@<X8>)
{
  v43[7] = *(id *)MEMORY[0x263EF8340];
  id v11 = a2;
  uint64_t v12 = [MEMORY[0x263F83EF8] resourceWithResourcePath:v11];
  id v13 = [v11 path];
  long long v14 = (const char *)[v13 UTF8String];

  if (v12) {
    goto LABEL_3;
  }
  long long v15 = [v11 path];
  long long v16 = [v15 stringByRemovingPercentEncoding];

  uint64_t v12 = [MEMORY[0x263F83EF8] resourceWithPath:v16];

  if (v12)
  {
LABEL_3:
    uint64_t v18 = [v12 dataNoCopy];
    id v19 = (id)[v18 copy];

    if (v19)
    {
      unint64_t v21 = (re::AudioFileAsset *)strlen(v14);
      int v22 = re::AudioFileAsset::assetType(v21);
      uint64_t v23 = (_anonymous_namespace_ *)re::ImportAssetTable::importedAsset((uint64_t)a1, (uint64_t)v14, (uint64_t)v21, (re **)v22);
      uint64_t v24 = (uint64_t)v23;
      if (!v23)
      {
        uint64_t v25 = re::globalAllocators(0);
        int v26 = (re::AudioFileAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25[2] + 32))(v25[2], 168, 8);
        unsigned __int16 v27 = re::AudioFileAsset::AudioFileAsset(v26);
        *((unsigned char *)v27 + 52) = a3;
        *((unsigned char *)v27 + 100) = 1;
        *((_DWORD *)v27 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = a4 << 31 >> 31;
        id v40 = v19;
        re::DataSeekableInputStream::DataSeekableInputStream((uint64_t)buf, &v40, 1, 0);

        if (a5)
        {
          unsigned __int16 v28 = +[_REAudioFile audioFileWithStream:buf ownsStream:0];
          uint64_t v29 = v28;
          if (v28)
          {
            BOOL v30 = [v28 fileFormat];
            [v30 sampleRate];
            double v32 = 0.0;
            if (v31 > 0.0) {
              double v32 = (double)[v29 length] / v31;
            }
          }
          else
          {
            BOOL v35 = *re::pipelineLogObjects(0);
            double v32 = 0.0;
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v39 = 0;
              _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_DEFAULT, "Failed to retrieve audio file duration.", v39, 2u);
            }
          }
          *a5 = v32;
          google::protobuf::io::ArrayInputStream::Seek((google::protobuf::io::ArrayInputStream *)v43, 0);
        }
        re::AudioFileAsset::setMappedData((uint64_t)v26, (uint64_t)buf);
        unsigned __int16 v36 = (re::AudioFileAsset *)strlen(v14);
        BOOL v37 = re::AudioFileAsset::assetType(v36);
        uint64_t v24 = re::ImportAssetTable::addAsset(a1, (uint64_t)v14, (uint64_t)v36, v26, (re **)v37);
        *(void *)long long buf = &unk_26E714530;

        *(void *)long long buf = &unk_26E7144B8;
        uint64_t v23 = (_anonymous_namespace_ *)re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)&v42);
      }
      *(void *)a6 = 0;
      *((void *)a6 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      *((void *)a6 + 2) = 0;
      if (*(unsigned char *)(v24 + 8)) {
        int v38 = *(re::AssetPath **)(v24 + 16);
      }
      else {
        int v38 = (re::AssetPath *)(v24 + 9);
      }
    }
    else
    {
      char v33 = *re::pipelineLogObjects(v20);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_error_impl(&dword_233120000, v33, OS_LOG_TYPE_ERROR, "Failed to load data for USD resource: %s", buf, 0xCu);
      }
      *(void *)a6 = 0;
      *((void *)a6 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      *((void *)a6 + 2) = 0;
    }
  }
  else
  {
    BOOL v34 = *re::pipelineLogObjects(v17);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_error_impl(&dword_233120000, v34, OS_LOG_TYPE_ERROR, "Failed to load USD resource: %s", buf, 0xCu);
    }
    *(void *)a6 = 0;
    *((void *)a6 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    *((void *)a6 + 2) = 0;
  }
}

void re::usdimport::SpatialAudioNodeData::configureFromUSDNode(unsigned __int8 *a1, void *a2, _anonymous_namespace_ *a3, double *a4, int a5)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  id v10 = a2;
  int v87 = a4;
  double v11 = *a4;
  uint64_t v12 = [v10 property:@"playbackMode"];
  id v13 = [v12 stringValue];
  if ([v13 isEqualToString:@"onceFromStart"])
  {
    int v14 = 1;
LABEL_11:

    goto LABEL_12;
  }
  if ([v13 isEqualToString:@"onceFromStartToEnd"])
  {
    int v14 = 2;
    goto LABEL_11;
  }
  if ([v13 isEqualToString:@"loopFromStart"])
  {
    int v14 = 3;
    goto LABEL_11;
  }
  if ([v13 isEqualToString:@"loopFromStartToEnd"])
  {
    int v14 = 4;
    goto LABEL_11;
  }
  if ([v13 isEqualToString:@"loopFromStage"])
  {
    int v14 = 5;
    goto LABEL_11;
  }

  uint64_t v75 = *re::pipelineLogObjects(v74);
  BOOL v76 = os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v76)
    {
      int v77 = v75;
      unint64_t v78 = [v10 name];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v78;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v13;
      uint64_t v79 = "USDz SpatialAudio node '%@' unrecognized playbackMode '%@'. Defaulting to 'onceFromStart'.";
      uint64_t v80 = v77;
      uint32_t v81 = 22;
LABEL_117:
      _os_log_impl(&dword_233120000, v80, OS_LOG_TYPE_DEFAULT, v79, buf, v81);
    }
  }
  else if (v76)
  {
    int v77 = v75;
    unint64_t v78 = [v10 name];
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v78;
    uint64_t v79 = "USDz SpatialAudio node '%@' missing playbackMode. Defaulting to 'onceFromStart'.";
    uint64_t v80 = v77;
    uint32_t v81 = 12;
    goto LABEL_117;
  }
  int v14 = 1;
LABEL_12:
  *((_DWORD *)a1 + 6) = v14;
  double v89 = 0.0;
  if (a5)
  {
    long long v15 = [v10 property:@"filePath"];

    long long v16 = [v15 resourcePath];
    uint64_t v12 = [v10 property:@"auralMode"];

    long long v17 = [v12 stringValue];
    uint64_t v18 = [v17 lowercaseString];
    char v19 = [v18 isEqualToString:@"nonspatial"];

    re::usdimport::createAudioFileAssetForResourcePath(a3, v16, v19, (*((_DWORD *)a1 + 6) - 3) < 3, &v89, (re::DynamicString *)buf);
    long long v20 = *((_OWORD *)a1 + 3);
    *((_OWORD *)a1 + 3) = *(_OWORD *)buf;
    *(_OWORD *)long long buf = v20;
    uint64_t v21 = *((void *)a1 + 8);
    *((void *)a1 + 8) = *(void *)&buf[16];
    *(void *)&uint8_t buf[16] = v21;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  }
  float v22 = v11;
  uint64_t v23 = [v10 property:@"gain"];

  if (v23)
  {
    [v23 floatValue];
    *((_DWORD *)a1 + 5) = v24;
    id v88 = v23;
    *((void *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = re::usdimport::createFloatKeyframeAnimationFromProperty(&v88, v22);
  }
  uint64_t v25 = [v10 property:@"mediaOffset"];

  if (v25)
  {
    [v25 floatValue];
    *((_DWORD *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v26;
  }
  unsigned __int16 v27 = [v10 property:@"startTime"];

  id v28 = v13;
  if (v27)
  {
    uint64_t v29 = [v27 timeCodeValue];
    BOOL v30 = v29;
    if (v29)
    {
      [v29 doubleValue];
      int v31 = 0;
      float v5 = v32 * v22;
      int v33 = 1;
      goto LABEL_24;
    }
    int v33 = 0;
  }
  else
  {
    int v33 = 0;
    BOOL v30 = 0;
  }
  int v31 = 1;
LABEL_24:
  BOOL v34 = [v10 property:@"endTime"];

  if (!v34)
  {
    int v38 = 0;
LABEL_29:
    int v86 = 1;
    goto LABEL_30;
  }
  unsigned __int16 v36 = [v34 timeCodeValue];

  if (!v36)
  {
    int v38 = 0;
    BOOL v30 = 0;
    goto LABEL_29;
  }
  BOOL v35 = (re *)[v36 doubleValue];
  int v86 = 0;
  float v22 = v37 * v22;
  int v38 = 1;
  BOOL v30 = v36;
LABEL_30:
  uint64_t v39 = re::globalAllocators(v35);
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39[2] + 32))(v39[2], 96, 8);
  uint64_t v41 = re::Timeline::Timeline(v40, 38);
  *(unsigned char *)(v41 + 72) = 0;
  *(void *)uint64_t v41 = &unk_26E6C3EC0;
  *(void *)(v41 + 80) = 0;
  uint64_t v42 = (double *)(v41 + 80);
  *(void *)(v41 + 88) = 0;
  switch(*((_DWORD *)a1 + 6))
  {
    case 1:
      if (v31)
      {
        BOOL v43 = *re::pipelineLogObjects((re *)v41);
        uint64_t v41 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
        float v5 = 0.0;
        if (v41)
        {
          int v44 = v43;
          __int16 v45 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v45;
          _os_log_impl(&dword_233120000, v44, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing startTime.", buf, 0xCu);
        }
      }
      if ((v86 & 1) == 0)
      {
        BOOL v46 = *re::pipelineLogObjects((re *)v41);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          int v47 = v46;
          uint64_t v48 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v48;
          _os_log_impl(&dword_233120000, v47, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' ignoring endTime for playbackMode = onceFromStart.", buf, 0xCu);
        }
      }
      float v22 = v89 + v5;
      int v38 = 1;
      BOOL v49 = v28;
      goto LABEL_97;
    case 2:
      BOOL v49 = v28;
      if (v31)
      {
        BOOL v52 = *re::pipelineLogObjects((re *)v41);
        uint64_t v41 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
        float v5 = 0.0;
        if (v41)
        {
          int v53 = v52;
          uint64_t v54 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v54;
          _os_log_impl(&dword_233120000, v53, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing startTime.", buf, 0xCu);
        }
      }
      if (v86)
      {
        BOOL v55 = *re::pipelineLogObjects((re *)v41);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          int v56 = v55;
          int v57 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v57;
          _os_log_impl(&dword_233120000, v56, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing endTime.", buf, 0xCu);
        }
        BOOL v58 = v87;
        if (*((unsigned char *)v87 + 24))
        {
          float v22 = *((float *)v87 + 7);
          int v38 = 1;
        }
        else
        {
          int v38 = 0;
        }
      }
      else
      {
        int v38 = 1;
        BOOL v58 = v87;
      }
      if (v22 > v5) {
        goto LABEL_97;
      }
      if (*((unsigned char *)v58 + 24))
      {
        float v82 = v89;
        if (*((float *)v58 + 7) >= v82) {
          float v22 = v89;
        }
        else {
          float v22 = *((float *)v58 + 7);
        }
      }
      else
      {
        float v22 = v89;
      }
      goto LABEL_96;
    case 3:
      BOOL v49 = v28;
      if (v31)
      {
        int v59 = *re::pipelineLogObjects((re *)v41);
        float v5 = 0.0;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          int v60 = v59;
          BOOL v61 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v61;
          _os_log_impl(&dword_233120000, v60, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing startTime.", buf, 0xCu);
        }
      }
      if (*((unsigned char *)v87 + 24))
      {
        float v22 = *((float *)v87 + 7);
        if (!v38) {
          goto LABEL_96;
        }
      }
      else if ((v38 | v86))
      {
        goto LABEL_85;
      }
      goto LABEL_97;
    case 4:
      BOOL v49 = v28;
      if (v31)
      {
        int v62 = *re::pipelineLogObjects((re *)v41);
        uint64_t v41 = os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT);
        float v5 = 0.0;
        if (v41)
        {
          __int16 v63 = v62;
          BOOL v64 = [v10 name];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v64;
          _os_log_impl(&dword_233120000, v63, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing startTime.", buf, 0xCu);
        }
      }
      if (!v86) {
        goto LABEL_96;
      }
      int v65 = *re::pipelineLogObjects((re *)v41);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        long long v66 = v65;
        BOOL v67 = [v10 name];
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v67;
        _os_log_impl(&dword_233120000, v66, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing endTime.", buf, 0xCu);
      }
      if (!*((unsigned char *)v87 + 24)) {
        goto LABEL_85;
      }
      float v22 = *((float *)v87 + 7);
      goto LABEL_96;
    case 5:
      int v68 = v87;
      if (*((unsigned char *)v87 + 16))
      {
        float v5 = *((float *)v87 + 5);
        if (!v33) {
          goto LABEL_81;
        }
      }
      else if ((v33 | v31))
      {
        goto LABEL_78;
      }
      if (!v31) {
        goto LABEL_81;
      }
LABEL_78:
      int v71 = *re::pipelineLogObjects((re *)v41);
      float v5 = 0.0;
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        char v72 = v71;
        BOOL v73 = [v10 name];
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v73;
        _os_log_impl(&dword_233120000, v72, OS_LOG_TYPE_DEFAULT, "USDz SpatialAudio node '%@' missing stage startTime.", buf, 0xCu);
      }
      int v68 = v87;
LABEL_81:
      if (*((unsigned char *)v68 + 24))
      {
        float v22 = *((float *)v68 + 7);
        BOOL v49 = v28;
        if (!v38) {
LABEL_96:
        }
          int v38 = 1;
      }
      else
      {
        BOOL v49 = v28;
        if ((v38 | v86)) {
LABEL_85:
        }
          int v38 = 0;
      }
LABEL_97:
      LOBYTE(v3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      int v50 = *a1;
      BOOL v69 = *a1 != 0;
      goto LABEL_98;
    default:
      int v50 = *a1;
      if (*a1) {
        char v51 = 0;
      }
      else {
        char v51 = v31;
      }
      if (v51)
      {
        int v50 = 0;
        BOOL v49 = v28;
      }
      else
      {
        BOOL v69 = v50 != 0;
        if (*a1) {
          int v70 = v31;
        }
        else {
          int v70 = 0;
        }
        BOOL v49 = v28;
        if (v70 == 1)
        {
          int v50 = 0;
          *a1 = 0;
        }
        else
        {
LABEL_98:
          if (!v69 && (v31 & 1) == 0)
          {
            int v50 = 1;
            *a1 = 1;
          }
          *((float *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v5;
        }
      }
      int v83 = a1[8];
      if (v83 | v38)
      {
        if (v38 || !a1[8])
        {
          if (v38 && !a1[8])
          {
            int v83 = 1;
            a1[8] = 1;
          }
          *((float *)a1 + 3) = v22;
        }
        else
        {
          int v83 = 0;
          a1[8] = 0;
        }
      }
      double v84 = 0.0;
      double v85 = 0.0;
      if (v50) {
        double v85 = *((float *)a1 + 1);
      }
      *uint64_t v42 = v85;
      if (v83) {
        double v84 = *((float *)a1 + 3);
      }
      *(double *)(v40 + 88) = v84;
      *(unsigned char *)(v40 + 16) = 3;
      *((void *)a1 + 5) = v40;

      return;
  }
}

re::DynamicString *re::VFXAssetCompiler::getCurrentCompiledAssetInfo@<X0>(re::VFXAssetCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v3 = (re::VFXAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::VFXAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::VFXAssetCompiler::assetIntrospectionType(re::VFXAssetCompiler *this)
{
  unint64_t v1 = &off_268773000;
  {
    unint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::VFXAsset>(void)::info = re::introspect_VFXAsset(0);
      unint64_t v1 = &off_268773000;
    }
  }
  return v1[149];
}

void *re::VFXAssetCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::VFXAssetCompiler::getSupportedExtensions(void)const::supportedExtensions);
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, off_268774240);
}

re::DynamicString *re::VFXAssetCompiler::compile@<X0>(re::VFXAssetCompiler *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v7 = re::globalAllocators(this);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 80, 8);
  *(_OWORD *)uint64_t v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v8 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  __int16 v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)v8, 0);
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  re::DynamicString::setCapacity((void *)(v8 + 32), 0);
  *(void *)(v8 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
  *(void *)(v8 + 72) = -1;
  v11[0] = a2;
  v11[1] = strlen(a2);
  id result = re::DynamicString::operator=((re::DynamicString *)v8, (uint64_t)v11);
  *(unsigned char *)a3 = 1;
  *(void *)(a3 + 8) = v8;
  return result;
}

re *re::VFXAssetCompiler::deleteAsset(re::VFXAssetCompiler *this, re::VFXAsset *a2)
{
  return re::internal::destroyPersistent<re::VFXAsset>((re *)"deleteAsset", 106, a2);
}

void re::VFXAssetCompiler::~VFXAssetCompiler(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x237DBCBD0);
}

uint64_t re::HMMaterialCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::HMMaterialCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::HMMaterialDefinitionCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::HMMaterialDefinitionCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::HMSceneCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::HMSceneCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::HMRenderGraphCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::HMRenderGraphCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::HMRenderGraphEmitterCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  v3[0] = re::HMRenderGraphEmitterCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

void re::HMMaterialCompiler::~HMMaterialCompiler(re::HMMaterialCompiler *this)
{
}

re::DynamicString *re::HMAssetCompiler<re::MaterialCompiler>::getCurrentCompiledAssetInfo@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return re::MaterialCompiler::getCurrentCompiledAssetInfo((re::MaterialCompiler *)(a1 + 8), a2);
}

char **re::HMAssetCompiler<re::MaterialCompiler>::assetIntrospectionType(uint64_t a1)
{
  return re::MaterialCompiler::assetIntrospectionType((re::MaterialCompiler *)(a1 + 8));
}

uint64_t re::HMAssetCompiler<re::MaterialCompiler>::compile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v31 = 0;
  double v32 = 0;
  uint64_t v33 = 0;
  re::DynamicString::setCapacity(&v30, 0);
  uint64_t v29 = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  v26[0] = 0;
  int v28 = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v26, re::MaterialCompiler::getSupportedExtensions(void)const::supportedExtensions);
  if (v27)
  {
    uint64_t v8 = v29;
    uint64_t v9 = 8 * v27;
    while (1)
    {
      uint64_t v10 = *v8;
      *(void *)&long long v34 = &unk_26E714FB0;
      *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v34;
      re::pathsToFilesInDirectory(a2, (uint64_t)&v34, (uint64_t)&v22);
      std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](&v34);
      if (!(_BYTE)v22)
      {
        *(void *)&long long v34 = 100;
        *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v22 + 8));
        long long v12 = v35;
        *(_OWORD *)(a4 + 8) = v34;
        uint64_t v13 = v36;
        uint64_t v14 = v37;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a4 + 40) = v13;
        *(void *)(a4 + 48) = v14;
        int v11 = 1;
        goto LABEL_9;
      }
      if (v24) {
        break;
      }
      re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_6;
      }
    }
    re::DynamicString::operator=((re::DynamicString *)&v30, v25);
    int v11 = 2;
LABEL_9:
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
  }
  else
  {
LABEL_6:
    int v11 = 2;
  }
  long long v15 = (_anonymous_namespace_ *)v26[0];
  if (v26[0] && v29) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v26[0] + 40))();
  }
  if (v11 == 2)
  {
    unint64_t v16 = v31 >> 1;
    if ((v31 & 1) == 0) {
      unint64_t v16 = v31 >> 1;
    }
    if (v16)
    {
      if (v31) {
        long long v17 = v32;
      }
      else {
        long long v17 = (re *)((char *)&v31 + 1);
      }
      re::MaterialCompiler::compile((re::MaterialCompiler *)(a1 + 8), v17, a3, a4);
    }
    else
    {
      long long v18 = v22;
      uint64_t v19 = v23;
      uint64_t v20 = v24;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 100;
      *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
      *(void *)(a4 + 40) = v19;
      *(void *)(a4 + 48) = v20;
    }
  }
  uint64_t result = (uint64_t)v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  return result;
}

re *re::HMAssetCompiler<re::MaterialCompiler>::deleteAsset(uint64_t a1, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::MaterialAsset>((re *)"deleteAsset", 2331, a2);
}

void re::HMMaterialDefinitionCompiler::~HMMaterialDefinitionCompiler(re::HMMaterialDefinitionCompiler *this)
{
}

re::DynamicString *re::HMAssetCompiler<re::MaterialDefinitionCompiler>::getCurrentCompiledAssetInfo@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return re::MaterialDefinitionCompiler::getCurrentCompiledAssetInfo((re::MaterialDefinitionCompiler *)(a1 + 8), a2);
}

char **re::HMAssetCompiler<re::MaterialDefinitionCompiler>::assetIntrospectionType(uint64_t a1)
{
  return re::MaterialDefinitionCompiler::assetIntrospectionType((re::MaterialDefinitionCompiler *)(a1 + 8));
}

uint64_t re::HMAssetCompiler<re::MaterialDefinitionCompiler>::compile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v31 = 0;
  double v32 = 0;
  uint64_t v33 = 0;
  re::DynamicString::setCapacity(&v30, 0);
  uint64_t v29 = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  v26[0] = 0;
  int v28 = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v26, &re::MaterialDefinitionCompiler::getSupportedExtensions(void)const::supportedExtensions);
  if (v27)
  {
    uint64_t v8 = v29;
    uint64_t v9 = 8 * v27;
    while (1)
    {
      uint64_t v10 = *v8;
      *(void *)&long long v34 = &unk_26E714FB0;
      *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v34;
      re::pathsToFilesInDirectory(a2, (uint64_t)&v34, (uint64_t)&v22);
      std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](&v34);
      if (!(_BYTE)v22)
      {
        *(void *)&long long v34 = 100;
        *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v22 + 8));
        long long v12 = v35;
        *(_OWORD *)(a4 + 8) = v34;
        uint64_t v13 = v36;
        uint64_t v14 = v37;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a4 + 40) = v13;
        *(void *)(a4 + 48) = v14;
        int v11 = 1;
        goto LABEL_9;
      }
      if (v24) {
        break;
      }
      re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_6;
      }
    }
    re::DynamicString::operator=((re::DynamicString *)&v30, v25);
    int v11 = 2;
LABEL_9:
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
  }
  else
  {
LABEL_6:
    int v11 = 2;
  }
  long long v15 = (_anonymous_namespace_ *)v26[0];
  if (v26[0] && v29) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v26[0] + 40))();
  }
  if (v11 == 2)
  {
    unint64_t v16 = v31 >> 1;
    if ((v31 & 1) == 0) {
      unint64_t v16 = v31 >> 1;
    }
    if (v16)
    {
      if (v31) {
        long long v17 = v32;
      }
      else {
        long long v17 = (re::MaterialDefinitionFile *)((char *)&v31 + 1);
      }
      re::MaterialDefinitionCompiler::compile((re::MaterialDefinitionCompiler *)(a1 + 8), v17, a3, a4);
    }
    else
    {
      long long v18 = v22;
      uint64_t v19 = v23;
      uint64_t v20 = v24;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 100;
      *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
      *(void *)(a4 + 40) = v19;
      *(void *)(a4 + 48) = v20;
    }
  }
  uint64_t result = (uint64_t)v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  return result;
}

re *re::HMAssetCompiler<re::MaterialDefinitionCompiler>::deleteAsset(uint64_t a1, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::MaterialDefinitionAsset>((re *)"deleteAsset", 2382, a2);
}

void re::HMSceneCompiler::~HMSceneCompiler(re::HMSceneCompiler *this)
{
}

re::DynamicString *re::HMAssetCompiler<re::SceneCompiler>::getCurrentCompiledAssetInfo@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return re::SceneCompiler::getCurrentCompiledAssetInfo((re::SceneCompiler *)(a1 + 8), a2);
}

char **re::HMAssetCompiler<re::SceneCompiler>::assetIntrospectionType(uint64_t a1)
{
  return re::SceneCompiler::assetIntrospectionType((re::SceneCompiler *)(a1 + 8));
}

uint64_t re::HMAssetCompiler<re::SceneCompiler>::compile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v31 = 0;
  double v32 = 0;
  uint64_t v33 = 0;
  re::DynamicString::setCapacity(&v30, 0);
  uint64_t v29 = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  v26[0] = 0;
  int v28 = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v26, re::SceneCompiler::getSupportedExtensions(void)const::supportedExtensions);
  if (v27)
  {
    uint64_t v8 = v29;
    uint64_t v9 = 8 * v27;
    while (1)
    {
      uint64_t v10 = *v8;
      *(void *)&long long v34 = &unk_26E714FB0;
      *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v34;
      re::pathsToFilesInDirectory(a2, (uint64_t)&v34, (uint64_t)&v22);
      std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](&v34);
      if (!(_BYTE)v22)
      {
        *(void *)&long long v34 = 100;
        *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v22 + 8));
        long long v12 = v35;
        *(_OWORD *)(a4 + 8) = v34;
        uint64_t v13 = v36;
        uint64_t v14 = v37;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a4 + 40) = v13;
        *(void *)(a4 + 48) = v14;
        int v11 = 1;
        goto LABEL_9;
      }
      if (v24) {
        break;
      }
      re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_6;
      }
    }
    re::DynamicString::operator=((re::DynamicString *)&v30, v25);
    int v11 = 2;
LABEL_9:
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
  }
  else
  {
LABEL_6:
    int v11 = 2;
  }
  long long v15 = (_anonymous_namespace_ *)v26[0];
  if (v26[0] && v29) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v26[0] + 40))();
  }
  if (v11 == 2)
  {
    unint64_t v16 = v31 >> 1;
    if ((v31 & 1) == 0) {
      unint64_t v16 = v31 >> 1;
    }
    if (v16)
    {
      if (v31) {
        long long v17 = v32;
      }
      else {
        long long v17 = (re::AssetUtilities *)((char *)&v31 + 1);
      }
      re::SceneCompiler::compile((re::SceneCompiler *)(a1 + 8), v17, a3, a4);
    }
    else
    {
      long long v18 = v22;
      uint64_t v19 = v23;
      uint64_t v20 = v24;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 100;
      *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
      *(void *)(a4 + 40) = v19;
      *(void *)(a4 + 48) = v20;
    }
  }
  uint64_t result = (uint64_t)v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  return result;
}

re *re::HMAssetCompiler<re::SceneCompiler>::deleteAsset(uint64_t a1, uint64_t a2)
{
  return re::internal::destroyPersistent<re::SceneAsset>((re *)"deleteAsset", 65, a2);
}

void re::HMRenderGraphCompiler::~HMRenderGraphCompiler(re::HMRenderGraphCompiler *this)
{
}

re::DynamicString *re::HMAssetCompiler<re::RenderGraphCompiler>::getCurrentCompiledAssetInfo@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return re::RenderGraphCompiler::getCurrentCompiledAssetInfo((re::RenderGraphCompiler *)(a1 + 8), a2);
}

char **re::HMAssetCompiler<re::RenderGraphCompiler>::assetIntrospectionType(uint64_t a1)
{
  return re::RenderGraphCompiler::assetIntrospectionType((re::RenderGraphCompiler *)(a1 + 8));
}

uint64_t re::HMAssetCompiler<re::RenderGraphCompiler>::compile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v31 = 0;
  double v32 = 0;
  uint64_t v33 = 0;
  re::DynamicString::setCapacity(&v30, 0);
  uint64_t v29 = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  v26[0] = 0;
  int v28 = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v26, re::RenderGraphCompiler::getSupportedExtensions(void)const::supportedExtensions);
  re::DynamicArray<re::TransitionCondition *>::add(v26, off_268774010);
  if (v27)
  {
    uint64_t v8 = v29;
    uint64_t v9 = 8 * v27;
    while (1)
    {
      uint64_t v10 = *v8;
      *(void *)&long long v34 = &unk_26E714FB0;
      *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v34;
      re::pathsToFilesInDirectory(a2, (uint64_t)&v34, (uint64_t)&v22);
      std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](&v34);
      if (!(_BYTE)v22)
      {
        *(void *)&long long v34 = 100;
        *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v22 + 8));
        long long v12 = v35;
        *(_OWORD *)(a4 + 8) = v34;
        uint64_t v13 = v36;
        uint64_t v14 = v37;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a4 + 40) = v13;
        *(void *)(a4 + 48) = v14;
        int v11 = 1;
        goto LABEL_9;
      }
      if (v24) {
        break;
      }
      re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_6;
      }
    }
    re::DynamicString::operator=((re::DynamicString *)&v30, v25);
    int v11 = 2;
LABEL_9:
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
  }
  else
  {
LABEL_6:
    int v11 = 2;
  }
  long long v15 = (_anonymous_namespace_ *)v26[0];
  if (v26[0] && v29) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v26[0] + 40))();
  }
  if (v11 == 2)
  {
    unint64_t v16 = v31 >> 1;
    if ((v31 & 1) == 0) {
      unint64_t v16 = v31 >> 1;
    }
    if (v16)
    {
      if (v31) {
        long long v17 = v32;
      }
      else {
        long long v17 = (re::FileStreamReader *)((char *)&v31 + 1);
      }
      re::RenderGraphCompiler::compile((re::RenderGraphCompiler *)(a1 + 8), v17, a3, a4);
    }
    else
    {
      long long v18 = v22;
      uint64_t v19 = v23;
      uint64_t v20 = v24;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 100;
      *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
      *(void *)(a4 + 40) = v19;
      *(void *)(a4 + 48) = v20;
    }
  }
  uint64_t result = (uint64_t)v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  return result;
}

re *re::HMAssetCompiler<re::RenderGraphCompiler>::deleteAsset(uint64_t a1, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::RenderGraphAsset>((re *)"deleteAsset", 97, a2);
}

void re::HMRenderGraphEmitterCompiler::~HMRenderGraphEmitterCompiler(re::HMRenderGraphEmitterCompiler *this)
{
}

re::DynamicString *re::HMAssetCompiler<re::RenderGraphEmitterCompiler>::getCurrentCompiledAssetInfo@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return re::RenderGraphEmitterCompiler::getCurrentCompiledAssetInfo((re::RenderGraphEmitterCompiler *)(a1 + 8), a2);
}

char **re::HMAssetCompiler<re::RenderGraphEmitterCompiler>::assetIntrospectionType(uint64_t a1)
{
  return re::RenderGraphEmitterCompiler::assetIntrospectionType((re::RenderGraphEmitterCompiler *)(a1 + 8));
}

uint64_t re::HMAssetCompiler<re::RenderGraphEmitterCompiler>::compile@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v31 = 0;
  double v32 = 0;
  uint64_t v33 = 0;
  re::DynamicString::setCapacity(&v30, 0);
  uint64_t v29 = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  v26[0] = 0;
  int v28 = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v26, &re::RenderGraphEmitterCompiler::getSupportedExtensions(void)const::supportedExtensions);
  if (v27)
  {
    uint64_t v8 = v29;
    uint64_t v9 = 8 * v27;
    while (1)
    {
      uint64_t v10 = *v8;
      *(void *)&long long v34 = &unk_26E714FB0;
      *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v10;
      *((void *)&v35 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v34;
      re::pathsToFilesInDirectory(a2, (uint64_t)&v34, (uint64_t)&v22);
      std::__function::__value_func<BOOL ()(char const*)>::~__value_func[abi:nn180100](&v34);
      if (!(_BYTE)v22)
      {
        *(void *)&long long v34 = 100;
        *((void *)&v34 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v22 + 8));
        long long v12 = v35;
        *(_OWORD *)(a4 + 8) = v34;
        uint64_t v13 = v36;
        uint64_t v14 = v37;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
        *(void *)(a4 + 40) = v13;
        *(void *)(a4 + 48) = v14;
        int v11 = 1;
        goto LABEL_9;
      }
      if (v24) {
        break;
      }
      re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_6;
      }
    }
    re::DynamicString::operator=((re::DynamicString *)&v30, v25);
    int v11 = 2;
LABEL_9:
    re::Result<re::DynamicArray<re::DynamicString>,re::DynamicString>::~Result((unsigned __int8 *)&v22);
  }
  else
  {
LABEL_6:
    int v11 = 2;
  }
  long long v15 = (_anonymous_namespace_ *)v26[0];
  if (v26[0] && v29) {
    long long v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v26[0] + 40))();
  }
  if (v11 == 2)
  {
    unint64_t v16 = v31 >> 1;
    if ((v31 & 1) == 0) {
      unint64_t v16 = v31 >> 1;
    }
    if (v16)
    {
      if (v31) {
        long long v17 = v32;
      }
      else {
        long long v17 = (re::AssetUtilities *)((char *)&v31 + 1);
      }
      re::RenderGraphEmitterCompiler::compile((re::RenderGraphEmitterCompiler *)(a1 + 8), v17, a3, a4);
    }
    else
    {
      long long v18 = v22;
      uint64_t v19 = v23;
      uint64_t v20 = v24;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = 100;
      *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v18;
      *(void *)(a4 + 40) = v19;
      *(void *)(a4 + 48) = v20;
    }
  }
  uint64_t result = (uint64_t)v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  return result;
}

re *re::HMAssetCompiler<re::RenderGraphEmitterCompiler>::deleteAsset(uint64_t a1, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::RenderGraphEmitterAsset>((re *)"deleteAsset", 154, a2);
}

re::DynamicString *re::SceneCompiler::getCurrentCompiledAssetInfo@<X0>(re::SceneCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::SceneAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::SceneAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::SceneCompiler::assetIntrospectionType(re::SceneCompiler *this)
{
  unint64_t v1 = &off_268773000;
  {
    unint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::SceneAsset>(void)::info = re::introspect_SceneAsset(0);
      unint64_t v1 = &off_268773000;
    }
  }
  return v1[334];
}

void *re::SceneCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::SceneCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re *re::SceneCompiler::compile@<X0>(re::SceneCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = re::globalAllocators(this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 40, 8);
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(void *)(v9 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  {
    re::introspect<re::ecs2::SceneAssetData>(void)::info = re::ecs2::introspect_SceneAssetData(0);
  }
  uint64_t result = (re *)re::AssetUtilities::readSourceJson(a2, (const char *)v9, re::introspect<re::ecs2::SceneAssetData>(void)::info, a3, (uint64_t)v19);
  if (v19[0])
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v9;
  }
  else
  {
    uint64_t v11 = re::globalAllocators(result)[2];
    re::DynamicArray<re::ecs2::EntityAssetData>::deinit(v9);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 40))(v11, v9);
    *(void *)&long long v15 = 100;
    *((void *)&v15 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
    uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)&v16, (const re::DynamicString *)&v20);
    long long v12 = v16;
    *(_OWORD *)(a4 + 8) = v15;
    uint64_t v13 = v17;
    uint64_t v14 = v18;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v12;
    *(void *)(a4 + 40) = v13;
    *(void *)(a4 + 48) = v14;
    if (!v19[0])
    {
      uint64_t result = v20;
      if (v20)
      {
        if (v21) {
          return (re *)(*(uint64_t (**)(void))(*(void *)v20 + 40))();
        }
      }
    }
  }
  return result;
}

re *re::SceneCompiler::deleteAsset(re::SceneCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::SceneAsset>((re *)"deleteAsset", 65, a2);
}

void re::SceneCompiler::~SceneCompiler(re::SceneCompiler *this)
{
}

re::DynamicString *re::RigCompiler::getCurrentCompiledAssetInfo@<X0>(re::RigCompiler *this@<X0>, void *a2@<X8>)
{
  *a2 = 0x100000001;
  uint64_t v2 = (re::DynamicString *)(a2 + 1);
  int v3 = (_anonymous_namespace_ *)re::RigAsset::assetType(this);
  uint64_t v4 = *(const char **)v3;
}

char **re::RigCompiler::assetIntrospectionType(re::RigCompiler *this)
{
  unint64_t v1 = &off_268773000;
  {
    unint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::RigAsset>(void)::info = re::introspect_RigAsset(0);
      unint64_t v1 = &off_268773000;
    }
  }
  return v1[380];
}

uint64_t re::RigCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = "rerig";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

void *re::RigCompiler::compile@<X0>(re::RigCompiler *this@<X0>, char *a2@<X1>, uint64_t *a3@<X2>, re::AssetSerializationScheme *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v10 = re::globalAllocators(this);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 120, 8);
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_OWORD *)(v11 + 6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0u;
  *(_OWORD *)(v11 + 80) = 0u;
  *(_OWORD *)(v11 + 96) = 0u;
  *(void *)(v11 + 112) = 0;
  *(void *)&long long v51 = &unk_26E6E1110;
  *((void *)&v52 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = &v51;
  BOOL v43 = v42;
  uint64_t v41 = (char *)v11;
  v42[0] = &unk_26E6E1110;
  std::__function::__value_func<void ()(re::RigAsset *)>::~__value_func[abi:nn180100](&v51);
  long long v12 = strrchr(a2, 46);
  if (strcasecmp(v12 + 1, "rerig"))
  {
    re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v51, a2);
    long long v13 = v51;
    uint64_t v15 = *((void *)&v52 + 1);
    uint64_t v14 = v52;
    *(unsigned char *)a5 = 0;
    uint64_t v16 = 200;
    goto LABEL_3;
  }
  uint64_t v18 = v41;
  float v5 = (int *)&off_268773000;
  while (1)
  {
    uint64_t v19 = *((void *)v5 + 380);
    float v5 = &v36;
    SourceJson = (_anonymous_namespace_ *)re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, v18, v19, a4, (uint64_t)&v36);
    if (!(_BYTE)v36)
    {
      *(void *)&long long v51 = 100;
      *((void *)&v51 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v52, (const re::DynamicString *)&v37[4]);
      long long v26 = v52;
      *(_OWORD *)(a5 + 8) = v51;
      long long v27 = v53;
      *(unsigned char *)a5 = 0;
      *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v26;
      *(_OWORD *)(a5 + 40) = v27;
      if ((_BYTE)v36) {
        goto LABEL_4;
      }
      uint64_t v28 = *(void *)&v37[4];
      if (!*(void *)&v37[4] || (v37[12] & 1) == 0) {
        goto LABEL_4;
      }
      uint64_t v29 = *(unsigned char **)&v39[4];
      goto LABEL_33;
    }
    if (a3 && !*(unsigned char *)a3)
    {
      char v21 = v41;
LABEL_35:
      *(unsigned char *)a5 = 1;
      *(void *)(a5 + 8) = v21;
      uint64_t v41 = 0;
      return std::__function::__value_func<void ()(re::RigAsset *)>::~__value_func[abi:nn180100](v42);
    }
    char v21 = v41;
    a2 = (char *)*((void *)v41 + 2);
    if (!a2) {
      goto LABEL_17;
    }
    float v5 = 0;
    a4 = 0;
    do
    {
      unint64_t v22 = *((void *)v41 + 2);
      if (v22 <= (unint64_t)a4)
      {
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v51 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int v44 = 136315906;
        *(void *)&v44[4] = "operator[]";
        __int16 v45 = 1024;
        int v46 = 789;
        __int16 v47 = 2048;
        uint64_t v48 = a4;
        __int16 v49 = 2048;
        unint64_t v50 = v22;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_40:
        *(void *)int v44 = 0;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v51 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v36 = 136315906;
        *(void *)uint64_t v37 = "operator[]";
        *(_WORD *)&v37[8] = 1024;
        *(_DWORD *)&void v37[10] = 789;
        __int16 v38 = 2048;
        *(void *)uint64_t v39 = a3;
        *(_WORD *)&uint8_t v39[8] = 2048;
        *(void *)&v39[10] = a4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (!(_BYTE)v36)
      {
        if (v39[12]) {
          BOOL v30 = v40;
        }
        else {
          BOOL v30 = &v39[13];
        }
        re::DynamicString::format((re::DynamicString *)"Rig %zu Validation Failed: %s.", (re::DynamicString *)&v51, a4, v30);
        long long v31 = v51;
        long long v32 = v52;
        *(unsigned char *)a5 = 0;
        *(void *)(a5 + 8) = 100;
        *(void *)(a5 + 16) = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v31;
        *(_OWORD *)(a5 + 40) = v32;
        if ((_BYTE)v36) {
          goto LABEL_4;
        }
        uint64_t v28 = *(void *)&v39[4];
        if (!*(void *)&v39[4] || (v39[12] & 1) == 0) {
          goto LABEL_4;
        }
        uint64_t v29 = v40;
LABEL_33:
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v28 + 40))(v28, v29);
        goto LABEL_4;
      }
      a4 = (re::AssetSerializationScheme *)((char *)a4 + 1);
      v5 += 286;
    }
    while (a2 != (char *)a4);
    char v21 = v41;
LABEL_17:
    a4 = (re::AssetSerializationScheme *)*((void *)v21 + 12);
    if (!a4) {
      goto LABEL_35;
    }
    a3 = 0;
    uint64_t v23 = (unsigned int *)(*((void *)v21 + 14) + 56);
    while (1)
    {
      unsigned int v25 = *v23;
      v23 += 16;
      uint64_t v24 = v25;
      if ((unint64_t)a2 <= v25) {
        break;
      }
      a3 = (uint64_t *)((char *)a3 + 1);
      if (a4 == (re::AssetSerializationScheme *)a3) {
        goto LABEL_35;
      }
    }
    if (a4 <= (re::AssetSerializationScheme *)a3) {
      goto LABEL_40;
    }
    re::DynamicString::format((re::DynamicString *)"Mesh Rig %zu uses an invalid rig: %u.", (re::DynamicString *)&v51, a3, v24);
    long long v13 = v51;
    uint64_t v15 = *((void *)&v52 + 1);
    uint64_t v14 = v52;
    *(unsigned char *)a5 = 0;
    uint64_t v16 = 100;
LABEL_3:
    *(void *)(a5 + 8) = v16;
    *(void *)(a5 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a5 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v13;
    *(void *)(a5 + 40) = v14;
    *(void *)(a5 + 48) = v15;
LABEL_4:
    uint64_t v17 = v41;
    uint64_t v41 = 0;
    if (!v17) {
      return std::__function::__value_func<void ()(re::RigAsset *)>::~__value_func[abi:nn180100](v42);
    }
    *(void *)&long long v51 = v17;
    if (v43)
    {
      (*(void (**)(void *, long long *))(*v43 + 48))(v43, &v51);
      return std::__function::__value_func<void ()(re::RigAsset *)>::~__value_func[abi:nn180100](v42);
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_42:
    long long v34 = v18;
    uint64_t v18 = v34;
    if (v35)
    {
      *((void *)v5 + 380) = re::introspect_RigAsset(0);
      uint64_t v18 = v34;
    }
  }
}

re *re::RigCompiler::deleteAsset(re::RigCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::RigAsset>((re *)"deleteAsset", 79, a2);
}

void re::RigCompiler::~RigCompiler(re::RigCompiler *this)
{
}

void std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::~__func()
{
}

void *std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6E1110;
  return result;
}

void std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6E1110;
}

re *std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::RigAsset>((re *)"operator()", 34, *a2);
}

uint64_t std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigAsset *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::RigAsset *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

re::DynamicString *re::LUTTextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::LUTTextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v3 = (re::TextureAsset *)re::DynamicString::setCapacity((void *)(a2 + 8), 0);
  *(void *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

char **re::LUTTextureCompiler::assetIntrospectionType(re::LUTTextureCompiler *this)
{
  unint64_t v1 = &off_268773000;
  {
    unint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
      unint64_t v1 = &off_268773000;
    }
  }
  return v1[262];
}

void *re::LUTTextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((void *)a1, re::LUTTextureCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

void re::LUTTextureCompiler::compile(id *this@<X0>, re::mtl::Device *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>, int16x8_t a5@<Q0>)
{
  v52[2] = *MEMORY[0x263EF8340];
  if (a2)
  {
    v52[0] = 0;
    *(void *)((char *)v52 + 5) = 0;
    if (a3)
    {
      a5.i32[0] = *(_DWORD *)a3;
      int16x8_t v24 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a5.i8);
      char v8 = a3[4];
      __int16 v27 = *(_WORD *)(a3 + 5);
      char v28 = a3[7];
      int v9 = *((_DWORD *)a3 + 2);
      v52[0] = *(void *)(a3 + 12);
      *(void *)((char *)v52 + 5) = *(void *)(a3 + 17);
      __int16 v25 = *(_WORD *)(a3 + 25);
      char v26 = a3[27];
      int v10 = *((_DWORD *)a3 + 7);
    }
    else
    {
      a5.i64[0] = 0x1000000010001;
      int16x8_t v24 = a5;
      int v10 = 0;
      char v8 = 1;
      int v9 = 1;
    }
    re::load3DTextureFromLutDataFile(this + 1, a2, a3, (uint64_t)buf);
    if (v50)
    {
      unint64_t v22 = (re::LUTTextureCompiler *)std::__throw_bad_variant_access[abi:nn180100]();
      re::LUTTextureCompiler::deleteAsset(v22, v23);
    }
    else
    {
      id v16 = *(id *)&buf[8];

      if (v50 != -1) {
        uint64_t v17 = (_anonymous_namespace_ *)((uint64_t (*)(long long *, unsigned char *))*(&off_26E6E11F8 + v50))(&v38, &buf[8]);
      }
      if (v16)
      {
        buf[0] = 0;
        *(void *)&uint8_t buf[8] = v16;
        unsigned int v50 = 0;
        id v51 = 0;
        unsigned __int32 v29 = vmovn_s16(v24).u32[0];
        char v30 = v8;
        __int16 v31 = v27;
        char v32 = v28;
        int v33 = v9;
        *(void *)long long v34 = v52[0];
        *(void *)&v34[5] = *(void *)((char *)v52 + 5);
        __int16 v35 = v25;
        char v36 = v26;
        int v37 = v10;
        uint64_t TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)buf, 6, (long long *)&v29);

        if (v50 != -1) {
          ((void (*)(long long *, unsigned char *))*(&off_26E6E11F8 + v50))(&v38, &buf[8]);
        }

        *(unsigned char *)a4 = 1;
        *(void *)(a4 + 8) = TextureAsset;
      }
      else
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        re::DynamicString::setCapacity(&v42, 0);
        re::DynamicString::assignf((re::DynamicString *)&v42, "failed to load texture %s", (const char *)a2);
        *(void *)&long long v38 = 100;
        *((void *)&v38 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v39, (const re::DynamicString *)&v42);
        uint64_t v19 = *((void *)&v40 + 1);
        uint64_t v20 = v39;
        char v21 = v40;
        buf[0] = 0;
        *(_OWORD *)&uint8_t buf[8] = v38;
        uint64_t v49 = v41;
        uint64_t v47 = v39;
        long long v48 = v40;
        if (v42 && (v43 & 1) != 0) {
          (*(void (**)(void))(*v42 + 40))();
        }
        long long v38 = *(_OWORD *)&buf[8];
        re::DynamicString::DynamicString((re::DynamicString *)&v39, (const re::DynamicString *)&v47);
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v38;
        *(void *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v39;
        *(void *)(a4 + 48) = v41;
        *(_OWORD *)(a4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v40;
        if (v20 && (v21 & 1) != 0) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 40))(v20, v19);
        }
      }
    }
  }
  else
  {
    uint64_t v11 = *re::pipelineLogObjects((re *)this);
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
    }
    long long v13 = *(_OWORD *)buf;
    uint64_t v14 = *(void *)&buf[16];
    uint64_t v15 = v47;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 100;
    *(void *)(a4 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + re::FramePersistentPtr<re::ecs2::VertexCacheComponent::VertexCacheInputs,re::FrameManager>::~FramePersistentPtr(this + 24) = v13;
    *(void *)(a4 + 40) = v14;
    *(void *)(a4 + 48) = v15;
  }
}

re *re::LUTTextureCompiler::deleteAsset(re::LUTTextureCompiler *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::TextureAsset>((re *)"deleteAsset", 99, a2);
}

re *re::LUTTextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(this)[2] + 40);
    return (re *)v2();
  }
  return this;
}

void re::LUTTextureCompiler::~LUTTextureCompiler(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x237DBCBD0);
}

void re::getLibraryHash(re *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  memset(v9, 0, sizeof(v9));
  if (!a5[1])
  {
    if (*(void *)(a4 + 72))
    {
      a5 = (uint64_t *)(a4 + 64);
    }
    else
    {
      if (!*(void *)(a3 + 104))
      {
        uint64_t v7 = *(void *)(*(void *)(a2 + 56) + 256);
        *(unsigned char *)a1 = 1;
        *((void *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v7;
        goto LABEL_7;
      }
      a5 = (uint64_t *)(a3 + 96);
    }
  }
  re::AssetHandle::operator=((uint64_t)v9, a5);
  re::AssetHandle::AssetHandle((re::AssetHandle *)v8, (const re::AssetHandle *)v9);
  re::getLibraryHash(a1, a2, (const re::AssetHandle *)v8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v8);
LABEL_7:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v9);
}

void re::getLibraryHash(re *a1, uint64_t a2, const re::AssetHandle *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)a3 + 1);
  if (!v5 || (unsigned int v6 = atomic_load((unsigned int *)(v5 + 704)), v6 != 2))
  {
    uint64_t v17 = *re::assetsLogObjects(a1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = **(void **)(*((void *)a3 + 1) + 264);
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v18;
      uint64_t v19 = "Can't get hash for not loaded %s";
LABEL_28:
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&buf, 0xCu);
    }
LABEL_29:
    *(unsigned char *)a1 = 0;
    return;
  }
  re::AssetHandle::AssetHandle((re::AssetHandle *)v24, a3);
  re::validateAssetType((const re::AssetHandle *)v24, (uint64_t)"Attempting to get library hash");
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v24);
  uint64_t v9 = *((void *)a3 + 1);
  if (!v9)
  {
    uint64_t v11 = re::ShaderLibraryAsset::assetType(v8);
LABEL_22:
    uint64_t v20 = *((void *)a3 + 1);
    if (v20)
    {
      char v21 = *(uint64_t **)(v20 + 264);
      unint64_t v22 = re::ShaderGraphAsset::assetType((re::ShaderGraphAsset *)v11);
      if (v21 == v22) {
        goto LABEL_29;
      }
    }
    else
    {
      unint64_t v22 = re::ShaderGraphAsset::assetType((re::ShaderGraphAsset *)v11);
    }
    uint64_t v17 = *re::assetsLogObjects((re *)v22);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = **(void **)(*((void *)a3 + 1) + 264);
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v23;
      uint64_t v19 = "Encountered asset with unexpected type %s in MaterialCompiler.cpp";
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  int v10 = *(uint64_t **)(v9 + 264);
  uint64_t v11 = re::ShaderLibraryAsset::assetType(v8);
  if (v10 != v11) {
    goto LABEL_22;
  }
  uint64_t v12 = re::AssetHandle::loadedAsset<re::ShaderLibraryAsset>(a3);
  re::DynamicString::DynamicString((re::DynamicString *)&buf, (const re::DynamicString *)(v12 + 40));
  uint64_t v13 = *((void *)&buf + 1) >> 1;
  if ((BYTE8(buf) & 1) == 0) {
    uint64_t v13 = BYTE8(buf) >> 1;
  }
  uint64_t v14 = *(void *)(a2 + 56);
  if (!v13) {
    goto LABEL_14;
  }
  if (BYTE8(buf)) {
    uint64_t v15 = v27;
  }
  else {
    uint64_t v15 = (char *)&buf + 9;
  }
  unint64_t LibraryHash = re::ShaderManager::getLibraryHash(*(re::ShaderManager **)(a2 + 56), v15);
  if (!re::HashTable<re::ecs2::Entity const*,re::ecs2::RenderPassGroup,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet(v14 + 264, (uint64_t *)&LibraryHash)|| (unint64_t v16 = LibraryHash) == 0)
  {
    uint64_t v14 = *(void *)(a2 + 56);
LABEL_14:
    unint64_t v16 = *(void *)(v14 + 256);
  }
  if ((void)buf)
  {
    if (BYTE8(buf)) {
      (*(void (**)(void))(*(void *)buf + 40))();
    }
  }
  *(unsigned char *)a1 = 1;
  *((void *)a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v16;
}

BOOL re::materialTextureParamIsAsset(re *this, const char *a2)
{
  uint64_t v2 = strrchr((char *)this, 46);
  BOOL result = 0;
  if (v2)
  {
    uint64_t v4 = v2;
    if (re::canLoadTextureFileWithExtension((re *)(v2 + 1), v3) || !strcmp(v4, ".compiledtexture")) {
      return 1;
    }
  }
  return result;
}

void re::tryLoadTexture(re *this, os_unfair_lock_s **a2, AssetService *a3, re::MaterialTextureParam *a4)
{
  if (LODWORD(a3[4].var0) != 1
    || (int v5 = (int)a4,
        (uint64_t v7 = (re::TextureAsset *)re::AssetHandle::loadedAsset<re::TextureAsset>((re::TextureAsset *)a3)) == 0))
  {
LABEL_19:
    *(unsigned char *)this = 0;
    return;
  }
  char v8 = v7;
  if (!v5
    || !re::TextureAsset::isLegacyLinearFormatWithSRGBData(v7)
    || ((uint64_t v9 = (void *)((char *)v8 + 136), !*((void *)v8 + 18)) || !*v9)
    && ((re::TextureAsset::addLegacyLinearFormatWithSRGBDataTexture((os_unfair_lock_s **)v8, a2), !*((void *)v8 + 18))
     || !*v9))
  {
    uint64_t isValid = (re *)re::TextureData::isValid((re::TextureAsset *)((char *)v8 + 152));
    if (isValid)
    {
      if (*((_DWORD *)v8 + 60))
      {
        uint64_t v11 = *re::pipelineLogObjects(isValid);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v12 = 0;
          _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, "Cannot render a texture asset that is not backed by a MTLAsset.", v12, 2u);
        }
      }
    }
    if (*((void *)v8 + 7) && *((void *)v8 + 6))
    {
      *(unsigned char *)this = 1;
      re::TextureHandle::TextureHandle((re *)((char *)this + 8), (re::TextureAsset *)((char *)v8 + 48));
      return;
    }
    goto LABEL_19;
  }
  *(unsigned char *)this = 1;
  re::TextureHandle::TextureHandle((re *)((char *)this + 8), (re::TextureAsset *)((char *)v8 + 136));
}

re::MaterialDefinitionFile *re::makeFlattenedMaterialFile(re *this, AssetService *a2, const re::MaterialDefinitionFile *a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v35 = 0;
  memset(v33, 0, sizeof(v33));
  int v34 = 0;
  unsigned int v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  uint64_t v32 = 0x7FFFFFFFLL;
  re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v29, (re::DynamicString *)a2);
  int16x8_t v24 = (uint64_t *)a2;
  re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)v33, &v24);
  re::AssetHandle::AssetHandle((re::AssetHandle *)v28, (const re::AssetHandle *)&a2[15]);
  if (*((_DWORD *)re::AssetHandle::assetInfo((re::AssetHandle *)v28) + 22))
  {
    while (1)
    {
      uint64_t v4 = re::AssetHandle::loadedAsset<re::MaterialDefinitionAsset>((re::MaterialDefinitionAsset *)v28);
      if (!v4)
      {
        char v8 = 0;
        goto LABEL_41;
      }
      uint64_t v5 = v4;
      unsigned int v6 = (re::DynamicString *)(v4 + 8);
      BOOL v7 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::contains((uint64_t)&v29, v4 + 8);
      if (v7) {
        break;
      }
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v29, v6);
      int16x8_t v24 = (uint64_t *)v6;
      re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)v33, &v24);
      re::AssetHandle::operator=((uint64_t)v28, (uint64_t *)(v5 + 128));
      if (!*((_DWORD *)re::AssetHandle::assetInfo((re::AssetHandle *)v28) + 22)) {
        goto LABEL_40;
      }
    }
    uint64_t v25 = 0;
    char v26 = 0;
    uint64_t v27 = 0;
    uint64_t v9 = (re *)re::DynamicString::setCapacity(&v24, 0);
    unsigned int v10 = v31;
    if (v31)
    {
      uint64_t v11 = 0;
      uint64_t v12 = (int *)(v30 + 8);
      while (1)
      {
        int v13 = *v12;
        v12 += 12;
        if (v13 < 0) {
          break;
        }
        if (v31 == ++v11)
        {
          LODWORD(v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v31;
          break;
        }
      }
    }
    else
    {
      LODWORD(v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    }
    if (v31 != v11)
    {
      uint64_t v14 = v11;
      uint64_t v15 = v30;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)(v15 + 48 * v14 + 16));
        if (buf[8]) {
          unint64_t v16 = *(const char **)&v38[2];
        }
        else {
          unint64_t v16 = &buf[9];
        }
        re::DynamicString::appendf((re::DynamicString *)&v24, "-> %s", v16);
        uint64_t v9 = *(re **)buf;
        if (*(void *)buf && (buf[8] & 1) != 0) {
          uint64_t v9 = (re *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
        }
        uint64_t v15 = v30;
        if (v31 <= (int)v11 + 1) {
          unsigned int v17 = v11 + 1;
        }
        else {
          unsigned int v17 = v31;
        }
        while (1)
        {
          uint64_t v14 = (v11 + 1);
          if (v17 - 1 == v11) {
            break;
          }
          LODWORD(v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v11 + 1;
          unsigned int v18 = v14;
          if ((*(_DWORD *)(v30 + 48 * v14 + 8) & 0x80000000) != 0) {
            goto LABEL_28;
          }
        }
        unsigned int v18 = v17;
LABEL_28:
        LODWORD(v1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v18;
      }
      while (v10 != v18);
    }
    uint64_t v19 = *re::pipelineLogObjects(v9);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      if ((uint64_t)a2[1].var0) {
        var0 = a2[2].var0;
      }
      else {
        var0 = (void **)((char *)&a2[1].var0 + 1);
      }
      if (v25) {
        char v21 = v26;
      }
      else {
        char v21 = (char *)&v25 + 1;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = var0;
      __int16 v37 = 2080;
      *(void *)long long v38 = v21;
      _os_log_impl(&dword_233120000, v19, OS_LOG_TYPE_DEFAULT, "Found circular dependency in material %s: {%s}", buf, 0x16u);
    }
    if (v24 && (v25 & 1) != 0) {
      (*(void (**)(void))(*v24 + 40))();
    }
  }
LABEL_40:
  char v8 = re::resolveOverrideMaterials((re *)a2, (uint64_t)v33);
LABEL_41:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v28);
  double v22 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v29);
  if (v33[0] && v35) {
    (*(void (**)(double))(*(void *)v33[0] + 40))(v22);
  }
  return v8;
}

uint64_t re::AssetHandle::loadedAsset<re::MaterialDefinitionAsset>(re::MaterialDefinitionAsset *a1)
{
  if (!*((void *)a1 + 1)) {
    return 0;
  }
  uint64_t v2 = re::MaterialDefinitionAsset::assetType(a1);
  return re::AssetHandle::assetWithType(a1, (const re::AssetType *)v2, 1);
}

re::MaterialDefinitionFile *re::resolveOverrideMaterials(re *a1, uint64_t a2)
{
  uint64_t v425 = *MEMORY[0x263EF8340];
  uint64_t v4 = re::globalAllocators(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 736, 8);
  unsigned int v6 = re::MaterialDefinitionFile::MaterialDefinitionFile((re::MaterialDefinitionFile *)v5);
  unsigned int v411 = 0;
  long long v409 = 0u;
  long long v410 = 0u;
  uint64_t v412 = 0x7FFFFFFFLL;
  unsigned int v407 = 0;
  long long v405 = 0u;
  long long v406 = 0u;
  uint64_t v408 = 0x7FFFFFFFLL;
  unsigned int v403 = 0;
  long long v401 = 0u;
  long long v402 = 0u;
  uint64_t v404 = 0x7FFFFFFFLL;
  unsigned int v399 = 0;
  long long v397 = 0u;
  long long v398 = 0u;
  uint64_t v400 = 0x7FFFFFFFLL;
  unsigned int v395 = 0;
  *(_OWORD *)__b = 0u;
  long long v394 = 0u;
  unint64_t v396 = 0x7FFFFFFFLL;
  unsigned int v391 = 0;
  long long v389 = 0u;
  long long v390 = 0u;
  uint64_t v392 = 0x7FFFFFFFLL;
  uint64_t v7 = *(void *)(a2 + 16);
  float v383 = v6;
  if (!v7)
  {
LABEL_465:
    unsigned int v305 = 0;
LABEL_466:
    LODWORD(v306) = 0;
    goto LABEL_467;
  }
  uint64_t v353 = a2;
  uint64_t v8 = *(void *)(a2 + 32) + 8 * v7;
  long long v356 = (re::DynamicString *)(v5 + 32);
  uint64_t v357 = v5 + 96;
  uint64_t v358 = v5 + 144;
  uint64_t v381 = (void *)(v5 + 336);
  float32_t v382 = (void *)(v5 + 240);
  uint64_t v363 = v5 + 688;
  unint64_t v354 = (char *)a1 + 9;
  uint64_t v355 = a1;
  int32x4_t v374 = (void *)(v5 + 600);
  float32_t v375 = (void *)(v5 + 288);
  uint64_t v352 = v5 + 464;
  long long v364 = (void *)(v5 + 512);
  uint64_t v365 = v5 + 192;
  do
  {
    uint64_t v9 = v8;
    if (HIDWORD(v394))
    {
      if (DWORD2(v394)) {
        memset_pattern16(__b[1], &memset_pattern_169, 4 * DWORD2(v394));
      }
      uint64_t v10 = v395;
      if (v395)
      {
        uint64_t v11 = v394;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicArray<unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(v11);
          v11 += 88;
          --v10;
        }
        while (v10);
      }
      unsigned int v395 = 0;
      HIDWORD(v39re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
      LODWORD(v396) = 0x7FFFFFFF;
      ++HIDWORD(v396);
    }
    re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)&v389);
    int v13 = *(re::DynamicString **)(v9 - 8);
    uint64_t v12 = (uint64_t *)(v9 - 8);
    re::DynamicString::operator=((re::DynamicString *)v5, v13);
    unint64_t v14 = *(void *)(v5 + 40);
    if (v14) {
      unint64_t v15 = v14 >> 1;
    }
    else {
      unint64_t v15 = v14 >> 1;
    }
    if (!v15) {
      re::DynamicString::operator=(v356, (re::DynamicString *)(*v12 + 32));
    }
    unint64_t v16 = (re *)re::AssetHandle::operator=(v357, (uint64_t *)(*v12 + 96));
    uint64_t v17 = *v12;
    unint64_t v18 = *(void *)(*v12 + 72);
    if (v18) {
      unint64_t v19 = v18 >> 1;
    }
    else {
      unint64_t v19 = v18 >> 1;
    }
    size_t v384 = v12;
    if (v19)
    {
      uint64_t v20 = *re::pipelineLogObjects(v16);
      BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      uint64_t v17 = *v12;
      if (v21)
      {
        if (*(unsigned char *)(v17 + 72)) {
          uint64_t v22 = *(void *)(v17 + 80);
        }
        else {
          uint64_t v22 = v17 + 73;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl(&dword_233120000, v20, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
        uint64_t v17 = *v12;
      }
    }
    re::append<re::DynamicString,re::DynamicString>(v365, v17 + 192);
    uint64_t v23 = v12;
    uint64_t v24 = *v12;
    uint64_t v25 = *(unsigned int *)(*v384 + 272);
    if (v25)
    {
      uint64_t v26 = 0;
      uint64_t v27 = (int *)(*(void *)(v24 + 256) + 8);
      while (1)
      {
        int v28 = *v27;
        v27 += 22;
        if (v28 < 0) {
          break;
        }
        if (v25 == ++v26)
        {
          LODWORD(v26) = *(_DWORD *)(*v384 + 272);
          break;
        }
      }
      uint64_t v23 = v384;
    }
    else
    {
      LODWORD(v26) = 0;
    }
    if (v25 == v26)
    {
      long long v29 = v23;
      goto LABEL_55;
    }
    uint64_t v30 = v26;
    uint64_t v31 = *(void *)(v24 + 256);
    uint64_t v370 = *v384;
    int v376 = *(_DWORD *)(*v384 + 272);
    do
    {
      uint64_t v32 = v31 + 88 * v30;
      int v33 = (re::DynamicString *)(v32 + 16);
      int v34 = (unsigned int *)(v32 + 48);
      unint64_t v35 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v32 + 16);
      unint64_t v36 = v35;
      if (!*v382)
      {
        LODWORD(v3re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
        goto LABEL_42;
      }
      unint64_t v37 = v35 % *((unsigned int *)v383 + 66);
      uint64_t v25 = *(unsigned int *)(*((void *)v383 + 31) + 4 * v37);
      if (v25 == 0x7FFFFFFF)
      {
LABEL_40:
        LODWORD(v25) = v376;
LABEL_42:
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)v382, v37, v36, v33, v34);
        goto LABEL_43;
      }
      uint64_t v38 = *((void *)v383 + 32);
      while (!re::DynamicString::operator==(v38 + 88 * v25 + 16, (uint64_t)v33))
      {
        uint64_t v25 = *(_DWORD *)(v38 + 88 * v25 + 8) & 0x7FFFFFFF;
        if (v25 == 0x7FFFFFFF)
        {
          uint64_t v24 = v370;
          goto LABEL_40;
        }
      }
      uint64_t v41 = v38 + 88 * v25;
      uint64_t v42 = (re::DynamicString *)(v41 + 48);
      uint64_t v43 = *(unsigned int *)(v41 + 80);
      if (v43 != -1) {
        off_26E6E12D8[v43]((int)buf, v42);
      }
      *((_DWORD *)v42 + 8) = -1;
      uint64_t v44 = *((void *)v383 + 32) + 88 * v25;
      *(unsigned char *)(v44 + 48) = 0;
      v44 += 48;
      *(_DWORD *)(v44 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1> const&>((unsigned int *)v44, v34);
      uint64_t v24 = v370;
      LODWORD(v25) = v376;
LABEL_43:
      ++*((_DWORD *)v383 + 70);
      uint64_t v31 = *(void *)(v24 + 256);
      if (*(_DWORD *)(v24 + 272) <= (v26 + 1)) {
        int v39 = v26 + 1;
      }
      else {
        int v39 = *(_DWORD *)(v24 + 272);
      }
      while (1)
      {
        uint64_t v30 = (v26 + 1);
        if (v39 - 1 == v26) {
          break;
        }
        LODWORD(v26) = v26 + 1;
        int v40 = v30;
        if ((*(_DWORD *)(v31 + 88 * v30 + 8) & 0x80000000) != 0) {
          goto LABEL_50;
        }
      }
      int v40 = v39;
LABEL_50:
      LODWORD(v26) = v40;
    }
    while (v25 != v40);
    long long v29 = v384;
    uint64_t v24 = *v384;
LABEL_55:
    unint64_t v45 = re::append<re::DynamicString,re::DynamicString>(v358, v24 + 144);
    uint64_t v5 = *v29;
    uint64_t v46 = *(unsigned int *)(*v29 + 368);
    if (v46)
    {
      uint64_t v47 = 0;
      long long v48 = (int *)(*(void *)(v5 + 352) + 8);
      while (1)
      {
        int v49 = *v48;
        v48 += 38;
        if (v49 < 0) {
          break;
        }
        if (v46 == ++v47)
        {
          LODWORD(v4re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v46;
          break;
        }
      }
    }
    else
    {
      LODWORD(v4re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
    }
    if (v46 == v47) {
      goto LABEL_81;
    }
    uint64_t v50 = v47;
    uint64_t v51 = *(void *)(v5 + 352);
    int v366 = v46;
    while (2)
    {
      uint64_t v52 = v51 + 152 * v50;
      long long v53 = (re::DynamicString *)(v52 + 16);
      uint64_t v54 = v52 + 48;
      unint64_t v55 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v52 + 16);
      unint64_t v56 = v55;
      if (!*v381)
      {
        LODWORD(v5re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
LABEL_70:
        unint64_t v45 = re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)v381, v57, v56, v53, v54);
        goto LABEL_71;
      }
      unint64_t v57 = v55 % *((unsigned int *)v383 + 90);
      uint64_t v58 = *(unsigned int *)(*((void *)v383 + 43) + 4 * v57);
      if (v58 == 0x7FFFFFFF) {
        goto LABEL_70;
      }
      unint64_t v371 = v55 % *((unsigned int *)v383 + 90);
      uint64_t v46 = *((void *)v383 + 44);
      while (!re::DynamicString::operator==(v46 + 152 * v58 + 16, (uint64_t)v53))
      {
        uint64_t v58 = *(_DWORD *)(v46 + 152 * v58 + 8) & 0x7FFFFFFF;
        if (v58 == 0x7FFFFFFF)
        {
          LODWORD(v46) = v366;
          LODWORD(v5re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v371;
          goto LABEL_70;
        }
      }
      unint64_t v45 = re::OptionalMaterialSamplerData::OptionalMaterialSamplerData(v46 + 152 * v58 + 48, v54);
      LODWORD(v46) = v366;
LABEL_71:
      ++*((_DWORD *)v383 + 94);
      uint64_t v51 = *(void *)(v5 + 352);
      if (*(_DWORD *)(v5 + 368) <= (v47 + 1)) {
        int v59 = v47 + 1;
      }
      else {
        int v59 = *(_DWORD *)(v5 + 368);
      }
      while (1)
      {
        uint64_t v50 = (v47 + 1);
        if (v59 - 1 == v47) {
          break;
        }
        LODWORD(v4re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v47 + 1;
        int v60 = v50;
        if ((*(_DWORD *)(v51 + 152 * v50 + 8) & 0x80000000) != 0) {
          goto LABEL_78;
        }
      }
      int v60 = v59;
LABEL_78:
      LODWORD(v4re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v60;
      if (v46 != v60) {
        continue;
      }
      break;
    }
    uint64_t v5 = *v384;
LABEL_81:
    uint64_t v377 = *(unsigned int *)(v5 + 320);
    uint64_t v61 = 0;
    if (v377)
    {
      int v62 = (int *)(*(void *)(v5 + 304) + 8);
      while (1)
      {
        int v63 = *v62;
        v62 += 40;
        if (v63 < 0) {
          break;
        }
        if (v377 == ++v61)
        {
          LODWORD(v6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(_DWORD *)(v5 + 320);
          break;
        }
      }
    }
    if (v377 == v61) {
      goto LABEL_126;
    }
    uint64_t v64 = v61;
    while (2)
    {
      uint64_t v65 = *(void *)(v5 + 304);
      uint64_t v66 = v65 + 160 * v64;
      BOOL v67 = (re::DynamicString *)(v66 + 16);
      int v68 = (re::MaterialTextureParam *)(v66 + 48);
      uint64_t v69 = re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v375, v66 + 16);
      if (v69)
      {
        uint64_t v71 = v69;
        if (*re::MaterialTextureParam::serializationString(v68, v70)) {
          std::__variant_detail::__assignment<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<re::DynamicString,re::AssetHandle>,(std::__variant_detail::_Trait)1> const&>(v71, (uint64_t)v68);
        }
        uint64_t v72 = v65 + 160 * v64;
        unint64_t v45 = (unint64_t)re::replaceIfValid<re::DynamicString>((re::DynamicString *)(v71 + 40), (re::DynamicString *)(v72 + 88));
        if (*(unsigned char *)(v72 + 152))
        {
          if (!*(unsigned char *)(v71 + 104)) {
            *(unsigned char *)(v71 + 10re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 1;
          }
          *(_DWORD *)(v71 + 108) = *(_DWORD *)(v65 + 160 * v64 + 156);
        }
        uint64_t v73 = v65 + 160 * v64;
        unint64_t v76 = *(void *)(v73 + 128);
        uint64_t v75 = (unsigned char *)(v73 + 128);
        char v74 = v76;
        unint64_t v77 = v76 >> 1;
        unint64_t v78 = v76 >> 1;
        if ((v76 & 1) == 0) {
          unint64_t v77 = v78;
        }
        if (v77)
        {
          uint64_t v79 = (v74 & 1) != 0 ? *(const char **)(v65 + 160 * v64 + 136) : v75 + 1;
          unint64_t v45 = strcmp("dynamicSamplers", v79);
          if (v45)
          {
            int v86 = *re::pipelineLogObjects((re *)v45);
            unint64_t v45 = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
            if (v45)
            {
              uint64_t v87 = *v384;
              if (*(unsigned char *)(*v384 + 8)) {
                uint64_t v88 = *(void *)(v87 + 16);
              }
              else {
                uint64_t v88 = v87 + 9;
              }
              if (*v75) {
                double v89 = *(unsigned char **)(v65 + 160 * v64 + 136);
              }
              else {
                double v89 = v75 + 1;
              }
              *(_DWORD *)long long buf = 136315650;
              *(void *)&uint8_t buf[4] = v88;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v89;
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "dynamicSamplers";
              _os_log_impl(&dword_233120000, v86, OS_LOG_TYPE_DEFAULT, "Material '%s' uses custom dynamic sampler array \"%s\", but custom array names are no longer supported. Please ensure the array name in the shader is \"%s\" and remove \"SamplerArray\" from your material file.", buf, 0x20u);
            }
          }
        }
        goto LABEL_118;
      }
      unint64_t v80 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v67);
      unint64_t v81 = v80;
      if (!*v375)
      {
        LODWORD(v82) = 0;
LABEL_112:
        unint64_t v45 = re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)v375, v82, v81, v67, (uint64_t)v68);
        ++*((_DWORD *)v383 + 82);
        goto LABEL_118;
      }
      unint64_t v82 = v80 % *((unsigned int *)v383 + 78);
      uint64_t v83 = *(unsigned int *)(*((void *)v383 + 37) + 4 * v82);
      if (v83 == 0x7FFFFFFF) {
        goto LABEL_112;
      }
      double v84 = v68;
      uint64_t v85 = *((void *)v383 + 38);
      while (1)
      {
        unint64_t v45 = re::DynamicString::operator==(v85 + 160 * v83 + 16, (uint64_t)v67);
        if (v45) {
          break;
        }
        uint64_t v83 = *(_DWORD *)(v85 + 160 * v83 + 8) & 0x7FFFFFFF;
        if (v83 == 0x7FFFFFFF)
        {
          int v68 = v84;
          goto LABEL_112;
        }
      }
LABEL_118:
      unsigned int v90 = *(_DWORD *)(v5 + 320);
      if (v90 <= (int)v61 + 1) {
        unsigned int v90 = v61 + 1;
      }
      while (1)
      {
        uint64_t v64 = (v61 + 1);
        if (v90 - 1 == v61) {
          break;
        }
        LODWORD(v6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v61 + 1;
        unsigned int v91 = v64;
        if ((*(_DWORD *)(*(void *)(v5 + 304) + 160 * v64 + 8) & 0x80000000) != 0) {
          goto LABEL_124;
        }
      }
      unsigned int v91 = v90;
LABEL_124:
      LODWORD(v6re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v91;
      if (v377 != v91) {
        continue;
      }
      break;
    }
    uint64_t v5 = *v384;
LABEL_126:
    unint64_t v387 = 0;
    float32x4_t v388 = &v409;
    unint64_t v92 = *(void *)(v5 + 400);
    if (v92)
    {
      unint64_t v93 = 0;
      while (1)
      {
        if (v92 <= v93) {
          goto LABEL_553;
        }
        re::MaterialTechniqueData::MaterialTechniqueData((re::MaterialTechniqueData *)buf, (const re::MaterialTechniqueData *)(*(void *)(v5 + 416) + 664 * v93));
        if ((BYTE8(v414) & 1) != 0 ? *((void *)&v414 + 1) >> 1 : BYTE8(v414) >> 1) {
          break;
        }
        re::resolveOverrideMaterials(re::MaterialDefinitionFile const&,re::DynamicArray<re::MaterialDefinitionFile const*> const&)::$_0::operator()((uint64_t *)&v388, (re::DynamicString *)buf, (uint64_t)buf);
LABEL_146:
        re::MaterialTechniqueData::~MaterialTechniqueData((re::MaterialTechniqueData *)buf);
        unint64_t v93 = v387 + 1;
        unint64_t v387 = v93;
        uint64_t v5 = *v384;
        unint64_t v92 = *(void *)(*v384 + 400);
        if (v93 >= v92) {
          goto LABEL_147;
        }
      }
      *(void *)&v424[2] = 0;
      memset(v424, 0, 28);
      unint64_t v95 = re::Hash<re::DynamicString>::operator()((uint64_t)v417, (uint64_t)&v414);
      unint64_t v96 = v95;
      if (__b[0])
      {
        unint64_t v97 = v95 % DWORD2(v394);
        uint64_t v98 = *((unsigned int *)__b[1] + v97);
        if (v98 != 0x7FFFFFFF)
        {
          uint64_t v99 = v394;
          while (!re::DynamicString::operator==(v99 + 88 * v98 + 16, (uint64_t)&v414))
          {
            uint64_t v98 = *(_DWORD *)(v99 + 88 * v98 + 8) & 0x7FFFFFFF;
            if (v98 == 0x7FFFFFFF) {
              goto LABEL_141;
            }
          }
          int v101 = (void *)(v99 + 88 * v98 + 48);
          goto LABEL_145;
        }
      }
      else
      {
        LODWORD(v9re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
      }
LABEL_141:
      unsigned int v100 = re::HashTable<re::DynamicString,re::DynamicArray<unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)__b, v97, v96, (const re::DynamicString *)&v414, (uint64_t)v424);
      ++HIDWORD(v396);
      int v101 = (void *)(v394 + 88 * v100 + 48);
      if (*(void *)&v424[0] && *(void *)&v424[2]) {
        (*(void (**)(void))(**(void **)&v424[0] + 40))();
      }
LABEL_145:
      re::DynamicArray<unsigned long>::add(v101, &v387);
      goto LABEL_146;
    }
LABEL_147:
    unint64_t v102 = HIDWORD(v394);
    while (2)
    {
      unsigned int v103 = v395;
      unint64_t v378 = v102;
      uint64_t v5 = 0;
      if (v395)
      {
        BOOL v104 = (int *)(v394 + 8);
        while (1)
        {
          int v105 = *v104;
          v104 += 22;
          if (v105 < 0) {
            break;
          }
          if (v395 == ++v5)
          {
            uint64_t v5 = v395;
            break;
          }
        }
      }
      if (v395 != v5)
      {
        uint64_t v106 = v5;
        uint64_t v107 = v394;
        while (1)
        {
          unint64_t v45 = re::HashTable<re::DynamicString,re::MaterialTechniqueData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v409, v107 + 88 * v106 + 16);
          if (v45)
          {
            unint64_t v45 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v389, (re::DynamicString *)(v107 + 88 * v106 + 16));
            uint64_t v108 = v107 + 88 * v106;
            uint64_t v109 = *(void *)(v108 + 64);
            if (v109) {
              break;
            }
          }
LABEL_167:
          uint64_t v107 = v394;
          if (v395 <= (int)v5 + 1) {
            uint64_t v118 = (v5 + 1);
          }
          else {
            uint64_t v118 = v395;
          }
          while (1)
          {
            uint64_t v106 = (v5 + 1);
            if (v118 - 1 == v5) {
              break;
            }
            LODWORD(v5) = v5 + 1;
            uint64_t v119 = v106;
            if ((*(_DWORD *)(v394 + 88 * v106 + 8) & 0x80000000) != 0) {
              goto LABEL_174;
            }
          }
          uint64_t v119 = v118;
LABEL_174:
          uint64_t v5 = v119;
          if (v103 == v119) {
            goto LABEL_175;
          }
        }
        unsigned __int16 v110 = *(unint64_t **)(v108 + 80);
        BOOL v111 = &v110[v109];
        while (2)
        {
          unint64_t v112 = *v110;
          unint64_t v113 = *(void *)(*v384 + 400);
          if (v113 <= *v110)
          {
            *(void *)uint64_t v417 = 0;
            long long v415 = 0u;
            long long v416 = 0u;
            long long v414 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v424[0]) = 136315906;
            *(void *)((char *)v424 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
            WORD6(v424[0]) = 1024;
            *(_DWORD *)((char *)v424 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 797;
            WORD1(v424[1]) = 2048;
            *(void *)((char *)&v424[1] + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v112;
            WORD6(v424[1]) = 2048;
            *(void *)((char *)&v424[1] + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v113;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_465;
          }
          BOOL v114 = (re::DynamicString *)(*(void *)(*v384 + 416) + 664 * v112);
          unint64_t v115 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v114 + 32);
          if ((void)v409)
          {
            uint64_t v116 = v410;
            uint64_t v117 = *(unsigned int *)(*((void *)&v409 + 1) + 4 * (v115 % DWORD2(v410)));
            if (v117 != 0x7FFFFFFF)
            {
              while (!re::DynamicString::operator==(v116 + 712 * v117 + 16, (uint64_t)v114 + 32))
              {
                uint64_t v117 = *(_DWORD *)(v116 + 712 * v117 + 8) & 0x7FFFFFFF;
                if (v117 == 0x7FFFFFFF) {
                  goto LABEL_165;
                }
              }
LABEL_166:
              re::resolveOverrideMaterials(re::MaterialDefinitionFile const&,re::DynamicArray<re::MaterialDefinitionFile const*> const&)::$_0::operator()((uint64_t *)&v388, v114, v116 + 712 * v117 + 48);
              re::resolveOverrideMaterials(re::MaterialDefinitionFile const&,re::DynamicArray<re::MaterialDefinitionFile const*> const&)::$_0::operator()((uint64_t *)&v388, v114, (uint64_t)v114);
              if (++v110 == v111) {
                goto LABEL_167;
              }
              continue;
            }
          }
          else
          {
            uint64_t v116 = v410;
          }
          break;
        }
LABEL_165:
        uint64_t v117 = 0x7FFFFFFFLL;
        goto LABEL_166;
      }
LABEL_175:
      unsigned int v120 = v391;
      if (v391)
      {
        uint64_t v121 = 0;
        long long v122 = (int *)(v390 + 8);
        while (1)
        {
          int v123 = *v122;
          v122 += 12;
          if (v123 < 0) {
            break;
          }
          if (v391 == ++v121)
          {
            LODWORD(v12re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v391;
            break;
          }
        }
      }
      else
      {
        LODWORD(v12re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
      }
      if (v391 != v121)
      {
        uint64_t v124 = v121;
        uint64_t v125 = v390;
        do
        {
          uint64_t v126 = v125 + 48 * v124 + 16;
          unint64_t v45 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v126);
          if (__b[0])
          {
            unint64_t v127 = v45 % DWORD2(v394);
            size_t v128 = __b[1];
            uint64_t v129 = *((unsigned int *)__b[1] + v127);
            if (v129 != 0x7FFFFFFF)
            {
              uint64_t v130 = v394;
              unint64_t v45 = re::DynamicString::operator==(v394 + 88 * v129 + 16, v126);
              if (v45)
              {
                v128[v127] = *(_DWORD *)(v130 + 88 * v129 + 8) & 0x7FFFFFFF;
LABEL_190:
                unint64_t v45 = re::HashTable<re::DynamicString,re::DynamicArray<unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(v130 + 88 * v129);
                int v132 = HIDWORD(v394);
                *(_DWORD *)(v130 + 88 * v129 + 8) = *(_DWORD *)(v130 + 88 * v129 + 8) & 0x80000000 | v396;
                HIDWORD(v39re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v132 - 1;
                unint64_t v396 = __PAIR64__(HIDWORD(v396), v129) + 0x100000000;
              }
              else
              {
                while (1)
                {
                  uint64_t v131 = v129;
                  uint64_t v129 = *(_DWORD *)(v130 + 88 * v129 + 8) & 0x7FFFFFFF;
                  if (v129 == 0x7FFFFFFF) {
                    break;
                  }
                  unint64_t v45 = re::DynamicString::operator==(v130 + 88 * v129 + 16, v126);
                  if (v45)
                  {
                    *(_DWORD *)(v130 + 88 * v131 + 8) = *(_DWORD *)(v130 + 88 * v131 + 8) & 0x80000000 | *(_DWORD *)(v130 + 88 * v129 + 8) & 0x7FFFFFFF;
                    goto LABEL_190;
                  }
                }
              }
            }
          }
          uint64_t v125 = v390;
          if (v391 <= (int)v121 + 1) {
            unsigned int v133 = v121 + 1;
          }
          else {
            unsigned int v133 = v391;
          }
          while (1)
          {
            uint64_t v124 = (v121 + 1);
            if (v133 - 1 == v121) {
              break;
            }
            LODWORD(v12re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v121 + 1;
            unsigned int v134 = v124;
            if ((*(_DWORD *)(v390 + 48 * v124 + 8) & 0x80000000) != 0) {
              goto LABEL_198;
            }
          }
          unsigned int v134 = v133;
LABEL_198:
          LODWORD(v12re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v134;
        }
        while (v120 != v134);
      }
      unint64_t v102 = HIDWORD(v394);
      if (v378 > HIDWORD(v394)) {
        continue;
      }
      break;
    }
    unsigned int v135 = v395;
    if (v395)
    {
      uint64_t v136 = 0;
      uint64_t v137 = (int *)(v394 + 8);
      while (1)
      {
        int v138 = *v137;
        v137 += 22;
        if (v138 < 0) {
          break;
        }
        if (v395 == ++v136)
        {
          LODWORD(v136) = v395;
          break;
        }
      }
    }
    else
    {
      LODWORD(v136) = 0;
    }
    if (v395 != v136)
    {
      uint64_t v139 = v136;
      uint64_t v140 = v394;
      *(void *)long long v359 = v394 + 9;
      while (1)
      {
        uint64_t v141 = v140 + 88 * v139;
        uint64_t v142 = *(void *)(v141 + 64);
        if (v142) {
          break;
        }
LABEL_223:
        if (v135 <= (int)v136 + 1) {
          unsigned int v152 = v136 + 1;
        }
        else {
          unsigned int v152 = v135;
        }
        while (1)
        {
          uint64_t v139 = (v136 + 1);
          if (v152 - 1 == v136) {
            break;
          }
          LODWORD(v136) = v136 + 1;
          unsigned int v153 = v139;
          if ((*(_DWORD *)(v140 + 88 * v139 + 8) & 0x80000000) != 0) {
            goto LABEL_230;
          }
        }
        unsigned int v153 = v152;
LABEL_230:
        LODWORD(v136) = v153;
        if (v135 == v153) {
          goto LABEL_231;
        }
      }
      unsigned int v143 = *(unint64_t **)(v141 + 80);
      uint64_t v144 = 88 * v139;
      float v379 = (unsigned char *)(v140 + v144 + 24);
      long long v367 = (uint64_t *)(v140 + v144 + 32);
      uint64_t v372 = *(void *)v359 + v144 + 16;
      uint64_t v5 = 8 * v142;
      while (1)
      {
        unint64_t v93 = *v143;
        unint64_t v92 = *(void *)(*v384 + 400);
        if (v92 <= *v143) {
          break;
        }
        uint64_t v145 = *(void *)(*v384 + 416);
        long long v146 = *re::assetsLogObjects((re *)v45);
        unint64_t v45 = os_log_type_enabled(v146, OS_LOG_TYPE_ERROR);
        if (v45)
        {
          uint64_t v147 = *v384;
          if (*(unsigned char *)(*v384 + 8)) {
            uint64_t v148 = *(void *)(v147 + 16);
          }
          else {
            uint64_t v148 = v147 + 9;
          }
          uint64_t v149 = v145 + 664 * v93;
          if (*(unsigned char *)(v149 + 8)) {
            uint64_t v150 = *(void *)(v149 + 16);
          }
          else {
            uint64_t v150 = v149 + 9;
          }
          uint64_t v151 = v372;
          if (*v379) {
            uint64_t v151 = *v367;
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v148;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v150;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v151;
          _os_log_error_impl(&dword_233120000, v146, OS_LOG_TYPE_ERROR, "Material definition '%s' contains technique '%s' which inherits from non-existent technique '%s', or forms a dependency cycle, so it will be skipped.", buf, 0x20u);
        }
        ++v143;
        v5 -= 8;
        if (!v5) {
          goto LABEL_223;
        }
      }
      *(void *)uint64_t v417 = 0;
      long long v415 = 0u;
      long long v416 = 0u;
      long long v414 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v424[0]) = 136315906;
      *(void *)((char *)v424 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = "operator[]";
      WORD6(v424[0]) = 1024;
      *(_DWORD *)((char *)v424 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 797;
      WORD1(v424[1]) = 2048;
      *(void *)((char *)&v424[1] + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v93;
      WORD6(v424[1]) = 2048;
      *(void *)((char *)&v424[1] + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v92;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_553:
      uint64_t v385 = 0;
      memset(v424, 0, sizeof(v424));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v417 = 136315906;
      *(void *)&v417[4] = "operator[]";
      __int16 v418 = 1024;
      int v419 = 797;
      __int16 v420 = 2048;
      unint64_t v421 = v93;
      __int16 v422 = 2048;
      unint64_t v423 = v92;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      break;
    }
LABEL_231:
    long long v154 = v384;
    uint64_t v155 = *v384;
    uint64_t v156 = *(void *)(*v384 + 440);
    if (!v156) {
      goto LABEL_252;
    }
    long long v157 = *(uint64_t **)(v155 + 456);
    unint64_t v158 = &v157[9 * v156];
    while (2)
    {
      re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)v157);
      re::DynamicArray<re::DynamicString>::DynamicArray((uint64_t)&v414, v157 + 4);
      unint64_t v159 = re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf);
      unint64_t v160 = v159;
      if (!(void)v405)
      {
        unint64_t v161 = 0;
LABEL_240:
        unsigned int v164 = v408;
        if (v408 == 0x7FFFFFFF)
        {
          unsigned int v164 = v407;
          unsigned int v165 = v407;
          if (v407 == DWORD2(v406))
          {
            re::HashTable<re::DynamicString,re::MaterialTechniqueGroupData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v405, 2 * HIDWORD(v406));
            unsigned int v165 = v407;
            unint64_t v161 = v160 % DWORD2(v406);
          }
          unsigned int v407 = v165 + 1;
          uint64_t v166 = v406;
          int v167 = *(_DWORD *)(v406 + 120 * v164 + 8);
        }
        else
        {
          uint64_t v166 = v406;
          int v167 = *(_DWORD *)(v406 + 120 * v408 + 8);
          LODWORD(v408) = v167 & 0x7FFFFFFF;
        }
        uint64_t v168 = v166 + 120 * v164;
        *(_DWORD *)(v168 + 8) = v167 | 0x80000000;
        uint64_t v169 = *((void *)&v405 + 1);
        *(_DWORD *)(v168 + 8) = *(_DWORD *)(*((void *)&v405 + 1) + 4 * v161) | 0x80000000;
        *(void *)uint64_t v168 = v160;
        re::DynamicString::DynamicString((re::DynamicString *)(v168 + 16), (const re::DynamicString *)buf);
        re::DynamicString::DynamicString((re::DynamicString *)(v168 + 48), (const re::DynamicString *)buf);
        re::DynamicArray<re::DynamicString>::DynamicArray(v168 + 80, (uint64_t *)&v414);
        *(_DWORD *)(v169 + 4 * v16re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v164;
        ++HIDWORD(v406);
        goto LABEL_246;
      }
      unint64_t v161 = v159 % DWORD2(v406);
      uint64_t v162 = *(unsigned int *)(*((void *)&v405 + 1) + 4 * v161);
      if (v162 == 0x7FFFFFFF) {
        goto LABEL_240;
      }
      uint64_t v163 = v406;
      while (!re::DynamicString::operator==(v163 + 120 * v162 + 16, (uint64_t)buf))
      {
        uint64_t v162 = *(_DWORD *)(v163 + 120 * v162 + 8) & 0x7FFFFFFF;
        if (v162 == 0x7FFFFFFF) {
          goto LABEL_240;
        }
      }
      uint64_t v170 = v163 + 120 * v162;
      re::MaterialTechniqueGroupData::deinit((const re::DynamicString **)(v170 + 48));
      re::DynamicArray<re::DynamicString>::deinit(v170 + 80);
      re::DynamicString::deinit((re::DynamicString *)(v170 + 48));
      re::DynamicString::DynamicString((re::DynamicString *)(v170 + 48), (const re::DynamicString *)buf);
      re::DynamicArray<re::DynamicString>::DynamicArray(v170 + 80, (uint64_t *)&v414);
LABEL_246:
      ++HIDWORD(v408);
      re::MaterialTechniqueGroupData::deinit((const re::DynamicString **)buf);
      re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v414);
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      v157 += 9;
      if (v157 != v158) {
        continue;
      }
      break;
    }
    long long v154 = v384;
    uint64_t v155 = *v384;
LABEL_252:
    uint64_t v171 = *(void *)(v155 + 576);
    if (!v171) {
      goto LABEL_298;
    }
    uint64_t v172 = *(const re::DynamicString **)(v155 + 592);
    uint64_t v173 = (const re::DynamicString *)((char *)v172 + 80 * v171);
    while (2)
    {
      re::DynamicString::DynamicString((re::DynamicString *)buf, v172);
      re::HashTable<re::DynamicString,int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v414, (uint64_t)v172 + 32);
      unint64_t v174 = re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf);
      if (!(void)v401)
      {
        unint64_t v180 = re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf);
        unint64_t v181 = 0;
        goto LABEL_265;
      }
      unint64_t v175 = DWORD2(v402);
      uint64_t v176 = *((void *)&v401 + 1);
      uint64_t v177 = *(unsigned int *)(*((void *)&v401 + 1) + 4 * (v174 % DWORD2(v402)));
      if (v177 == 0x7FFFFFFF)
      {
LABEL_259:
        unint64_t v180 = re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf);
        unint64_t v181 = v180 % v175;
        uint64_t v182 = *(unsigned int *)(v176 + 4 * v181);
        if (v182 != 0x7FFFFFFF)
        {
          uint64_t v183 = v402;
          do
          {
            uint64_t v184 = v183 + (v182 << 7);
            if (re::DynamicString::operator==(v184 + 16, (uint64_t)buf)) {
              goto LABEL_271;
            }
            uint64_t v182 = *(_DWORD *)(v184 + 8) & 0x7FFFFFFF;
          }
          while (v182 != 0x7FFFFFFF);
        }
LABEL_265:
        uint64_t v185 = v404;
        if (v404 == 0x7FFFFFFF)
        {
          uint64_t v185 = v403;
          unsigned int v186 = v403;
          if (v403 == DWORD2(v402))
          {
            re::HashTable<re::DynamicString,re::DebugMapping,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v401, 2 * HIDWORD(v402));
            unsigned int v186 = v403;
            unint64_t v181 = v180 % DWORD2(v402);
          }
          unsigned int v403 = v186 + 1;
          uint64_t v187 = v402;
          int v188 = *(_DWORD *)(v402 + (v185 << 7) + 8);
        }
        else
        {
          uint64_t v187 = v402;
          int v188 = *(_DWORD *)(v402 + ((unint64_t)v404 << 7) + 8);
          LODWORD(v40re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v188 & 0x7FFFFFFF;
        }
        uint64_t v189 = v187 + (v185 << 7);
        *(_DWORD *)(v189 + 8) = v188 | 0x80000000;
        uint64_t v190 = *((void *)&v401 + 1);
        *(_DWORD *)(v189 + 8) = *(_DWORD *)(*((void *)&v401 + 1) + 4 * v181) | 0x80000000;
        *(void *)uint64_t v189 = v180;
        re::DynamicString::DynamicString((re::DynamicString *)(v189 + 16), (const re::DynamicString *)buf);
        re::DynamicString::DynamicString((re::DynamicString *)(v189 + 48), (const re::DynamicString *)buf);
        re::HashTable<re::DynamicString,int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v189 + 80, (uint64_t)&v414);
        *(_DWORD *)(v190 + 4 * v18re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v185;
        ++HIDWORD(v402);
        ++HIDWORD(v404);
        goto LABEL_271;
      }
      uint64_t v178 = v402;
      while (1)
      {
        uint64_t v179 = v178 + (v177 << 7);
        if (re::DynamicString::operator==(v179 + 16, (uint64_t)buf)) {
          break;
        }
        uint64_t v177 = *(_DWORD *)(v179 + 8) & 0x7FFFFFFF;
        if (v177 == 0x7FFFFFFF) {
          goto LABEL_259;
        }
      }
      uint64_t v192 = *(unsigned int *)(v176 + 4 * (re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf) % v175));
      if (v192 == 0x7FFFFFFF)
      {
        uint64_t v193 = 0x7FFFFFFFLL;
      }
      else
      {
        do
        {
          uint64_t v194 = v178 + (v192 << 7);
          BOOL v195 = re::DynamicString::operator==(v194 + 16, (uint64_t)buf);
          uint64_t v193 = v192;
          if (v195) {
            break;
          }
          uint64_t v192 = *(_DWORD *)(v194 + 8) & 0x7FFFFFFF;
          uint64_t v193 = 0x7FFFFFFFLL;
        }
        while (v192 != 0x7FFFFFFF);
      }
      int v196 = v416;
      if (v416)
      {
        uint64_t v197 = 0;
        uint64_t v198 = (int *)(v415 + 8);
        while (1)
        {
          int v199 = *v198;
          v198 += 14;
          if (v199 < 0) {
            break;
          }
          if (v416 == ++v197)
          {
            LODWORD(v19re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v416;
            break;
          }
        }
      }
      else
      {
        LODWORD(v19re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = 0;
      }
      if (v416 != v197)
      {
        uint64_t v200 = v178 + (v193 << 7) + 80;
        uint64_t v201 = v197;
        uint64_t v202 = v415;
        do
        {
          re::HashTable<re::DynamicString,int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace<int &>(v200, (re::DynamicString *)(v202 + 56 * v201 + 16), (_DWORD *)(v202 + 56 * v201 + 48));
          uint64_t v202 = v415;
          if (v416 <= (int)v197 + 1) {
            int v203 = v197 + 1;
          }
          else {
            int v203 = v416;
          }
          int v204 = v197;
          while (1)
          {
            uint64_t v201 = (v204 + 1);
            if (v203 - 1 == v204) {
              break;
            }
            ++v204;
            LODWORD(v19re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v201;
            if ((*(_DWORD *)(v415 + 56 * v201 + 8) & 0x80000000) != 0) {
              goto LABEL_296;
            }
          }
          LODWORD(v19re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v203;
LABEL_296:
          ;
        }
        while (v196 != v197);
      }
LABEL_271:
      double v191 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v414);
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(double))(**(void **)buf + 40))(v191);
      }
      uint64_t v172 = (const re::DynamicString *)((char *)v172 + 80);
      if (v172 != v173) {
        continue;
      }
      break;
    }
    long long v154 = v384;
    uint64_t v155 = *v384;
LABEL_298:
    uint64_t v205 = *(void *)(v155 + 664);
    if (!v205) {
      goto LABEL_316;
    }
    double v206 = *(const re::MaterialTechniqueQualityLevelSetData **)(v155 + 680);
    unint64_t v207 = (const re::MaterialTechniqueQualityLevelSetData *)((char *)v206 + 104 * v205);
    while (2)
    {
      re::MaterialTechniqueQualityLevelSetData::MaterialTechniqueQualityLevelSetData((re::MaterialTechniqueQualityLevelSetData *)buf, v206);
      unint64_t v208 = re::Hash<re::DynamicString>::operator()((uint64_t)v424, (uint64_t)buf);
      unint64_t v209 = v208;
      if (!(void)v397)
      {
        unint64_t v210 = 0;
LABEL_307:
        unsigned int v213 = v400;
        if (v400 == 0x7FFFFFFF)
        {
          unsigned int v213 = v399;
          unsigned int v214 = v399;
          if (v399 == DWORD2(v398))
          {
            re::HashTable<re::DynamicString,re::MaterialTechniqueQualityLevelSetData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v397, 2 * HIDWORD(v398));
            unsigned int v214 = v399;
            unint64_t v210 = v209 % DWORD2(v398);
          }
          unsigned int v399 = v214 + 1;
          uint64_t v215 = v398;
          int v216 = *(_DWORD *)(v398 + 152 * v213 + 8);
        }
        else
        {
          uint64_t v215 = v398;
          int v216 = *(_DWORD *)(v398 + 152 * v400 + 8);
          LODWORD(v400) = v216 & 0x7FFFFFFF;
        }
        uint64_t v217 = v215 + 152 * v213;
        *(_DWORD *)(v217 + 8) = v216 | 0x80000000;
        uint64_t v218 = *((void *)&v397 + 1);
        *(_DWORD *)(v217 + 8) = *(_DWORD *)(*((void *)&v397 + 1) + 4 * v210) | 0x80000000;
        *(void *)uint64_t v217 = v209;
        re::DynamicString::DynamicString((re::DynamicString *)(v217 + 16), (const re::DynamicString *)buf);
        re::MaterialTechniqueQualityLevelSetData::MaterialTechniqueQualityLevelSetData((re::MaterialTechniqueQualityLevelSetData *)(v217 + 48), (const re::MaterialTechniqueQualityLevelSetData *)buf);
        *(_DWORD *)(v218 + 4 * v2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 10) = v213;
        ++HIDWORD(v398);
        goto LABEL_313;
      }
      unint64_t v210 = v208 % DWORD2(v398);
      uint64_t v211 = *(unsigned int *)(*((void *)&v397 + 1) + 4 * v210);
      if (v211 == 0x7FFFFFFF) {
        goto LABEL_307;
      }
      uint64_t v212 = v398;
      while (!re::DynamicString::operator==(v212 + 152 * v211 + 16, (uint64_t)buf))
      {
        uint64_t v211 = *(_DWORD *)(v212 + 152 * v211 + 8) & 0x7FFFFFFF;
        if (v211 == 0x7FFFFFFF) {
          goto LABEL_307;
        }
      }
      re::MaterialTechniqueQualityLevelSetData::~MaterialTechniqueQualityLevelSetData((const re::DynamicString **)(v212 + 152 * v211 + 48));
      re::MaterialTechniqueQualityLevelSetData::MaterialTechniqueQualityLevelSetData(v219, (const re::MaterialTechniqueQualityLevelSetData *)buf);
LABEL_313:
      ++HIDWORD(v400);
      re::MaterialTechniqueQualityLevelSetData::~MaterialTechniqueQualityLevelSetData((const re::DynamicString **)buf);
      double v206 = (const re::MaterialTechniqueQualityLevelSetData *)((char *)v206 + 104);
      if (v206 != v207) {
        continue;
      }
      break;
    }
    long long v154 = v384;
    uint64_t v155 = *v384;
LABEL_316:
    uint64_t v220 = *(unsigned int *)(v155 + 720);
    if (v220)
    {
      uint64_t v221 = 0;
      uint64_t v222 = (int *)(*(void *)(v155 + 704) + 8);
      while (1)
      {
        int v223 = *v222;
        v222 += 14;
        if (v223 < 0) {
          break;
        }
        if (v220 == ++v221)
        {
          LODWORD(v22re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = *(_DWORD *)(v155 + 720);
          break;
        }
      }
      long long v154 = v384;
    }
    else
    {
      LODWORD(v22re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = 0;
    }
    if (v220 != v221)
    {
      uint64_t v224 = v221;
      do
      {
        re::HashTable<re::DynamicString,int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace<int &>(v363, (re::DynamicString *)(*(void *)(v155 + 704) + 56 * v224 + 16), (_DWORD *)(*(void *)(v155 + 704) + 56 * v224 + 48));
        if (*(_DWORD *)(v155 + 720) <= (v221 + 1)) {
          int v225 = v221 + 1;
        }
        else {
          int v225 = *(_DWORD *)(v155 + 720);
        }
        int v226 = v221;
        while (1)
        {
          uint64_t v224 = (v226 + 1);
          if (v225 - 1 == v226) {
            break;
          }
          ++v226;
          LODWORD(v22re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v224;
          if ((*(_DWORD *)(*(void *)(v155 + 704) + 56 * v224 + 8) & 0x80000000) != 0) {
            goto LABEL_333;
          }
        }
        LODWORD(v22re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v225;
LABEL_333:
        ;
      }
      while (v220 != v221);
      long long v154 = v384;
      uint64_t v155 = *v384;
    }
    uint64_t v373 = *(unsigned int *)(v155 + 632);
    uint64_t v227 = 0;
    if (v373)
    {
      uint64_t v228 = (int *)(*(void *)(v155 + 616) + 8);
      while (1)
      {
        int v229 = *v228;
        v228 += 24;
        if (v229 < 0) {
          break;
        }
        if (v373 == ++v227)
        {
          LODWORD(v22re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = *(_DWORD *)(v155 + 632);
          break;
        }
      }
      long long v154 = v384;
    }
    if (v373 != v227)
    {
      uint64_t v231 = v227;
      while (1)
      {
        uint64_t v380 = *(void *)(v155 + 616);
        uint64_t v232 = v380 + 96 * v231;
        uint64_t v233 = (const re::DynamicString *)(v232 + 16);
        if (!re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(v365, v232 + 16))
        {
          unint64_t v234 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v232 + 16);
          if (!*v382
            || (uint64_t v235 = *(unsigned int *)(*((void *)v383 + 31) + 4 * (v234 % *((unsigned int *)v383 + 66))),
                v235 == 0x7FFFFFFF))
          {
LABEL_350:
            if (!re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(v358, v232 + 16))
            {
              unint64_t v259 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v232 + 16);
              if (!*v375
                || (uint64_t v260 = *(unsigned int *)(*((void *)v383 + 37) + 4 * (v259 % *((unsigned int *)v383 + 78))),
                    v260 == 0x7FFFFFFF))
              {
LABEL_386:
                unint64_t v262 = *re::pipelineLogObjects((re *)v259);
                if (os_log_type_enabled(v262, OS_LOG_TYPE_DEFAULT))
                {
                  if (*(unsigned char *)(v380 + 96 * v231 + 24)) {
                    uint64_t v263 = *(void *)(v380 + 96 * v231 + 32);
                  }
                  else {
                    uint64_t v263 = v232 + 25;
                  }
                  float v280 = v354;
                  if (*((void *)v355 + 1)) {
                    float v280 = (char *)*((void *)v355 + 2);
                  }
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v263;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v280;
                  _os_log_impl(&dword_233120000, v262, OS_LOG_TYPE_DEFAULT, "Ignoring property for unknown parameter (%s) in material (%s)", buf, 0x16u);
                }
                goto LABEL_373;
              }
              uint64_t v261 = *((void *)v383 + 38);
              while (1)
              {
                unint64_t v259 = re::DynamicString::operator==(v261 + 160 * v260 + 16, v232 + 16);
                if (v259) {
                  break;
                }
                uint64_t v260 = *(_DWORD *)(v261 + 160 * v260 + 8) & 0x7FFFFFFF;
                if (v260 == 0x7FFFFFFF) {
                  goto LABEL_386;
                }
              }
            }
          }
          else
          {
            uint64_t v236 = *((void *)v383 + 32);
            while (!re::DynamicString::operator==(v236 + 88 * v235 + 16, v232 + 16))
            {
              uint64_t v235 = *(_DWORD *)(v236 + 88 * v235 + 8) & 0x7FFFFFFF;
              if (v235 == 0x7FFFFFFF) {
                goto LABEL_350;
              }
            }
          }
        }
        long long v368 = (unsigned __int8 *)(v232 + 48);
        unint64_t v237 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v232 + 16);
        unsigned int v238 = v383;
        if (*v374)
        {
          uint64_t v239 = *(unsigned int *)(*((void *)v383 + 76) + 4 * (v237 % *((unsigned int *)v383 + 156)));
          if (v239 != 0x7FFFFFFF)
          {
            uint64_t v240 = *((void *)v383 + 77);
            while (!re::DynamicString::operator==(v240 + 96 * v239 + 16, (uint64_t)v233))
            {
              uint64_t v239 = *(_DWORD *)(v240 + 96 * v239 + 8) & 0x7FFFFFFF;
              if (v239 == 0x7FFFFFFF) {
                goto LABEL_356;
              }
            }
            unint64_t v264 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v233);
            if (*v374
              && (uint64_t v265 = *(unsigned int *)(*((void *)v383 + 76) + 4 * (v264 % *((unsigned int *)v383 + 156))),
                  v265 != 0x7FFFFFFF))
            {
              uint64_t v281 = *((void *)v383 + 77);
              while (!re::DynamicString::operator==(v281 + 96 * v265 + 16, (uint64_t)v233))
              {
                uint64_t v265 = *(_DWORD *)(v281 + 96 * v265 + 8) & 0x7FFFFFFF;
                uint64_t v266 = 0x7FFFFFFFLL;
                if (v265 == 0x7FFFFFFF) {
                  goto LABEL_392;
                }
              }
              uint64_t v266 = v265;
            }
            else
            {
              uint64_t v266 = 0x7FFFFFFFLL;
            }
LABEL_392:
            if (*v368) {
              re::Optional<re::DynamicString>::operator=((unsigned char *)(*((void *)v383 + 77) + 96 * v266 + 48), v368);
            }
            unint64_t v267 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v233);
            if (*v374)
            {
              uint64_t v268 = *(unsigned int *)(*((void *)v383 + 76) + 4 * (v267 % *((unsigned int *)v383 + 156)));
              uint64_t v269 = *((void *)v383 + 77);
              if (v268 != 0x7FFFFFFF)
              {
                while (!re::DynamicString::operator==(v269 + 96 * v268 + 16, (uint64_t)v233))
                {
                  uint64_t v268 = *(_DWORD *)(v269 + 96 * v268 + 8) & 0x7FFFFFFF;
                  if (v268 == 0x7FFFFFFF) {
                    goto LABEL_407;
                  }
                }
                goto LABEL_408;
              }
            }
            else
            {
              uint64_t v269 = *((void *)v383 + 77);
            }
LABEL_407:
            uint64_t v268 = 0x7FFFFFFFLL;
LABEL_408:
            if (*(unsigned char *)(v380 + 96 * v231 + 88))
            {
              uint64_t v277 = v269 + 96 * v268;
              int v279 = *(unsigned __int8 *)(v277 + 88);
              unsigned int v278 = (unsigned char *)(v277 + 88);
              if (!v279) {
                *unsigned int v278 = 1;
              }
              *(unsigned char *)(v269 + 96 * v268 + 89) = *(unsigned char *)(v380 + 96 * v231 + 89);
            }
            goto LABEL_373;
          }
        }
LABEL_356:
        unint64_t v241 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v233);
        if (*v374)
        {
          unint64_t v242 = *((unsigned int *)v383 + 156);
          unint64_t v243 = v241 % v242;
          uint64_t v244 = *(unsigned int *)(*((void *)v383 + 76) + 4 * (v241 % v242));
          if (v244 != 0x7FFFFFFF)
          {
            *(void *)uint64_t v360 = v241;
            unint64_t v245 = v241 % v242;
            uint64_t v246 = *((void *)v383 + 77);
            while (!re::DynamicString::operator==(v246 + 96 * v244 + 16, (uint64_t)v233))
            {
              uint64_t v244 = *(_DWORD *)(v246 + 96 * v244 + 8) & 0x7FFFFFFF;
              if (v244 == 0x7FFFFFFF)
              {
                unsigned int v238 = v383;
                unint64_t v243 = v245;
                unint64_t v241 = *(void *)v360;
                goto LABEL_363;
              }
            }
            uint64_t v270 = v246 + 96 * v244;
            int v272 = *(unsigned __int8 *)(v270 + 48);
            uint64_t v271 = v270 + 48;
            if (v272)
            {
              re::DynamicString::deinit((re::DynamicString *)(v271 + 8));
              uint64_t v246 = *((void *)v383 + 77);
            }
            uint64_t v273 = v246 + 96 * v244;
            int v274 = *v368;
            *(unsigned char *)(v273 + 48) = v274;
            uint64_t v275 = v273 + 48;
            if (v274) {
              re::DynamicString::DynamicString((re::DynamicString *)(v275 + 8), (const re::DynamicString *)(v368 + 8));
            }
            int v276 = *(unsigned __int8 *)(v380 + 96 * v231 + 88);
            *(unsigned char *)(v246 + 96 * v244 + 88) = v276;
            if (v276) {
              *(unsigned char *)(v246 + 96 * v244 + 89) = *(unsigned char *)(v380 + 96 * v231 + 89);
            }
            ++*((_DWORD *)v383 + 160);
            goto LABEL_373;
          }
        }
        else
        {
          unint64_t v243 = 0;
        }
LABEL_363:
        uint64_t v247 = *((unsigned int *)v238 + 159);
        if (v247 == 0x7FFFFFFF)
        {
          uint64_t v247 = *((unsigned int *)v238 + 158);
          int v248 = v247;
          if (v247 == *((_DWORD *)v238 + 156))
          {
            unint64_t v249 = v241;
            re::HashTable<re::DynamicString,re::OptionalMaterialParameterProperties,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)v374, 2 * *((_DWORD *)v238 + 157));
            unint64_t v241 = v249;
            unint64_t v243 = v249 % *((unsigned int *)v238 + 156);
            int v248 = *((_DWORD *)v238 + 158);
          }
          *((_DWORD *)v238 + 158) = v248 + 1;
          uint64_t v250 = *((void *)v238 + 77);
          int v251 = *(_DWORD *)(v250 + 96 * v247 + 8);
        }
        else
        {
          uint64_t v250 = *((void *)v238 + 77);
          int v251 = *(_DWORD *)(v250 + 96 * v247 + 8);
          *((_DWORD *)v238 + 159) = v251 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v250 + 96 * v247 + 8) = v251 | 0x80000000;
        *(void *)uint64_t v361 = v243;
        *(_DWORD *)(*((void *)v238 + 77) + 96 * v247 + 8) = *(_DWORD *)(*((void *)v238 + 77) + 96 * v247 + 8) & 0x80000000 | *(_DWORD *)(*((void *)v238 + 76) + 4 * v243);
        *(void *)(*((void *)v238 + 77) + 96 * v24re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v241;
        re::DynamicString::DynamicString((re::DynamicString *)(*((void *)v238 + 77) + 96 * v247 + 16), v233);
        uint64_t v252 = *((void *)v238 + 77);
        uint64_t v253 = v252 + 96 * v247;
        int v254 = *v368;
        *(unsigned char *)(v253 + 48) = v254;
        uint64_t v255 = v253 + 48;
        if (v254) {
          re::DynamicString::DynamicString((re::DynamicString *)(v255 + 8), (const re::DynamicString *)(v368 + 8));
        }
        int v256 = *(unsigned __int8 *)(v380 + 96 * v231 + 88);
        *(unsigned char *)(v252 + 96 * v247 + 88) = v256;
        if (v256) {
          *(unsigned char *)(v252 + 96 * v247 + 89) = *(unsigned char *)(v380 + 96 * v231 + 89);
        }
        *(_DWORD *)(*((void *)v238 + 76) + 4 * *(void *)v36re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 1) = v247;
        ++*((_DWORD *)v238 + 157);
        ++*((_DWORD *)v238 + 160);
LABEL_373:
        unsigned int v257 = *(_DWORD *)(v155 + 632);
        if (v257 <= (int)v227 + 1) {
          unsigned int v257 = v227 + 1;
        }
        while (1)
        {
          uint64_t v231 = (v227 + 1);
          if (v257 - 1 == v227) {
            break;
          }
          LODWORD(v22re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v227 + 1;
          unsigned int v258 = v231;
          if ((*(_DWORD *)(*(void *)(v155 + 616) + 96 * v231 + 8) & 0x80000000) != 0) {
            goto LABEL_379;
          }
        }
        unsigned int v258 = v257;
LABEL_379:
        LODWORD(v22re::HashTable<re::AssetHandle,re::DynamicArray<re::AnimationLibraryMeshMappingData>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 7) = v258;
        if (v373 == v258)
        {
          uint64_t v230 = v384;
          uint64_t v155 = *v384;
          goto LABEL_422;
        }
      }
    }
    uint64_t v230 = v154;
LABEL_422:
    re::appendOrDelete<re::DynamicString,re::DynamicString>(v352, v155 + 464);
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)buf);
    re::DynamicString::DynamicString((re::DynamicString *)v417, "Transparent", (re::Allocator *)buf);
    re::DynamicString::DynamicString((re::DynamicString *)&v385, "FadeOpaque", (re::Allocator *)buf);
    uint64_t v282 = *v230;
    if (*(_DWORD *)(*v230 + 540))
    {
      uint64_t v283 = *(unsigned int *)(v282 + 544);
      if (v283)
      {
        uint64_t v284 = 0;
        uint64_t v285 = (int *)(*(void *)(v282 + 528) + 8);
        while (1)
        {
          int v286 = *v285;
          v285 += 24;
          if (v286 < 0) {
            break;
          }
          if (v283 == ++v284)
          {
            LODWORD(v28re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = *(_DWORD *)(v282 + 544);
            break;
          }
        }
      }
      else
      {
        LODWORD(v28re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = 0;
      }
      if (v283 != v284)
      {
        uint64_t v287 = v284;
        int v369 = *(_DWORD *)(v282 + 544);
        do
        {
          uint64_t v288 = *(void *)(v282 + 528);
          uint64_t v289 = v288 + 96 * v287;
          uint64_t v290 = (re::DynamicString *)(v289 + 16);
          memset(v424, 0, 48);
          DWORD1(v424[2]) = 0x7FFFFFFF;
          unint64_t v291 = re::Hash<re::DynamicString>::operator()((uint64_t)&v387, v289 + 16);
          unint64_t v292 = v291;
          if (*v364)
          {
            unint64_t v293 = v291 % *((unsigned int *)v383 + 134);
            uint64_t v294 = *(unsigned int *)(*((void *)v383 + 65) + 4 * v293);
            if (v294 != 0x7FFFFFFF)
            {
              unint64_t v362 = v291 % *((unsigned int *)v383 + 134);
              uint64_t v295 = *((void *)v383 + 66);
              while (!re::DynamicString::operator==(v295 + 96 * v294 + 16, (uint64_t)v290))
              {
                uint64_t v294 = *(_DWORD *)(v295 + 96 * v294 + 8) & 0x7FFFFFFF;
                if (v294 == 0x7FFFFFFF)
                {
                  uint64_t v289 = v288 + 96 * v287;
                  LODWORD(v293) = v362;
                  goto LABEL_447;
                }
              }
              uint64_t v297 = v295 + 96 * v294 + 48;
              uint64_t v289 = v288 + 96 * v287;
              goto LABEL_448;
            }
            uint64_t v289 = v288 + 96 * v287;
          }
          else
          {
            LODWORD(v293) = 0;
          }
LABEL_447:
          unsigned int v296 = re::HashTable<re::DynamicString,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)v364, v293, v292, v290, (uint64_t *)v424);
          ++*((_DWORD *)v383 + 138);
          uint64_t v297 = *((void *)v383 + 66) + 96 * v296 + 48;
LABEL_448:
          uint64_t v298 = v289 + 48;
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v424);
          uint64_t v299 = v288 + 96 * v287;
          uint64_t v301 = *(void *)(v299 + 24);
          uint64_t v300 = *(const char **)(v299 + 32);
          if (v301) {
            uint64_t v302 = v300;
          }
          else {
            uint64_t v302 = (char *)v290 + 9;
          }
          if (!strcmp(v302, "Fade")
            && re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(v298, (uint64_t)v417)&& re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(v297, (uint64_t)&v385))
          {
            re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v297, (uint64_t)&v385);
          }
          re::append<re::DynamicString,re::DynamicString>(v297, v298);
          unsigned int v303 = *(_DWORD *)(v282 + 544);
          if (v303 <= (int)v284 + 1) {
            unsigned int v303 = v284 + 1;
          }
          while (1)
          {
            uint64_t v287 = (v284 + 1);
            if (v303 - 1 == v284) {
              break;
            }
            LODWORD(v28re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v284 + 1;
            unsigned int v304 = v287;
            if ((*(_DWORD *)(*(void *)(v282 + 528) + 96 * v287 + 8) & 0x80000000) != 0) {
              goto LABEL_461;
            }
          }
          unsigned int v304 = v303;
LABEL_461:
          LODWORD(v28re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4) = v304;
        }
        while (v369 != v304);
      }
    }
    if (v385 && (v386 & 1) != 0) {
      (*(void (**)(void))(*(void *)v385 + 40))();
    }
    uint64_t v5 = (uint64_t)v383;
    if (*(void *)v417 && (v417[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)v417 + 40))();
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)buf);
    uint64_t v8 = (uint64_t)v384;
  }
  while (v384 != *(uint64_t **)(v353 + 32));
  unsigned int v305 = v411;
  if (!v411) {
    goto LABEL_466;
  }
  uint64_t v306 = 0;
  long long v351 = (_DWORD *)(v410 + 8);
  while ((*v351 & 0x80000000) == 0)
  {
    v351 += 178;
    if (v411 == ++v306)
    {
      LODWORD(v306) = v411;
      break;
    }
  }
LABEL_467:
  if (v305 != v306)
  {
    uint64_t v307 = v306;
    uint64_t v308 = v410;
    unint64_t v309 = *(void *)(v5 + 400);
    do
    {
      if (v309 >= *(void *)(v5 + 392))
      {
        re::DynamicArray<re::MaterialTechniqueData>::growCapacity((void *)(v5 + 384), v309 + 1);
        unint64_t v309 = *(void *)(v5 + 400);
      }
      re::MaterialTechniqueData::MaterialTechniqueData((re::MaterialTechniqueData *)(*(void *)(v5 + 416) + 664 * v309), (const re::MaterialTechniqueData *)(v308 + 712 * v307 + 48));
      unint64_t v309 = *(void *)(v5 + 400) + 1;
      *(void *)(v5 + 400) = v309;
      ++*(_DWORD *)(v5 + 408);
      uint64_t v308 = v410;
      if (v411 <= (int)v306 + 1) {
        unsigned int v310 = v306 + 1;
      }
      else {
        unsigned int v310 = v411;
      }
      while (1)
      {
        uint64_t v307 = (v306 + 1);
        if (v310 - 1 == v306) {
          break;
        }
        LODWORD(v306) = v306 + 1;
        unsigned int v311 = v307;
        if ((*(_DWORD *)(v410 + 712 * v307 + 8) & 0x80000000) != 0) {
          goto LABEL_478;
        }
      }
      unsigned int v311 = v310;
LABEL_478:
      LODWORD(v306) = v311;
    }
    while (v305 != v311);
  }
  re::HashTable<re::DynamicString,re::MaterialTechniqueData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v409);
  if (*(void *)(v5 + 432) < (unint64_t)HIDWORD(v406)) {
    re::DynamicArray<re::MaterialTechniqueGroupData>::setCapacity((void *)(v5 + 424), HIDWORD(v406));
  }
  unsigned int v312 = v407;
  if (v407)
  {
    uint64_t v313 = 0;
    long long v314 = (int *)(v406 + 8);
    while (1)
    {
      int v315 = *v314;
      v314 += 30;
      if (v315 < 0) {
        break;
      }
      if (v407 == ++v313)
      {
        LODWORD(v3re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = v407;
        break;
      }
    }
  }
  else
  {
    LODWORD(v3re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = 0;
  }
  if (v407 != v313)
  {
    uint64_t v316 = v313;
    uint64_t v317 = v406;
    do
    {
      BOOL v318 = re::HashTable<re::DynamicString,re::MaterialTechniqueData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v409, v317 + 120 * v316 + 16);
      if (v318)
      {
        long long v319 = *re::pipelineLogObjects((re *)v318);
        if (os_log_type_enabled(v319, OS_LOG_TYPE_DEFAULT))
        {
          if (*(unsigned char *)(v317 + 120 * v316 + 24)) {
            uint64_t v320 = *(void *)(v317 + 120 * v316 + 32);
          }
          else {
            uint64_t v320 = v317 + 120 * v316 + 25;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v320;
          _os_log_impl(&dword_233120000, v319, OS_LOG_TYPE_DEFAULT, "Technique group \"%s\" has the same name as a technique. Skipping the group.", buf, 0xCu);
        }
      }
      else
      {
        unint64_t v321 = *((void *)v383 + 55);
        if (v321 >= *((void *)v383 + 54))
        {
          re::DynamicArray<re::MaterialTechniqueGroupData>::growCapacity((void *)(v5 + 424), v321 + 1);
          unint64_t v321 = *((void *)v383 + 55);
        }
        long long v322 = re::DynamicString::DynamicString((re::DynamicString *)(*((void *)v383 + 57) + 72 * v321), (const re::DynamicString *)(v317 + 120 * v316 + 48));
        re::DynamicArray<re::DynamicString>::DynamicArray((uint64_t)v322 + 32, (uint64_t *)(v317 + 120 * v316 + 80));
        ++*((void *)v383 + 55);
        ++*((_DWORD *)v383 + 112);
      }
      uint64_t v317 = v406;
      if (v407 <= (int)v313 + 1) {
        unsigned int v323 = v313 + 1;
      }
      else {
        unsigned int v323 = v407;
      }
      while (1)
      {
        uint64_t v316 = (v313 + 1);
        if (v323 - 1 == v313) {
          break;
        }
        LODWORD(v3re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = v313 + 1;
        unsigned int v324 = v316;
        if ((*(_DWORD *)(v406 + 120 * v316 + 8) & 0x80000000) != 0) {
          goto LABEL_505;
        }
      }
      unsigned int v324 = v323;
LABEL_505:
      LODWORD(v3re::FixedArray<re::DeformationBufferAllocator>::deinit((void *)this + 13) = v324;
    }
    while (v312 != v324);
  }
  re::HashTable<re::DynamicString,re::MaterialTechniqueGroupData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v405);
  unsigned int v325 = v403;
  if (v403)
  {
    uint64_t v326 = 0;
    char v327 = (int *)(v402 + 8);
    long long v328 = v383;
    while (1)
    {
      int v329 = *v327;
      v327 += 32;
      if (v329 < 0) {
        break;
      }
      if (v403 == ++v326)
      {
        LODWORD(v326) = v403;
        break;
      }
    }
  }
  else
  {
    LODWORD(v326) = 0;
    long long v328 = v383;
  }
  if (v403 != v326)
  {
    uint64_t v330 = v326;
    uint64_t v331 = v402;
    unint64_t v332 = *((void *)v328 + 72);
    do
    {
      if (v332 >= *((void *)v328 + 71))
      {
        re::DynamicArray<re::DebugMapping>::growCapacity((void *)v328 + 70, v332 + 1);
        unint64_t v332 = *((void *)v328 + 72);
      }
      uint64_t v333 = v331 + (v330 << 7);
      long long v334 = re::DynamicString::DynamicString((re::DynamicString *)(*((void *)v328 + 74) + 80 * v332), (const re::DynamicString *)(v333 + 48));
      re::HashTable<re::DynamicString,int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v334 + 32, v333 + 80);
      unint64_t v332 = *((void *)v328 + 72) + 1;
      *((void *)v328 + 72) = v332;
      ++*((_DWORD *)v328 + 146);
      uint64_t v331 = v402;
      if (v403 <= (int)v326 + 1) {
        unsigned int v335 = v326 + 1;
      }
      else {
        unsigned int v335 = v403;
      }
      while (1)
      {
        uint64_t v330 = (v326 + 1);
        if (v335 - 1 == v326) {
          break;
        }
        LODWORD(v326) = v326 + 1;
        unsigned int v336 = v330;
        if ((*(_DWORD *)(v402 + (v330 << 7) + 8) & 0x80000000) != 0) {
          goto LABEL_523;
        }
      }
      unsigned int v336 = v335;
LABEL_523:
      LODWORD(v326) = v336;
    }
    while (v325 != v336);
  }
  re::HashTable<re::DynamicString,re::DebugMapping,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v401);
  long long v337 = (void *)((char *)v328 + 648);
  if (*((void *)v328 + 82) < (unint64_t)HIDWORD(v398)) {
    re::DynamicArray<re::MaterialTechniqueQualityLevelSetData>::setCapacity((void *)v328 + 81, HIDWORD(v398));
  }
  unsigned int v338 = v399;
  if (v399)
  {
    uint64_t v339 = 0;
    long long v340 = (int *)(v398 + 8);
    while (1)
    {
      int v341 = *v340;
      v340 += 38;
      if (v341 < 0) {
        break;
      }
      if (v399 == ++v339)
      {
        LODWORD(v339) = v399;
        break;
      }
    }
  }
  else
  {
    LODWORD(v339) = 0;
  }
  if (v399 != v339)
  {
    uint64_t v342 = v339;
    uint64_t v343 = v398;
    do
    {
      BOOL v344 = re::HashTable<re::DynamicString,re::MaterialTechniqueData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v409, v343 + 152 * v342 + 16);
      if (v344)
      {
        long long v345 = *re::pipelineLogObjects((re *)v344);
        if (os_log_type_enabled(v345, OS_LOG_TYPE_DEFAULT))
        {
          if (*(unsigned char *)(v343 + 152 * v342 + 24)) {
            uint64_t v346 = *(void *)(v343 + 152 * v342 + 32);
          }
          else {
            uint64_t v346 = v343 + 152 * v342 + 25;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v346;
          _os_log_impl(&dword_233120000, v345, OS_LOG_TYPE_DEFAULT, "Technique group \"%s\" has the same name as a technique. Skipping the group.", buf, 0xCu);
        }
      }
      else
      {
        unint64_t v347 = *((void *)v383 + 83);
        if (v347 >= *((void *)v383 + 82))
        {
          re::DynamicArray<re::MaterialTechniqueQualityLevelSetData>::growCapacity(v337, v347 + 1);
          unint64_t v347 = *((void *)v383 + 83);
        }
        re::MaterialTechniqueQualityLevelSetData::MaterialTechniqueQualityLevelSetData((re::MaterialTechniqueQualityLevelSetData *)(*((void *)v383 + 85) + 104 * v347), (const re::MaterialTechniqueQualityLevelSetData *)(v343 + 152 * v342 + 48));
        ++*((void *)v383 + 83);
        ++*((_DWORD *)v383 + 168);
      }
      uint64_t v343 = v398;
      if (v399 <= (int)v339 + 1) {
        unsigned int v348 = v339 + 1;
      }
      else {
        unsigned int v348 = v399;
      }
      while (1)
      {
        uint64_t v342 = (v339 + 1);
        if (v348 - 1 == v339) {
          break;
        }
        LODWORD(v339) = v339 + 1;
        unsigned int v349 = v342;
        if ((*(_DWORD *)(v398 + 152 * v342 + 8) & 0x80000000) != 0) {
          goto LABEL_550;
        }
      }
      unsigned int v349 = v348;
LABEL_550:
      LODWORD(v339) = v349;
    }
    while (v338 != v349);
  }
  re::HashTable<re::DynamicString,re::MaterialTechniqueQualityLevelSetData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v397);
  re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v389);
  re::HashTable<re::DynamicString,re::DynamicArray<unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)__b);
  re::HashTable<re::DynamicString,re::MaterialTechniqueQualityLevelSetData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v397);
  re::HashTable<re::DynamicString,re::DebugMapping,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v401);
  re::HashTable<re::DynamicString,re::MaterialTechniqueGroupData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v405);
  re::HashTable<re::DynamicString,re::MaterialTechniqueData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v409);
  return v383;
}